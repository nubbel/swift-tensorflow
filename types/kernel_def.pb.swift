/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: tensorflow/core/framework/kernel_def.proto
 *
 */

import Foundation
import SwiftProtobuf


public struct Tensorflow_KernelDef: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_KernelDef"}
  public var protoMessageName: String {return "KernelDef"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "op": 1,
    "deviceType": 2,
    "constraint": 3,
    "hostMemoryArg": 4,
    "label": 5,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "op": 1,
    "device_type": 2,
    "constraint": 3,
    "host_memory_arg": 4,
    "label": 5,
  ]}

  public struct AttrConstraint: ProtobufGeneratedMessage {
    public var swiftClassName: String {return "Tensorflow_KernelDef.AttrConstraint"}
    public var protoMessageName: String {return "AttrConstraint"}
    public var protoPackageName: String {return "tensorflow"}
    public var jsonFieldNames: [String: Int] {return [
      "name": 1,
      "allowedValues": 2,
    ]}
    public var protoFieldNames: [String: Int] {return [
      "name": 1,
      "allowed_values": 2,
    ]}

    private class _StorageClass {
      typealias ProtobufExtendedMessage = Tensorflow_KernelDef.AttrConstraint
      var _name: String = ""
      var _allowedValues: Tensorflow_AttrValue? = nil

      init() {}

      func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
        let handled: Bool
        switch protoFieldNumber {
        case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_name)
        case 2: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_AttrValue.self, value: &_allowedValues)
        default:
          handled = false
        }
        return handled
      }

      func traverse(visitor: inout ProtobufVisitor) throws {
        if _name != "" {
          try visitor.visitSingularField(fieldType: ProtobufString.self, value: _name, protoFieldNumber: 1, protoFieldName: "name", jsonFieldName: "name", swiftFieldName: "name")
        }
        if let v = _allowedValues {
          try visitor.visitSingularMessageField(value: v, protoFieldNumber: 2, protoFieldName: "allowed_values", jsonFieldName: "allowedValues", swiftFieldName: "allowedValues")
        }
      }

      var isEmpty: Bool {
        if _name != "" {return false}
        if _allowedValues != nil {return false}
        return true
      }

      func isEqualTo(other: _StorageClass) -> Bool {
        if _name != other._name {return false}
        if _allowedValues != other._allowedValues {return false}
        return true
      }

      func copy() -> _StorageClass {
        let clone = _StorageClass()
        clone._name = _name
        clone._allowedValues = _allowedValues
        return clone
      }
    }

    private var _storage: _StorageClass?

    ///   Name of an attr from the Op.
    public var name: String {
      get {return _storage?._name ?? ""}
      set {_uniqueStorage()._name = newValue}
    }

    ///   A list of values that this kernel supports for this attr.
    ///   Like OpDef.AttrDef.allowed_values, except for kernels instead of Ops.
    public var allowedValues: Tensorflow_AttrValue {
      get {return _storage?._allowedValues ?? Tensorflow_AttrValue()}
      set {_uniqueStorage()._allowedValues = newValue}
    }

    public init() {}

    public init(name: String? = nil,
      allowedValues: Tensorflow_AttrValue? = nil)
    {
      let storage = _uniqueStorage()
      if let v = name {
        storage._name = v
      }
      storage._allowedValues = allowedValues
    }

    public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
    }

    public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
      try _storage?.traverse(visitor: &visitor)
    }

    public var _protoc_generated_isEmpty: Bool {return _storage?.isEmpty ?? true}

    public func _protoc_generated_isEqualTo(other: Tensorflow_KernelDef.AttrConstraint) -> Bool {
      if let s = _storage {
        if let os = other._storage {
          return s === os || s.isEqualTo(other: os)
        }
        return isEmpty // empty storage == nil storage
      } else if let os = other._storage {
        return os.isEmpty // nil storage == empty storage
      }
      return true // Both nil, both empty
    }

    private mutating func _uniqueStorage() -> _StorageClass {
      if _storage == nil {
        _storage = _StorageClass()
      } else if !isKnownUniquelyReferenced(&_storage) {
        _storage = _storage!.copy()
      }
      return _storage!
    }
  }

  ///   Must match the name of an Op.
  public var op: String = ""

  ///   Type of device this kernel runs on.
  public var deviceType: String = ""

  public var constraint: [Tensorflow_KernelDef.AttrConstraint] = []

  ///   Names of the Op's input_/output_args that reside in host memory
  ///   instead of device memory.
  public var hostMemoryArg: [String] = []

  ///   This allows experimental kernels to be registered for an op that
  ///   won't be used unless the user specifies a "_kernel" attr with
  ///   value matching this.
  public var label: String = ""

  public init() {}

  public init(op: String? = nil,
    deviceType: String? = nil,
    constraint: [Tensorflow_KernelDef.AttrConstraint] = [],
    hostMemoryArg: [String] = [],
    label: String? = nil)
  {
    if let v = op {
      self.op = v
    }
    if let v = deviceType {
      self.deviceType = v
    }
    if !constraint.isEmpty {
      self.constraint = constraint
    }
    if !hostMemoryArg.isEmpty {
      self.hostMemoryArg = hostMemoryArg
    }
    if let v = label {
      self.label = v
    }
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &op)
    case 2: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &deviceType)
    case 3: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_KernelDef.AttrConstraint.self, value: &constraint)
    case 4: handled = try setter.decodeRepeatedField(fieldType: ProtobufString.self, value: &hostMemoryArg)
    case 5: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &label)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if op != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: op, protoFieldNumber: 1, protoFieldName: "op", jsonFieldName: "op", swiftFieldName: "op")
    }
    if deviceType != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: deviceType, protoFieldNumber: 2, protoFieldName: "device_type", jsonFieldName: "deviceType", swiftFieldName: "deviceType")
    }
    if !constraint.isEmpty {
      try visitor.visitRepeatedMessageField(value: constraint, protoFieldNumber: 3, protoFieldName: "constraint", jsonFieldName: "constraint", swiftFieldName: "constraint")
    }
    if !hostMemoryArg.isEmpty {
      try visitor.visitRepeatedField(fieldType: ProtobufString.self, value: hostMemoryArg, protoFieldNumber: 4, protoFieldName: "host_memory_arg", jsonFieldName: "hostMemoryArg", swiftFieldName: "hostMemoryArg")
    }
    if label != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: label, protoFieldNumber: 5, protoFieldName: "label", jsonFieldName: "label", swiftFieldName: "label")
    }
  }

  public var _protoc_generated_isEmpty: Bool {
    if op != "" {return false}
    if deviceType != "" {return false}
    if !constraint.isEmpty {return false}
    if !hostMemoryArg.isEmpty {return false}
    if label != "" {return false}
    return true
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_KernelDef) -> Bool {
    if op != other.op {return false}
    if deviceType != other.deviceType {return false}
    if constraint != other.constraint {return false}
    if hostMemoryArg != other.hostMemoryArg {return false}
    if label != other.label {return false}
    return true
  }
}

/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: tensorflow/core/framework/versions.proto
 *
 */

import Foundation
import SwiftProtobuf


///   Version information for a piece of serialized data
///  
///   There are different types of versions for each type of data
///   (GraphDef, etc.), but they all have the same common shape
///   described here.
///  
///   Each consumer has "consumer" and "min_producer" versions (specified
///   elsewhere).  A consumer is allowed to consume this data if
///  
///     producer >= min_producer
///     consumer >= min_consumer
///     consumer not in bad_consumers
public struct Tensorflow_VersionDef: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_VersionDef"}
  public var protoMessageName: String {return "VersionDef"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "producer": 1,
    "minConsumer": 2,
    "badConsumers": 3,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "producer": 1,
    "min_consumer": 2,
    "bad_consumers": 3,
  ]}

  ///   The version of the code that produced this data.
  public var producer: Int32 = 0

  ///   Any consumer below this version is not allowed to consume this data.
  public var minConsumer: Int32 = 0

  ///   Specific consumer versions which are disallowed (e.g. due to bugs).
  public var badConsumers: [Int32] = []

  public init() {}

  public init(producer: Int32? = nil,
    minConsumer: Int32? = nil,
    badConsumers: [Int32] = [])
  {
    if let v = producer {
      self.producer = v
    }
    if let v = minConsumer {
      self.minConsumer = v
    }
    if !badConsumers.isEmpty {
      self.badConsumers = badConsumers
    }
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufInt32.self, value: &producer)
    case 2: handled = try setter.decodeSingularField(fieldType: ProtobufInt32.self, value: &minConsumer)
    case 3: handled = try setter.decodePackedField(fieldType: ProtobufInt32.self, value: &badConsumers)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if producer != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: producer, protoFieldNumber: 1, protoFieldName: "producer", jsonFieldName: "producer", swiftFieldName: "producer")
    }
    if minConsumer != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: minConsumer, protoFieldNumber: 2, protoFieldName: "min_consumer", jsonFieldName: "minConsumer", swiftFieldName: "minConsumer")
    }
    if !badConsumers.isEmpty {
      try visitor.visitPackedField(fieldType: ProtobufInt32.self, value: badConsumers, protoFieldNumber: 3, protoFieldName: "bad_consumers", jsonFieldName: "badConsumers", swiftFieldName: "badConsumers")
    }
  }

  public var _protoc_generated_isEmpty: Bool {
    if producer != 0 {return false}
    if minConsumer != 0 {return false}
    if !badConsumers.isEmpty {return false}
    return true
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_VersionDef) -> Bool {
    if producer != other.producer {return false}
    if minConsumer != other.minConsumer {return false}
    if badConsumers != other.badConsumers {return false}
    return true
  }
}

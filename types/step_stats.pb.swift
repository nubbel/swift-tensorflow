/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: tensorflow/core/framework/step_stats.proto
 *
 */

import Foundation
import SwiftProtobuf


//  TODO(tucker): The next 4 message defs are very similar to
//  the *LogEntry messages in profile.proto.  They should be
//  unified in one place.
public struct Tensorflow_AllocatorMemoryUsed: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_AllocatorMemoryUsed"}
  public var protoMessageName: String {return "AllocatorMemoryUsed"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "allocatorName": 1,
    "totalBytes": 2,
    "peakBytes": 3,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "allocator_name": 1,
    "total_bytes": 2,
    "peak_bytes": 3,
  ]}

  public var allocatorName: String = ""

  public var totalBytes: Int64 = 0

  public var peakBytes: Int64 = 0

  public init() {}

  public init(allocatorName: String? = nil,
    totalBytes: Int64? = nil,
    peakBytes: Int64? = nil)
  {
    if let v = allocatorName {
      self.allocatorName = v
    }
    if let v = totalBytes {
      self.totalBytes = v
    }
    if let v = peakBytes {
      self.peakBytes = v
    }
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &allocatorName)
    case 2: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &totalBytes)
    case 3: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &peakBytes)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if allocatorName != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: allocatorName, protoFieldNumber: 1, protoFieldName: "allocator_name", jsonFieldName: "allocatorName", swiftFieldName: "allocatorName")
    }
    if totalBytes != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: totalBytes, protoFieldNumber: 2, protoFieldName: "total_bytes", jsonFieldName: "totalBytes", swiftFieldName: "totalBytes")
    }
    if peakBytes != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: peakBytes, protoFieldNumber: 3, protoFieldName: "peak_bytes", jsonFieldName: "peakBytes", swiftFieldName: "peakBytes")
    }
  }

  public var _protoc_generated_isEmpty: Bool {
    if allocatorName != "" {return false}
    if totalBytes != 0 {return false}
    if peakBytes != 0 {return false}
    return true
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_AllocatorMemoryUsed) -> Bool {
    if allocatorName != other.allocatorName {return false}
    if totalBytes != other.totalBytes {return false}
    if peakBytes != other.peakBytes {return false}
    return true
  }
}

///   Output sizes recorded for a single execution of a graph node.
public struct Tensorflow_NodeOutput: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_NodeOutput"}
  public var protoMessageName: String {return "NodeOutput"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "slot": 1,
    "tensorDescription": 3,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "slot": 1,
    "tensor_description": 3,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_NodeOutput
    var _slot: Int32 = 0
    var _tensorDescription: Tensorflow_TensorDescription? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularField(fieldType: ProtobufInt32.self, value: &_slot)
      case 3: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_TensorDescription.self, value: &_tensorDescription)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if _slot != 0 {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: _slot, protoFieldNumber: 1, protoFieldName: "slot", jsonFieldName: "slot", swiftFieldName: "slot")
      }
      if let v = _tensorDescription {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 3, protoFieldName: "tensor_description", jsonFieldName: "tensorDescription", swiftFieldName: "tensorDescription")
      }
    }

    var isEmpty: Bool {
      if _slot != 0 {return false}
      if _tensorDescription != nil {return false}
      return true
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _slot != other._slot {return false}
      if _tensorDescription != other._tensorDescription {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._slot = _slot
      clone._tensorDescription = _tensorDescription
      return clone
    }
  }

  private var _storage: _StorageClass?

  public var slot: Int32 {
    get {return _storage?._slot ?? 0}
    set {_uniqueStorage()._slot = newValue}
  }

  public var tensorDescription: Tensorflow_TensorDescription {
    get {return _storage?._tensorDescription ?? Tensorflow_TensorDescription()}
    set {_uniqueStorage()._tensorDescription = newValue}
  }

  public init() {}

  public init(slot: Int32? = nil,
    tensorDescription: Tensorflow_TensorDescription? = nil)
  {
    let storage = _uniqueStorage()
    if let v = slot {
      storage._slot = v
    }
    storage._tensorDescription = tensorDescription
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage?.traverse(visitor: &visitor)
  }

  public var _protoc_generated_isEmpty: Bool {return _storage?.isEmpty ?? true}

  public func _protoc_generated_isEqualTo(other: Tensorflow_NodeOutput) -> Bool {
    if let s = _storage {
      if let os = other._storage {
        return s === os || s.isEqualTo(other: os)
      }
      return isEmpty // empty storage == nil storage
    } else if let os = other._storage {
      return os.isEmpty // nil storage == empty storage
    }
    return true // Both nil, both empty
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if _storage == nil {
      _storage = _StorageClass()
    } else if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage!.copy()
    }
    return _storage!
  }
}

///   Time/size stats recorded for a single execution of a graph node.
public struct Tensorflow_NodeExecStats: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_NodeExecStats"}
  public var protoMessageName: String {return "NodeExecStats"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "nodeName": 1,
    "allStartMicros": 2,
    "opStartRelMicros": 3,
    "opEndRelMicros": 4,
    "allEndRelMicros": 5,
    "memory": 6,
    "output": 7,
    "timelineLabel": 8,
    "scheduledMicros": 9,
    "threadId": 10,
    "referencedTensor": 11,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "node_name": 1,
    "all_start_micros": 2,
    "op_start_rel_micros": 3,
    "op_end_rel_micros": 4,
    "all_end_rel_micros": 5,
    "memory": 6,
    "output": 7,
    "timeline_label": 8,
    "scheduled_micros": 9,
    "thread_id": 10,
    "referenced_tensor": 11,
  ]}

  ///   TODO(tucker): Use some more compact form of node identity than
  ///   the full string name.  Either all processes should agree on a
  ///   global id (cost_id?) for each node, or we should use a hash of
  ///   the name.
  public var nodeName: String = ""

  public var allStartMicros: Int64 = 0

  public var opStartRelMicros: Int64 = 0

  public var opEndRelMicros: Int64 = 0

  public var allEndRelMicros: Int64 = 0

  public var memory: [Tensorflow_AllocatorMemoryUsed] = []

  public var output: [Tensorflow_NodeOutput] = []

  public var timelineLabel: String = ""

  public var scheduledMicros: Int64 = 0

  public var threadId: UInt32 = 0

  public var referencedTensor: [Tensorflow_AllocationDescription] = []

  public init() {}

  public init(nodeName: String? = nil,
    allStartMicros: Int64? = nil,
    opStartRelMicros: Int64? = nil,
    opEndRelMicros: Int64? = nil,
    allEndRelMicros: Int64? = nil,
    memory: [Tensorflow_AllocatorMemoryUsed] = [],
    output: [Tensorflow_NodeOutput] = [],
    timelineLabel: String? = nil,
    scheduledMicros: Int64? = nil,
    threadId: UInt32? = nil,
    referencedTensor: [Tensorflow_AllocationDescription] = [])
  {
    if let v = nodeName {
      self.nodeName = v
    }
    if let v = allStartMicros {
      self.allStartMicros = v
    }
    if let v = opStartRelMicros {
      self.opStartRelMicros = v
    }
    if let v = opEndRelMicros {
      self.opEndRelMicros = v
    }
    if let v = allEndRelMicros {
      self.allEndRelMicros = v
    }
    if !memory.isEmpty {
      self.memory = memory
    }
    if !output.isEmpty {
      self.output = output
    }
    if let v = timelineLabel {
      self.timelineLabel = v
    }
    if let v = scheduledMicros {
      self.scheduledMicros = v
    }
    if let v = threadId {
      self.threadId = v
    }
    if !referencedTensor.isEmpty {
      self.referencedTensor = referencedTensor
    }
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &nodeName)
    case 2: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &allStartMicros)
    case 3: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &opStartRelMicros)
    case 4: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &opEndRelMicros)
    case 5: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &allEndRelMicros)
    case 6: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_AllocatorMemoryUsed.self, value: &memory)
    case 7: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_NodeOutput.self, value: &output)
    case 8: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &timelineLabel)
    case 9: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &scheduledMicros)
    case 10: handled = try setter.decodeSingularField(fieldType: ProtobufUInt32.self, value: &threadId)
    case 11: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_AllocationDescription.self, value: &referencedTensor)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if nodeName != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: nodeName, protoFieldNumber: 1, protoFieldName: "node_name", jsonFieldName: "nodeName", swiftFieldName: "nodeName")
    }
    if allStartMicros != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: allStartMicros, protoFieldNumber: 2, protoFieldName: "all_start_micros", jsonFieldName: "allStartMicros", swiftFieldName: "allStartMicros")
    }
    if opStartRelMicros != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: opStartRelMicros, protoFieldNumber: 3, protoFieldName: "op_start_rel_micros", jsonFieldName: "opStartRelMicros", swiftFieldName: "opStartRelMicros")
    }
    if opEndRelMicros != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: opEndRelMicros, protoFieldNumber: 4, protoFieldName: "op_end_rel_micros", jsonFieldName: "opEndRelMicros", swiftFieldName: "opEndRelMicros")
    }
    if allEndRelMicros != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: allEndRelMicros, protoFieldNumber: 5, protoFieldName: "all_end_rel_micros", jsonFieldName: "allEndRelMicros", swiftFieldName: "allEndRelMicros")
    }
    if !memory.isEmpty {
      try visitor.visitRepeatedMessageField(value: memory, protoFieldNumber: 6, protoFieldName: "memory", jsonFieldName: "memory", swiftFieldName: "memory")
    }
    if !output.isEmpty {
      try visitor.visitRepeatedMessageField(value: output, protoFieldNumber: 7, protoFieldName: "output", jsonFieldName: "output", swiftFieldName: "output")
    }
    if timelineLabel != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: timelineLabel, protoFieldNumber: 8, protoFieldName: "timeline_label", jsonFieldName: "timelineLabel", swiftFieldName: "timelineLabel")
    }
    if scheduledMicros != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: scheduledMicros, protoFieldNumber: 9, protoFieldName: "scheduled_micros", jsonFieldName: "scheduledMicros", swiftFieldName: "scheduledMicros")
    }
    if threadId != 0 {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: threadId, protoFieldNumber: 10, protoFieldName: "thread_id", jsonFieldName: "threadId", swiftFieldName: "threadId")
    }
    if !referencedTensor.isEmpty {
      try visitor.visitRepeatedMessageField(value: referencedTensor, protoFieldNumber: 11, protoFieldName: "referenced_tensor", jsonFieldName: "referencedTensor", swiftFieldName: "referencedTensor")
    }
  }

  public var _protoc_generated_isEmpty: Bool {
    if nodeName != "" {return false}
    if allStartMicros != 0 {return false}
    if opStartRelMicros != 0 {return false}
    if opEndRelMicros != 0 {return false}
    if allEndRelMicros != 0 {return false}
    if !memory.isEmpty {return false}
    if !output.isEmpty {return false}
    if timelineLabel != "" {return false}
    if scheduledMicros != 0 {return false}
    if threadId != 0 {return false}
    if !referencedTensor.isEmpty {return false}
    return true
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_NodeExecStats) -> Bool {
    if nodeName != other.nodeName {return false}
    if allStartMicros != other.allStartMicros {return false}
    if opStartRelMicros != other.opStartRelMicros {return false}
    if opEndRelMicros != other.opEndRelMicros {return false}
    if allEndRelMicros != other.allEndRelMicros {return false}
    if memory != other.memory {return false}
    if output != other.output {return false}
    if timelineLabel != other.timelineLabel {return false}
    if scheduledMicros != other.scheduledMicros {return false}
    if threadId != other.threadId {return false}
    if referencedTensor != other.referencedTensor {return false}
    return true
  }
}

public struct Tensorflow_DeviceStepStats: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_DeviceStepStats"}
  public var protoMessageName: String {return "DeviceStepStats"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "device": 1,
    "nodeStats": 2,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "device": 1,
    "node_stats": 2,
  ]}

  public var device: String = ""

  public var nodeStats: [Tensorflow_NodeExecStats] = []

  public init() {}

  public init(device: String? = nil,
    nodeStats: [Tensorflow_NodeExecStats] = [])
  {
    if let v = device {
      self.device = v
    }
    if !nodeStats.isEmpty {
      self.nodeStats = nodeStats
    }
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &device)
    case 2: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_NodeExecStats.self, value: &nodeStats)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if device != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: device, protoFieldNumber: 1, protoFieldName: "device", jsonFieldName: "device", swiftFieldName: "device")
    }
    if !nodeStats.isEmpty {
      try visitor.visitRepeatedMessageField(value: nodeStats, protoFieldNumber: 2, protoFieldName: "node_stats", jsonFieldName: "nodeStats", swiftFieldName: "nodeStats")
    }
  }

  public var _protoc_generated_isEmpty: Bool {
    if device != "" {return false}
    if !nodeStats.isEmpty {return false}
    return true
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_DeviceStepStats) -> Bool {
    if device != other.device {return false}
    if nodeStats != other.nodeStats {return false}
    return true
  }
}

public struct Tensorflow_StepStats: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_StepStats"}
  public var protoMessageName: String {return "StepStats"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "devStats": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "dev_stats": 1,
  ]}

  public var devStats: [Tensorflow_DeviceStepStats] = []

  public init() {}

  public init(devStats: [Tensorflow_DeviceStepStats] = [])
  {
    if !devStats.isEmpty {
      self.devStats = devStats
    }
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_DeviceStepStats.self, value: &devStats)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if !devStats.isEmpty {
      try visitor.visitRepeatedMessageField(value: devStats, protoFieldNumber: 1, protoFieldName: "dev_stats", jsonFieldName: "devStats", swiftFieldName: "devStats")
    }
  }

  public var _protoc_generated_isEmpty: Bool {
    if !devStats.isEmpty {return false}
    return true
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_StepStats) -> Bool {
    if devStats != other.devStats {return false}
    return true
  }
}

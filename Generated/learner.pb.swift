/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: tensorflow/contrib/boosted_trees/proto/learner.proto
 *
 */

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _1: SwiftProtobuf.ProtobufAPIVersion_1 {}
  typealias Version = _1
}

/// Tree regularization config.
public struct Tensorflow_BoostedTrees_Learner_TreeRegularizationConfig: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".TreeRegularizationConfig"

  /// Classic L1/L2.
  public var l1: Float = 0

  public var l2: Float = 0

  /// Tree complexity penalizes overall model complexity effectively
  /// limiting how deep the tree can grow in regions with small gain.
  public var treeComplexity: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.l1)
      case 2: try decoder.decodeSingularFloatField(value: &self.l2)
      case 3: try decoder.decodeSingularFloatField(value: &self.treeComplexity)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.l1 != 0 {
      try visitor.visitSingularFloatField(value: self.l1, fieldNumber: 1)
    }
    if self.l2 != 0 {
      try visitor.visitSingularFloatField(value: self.l2, fieldNumber: 2)
    }
    if self.treeComplexity != 0 {
      try visitor.visitSingularFloatField(value: self.treeComplexity, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

/// Tree constraints config.
public struct Tensorflow_BoostedTrees_Learner_TreeConstraintsConfig: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".TreeConstraintsConfig"

  /// Maximum depth of the trees.
  public var maxTreeDepth: UInt32 = 0

  /// Min hessian weight per node.
  public var minNodeWeight: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.maxTreeDepth)
      case 2: try decoder.decodeSingularFloatField(value: &self.minNodeWeight)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxTreeDepth != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxTreeDepth, fieldNumber: 1)
    }
    if self.minNodeWeight != 0 {
      try visitor.visitSingularFloatField(value: self.minNodeWeight, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

/// LearningRateConfig describes all supported learning rate tuners.
public struct Tensorflow_BoostedTrees_Learner_LearningRateConfig: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".LearningRateConfig"

  public var tuner: OneOf_Tuner? {
    get {return _storage._tuner}
    set {_uniqueStorage()._tuner = newValue}
  }

  public var fixed: Tensorflow_BoostedTrees_Learner_LearningRateFixedConfig {
    get {
      if case .fixed(let v)? = _storage._tuner {return v}
      return Tensorflow_BoostedTrees_Learner_LearningRateFixedConfig()
    }
    set {_uniqueStorage()._tuner = .fixed(newValue)}
  }

  public var dropout: Tensorflow_BoostedTrees_Learner_LearningRateDropoutDrivenConfig {
    get {
      if case .dropout(let v)? = _storage._tuner {return v}
      return Tensorflow_BoostedTrees_Learner_LearningRateDropoutDrivenConfig()
    }
    set {_uniqueStorage()._tuner = .dropout(newValue)}
  }

  public var lineSearch: Tensorflow_BoostedTrees_Learner_LearningRateLineSearchConfig {
    get {
      if case .lineSearch(let v)? = _storage._tuner {return v}
      return Tensorflow_BoostedTrees_Learner_LearningRateLineSearchConfig()
    }
    set {_uniqueStorage()._tuner = .lineSearch(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Tuner: Equatable {
    case fixed(Tensorflow_BoostedTrees_Learner_LearningRateFixedConfig)
    case dropout(Tensorflow_BoostedTrees_Learner_LearningRateDropoutDrivenConfig)
    case lineSearch(Tensorflow_BoostedTrees_Learner_LearningRateLineSearchConfig)

    public static func ==(lhs: Tensorflow_BoostedTrees_Learner_LearningRateConfig.OneOf_Tuner, rhs: Tensorflow_BoostedTrees_Learner_LearningRateConfig.OneOf_Tuner) -> Bool {
      switch (lhs, rhs) {
      case (.fixed(let l), .fixed(let r)): return l == r
      case (.dropout(let l), .dropout(let r)): return l == r
      case (.lineSearch(let l), .lineSearch(let r)): return l == r
      default: return false
      }
    }
  }

  public init() {}

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1...3:
          if _storage._tuner != nil {
            try decoder.handleConflictingOneOf()
          }
          _storage._tuner = try Tensorflow_BoostedTrees_Learner_LearningRateConfig.OneOf_Tuner(byDecodingFrom: &decoder, fieldNumber: fieldNumber)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      try _storage._tuner?.traverse(visitor: &visitor)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass()
}

/// Config for a fixed learning rate.
public struct Tensorflow_BoostedTrees_Learner_LearningRateFixedConfig: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".LearningRateFixedConfig"

  public var learningRate: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.learningRate)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.learningRate != 0 {
      try visitor.visitSingularFloatField(value: self.learningRate, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

/// Config for a tuned learning rate.
public struct Tensorflow_BoostedTrees_Learner_LearningRateLineSearchConfig: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".LearningRateLineSearchConfig"

  /// Max learning rate. Must be strictly positive.
  public var maxLearningRate: Float = 0

  /// Number of learning rate values to consider between [0, max_learning_rate).
  public var numSteps: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.maxLearningRate)
      case 2: try decoder.decodeSingularInt32Field(value: &self.numSteps)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxLearningRate != 0 {
      try visitor.visitSingularFloatField(value: self.maxLearningRate, fieldNumber: 1)
    }
    if self.numSteps != 0 {
      try visitor.visitSingularInt32Field(value: self.numSteps, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

/// When we have a sequence of trees 1, 2, 3 ... n, these essentially represent
/// weights updates in functional space, and thus we can use averaging of weight
/// updates to achieve better performance. For example, we can say that our final
/// ensemble will be an average of ensembles of tree 1, and ensemble of tree 1
/// and tree 2 etc .. ensemble of all trees.
/// Note that this averaging will apply ONLY DURING PREDICTION. The training
/// stays the same.
public struct Tensorflow_BoostedTrees_Learner_AveragingConfig: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".AveragingConfig"

  public var config: Tensorflow_BoostedTrees_Learner_AveragingConfig.OneOf_Config? = nil

  public var averageLastNTrees: Float {
    get {
      if case .averageLastNTrees(let v)? = config {return v}
      return 0
    }
    set {config = .averageLastNTrees(newValue)}
  }

  /// Between 0 and 1. If set to 1.0, we are averaging ensembles of tree 1,
  /// ensemble of tree 1 and tree 2, etc ensemble of all trees. If set to 0.5,
  /// last half of the trees are averaged etc.
  public var averageLastPercentTrees: Float {
    get {
      if case .averageLastPercentTrees(let v)? = config {return v}
      return 0
    }
    set {config = .averageLastPercentTrees(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Config: Equatable {
    case averageLastNTrees(Float)
    /// Between 0 and 1. If set to 1.0, we are averaging ensembles of tree 1,
    /// ensemble of tree 1 and tree 2, etc ensemble of all trees. If set to 0.5,
    /// last half of the trees are averaged etc.
    case averageLastPercentTrees(Float)

    public static func ==(lhs: Tensorflow_BoostedTrees_Learner_AveragingConfig.OneOf_Config, rhs: Tensorflow_BoostedTrees_Learner_AveragingConfig.OneOf_Config) -> Bool {
      switch (lhs, rhs) {
      case (.averageLastNTrees(let l), .averageLastNTrees(let r)): return l == r
      case (.averageLastPercentTrees(let l), .averageLastPercentTrees(let r)): return l == r
      default: return false
      }
    }
  }

  public init() {}

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1, 2:
        if self.config != nil {
          try decoder.handleConflictingOneOf()
        }
        self.config = try Tensorflow_BoostedTrees_Learner_AveragingConfig.OneOf_Config(byDecodingFrom: &decoder, fieldNumber: fieldNumber)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try self.config?.traverse(visitor: &visitor)
    try unknownFields.traverse(visitor: &visitor)
  }
}

public struct Tensorflow_BoostedTrees_Learner_LearningRateDropoutDrivenConfig: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".LearningRateDropoutDrivenConfig"

  /// Probability of dropping each tree in an existing so far ensemble.
  public var dropoutProbability: Float = 0

  /// When trees are built after dropout happen, they don't "advance" to the
  /// optimal solution, they just rearrange the path. However you can still
  /// choose to skip dropout periodically, to allow a new tree that "advances"
  /// to be added.
  /// For example, if running for 200 steps with probability of dropout 1/100,
  /// you would expect the dropout to start happening for sure for all iterations
  /// after 100. However you can add probability_of_skipping_dropout of 0.1, this
  /// way iterations 100-200 will include approx 90 iterations of dropout and 10
  /// iterations of normal steps.Set it to 0 if you want just keep building
  /// the refinement trees after dropout kicks in.
  public var probabilityOfSkippingDropout: Float = 0

  /// Between 0 and 1.
  public var learningRate: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.dropoutProbability)
      case 2: try decoder.decodeSingularFloatField(value: &self.probabilityOfSkippingDropout)
      case 3: try decoder.decodeSingularFloatField(value: &self.learningRate)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.dropoutProbability != 0 {
      try visitor.visitSingularFloatField(value: self.dropoutProbability, fieldNumber: 1)
    }
    if self.probabilityOfSkippingDropout != 0 {
      try visitor.visitSingularFloatField(value: self.probabilityOfSkippingDropout, fieldNumber: 2)
    }
    if self.learningRate != 0 {
      try visitor.visitSingularFloatField(value: self.learningRate, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

public struct Tensorflow_BoostedTrees_Learner_LearnerConfig: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".LearnerConfig"

  /// Number of classes.
  public var numClasses: UInt32 {
    get {return _storage._numClasses}
    set {_uniqueStorage()._numClasses = newValue}
  }

  /// Fraction of features to consider in each tree sampled randomly
  /// from all available features.
  public var featureFraction: OneOf_FeatureFraction? {
    get {return _storage._featureFraction}
    set {_uniqueStorage()._featureFraction = newValue}
  }

  public var featureFractionPerTree: Float {
    get {
      if case .featureFractionPerTree(let v)? = _storage._featureFraction {return v}
      return 0
    }
    set {_uniqueStorage()._featureFraction = .featureFractionPerTree(newValue)}
  }

  public var featureFractionPerLevel: Float {
    get {
      if case .featureFractionPerLevel(let v)? = _storage._featureFraction {return v}
      return 0
    }
    set {_uniqueStorage()._featureFraction = .featureFractionPerLevel(newValue)}
  }

  /// Regularization.
  public var regularization: Tensorflow_BoostedTrees_Learner_TreeRegularizationConfig {
    get {return _storage._regularization ?? Tensorflow_BoostedTrees_Learner_TreeRegularizationConfig()}
    set {_uniqueStorage()._regularization = newValue}
  }
  public var hasRegularization: Bool {
    return _storage._regularization != nil
  }
  public mutating func clearRegularization() {
    _storage._regularization = nil
  }

  /// Constraints.
  public var constraints: Tensorflow_BoostedTrees_Learner_TreeConstraintsConfig {
    get {return _storage._constraints ?? Tensorflow_BoostedTrees_Learner_TreeConstraintsConfig()}
    set {_uniqueStorage()._constraints = newValue}
  }
  public var hasConstraints: Bool {
    return _storage._constraints != nil
  }
  public mutating func clearConstraints() {
    _storage._constraints = nil
  }

  /// Pruning.
  public var pruningMode: Tensorflow_BoostedTrees_Learner_LearnerConfig.PruningMode {
    get {return _storage._pruningMode}
    set {_uniqueStorage()._pruningMode = newValue}
  }

  /// Growing Mode.
  public var growingMode: Tensorflow_BoostedTrees_Learner_LearnerConfig.GrowingMode {
    get {return _storage._growingMode}
    set {_uniqueStorage()._growingMode = newValue}
  }

  /// Learning rate.
  public var learningRateTuner: Tensorflow_BoostedTrees_Learner_LearningRateConfig {
    get {return _storage._learningRateTuner ?? Tensorflow_BoostedTrees_Learner_LearningRateConfig()}
    set {_uniqueStorage()._learningRateTuner = newValue}
  }
  public var hasLearningRateTuner: Bool {
    return _storage._learningRateTuner != nil
  }
  public mutating func clearLearningRateTuner() {
    _storage._learningRateTuner = nil
  }

  /// Multi-class strategy.
  public var multiClassStrategy: Tensorflow_BoostedTrees_Learner_LearnerConfig.MultiClassStrategy {
    get {return _storage._multiClassStrategy}
    set {_uniqueStorage()._multiClassStrategy = newValue}
  }

  /// If you want to average the ensembles (for regularization), provide the
  /// config below.
  public var averagingConfig: Tensorflow_BoostedTrees_Learner_AveragingConfig {
    get {return _storage._averagingConfig ?? Tensorflow_BoostedTrees_Learner_AveragingConfig()}
    set {_uniqueStorage()._averagingConfig = newValue}
  }
  public var hasAveragingConfig: Bool {
    return _storage._averagingConfig != nil
  }
  public mutating func clearAveragingConfig() {
    _storage._averagingConfig = nil
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Fraction of features to consider in each tree sampled randomly
  /// from all available features.
  public enum OneOf_FeatureFraction: Equatable {
    case featureFractionPerTree(Float)
    case featureFractionPerLevel(Float)

    public static func ==(lhs: Tensorflow_BoostedTrees_Learner_LearnerConfig.OneOf_FeatureFraction, rhs: Tensorflow_BoostedTrees_Learner_LearnerConfig.OneOf_FeatureFraction) -> Bool {
      switch (lhs, rhs) {
      case (.featureFractionPerTree(let l), .featureFractionPerTree(let r)): return l == r
      case (.featureFractionPerLevel(let l), .featureFractionPerLevel(let r)): return l == r
      default: return false
      }
    }
  }

  public enum PruningMode: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case prePrune // = 0
    case postPrune // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .prePrune
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .prePrune
      case 1: self = .postPrune
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .prePrune: return 0
      case .postPrune: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum GrowingMode: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case wholeTree // = 0

    /// Layer by layer is only supported by the batch learner.
    case layerByLayer // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .wholeTree
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .wholeTree
      case 1: self = .layerByLayer
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .wholeTree: return 0
      case .layerByLayer: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum MultiClassStrategy: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case treePerClass // = 0
    case fullHessian // = 1
    case diagonalHessian // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .treePerClass
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .treePerClass
      case 1: self = .fullHessian
      case 2: self = .diagonalHessian
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .treePerClass: return 0
      case .fullHessian: return 1
      case .diagonalHessian: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt32Field(value: &_storage._numClasses)
        case 2, 3:
          if _storage._featureFraction != nil {
            try decoder.handleConflictingOneOf()
          }
          _storage._featureFraction = try Tensorflow_BoostedTrees_Learner_LearnerConfig.OneOf_FeatureFraction(byDecodingFrom: &decoder, fieldNumber: fieldNumber)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._regularization)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._constraints)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._learningRateTuner)
        case 8: try decoder.decodeSingularEnumField(value: &_storage._pruningMode)
        case 9: try decoder.decodeSingularEnumField(value: &_storage._growingMode)
        case 10: try decoder.decodeSingularEnumField(value: &_storage._multiClassStrategy)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._averagingConfig)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._numClasses != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._numClasses, fieldNumber: 1)
      }
      try _storage._featureFraction?.traverse(visitor: &visitor)
      if let v = _storage._regularization {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._constraints {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._learningRateTuner {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if _storage._pruningMode != Tensorflow_BoostedTrees_Learner_LearnerConfig.PruningMode.prePrune {
        try visitor.visitSingularEnumField(value: _storage._pruningMode, fieldNumber: 8)
      }
      if _storage._growingMode != Tensorflow_BoostedTrees_Learner_LearnerConfig.GrowingMode.wholeTree {
        try visitor.visitSingularEnumField(value: _storage._growingMode, fieldNumber: 9)
      }
      if _storage._multiClassStrategy != Tensorflow_BoostedTrees_Learner_LearnerConfig.MultiClassStrategy.treePerClass {
        try visitor.visitSingularEnumField(value: _storage._multiClassStrategy, fieldNumber: 10)
      }
      if let v = _storage._averagingConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass()
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tensorflow.boosted_trees.learner"

extension Tensorflow_BoostedTrees_Learner_TreeRegularizationConfig: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "l1"),
    2: .same(proto: "l2"),
    3: .standard(proto: "tree_complexity"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_BoostedTrees_Learner_TreeRegularizationConfig) -> Bool {
    if self.l1 != other.l1 {return false}
    if self.l2 != other.l2 {return false}
    if self.treeComplexity != other.treeComplexity {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_BoostedTrees_Learner_TreeConstraintsConfig: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_tree_depth"),
    2: .standard(proto: "min_node_weight"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_BoostedTrees_Learner_TreeConstraintsConfig) -> Bool {
    if self.maxTreeDepth != other.maxTreeDepth {return false}
    if self.minNodeWeight != other.minNodeWeight {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_BoostedTrees_Learner_LearningRateConfig: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fixed"),
    2: .same(proto: "dropout"),
    3: .standard(proto: "line_search"),
  ]

  fileprivate class _StorageClass {
    var _tuner: Tensorflow_BoostedTrees_Learner_LearningRateConfig.OneOf_Tuner?

    init() {}

    init(copying source: _StorageClass) {
      _tuner = source._tuner
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_BoostedTrees_Learner_LearningRateConfig) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_storage, other_storage) in
        if _storage._tuner != other_storage._tuner {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_BoostedTrees_Learner_LearningRateConfig.OneOf_Tuner {
  fileprivate init?<T: SwiftProtobuf.Decoder>(byDecodingFrom decoder: inout T, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1:
      var value: Tensorflow_BoostedTrees_Learner_LearningRateFixedConfig?
      try decoder.decodeSingularMessageField(value: &value)
      if let value = value {
        self = .fixed(value)
        return
      }
    case 2:
      var value: Tensorflow_BoostedTrees_Learner_LearningRateDropoutDrivenConfig?
      try decoder.decodeSingularMessageField(value: &value)
      if let value = value {
        self = .dropout(value)
        return
      }
    case 3:
      var value: Tensorflow_BoostedTrees_Learner_LearningRateLineSearchConfig?
      try decoder.decodeSingularMessageField(value: &value)
      if let value = value {
        self = .lineSearch(value)
        return
      }
    default:
      break
    }
    return nil
  }

  fileprivate func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self {
    case .fixed(let v):
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    case .dropout(let v):
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case .lineSearch(let v):
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
  }
}

extension Tensorflow_BoostedTrees_Learner_LearningRateFixedConfig: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "learning_rate"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_BoostedTrees_Learner_LearningRateFixedConfig) -> Bool {
    if self.learningRate != other.learningRate {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_BoostedTrees_Learner_LearningRateLineSearchConfig: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_learning_rate"),
    2: .standard(proto: "num_steps"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_BoostedTrees_Learner_LearningRateLineSearchConfig) -> Bool {
    if self.maxLearningRate != other.maxLearningRate {return false}
    if self.numSteps != other.numSteps {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_BoostedTrees_Learner_AveragingConfig: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "average_last_n_trees"),
    2: .standard(proto: "average_last_percent_trees"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_BoostedTrees_Learner_AveragingConfig) -> Bool {
    if self.config != other.config {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_BoostedTrees_Learner_AveragingConfig.OneOf_Config {
  fileprivate init?<T: SwiftProtobuf.Decoder>(byDecodingFrom decoder: inout T, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1:
      var value = Float()
      try decoder.decodeSingularFloatField(value: &value)
      self = .averageLastNTrees(value)
      return
    case 2:
      var value = Float()
      try decoder.decodeSingularFloatField(value: &value)
      self = .averageLastPercentTrees(value)
      return
    default:
      break
    }
    return nil
  }

  fileprivate func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self {
    case .averageLastNTrees(let v):
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    case .averageLastPercentTrees(let v):
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    }
  }
}

extension Tensorflow_BoostedTrees_Learner_LearningRateDropoutDrivenConfig: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dropout_probability"),
    2: .standard(proto: "probability_of_skipping_dropout"),
    3: .standard(proto: "learning_rate"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_BoostedTrees_Learner_LearningRateDropoutDrivenConfig) -> Bool {
    if self.dropoutProbability != other.dropoutProbability {return false}
    if self.probabilityOfSkippingDropout != other.probabilityOfSkippingDropout {return false}
    if self.learningRate != other.learningRate {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_BoostedTrees_Learner_LearnerConfig: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_classes"),
    2: .standard(proto: "feature_fraction_per_tree"),
    3: .standard(proto: "feature_fraction_per_level"),
    4: .same(proto: "regularization"),
    5: .same(proto: "constraints"),
    8: .standard(proto: "pruning_mode"),
    9: .standard(proto: "growing_mode"),
    6: .standard(proto: "learning_rate_tuner"),
    10: .standard(proto: "multi_class_strategy"),
    11: .standard(proto: "averaging_config"),
  ]

  fileprivate class _StorageClass {
    var _numClasses: UInt32 = 0
    var _featureFraction: Tensorflow_BoostedTrees_Learner_LearnerConfig.OneOf_FeatureFraction?
    var _regularization: Tensorflow_BoostedTrees_Learner_TreeRegularizationConfig? = nil
    var _constraints: Tensorflow_BoostedTrees_Learner_TreeConstraintsConfig? = nil
    var _pruningMode: Tensorflow_BoostedTrees_Learner_LearnerConfig.PruningMode = Tensorflow_BoostedTrees_Learner_LearnerConfig.PruningMode.prePrune
    var _growingMode: Tensorflow_BoostedTrees_Learner_LearnerConfig.GrowingMode = Tensorflow_BoostedTrees_Learner_LearnerConfig.GrowingMode.wholeTree
    var _learningRateTuner: Tensorflow_BoostedTrees_Learner_LearningRateConfig? = nil
    var _multiClassStrategy: Tensorflow_BoostedTrees_Learner_LearnerConfig.MultiClassStrategy = Tensorflow_BoostedTrees_Learner_LearnerConfig.MultiClassStrategy.treePerClass
    var _averagingConfig: Tensorflow_BoostedTrees_Learner_AveragingConfig? = nil

    init() {}

    init(copying source: _StorageClass) {
      _numClasses = source._numClasses
      _featureFraction = source._featureFraction
      _regularization = source._regularization
      _constraints = source._constraints
      _pruningMode = source._pruningMode
      _growingMode = source._growingMode
      _learningRateTuner = source._learningRateTuner
      _multiClassStrategy = source._multiClassStrategy
      _averagingConfig = source._averagingConfig
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_BoostedTrees_Learner_LearnerConfig) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_storage, other_storage) in
        if _storage._numClasses != other_storage._numClasses {return false}
        if _storage._featureFraction != other_storage._featureFraction {return false}
        if _storage._regularization != other_storage._regularization {return false}
        if _storage._constraints != other_storage._constraints {return false}
        if _storage._pruningMode != other_storage._pruningMode {return false}
        if _storage._growingMode != other_storage._growingMode {return false}
        if _storage._learningRateTuner != other_storage._learningRateTuner {return false}
        if _storage._multiClassStrategy != other_storage._multiClassStrategy {return false}
        if _storage._averagingConfig != other_storage._averagingConfig {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_BoostedTrees_Learner_LearnerConfig.OneOf_FeatureFraction {
  fileprivate init?<T: SwiftProtobuf.Decoder>(byDecodingFrom decoder: inout T, fieldNumber: Int) throws {
    switch fieldNumber {
    case 2:
      var value = Float()
      try decoder.decodeSingularFloatField(value: &value)
      self = .featureFractionPerTree(value)
      return
    case 3:
      var value = Float()
      try decoder.decodeSingularFloatField(value: &value)
      self = .featureFractionPerLevel(value)
      return
    default:
      break
    }
    return nil
  }

  fileprivate func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self {
    case .featureFractionPerTree(let v):
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    case .featureFractionPerLevel(let v):
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    }
  }
}

extension Tensorflow_BoostedTrees_Learner_LearnerConfig.PruningMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PRE_PRUNE"),
    1: .same(proto: "POST_PRUNE"),
  ]
}

extension Tensorflow_BoostedTrees_Learner_LearnerConfig.GrowingMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WHOLE_TREE"),
    1: .same(proto: "LAYER_BY_LAYER"),
  ]
}

extension Tensorflow_BoostedTrees_Learner_LearnerConfig.MultiClassStrategy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TREE_PER_CLASS"),
    1: .same(proto: "FULL_HESSIAN"),
    2: .same(proto: "DIAGONAL_HESSIAN"),
  ]
}

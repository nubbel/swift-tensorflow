/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: tensorflow/core/grappler/costs/op_performance_data.proto
 *
 */

// Copyright 2017 The TensorFlow Authors. All Rights Reserved.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.
//==============================================================================

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _1: SwiftProtobuf.ProtobufAPIVersion_1 {}
  typealias Version = _1
}

/// Description of an operation as well as the parameters expected to impact its
/// performance.
public struct Tensorflow_OpInfo: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".OpInfo"

  /// The operation name.  There may be custom parameters in attrs.
  public var op: String {
    get {return _storage._op}
    set {_uniqueStorage()._op = newValue}
  }

  /// Custom parameters impacting the behavior of the op.
  public var attr: Dictionary<String,Tensorflow_AttrValue> {
    get {return _storage._attr}
    set {_uniqueStorage()._attr = newValue}
  }

  public var inputs: [Tensorflow_OpInfo.TensorProperties] {
    get {return _storage._inputs}
    set {_uniqueStorage()._inputs = newValue}
  }

  public var device: Tensorflow_OpInfo.DeviceProperties {
    get {return _storage._device ?? Tensorflow_OpInfo.DeviceProperties()}
    set {_uniqueStorage()._device = newValue}
  }
  public var hasDevice: Bool {
    return _storage._device != nil
  }
  public mutating func clearDevice() {
    _storage._device = nil
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct TensorProperties: SwiftProtobuf.Message {
    public static let protoMessageName: String = Tensorflow_OpInfo.protoMessageName + ".TensorProperties"

    public var dtype: Tensorflow_DataType {
      get {return _storage._dtype}
      set {_uniqueStorage()._dtype = newValue}
    }

    public var shape: Tensorflow_TensorShapeProto {
      get {return _storage._shape ?? Tensorflow_TensorShapeProto()}
      set {_uniqueStorage()._shape = newValue}
    }
    public var hasShape: Bool {
      return _storage._shape != nil
    }
    public mutating func clearShape() {
      _storage._shape = nil
    }

    public var value: Tensorflow_TensorProto {
      get {return _storage._value ?? Tensorflow_TensorProto()}
      set {_uniqueStorage()._value = newValue}
    }
    public var hasValue: Bool {
      return _storage._value != nil
    }
    public mutating func clearValue() {
      _storage._value = nil
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      _ = _uniqueStorage()
      try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        while let fieldNumber = try decoder.nextFieldNumber() {
          switch fieldNumber {
          case 1: try decoder.decodeSingularEnumField(value: &_storage._dtype)
          case 2: try decoder.decodeSingularMessageField(value: &_storage._shape)
          case 3: try decoder.decodeSingularMessageField(value: &_storage._value)
          default: break
          }
        }
      }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        if _storage._dtype != Tensorflow_DataType.dtInvalid {
          try visitor.visitSingularEnumField(value: _storage._dtype, fieldNumber: 1)
        }
        if let v = _storage._shape {
          try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        }
        if let v = _storage._value {
          try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        }
      }
      try unknownFields.traverse(visitor: &visitor)
    }

    fileprivate var _storage = _StorageClass()
  }

  /// Input types, shapes and values if known.
  public struct DeviceProperties: SwiftProtobuf.Message {
    public static let protoMessageName: String = Tensorflow_OpInfo.protoMessageName + ".DeviceProperties"

    public var type: String = String()

    public var vendor: String = String()

    public var model: String = String()

    public var frequency: Int64 = 0

    public var numCores: Int64 = 0

    public var environment: Dictionary<String,String> = [:]

    public var numRegisters: Int64 = 0

    public var l1CacheSize: Int64 = 0

    public var l2CacheSize: Int64 = 0

    public var l3CacheSize: Int64 = 0

    public var sharedMemorySizePerMultiprocessor: Int64 = 0

    public var memorySize: Int64 = 0

    public var bandwidth: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &self.type)
        case 2: try decoder.decodeSingularStringField(value: &self.vendor)
        case 3: try decoder.decodeSingularStringField(value: &self.model)
        case 4: try decoder.decodeSingularInt64Field(value: &self.frequency)
        case 5: try decoder.decodeSingularInt64Field(value: &self.numCores)
        case 6: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.environment)
        case 7: try decoder.decodeSingularInt64Field(value: &self.numRegisters)
        case 8: try decoder.decodeSingularInt64Field(value: &self.l1CacheSize)
        case 9: try decoder.decodeSingularInt64Field(value: &self.l2CacheSize)
        case 10: try decoder.decodeSingularInt64Field(value: &self.l3CacheSize)
        case 11: try decoder.decodeSingularInt64Field(value: &self.sharedMemorySizePerMultiprocessor)
        case 12: try decoder.decodeSingularInt64Field(value: &self.memorySize)
        case 13: try decoder.decodeSingularInt64Field(value: &self.bandwidth)
        default: break
        }
      }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.type.isEmpty {
        try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
      }
      if !self.vendor.isEmpty {
        try visitor.visitSingularStringField(value: self.vendor, fieldNumber: 2)
      }
      if !self.model.isEmpty {
        try visitor.visitSingularStringField(value: self.model, fieldNumber: 3)
      }
      if self.frequency != 0 {
        try visitor.visitSingularInt64Field(value: self.frequency, fieldNumber: 4)
      }
      if self.numCores != 0 {
        try visitor.visitSingularInt64Field(value: self.numCores, fieldNumber: 5)
      }
      if !self.environment.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.environment, fieldNumber: 6)
      }
      if self.numRegisters != 0 {
        try visitor.visitSingularInt64Field(value: self.numRegisters, fieldNumber: 7)
      }
      if self.l1CacheSize != 0 {
        try visitor.visitSingularInt64Field(value: self.l1CacheSize, fieldNumber: 8)
      }
      if self.l2CacheSize != 0 {
        try visitor.visitSingularInt64Field(value: self.l2CacheSize, fieldNumber: 9)
      }
      if self.l3CacheSize != 0 {
        try visitor.visitSingularInt64Field(value: self.l3CacheSize, fieldNumber: 10)
      }
      if self.sharedMemorySizePerMultiprocessor != 0 {
        try visitor.visitSingularInt64Field(value: self.sharedMemorySizePerMultiprocessor, fieldNumber: 11)
      }
      if self.memorySize != 0 {
        try visitor.visitSingularInt64Field(value: self.memorySize, fieldNumber: 12)
      }
      if self.bandwidth != 0 {
        try visitor.visitSingularInt64Field(value: self.bandwidth, fieldNumber: 13)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  public init() {}

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._op)
        case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorflow_AttrValue>.self, value: &_storage._attr)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._inputs)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._device)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._op.isEmpty {
        try visitor.visitSingularStringField(value: _storage._op, fieldNumber: 1)
      }
      if !_storage._attr.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorflow_AttrValue>.self, value: _storage._attr, fieldNumber: 2)
      }
      if !_storage._inputs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._inputs, fieldNumber: 3)
      }
      if let v = _storage._device {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass()
}

/// Performance data for tensorflow operations
public struct Tensorflow_OpPerformance: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".OpPerformance"

  /// The op
  public var op: Tensorflow_OpInfo {
    get {return _storage._op ?? Tensorflow_OpInfo()}
    set {_uniqueStorage()._op = newValue}
  }
  public var hasOp: Bool {
    return _storage._op != nil
  }
  public mutating func clearOp() {
    _storage._op = nil
  }

  /// The node name (optional). Makes it easier to associate the performance data
  /// with a specific graph node.
  public var node: String {
    get {return _storage._node}
    set {_uniqueStorage()._node = newValue}
  }

  /// Temporary memory used by this node (in bytes).
  public var temporaryMemorySize: Int64 {
    get {return _storage._temporaryMemorySize}
    set {_uniqueStorage()._temporaryMemorySize = newValue}
  }

  /// Time it takes to run the op (in nanoseconds).
  public var computeCost: Int64 {
    get {return _storage._computeCost}
    set {_uniqueStorage()._computeCost = newValue}
  }

  /// Analytical compute cost (in nanoseconds).
  public var computeTime: Int64 {
    get {return _storage._computeTime}
    set {_uniqueStorage()._computeTime = newValue}
  }

  /// Analytical memory access cost (in nanoseconds).
  public var memoryTime: Int64 {
    get {return _storage._memoryTime}
    set {_uniqueStorage()._memoryTime = newValue}
  }

  /// Percentage of theoretical compute performance.
  public var computeEfficiency: Double {
    get {return _storage._computeEfficiency}
    set {_uniqueStorage()._computeEfficiency = newValue}
  }

  /// Percentage of theoretical memory performance.
  public var memoryEfficiency: Double {
    get {return _storage._memoryEfficiency}
    set {_uniqueStorage()._memoryEfficiency = newValue}
  }

  public var opMemory: Tensorflow_OpPerformance.OpMemory {
    get {return _storage._opMemory ?? Tensorflow_OpPerformance.OpMemory()}
    set {_uniqueStorage()._opMemory = newValue}
  }
  public var hasOpMemory: Bool {
    return _storage._opMemory != nil
  }
  public mutating func clearOpMemory() {
    _storage._opMemory = nil
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Memory usage data for a tensorflow operation.
  public struct OpMemory: SwiftProtobuf.Message {
    public static let protoMessageName: String = Tensorflow_OpPerformance.protoMessageName + ".OpMemory"

    /// The output information may have memory usage and output shapes.
    public var outputMemory: [Int64] = []

    /// Temporary memory allocated by this node.
    public var hostTempMemory: Int64 = 0

    public var deviceTempMemory: Int64 = 0

    /// The persisted_memory doesn't include outputs.
    public var hostPersistentMemory: Int64 = 0

    public var devicePersistentMemory: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedInt64Field(value: &self.outputMemory)
        case 2: try decoder.decodeSingularInt64Field(value: &self.hostTempMemory)
        case 3: try decoder.decodeSingularInt64Field(value: &self.deviceTempMemory)
        case 4: try decoder.decodeSingularInt64Field(value: &self.hostPersistentMemory)
        case 5: try decoder.decodeSingularInt64Field(value: &self.devicePersistentMemory)
        default: break
        }
      }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.outputMemory.isEmpty {
        try visitor.visitPackedInt64Field(value: self.outputMemory, fieldNumber: 1)
      }
      if self.hostTempMemory != 0 {
        try visitor.visitSingularInt64Field(value: self.hostTempMemory, fieldNumber: 2)
      }
      if self.deviceTempMemory != 0 {
        try visitor.visitSingularInt64Field(value: self.deviceTempMemory, fieldNumber: 3)
      }
      if self.hostPersistentMemory != 0 {
        try visitor.visitSingularInt64Field(value: self.hostPersistentMemory, fieldNumber: 4)
      }
      if self.devicePersistentMemory != 0 {
        try visitor.visitSingularInt64Field(value: self.devicePersistentMemory, fieldNumber: 5)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  public init() {}

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._op)
        case 2: try decoder.decodeSingularInt64Field(value: &_storage._temporaryMemorySize)
        case 3: try decoder.decodeSingularInt64Field(value: &_storage._computeCost)
        case 4: try decoder.decodeSingularDoubleField(value: &_storage._computeEfficiency)
        case 5: try decoder.decodeSingularStringField(value: &_storage._node)
        case 6: try decoder.decodeSingularInt64Field(value: &_storage._computeTime)
        case 7: try decoder.decodeSingularInt64Field(value: &_storage._memoryTime)
        case 8: try decoder.decodeSingularDoubleField(value: &_storage._memoryEfficiency)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._opMemory)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._op {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._temporaryMemorySize != 0 {
        try visitor.visitSingularInt64Field(value: _storage._temporaryMemorySize, fieldNumber: 2)
      }
      if _storage._computeCost != 0 {
        try visitor.visitSingularInt64Field(value: _storage._computeCost, fieldNumber: 3)
      }
      if _storage._computeEfficiency != 0 {
        try visitor.visitSingularDoubleField(value: _storage._computeEfficiency, fieldNumber: 4)
      }
      if !_storage._node.isEmpty {
        try visitor.visitSingularStringField(value: _storage._node, fieldNumber: 5)
      }
      if _storage._computeTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._computeTime, fieldNumber: 6)
      }
      if _storage._memoryTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._memoryTime, fieldNumber: 7)
      }
      if _storage._memoryEfficiency != 0 {
        try visitor.visitSingularDoubleField(value: _storage._memoryEfficiency, fieldNumber: 8)
      }
      if let v = _storage._opMemory {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass()
}

/// A collection of OpPerformance data points.
public struct Tensorflow_OpPerformanceList: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".OpPerformanceList"

  public var opPerformance: [Tensorflow_OpPerformance] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.opPerformance)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.opPerformance.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.opPerformance, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tensorflow"

extension Tensorflow_OpInfo: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "op"),
    2: .same(proto: "attr"),
    3: .same(proto: "inputs"),
    4: .same(proto: "device"),
  ]

  fileprivate class _StorageClass {
    var _op: String = String()
    var _attr: Dictionary<String,Tensorflow_AttrValue> = [:]
    var _inputs: [Tensorflow_OpInfo.TensorProperties] = []
    var _device: Tensorflow_OpInfo.DeviceProperties? = nil

    init() {}

    init(copying source: _StorageClass) {
      _op = source._op
      _attr = source._attr
      _inputs = source._inputs
      _device = source._device
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_OpInfo) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_storage, other_storage) in
        if _storage._op != other_storage._op {return false}
        if _storage._attr != other_storage._attr {return false}
        if _storage._inputs != other_storage._inputs {return false}
        if _storage._device != other_storage._device {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_OpInfo.TensorProperties: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dtype"),
    2: .same(proto: "shape"),
    3: .same(proto: "value"),
  ]

  fileprivate class _StorageClass {
    var _dtype: Tensorflow_DataType = Tensorflow_DataType.dtInvalid
    var _shape: Tensorflow_TensorShapeProto? = nil
    var _value: Tensorflow_TensorProto? = nil

    init() {}

    init(copying source: _StorageClass) {
      _dtype = source._dtype
      _shape = source._shape
      _value = source._value
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_OpInfo.TensorProperties) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_storage, other_storage) in
        if _storage._dtype != other_storage._dtype {return false}
        if _storage._shape != other_storage._shape {return false}
        if _storage._value != other_storage._value {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_OpInfo.DeviceProperties: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "vendor"),
    3: .same(proto: "model"),
    4: .same(proto: "frequency"),
    5: .standard(proto: "num_cores"),
    6: .same(proto: "environment"),
    7: .standard(proto: "num_registers"),
    8: .standard(proto: "l1_cache_size"),
    9: .standard(proto: "l2_cache_size"),
    10: .standard(proto: "l3_cache_size"),
    11: .standard(proto: "shared_memory_size_per_multiprocessor"),
    12: .standard(proto: "memory_size"),
    13: .same(proto: "bandwidth"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_OpInfo.DeviceProperties) -> Bool {
    if self.type != other.type {return false}
    if self.vendor != other.vendor {return false}
    if self.model != other.model {return false}
    if self.frequency != other.frequency {return false}
    if self.numCores != other.numCores {return false}
    if self.environment != other.environment {return false}
    if self.numRegisters != other.numRegisters {return false}
    if self.l1CacheSize != other.l1CacheSize {return false}
    if self.l2CacheSize != other.l2CacheSize {return false}
    if self.l3CacheSize != other.l3CacheSize {return false}
    if self.sharedMemorySizePerMultiprocessor != other.sharedMemorySizePerMultiprocessor {return false}
    if self.memorySize != other.memorySize {return false}
    if self.bandwidth != other.bandwidth {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_OpPerformance: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "op"),
    5: .same(proto: "node"),
    2: .standard(proto: "temporary_memory_size"),
    3: .standard(proto: "compute_cost"),
    6: .standard(proto: "compute_time"),
    7: .standard(proto: "memory_time"),
    4: .standard(proto: "compute_efficiency"),
    8: .standard(proto: "memory_efficiency"),
    9: .standard(proto: "op_memory"),
  ]

  fileprivate class _StorageClass {
    var _op: Tensorflow_OpInfo? = nil
    var _node: String = String()
    var _temporaryMemorySize: Int64 = 0
    var _computeCost: Int64 = 0
    var _computeTime: Int64 = 0
    var _memoryTime: Int64 = 0
    var _computeEfficiency: Double = 0
    var _memoryEfficiency: Double = 0
    var _opMemory: Tensorflow_OpPerformance.OpMemory? = nil

    init() {}

    init(copying source: _StorageClass) {
      _op = source._op
      _node = source._node
      _temporaryMemorySize = source._temporaryMemorySize
      _computeCost = source._computeCost
      _computeTime = source._computeTime
      _memoryTime = source._memoryTime
      _computeEfficiency = source._computeEfficiency
      _memoryEfficiency = source._memoryEfficiency
      _opMemory = source._opMemory
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_OpPerformance) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_storage, other_storage) in
        if _storage._op != other_storage._op {return false}
        if _storage._node != other_storage._node {return false}
        if _storage._temporaryMemorySize != other_storage._temporaryMemorySize {return false}
        if _storage._computeCost != other_storage._computeCost {return false}
        if _storage._computeTime != other_storage._computeTime {return false}
        if _storage._memoryTime != other_storage._memoryTime {return false}
        if _storage._computeEfficiency != other_storage._computeEfficiency {return false}
        if _storage._memoryEfficiency != other_storage._memoryEfficiency {return false}
        if _storage._opMemory != other_storage._opMemory {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_OpPerformance.OpMemory: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "output_memory"),
    2: .standard(proto: "host_temp_memory"),
    3: .standard(proto: "device_temp_memory"),
    4: .standard(proto: "host_persistent_memory"),
    5: .standard(proto: "device_persistent_memory"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_OpPerformance.OpMemory) -> Bool {
    if self.outputMemory != other.outputMemory {return false}
    if self.hostTempMemory != other.hostTempMemory {return false}
    if self.deviceTempMemory != other.deviceTempMemory {return false}
    if self.hostPersistentMemory != other.hostPersistentMemory {return false}
    if self.devicePersistentMemory != other.devicePersistentMemory {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_OpPerformanceList: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "op_performance"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_OpPerformanceList) -> Bool {
    if self.opPerformance != other.opPerformance {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

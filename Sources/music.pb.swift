// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: protobuf/music.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2016 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////////

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A message containing a symbolic music sequence. The design is largely
/// based on MIDI but it should be able to represent any music sequence.
/// For details see https://www.midi.org/specifications.
/// Note that repeated fields in this proto are not guaranteed to be sorted
/// by time.
/// Next tag: 18
public struct Tensorflow_Magenta_NoteSequence: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".NoteSequence"

  /// Unique id.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// The path of the file relative to the root of the collection.
  public var filename: String {
    get {return _storage._filename}
    set {_uniqueStorage()._filename = newValue}
  }

  /// The collection from which the file comes. This can be shorthand e.g.
  /// "bach". One purpose is to allow for easy selection of all or some files
  /// from a particular source.
  public var collectionName: String {
    get {return _storage._collectionName}
    set {_uniqueStorage()._collectionName = newValue}
  }

  /// MIDI ticks per quarter note, also known as resolution or PPQ ("pulses per
  /// quarter").
  /// There is no widely-used default. A default of 220 is assumed per the choice
  /// made in third_party/py/pretty_midi.
  public var ticksPerQuarter: Int32 {
    get {return _storage._ticksPerQuarter}
    set {_uniqueStorage()._ticksPerQuarter = newValue}
  }

  /// Lacking a time signature, 4/4 is assumed per MIDI standard.
  public var timeSignatures: [Tensorflow_Magenta_NoteSequence.TimeSignature] {
    get {return _storage._timeSignatures}
    set {_uniqueStorage()._timeSignatures = newValue}
  }

  /// Lacking a key signature, C Major is assumed per MIDI standard.
  public var keySignatures: [Tensorflow_Magenta_NoteSequence.KeySignature] {
    get {return _storage._keySignatures}
    set {_uniqueStorage()._keySignatures = newValue}
  }

  /// Lacking a tempo change, 120 qpm is assumed per MIDI standard.
  public var tempos: [Tensorflow_Magenta_NoteSequence.Tempo] {
    get {return _storage._tempos}
    set {_uniqueStorage()._tempos = newValue}
  }

  /// A Note combines a MIDI NoteOn and NoteOff into one event with duration.
  public var notes: [Tensorflow_Magenta_NoteSequence.Note] {
    get {return _storage._notes}
    set {_uniqueStorage()._notes = newValue}
  }

  /// The total time of the Sequence in seconds.
  public var totalTime: Double {
    get {return _storage._totalTime}
    set {_uniqueStorage()._totalTime = newValue}
  }

  /// The total time of the sequence in quantized steps.
  public var totalQuantizedSteps: Int64 {
    get {return _storage._totalQuantizedSteps}
    set {_uniqueStorage()._totalQuantizedSteps = newValue}
  }

  /// MIDI-specific events that are generally relevant for performance, metadata
  /// storage or re-synthesis but not for processing the music score.
  public var pitchBends: [Tensorflow_Magenta_NoteSequence.PitchBend] {
    get {return _storage._pitchBends}
    set {_uniqueStorage()._pitchBends = newValue}
  }

  public var controlChanges: [Tensorflow_Magenta_NoteSequence.ControlChange] {
    get {return _storage._controlChanges}
    set {_uniqueStorage()._controlChanges = newValue}
  }

  /// Score-related information about parts.
  public var partInfos: [Tensorflow_Magenta_NoteSequence.PartInfo] {
    get {return _storage._partInfos}
    set {_uniqueStorage()._partInfos = newValue}
  }

  /// Source-related information.
  public var sourceInfo: Tensorflow_Magenta_NoteSequence.SourceInfo {
    get {return _storage._sourceInfo ?? Tensorflow_Magenta_NoteSequence.SourceInfo()}
    set {_uniqueStorage()._sourceInfo = newValue}
  }
  /// Returns true if `sourceInfo` has been explicitly set.
  public var hasSourceInfo: Bool {return _storage._sourceInfo != nil}
  /// Clears the value of `sourceInfo`. Subsequent reads from it will return its default value.
  public mutating func clearSourceInfo() {_storage._sourceInfo = nil}

  /// Arbitrary textual annotations.
  public var textAnnotations: [Tensorflow_Magenta_NoteSequence.TextAnnotation] {
    get {return _storage._textAnnotations}
    set {_uniqueStorage()._textAnnotations = newValue}
  }

  /// Information about how/if this sequence was quantized.
  public var quantizationInfo: Tensorflow_Magenta_NoteSequence.QuantizationInfo {
    get {return _storage._quantizationInfo ?? Tensorflow_Magenta_NoteSequence.QuantizationInfo()}
    set {_uniqueStorage()._quantizationInfo = newValue}
  }
  /// Returns true if `quantizationInfo` has been explicitly set.
  public var hasQuantizationInfo: Bool {return _storage._quantizationInfo != nil}
  /// Clears the value of `quantizationInfo`. Subsequent reads from it will return its default value.
  public mutating func clearQuantizationInfo() {_storage._quantizationInfo = nil}

  /// Information about how this sequence was extracted from a larger source
  /// sequence (if that was the case).
  public var subsequenceInfo: Tensorflow_Magenta_NoteSequence.SubsequenceInfo {
    get {return _storage._subsequenceInfo ?? Tensorflow_Magenta_NoteSequence.SubsequenceInfo()}
    set {_uniqueStorage()._subsequenceInfo = newValue}
  }
  /// Returns true if `subsequenceInfo` has been explicitly set.
  public var hasSubsequenceInfo: Bool {return _storage._subsequenceInfo != nil}
  /// Clears the value of `subsequenceInfo`. Subsequent reads from it will return its default value.
  public mutating func clearSubsequenceInfo() {_storage._subsequenceInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Adopted from Musescore with start enum shifted to 0; see
  /// https://musescore.org/en/plugin-development/tonal-pitch-class-enum
  /// for details.
  public enum PitchName: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownPitchName // = 0
    case fFlatFlat // = 1
    case cFlatFlat // = 2
    case gFlatFlat // = 3
    case dFlatFlat // = 4
    case aFlatFlat // = 5
    case eFlatFlat // = 6
    case bFlatFlat // = 7
    case fFlat // = 8
    case cFlat // = 9
    case gFlat // = 10
    case dFlat // = 11
    case aFlat // = 12
    case eFlat // = 13
    case bFlat // = 14
    case f // = 15
    case c // = 16
    case g // = 17
    case d // = 18
    case a // = 19
    case e // = 20
    case b // = 21
    case fSharp // = 22
    case cSharp // = 23
    case gSharp // = 24
    case dSharp // = 25
    case aSharp // = 26
    case eSharp // = 27
    case bSharp // = 28
    case fSharpSharp // = 29
    case cSharpSharp // = 30
    case gSharpSharp // = 31
    case dSharpSharp // = 32
    case aSharpSharp // = 33
    case eSharpSharp // = 34
    case bSharpSharp // = 35
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownPitchName
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownPitchName
      case 1: self = .fFlatFlat
      case 2: self = .cFlatFlat
      case 3: self = .gFlatFlat
      case 4: self = .dFlatFlat
      case 5: self = .aFlatFlat
      case 6: self = .eFlatFlat
      case 7: self = .bFlatFlat
      case 8: self = .fFlat
      case 9: self = .cFlat
      case 10: self = .gFlat
      case 11: self = .dFlat
      case 12: self = .aFlat
      case 13: self = .eFlat
      case 14: self = .bFlat
      case 15: self = .f
      case 16: self = .c
      case 17: self = .g
      case 18: self = .d
      case 19: self = .a
      case 20: self = .e
      case 21: self = .b
      case 22: self = .fSharp
      case 23: self = .cSharp
      case 24: self = .gSharp
      case 25: self = .dSharp
      case 26: self = .aSharp
      case 27: self = .eSharp
      case 28: self = .bSharp
      case 29: self = .fSharpSharp
      case 30: self = .cSharpSharp
      case 31: self = .gSharpSharp
      case 32: self = .dSharpSharp
      case 33: self = .aSharpSharp
      case 34: self = .eSharpSharp
      case 35: self = .bSharpSharp
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownPitchName: return 0
      case .fFlatFlat: return 1
      case .cFlatFlat: return 2
      case .gFlatFlat: return 3
      case .dFlatFlat: return 4
      case .aFlatFlat: return 5
      case .eFlatFlat: return 6
      case .bFlatFlat: return 7
      case .fFlat: return 8
      case .cFlat: return 9
      case .gFlat: return 10
      case .dFlat: return 11
      case .aFlat: return 12
      case .eFlat: return 13
      case .bFlat: return 14
      case .f: return 15
      case .c: return 16
      case .g: return 17
      case .d: return 18
      case .a: return 19
      case .e: return 20
      case .b: return 21
      case .fSharp: return 22
      case .cSharp: return 23
      case .gSharp: return 24
      case .dSharp: return 25
      case .aSharp: return 26
      case .eSharp: return 27
      case .bSharp: return 28
      case .fSharpSharp: return 29
      case .cSharpSharp: return 30
      case .gSharpSharp: return 31
      case .dSharpSharp: return 32
      case .aSharpSharp: return 33
      case .eSharpSharp: return 34
      case .bSharpSharp: return 35
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Next tag: 15
  public struct Note: SwiftProtobuf.Message {
    public static let protoMessageName: String = Tensorflow_Magenta_NoteSequence.protoMessageName + ".Note"

    /// MIDI pitch; see en.wikipedia.org/wiki/MIDI_Tuning_Standard for details.
    public var pitch: Int32 = 0

    /// The notated pitch spelling in the score.
    public var pitchName: Tensorflow_Magenta_NoteSequence.PitchName = .unknownPitchName

    /// Velocity ranging between 0 and 127.
    public var velocity: Int32 = 0

    /// Start time in seconds.
    public var startTime: Double = 0

    /// Quantized start time in steps.
    public var quantizedStartStep: Int64 = 0

    /// End time in seconds.
    public var endTime: Double = 0

    /// Quantized end time in steps.
    public var quantizedEndStep: Int64 = 0

    /// Score-relative note length. E.g. a quarter note is 1/4.
    public var numerator: Int32 = 0

    public var denominator: Int32 = 0

    /// For MIDI source data, an instrument stores all events in a track having
    /// the same program and channel, as done by pretty-midi.
    public var instrument: Int32 = 0

    /// A program selects an instrument's sound.
    /// Note that the General MIDI documentation is 1-based, but this field is
    /// 0-based. So GM documents program 12 as vibraphone, but this field would
    /// be set to 11 for that instrument.
    /// See www.midi.org/specifications/item/gm-level-1-sound-set.
    public var program: Int32 = 0

    /// When true, the event is on an instrument that is a drum (MIDI channel 9).
    public var isDrum: Bool = false

    /// The part index if this came from a score. Otherwise, just 0.
    /// For example, a score may have separate parts for different instruments in
    /// an orchestra.
    /// If additional information is available about the part, a corresponding
    /// PartInfo should be defined with the same index.
    public var part: Int32 = 0

    /// The voice index if this came from a score. Otherwise, just 0.
    /// For example, within a part, there may be multiple voices (e.g., Soprano,
    /// Alto, Tenor, Bass).
    /// Note that while voices indexes must be unique within a part, they are not
    /// guaranteed to be unique across parts.
    public var voice: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt32Field(value: &self.pitch)
        case 2: try decoder.decodeSingularInt32Field(value: &self.velocity)
        case 3: try decoder.decodeSingularDoubleField(value: &self.startTime)
        case 4: try decoder.decodeSingularDoubleField(value: &self.endTime)
        case 5: try decoder.decodeSingularInt32Field(value: &self.numerator)
        case 6: try decoder.decodeSingularInt32Field(value: &self.denominator)
        case 7: try decoder.decodeSingularInt32Field(value: &self.instrument)
        case 8: try decoder.decodeSingularInt32Field(value: &self.program)
        case 9: try decoder.decodeSingularBoolField(value: &self.isDrum)
        case 10: try decoder.decodeSingularInt32Field(value: &self.part)
        case 11: try decoder.decodeSingularEnumField(value: &self.pitchName)
        case 12: try decoder.decodeSingularInt32Field(value: &self.voice)
        case 13: try decoder.decodeSingularInt64Field(value: &self.quantizedStartStep)
        case 14: try decoder.decodeSingularInt64Field(value: &self.quantizedEndStep)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if self.pitch != 0 {
        try visitor.visitSingularInt32Field(value: self.pitch, fieldNumber: 1)
      }
      if self.velocity != 0 {
        try visitor.visitSingularInt32Field(value: self.velocity, fieldNumber: 2)
      }
      if self.startTime != 0 {
        try visitor.visitSingularDoubleField(value: self.startTime, fieldNumber: 3)
      }
      if self.endTime != 0 {
        try visitor.visitSingularDoubleField(value: self.endTime, fieldNumber: 4)
      }
      if self.numerator != 0 {
        try visitor.visitSingularInt32Field(value: self.numerator, fieldNumber: 5)
      }
      if self.denominator != 0 {
        try visitor.visitSingularInt32Field(value: self.denominator, fieldNumber: 6)
      }
      if self.instrument != 0 {
        try visitor.visitSingularInt32Field(value: self.instrument, fieldNumber: 7)
      }
      if self.program != 0 {
        try visitor.visitSingularInt32Field(value: self.program, fieldNumber: 8)
      }
      if self.isDrum != false {
        try visitor.visitSingularBoolField(value: self.isDrum, fieldNumber: 9)
      }
      if self.part != 0 {
        try visitor.visitSingularInt32Field(value: self.part, fieldNumber: 10)
      }
      if self.pitchName != .unknownPitchName {
        try visitor.visitSingularEnumField(value: self.pitchName, fieldNumber: 11)
      }
      if self.voice != 0 {
        try visitor.visitSingularInt32Field(value: self.voice, fieldNumber: 12)
      }
      if self.quantizedStartStep != 0 {
        try visitor.visitSingularInt64Field(value: self.quantizedStartStep, fieldNumber: 13)
      }
      if self.quantizedEndStep != 0 {
        try visitor.visitSingularInt64Field(value: self.quantizedEndStep, fieldNumber: 14)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  public struct TimeSignature: SwiftProtobuf.Message {
    public static let protoMessageName: String = Tensorflow_Magenta_NoteSequence.protoMessageName + ".TimeSignature"

    /// Time in seconds.
    public var time: Double = 0

    public var numerator: Int32 = 0

    public var denominator: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularDoubleField(value: &self.time)
        case 2: try decoder.decodeSingularInt32Field(value: &self.numerator)
        case 3: try decoder.decodeSingularInt32Field(value: &self.denominator)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if self.time != 0 {
        try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 1)
      }
      if self.numerator != 0 {
        try visitor.visitSingularInt32Field(value: self.numerator, fieldNumber: 2)
      }
      if self.denominator != 0 {
        try visitor.visitSingularInt32Field(value: self.denominator, fieldNumber: 3)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  public struct KeySignature: SwiftProtobuf.Message {
    public static let protoMessageName: String = Tensorflow_Magenta_NoteSequence.protoMessageName + ".KeySignature"

    /// Time in seconds.
    public var time: Double = 0

    public var key: Tensorflow_Magenta_NoteSequence.KeySignature.Key = .c

    public var mode: Tensorflow_Magenta_NoteSequence.KeySignature.Mode = .major

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Key: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case c // = 0
      case cSharp // = 1
      public static let dFlat = cSharp
      case d // = 2
      case dSharp // = 3
      public static let eFlat = dSharp
      case e // = 4
      case f // = 5
      case fSharp // = 6
      public static let gFlat = fSharp
      case g // = 7
      case gSharp // = 8
      public static let aFlat = gSharp
      case a // = 9
      case aSharp // = 10
      public static let bFlat = aSharp
      case b // = 11
      case UNRECOGNIZED(Int)

      public init() {
        self = .c
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .c
        case 1: self = .cSharp
        case 2: self = .d
        case 3: self = .dSharp
        case 4: self = .e
        case 5: self = .f
        case 6: self = .fSharp
        case 7: self = .g
        case 8: self = .gSharp
        case 9: self = .a
        case 10: self = .aSharp
        case 11: self = .b
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .c: return 0
        case .cSharp: return 1
        case .d: return 2
        case .dSharp: return 3
        case .e: return 4
        case .f: return 5
        case .fSharp: return 6
        case .g: return 7
        case .gSharp: return 8
        case .a: return 9
        case .aSharp: return 10
        case .b: return 11
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public enum Mode: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case major // = 0
      case minor // = 1
      case notSpecified // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .major
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .major
        case 1: self = .minor
        case 2: self = .notSpecified
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .major: return 0
        case .minor: return 1
        case .notSpecified: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularDoubleField(value: &self.time)
        case 2: try decoder.decodeSingularEnumField(value: &self.key)
        case 3: try decoder.decodeSingularEnumField(value: &self.mode)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if self.time != 0 {
        try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 1)
      }
      if self.key != .c {
        try visitor.visitSingularEnumField(value: self.key, fieldNumber: 2)
      }
      if self.mode != .major {
        try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 3)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  public struct Tempo: SwiftProtobuf.Message {
    public static let protoMessageName: String = Tensorflow_Magenta_NoteSequence.protoMessageName + ".Tempo"

    /// Time in seconds when tempo goes into effect.
    public var time: Double = 0

    /// Tempo in quarter notes per minute.
    public var qpm: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularDoubleField(value: &self.time)
        case 2: try decoder.decodeSingularDoubleField(value: &self.qpm)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if self.time != 0 {
        try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 1)
      }
      if self.qpm != 0 {
        try visitor.visitSingularDoubleField(value: self.qpm, fieldNumber: 2)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  /// Stores MIDI PitchBend data. See the MIDI specification for details.
  public struct PitchBend: SwiftProtobuf.Message {
    public static let protoMessageName: String = Tensorflow_Magenta_NoteSequence.protoMessageName + ".PitchBend"

    /// Time in seconds.
    public var time: Double = 0

    /// Pitch bend amount in the range (-8192, 8191).
    public var bend: Int32 = 0

    public var instrument: Int32 = 0

    public var program: Int32 = 0

    public var isDrum: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularDoubleField(value: &self.time)
        case 2: try decoder.decodeSingularInt32Field(value: &self.bend)
        case 3: try decoder.decodeSingularInt32Field(value: &self.instrument)
        case 4: try decoder.decodeSingularInt32Field(value: &self.program)
        case 5: try decoder.decodeSingularBoolField(value: &self.isDrum)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if self.time != 0 {
        try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 1)
      }
      if self.bend != 0 {
        try visitor.visitSingularInt32Field(value: self.bend, fieldNumber: 2)
      }
      if self.instrument != 0 {
        try visitor.visitSingularInt32Field(value: self.instrument, fieldNumber: 3)
      }
      if self.program != 0 {
        try visitor.visitSingularInt32Field(value: self.program, fieldNumber: 4)
      }
      if self.isDrum != false {
        try visitor.visitSingularBoolField(value: self.isDrum, fieldNumber: 5)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  /// Stores MIDI Control Change data. See the MIDI specification for details.
  public struct ControlChange: SwiftProtobuf.Message {
    public static let protoMessageName: String = Tensorflow_Magenta_NoteSequence.protoMessageName + ".ControlChange"

    /// Time in seconds.
    public var time: Double = 0

    /// Control (or "controller") number e.g. 0x4 = Foot Controller.
    public var controlNumber: Int32 = 0

    /// The value for that controller in the range (0, 127).
    public var controlValue: Int32 = 0

    public var instrument: Int32 = 0

    public var program: Int32 = 0

    public var isDrum: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularDoubleField(value: &self.time)
        case 2: try decoder.decodeSingularInt32Field(value: &self.controlNumber)
        case 3: try decoder.decodeSingularInt32Field(value: &self.controlValue)
        case 4: try decoder.decodeSingularInt32Field(value: &self.instrument)
        case 5: try decoder.decodeSingularInt32Field(value: &self.program)
        case 6: try decoder.decodeSingularBoolField(value: &self.isDrum)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if self.time != 0 {
        try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 1)
      }
      if self.controlNumber != 0 {
        try visitor.visitSingularInt32Field(value: self.controlNumber, fieldNumber: 2)
      }
      if self.controlValue != 0 {
        try visitor.visitSingularInt32Field(value: self.controlValue, fieldNumber: 3)
      }
      if self.instrument != 0 {
        try visitor.visitSingularInt32Field(value: self.instrument, fieldNumber: 4)
      }
      if self.program != 0 {
        try visitor.visitSingularInt32Field(value: self.program, fieldNumber: 5)
      }
      if self.isDrum != false {
        try visitor.visitSingularBoolField(value: self.isDrum, fieldNumber: 6)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  /// Stores score-related information about a particular part.
  /// See usage within Note for more details.
  public struct PartInfo: SwiftProtobuf.Message {
    public static let protoMessageName: String = Tensorflow_Magenta_NoteSequence.protoMessageName + ".PartInfo"

    /// The part index.
    public var part: Int32 = 0

    /// The name of the part. Examples: "Piano" or "Voice".
    public var name: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt32Field(value: &self.part)
        case 2: try decoder.decodeSingularStringField(value: &self.name)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if self.part != 0 {
        try visitor.visitSingularInt32Field(value: self.part, fieldNumber: 1)
      }
      if !self.name.isEmpty {
        try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  /// Stores source-related information.
  public struct SourceInfo: SwiftProtobuf.Message {
    public static let protoMessageName: String = Tensorflow_Magenta_NoteSequence.protoMessageName + ".SourceInfo"

    /// The type of source, if it was score-based or performance-based.
    public var sourceType: Tensorflow_Magenta_NoteSequence.SourceInfo.SourceType = .unknownSourceType

    /// The encoding type used in the source file.
    public var encodingType: Tensorflow_Magenta_NoteSequence.SourceInfo.EncodingType = .unknownEncodingType

    /// That parser that was used to parse the source file.
    public var parser: Tensorflow_Magenta_NoteSequence.SourceInfo.Parser = .unknownParser

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The type of source that was encoded in the original file.
    public enum SourceType: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case unknownSourceType // = 0

      /// If the source was some kind of score (e.g., MusicXML, ABC, etc.).
      /// We can expect perfect timing alignment with measures and complete
      /// TimeSignature and KeySignature information.
      case scoreBased // = 1
      case performanceBased // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknownSourceType
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknownSourceType
        case 1: self = .scoreBased
        case 2: self = .performanceBased
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknownSourceType: return 0
        case .scoreBased: return 1
        case .performanceBased: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    /// Enum for all encoding types, both score_based and performance_based.
    public enum EncodingType: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case unknownEncodingType // = 0
      case musicXml // = 1
      case abc // = 2
      case midi // = 3
      case musicnet // = 4
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknownEncodingType
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknownEncodingType
        case 1: self = .musicXml
        case 2: self = .abc
        case 3: self = .midi
        case 4: self = .musicnet
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknownEncodingType: return 0
        case .musicXml: return 1
        case .abc: return 2
        case .midi: return 3
        case .musicnet: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    /// Name of parser used to parse the source file.
    public enum Parser: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case unknownParser // = 0
      case music21 // = 1
      case prettyMidi // = 2

      /// Magenta's built-in MusicXML parser.
      case magentaMusicXml // = 3

      /// Magenta's parser for MusicNet data.
      case magentaMusicnet // = 4
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknownParser
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknownParser
        case 1: self = .music21
        case 2: self = .prettyMidi
        case 3: self = .magentaMusicXml
        case 4: self = .magentaMusicnet
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknownParser: return 0
        case .music21: return 1
        case .prettyMidi: return 2
        case .magentaMusicXml: return 3
        case .magentaMusicnet: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &self.sourceType)
        case 2: try decoder.decodeSingularEnumField(value: &self.encodingType)
        case 3: try decoder.decodeSingularEnumField(value: &self.parser)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if self.sourceType != .unknownSourceType {
        try visitor.visitSingularEnumField(value: self.sourceType, fieldNumber: 1)
      }
      if self.encodingType != .unknownEncodingType {
        try visitor.visitSingularEnumField(value: self.encodingType, fieldNumber: 2)
      }
      if self.parser != .unknownParser {
        try visitor.visitSingularEnumField(value: self.parser, fieldNumber: 3)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  /// Stores an arbitrary text annotation associated with a point in time.
  /// Next tag: 5
  public struct TextAnnotation: SwiftProtobuf.Message {
    public static let protoMessageName: String = Tensorflow_Magenta_NoteSequence.protoMessageName + ".TextAnnotation"

    /// Time in seconds.
    public var time: Double = 0

    /// Quantized time in steps.
    public var quantizedStep: Int64 = 0

    /// Text of the annotation.
    public var text: String = String()

    /// Type of the annotation, to assist with automated interpretation.
    public var annotationType: Tensorflow_Magenta_NoteSequence.TextAnnotation.TextAnnotationType = .unknown

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum TextAnnotationType: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Unknown annotation type.
      case unknown // = 0

      /// Chord symbol as used in lead sheets. We treat text as the "ground
      /// truth" format for chord symbols, as the semantic interpretation of
      /// a chord symbol is often fuzzy. We defer this interpretation to
      /// individual models, each of which can translate chord symbol strings
      /// into model input in whatever way is deemed most appropriate for that
      /// model.
      ///
      /// Some examples of chord symbol text we consider reasonable: 'C#', 'A7',
      /// 'Fm7b5', 'N.C.', 'G(no3)', 'C/Bb', 'D-9(b5)', 'Gadd2', 'Abm(maj7)'.
      case chordSymbol // = 1
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .chordSymbol
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .chordSymbol: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularDoubleField(value: &self.time)
        case 2: try decoder.decodeSingularStringField(value: &self.text)
        case 3: try decoder.decodeSingularEnumField(value: &self.annotationType)
        case 4: try decoder.decodeSingularInt64Field(value: &self.quantizedStep)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if self.time != 0 {
        try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 1)
      }
      if !self.text.isEmpty {
        try visitor.visitSingularStringField(value: self.text, fieldNumber: 2)
      }
      if self.annotationType != .unknown {
        try visitor.visitSingularEnumField(value: self.annotationType, fieldNumber: 3)
      }
      if self.quantizedStep != 0 {
        try visitor.visitSingularInt64Field(value: self.quantizedStep, fieldNumber: 4)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  /// Information about how/if this sequence was quantized.
  public struct QuantizationInfo: SwiftProtobuf.Message {
    public static let protoMessageName: String = Tensorflow_Magenta_NoteSequence.protoMessageName + ".QuantizationInfo"

    public var resolution: Tensorflow_Magenta_NoteSequence.QuantizationInfo.OneOf_Resolution? = nil

    /// How many quantization steps per quarter note of music.
    public var stepsPerQuarter: Int32 {
      get {
        if case .stepsPerQuarter(let v)? = resolution {return v}
        return 0
      }
      set {resolution = .stepsPerQuarter(newValue)}
    }

    /// How many quantization steps per second.
    public var stepsPerSecond: Int32 {
      get {
        if case .stepsPerSecond(let v)? = resolution {return v}
        return 0
      }
      set {resolution = .stepsPerSecond(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Resolution: Equatable {
      /// How many quantization steps per quarter note of music.
      case stepsPerQuarter(Int32)
      /// How many quantization steps per second.
      case stepsPerSecond(Int32)

      public static func ==(lhs: Tensorflow_Magenta_NoteSequence.QuantizationInfo.OneOf_Resolution, rhs: Tensorflow_Magenta_NoteSequence.QuantizationInfo.OneOf_Resolution) -> Bool {
        switch (lhs, rhs) {
        case (.stepsPerQuarter(let l), .stepsPerQuarter(let r)): return l == r
        case (.stepsPerSecond(let l), .stepsPerSecond(let r)): return l == r
        default: return false
        }
      }
    }

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if self.resolution != nil {try decoder.handleConflictingOneOf()}
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {self.resolution = .stepsPerQuarter(v)}
        case 2:
          if self.resolution != nil {try decoder.handleConflictingOneOf()}
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {self.resolution = .stepsPerSecond(v)}
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      switch self.resolution {
      case .stepsPerQuarter(let v)?:
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
      case .stepsPerSecond(let v)?:
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
      case nil: break
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  /// Information about the location of the sequence in a larger source sequence.
  public struct SubsequenceInfo: SwiftProtobuf.Message {
    public static let protoMessageName: String = Tensorflow_Magenta_NoteSequence.protoMessageName + ".SubsequenceInfo"

    /// Time in seconds from the start of the source sequence to the start of
    /// this sequence.
    public var startTimeOffset: Double = 0

    /// Time in seconds from the end of this sequence to the end of the source
    /// sequence.
    public var endTimeOffset: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularDoubleField(value: &self.startTimeOffset)
        case 2: try decoder.decodeSingularDoubleField(value: &self.endTimeOffset)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if self.startTimeOffset != 0 {
        try visitor.visitSingularDoubleField(value: self.startTimeOffset, fieldNumber: 1)
      }
      if self.endTimeOffset != 0 {
        try visitor.visitSingularDoubleField(value: self.endTimeOffset, fieldNumber: 2)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularStringField(value: &_storage._filename)
        case 3: try decoder.decodeSingularStringField(value: &_storage._collectionName)
        case 4: try decoder.decodeSingularInt32Field(value: &_storage._ticksPerQuarter)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._timeSignatures)
        case 6: try decoder.decodeRepeatedMessageField(value: &_storage._keySignatures)
        case 7: try decoder.decodeRepeatedMessageField(value: &_storage._tempos)
        case 8: try decoder.decodeRepeatedMessageField(value: &_storage._notes)
        case 9: try decoder.decodeSingularDoubleField(value: &_storage._totalTime)
        case 10: try decoder.decodeRepeatedMessageField(value: &_storage._pitchBends)
        case 11: try decoder.decodeRepeatedMessageField(value: &_storage._controlChanges)
        case 12: try decoder.decodeRepeatedMessageField(value: &_storage._partInfos)
        case 13: try decoder.decodeSingularMessageField(value: &_storage._sourceInfo)
        case 14: try decoder.decodeRepeatedMessageField(value: &_storage._textAnnotations)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._quantizationInfo)
        case 16: try decoder.decodeSingularInt64Field(value: &_storage._totalQuantizedSteps)
        case 17: try decoder.decodeSingularMessageField(value: &_storage._subsequenceInfo)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._filename.isEmpty {
        try visitor.visitSingularStringField(value: _storage._filename, fieldNumber: 2)
      }
      if !_storage._collectionName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._collectionName, fieldNumber: 3)
      }
      if _storage._ticksPerQuarter != 0 {
        try visitor.visitSingularInt32Field(value: _storage._ticksPerQuarter, fieldNumber: 4)
      }
      if !_storage._timeSignatures.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._timeSignatures, fieldNumber: 5)
      }
      if !_storage._keySignatures.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._keySignatures, fieldNumber: 6)
      }
      if !_storage._tempos.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tempos, fieldNumber: 7)
      }
      if !_storage._notes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._notes, fieldNumber: 8)
      }
      if _storage._totalTime != 0 {
        try visitor.visitSingularDoubleField(value: _storage._totalTime, fieldNumber: 9)
      }
      if !_storage._pitchBends.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pitchBends, fieldNumber: 10)
      }
      if !_storage._controlChanges.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._controlChanges, fieldNumber: 11)
      }
      if !_storage._partInfos.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._partInfos, fieldNumber: 12)
      }
      if let v = _storage._sourceInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if !_storage._textAnnotations.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._textAnnotations, fieldNumber: 14)
      }
      if let v = _storage._quantizationInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if _storage._totalQuantizedSteps != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalQuantizedSteps, fieldNumber: 16)
      }
      if let v = _storage._subsequenceInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tensorflow.magenta"

extension Tensorflow_Magenta_NoteSequence: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "filename"),
    3: .standard(proto: "collection_name"),
    4: .standard(proto: "ticks_per_quarter"),
    5: .standard(proto: "time_signatures"),
    6: .standard(proto: "key_signatures"),
    7: .same(proto: "tempos"),
    8: .same(proto: "notes"),
    9: .standard(proto: "total_time"),
    16: .standard(proto: "total_quantized_steps"),
    10: .standard(proto: "pitch_bends"),
    11: .standard(proto: "control_changes"),
    12: .standard(proto: "part_infos"),
    13: .standard(proto: "source_info"),
    14: .standard(proto: "text_annotations"),
    15: .standard(proto: "quantization_info"),
    17: .standard(proto: "subsequence_info"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _filename: String = String()
    var _collectionName: String = String()
    var _ticksPerQuarter: Int32 = 0
    var _timeSignatures: [Tensorflow_Magenta_NoteSequence.TimeSignature] = []
    var _keySignatures: [Tensorflow_Magenta_NoteSequence.KeySignature] = []
    var _tempos: [Tensorflow_Magenta_NoteSequence.Tempo] = []
    var _notes: [Tensorflow_Magenta_NoteSequence.Note] = []
    var _totalTime: Double = 0
    var _totalQuantizedSteps: Int64 = 0
    var _pitchBends: [Tensorflow_Magenta_NoteSequence.PitchBend] = []
    var _controlChanges: [Tensorflow_Magenta_NoteSequence.ControlChange] = []
    var _partInfos: [Tensorflow_Magenta_NoteSequence.PartInfo] = []
    var _sourceInfo: Tensorflow_Magenta_NoteSequence.SourceInfo? = nil
    var _textAnnotations: [Tensorflow_Magenta_NoteSequence.TextAnnotation] = []
    var _quantizationInfo: Tensorflow_Magenta_NoteSequence.QuantizationInfo? = nil
    var _subsequenceInfo: Tensorflow_Magenta_NoteSequence.SubsequenceInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _filename = source._filename
      _collectionName = source._collectionName
      _ticksPerQuarter = source._ticksPerQuarter
      _timeSignatures = source._timeSignatures
      _keySignatures = source._keySignatures
      _tempos = source._tempos
      _notes = source._notes
      _totalTime = source._totalTime
      _totalQuantizedSteps = source._totalQuantizedSteps
      _pitchBends = source._pitchBends
      _controlChanges = source._controlChanges
      _partInfos = source._partInfos
      _sourceInfo = source._sourceInfo
      _textAnnotations = source._textAnnotations
      _quantizationInfo = source._quantizationInfo
      _subsequenceInfo = source._subsequenceInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_Magenta_NoteSequence) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_storage, other_storage) in
        if _storage._id != other_storage._id {return false}
        if _storage._filename != other_storage._filename {return false}
        if _storage._collectionName != other_storage._collectionName {return false}
        if _storage._ticksPerQuarter != other_storage._ticksPerQuarter {return false}
        if _storage._timeSignatures != other_storage._timeSignatures {return false}
        if _storage._keySignatures != other_storage._keySignatures {return false}
        if _storage._tempos != other_storage._tempos {return false}
        if _storage._notes != other_storage._notes {return false}
        if _storage._totalTime != other_storage._totalTime {return false}
        if _storage._totalQuantizedSteps != other_storage._totalQuantizedSteps {return false}
        if _storage._pitchBends != other_storage._pitchBends {return false}
        if _storage._controlChanges != other_storage._controlChanges {return false}
        if _storage._partInfos != other_storage._partInfos {return false}
        if _storage._sourceInfo != other_storage._sourceInfo {return false}
        if _storage._textAnnotations != other_storage._textAnnotations {return false}
        if _storage._quantizationInfo != other_storage._quantizationInfo {return false}
        if _storage._subsequenceInfo != other_storage._subsequenceInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Magenta_NoteSequence.PitchName: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_PITCH_NAME"),
    1: .same(proto: "F_FLAT_FLAT"),
    2: .same(proto: "C_FLAT_FLAT"),
    3: .same(proto: "G_FLAT_FLAT"),
    4: .same(proto: "D_FLAT_FLAT"),
    5: .same(proto: "A_FLAT_FLAT"),
    6: .same(proto: "E_FLAT_FLAT"),
    7: .same(proto: "B_FLAT_FLAT"),
    8: .same(proto: "F_FLAT"),
    9: .same(proto: "C_FLAT"),
    10: .same(proto: "G_FLAT"),
    11: .same(proto: "D_FLAT"),
    12: .same(proto: "A_FLAT"),
    13: .same(proto: "E_FLAT"),
    14: .same(proto: "B_FLAT"),
    15: .same(proto: "F"),
    16: .same(proto: "C"),
    17: .same(proto: "G"),
    18: .same(proto: "D"),
    19: .same(proto: "A"),
    20: .same(proto: "E"),
    21: .same(proto: "B"),
    22: .same(proto: "F_SHARP"),
    23: .same(proto: "C_SHARP"),
    24: .same(proto: "G_SHARP"),
    25: .same(proto: "D_SHARP"),
    26: .same(proto: "A_SHARP"),
    27: .same(proto: "E_SHARP"),
    28: .same(proto: "B_SHARP"),
    29: .same(proto: "F_SHARP_SHARP"),
    30: .same(proto: "C_SHARP_SHARP"),
    31: .same(proto: "G_SHARP_SHARP"),
    32: .same(proto: "D_SHARP_SHARP"),
    33: .same(proto: "A_SHARP_SHARP"),
    34: .same(proto: "E_SHARP_SHARP"),
    35: .same(proto: "B_SHARP_SHARP"),
  ]
}

extension Tensorflow_Magenta_NoteSequence.Note: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pitch"),
    11: .standard(proto: "pitch_name"),
    2: .same(proto: "velocity"),
    3: .standard(proto: "start_time"),
    13: .standard(proto: "quantized_start_step"),
    4: .standard(proto: "end_time"),
    14: .standard(proto: "quantized_end_step"),
    5: .same(proto: "numerator"),
    6: .same(proto: "denominator"),
    7: .same(proto: "instrument"),
    8: .same(proto: "program"),
    9: .standard(proto: "is_drum"),
    10: .same(proto: "part"),
    12: .same(proto: "voice"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_Magenta_NoteSequence.Note) -> Bool {
    if self.pitch != other.pitch {return false}
    if self.pitchName != other.pitchName {return false}
    if self.velocity != other.velocity {return false}
    if self.startTime != other.startTime {return false}
    if self.quantizedStartStep != other.quantizedStartStep {return false}
    if self.endTime != other.endTime {return false}
    if self.quantizedEndStep != other.quantizedEndStep {return false}
    if self.numerator != other.numerator {return false}
    if self.denominator != other.denominator {return false}
    if self.instrument != other.instrument {return false}
    if self.program != other.program {return false}
    if self.isDrum != other.isDrum {return false}
    if self.part != other.part {return false}
    if self.voice != other.voice {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Magenta_NoteSequence.TimeSignature: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .same(proto: "numerator"),
    3: .same(proto: "denominator"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_Magenta_NoteSequence.TimeSignature) -> Bool {
    if self.time != other.time {return false}
    if self.numerator != other.numerator {return false}
    if self.denominator != other.denominator {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Magenta_NoteSequence.KeySignature: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .same(proto: "key"),
    3: .same(proto: "mode"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_Magenta_NoteSequence.KeySignature) -> Bool {
    if self.time != other.time {return false}
    if self.key != other.key {return false}
    if self.mode != other.mode {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Magenta_NoteSequence.KeySignature.Key: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "C"),
    1: .aliased(proto: "C_SHARP", aliases: ["D_FLAT"]),
    2: .same(proto: "D"),
    3: .aliased(proto: "D_SHARP", aliases: ["E_FLAT"]),
    4: .same(proto: "E"),
    5: .same(proto: "F"),
    6: .aliased(proto: "F_SHARP", aliases: ["G_FLAT"]),
    7: .same(proto: "G"),
    8: .aliased(proto: "G_SHARP", aliases: ["A_FLAT"]),
    9: .same(proto: "A"),
    10: .aliased(proto: "A_SHARP", aliases: ["B_FLAT"]),
    11: .same(proto: "B"),
  ]
}

extension Tensorflow_Magenta_NoteSequence.KeySignature.Mode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MAJOR"),
    1: .same(proto: "MINOR"),
    2: .same(proto: "NOT_SPECIFIED"),
  ]
}

extension Tensorflow_Magenta_NoteSequence.Tempo: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .same(proto: "qpm"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_Magenta_NoteSequence.Tempo) -> Bool {
    if self.time != other.time {return false}
    if self.qpm != other.qpm {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Magenta_NoteSequence.PitchBend: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .same(proto: "bend"),
    3: .same(proto: "instrument"),
    4: .same(proto: "program"),
    5: .standard(proto: "is_drum"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_Magenta_NoteSequence.PitchBend) -> Bool {
    if self.time != other.time {return false}
    if self.bend != other.bend {return false}
    if self.instrument != other.instrument {return false}
    if self.program != other.program {return false}
    if self.isDrum != other.isDrum {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Magenta_NoteSequence.ControlChange: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .standard(proto: "control_number"),
    3: .standard(proto: "control_value"),
    4: .same(proto: "instrument"),
    5: .same(proto: "program"),
    6: .standard(proto: "is_drum"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_Magenta_NoteSequence.ControlChange) -> Bool {
    if self.time != other.time {return false}
    if self.controlNumber != other.controlNumber {return false}
    if self.controlValue != other.controlValue {return false}
    if self.instrument != other.instrument {return false}
    if self.program != other.program {return false}
    if self.isDrum != other.isDrum {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Magenta_NoteSequence.PartInfo: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "part"),
    2: .same(proto: "name"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_Magenta_NoteSequence.PartInfo) -> Bool {
    if self.part != other.part {return false}
    if self.name != other.name {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Magenta_NoteSequence.SourceInfo: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "source_type"),
    2: .standard(proto: "encoding_type"),
    3: .same(proto: "parser"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_Magenta_NoteSequence.SourceInfo) -> Bool {
    if self.sourceType != other.sourceType {return false}
    if self.encodingType != other.encodingType {return false}
    if self.parser != other.parser {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Magenta_NoteSequence.SourceInfo.SourceType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_SOURCE_TYPE"),
    1: .same(proto: "SCORE_BASED"),
    2: .same(proto: "PERFORMANCE_BASED"),
  ]
}

extension Tensorflow_Magenta_NoteSequence.SourceInfo.EncodingType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_ENCODING_TYPE"),
    1: .same(proto: "MUSIC_XML"),
    2: .same(proto: "ABC"),
    3: .same(proto: "MIDI"),
    4: .same(proto: "MUSICNET"),
  ]
}

extension Tensorflow_Magenta_NoteSequence.SourceInfo.Parser: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_PARSER"),
    1: .same(proto: "MUSIC21"),
    2: .same(proto: "PRETTY_MIDI"),
    3: .same(proto: "MAGENTA_MUSIC_XML"),
    4: .same(proto: "MAGENTA_MUSICNET"),
  ]
}

extension Tensorflow_Magenta_NoteSequence.TextAnnotation: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    4: .standard(proto: "quantized_step"),
    2: .same(proto: "text"),
    3: .standard(proto: "annotation_type"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_Magenta_NoteSequence.TextAnnotation) -> Bool {
    if self.time != other.time {return false}
    if self.quantizedStep != other.quantizedStep {return false}
    if self.text != other.text {return false}
    if self.annotationType != other.annotationType {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Magenta_NoteSequence.TextAnnotation.TextAnnotationType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CHORD_SYMBOL"),
  ]
}

extension Tensorflow_Magenta_NoteSequence.QuantizationInfo: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "steps_per_quarter"),
    2: .standard(proto: "steps_per_second"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_Magenta_NoteSequence.QuantizationInfo) -> Bool {
    if self.resolution != other.resolution {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Magenta_NoteSequence.SubsequenceInfo: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_time_offset"),
    2: .standard(proto: "end_time_offset"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_Magenta_NoteSequence.SubsequenceInfo) -> Bool {
    if self.startTimeOffset != other.startTimeOffset {return false}
    if self.endTimeOffset != other.endTimeOffset {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

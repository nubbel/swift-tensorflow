/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "event.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { }

public extension Tensorflow {
    public struct EventRoot {
        public static let `default` = EventRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Tensorflow.SummaryRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    /// Protocol buffer representing an event that happened during
    /// the execution of a Brain model.
    final public class Event : GeneratedMessage {

        public static func == (lhs: Tensorflow.Event, rhs: Tensorflow.Event) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasWallTime == rhs.hasWallTime) && (!lhs.hasWallTime || lhs.wallTime == rhs.wallTime)
            fieldCheck = fieldCheck && (lhs.hasStep == rhs.hasStep) && (!lhs.hasStep || lhs.step == rhs.step)
            fieldCheck = fieldCheck && (lhs.hasFileVersion == rhs.hasFileVersion) && (!lhs.hasFileVersion || lhs.fileVersion == rhs.fileVersion)
            fieldCheck = fieldCheck && (lhs.hasGraphDef == rhs.hasGraphDef) && (!lhs.hasGraphDef || lhs.graphDef == rhs.graphDef)
            fieldCheck = fieldCheck && (lhs.hasSummary == rhs.hasSummary) && (!lhs.hasSummary || lhs.summary == rhs.summary)
            fieldCheck = fieldCheck && (lhs.hasLogMessage == rhs.hasLogMessage) && (!lhs.hasLogMessage || lhs.logMessage == rhs.logMessage)
            fieldCheck = fieldCheck && (lhs.hasSessionLog == rhs.hasSessionLog) && (!lhs.hasSessionLog || lhs.sessionLog == rhs.sessionLog)
            fieldCheck = fieldCheck && (lhs.hasTaggedRunMetadata == rhs.hasTaggedRunMetadata) && (!lhs.hasTaggedRunMetadata || lhs.taggedRunMetadata == rhs.taggedRunMetadata)
            fieldCheck = fieldCheck && (lhs.hasMetaGraphDef == rhs.hasMetaGraphDef) && (!lhs.hasMetaGraphDef || lhs.metaGraphDef == rhs.metaGraphDef)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //OneOf declaration start

        public enum What {
            case OneOfWhatNotSet

            public func checkOneOfIsSet() -> Bool {
                switch self {
                case .OneOfWhatNotSet: return false
                default: return true
                }
            }
            case FileVersion(String)

            public static func getFileVersion(_ value:What) -> String? {
                switch value {
                case .FileVersion(let enumValue): return enumValue
                default: return nil
                }
            }
            case GraphDef(Data)

            public static func getGraphDef(_ value:What) -> Data? {
                switch value {
                case .GraphDef(let enumValue): return enumValue
                default: return nil
                }
            }
            case Summary(Tensorflow.Summary)

            public static func getSummary(_ value:What) -> Tensorflow.Summary? {
                switch value {
                case .Summary(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case LogMessage(Tensorflow.LogMessage)

            public static func getLogMessage(_ value:What) -> Tensorflow.LogMessage? {
                switch value {
                case .LogMessage(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case SessionLog(Tensorflow.SessionLog)

            public static func getSessionLog(_ value:What) -> Tensorflow.SessionLog? {
                switch value {
                case .SessionLog(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case TaggedRunMetadata(Tensorflow.TaggedRunMetadata)

            public static func getTaggedRunMetadata(_ value:What) -> Tensorflow.TaggedRunMetadata? {
                switch value {
                case .TaggedRunMetadata(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case MetaGraphDef(Data)

            public static func getMetaGraphDef(_ value:What) -> Data? {
                switch value {
                case .MetaGraphDef(let enumValue): return enumValue
                default: return nil
                }
            }
        }
        //OneOf declaration end

        fileprivate var storageWhat:Event.What =  Event.What.OneOfWhatNotSet
        public func getOneOfWhat() ->  Event.What {
            let copyObjectWhat = storageWhat
            return copyObjectWhat
        }
        /// Timestamp of the event.
        public fileprivate(set) var wallTime:Double = Double(0)
        public fileprivate(set) var hasWallTime:Bool = false

        /// Global step of the event.
        public fileprivate(set) var step:Int64 = Int64(0)
        public fileprivate(set) var hasStep:Bool = false

        /// An event file was started, with the specified version.
        /// This is use to identify the contents of the record IO files
        /// easily.  Current version is "brain.Event:2".  All versions
        /// start with "brain.Event:".
        public fileprivate(set) var fileVersion:String!{
            get {
                return Event.What.getFileVersion(storageWhat)
            }
            set (newvalue) {
                storageWhat = Event.What.FileVersion(newvalue)
            }
        }
        public fileprivate(set) var hasFileVersion:Bool {
            get {
                guard let _ = Event.What.getFileVersion(storageWhat) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        /// An encoded version of a GraphDef.
        public fileprivate(set) var graphDef:Data!{
            get {
                return Event.What.getGraphDef(storageWhat)
            }
            set (newvalue) {
                storageWhat = Event.What.GraphDef(newvalue)
            }
        }
        public fileprivate(set) var hasGraphDef:Bool {
            get {
                guard let _ = Event.What.getGraphDef(storageWhat) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var summary:Tensorflow.Summary!{
            get {
                return Event.What.getSummary(storageWhat)
            }
            set (newvalue) {
                storageWhat = Event.What.Summary(newvalue)
            }
        }
        public fileprivate(set) var hasSummary:Bool {
            get {
                guard let _ = Event.What.getSummary(storageWhat) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var logMessage:Tensorflow.LogMessage!{
            get {
                return Event.What.getLogMessage(storageWhat)
            }
            set (newvalue) {
                storageWhat = Event.What.LogMessage(newvalue)
            }
        }
        public fileprivate(set) var hasLogMessage:Bool {
            get {
                guard let _ = Event.What.getLogMessage(storageWhat) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var sessionLog:Tensorflow.SessionLog!{
            get {
                return Event.What.getSessionLog(storageWhat)
            }
            set (newvalue) {
                storageWhat = Event.What.SessionLog(newvalue)
            }
        }
        public fileprivate(set) var hasSessionLog:Bool {
            get {
                guard let _ = Event.What.getSessionLog(storageWhat) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var taggedRunMetadata:Tensorflow.TaggedRunMetadata!{
            get {
                return Event.What.getTaggedRunMetadata(storageWhat)
            }
            set (newvalue) {
                storageWhat = Event.What.TaggedRunMetadata(newvalue)
            }
        }
        public fileprivate(set) var hasTaggedRunMetadata:Bool {
            get {
                guard let _ = Event.What.getTaggedRunMetadata(storageWhat) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        /// An encoded version of a MetaGraphDef.
        public fileprivate(set) var metaGraphDef:Data!{
            get {
                return Event.What.getMetaGraphDef(storageWhat)
            }
            set (newvalue) {
                storageWhat = Event.What.MetaGraphDef(newvalue)
            }
        }
        public fileprivate(set) var hasMetaGraphDef:Bool {
            get {
                guard let _ = Event.What.getMetaGraphDef(storageWhat) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasWallTime {
                try codedOutputStream.writeDouble(fieldNumber: 1, value:wallTime)
            }
            if hasStep {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:step)
            }
            if hasFileVersion {
                try codedOutputStream.writeString(fieldNumber: 3, value:fileVersion)
            }
            if hasGraphDef {
                try codedOutputStream.writeData(fieldNumber: 4, value:graphDef)
            }
            if hasSummary {
                try codedOutputStream.writeMessage(fieldNumber: 5, value:summary)
            }
            if hasLogMessage {
                try codedOutputStream.writeMessage(fieldNumber: 6, value:logMessage)
            }
            if hasSessionLog {
                try codedOutputStream.writeMessage(fieldNumber: 7, value:sessionLog)
            }
            if hasTaggedRunMetadata {
                try codedOutputStream.writeMessage(fieldNumber: 8, value:taggedRunMetadata)
            }
            if hasMetaGraphDef {
                try codedOutputStream.writeData(fieldNumber: 9, value:metaGraphDef)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasWallTime {
                serialize_size += wallTime.computeDoubleSize(fieldNumber: 1)
            }
            if hasStep {
                serialize_size += step.computeInt64Size(fieldNumber: 2)
            }
            if hasFileVersion {
                serialize_size += fileVersion.computeStringSize(fieldNumber: 3)
            }
            if hasGraphDef {
                serialize_size += graphDef.computeDataSize(fieldNumber: 4)
            }
            if hasSummary {
                if let varSizesummary = summary?.computeMessageSize(fieldNumber: 5) {
                    serialize_size += varSizesummary
                }
            }
            if hasLogMessage {
                if let varSizelogMessage = logMessage?.computeMessageSize(fieldNumber: 6) {
                    serialize_size += varSizelogMessage
                }
            }
            if hasSessionLog {
                if let varSizesessionLog = sessionLog?.computeMessageSize(fieldNumber: 7) {
                    serialize_size += varSizesessionLog
                }
            }
            if hasTaggedRunMetadata {
                if let varSizetaggedRunMetadata = taggedRunMetadata?.computeMessageSize(fieldNumber: 8) {
                    serialize_size += varSizetaggedRunMetadata
                }
            }
            if hasMetaGraphDef {
                serialize_size += metaGraphDef.computeDataSize(fieldNumber: 9)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.Event.Builder {
            return Tensorflow.Event.classBuilder() as! Tensorflow.Event.Builder
        }
        public func getBuilder() -> Tensorflow.Event.Builder {
            return classBuilder() as! Tensorflow.Event.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Event.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Event.Builder()
        }
        public func toBuilder() throws -> Tensorflow.Event.Builder {
            return try Tensorflow.Event.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.Event) throws -> Tensorflow.Event.Builder {
            return try Tensorflow.Event.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasWallTime {
                jsonMap["wallTime"] = Double(wallTime)
            }
            if hasStep {
                jsonMap["step"] = "\(step)"
            }
            if hasFileVersion {
                jsonMap["fileVersion"] = fileVersion
            }
            if hasGraphDef {
                jsonMap["graphDef"] = graphDef.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            if hasSummary {
                jsonMap["summary"] = try summary.encode()
            }
            if hasLogMessage {
                jsonMap["logMessage"] = try logMessage.encode()
            }
            if hasSessionLog {
                jsonMap["sessionLog"] = try sessionLog.encode()
            }
            if hasTaggedRunMetadata {
                jsonMap["taggedRunMetadata"] = try taggedRunMetadata.encode()
            }
            if hasMetaGraphDef {
                jsonMap["metaGraphDef"] = metaGraphDef.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Event {
            return try Tensorflow.Event.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.Event {
            return try Tensorflow.Event.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasWallTime {
                output += "\(indent) wallTime: \(wallTime) \n"
            }
            if hasStep {
                output += "\(indent) step: \(step) \n"
            }
            if hasFileVersion {
                output += "\(indent) fileVersion: \(fileVersion) \n"
            }
            if hasGraphDef {
                output += "\(indent) graphDef: \(graphDef) \n"
            }
            if hasSummary {
                output += "\(indent) summary {\n"
                if let outDescSummary = summary {
                    output += try outDescSummary.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasLogMessage {
                output += "\(indent) logMessage {\n"
                if let outDescLogMessage = logMessage {
                    output += try outDescLogMessage.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasSessionLog {
                output += "\(indent) sessionLog {\n"
                if let outDescSessionLog = sessionLog {
                    output += try outDescSessionLog.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasTaggedRunMetadata {
                output += "\(indent) taggedRunMetadata {\n"
                if let outDescTaggedRunMetadata = taggedRunMetadata {
                    output += try outDescTaggedRunMetadata.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasMetaGraphDef {
                output += "\(indent) metaGraphDef: \(metaGraphDef) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasWallTime {
                    hashCode = (hashCode &* 31) &+ wallTime.hashValue
                }
                if hasStep {
                    hashCode = (hashCode &* 31) &+ step.hashValue
                }
                if hasFileVersion {
                    hashCode = (hashCode &* 31) &+ fileVersion.hashValue
                }
                if hasGraphDef {
                    hashCode = (hashCode &* 31) &+ graphDef.hashValue
                }
                if hasSummary {
                    if let hashValuesummary = summary?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuesummary
                    }
                }
                if hasLogMessage {
                    if let hashValuelogMessage = logMessage?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuelogMessage
                    }
                }
                if hasSessionLog {
                    if let hashValuesessionLog = sessionLog?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuesessionLog
                    }
                }
                if hasTaggedRunMetadata {
                    if let hashValuetaggedRunMetadata = taggedRunMetadata?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuetaggedRunMetadata
                    }
                }
                if hasMetaGraphDef {
                    hashCode = (hashCode &* 31) &+ metaGraphDef.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.Event"
        }
        override public func className() -> String {
            return "Tensorflow.Event"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.Event = Tensorflow.Event()
            public func getMessage() -> Tensorflow.Event {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Timestamp of the event.
            public var wallTime:Double {
                get {
                    return builderResult.wallTime
                }
                set (value) {
                    builderResult.hasWallTime = true
                    builderResult.wallTime = value
                }
            }
            public var hasWallTime:Bool {
                get {
                    return builderResult.hasWallTime
                }
            }
            @discardableResult
            public func setWallTime(_ value:Double) -> Tensorflow.Event.Builder {
                self.wallTime = value
                return self
            }
            @discardableResult
            public func clearWallTime() -> Tensorflow.Event.Builder{
                builderResult.hasWallTime = false
                builderResult.wallTime = Double(0)
                return self
            }
            /// Global step of the event.
            public var step:Int64 {
                get {
                    return builderResult.step
                }
                set (value) {
                    builderResult.hasStep = true
                    builderResult.step = value
                }
            }
            public var hasStep:Bool {
                get {
                    return builderResult.hasStep
                }
            }
            @discardableResult
            public func setStep(_ value:Int64) -> Tensorflow.Event.Builder {
                self.step = value
                return self
            }
            @discardableResult
            public func clearStep() -> Tensorflow.Event.Builder{
                builderResult.hasStep = false
                builderResult.step = Int64(0)
                return self
            }
            /// An event file was started, with the specified version.
            /// This is use to identify the contents of the record IO files
            /// easily.  Current version is "brain.Event:2".  All versions
            /// start with "brain.Event:".
            public var fileVersion:String {
                get {
                    return builderResult.fileVersion
                }
                set (value) {
                    builderResult.hasFileVersion = true
                    builderResult.fileVersion = value
                }
            }
            public var hasFileVersion:Bool {
                get {
                    return builderResult.hasFileVersion
                }
            }
            @discardableResult
            public func setFileVersion(_ value:String) -> Tensorflow.Event.Builder {
                self.fileVersion = value
                return self
            }
            @discardableResult
            public func clearFileVersion() -> Tensorflow.Event.Builder{
                builderResult.hasFileVersion = false
                builderResult.fileVersion = ""
                return self
            }
            /// An encoded version of a GraphDef.
            public var graphDef:Data {
                get {
                    return builderResult.graphDef
                }
                set (value) {
                    builderResult.hasGraphDef = true
                    builderResult.graphDef = value
                }
            }
            public var hasGraphDef:Bool {
                get {
                    return builderResult.hasGraphDef
                }
            }
            @discardableResult
            public func setGraphDef(_ value:Data) -> Tensorflow.Event.Builder {
                self.graphDef = value
                return self
            }
            @discardableResult
            public func clearGraphDef() -> Tensorflow.Event.Builder{
                builderResult.hasGraphDef = false
                builderResult.graphDef = Data()
                return self
            }
            /// A summary was generated.
            public var summary:Tensorflow.Summary! {
                get {
                    if summaryBuilder_ != nil {
                        builderResult.summary = summaryBuilder_.getMessage()
                    }
                    return builderResult.summary
                }
                set (value) {
                    builderResult.hasSummary = true
                    builderResult.summary = value
                }
            }
            public var hasSummary:Bool {
                get {
                    return builderResult.hasSummary
                }
            }
            fileprivate var summaryBuilder_:Tensorflow.Summary.Builder! {
                didSet {
                    builderResult.hasSummary = true
                }
            }
            public func getSummaryBuilder() -> Tensorflow.Summary.Builder {
                if summaryBuilder_ == nil {
                    summaryBuilder_ = Tensorflow.Summary.Builder()
                    builderResult.summary = summaryBuilder_.getMessage()
                    if summary != nil {
                        try! summaryBuilder_.mergeFrom(other: summary)
                    }
                }
                return summaryBuilder_
            }
            @discardableResult
            public func setSummary(_ value:Tensorflow.Summary!) -> Tensorflow.Event.Builder {
                self.summary = value
                return self
            }
            @discardableResult
            public func mergeSummary(value:Tensorflow.Summary) throws -> Tensorflow.Event.Builder {
                if builderResult.hasSummary {
                    builderResult.summary = try Tensorflow.Summary.builderWithPrototype(prototype:builderResult.summary).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.summary = value
                }
                builderResult.hasSummary = true
                return self
            }
            @discardableResult
            public func clearSummary() -> Tensorflow.Event.Builder {
                summaryBuilder_ = nil
                builderResult.hasSummary = false
                builderResult.summary = nil
                return self
            }
            /// The user output a log message. Not all messages are logged, only ones
            /// generated via the Python tensorboard_logging module.
            public var logMessage:Tensorflow.LogMessage! {
                get {
                    if logMessageBuilder_ != nil {
                        builderResult.logMessage = logMessageBuilder_.getMessage()
                    }
                    return builderResult.logMessage
                }
                set (value) {
                    builderResult.hasLogMessage = true
                    builderResult.logMessage = value
                }
            }
            public var hasLogMessage:Bool {
                get {
                    return builderResult.hasLogMessage
                }
            }
            fileprivate var logMessageBuilder_:Tensorflow.LogMessage.Builder! {
                didSet {
                    builderResult.hasLogMessage = true
                }
            }
            public func getLogMessageBuilder() -> Tensorflow.LogMessage.Builder {
                if logMessageBuilder_ == nil {
                    logMessageBuilder_ = Tensorflow.LogMessage.Builder()
                    builderResult.logMessage = logMessageBuilder_.getMessage()
                    if logMessage != nil {
                        try! logMessageBuilder_.mergeFrom(other: logMessage)
                    }
                }
                return logMessageBuilder_
            }
            @discardableResult
            public func setLogMessage(_ value:Tensorflow.LogMessage!) -> Tensorflow.Event.Builder {
                self.logMessage = value
                return self
            }
            @discardableResult
            public func mergeLogMessage(value:Tensorflow.LogMessage) throws -> Tensorflow.Event.Builder {
                if builderResult.hasLogMessage {
                    builderResult.logMessage = try Tensorflow.LogMessage.builderWithPrototype(prototype:builderResult.logMessage).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.logMessage = value
                }
                builderResult.hasLogMessage = true
                return self
            }
            @discardableResult
            public func clearLogMessage() -> Tensorflow.Event.Builder {
                logMessageBuilder_ = nil
                builderResult.hasLogMessage = false
                builderResult.logMessage = nil
                return self
            }
            /// The state of the session which can be used for restarting after crashes.
            public var sessionLog:Tensorflow.SessionLog! {
                get {
                    if sessionLogBuilder_ != nil {
                        builderResult.sessionLog = sessionLogBuilder_.getMessage()
                    }
                    return builderResult.sessionLog
                }
                set (value) {
                    builderResult.hasSessionLog = true
                    builderResult.sessionLog = value
                }
            }
            public var hasSessionLog:Bool {
                get {
                    return builderResult.hasSessionLog
                }
            }
            fileprivate var sessionLogBuilder_:Tensorflow.SessionLog.Builder! {
                didSet {
                    builderResult.hasSessionLog = true
                }
            }
            public func getSessionLogBuilder() -> Tensorflow.SessionLog.Builder {
                if sessionLogBuilder_ == nil {
                    sessionLogBuilder_ = Tensorflow.SessionLog.Builder()
                    builderResult.sessionLog = sessionLogBuilder_.getMessage()
                    if sessionLog != nil {
                        try! sessionLogBuilder_.mergeFrom(other: sessionLog)
                    }
                }
                return sessionLogBuilder_
            }
            @discardableResult
            public func setSessionLog(_ value:Tensorflow.SessionLog!) -> Tensorflow.Event.Builder {
                self.sessionLog = value
                return self
            }
            @discardableResult
            public func mergeSessionLog(value:Tensorflow.SessionLog) throws -> Tensorflow.Event.Builder {
                if builderResult.hasSessionLog {
                    builderResult.sessionLog = try Tensorflow.SessionLog.builderWithPrototype(prototype:builderResult.sessionLog).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.sessionLog = value
                }
                builderResult.hasSessionLog = true
                return self
            }
            @discardableResult
            public func clearSessionLog() -> Tensorflow.Event.Builder {
                sessionLogBuilder_ = nil
                builderResult.hasSessionLog = false
                builderResult.sessionLog = nil
                return self
            }
            /// The metadata returned by running a session.run() call.
            public var taggedRunMetadata:Tensorflow.TaggedRunMetadata! {
                get {
                    if taggedRunMetadataBuilder_ != nil {
                        builderResult.taggedRunMetadata = taggedRunMetadataBuilder_.getMessage()
                    }
                    return builderResult.taggedRunMetadata
                }
                set (value) {
                    builderResult.hasTaggedRunMetadata = true
                    builderResult.taggedRunMetadata = value
                }
            }
            public var hasTaggedRunMetadata:Bool {
                get {
                    return builderResult.hasTaggedRunMetadata
                }
            }
            fileprivate var taggedRunMetadataBuilder_:Tensorflow.TaggedRunMetadata.Builder! {
                didSet {
                    builderResult.hasTaggedRunMetadata = true
                }
            }
            public func getTaggedRunMetadataBuilder() -> Tensorflow.TaggedRunMetadata.Builder {
                if taggedRunMetadataBuilder_ == nil {
                    taggedRunMetadataBuilder_ = Tensorflow.TaggedRunMetadata.Builder()
                    builderResult.taggedRunMetadata = taggedRunMetadataBuilder_.getMessage()
                    if taggedRunMetadata != nil {
                        try! taggedRunMetadataBuilder_.mergeFrom(other: taggedRunMetadata)
                    }
                }
                return taggedRunMetadataBuilder_
            }
            @discardableResult
            public func setTaggedRunMetadata(_ value:Tensorflow.TaggedRunMetadata!) -> Tensorflow.Event.Builder {
                self.taggedRunMetadata = value
                return self
            }
            @discardableResult
            public func mergeTaggedRunMetadata(value:Tensorflow.TaggedRunMetadata) throws -> Tensorflow.Event.Builder {
                if builderResult.hasTaggedRunMetadata {
                    builderResult.taggedRunMetadata = try Tensorflow.TaggedRunMetadata.builderWithPrototype(prototype:builderResult.taggedRunMetadata).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.taggedRunMetadata = value
                }
                builderResult.hasTaggedRunMetadata = true
                return self
            }
            @discardableResult
            public func clearTaggedRunMetadata() -> Tensorflow.Event.Builder {
                taggedRunMetadataBuilder_ = nil
                builderResult.hasTaggedRunMetadata = false
                builderResult.taggedRunMetadata = nil
                return self
            }
            /// An encoded version of a MetaGraphDef.
            public var metaGraphDef:Data {
                get {
                    return builderResult.metaGraphDef
                }
                set (value) {
                    builderResult.hasMetaGraphDef = true
                    builderResult.metaGraphDef = value
                }
            }
            public var hasMetaGraphDef:Bool {
                get {
                    return builderResult.hasMetaGraphDef
                }
            }
            @discardableResult
            public func setMetaGraphDef(_ value:Data) -> Tensorflow.Event.Builder {
                self.metaGraphDef = value
                return self
            }
            @discardableResult
            public func clearMetaGraphDef() -> Tensorflow.Event.Builder{
                builderResult.hasMetaGraphDef = false
                builderResult.metaGraphDef = Data()
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.Event.Builder {
                builderResult = Tensorflow.Event()
                return self
            }
            override public func clone() throws -> Tensorflow.Event.Builder {
                return try Tensorflow.Event.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.Event {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.Event {
                let returnMe:Tensorflow.Event = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.Event) throws -> Tensorflow.Event.Builder {
                if other == Tensorflow.Event() {
                    return self
                }
                if other.hasWallTime {
                    wallTime = other.wallTime
                }
                if other.hasStep {
                    step = other.step
                }
                if other.hasFileVersion {
                    fileVersion = other.fileVersion
                }
                if other.hasGraphDef {
                    graphDef = other.graphDef
                }
                if (other.hasSummary) {
                    try mergeSummary(value: other.summary)
                }
                if (other.hasLogMessage) {
                    try mergeLogMessage(value: other.logMessage)
                }
                if (other.hasSessionLog) {
                    try mergeSessionLog(value: other.sessionLog)
                }
                if (other.hasTaggedRunMetadata) {
                    try mergeTaggedRunMetadata(value: other.taggedRunMetadata)
                }
                if other.hasMetaGraphDef {
                    metaGraphDef = other.metaGraphDef
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Event.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Event.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 9:
                        wallTime = try codedInputStream.readDouble()

                    case 16:
                        step = try codedInputStream.readInt64()

                    case 26:
                        fileVersion = try codedInputStream.readString()

                    case 34:
                        graphDef = try codedInputStream.readData()

                    case 42:
                        let subBuilder:Tensorflow.Summary.Builder = Tensorflow.Summary.Builder()
                        if hasSummary {
                            try subBuilder.mergeFrom(other: summary)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        summary = subBuilder.buildPartial()

                    case 50:
                        let subBuilder:Tensorflow.LogMessage.Builder = Tensorflow.LogMessage.Builder()
                        if hasLogMessage {
                            try subBuilder.mergeFrom(other: logMessage)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        logMessage = subBuilder.buildPartial()

                    case 58:
                        let subBuilder:Tensorflow.SessionLog.Builder = Tensorflow.SessionLog.Builder()
                        if hasSessionLog {
                            try subBuilder.mergeFrom(other: sessionLog)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        sessionLog = subBuilder.buildPartial()

                    case 66:
                        let subBuilder:Tensorflow.TaggedRunMetadata.Builder = Tensorflow.TaggedRunMetadata.Builder()
                        if hasTaggedRunMetadata {
                            try subBuilder.mergeFrom(other: taggedRunMetadata)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        taggedRunMetadata = subBuilder.buildPartial()

                    case 74:
                        metaGraphDef = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Event.Builder {
                let resultDecodedBuilder = Tensorflow.Event.Builder()
                if let jsonValueWallTime = jsonMap["wallTime"] as? Double {
                    resultDecodedBuilder.wallTime = Double(jsonValueWallTime)
                } else if let jsonValueWallTime = jsonMap["wallTime"] as? String {
                    resultDecodedBuilder.wallTime = Double(jsonValueWallTime)!
                }
                if let jsonValueStep = jsonMap["step"] as? String {
                    resultDecodedBuilder.step = Int64(jsonValueStep)!
                } else if let jsonValueStep = jsonMap["step"] as? Int {
                    resultDecodedBuilder.step = Int64(jsonValueStep)
                }
                if let jsonValueFileVersion = jsonMap["fileVersion"] as? String {
                    resultDecodedBuilder.fileVersion = jsonValueFileVersion
                }
                if let jsonValueGraphDef = jsonMap["graphDef"] as? String {
                    resultDecodedBuilder.graphDef = Data(base64Encoded:jsonValueGraphDef, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                if let jsonValueSummary = jsonMap["summary"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.summary = try Tensorflow.Summary.Builder.decodeToBuilder(jsonMap:jsonValueSummary).build()

                }
                if let jsonValueLogMessage = jsonMap["logMessage"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.logMessage = try Tensorflow.LogMessage.Builder.decodeToBuilder(jsonMap:jsonValueLogMessage).build()

                }
                if let jsonValueSessionLog = jsonMap["sessionLog"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.sessionLog = try Tensorflow.SessionLog.Builder.decodeToBuilder(jsonMap:jsonValueSessionLog).build()

                }
                if let jsonValueTaggedRunMetadata = jsonMap["taggedRunMetadata"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.taggedRunMetadata = try Tensorflow.TaggedRunMetadata.Builder.decodeToBuilder(jsonMap:jsonValueTaggedRunMetadata).build()

                }
                if let jsonValueMetaGraphDef = jsonMap["metaGraphDef"] as? String {
                    resultDecodedBuilder.metaGraphDef = Data(base64Encoded:jsonValueMetaGraphDef, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Event.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.Event.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Protocol buffer used for logging messages to the events file.
    final public class LogMessage : GeneratedMessage {

        public static func == (lhs: Tensorflow.LogMessage, rhs: Tensorflow.LogMessage) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasLevel == rhs.hasLevel) && (!lhs.hasLevel || lhs.level == rhs.level)
            fieldCheck = fieldCheck && (lhs.hasMessage == rhs.hasMessage) && (!lhs.hasMessage || lhs.message == rhs.message)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



            //Enum type declaration start 

            public enum Level:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
                case unknown = 0

                /// Note: The logging level 10 cannot be named DEBUG. Some software
                /// projects compile their C/C++ code with -DDEBUG in debug builds. So the
                /// C++ code generated from this file should not have an identifier named
                /// DEBUG.
                case debugging = 10
                case info = 20
                case warn = 30
                case error = 40
                case fatal = 50
                public func toString() -> String {
                    switch self {
                    case .unknown: return "UNKNOWN"
                    case .debugging: return "DEBUGGING"
                    case .info: return "INFO"
                    case .warn: return "WARN"
                    case .error: return "ERROR"
                    case .fatal: return "FATAL"
                    }
                }
                public static func fromString(str:String) throws -> Tensorflow.LogMessage.Level {
                    switch str {
                    case "UNKNOWN":    return .unknown
                    case "DEBUGGING":    return .debugging
                    case "INFO":    return .info
                    case "WARN":    return .warn
                    case "ERROR":    return .error
                    case "FATAL":    return .fatal
                    default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
                    }
                }
                public var debugDescription:String { return getDescription() }
                public var description:String { return getDescription() }
                private func getDescription() -> String { 
                    switch self {
                    case .unknown: return ".unknown"
                    case .debugging: return ".debugging"
                    case .info: return ".info"
                    case .warn: return ".warn"
                    case .error: return ".error"
                    case .fatal: return ".fatal"
                    }
                }
                public var hashValue:Int {
                    return self.rawValue.hashValue
                }
                public static func ==(lhs:Level, rhs:Level) -> Bool {
                    return lhs.hashValue == rhs.hashValue
                }
            }

            //Enum type declaration end 

        public fileprivate(set) var level:Tensorflow.LogMessage.Level = Tensorflow.LogMessage.Level.unknown
        public fileprivate(set) var hasLevel:Bool = false
        public fileprivate(set) var message:String = ""
        public fileprivate(set) var hasMessage:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasLevel {
                try codedOutputStream.writeEnum(fieldNumber: 1, value:level.rawValue)
            }
            if hasMessage {
                try codedOutputStream.writeString(fieldNumber: 2, value:message)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if (hasLevel) {
                serialize_size += level.rawValue.computeEnumSize(fieldNumber: 1)
            }
            if hasMessage {
                serialize_size += message.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.LogMessage.Builder {
            return Tensorflow.LogMessage.classBuilder() as! Tensorflow.LogMessage.Builder
        }
        public func getBuilder() -> Tensorflow.LogMessage.Builder {
            return classBuilder() as! Tensorflow.LogMessage.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.LogMessage.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.LogMessage.Builder()
        }
        public func toBuilder() throws -> Tensorflow.LogMessage.Builder {
            return try Tensorflow.LogMessage.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.LogMessage) throws -> Tensorflow.LogMessage.Builder {
            return try Tensorflow.LogMessage.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasLevel {
                jsonMap["level"] = level.toString()
            }
            if hasMessage {
                jsonMap["message"] = message
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.LogMessage {
            return try Tensorflow.LogMessage.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.LogMessage {
            return try Tensorflow.LogMessage.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if (hasLevel) {
                output += "\(indent) level: \(level.description)\n"
            }
            if hasMessage {
                output += "\(indent) message: \(message) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasLevel {
                     hashCode = (hashCode &* 31) &+ level.hashValue
                }
                if hasMessage {
                    hashCode = (hashCode &* 31) &+ message.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.LogMessage"
        }
        override public func className() -> String {
            return "Tensorflow.LogMessage"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.LogMessage = Tensorflow.LogMessage()
            public func getMessage() -> Tensorflow.LogMessage {
                return builderResult
            }

            required override public init () {
                super.init()
            }
                public var level:Tensorflow.LogMessage.Level {
                    get {
                        return builderResult.level
                    }
                    set (value) {
                        builderResult.hasLevel = true
                        builderResult.level = value
                    }
                }
                public var hasLevel:Bool{
                    get {
                        return builderResult.hasLevel
                    }
                }
            @discardableResult
                public func setLevel(_ value:Tensorflow.LogMessage.Level) -> Tensorflow.LogMessage.Builder {
                  self.level = value
                  return self
                }
            @discardableResult
                public func clearLevel() -> Tensorflow.LogMessage.Builder {
                   builderResult.hasLevel = false
                   builderResult.level = .unknown
                   return self
                }
            public var message:String {
                get {
                    return builderResult.message
                }
                set (value) {
                    builderResult.hasMessage = true
                    builderResult.message = value
                }
            }
            public var hasMessage:Bool {
                get {
                    return builderResult.hasMessage
                }
            }
            @discardableResult
            public func setMessage(_ value:String) -> Tensorflow.LogMessage.Builder {
                self.message = value
                return self
            }
            @discardableResult
            public func clearMessage() -> Tensorflow.LogMessage.Builder{
                builderResult.hasMessage = false
                builderResult.message = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.LogMessage.Builder {
                builderResult = Tensorflow.LogMessage()
                return self
            }
            override public func clone() throws -> Tensorflow.LogMessage.Builder {
                return try Tensorflow.LogMessage.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.LogMessage {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.LogMessage {
                let returnMe:Tensorflow.LogMessage = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.LogMessage) throws -> Tensorflow.LogMessage.Builder {
                if other == Tensorflow.LogMessage() {
                    return self
                }
                if other.hasLevel {
                    level = other.level
                }
                if other.hasMessage {
                    message = other.message
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.LogMessage.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.LogMessage.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        let valueIntlevel = try codedInputStream.readEnum()
                        if let enumslevel = Tensorflow.LogMessage.Level(rawValue:valueIntlevel){
                            level = enumslevel
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntlevel))
                        }

                    case 18:
                        message = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.LogMessage.Builder {
                let resultDecodedBuilder = Tensorflow.LogMessage.Builder()
                if let jsonValueLevel = jsonMap["level"] as? String {
                    resultDecodedBuilder.level = try Tensorflow.LogMessage.Level.fromString(str: jsonValueLevel)
                }
                if let jsonValueMessage = jsonMap["message"] as? String {
                    resultDecodedBuilder.message = jsonValueMessage
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.LogMessage.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.LogMessage.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Protocol buffer used for logging session state.
    final public class SessionLog : GeneratedMessage {

        public static func == (lhs: Tensorflow.SessionLog, rhs: Tensorflow.SessionLog) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
            fieldCheck = fieldCheck && (lhs.hasCheckpointPath == rhs.hasCheckpointPath) && (!lhs.hasCheckpointPath || lhs.checkpointPath == rhs.checkpointPath)
            fieldCheck = fieldCheck && (lhs.hasMsg == rhs.hasMsg) && (!lhs.hasMsg || lhs.msg == rhs.msg)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



            //Enum type declaration start 

            public enum SessionStatus:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
                case statusUnspecified = 0
                case start = 1
                case stop = 2
                case checkpoint = 3
                public func toString() -> String {
                    switch self {
                    case .statusUnspecified: return "STATUS_UNSPECIFIED"
                    case .start: return "START"
                    case .stop: return "STOP"
                    case .checkpoint: return "CHECKPOINT"
                    }
                }
                public static func fromString(str:String) throws -> Tensorflow.SessionLog.SessionStatus {
                    switch str {
                    case "STATUS_UNSPECIFIED":    return .statusUnspecified
                    case "START":    return .start
                    case "STOP":    return .stop
                    case "CHECKPOINT":    return .checkpoint
                    default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
                    }
                }
                public var debugDescription:String { return getDescription() }
                public var description:String { return getDescription() }
                private func getDescription() -> String { 
                    switch self {
                    case .statusUnspecified: return ".statusUnspecified"
                    case .start: return ".start"
                    case .stop: return ".stop"
                    case .checkpoint: return ".checkpoint"
                    }
                }
                public var hashValue:Int {
                    return self.rawValue.hashValue
                }
                public static func ==(lhs:SessionStatus, rhs:SessionStatus) -> Bool {
                    return lhs.hashValue == rhs.hashValue
                }
            }

            //Enum type declaration end 

        public fileprivate(set) var status:Tensorflow.SessionLog.SessionStatus = Tensorflow.SessionLog.SessionStatus.statusUnspecified
        public fileprivate(set) var hasStatus:Bool = false
        /// This checkpoint_path contains both the path and filename.
        public fileprivate(set) var checkpointPath:String = ""
        public fileprivate(set) var hasCheckpointPath:Bool = false

        public fileprivate(set) var msg:String = ""
        public fileprivate(set) var hasMsg:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasStatus {
                try codedOutputStream.writeEnum(fieldNumber: 1, value:status.rawValue)
            }
            if hasCheckpointPath {
                try codedOutputStream.writeString(fieldNumber: 2, value:checkpointPath)
            }
            if hasMsg {
                try codedOutputStream.writeString(fieldNumber: 3, value:msg)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if (hasStatus) {
                serialize_size += status.rawValue.computeEnumSize(fieldNumber: 1)
            }
            if hasCheckpointPath {
                serialize_size += checkpointPath.computeStringSize(fieldNumber: 2)
            }
            if hasMsg {
                serialize_size += msg.computeStringSize(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.SessionLog.Builder {
            return Tensorflow.SessionLog.classBuilder() as! Tensorflow.SessionLog.Builder
        }
        public func getBuilder() -> Tensorflow.SessionLog.Builder {
            return classBuilder() as! Tensorflow.SessionLog.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.SessionLog.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.SessionLog.Builder()
        }
        public func toBuilder() throws -> Tensorflow.SessionLog.Builder {
            return try Tensorflow.SessionLog.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.SessionLog) throws -> Tensorflow.SessionLog.Builder {
            return try Tensorflow.SessionLog.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasStatus {
                jsonMap["status"] = status.toString()
            }
            if hasCheckpointPath {
                jsonMap["checkpointPath"] = checkpointPath
            }
            if hasMsg {
                jsonMap["msg"] = msg
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.SessionLog {
            return try Tensorflow.SessionLog.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.SessionLog {
            return try Tensorflow.SessionLog.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if (hasStatus) {
                output += "\(indent) status: \(status.description)\n"
            }
            if hasCheckpointPath {
                output += "\(indent) checkpointPath: \(checkpointPath) \n"
            }
            if hasMsg {
                output += "\(indent) msg: \(msg) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasStatus {
                     hashCode = (hashCode &* 31) &+ status.hashValue
                }
                if hasCheckpointPath {
                    hashCode = (hashCode &* 31) &+ checkpointPath.hashValue
                }
                if hasMsg {
                    hashCode = (hashCode &* 31) &+ msg.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.SessionLog"
        }
        override public func className() -> String {
            return "Tensorflow.SessionLog"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.SessionLog = Tensorflow.SessionLog()
            public func getMessage() -> Tensorflow.SessionLog {
                return builderResult
            }

            required override public init () {
                super.init()
            }
                public var status:Tensorflow.SessionLog.SessionStatus {
                    get {
                        return builderResult.status
                    }
                    set (value) {
                        builderResult.hasStatus = true
                        builderResult.status = value
                    }
                }
                public var hasStatus:Bool{
                    get {
                        return builderResult.hasStatus
                    }
                }
            @discardableResult
                public func setStatus(_ value:Tensorflow.SessionLog.SessionStatus) -> Tensorflow.SessionLog.Builder {
                  self.status = value
                  return self
                }
            @discardableResult
                public func clearStatus() -> Tensorflow.SessionLog.Builder {
                   builderResult.hasStatus = false
                   builderResult.status = .statusUnspecified
                   return self
                }
            /// This checkpoint_path contains both the path and filename.
            public var checkpointPath:String {
                get {
                    return builderResult.checkpointPath
                }
                set (value) {
                    builderResult.hasCheckpointPath = true
                    builderResult.checkpointPath = value
                }
            }
            public var hasCheckpointPath:Bool {
                get {
                    return builderResult.hasCheckpointPath
                }
            }
            @discardableResult
            public func setCheckpointPath(_ value:String) -> Tensorflow.SessionLog.Builder {
                self.checkpointPath = value
                return self
            }
            @discardableResult
            public func clearCheckpointPath() -> Tensorflow.SessionLog.Builder{
                builderResult.hasCheckpointPath = false
                builderResult.checkpointPath = ""
                return self
            }
            public var msg:String {
                get {
                    return builderResult.msg
                }
                set (value) {
                    builderResult.hasMsg = true
                    builderResult.msg = value
                }
            }
            public var hasMsg:Bool {
                get {
                    return builderResult.hasMsg
                }
            }
            @discardableResult
            public func setMsg(_ value:String) -> Tensorflow.SessionLog.Builder {
                self.msg = value
                return self
            }
            @discardableResult
            public func clearMsg() -> Tensorflow.SessionLog.Builder{
                builderResult.hasMsg = false
                builderResult.msg = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.SessionLog.Builder {
                builderResult = Tensorflow.SessionLog()
                return self
            }
            override public func clone() throws -> Tensorflow.SessionLog.Builder {
                return try Tensorflow.SessionLog.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.SessionLog {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.SessionLog {
                let returnMe:Tensorflow.SessionLog = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.SessionLog) throws -> Tensorflow.SessionLog.Builder {
                if other == Tensorflow.SessionLog() {
                    return self
                }
                if other.hasStatus {
                    status = other.status
                }
                if other.hasCheckpointPath {
                    checkpointPath = other.checkpointPath
                }
                if other.hasMsg {
                    msg = other.msg
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.SessionLog.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.SessionLog.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        let valueIntstatus = try codedInputStream.readEnum()
                        if let enumsstatus = Tensorflow.SessionLog.SessionStatus(rawValue:valueIntstatus){
                            status = enumsstatus
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntstatus))
                        }

                    case 18:
                        checkpointPath = try codedInputStream.readString()

                    case 26:
                        msg = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.SessionLog.Builder {
                let resultDecodedBuilder = Tensorflow.SessionLog.Builder()
                if let jsonValueStatus = jsonMap["status"] as? String {
                    resultDecodedBuilder.status = try Tensorflow.SessionLog.SessionStatus.fromString(str: jsonValueStatus)
                }
                if let jsonValueCheckpointPath = jsonMap["checkpointPath"] as? String {
                    resultDecodedBuilder.checkpointPath = jsonValueCheckpointPath
                }
                if let jsonValueMsg = jsonMap["msg"] as? String {
                    resultDecodedBuilder.msg = jsonValueMsg
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.SessionLog.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.SessionLog.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// For logging the metadata output for a single session.run() call.
    final public class TaggedRunMetadata : GeneratedMessage {

        public static func == (lhs: Tensorflow.TaggedRunMetadata, rhs: Tensorflow.TaggedRunMetadata) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasTag == rhs.hasTag) && (!lhs.hasTag || lhs.tag == rhs.tag)
            fieldCheck = fieldCheck && (lhs.hasRunMetadata == rhs.hasRunMetadata) && (!lhs.hasRunMetadata || lhs.runMetadata == rhs.runMetadata)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Tag name associated with this metadata.
        public fileprivate(set) var tag:String = ""
        public fileprivate(set) var hasTag:Bool = false

        /// Byte-encoded version of the `RunMetadata` proto in order to allow lazy
        /// deserialization.
        public fileprivate(set) var runMetadata:Data = Data()
        public fileprivate(set) var hasRunMetadata:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasTag {
                try codedOutputStream.writeString(fieldNumber: 1, value:tag)
            }
            if hasRunMetadata {
                try codedOutputStream.writeData(fieldNumber: 2, value:runMetadata)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasTag {
                serialize_size += tag.computeStringSize(fieldNumber: 1)
            }
            if hasRunMetadata {
                serialize_size += runMetadata.computeDataSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.TaggedRunMetadata.Builder {
            return Tensorflow.TaggedRunMetadata.classBuilder() as! Tensorflow.TaggedRunMetadata.Builder
        }
        public func getBuilder() -> Tensorflow.TaggedRunMetadata.Builder {
            return classBuilder() as! Tensorflow.TaggedRunMetadata.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.TaggedRunMetadata.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.TaggedRunMetadata.Builder()
        }
        public func toBuilder() throws -> Tensorflow.TaggedRunMetadata.Builder {
            return try Tensorflow.TaggedRunMetadata.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.TaggedRunMetadata) throws -> Tensorflow.TaggedRunMetadata.Builder {
            return try Tensorflow.TaggedRunMetadata.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasTag {
                jsonMap["tag"] = tag
            }
            if hasRunMetadata {
                jsonMap["runMetadata"] = runMetadata.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.TaggedRunMetadata {
            return try Tensorflow.TaggedRunMetadata.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.TaggedRunMetadata {
            return try Tensorflow.TaggedRunMetadata.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasTag {
                output += "\(indent) tag: \(tag) \n"
            }
            if hasRunMetadata {
                output += "\(indent) runMetadata: \(runMetadata) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasTag {
                    hashCode = (hashCode &* 31) &+ tag.hashValue
                }
                if hasRunMetadata {
                    hashCode = (hashCode &* 31) &+ runMetadata.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.TaggedRunMetadata"
        }
        override public func className() -> String {
            return "Tensorflow.TaggedRunMetadata"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.TaggedRunMetadata = Tensorflow.TaggedRunMetadata()
            public func getMessage() -> Tensorflow.TaggedRunMetadata {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Tag name associated with this metadata.
            public var tag:String {
                get {
                    return builderResult.tag
                }
                set (value) {
                    builderResult.hasTag = true
                    builderResult.tag = value
                }
            }
            public var hasTag:Bool {
                get {
                    return builderResult.hasTag
                }
            }
            @discardableResult
            public func setTag(_ value:String) -> Tensorflow.TaggedRunMetadata.Builder {
                self.tag = value
                return self
            }
            @discardableResult
            public func clearTag() -> Tensorflow.TaggedRunMetadata.Builder{
                builderResult.hasTag = false
                builderResult.tag = ""
                return self
            }
            /// Byte-encoded version of the `RunMetadata` proto in order to allow lazy
            /// deserialization.
            public var runMetadata:Data {
                get {
                    return builderResult.runMetadata
                }
                set (value) {
                    builderResult.hasRunMetadata = true
                    builderResult.runMetadata = value
                }
            }
            public var hasRunMetadata:Bool {
                get {
                    return builderResult.hasRunMetadata
                }
            }
            @discardableResult
            public func setRunMetadata(_ value:Data) -> Tensorflow.TaggedRunMetadata.Builder {
                self.runMetadata = value
                return self
            }
            @discardableResult
            public func clearRunMetadata() -> Tensorflow.TaggedRunMetadata.Builder{
                builderResult.hasRunMetadata = false
                builderResult.runMetadata = Data()
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.TaggedRunMetadata.Builder {
                builderResult = Tensorflow.TaggedRunMetadata()
                return self
            }
            override public func clone() throws -> Tensorflow.TaggedRunMetadata.Builder {
                return try Tensorflow.TaggedRunMetadata.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.TaggedRunMetadata {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.TaggedRunMetadata {
                let returnMe:Tensorflow.TaggedRunMetadata = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.TaggedRunMetadata) throws -> Tensorflow.TaggedRunMetadata.Builder {
                if other == Tensorflow.TaggedRunMetadata() {
                    return self
                }
                if other.hasTag {
                    tag = other.tag
                }
                if other.hasRunMetadata {
                    runMetadata = other.runMetadata
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.TaggedRunMetadata.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.TaggedRunMetadata.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        tag = try codedInputStream.readString()

                    case 18:
                        runMetadata = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.TaggedRunMetadata.Builder {
                let resultDecodedBuilder = Tensorflow.TaggedRunMetadata.Builder()
                if let jsonValueTag = jsonMap["tag"] as? String {
                    resultDecodedBuilder.tag = jsonValueTag
                }
                if let jsonValueRunMetadata = jsonMap["runMetadata"] as? String {
                    resultDecodedBuilder.runMetadata = Data(base64Encoded:jsonValueRunMetadata, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.TaggedRunMetadata.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.TaggedRunMetadata.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.Event: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Event> {
        var mergedArray = Array<Tensorflow.Event>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Event? {
        return try Tensorflow.Event.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Event {
        return try Tensorflow.Event.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.EventRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Event {
        return try Tensorflow.Event.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Event {
        return try Tensorflow.Event.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Event {
        return try Tensorflow.Event.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Event {
        return try Tensorflow.Event.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Event {
        return try Tensorflow.Event.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "wallTime": return self.wallTime
        case "step": return self.step
        case "fileVersion": return self.fileVersion
        case "graphDef": return self.graphDef
        case "summary": return self.summary
        case "logMessage": return self.logMessage
        case "sessionLog": return self.sessionLog
        case "taggedRunMetadata": return self.taggedRunMetadata
        case "metaGraphDef": return self.metaGraphDef
        default: return nil
        }
    }
}
extension Tensorflow.Event.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "wallTime": return self.wallTime
            case "step": return self.step
            case "fileVersion": return self.fileVersion
            case "graphDef": return self.graphDef
            case "summary": return self.summary
            case "logMessage": return self.logMessage
            case "sessionLog": return self.sessionLog
            case "taggedRunMetadata": return self.taggedRunMetadata
            case "metaGraphDef": return self.metaGraphDef
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "wallTime":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.wallTime = newSubscriptValue
            case "step":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.step = newSubscriptValue
            case "fileVersion":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.fileVersion = newSubscriptValue
            case "graphDef":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.graphDef = newSubscriptValue
            case "summary":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Summary else {
                    return
                }
                self.summary = newSubscriptValue
            case "logMessage":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.LogMessage else {
                    return
                }
                self.logMessage = newSubscriptValue
            case "sessionLog":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.SessionLog else {
                    return
                }
                self.sessionLog = newSubscriptValue
            case "taggedRunMetadata":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.TaggedRunMetadata else {
                    return
                }
                self.taggedRunMetadata = newSubscriptValue
            case "metaGraphDef":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.metaGraphDef = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.LogMessage: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.LogMessage> {
        var mergedArray = Array<Tensorflow.LogMessage>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.LogMessage? {
        return try Tensorflow.LogMessage.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.LogMessage {
        return try Tensorflow.LogMessage.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.EventRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.LogMessage {
        return try Tensorflow.LogMessage.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.LogMessage {
        return try Tensorflow.LogMessage.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.LogMessage {
        return try Tensorflow.LogMessage.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.LogMessage {
        return try Tensorflow.LogMessage.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.LogMessage {
        return try Tensorflow.LogMessage.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "level": return self.level
        case "message": return self.message
        default: return nil
        }
    }
}
extension Tensorflow.LogMessage.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "level": return self.level
            case "message": return self.message
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "level":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.LogMessage.Level else {
                    return
                }
                self.level = newSubscriptValue
            case "message":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.message = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.SessionLog: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.SessionLog> {
        var mergedArray = Array<Tensorflow.SessionLog>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.SessionLog? {
        return try Tensorflow.SessionLog.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.SessionLog {
        return try Tensorflow.SessionLog.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.EventRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.SessionLog {
        return try Tensorflow.SessionLog.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.SessionLog {
        return try Tensorflow.SessionLog.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.SessionLog {
        return try Tensorflow.SessionLog.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.SessionLog {
        return try Tensorflow.SessionLog.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.SessionLog {
        return try Tensorflow.SessionLog.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "status": return self.status
        case "checkpointPath": return self.checkpointPath
        case "msg": return self.msg
        default: return nil
        }
    }
}
extension Tensorflow.SessionLog.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "status": return self.status
            case "checkpointPath": return self.checkpointPath
            case "msg": return self.msg
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "status":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.SessionLog.SessionStatus else {
                    return
                }
                self.status = newSubscriptValue
            case "checkpointPath":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.checkpointPath = newSubscriptValue
            case "msg":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.msg = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.TaggedRunMetadata: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.TaggedRunMetadata> {
        var mergedArray = Array<Tensorflow.TaggedRunMetadata>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.TaggedRunMetadata? {
        return try Tensorflow.TaggedRunMetadata.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.TaggedRunMetadata {
        return try Tensorflow.TaggedRunMetadata.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.EventRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.TaggedRunMetadata {
        return try Tensorflow.TaggedRunMetadata.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.TaggedRunMetadata {
        return try Tensorflow.TaggedRunMetadata.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.TaggedRunMetadata {
        return try Tensorflow.TaggedRunMetadata.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.TaggedRunMetadata {
        return try Tensorflow.TaggedRunMetadata.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.TaggedRunMetadata {
        return try Tensorflow.TaggedRunMetadata.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "tag": return self.tag
        case "runMetadata": return self.runMetadata
        default: return nil
        }
    }
}
extension Tensorflow.TaggedRunMetadata.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "tag": return self.tag
            case "runMetadata": return self.runMetadata
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "tag":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.tag = newSubscriptValue
            case "runMetadata":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.runMetadata = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

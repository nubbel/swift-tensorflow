/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "verbs_service.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { }

public extension Tensorflow {
    public struct VerbsServiceRoot {
        public static let `default` = VerbsServiceRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    final public class Channel : GeneratedMessage {

        public static func == (lhs: Tensorflow.Channel, rhs: Tensorflow.Channel) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasLid == rhs.hasLid) && (!lhs.hasLid || lhs.lid == rhs.lid)
            fieldCheck = fieldCheck && (lhs.hasQpn == rhs.hasQpn) && (!lhs.hasQpn || lhs.qpn == rhs.qpn)
            fieldCheck = fieldCheck && (lhs.hasPsn == rhs.hasPsn) && (!lhs.hasPsn || lhs.psn == rhs.psn)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var lid:Int32 = Int32(0)
        public fileprivate(set) var hasLid:Bool = false

        public fileprivate(set) var qpn:Int32 = Int32(0)
        public fileprivate(set) var hasQpn:Bool = false

        public fileprivate(set) var psn:Int32 = Int32(0)
        public fileprivate(set) var hasPsn:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasLid {
                try codedOutputStream.writeInt32(fieldNumber: 1, value:lid)
            }
            if hasQpn {
                try codedOutputStream.writeInt32(fieldNumber: 2, value:qpn)
            }
            if hasPsn {
                try codedOutputStream.writeInt32(fieldNumber: 3, value:psn)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasLid {
                serialize_size += lid.computeInt32Size(fieldNumber: 1)
            }
            if hasQpn {
                serialize_size += qpn.computeInt32Size(fieldNumber: 2)
            }
            if hasPsn {
                serialize_size += psn.computeInt32Size(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.Channel.Builder {
            return Tensorflow.Channel.classBuilder() as! Tensorflow.Channel.Builder
        }
        public func getBuilder() -> Tensorflow.Channel.Builder {
            return classBuilder() as! Tensorflow.Channel.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Channel.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Channel.Builder()
        }
        public func toBuilder() throws -> Tensorflow.Channel.Builder {
            return try Tensorflow.Channel.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.Channel) throws -> Tensorflow.Channel.Builder {
            return try Tensorflow.Channel.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasLid {
                jsonMap["lid"] = Int(lid)
            }
            if hasQpn {
                jsonMap["qpn"] = Int(qpn)
            }
            if hasPsn {
                jsonMap["psn"] = Int(psn)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Channel {
            return try Tensorflow.Channel.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.Channel {
            return try Tensorflow.Channel.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasLid {
                output += "\(indent) lid: \(lid) \n"
            }
            if hasQpn {
                output += "\(indent) qpn: \(qpn) \n"
            }
            if hasPsn {
                output += "\(indent) psn: \(psn) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasLid {
                    hashCode = (hashCode &* 31) &+ lid.hashValue
                }
                if hasQpn {
                    hashCode = (hashCode &* 31) &+ qpn.hashValue
                }
                if hasPsn {
                    hashCode = (hashCode &* 31) &+ psn.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.Channel"
        }
        override public func className() -> String {
            return "Tensorflow.Channel"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.Channel = Tensorflow.Channel()
            public func getMessage() -> Tensorflow.Channel {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var lid:Int32 {
                get {
                    return builderResult.lid
                }
                set (value) {
                    builderResult.hasLid = true
                    builderResult.lid = value
                }
            }
            public var hasLid:Bool {
                get {
                    return builderResult.hasLid
                }
            }
            @discardableResult
            public func setLid(_ value:Int32) -> Tensorflow.Channel.Builder {
                self.lid = value
                return self
            }
            @discardableResult
            public func clearLid() -> Tensorflow.Channel.Builder{
                builderResult.hasLid = false
                builderResult.lid = Int32(0)
                return self
            }
            public var qpn:Int32 {
                get {
                    return builderResult.qpn
                }
                set (value) {
                    builderResult.hasQpn = true
                    builderResult.qpn = value
                }
            }
            public var hasQpn:Bool {
                get {
                    return builderResult.hasQpn
                }
            }
            @discardableResult
            public func setQpn(_ value:Int32) -> Tensorflow.Channel.Builder {
                self.qpn = value
                return self
            }
            @discardableResult
            public func clearQpn() -> Tensorflow.Channel.Builder{
                builderResult.hasQpn = false
                builderResult.qpn = Int32(0)
                return self
            }
            public var psn:Int32 {
                get {
                    return builderResult.psn
                }
                set (value) {
                    builderResult.hasPsn = true
                    builderResult.psn = value
                }
            }
            public var hasPsn:Bool {
                get {
                    return builderResult.hasPsn
                }
            }
            @discardableResult
            public func setPsn(_ value:Int32) -> Tensorflow.Channel.Builder {
                self.psn = value
                return self
            }
            @discardableResult
            public func clearPsn() -> Tensorflow.Channel.Builder{
                builderResult.hasPsn = false
                builderResult.psn = Int32(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.Channel.Builder {
                builderResult = Tensorflow.Channel()
                return self
            }
            override public func clone() throws -> Tensorflow.Channel.Builder {
                return try Tensorflow.Channel.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.Channel {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.Channel {
                let returnMe:Tensorflow.Channel = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.Channel) throws -> Tensorflow.Channel.Builder {
                if other == Tensorflow.Channel() {
                    return self
                }
                if other.hasLid {
                    lid = other.lid
                }
                if other.hasQpn {
                    qpn = other.qpn
                }
                if other.hasPsn {
                    psn = other.psn
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Channel.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Channel.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        lid = try codedInputStream.readInt32()

                    case 16:
                        qpn = try codedInputStream.readInt32()

                    case 24:
                        psn = try codedInputStream.readInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Channel.Builder {
                let resultDecodedBuilder = Tensorflow.Channel.Builder()
                if let jsonValueLid = jsonMap["lid"] as? Int {
                    resultDecodedBuilder.lid = Int32(jsonValueLid)
                } else if let jsonValueLid = jsonMap["lid"] as? String {
                    resultDecodedBuilder.lid = Int32(jsonValueLid)!
                }
                if let jsonValueQpn = jsonMap["qpn"] as? Int {
                    resultDecodedBuilder.qpn = Int32(jsonValueQpn)
                } else if let jsonValueQpn = jsonMap["qpn"] as? String {
                    resultDecodedBuilder.qpn = Int32(jsonValueQpn)!
                }
                if let jsonValuePsn = jsonMap["psn"] as? Int {
                    resultDecodedBuilder.psn = Int32(jsonValuePsn)
                } else if let jsonValuePsn = jsonMap["psn"] as? String {
                    resultDecodedBuilder.psn = Int32(jsonValuePsn)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Channel.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.Channel.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class MemoryRegion : GeneratedMessage {

        public static func == (lhs: Tensorflow.MemoryRegion, rhs: Tensorflow.MemoryRegion) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasRemoteAddr == rhs.hasRemoteAddr) && (!lhs.hasRemoteAddr || lhs.remoteAddr == rhs.remoteAddr)
            fieldCheck = fieldCheck && (lhs.hasRkey == rhs.hasRkey) && (!lhs.hasRkey || lhs.rkey == rhs.rkey)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var remoteAddr:UInt64 = UInt64(0)
        public fileprivate(set) var hasRemoteAddr:Bool = false

        public fileprivate(set) var rkey:UInt32 = UInt32(0)
        public fileprivate(set) var hasRkey:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasRemoteAddr {
                try codedOutputStream.writeUInt64(fieldNumber: 1, value:remoteAddr)
            }
            if hasRkey {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:rkey)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasRemoteAddr {
                serialize_size += remoteAddr.computeUInt64Size(fieldNumber: 1)
            }
            if hasRkey {
                serialize_size += rkey.computeUInt32Size(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.MemoryRegion.Builder {
            return Tensorflow.MemoryRegion.classBuilder() as! Tensorflow.MemoryRegion.Builder
        }
        public func getBuilder() -> Tensorflow.MemoryRegion.Builder {
            return classBuilder() as! Tensorflow.MemoryRegion.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.MemoryRegion.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.MemoryRegion.Builder()
        }
        public func toBuilder() throws -> Tensorflow.MemoryRegion.Builder {
            return try Tensorflow.MemoryRegion.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.MemoryRegion) throws -> Tensorflow.MemoryRegion.Builder {
            return try Tensorflow.MemoryRegion.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasRemoteAddr {
                jsonMap["remoteAddr"] = "\(remoteAddr)"
            }
            if hasRkey {
                jsonMap["rkey"] = UInt(rkey)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.MemoryRegion {
            return try Tensorflow.MemoryRegion.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.MemoryRegion {
            return try Tensorflow.MemoryRegion.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasRemoteAddr {
                output += "\(indent) remoteAddr: \(remoteAddr) \n"
            }
            if hasRkey {
                output += "\(indent) rkey: \(rkey) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasRemoteAddr {
                    hashCode = (hashCode &* 31) &+ remoteAddr.hashValue
                }
                if hasRkey {
                    hashCode = (hashCode &* 31) &+ rkey.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.MemoryRegion"
        }
        override public func className() -> String {
            return "Tensorflow.MemoryRegion"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.MemoryRegion = Tensorflow.MemoryRegion()
            public func getMessage() -> Tensorflow.MemoryRegion {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var remoteAddr:UInt64 {
                get {
                    return builderResult.remoteAddr
                }
                set (value) {
                    builderResult.hasRemoteAddr = true
                    builderResult.remoteAddr = value
                }
            }
            public var hasRemoteAddr:Bool {
                get {
                    return builderResult.hasRemoteAddr
                }
            }
            @discardableResult
            public func setRemoteAddr(_ value:UInt64) -> Tensorflow.MemoryRegion.Builder {
                self.remoteAddr = value
                return self
            }
            @discardableResult
            public func clearRemoteAddr() -> Tensorflow.MemoryRegion.Builder{
                builderResult.hasRemoteAddr = false
                builderResult.remoteAddr = UInt64(0)
                return self
            }
            public var rkey:UInt32 {
                get {
                    return builderResult.rkey
                }
                set (value) {
                    builderResult.hasRkey = true
                    builderResult.rkey = value
                }
            }
            public var hasRkey:Bool {
                get {
                    return builderResult.hasRkey
                }
            }
            @discardableResult
            public func setRkey(_ value:UInt32) -> Tensorflow.MemoryRegion.Builder {
                self.rkey = value
                return self
            }
            @discardableResult
            public func clearRkey() -> Tensorflow.MemoryRegion.Builder{
                builderResult.hasRkey = false
                builderResult.rkey = UInt32(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.MemoryRegion.Builder {
                builderResult = Tensorflow.MemoryRegion()
                return self
            }
            override public func clone() throws -> Tensorflow.MemoryRegion.Builder {
                return try Tensorflow.MemoryRegion.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.MemoryRegion {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.MemoryRegion {
                let returnMe:Tensorflow.MemoryRegion = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.MemoryRegion) throws -> Tensorflow.MemoryRegion.Builder {
                if other == Tensorflow.MemoryRegion() {
                    return self
                }
                if other.hasRemoteAddr {
                    remoteAddr = other.remoteAddr
                }
                if other.hasRkey {
                    rkey = other.rkey
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.MemoryRegion.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryRegion.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        remoteAddr = try codedInputStream.readUInt64()

                    case 16:
                        rkey = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.MemoryRegion.Builder {
                let resultDecodedBuilder = Tensorflow.MemoryRegion.Builder()
                if let jsonValueRemoteAddr = jsonMap["remoteAddr"] as? String {
                    resultDecodedBuilder.remoteAddr = UInt64(jsonValueRemoteAddr)!
                } else if let jsonValueRemoteAddr = jsonMap["remoteAddr"] as? UInt {
                    resultDecodedBuilder.remoteAddr = UInt64(jsonValueRemoteAddr)
                }
                if let jsonValueRkey = jsonMap["rkey"] as? UInt {
                    resultDecodedBuilder.rkey = UInt32(jsonValueRkey)
                } else if let jsonValueRkey = jsonMap["rkey"] as? String {
                    resultDecodedBuilder.rkey = UInt32(jsonValueRkey)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.MemoryRegion.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.MemoryRegion.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class GetRemoteAddressRequest : GeneratedMessage {

        public static func == (lhs: Tensorflow.GetRemoteAddressRequest, rhs: Tensorflow.GetRemoteAddressRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasHostName == rhs.hasHostName) && (!lhs.hasHostName || lhs.hostName == rhs.hostName)
            fieldCheck = fieldCheck && (lhs.hasChannel == rhs.hasChannel) && (!lhs.hasChannel || lhs.channel == rhs.channel)
            fieldCheck = fieldCheck && (lhs.mr == rhs.mr)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var hostName:String = ""
        public fileprivate(set) var hasHostName:Bool = false

        public fileprivate(set) var channel:Tensorflow.Channel!
        public fileprivate(set) var hasChannel:Bool = false
        public fileprivate(set) var mr:Array<Tensorflow.MemoryRegion>  = Array<Tensorflow.MemoryRegion>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasHostName {
                try codedOutputStream.writeString(fieldNumber: 1, value:hostName)
            }
            if hasChannel {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:channel)
            }
            for oneElementMr in mr {
                  try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementMr)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasHostName {
                serialize_size += hostName.computeStringSize(fieldNumber: 1)
            }
            if hasChannel {
                if let varSizechannel = channel?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizechannel
                }
            }
            for oneElementMr in mr {
                serialize_size += oneElementMr.computeMessageSize(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.GetRemoteAddressRequest.Builder {
            return Tensorflow.GetRemoteAddressRequest.classBuilder() as! Tensorflow.GetRemoteAddressRequest.Builder
        }
        public func getBuilder() -> Tensorflow.GetRemoteAddressRequest.Builder {
            return classBuilder() as! Tensorflow.GetRemoteAddressRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.GetRemoteAddressRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.GetRemoteAddressRequest.Builder()
        }
        public func toBuilder() throws -> Tensorflow.GetRemoteAddressRequest.Builder {
            return try Tensorflow.GetRemoteAddressRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.GetRemoteAddressRequest) throws -> Tensorflow.GetRemoteAddressRequest.Builder {
            return try Tensorflow.GetRemoteAddressRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasHostName {
                jsonMap["hostName"] = hostName
            }
            if hasChannel {
                jsonMap["channel"] = try channel.encode()
            }
            if !mr.isEmpty {
                var jsonArrayMr:Array<Dictionary<String,Any>> = []
                for oneValueMr in mr {
                    let ecodedMessageMr = try oneValueMr.encode()
                    jsonArrayMr.append(ecodedMessageMr)
                }
                jsonMap["mr"] = jsonArrayMr
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.GetRemoteAddressRequest {
            return try Tensorflow.GetRemoteAddressRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.GetRemoteAddressRequest {
            return try Tensorflow.GetRemoteAddressRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasHostName {
                output += "\(indent) hostName: \(hostName) \n"
            }
            if hasChannel {
                output += "\(indent) channel {\n"
                if let outDescChannel = channel {
                    output += try outDescChannel.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            var mrElementIndex:Int = 0
            for oneElementMr in mr {
                output += "\(indent) mr[\(mrElementIndex)] {\n"
                output += try oneElementMr.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                mrElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasHostName {
                    hashCode = (hashCode &* 31) &+ hostName.hashValue
                }
                if hasChannel {
                    if let hashValuechannel = channel?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuechannel
                    }
                }
                for oneElementMr in mr {
                    hashCode = (hashCode &* 31) &+ oneElementMr.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.GetRemoteAddressRequest"
        }
        override public func className() -> String {
            return "Tensorflow.GetRemoteAddressRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.GetRemoteAddressRequest = Tensorflow.GetRemoteAddressRequest()
            public func getMessage() -> Tensorflow.GetRemoteAddressRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var hostName:String {
                get {
                    return builderResult.hostName
                }
                set (value) {
                    builderResult.hasHostName = true
                    builderResult.hostName = value
                }
            }
            public var hasHostName:Bool {
                get {
                    return builderResult.hasHostName
                }
            }
            @discardableResult
            public func setHostName(_ value:String) -> Tensorflow.GetRemoteAddressRequest.Builder {
                self.hostName = value
                return self
            }
            @discardableResult
            public func clearHostName() -> Tensorflow.GetRemoteAddressRequest.Builder{
                builderResult.hasHostName = false
                builderResult.hostName = ""
                return self
            }
            public var channel:Tensorflow.Channel! {
                get {
                    if channelBuilder_ != nil {
                        builderResult.channel = channelBuilder_.getMessage()
                    }
                    return builderResult.channel
                }
                set (value) {
                    builderResult.hasChannel = true
                    builderResult.channel = value
                }
            }
            public var hasChannel:Bool {
                get {
                    return builderResult.hasChannel
                }
            }
            fileprivate var channelBuilder_:Tensorflow.Channel.Builder! {
                didSet {
                    builderResult.hasChannel = true
                }
            }
            public func getChannelBuilder() -> Tensorflow.Channel.Builder {
                if channelBuilder_ == nil {
                    channelBuilder_ = Tensorflow.Channel.Builder()
                    builderResult.channel = channelBuilder_.getMessage()
                    if channel != nil {
                        try! channelBuilder_.mergeFrom(other: channel)
                    }
                }
                return channelBuilder_
            }
            @discardableResult
            public func setChannel(_ value:Tensorflow.Channel!) -> Tensorflow.GetRemoteAddressRequest.Builder {
                self.channel = value
                return self
            }
            @discardableResult
            public func mergeChannel(value:Tensorflow.Channel) throws -> Tensorflow.GetRemoteAddressRequest.Builder {
                if builderResult.hasChannel {
                    builderResult.channel = try Tensorflow.Channel.builderWithPrototype(prototype:builderResult.channel).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.channel = value
                }
                builderResult.hasChannel = true
                return self
            }
            @discardableResult
            public func clearChannel() -> Tensorflow.GetRemoteAddressRequest.Builder {
                channelBuilder_ = nil
                builderResult.hasChannel = false
                builderResult.channel = nil
                return self
            }
            public var mr:Array<Tensorflow.MemoryRegion> {
                get {
                    return builderResult.mr
                }
                set (value) {
                    builderResult.mr = value
                }
            }
            @discardableResult
            public func setMr(_ value:Array<Tensorflow.MemoryRegion>) -> Tensorflow.GetRemoteAddressRequest.Builder {
                self.mr = value
                return self
            }
            @discardableResult
            public func clearMr() -> Tensorflow.GetRemoteAddressRequest.Builder {
                builderResult.mr.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.GetRemoteAddressRequest.Builder {
                builderResult = Tensorflow.GetRemoteAddressRequest()
                return self
            }
            override public func clone() throws -> Tensorflow.GetRemoteAddressRequest.Builder {
                return try Tensorflow.GetRemoteAddressRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.GetRemoteAddressRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.GetRemoteAddressRequest {
                let returnMe:Tensorflow.GetRemoteAddressRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.GetRemoteAddressRequest) throws -> Tensorflow.GetRemoteAddressRequest.Builder {
                if other == Tensorflow.GetRemoteAddressRequest() {
                    return self
                }
                if other.hasHostName {
                    hostName = other.hostName
                }
                if (other.hasChannel) {
                    try mergeChannel(value: other.channel)
                }
                if !other.mr.isEmpty  {
                     builderResult.mr += other.mr
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.GetRemoteAddressRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GetRemoteAddressRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        hostName = try codedInputStream.readString()

                    case 18:
                        let subBuilder:Tensorflow.Channel.Builder = Tensorflow.Channel.Builder()
                        if hasChannel {
                            try subBuilder.mergeFrom(other: channel)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        channel = subBuilder.buildPartial()

                    case 26:
                        let subBuilder = Tensorflow.MemoryRegion.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        mr.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.GetRemoteAddressRequest.Builder {
                let resultDecodedBuilder = Tensorflow.GetRemoteAddressRequest.Builder()
                if let jsonValueHostName = jsonMap["hostName"] as? String {
                    resultDecodedBuilder.hostName = jsonValueHostName
                }
                if let jsonValueChannel = jsonMap["channel"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.channel = try Tensorflow.Channel.Builder.decodeToBuilder(jsonMap:jsonValueChannel).build()

                }
                if let jsonValueMr = jsonMap["mr"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayMr:Array<Tensorflow.MemoryRegion> = []
                    for oneValueMr in jsonValueMr {
                        let messageFromStringMr = try Tensorflow.MemoryRegion.Builder.decodeToBuilder(jsonMap:oneValueMr).build()

                        jsonArrayMr.append(messageFromStringMr)
                    }
                    resultDecodedBuilder.mr = jsonArrayMr
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.GetRemoteAddressRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.GetRemoteAddressRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class GetRemoteAddressResponse : GeneratedMessage {

        public static func == (lhs: Tensorflow.GetRemoteAddressResponse, rhs: Tensorflow.GetRemoteAddressResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasHostName == rhs.hasHostName) && (!lhs.hasHostName || lhs.hostName == rhs.hostName)
            fieldCheck = fieldCheck && (lhs.hasChannel == rhs.hasChannel) && (!lhs.hasChannel || lhs.channel == rhs.channel)
            fieldCheck = fieldCheck && (lhs.mr == rhs.mr)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var hostName:String = ""
        public fileprivate(set) var hasHostName:Bool = false

        public fileprivate(set) var channel:Tensorflow.Channel!
        public fileprivate(set) var hasChannel:Bool = false
        public fileprivate(set) var mr:Array<Tensorflow.MemoryRegion>  = Array<Tensorflow.MemoryRegion>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasHostName {
                try codedOutputStream.writeString(fieldNumber: 1, value:hostName)
            }
            if hasChannel {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:channel)
            }
            for oneElementMr in mr {
                  try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementMr)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasHostName {
                serialize_size += hostName.computeStringSize(fieldNumber: 1)
            }
            if hasChannel {
                if let varSizechannel = channel?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizechannel
                }
            }
            for oneElementMr in mr {
                serialize_size += oneElementMr.computeMessageSize(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.GetRemoteAddressResponse.Builder {
            return Tensorflow.GetRemoteAddressResponse.classBuilder() as! Tensorflow.GetRemoteAddressResponse.Builder
        }
        public func getBuilder() -> Tensorflow.GetRemoteAddressResponse.Builder {
            return classBuilder() as! Tensorflow.GetRemoteAddressResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.GetRemoteAddressResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.GetRemoteAddressResponse.Builder()
        }
        public func toBuilder() throws -> Tensorflow.GetRemoteAddressResponse.Builder {
            return try Tensorflow.GetRemoteAddressResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.GetRemoteAddressResponse) throws -> Tensorflow.GetRemoteAddressResponse.Builder {
            return try Tensorflow.GetRemoteAddressResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasHostName {
                jsonMap["hostName"] = hostName
            }
            if hasChannel {
                jsonMap["channel"] = try channel.encode()
            }
            if !mr.isEmpty {
                var jsonArrayMr:Array<Dictionary<String,Any>> = []
                for oneValueMr in mr {
                    let ecodedMessageMr = try oneValueMr.encode()
                    jsonArrayMr.append(ecodedMessageMr)
                }
                jsonMap["mr"] = jsonArrayMr
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.GetRemoteAddressResponse {
            return try Tensorflow.GetRemoteAddressResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.GetRemoteAddressResponse {
            return try Tensorflow.GetRemoteAddressResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasHostName {
                output += "\(indent) hostName: \(hostName) \n"
            }
            if hasChannel {
                output += "\(indent) channel {\n"
                if let outDescChannel = channel {
                    output += try outDescChannel.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            var mrElementIndex:Int = 0
            for oneElementMr in mr {
                output += "\(indent) mr[\(mrElementIndex)] {\n"
                output += try oneElementMr.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                mrElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasHostName {
                    hashCode = (hashCode &* 31) &+ hostName.hashValue
                }
                if hasChannel {
                    if let hashValuechannel = channel?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuechannel
                    }
                }
                for oneElementMr in mr {
                    hashCode = (hashCode &* 31) &+ oneElementMr.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.GetRemoteAddressResponse"
        }
        override public func className() -> String {
            return "Tensorflow.GetRemoteAddressResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.GetRemoteAddressResponse = Tensorflow.GetRemoteAddressResponse()
            public func getMessage() -> Tensorflow.GetRemoteAddressResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var hostName:String {
                get {
                    return builderResult.hostName
                }
                set (value) {
                    builderResult.hasHostName = true
                    builderResult.hostName = value
                }
            }
            public var hasHostName:Bool {
                get {
                    return builderResult.hasHostName
                }
            }
            @discardableResult
            public func setHostName(_ value:String) -> Tensorflow.GetRemoteAddressResponse.Builder {
                self.hostName = value
                return self
            }
            @discardableResult
            public func clearHostName() -> Tensorflow.GetRemoteAddressResponse.Builder{
                builderResult.hasHostName = false
                builderResult.hostName = ""
                return self
            }
            public var channel:Tensorflow.Channel! {
                get {
                    if channelBuilder_ != nil {
                        builderResult.channel = channelBuilder_.getMessage()
                    }
                    return builderResult.channel
                }
                set (value) {
                    builderResult.hasChannel = true
                    builderResult.channel = value
                }
            }
            public var hasChannel:Bool {
                get {
                    return builderResult.hasChannel
                }
            }
            fileprivate var channelBuilder_:Tensorflow.Channel.Builder! {
                didSet {
                    builderResult.hasChannel = true
                }
            }
            public func getChannelBuilder() -> Tensorflow.Channel.Builder {
                if channelBuilder_ == nil {
                    channelBuilder_ = Tensorflow.Channel.Builder()
                    builderResult.channel = channelBuilder_.getMessage()
                    if channel != nil {
                        try! channelBuilder_.mergeFrom(other: channel)
                    }
                }
                return channelBuilder_
            }
            @discardableResult
            public func setChannel(_ value:Tensorflow.Channel!) -> Tensorflow.GetRemoteAddressResponse.Builder {
                self.channel = value
                return self
            }
            @discardableResult
            public func mergeChannel(value:Tensorflow.Channel) throws -> Tensorflow.GetRemoteAddressResponse.Builder {
                if builderResult.hasChannel {
                    builderResult.channel = try Tensorflow.Channel.builderWithPrototype(prototype:builderResult.channel).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.channel = value
                }
                builderResult.hasChannel = true
                return self
            }
            @discardableResult
            public func clearChannel() -> Tensorflow.GetRemoteAddressResponse.Builder {
                channelBuilder_ = nil
                builderResult.hasChannel = false
                builderResult.channel = nil
                return self
            }
            public var mr:Array<Tensorflow.MemoryRegion> {
                get {
                    return builderResult.mr
                }
                set (value) {
                    builderResult.mr = value
                }
            }
            @discardableResult
            public func setMr(_ value:Array<Tensorflow.MemoryRegion>) -> Tensorflow.GetRemoteAddressResponse.Builder {
                self.mr = value
                return self
            }
            @discardableResult
            public func clearMr() -> Tensorflow.GetRemoteAddressResponse.Builder {
                builderResult.mr.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.GetRemoteAddressResponse.Builder {
                builderResult = Tensorflow.GetRemoteAddressResponse()
                return self
            }
            override public func clone() throws -> Tensorflow.GetRemoteAddressResponse.Builder {
                return try Tensorflow.GetRemoteAddressResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.GetRemoteAddressResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.GetRemoteAddressResponse {
                let returnMe:Tensorflow.GetRemoteAddressResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.GetRemoteAddressResponse) throws -> Tensorflow.GetRemoteAddressResponse.Builder {
                if other == Tensorflow.GetRemoteAddressResponse() {
                    return self
                }
                if other.hasHostName {
                    hostName = other.hostName
                }
                if (other.hasChannel) {
                    try mergeChannel(value: other.channel)
                }
                if !other.mr.isEmpty  {
                     builderResult.mr += other.mr
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.GetRemoteAddressResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GetRemoteAddressResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        hostName = try codedInputStream.readString()

                    case 18:
                        let subBuilder:Tensorflow.Channel.Builder = Tensorflow.Channel.Builder()
                        if hasChannel {
                            try subBuilder.mergeFrom(other: channel)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        channel = subBuilder.buildPartial()

                    case 26:
                        let subBuilder = Tensorflow.MemoryRegion.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        mr.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.GetRemoteAddressResponse.Builder {
                let resultDecodedBuilder = Tensorflow.GetRemoteAddressResponse.Builder()
                if let jsonValueHostName = jsonMap["hostName"] as? String {
                    resultDecodedBuilder.hostName = jsonValueHostName
                }
                if let jsonValueChannel = jsonMap["channel"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.channel = try Tensorflow.Channel.Builder.decodeToBuilder(jsonMap:jsonValueChannel).build()

                }
                if let jsonValueMr = jsonMap["mr"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayMr:Array<Tensorflow.MemoryRegion> = []
                    for oneValueMr in jsonValueMr {
                        let messageFromStringMr = try Tensorflow.MemoryRegion.Builder.decodeToBuilder(jsonMap:oneValueMr).build()

                        jsonArrayMr.append(messageFromStringMr)
                    }
                    resultDecodedBuilder.mr = jsonArrayMr
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.GetRemoteAddressResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.GetRemoteAddressResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.Channel: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Channel> {
        var mergedArray = Array<Tensorflow.Channel>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Channel? {
        return try Tensorflow.Channel.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Channel {
        return try Tensorflow.Channel.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.VerbsServiceRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Channel {
        return try Tensorflow.Channel.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Channel {
        return try Tensorflow.Channel.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Channel {
        return try Tensorflow.Channel.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Channel {
        return try Tensorflow.Channel.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Channel {
        return try Tensorflow.Channel.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "lid": return self.lid
        case "qpn": return self.qpn
        case "psn": return self.psn
        default: return nil
        }
    }
}
extension Tensorflow.Channel.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "lid": return self.lid
            case "qpn": return self.qpn
            case "psn": return self.psn
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "lid":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.lid = newSubscriptValue
            case "qpn":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.qpn = newSubscriptValue
            case "psn":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.psn = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.MemoryRegion: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.MemoryRegion> {
        var mergedArray = Array<Tensorflow.MemoryRegion>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.MemoryRegion? {
        return try Tensorflow.MemoryRegion.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.MemoryRegion {
        return try Tensorflow.MemoryRegion.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.VerbsServiceRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryRegion {
        return try Tensorflow.MemoryRegion.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.MemoryRegion {
        return try Tensorflow.MemoryRegion.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryRegion {
        return try Tensorflow.MemoryRegion.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.MemoryRegion {
        return try Tensorflow.MemoryRegion.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryRegion {
        return try Tensorflow.MemoryRegion.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "remoteAddr": return self.remoteAddr
        case "rkey": return self.rkey
        default: return nil
        }
    }
}
extension Tensorflow.MemoryRegion.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "remoteAddr": return self.remoteAddr
            case "rkey": return self.rkey
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "remoteAddr":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.remoteAddr = newSubscriptValue
            case "rkey":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.rkey = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.GetRemoteAddressRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.GetRemoteAddressRequest> {
        var mergedArray = Array<Tensorflow.GetRemoteAddressRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.GetRemoteAddressRequest? {
        return try Tensorflow.GetRemoteAddressRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.GetRemoteAddressRequest {
        return try Tensorflow.GetRemoteAddressRequest.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.VerbsServiceRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GetRemoteAddressRequest {
        return try Tensorflow.GetRemoteAddressRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.GetRemoteAddressRequest {
        return try Tensorflow.GetRemoteAddressRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GetRemoteAddressRequest {
        return try Tensorflow.GetRemoteAddressRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.GetRemoteAddressRequest {
        return try Tensorflow.GetRemoteAddressRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GetRemoteAddressRequest {
        return try Tensorflow.GetRemoteAddressRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "hostName": return self.hostName
        case "channel": return self.channel
        case "mr": return self.mr
        default: return nil
        }
    }
}
extension Tensorflow.GetRemoteAddressRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "hostName": return self.hostName
            case "channel": return self.channel
            case "mr": return self.mr
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "hostName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.hostName = newSubscriptValue
            case "channel":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Channel else {
                    return
                }
                self.channel = newSubscriptValue
            case "mr":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.MemoryRegion> else {
                    return
                }
                self.mr = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.GetRemoteAddressResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.GetRemoteAddressResponse> {
        var mergedArray = Array<Tensorflow.GetRemoteAddressResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.GetRemoteAddressResponse? {
        return try Tensorflow.GetRemoteAddressResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.GetRemoteAddressResponse {
        return try Tensorflow.GetRemoteAddressResponse.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.VerbsServiceRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GetRemoteAddressResponse {
        return try Tensorflow.GetRemoteAddressResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.GetRemoteAddressResponse {
        return try Tensorflow.GetRemoteAddressResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GetRemoteAddressResponse {
        return try Tensorflow.GetRemoteAddressResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.GetRemoteAddressResponse {
        return try Tensorflow.GetRemoteAddressResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GetRemoteAddressResponse {
        return try Tensorflow.GetRemoteAddressResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "hostName": return self.hostName
        case "channel": return self.channel
        case "mr": return self.mr
        default: return nil
        }
    }
}
extension Tensorflow.GetRemoteAddressResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "hostName": return self.hostName
            case "channel": return self.channel
            case "mr": return self.mr
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "hostName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.hostName = newSubscriptValue
            case "channel":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Channel else {
                    return
                }
                self.channel = newSubscriptValue
            case "mr":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.MemoryRegion> else {
                    return
                }
                self.mr = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "graph_transfer_info.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { }

public extension Tensorflow {
    public struct GraphTransferInfoRoot {
        public static let `default` = GraphTransferInfoRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Tensorflow.TypesRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    /// Protocol buffer representing a handle to a tensorflow resource. Handles are
    /// not valid across executions, but can be serialized back and forth from within
    /// a single run.
    final public class GraphTransferInfo : GeneratedMessage {

        public static func == (lhs: Tensorflow.GraphTransferInfo, rhs: Tensorflow.GraphTransferInfo) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.nodeInfo == rhs.nodeInfo)
            fieldCheck = fieldCheck && (lhs.constNodeInfo == rhs.constNodeInfo)
            fieldCheck = fieldCheck && (lhs.nodeInputInfo == rhs.nodeInputInfo)
            fieldCheck = fieldCheck && (lhs.nodeOutputInfo == rhs.nodeOutputInfo)
            fieldCheck = fieldCheck && (lhs.graphInputNodeInfo == rhs.graphInputNodeInfo)
            fieldCheck = fieldCheck && (lhs.graphOutputNodeInfo == rhs.graphOutputNodeInfo)
            fieldCheck = fieldCheck && (lhs.hasDestination == rhs.hasDestination) && (!lhs.hasDestination || lhs.destination == rhs.destination)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        final public class NodeInput : GeneratedMessage {

            public static func == (lhs: Tensorflow.GraphTransferInfo.NodeInput, rhs: Tensorflow.GraphTransferInfo.NodeInput) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasNodeId == rhs.hasNodeId) && (!lhs.hasNodeId || lhs.nodeId == rhs.nodeId)
                fieldCheck = fieldCheck && (lhs.hasOutputPort == rhs.hasOutputPort) && (!lhs.hasOutputPort || lhs.outputPort == rhs.outputPort)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var nodeId:Int32 = Int32(0)
            public fileprivate(set) var hasNodeId:Bool = false

            public fileprivate(set) var outputPort:Int32 = Int32(0)
            public fileprivate(set) var hasOutputPort:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasNodeId {
                    try codedOutputStream.writeInt32(fieldNumber: 1, value:nodeId)
                }
                if hasOutputPort {
                    try codedOutputStream.writeInt32(fieldNumber: 2, value:outputPort)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasNodeId {
                    serialize_size += nodeId.computeInt32Size(fieldNumber: 1)
                }
                if hasOutputPort {
                    serialize_size += outputPort.computeInt32Size(fieldNumber: 2)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.GraphTransferInfo.NodeInput.Builder {
                return Tensorflow.GraphTransferInfo.NodeInput.classBuilder() as! Tensorflow.GraphTransferInfo.NodeInput.Builder
            }
            public func getBuilder() -> Tensorflow.GraphTransferInfo.NodeInput.Builder {
                return classBuilder() as! Tensorflow.GraphTransferInfo.NodeInput.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.GraphTransferInfo.NodeInput.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.GraphTransferInfo.NodeInput.Builder()
            }
            public func toBuilder() throws -> Tensorflow.GraphTransferInfo.NodeInput.Builder {
                return try Tensorflow.GraphTransferInfo.NodeInput.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.GraphTransferInfo.NodeInput) throws -> Tensorflow.GraphTransferInfo.NodeInput.Builder {
                return try Tensorflow.GraphTransferInfo.NodeInput.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasNodeId {
                    jsonMap["nodeId"] = Int(nodeId)
                }
                if hasOutputPort {
                    jsonMap["outputPort"] = Int(outputPort)
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.GraphTransferInfo.NodeInput {
                return try Tensorflow.GraphTransferInfo.NodeInput.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.GraphTransferInfo.NodeInput {
                return try Tensorflow.GraphTransferInfo.NodeInput.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasNodeId {
                    output += "\(indent) nodeId: \(nodeId) \n"
                }
                if hasOutputPort {
                    output += "\(indent) outputPort: \(outputPort) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasNodeId {
                        hashCode = (hashCode &* 31) &+ nodeId.hashValue
                    }
                    if hasOutputPort {
                        hashCode = (hashCode &* 31) &+ outputPort.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.GraphTransferInfo.NodeInput"
            }
            override public func className() -> String {
                return "Tensorflow.GraphTransferInfo.NodeInput"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.GraphTransferInfo.NodeInput = Tensorflow.GraphTransferInfo.NodeInput()
                public func getMessage() -> Tensorflow.GraphTransferInfo.NodeInput {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var nodeId:Int32 {
                    get {
                        return builderResult.nodeId
                    }
                    set (value) {
                        builderResult.hasNodeId = true
                        builderResult.nodeId = value
                    }
                }
                public var hasNodeId:Bool {
                    get {
                        return builderResult.hasNodeId
                    }
                }
                @discardableResult
                public func setNodeId(_ value:Int32) -> Tensorflow.GraphTransferInfo.NodeInput.Builder {
                    self.nodeId = value
                    return self
                }
                @discardableResult
                public func clearNodeId() -> Tensorflow.GraphTransferInfo.NodeInput.Builder{
                    builderResult.hasNodeId = false
                    builderResult.nodeId = Int32(0)
                    return self
                }
                public var outputPort:Int32 {
                    get {
                        return builderResult.outputPort
                    }
                    set (value) {
                        builderResult.hasOutputPort = true
                        builderResult.outputPort = value
                    }
                }
                public var hasOutputPort:Bool {
                    get {
                        return builderResult.hasOutputPort
                    }
                }
                @discardableResult
                public func setOutputPort(_ value:Int32) -> Tensorflow.GraphTransferInfo.NodeInput.Builder {
                    self.outputPort = value
                    return self
                }
                @discardableResult
                public func clearOutputPort() -> Tensorflow.GraphTransferInfo.NodeInput.Builder{
                    builderResult.hasOutputPort = false
                    builderResult.outputPort = Int32(0)
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.GraphTransferInfo.NodeInput.Builder {
                    builderResult = Tensorflow.GraphTransferInfo.NodeInput()
                    return self
                }
                override public func clone() throws -> Tensorflow.GraphTransferInfo.NodeInput.Builder {
                    return try Tensorflow.GraphTransferInfo.NodeInput.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.GraphTransferInfo.NodeInput {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.GraphTransferInfo.NodeInput {
                    let returnMe:Tensorflow.GraphTransferInfo.NodeInput = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.GraphTransferInfo.NodeInput) throws -> Tensorflow.GraphTransferInfo.NodeInput.Builder {
                    if other == Tensorflow.GraphTransferInfo.NodeInput() {
                        return self
                    }
                    if other.hasNodeId {
                        nodeId = other.nodeId
                    }
                    if other.hasOutputPort {
                        outputPort = other.outputPort
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.GraphTransferInfo.NodeInput.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphTransferInfo.NodeInput.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 8:
                            nodeId = try codedInputStream.readInt32()

                        case 16:
                            outputPort = try codedInputStream.readInt32()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.GraphTransferInfo.NodeInput.Builder {
                    let resultDecodedBuilder = Tensorflow.GraphTransferInfo.NodeInput.Builder()
                    if let jsonValueNodeId = jsonMap["nodeId"] as? Int {
                        resultDecodedBuilder.nodeId = Int32(jsonValueNodeId)
                    } else if let jsonValueNodeId = jsonMap["nodeId"] as? String {
                        resultDecodedBuilder.nodeId = Int32(jsonValueNodeId)!
                    }
                    if let jsonValueOutputPort = jsonMap["outputPort"] as? Int {
                        resultDecodedBuilder.outputPort = Int32(jsonValueOutputPort)
                    } else if let jsonValueOutputPort = jsonMap["outputPort"] as? String {
                        resultDecodedBuilder.outputPort = Int32(jsonValueOutputPort)!
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.GraphTransferInfo.NodeInput.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.GraphTransferInfo.NodeInput.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        final public class NodeInfo : GeneratedMessage {

            public static func == (lhs: Tensorflow.GraphTransferInfo.NodeInfo, rhs: Tensorflow.GraphTransferInfo.NodeInfo) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
                fieldCheck = fieldCheck && (lhs.hasNodeId == rhs.hasNodeId) && (!lhs.hasNodeId || lhs.nodeId == rhs.nodeId)
                fieldCheck = fieldCheck && (lhs.hasTypeName == rhs.hasTypeName) && (!lhs.hasTypeName || lhs.typeName == rhs.typeName)
                fieldCheck = fieldCheck && (lhs.hasSocOpId == rhs.hasSocOpId) && (!lhs.hasSocOpId || lhs.socOpId == rhs.socOpId)
                fieldCheck = fieldCheck && (lhs.hasPaddingId == rhs.hasPaddingId) && (!lhs.hasPaddingId || lhs.paddingId == rhs.paddingId)
                fieldCheck = fieldCheck && (lhs.hasInputCount == rhs.hasInputCount) && (!lhs.hasInputCount || lhs.inputCount == rhs.inputCount)
                fieldCheck = fieldCheck && (lhs.hasOutputCount == rhs.hasOutputCount) && (!lhs.hasOutputCount || lhs.outputCount == rhs.outputCount)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var name:String = ""
            public fileprivate(set) var hasName:Bool = false

            public fileprivate(set) var nodeId:Int32 = Int32(0)
            public fileprivate(set) var hasNodeId:Bool = false

            public fileprivate(set) var typeName:String = ""
            public fileprivate(set) var hasTypeName:Bool = false

            public fileprivate(set) var socOpId:Int32 = Int32(0)
            public fileprivate(set) var hasSocOpId:Bool = false

            public fileprivate(set) var paddingId:Int32 = Int32(0)
            public fileprivate(set) var hasPaddingId:Bool = false

            public fileprivate(set) var inputCount:Int32 = Int32(0)
            public fileprivate(set) var hasInputCount:Bool = false

            public fileprivate(set) var outputCount:Int32 = Int32(0)
            public fileprivate(set) var hasOutputCount:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasName {
                    try codedOutputStream.writeString(fieldNumber: 1, value:name)
                }
                if hasNodeId {
                    try codedOutputStream.writeInt32(fieldNumber: 2, value:nodeId)
                }
                if hasTypeName {
                    try codedOutputStream.writeString(fieldNumber: 3, value:typeName)
                }
                if hasSocOpId {
                    try codedOutputStream.writeInt32(fieldNumber: 4, value:socOpId)
                }
                if hasPaddingId {
                    try codedOutputStream.writeInt32(fieldNumber: 5, value:paddingId)
                }
                if hasInputCount {
                    try codedOutputStream.writeInt32(fieldNumber: 6, value:inputCount)
                }
                if hasOutputCount {
                    try codedOutputStream.writeInt32(fieldNumber: 7, value:outputCount)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasName {
                    serialize_size += name.computeStringSize(fieldNumber: 1)
                }
                if hasNodeId {
                    serialize_size += nodeId.computeInt32Size(fieldNumber: 2)
                }
                if hasTypeName {
                    serialize_size += typeName.computeStringSize(fieldNumber: 3)
                }
                if hasSocOpId {
                    serialize_size += socOpId.computeInt32Size(fieldNumber: 4)
                }
                if hasPaddingId {
                    serialize_size += paddingId.computeInt32Size(fieldNumber: 5)
                }
                if hasInputCount {
                    serialize_size += inputCount.computeInt32Size(fieldNumber: 6)
                }
                if hasOutputCount {
                    serialize_size += outputCount.computeInt32Size(fieldNumber: 7)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.GraphTransferInfo.NodeInfo.Builder {
                return Tensorflow.GraphTransferInfo.NodeInfo.classBuilder() as! Tensorflow.GraphTransferInfo.NodeInfo.Builder
            }
            public func getBuilder() -> Tensorflow.GraphTransferInfo.NodeInfo.Builder {
                return classBuilder() as! Tensorflow.GraphTransferInfo.NodeInfo.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.GraphTransferInfo.NodeInfo.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.GraphTransferInfo.NodeInfo.Builder()
            }
            public func toBuilder() throws -> Tensorflow.GraphTransferInfo.NodeInfo.Builder {
                return try Tensorflow.GraphTransferInfo.NodeInfo.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.GraphTransferInfo.NodeInfo) throws -> Tensorflow.GraphTransferInfo.NodeInfo.Builder {
                return try Tensorflow.GraphTransferInfo.NodeInfo.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasName {
                    jsonMap["name"] = name
                }
                if hasNodeId {
                    jsonMap["nodeId"] = Int(nodeId)
                }
                if hasTypeName {
                    jsonMap["typeName"] = typeName
                }
                if hasSocOpId {
                    jsonMap["socOpId"] = Int(socOpId)
                }
                if hasPaddingId {
                    jsonMap["paddingId"] = Int(paddingId)
                }
                if hasInputCount {
                    jsonMap["inputCount"] = Int(inputCount)
                }
                if hasOutputCount {
                    jsonMap["outputCount"] = Int(outputCount)
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.GraphTransferInfo.NodeInfo {
                return try Tensorflow.GraphTransferInfo.NodeInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.GraphTransferInfo.NodeInfo {
                return try Tensorflow.GraphTransferInfo.NodeInfo.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasName {
                    output += "\(indent) name: \(name) \n"
                }
                if hasNodeId {
                    output += "\(indent) nodeId: \(nodeId) \n"
                }
                if hasTypeName {
                    output += "\(indent) typeName: \(typeName) \n"
                }
                if hasSocOpId {
                    output += "\(indent) socOpId: \(socOpId) \n"
                }
                if hasPaddingId {
                    output += "\(indent) paddingId: \(paddingId) \n"
                }
                if hasInputCount {
                    output += "\(indent) inputCount: \(inputCount) \n"
                }
                if hasOutputCount {
                    output += "\(indent) outputCount: \(outputCount) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasName {
                        hashCode = (hashCode &* 31) &+ name.hashValue
                    }
                    if hasNodeId {
                        hashCode = (hashCode &* 31) &+ nodeId.hashValue
                    }
                    if hasTypeName {
                        hashCode = (hashCode &* 31) &+ typeName.hashValue
                    }
                    if hasSocOpId {
                        hashCode = (hashCode &* 31) &+ socOpId.hashValue
                    }
                    if hasPaddingId {
                        hashCode = (hashCode &* 31) &+ paddingId.hashValue
                    }
                    if hasInputCount {
                        hashCode = (hashCode &* 31) &+ inputCount.hashValue
                    }
                    if hasOutputCount {
                        hashCode = (hashCode &* 31) &+ outputCount.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.GraphTransferInfo.NodeInfo"
            }
            override public func className() -> String {
                return "Tensorflow.GraphTransferInfo.NodeInfo"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.GraphTransferInfo.NodeInfo = Tensorflow.GraphTransferInfo.NodeInfo()
                public func getMessage() -> Tensorflow.GraphTransferInfo.NodeInfo {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var name:String {
                    get {
                        return builderResult.name
                    }
                    set (value) {
                        builderResult.hasName = true
                        builderResult.name = value
                    }
                }
                public var hasName:Bool {
                    get {
                        return builderResult.hasName
                    }
                }
                @discardableResult
                public func setName(_ value:String) -> Tensorflow.GraphTransferInfo.NodeInfo.Builder {
                    self.name = value
                    return self
                }
                @discardableResult
                public func clearName() -> Tensorflow.GraphTransferInfo.NodeInfo.Builder{
                    builderResult.hasName = false
                    builderResult.name = ""
                    return self
                }
                public var nodeId:Int32 {
                    get {
                        return builderResult.nodeId
                    }
                    set (value) {
                        builderResult.hasNodeId = true
                        builderResult.nodeId = value
                    }
                }
                public var hasNodeId:Bool {
                    get {
                        return builderResult.hasNodeId
                    }
                }
                @discardableResult
                public func setNodeId(_ value:Int32) -> Tensorflow.GraphTransferInfo.NodeInfo.Builder {
                    self.nodeId = value
                    return self
                }
                @discardableResult
                public func clearNodeId() -> Tensorflow.GraphTransferInfo.NodeInfo.Builder{
                    builderResult.hasNodeId = false
                    builderResult.nodeId = Int32(0)
                    return self
                }
                public var typeName:String {
                    get {
                        return builderResult.typeName
                    }
                    set (value) {
                        builderResult.hasTypeName = true
                        builderResult.typeName = value
                    }
                }
                public var hasTypeName:Bool {
                    get {
                        return builderResult.hasTypeName
                    }
                }
                @discardableResult
                public func setTypeName(_ value:String) -> Tensorflow.GraphTransferInfo.NodeInfo.Builder {
                    self.typeName = value
                    return self
                }
                @discardableResult
                public func clearTypeName() -> Tensorflow.GraphTransferInfo.NodeInfo.Builder{
                    builderResult.hasTypeName = false
                    builderResult.typeName = ""
                    return self
                }
                public var socOpId:Int32 {
                    get {
                        return builderResult.socOpId
                    }
                    set (value) {
                        builderResult.hasSocOpId = true
                        builderResult.socOpId = value
                    }
                }
                public var hasSocOpId:Bool {
                    get {
                        return builderResult.hasSocOpId
                    }
                }
                @discardableResult
                public func setSocOpId(_ value:Int32) -> Tensorflow.GraphTransferInfo.NodeInfo.Builder {
                    self.socOpId = value
                    return self
                }
                @discardableResult
                public func clearSocOpId() -> Tensorflow.GraphTransferInfo.NodeInfo.Builder{
                    builderResult.hasSocOpId = false
                    builderResult.socOpId = Int32(0)
                    return self
                }
                public var paddingId:Int32 {
                    get {
                        return builderResult.paddingId
                    }
                    set (value) {
                        builderResult.hasPaddingId = true
                        builderResult.paddingId = value
                    }
                }
                public var hasPaddingId:Bool {
                    get {
                        return builderResult.hasPaddingId
                    }
                }
                @discardableResult
                public func setPaddingId(_ value:Int32) -> Tensorflow.GraphTransferInfo.NodeInfo.Builder {
                    self.paddingId = value
                    return self
                }
                @discardableResult
                public func clearPaddingId() -> Tensorflow.GraphTransferInfo.NodeInfo.Builder{
                    builderResult.hasPaddingId = false
                    builderResult.paddingId = Int32(0)
                    return self
                }
                public var inputCount:Int32 {
                    get {
                        return builderResult.inputCount
                    }
                    set (value) {
                        builderResult.hasInputCount = true
                        builderResult.inputCount = value
                    }
                }
                public var hasInputCount:Bool {
                    get {
                        return builderResult.hasInputCount
                    }
                }
                @discardableResult
                public func setInputCount(_ value:Int32) -> Tensorflow.GraphTransferInfo.NodeInfo.Builder {
                    self.inputCount = value
                    return self
                }
                @discardableResult
                public func clearInputCount() -> Tensorflow.GraphTransferInfo.NodeInfo.Builder{
                    builderResult.hasInputCount = false
                    builderResult.inputCount = Int32(0)
                    return self
                }
                public var outputCount:Int32 {
                    get {
                        return builderResult.outputCount
                    }
                    set (value) {
                        builderResult.hasOutputCount = true
                        builderResult.outputCount = value
                    }
                }
                public var hasOutputCount:Bool {
                    get {
                        return builderResult.hasOutputCount
                    }
                }
                @discardableResult
                public func setOutputCount(_ value:Int32) -> Tensorflow.GraphTransferInfo.NodeInfo.Builder {
                    self.outputCount = value
                    return self
                }
                @discardableResult
                public func clearOutputCount() -> Tensorflow.GraphTransferInfo.NodeInfo.Builder{
                    builderResult.hasOutputCount = false
                    builderResult.outputCount = Int32(0)
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.GraphTransferInfo.NodeInfo.Builder {
                    builderResult = Tensorflow.GraphTransferInfo.NodeInfo()
                    return self
                }
                override public func clone() throws -> Tensorflow.GraphTransferInfo.NodeInfo.Builder {
                    return try Tensorflow.GraphTransferInfo.NodeInfo.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.GraphTransferInfo.NodeInfo {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.GraphTransferInfo.NodeInfo {
                    let returnMe:Tensorflow.GraphTransferInfo.NodeInfo = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.GraphTransferInfo.NodeInfo) throws -> Tensorflow.GraphTransferInfo.NodeInfo.Builder {
                    if other == Tensorflow.GraphTransferInfo.NodeInfo() {
                        return self
                    }
                    if other.hasName {
                        name = other.name
                    }
                    if other.hasNodeId {
                        nodeId = other.nodeId
                    }
                    if other.hasTypeName {
                        typeName = other.typeName
                    }
                    if other.hasSocOpId {
                        socOpId = other.socOpId
                    }
                    if other.hasPaddingId {
                        paddingId = other.paddingId
                    }
                    if other.hasInputCount {
                        inputCount = other.inputCount
                    }
                    if other.hasOutputCount {
                        outputCount = other.outputCount
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.GraphTransferInfo.NodeInfo.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphTransferInfo.NodeInfo.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            name = try codedInputStream.readString()

                        case 16:
                            nodeId = try codedInputStream.readInt32()

                        case 26:
                            typeName = try codedInputStream.readString()

                        case 32:
                            socOpId = try codedInputStream.readInt32()

                        case 40:
                            paddingId = try codedInputStream.readInt32()

                        case 48:
                            inputCount = try codedInputStream.readInt32()

                        case 56:
                            outputCount = try codedInputStream.readInt32()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.GraphTransferInfo.NodeInfo.Builder {
                    let resultDecodedBuilder = Tensorflow.GraphTransferInfo.NodeInfo.Builder()
                    if let jsonValueName = jsonMap["name"] as? String {
                        resultDecodedBuilder.name = jsonValueName
                    }
                    if let jsonValueNodeId = jsonMap["nodeId"] as? Int {
                        resultDecodedBuilder.nodeId = Int32(jsonValueNodeId)
                    } else if let jsonValueNodeId = jsonMap["nodeId"] as? String {
                        resultDecodedBuilder.nodeId = Int32(jsonValueNodeId)!
                    }
                    if let jsonValueTypeName = jsonMap["typeName"] as? String {
                        resultDecodedBuilder.typeName = jsonValueTypeName
                    }
                    if let jsonValueSocOpId = jsonMap["socOpId"] as? Int {
                        resultDecodedBuilder.socOpId = Int32(jsonValueSocOpId)
                    } else if let jsonValueSocOpId = jsonMap["socOpId"] as? String {
                        resultDecodedBuilder.socOpId = Int32(jsonValueSocOpId)!
                    }
                    if let jsonValuePaddingId = jsonMap["paddingId"] as? Int {
                        resultDecodedBuilder.paddingId = Int32(jsonValuePaddingId)
                    } else if let jsonValuePaddingId = jsonMap["paddingId"] as? String {
                        resultDecodedBuilder.paddingId = Int32(jsonValuePaddingId)!
                    }
                    if let jsonValueInputCount = jsonMap["inputCount"] as? Int {
                        resultDecodedBuilder.inputCount = Int32(jsonValueInputCount)
                    } else if let jsonValueInputCount = jsonMap["inputCount"] as? String {
                        resultDecodedBuilder.inputCount = Int32(jsonValueInputCount)!
                    }
                    if let jsonValueOutputCount = jsonMap["outputCount"] as? Int {
                        resultDecodedBuilder.outputCount = Int32(jsonValueOutputCount)
                    } else if let jsonValueOutputCount = jsonMap["outputCount"] as? String {
                        resultDecodedBuilder.outputCount = Int32(jsonValueOutputCount)!
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.GraphTransferInfo.NodeInfo.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.GraphTransferInfo.NodeInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        final public class ConstNodeInfo : GeneratedMessage {

            public static func == (lhs: Tensorflow.GraphTransferInfo.ConstNodeInfo, rhs: Tensorflow.GraphTransferInfo.ConstNodeInfo) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
                fieldCheck = fieldCheck && (lhs.hasNodeId == rhs.hasNodeId) && (!lhs.hasNodeId || lhs.nodeId == rhs.nodeId)
                fieldCheck = fieldCheck && (lhs.shape == rhs.shape)
                fieldCheck = fieldCheck && (lhs.hasData == rhs.hasData) && (!lhs.hasData || lhs.data == rhs.data)
                fieldCheck = fieldCheck && (lhs.hasDtype == rhs.hasDtype) && (!lhs.hasDtype || lhs.dtype == rhs.dtype)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var name:String = ""
            public fileprivate(set) var hasName:Bool = false

            public fileprivate(set) var nodeId:Int32 = Int32(0)
            public fileprivate(set) var hasNodeId:Bool = false

            public fileprivate(set) var shape:Array<Int64> = Array<Int64>()
            private var shapeMemoizedSerializedSize:Int32 = -1
            public fileprivate(set) var data:Data = Data()
            public fileprivate(set) var hasData:Bool = false

            public fileprivate(set) var dtype:Tensorflow.DataType = Tensorflow.DataType.dtInvalid
            public fileprivate(set) var hasDtype:Bool = false
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasName {
                    try codedOutputStream.writeString(fieldNumber: 1, value:name)
                }
                if hasNodeId {
                    try codedOutputStream.writeInt32(fieldNumber: 2, value:nodeId)
                }
                if !shape.isEmpty {
                    try codedOutputStream.writeRawVarint32(value: 26)
                    try codedOutputStream.writeRawVarint32(value: shapeMemoizedSerializedSize)
                    for oneValueshape in shape {
                        try codedOutputStream.writeInt64NoTag(value: oneValueshape)
                    }
                }
                if hasData {
                    try codedOutputStream.writeData(fieldNumber: 4, value:data)
                }
                if hasDtype {
                    try codedOutputStream.writeEnum(fieldNumber: 5, value:dtype.rawValue)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasName {
                    serialize_size += name.computeStringSize(fieldNumber: 1)
                }
                if hasNodeId {
                    serialize_size += nodeId.computeInt32Size(fieldNumber: 2)
                }
                var dataSizeShape:Int32 = 0
                for oneValueshape in shape {
                    dataSizeShape += oneValueshape.computeInt64SizeNoTag()
                }
                serialize_size += dataSizeShape
                if !shape.isEmpty {
                    serialize_size += 1
                    serialize_size += dataSizeShape.computeInt32SizeNoTag()
                }
                shapeMemoizedSerializedSize = dataSizeShape
                if hasData {
                    serialize_size += data.computeDataSize(fieldNumber: 4)
                }
                if (hasDtype) {
                    serialize_size += dtype.rawValue.computeEnumSize(fieldNumber: 5)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder {
                return Tensorflow.GraphTransferInfo.ConstNodeInfo.classBuilder() as! Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder
            }
            public func getBuilder() -> Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder {
                return classBuilder() as! Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder()
            }
            public func toBuilder() throws -> Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder {
                return try Tensorflow.GraphTransferInfo.ConstNodeInfo.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.GraphTransferInfo.ConstNodeInfo) throws -> Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder {
                return try Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasName {
                    jsonMap["name"] = name
                }
                if hasNodeId {
                    jsonMap["nodeId"] = Int(nodeId)
                }
                if !shape.isEmpty {
                    var jsonArrayShape:Array<String> = []
                    for oneValueShape in shape {
                        jsonArrayShape.append("\(oneValueShape)")
                    }
                    jsonMap["shape"] = jsonArrayShape
                }
                if hasData {
                    jsonMap["data"] = data.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
                }
                if hasDtype {
                    jsonMap["dtype"] = dtype.toString()
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.GraphTransferInfo.ConstNodeInfo {
                return try Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.GraphTransferInfo.ConstNodeInfo {
                return try Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasName {
                    output += "\(indent) name: \(name) \n"
                }
                if hasNodeId {
                    output += "\(indent) nodeId: \(nodeId) \n"
                }
                var shapeElementIndex:Int = 0
                for oneValueShape in shape  {
                    output += "\(indent) shape[\(shapeElementIndex)]: \(oneValueShape)\n"
                    shapeElementIndex += 1
                }
                if hasData {
                    output += "\(indent) data: \(data) \n"
                }
                if (hasDtype) {
                    output += "\(indent) dtype: \(dtype.description)\n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasName {
                        hashCode = (hashCode &* 31) &+ name.hashValue
                    }
                    if hasNodeId {
                        hashCode = (hashCode &* 31) &+ nodeId.hashValue
                    }
                    for oneValueShape in shape {
                        hashCode = (hashCode &* 31) &+ oneValueShape.hashValue
                    }
                    if hasData {
                        hashCode = (hashCode &* 31) &+ data.hashValue
                    }
                    if hasDtype {
                         hashCode = (hashCode &* 31) &+ dtype.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.GraphTransferInfo.ConstNodeInfo"
            }
            override public func className() -> String {
                return "Tensorflow.GraphTransferInfo.ConstNodeInfo"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.GraphTransferInfo.ConstNodeInfo = Tensorflow.GraphTransferInfo.ConstNodeInfo()
                public func getMessage() -> Tensorflow.GraphTransferInfo.ConstNodeInfo {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var name:String {
                    get {
                        return builderResult.name
                    }
                    set (value) {
                        builderResult.hasName = true
                        builderResult.name = value
                    }
                }
                public var hasName:Bool {
                    get {
                        return builderResult.hasName
                    }
                }
                @discardableResult
                public func setName(_ value:String) -> Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder {
                    self.name = value
                    return self
                }
                @discardableResult
                public func clearName() -> Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder{
                    builderResult.hasName = false
                    builderResult.name = ""
                    return self
                }
                public var nodeId:Int32 {
                    get {
                        return builderResult.nodeId
                    }
                    set (value) {
                        builderResult.hasNodeId = true
                        builderResult.nodeId = value
                    }
                }
                public var hasNodeId:Bool {
                    get {
                        return builderResult.hasNodeId
                    }
                }
                @discardableResult
                public func setNodeId(_ value:Int32) -> Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder {
                    self.nodeId = value
                    return self
                }
                @discardableResult
                public func clearNodeId() -> Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder{
                    builderResult.hasNodeId = false
                    builderResult.nodeId = Int32(0)
                    return self
                }
                public var shape:Array<Int64> {
                    get {
                        return builderResult.shape
                    }
                    set (array) {
                        builderResult.shape = array
                    }
                }
                @discardableResult
                public func setShape(_ value:Array<Int64>) -> Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder {
                    self.shape = value
                    return self
                }
                @discardableResult
                public func clearShape() -> Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder {
                    builderResult.shape.removeAll(keepingCapacity: false)
                    return self
                }
                public var data:Data {
                    get {
                        return builderResult.data
                    }
                    set (value) {
                        builderResult.hasData = true
                        builderResult.data = value
                    }
                }
                public var hasData:Bool {
                    get {
                        return builderResult.hasData
                    }
                }
                @discardableResult
                public func setData(_ value:Data) -> Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder {
                    self.data = value
                    return self
                }
                @discardableResult
                public func clearData() -> Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder{
                    builderResult.hasData = false
                    builderResult.data = Data()
                    return self
                }
                    public var dtype:Tensorflow.DataType {
                        get {
                            return builderResult.dtype
                        }
                        set (value) {
                            builderResult.hasDtype = true
                            builderResult.dtype = value
                        }
                    }
                    public var hasDtype:Bool{
                        get {
                            return builderResult.hasDtype
                        }
                    }
                @discardableResult
                    public func setDtype(_ value:Tensorflow.DataType) -> Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder {
                      self.dtype = value
                      return self
                    }
                @discardableResult
                    public func clearDtype() -> Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder {
                       builderResult.hasDtype = false
                       builderResult.dtype = .dtInvalid
                       return self
                    }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder {
                    builderResult = Tensorflow.GraphTransferInfo.ConstNodeInfo()
                    return self
                }
                override public func clone() throws -> Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder {
                    return try Tensorflow.GraphTransferInfo.ConstNodeInfo.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.GraphTransferInfo.ConstNodeInfo {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.GraphTransferInfo.ConstNodeInfo {
                    let returnMe:Tensorflow.GraphTransferInfo.ConstNodeInfo = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.GraphTransferInfo.ConstNodeInfo) throws -> Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder {
                    if other == Tensorflow.GraphTransferInfo.ConstNodeInfo() {
                        return self
                    }
                    if other.hasName {
                        name = other.name
                    }
                    if other.hasNodeId {
                        nodeId = other.nodeId
                    }
                    if !other.shape.isEmpty {
                        builderResult.shape += other.shape
                    }
                    if other.hasData {
                        data = other.data
                    }
                    if other.hasDtype {
                        dtype = other.dtype
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            name = try codedInputStream.readString()

                        case 16:
                            nodeId = try codedInputStream.readInt32()

                        case 26:
                            let length = Int(try codedInputStream.readRawVarint32())
                            let limit = try codedInputStream.pushLimit(byteLimit: length)
                            while (codedInputStream.bytesUntilLimit() > 0) {
                                builderResult.shape.append(try codedInputStream.readInt64())
                            }
                            codedInputStream.popLimit(oldLimit: limit)

                        case 34:
                            data = try codedInputStream.readData()

                        case 40:
                            let valueIntdtype = try codedInputStream.readEnum()
                            if let enumsdtype = Tensorflow.DataType(rawValue:valueIntdtype){
                                dtype = enumsdtype
                            } else {
                                try unknownFieldsBuilder.mergeVarintField(fieldNumber: 5, value:Int64(valueIntdtype))
                            }

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder {
                    let resultDecodedBuilder = Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder()
                    if let jsonValueName = jsonMap["name"] as? String {
                        resultDecodedBuilder.name = jsonValueName
                    }
                    if let jsonValueNodeId = jsonMap["nodeId"] as? Int {
                        resultDecodedBuilder.nodeId = Int32(jsonValueNodeId)
                    } else if let jsonValueNodeId = jsonMap["nodeId"] as? String {
                        resultDecodedBuilder.nodeId = Int32(jsonValueNodeId)!
                    }
                    if let jsonValueShape = jsonMap["shape"] as? Array<String> {
                        var jsonArrayShape:Array<Int64> = []
                        for oneValueShape in jsonValueShape {
                            jsonArrayShape.append(Int64(oneValueShape)!)
                        }
                        resultDecodedBuilder.shape = jsonArrayShape
                    }
                    if let jsonValueData = jsonMap["data"] as? String {
                        resultDecodedBuilder.data = Data(base64Encoded:jsonValueData, options: Data.Base64DecodingOptions(rawValue:0))!
                    }
                    if let jsonValueDtype = jsonMap["dtype"] as? String {
                        resultDecodedBuilder.dtype = try Tensorflow.DataType.fromString(str: jsonValueDtype)
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        final public class NodeInputInfo : GeneratedMessage {

            public static func == (lhs: Tensorflow.GraphTransferInfo.NodeInputInfo, rhs: Tensorflow.GraphTransferInfo.NodeInputInfo) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasNodeId == rhs.hasNodeId) && (!lhs.hasNodeId || lhs.nodeId == rhs.nodeId)
                fieldCheck = fieldCheck && (lhs.nodeInput == rhs.nodeInput)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var nodeId:Int32 = Int32(0)
            public fileprivate(set) var hasNodeId:Bool = false

            public fileprivate(set) var nodeInput:Array<Tensorflow.GraphTransferInfo.NodeInput>  = Array<Tensorflow.GraphTransferInfo.NodeInput>()
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasNodeId {
                    try codedOutputStream.writeInt32(fieldNumber: 1, value:nodeId)
                }
                for oneElementNodeInput in nodeInput {
                      try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementNodeInput)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasNodeId {
                    serialize_size += nodeId.computeInt32Size(fieldNumber: 1)
                }
                for oneElementNodeInput in nodeInput {
                    serialize_size += oneElementNodeInput.computeMessageSize(fieldNumber: 2)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.GraphTransferInfo.NodeInputInfo.Builder {
                return Tensorflow.GraphTransferInfo.NodeInputInfo.classBuilder() as! Tensorflow.GraphTransferInfo.NodeInputInfo.Builder
            }
            public func getBuilder() -> Tensorflow.GraphTransferInfo.NodeInputInfo.Builder {
                return classBuilder() as! Tensorflow.GraphTransferInfo.NodeInputInfo.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.GraphTransferInfo.NodeInputInfo.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.GraphTransferInfo.NodeInputInfo.Builder()
            }
            public func toBuilder() throws -> Tensorflow.GraphTransferInfo.NodeInputInfo.Builder {
                return try Tensorflow.GraphTransferInfo.NodeInputInfo.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.GraphTransferInfo.NodeInputInfo) throws -> Tensorflow.GraphTransferInfo.NodeInputInfo.Builder {
                return try Tensorflow.GraphTransferInfo.NodeInputInfo.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasNodeId {
                    jsonMap["nodeId"] = Int(nodeId)
                }
                if !nodeInput.isEmpty {
                    var jsonArrayNodeInput:Array<Dictionary<String,Any>> = []
                    for oneValueNodeInput in nodeInput {
                        let ecodedMessageNodeInput = try oneValueNodeInput.encode()
                        jsonArrayNodeInput.append(ecodedMessageNodeInput)
                    }
                    jsonMap["nodeInput"] = jsonArrayNodeInput
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.GraphTransferInfo.NodeInputInfo {
                return try Tensorflow.GraphTransferInfo.NodeInputInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.GraphTransferInfo.NodeInputInfo {
                return try Tensorflow.GraphTransferInfo.NodeInputInfo.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasNodeId {
                    output += "\(indent) nodeId: \(nodeId) \n"
                }
                var nodeInputElementIndex:Int = 0
                for oneElementNodeInput in nodeInput {
                    output += "\(indent) nodeInput[\(nodeInputElementIndex)] {\n"
                    output += try oneElementNodeInput.getDescription(indent: "\(indent)  ")
                    output += "\(indent)}\n"
                    nodeInputElementIndex += 1
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasNodeId {
                        hashCode = (hashCode &* 31) &+ nodeId.hashValue
                    }
                    for oneElementNodeInput in nodeInput {
                        hashCode = (hashCode &* 31) &+ oneElementNodeInput.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.GraphTransferInfo.NodeInputInfo"
            }
            override public func className() -> String {
                return "Tensorflow.GraphTransferInfo.NodeInputInfo"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.GraphTransferInfo.NodeInputInfo = Tensorflow.GraphTransferInfo.NodeInputInfo()
                public func getMessage() -> Tensorflow.GraphTransferInfo.NodeInputInfo {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var nodeId:Int32 {
                    get {
                        return builderResult.nodeId
                    }
                    set (value) {
                        builderResult.hasNodeId = true
                        builderResult.nodeId = value
                    }
                }
                public var hasNodeId:Bool {
                    get {
                        return builderResult.hasNodeId
                    }
                }
                @discardableResult
                public func setNodeId(_ value:Int32) -> Tensorflow.GraphTransferInfo.NodeInputInfo.Builder {
                    self.nodeId = value
                    return self
                }
                @discardableResult
                public func clearNodeId() -> Tensorflow.GraphTransferInfo.NodeInputInfo.Builder{
                    builderResult.hasNodeId = false
                    builderResult.nodeId = Int32(0)
                    return self
                }
                public var nodeInput:Array<Tensorflow.GraphTransferInfo.NodeInput> {
                    get {
                        return builderResult.nodeInput
                    }
                    set (value) {
                        builderResult.nodeInput = value
                    }
                }
                @discardableResult
                public func setNodeInput(_ value:Array<Tensorflow.GraphTransferInfo.NodeInput>) -> Tensorflow.GraphTransferInfo.NodeInputInfo.Builder {
                    self.nodeInput = value
                    return self
                }
                @discardableResult
                public func clearNodeInput() -> Tensorflow.GraphTransferInfo.NodeInputInfo.Builder {
                    builderResult.nodeInput.removeAll(keepingCapacity: false)
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.GraphTransferInfo.NodeInputInfo.Builder {
                    builderResult = Tensorflow.GraphTransferInfo.NodeInputInfo()
                    return self
                }
                override public func clone() throws -> Tensorflow.GraphTransferInfo.NodeInputInfo.Builder {
                    return try Tensorflow.GraphTransferInfo.NodeInputInfo.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.GraphTransferInfo.NodeInputInfo {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.GraphTransferInfo.NodeInputInfo {
                    let returnMe:Tensorflow.GraphTransferInfo.NodeInputInfo = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.GraphTransferInfo.NodeInputInfo) throws -> Tensorflow.GraphTransferInfo.NodeInputInfo.Builder {
                    if other == Tensorflow.GraphTransferInfo.NodeInputInfo() {
                        return self
                    }
                    if other.hasNodeId {
                        nodeId = other.nodeId
                    }
                    if !other.nodeInput.isEmpty  {
                         builderResult.nodeInput += other.nodeInput
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.GraphTransferInfo.NodeInputInfo.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphTransferInfo.NodeInputInfo.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 8:
                            nodeId = try codedInputStream.readInt32()

                        case 18:
                            let subBuilder = Tensorflow.GraphTransferInfo.NodeInput.Builder()
                            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                            nodeInput.append(subBuilder.buildPartial())

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.GraphTransferInfo.NodeInputInfo.Builder {
                    let resultDecodedBuilder = Tensorflow.GraphTransferInfo.NodeInputInfo.Builder()
                    if let jsonValueNodeId = jsonMap["nodeId"] as? Int {
                        resultDecodedBuilder.nodeId = Int32(jsonValueNodeId)
                    } else if let jsonValueNodeId = jsonMap["nodeId"] as? String {
                        resultDecodedBuilder.nodeId = Int32(jsonValueNodeId)!
                    }
                    if let jsonValueNodeInput = jsonMap["nodeInput"] as? Array<Dictionary<String,Any>> {
                        var jsonArrayNodeInput:Array<Tensorflow.GraphTransferInfo.NodeInput> = []
                        for oneValueNodeInput in jsonValueNodeInput {
                            let messageFromStringNodeInput = try Tensorflow.GraphTransferInfo.NodeInput.Builder.decodeToBuilder(jsonMap:oneValueNodeInput).build()

                            jsonArrayNodeInput.append(messageFromStringNodeInput)
                        }
                        resultDecodedBuilder.nodeInput = jsonArrayNodeInput
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.GraphTransferInfo.NodeInputInfo.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.GraphTransferInfo.NodeInputInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        final public class NodeOutputInfo : GeneratedMessage {

            public static func == (lhs: Tensorflow.GraphTransferInfo.NodeOutputInfo, rhs: Tensorflow.GraphTransferInfo.NodeOutputInfo) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasNodeId == rhs.hasNodeId) && (!lhs.hasNodeId || lhs.nodeId == rhs.nodeId)
                fieldCheck = fieldCheck && (lhs.maxByteSize == rhs.maxByteSize)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var nodeId:Int32 = Int32(0)
            public fileprivate(set) var hasNodeId:Bool = false

            public fileprivate(set) var maxByteSize:Array<Int32> = Array<Int32>()
            private var maxByteSizeMemoizedSerializedSize:Int32 = -1
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasNodeId {
                    try codedOutputStream.writeInt32(fieldNumber: 1, value:nodeId)
                }
                if !maxByteSize.isEmpty {
                    try codedOutputStream.writeRawVarint32(value: 18)
                    try codedOutputStream.writeRawVarint32(value: maxByteSizeMemoizedSerializedSize)
                    for oneValuemaxByteSize in maxByteSize {
                        try codedOutputStream.writeInt32NoTag(value: oneValuemaxByteSize)
                    }
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasNodeId {
                    serialize_size += nodeId.computeInt32Size(fieldNumber: 1)
                }
                var dataSizeMaxByteSize:Int32 = 0
                for oneValuemaxByteSize in maxByteSize {
                    dataSizeMaxByteSize += oneValuemaxByteSize.computeInt32SizeNoTag()
                }
                serialize_size += dataSizeMaxByteSize
                if !maxByteSize.isEmpty {
                    serialize_size += 1
                    serialize_size += dataSizeMaxByteSize.computeInt32SizeNoTag()
                }
                maxByteSizeMemoizedSerializedSize = dataSizeMaxByteSize
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.GraphTransferInfo.NodeOutputInfo.Builder {
                return Tensorflow.GraphTransferInfo.NodeOutputInfo.classBuilder() as! Tensorflow.GraphTransferInfo.NodeOutputInfo.Builder
            }
            public func getBuilder() -> Tensorflow.GraphTransferInfo.NodeOutputInfo.Builder {
                return classBuilder() as! Tensorflow.GraphTransferInfo.NodeOutputInfo.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.GraphTransferInfo.NodeOutputInfo.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.GraphTransferInfo.NodeOutputInfo.Builder()
            }
            public func toBuilder() throws -> Tensorflow.GraphTransferInfo.NodeOutputInfo.Builder {
                return try Tensorflow.GraphTransferInfo.NodeOutputInfo.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.GraphTransferInfo.NodeOutputInfo) throws -> Tensorflow.GraphTransferInfo.NodeOutputInfo.Builder {
                return try Tensorflow.GraphTransferInfo.NodeOutputInfo.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasNodeId {
                    jsonMap["nodeId"] = Int(nodeId)
                }
                if !maxByteSize.isEmpty {
                    var jsonArrayMaxByteSize:Array<Int> = []
                    for oneValueMaxByteSize in maxByteSize {
                        jsonArrayMaxByteSize.append(Int(oneValueMaxByteSize))
                    }
                    jsonMap["maxByteSize"] = jsonArrayMaxByteSize
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.GraphTransferInfo.NodeOutputInfo {
                return try Tensorflow.GraphTransferInfo.NodeOutputInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.GraphTransferInfo.NodeOutputInfo {
                return try Tensorflow.GraphTransferInfo.NodeOutputInfo.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasNodeId {
                    output += "\(indent) nodeId: \(nodeId) \n"
                }
                var maxByteSizeElementIndex:Int = 0
                for oneValueMaxByteSize in maxByteSize  {
                    output += "\(indent) maxByteSize[\(maxByteSizeElementIndex)]: \(oneValueMaxByteSize)\n"
                    maxByteSizeElementIndex += 1
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasNodeId {
                        hashCode = (hashCode &* 31) &+ nodeId.hashValue
                    }
                    for oneValueMaxByteSize in maxByteSize {
                        hashCode = (hashCode &* 31) &+ oneValueMaxByteSize.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.GraphTransferInfo.NodeOutputInfo"
            }
            override public func className() -> String {
                return "Tensorflow.GraphTransferInfo.NodeOutputInfo"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.GraphTransferInfo.NodeOutputInfo = Tensorflow.GraphTransferInfo.NodeOutputInfo()
                public func getMessage() -> Tensorflow.GraphTransferInfo.NodeOutputInfo {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var nodeId:Int32 {
                    get {
                        return builderResult.nodeId
                    }
                    set (value) {
                        builderResult.hasNodeId = true
                        builderResult.nodeId = value
                    }
                }
                public var hasNodeId:Bool {
                    get {
                        return builderResult.hasNodeId
                    }
                }
                @discardableResult
                public func setNodeId(_ value:Int32) -> Tensorflow.GraphTransferInfo.NodeOutputInfo.Builder {
                    self.nodeId = value
                    return self
                }
                @discardableResult
                public func clearNodeId() -> Tensorflow.GraphTransferInfo.NodeOutputInfo.Builder{
                    builderResult.hasNodeId = false
                    builderResult.nodeId = Int32(0)
                    return self
                }
                public var maxByteSize:Array<Int32> {
                    get {
                        return builderResult.maxByteSize
                    }
                    set (array) {
                        builderResult.maxByteSize = array
                    }
                }
                @discardableResult
                public func setMaxByteSize(_ value:Array<Int32>) -> Tensorflow.GraphTransferInfo.NodeOutputInfo.Builder {
                    self.maxByteSize = value
                    return self
                }
                @discardableResult
                public func clearMaxByteSize() -> Tensorflow.GraphTransferInfo.NodeOutputInfo.Builder {
                    builderResult.maxByteSize.removeAll(keepingCapacity: false)
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.GraphTransferInfo.NodeOutputInfo.Builder {
                    builderResult = Tensorflow.GraphTransferInfo.NodeOutputInfo()
                    return self
                }
                override public func clone() throws -> Tensorflow.GraphTransferInfo.NodeOutputInfo.Builder {
                    return try Tensorflow.GraphTransferInfo.NodeOutputInfo.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.GraphTransferInfo.NodeOutputInfo {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.GraphTransferInfo.NodeOutputInfo {
                    let returnMe:Tensorflow.GraphTransferInfo.NodeOutputInfo = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.GraphTransferInfo.NodeOutputInfo) throws -> Tensorflow.GraphTransferInfo.NodeOutputInfo.Builder {
                    if other == Tensorflow.GraphTransferInfo.NodeOutputInfo() {
                        return self
                    }
                    if other.hasNodeId {
                        nodeId = other.nodeId
                    }
                    if !other.maxByteSize.isEmpty {
                        builderResult.maxByteSize += other.maxByteSize
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.GraphTransferInfo.NodeOutputInfo.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphTransferInfo.NodeOutputInfo.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 8:
                            nodeId = try codedInputStream.readInt32()

                        case 18:
                            let length = Int(try codedInputStream.readRawVarint32())
                            let limit = try codedInputStream.pushLimit(byteLimit: length)
                            while (codedInputStream.bytesUntilLimit() > 0) {
                                builderResult.maxByteSize.append(try codedInputStream.readInt32())
                            }
                            codedInputStream.popLimit(oldLimit: limit)

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.GraphTransferInfo.NodeOutputInfo.Builder {
                    let resultDecodedBuilder = Tensorflow.GraphTransferInfo.NodeOutputInfo.Builder()
                    if let jsonValueNodeId = jsonMap["nodeId"] as? Int {
                        resultDecodedBuilder.nodeId = Int32(jsonValueNodeId)
                    } else if let jsonValueNodeId = jsonMap["nodeId"] as? String {
                        resultDecodedBuilder.nodeId = Int32(jsonValueNodeId)!
                    }
                    if let jsonValueMaxByteSize = jsonMap["maxByteSize"] as? Array<Int> {
                        var jsonArrayMaxByteSize:Array<Int32> = []
                        for oneValueMaxByteSize in jsonValueMaxByteSize {
                            jsonArrayMaxByteSize.append(Int32(oneValueMaxByteSize))
                        }
                        resultDecodedBuilder.maxByteSize = jsonArrayMaxByteSize
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.GraphTransferInfo.NodeOutputInfo.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.GraphTransferInfo.NodeOutputInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        final public class GraphInputNodeInfo : GeneratedMessage {

            public static func == (lhs: Tensorflow.GraphTransferInfo.GraphInputNodeInfo, rhs: Tensorflow.GraphTransferInfo.GraphInputNodeInfo) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
                fieldCheck = fieldCheck && (lhs.shape == rhs.shape)
                fieldCheck = fieldCheck && (lhs.hasDtype == rhs.hasDtype) && (!lhs.hasDtype || lhs.dtype == rhs.dtype)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var name:String = ""
            public fileprivate(set) var hasName:Bool = false

            public fileprivate(set) var shape:Array<Int64> = Array<Int64>()
            private var shapeMemoizedSerializedSize:Int32 = -1
            public fileprivate(set) var dtype:Tensorflow.DataType = Tensorflow.DataType.dtInvalid
            public fileprivate(set) var hasDtype:Bool = false
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasName {
                    try codedOutputStream.writeString(fieldNumber: 1, value:name)
                }
                if !shape.isEmpty {
                    try codedOutputStream.writeRawVarint32(value: 18)
                    try codedOutputStream.writeRawVarint32(value: shapeMemoizedSerializedSize)
                    for oneValueshape in shape {
                        try codedOutputStream.writeInt64NoTag(value: oneValueshape)
                    }
                }
                if hasDtype {
                    try codedOutputStream.writeEnum(fieldNumber: 3, value:dtype.rawValue)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasName {
                    serialize_size += name.computeStringSize(fieldNumber: 1)
                }
                var dataSizeShape:Int32 = 0
                for oneValueshape in shape {
                    dataSizeShape += oneValueshape.computeInt64SizeNoTag()
                }
                serialize_size += dataSizeShape
                if !shape.isEmpty {
                    serialize_size += 1
                    serialize_size += dataSizeShape.computeInt32SizeNoTag()
                }
                shapeMemoizedSerializedSize = dataSizeShape
                if (hasDtype) {
                    serialize_size += dtype.rawValue.computeEnumSize(fieldNumber: 3)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder {
                return Tensorflow.GraphTransferInfo.GraphInputNodeInfo.classBuilder() as! Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder
            }
            public func getBuilder() -> Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder {
                return classBuilder() as! Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder()
            }
            public func toBuilder() throws -> Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder {
                return try Tensorflow.GraphTransferInfo.GraphInputNodeInfo.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.GraphTransferInfo.GraphInputNodeInfo) throws -> Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder {
                return try Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasName {
                    jsonMap["name"] = name
                }
                if !shape.isEmpty {
                    var jsonArrayShape:Array<String> = []
                    for oneValueShape in shape {
                        jsonArrayShape.append("\(oneValueShape)")
                    }
                    jsonMap["shape"] = jsonArrayShape
                }
                if hasDtype {
                    jsonMap["dtype"] = dtype.toString()
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.GraphTransferInfo.GraphInputNodeInfo {
                return try Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.GraphTransferInfo.GraphInputNodeInfo {
                return try Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasName {
                    output += "\(indent) name: \(name) \n"
                }
                var shapeElementIndex:Int = 0
                for oneValueShape in shape  {
                    output += "\(indent) shape[\(shapeElementIndex)]: \(oneValueShape)\n"
                    shapeElementIndex += 1
                }
                if (hasDtype) {
                    output += "\(indent) dtype: \(dtype.description)\n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasName {
                        hashCode = (hashCode &* 31) &+ name.hashValue
                    }
                    for oneValueShape in shape {
                        hashCode = (hashCode &* 31) &+ oneValueShape.hashValue
                    }
                    if hasDtype {
                         hashCode = (hashCode &* 31) &+ dtype.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.GraphTransferInfo.GraphInputNodeInfo"
            }
            override public func className() -> String {
                return "Tensorflow.GraphTransferInfo.GraphInputNodeInfo"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.GraphTransferInfo.GraphInputNodeInfo = Tensorflow.GraphTransferInfo.GraphInputNodeInfo()
                public func getMessage() -> Tensorflow.GraphTransferInfo.GraphInputNodeInfo {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var name:String {
                    get {
                        return builderResult.name
                    }
                    set (value) {
                        builderResult.hasName = true
                        builderResult.name = value
                    }
                }
                public var hasName:Bool {
                    get {
                        return builderResult.hasName
                    }
                }
                @discardableResult
                public func setName(_ value:String) -> Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder {
                    self.name = value
                    return self
                }
                @discardableResult
                public func clearName() -> Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder{
                    builderResult.hasName = false
                    builderResult.name = ""
                    return self
                }
                public var shape:Array<Int64> {
                    get {
                        return builderResult.shape
                    }
                    set (array) {
                        builderResult.shape = array
                    }
                }
                @discardableResult
                public func setShape(_ value:Array<Int64>) -> Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder {
                    self.shape = value
                    return self
                }
                @discardableResult
                public func clearShape() -> Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder {
                    builderResult.shape.removeAll(keepingCapacity: false)
                    return self
                }
                    public var dtype:Tensorflow.DataType {
                        get {
                            return builderResult.dtype
                        }
                        set (value) {
                            builderResult.hasDtype = true
                            builderResult.dtype = value
                        }
                    }
                    public var hasDtype:Bool{
                        get {
                            return builderResult.hasDtype
                        }
                    }
                @discardableResult
                    public func setDtype(_ value:Tensorflow.DataType) -> Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder {
                      self.dtype = value
                      return self
                    }
                @discardableResult
                    public func clearDtype() -> Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder {
                       builderResult.hasDtype = false
                       builderResult.dtype = .dtInvalid
                       return self
                    }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder {
                    builderResult = Tensorflow.GraphTransferInfo.GraphInputNodeInfo()
                    return self
                }
                override public func clone() throws -> Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder {
                    return try Tensorflow.GraphTransferInfo.GraphInputNodeInfo.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.GraphTransferInfo.GraphInputNodeInfo {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.GraphTransferInfo.GraphInputNodeInfo {
                    let returnMe:Tensorflow.GraphTransferInfo.GraphInputNodeInfo = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.GraphTransferInfo.GraphInputNodeInfo) throws -> Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder {
                    if other == Tensorflow.GraphTransferInfo.GraphInputNodeInfo() {
                        return self
                    }
                    if other.hasName {
                        name = other.name
                    }
                    if !other.shape.isEmpty {
                        builderResult.shape += other.shape
                    }
                    if other.hasDtype {
                        dtype = other.dtype
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            name = try codedInputStream.readString()

                        case 18:
                            let length = Int(try codedInputStream.readRawVarint32())
                            let limit = try codedInputStream.pushLimit(byteLimit: length)
                            while (codedInputStream.bytesUntilLimit() > 0) {
                                builderResult.shape.append(try codedInputStream.readInt64())
                            }
                            codedInputStream.popLimit(oldLimit: limit)

                        case 24:
                            let valueIntdtype = try codedInputStream.readEnum()
                            if let enumsdtype = Tensorflow.DataType(rawValue:valueIntdtype){
                                dtype = enumsdtype
                            } else {
                                try unknownFieldsBuilder.mergeVarintField(fieldNumber: 3, value:Int64(valueIntdtype))
                            }

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder {
                    let resultDecodedBuilder = Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder()
                    if let jsonValueName = jsonMap["name"] as? String {
                        resultDecodedBuilder.name = jsonValueName
                    }
                    if let jsonValueShape = jsonMap["shape"] as? Array<String> {
                        var jsonArrayShape:Array<Int64> = []
                        for oneValueShape in jsonValueShape {
                            jsonArrayShape.append(Int64(oneValueShape)!)
                        }
                        resultDecodedBuilder.shape = jsonArrayShape
                    }
                    if let jsonValueDtype = jsonMap["dtype"] as? String {
                        resultDecodedBuilder.dtype = try Tensorflow.DataType.fromString(str: jsonValueDtype)
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        final public class GraphOutputNodeInfo : GeneratedMessage {

            public static func == (lhs: Tensorflow.GraphTransferInfo.GraphOutputNodeInfo, rhs: Tensorflow.GraphTransferInfo.GraphOutputNodeInfo) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
                fieldCheck = fieldCheck && (lhs.shape == rhs.shape)
                fieldCheck = fieldCheck && (lhs.hasDtype == rhs.hasDtype) && (!lhs.hasDtype || lhs.dtype == rhs.dtype)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var name:String = ""
            public fileprivate(set) var hasName:Bool = false

            public fileprivate(set) var shape:Array<Int64> = Array<Int64>()
            private var shapeMemoizedSerializedSize:Int32 = -1
            public fileprivate(set) var dtype:Tensorflow.DataType = Tensorflow.DataType.dtInvalid
            public fileprivate(set) var hasDtype:Bool = false
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasName {
                    try codedOutputStream.writeString(fieldNumber: 1, value:name)
                }
                if !shape.isEmpty {
                    try codedOutputStream.writeRawVarint32(value: 18)
                    try codedOutputStream.writeRawVarint32(value: shapeMemoizedSerializedSize)
                    for oneValueshape in shape {
                        try codedOutputStream.writeInt64NoTag(value: oneValueshape)
                    }
                }
                if hasDtype {
                    try codedOutputStream.writeEnum(fieldNumber: 3, value:dtype.rawValue)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasName {
                    serialize_size += name.computeStringSize(fieldNumber: 1)
                }
                var dataSizeShape:Int32 = 0
                for oneValueshape in shape {
                    dataSizeShape += oneValueshape.computeInt64SizeNoTag()
                }
                serialize_size += dataSizeShape
                if !shape.isEmpty {
                    serialize_size += 1
                    serialize_size += dataSizeShape.computeInt32SizeNoTag()
                }
                shapeMemoizedSerializedSize = dataSizeShape
                if (hasDtype) {
                    serialize_size += dtype.rawValue.computeEnumSize(fieldNumber: 3)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder {
                return Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.classBuilder() as! Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder
            }
            public func getBuilder() -> Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder {
                return classBuilder() as! Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder()
            }
            public func toBuilder() throws -> Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder {
                return try Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.GraphTransferInfo.GraphOutputNodeInfo) throws -> Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder {
                return try Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasName {
                    jsonMap["name"] = name
                }
                if !shape.isEmpty {
                    var jsonArrayShape:Array<String> = []
                    for oneValueShape in shape {
                        jsonArrayShape.append("\(oneValueShape)")
                    }
                    jsonMap["shape"] = jsonArrayShape
                }
                if hasDtype {
                    jsonMap["dtype"] = dtype.toString()
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.GraphTransferInfo.GraphOutputNodeInfo {
                return try Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.GraphTransferInfo.GraphOutputNodeInfo {
                return try Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasName {
                    output += "\(indent) name: \(name) \n"
                }
                var shapeElementIndex:Int = 0
                for oneValueShape in shape  {
                    output += "\(indent) shape[\(shapeElementIndex)]: \(oneValueShape)\n"
                    shapeElementIndex += 1
                }
                if (hasDtype) {
                    output += "\(indent) dtype: \(dtype.description)\n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasName {
                        hashCode = (hashCode &* 31) &+ name.hashValue
                    }
                    for oneValueShape in shape {
                        hashCode = (hashCode &* 31) &+ oneValueShape.hashValue
                    }
                    if hasDtype {
                         hashCode = (hashCode &* 31) &+ dtype.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.GraphTransferInfo.GraphOutputNodeInfo"
            }
            override public func className() -> String {
                return "Tensorflow.GraphTransferInfo.GraphOutputNodeInfo"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.GraphTransferInfo.GraphOutputNodeInfo = Tensorflow.GraphTransferInfo.GraphOutputNodeInfo()
                public func getMessage() -> Tensorflow.GraphTransferInfo.GraphOutputNodeInfo {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var name:String {
                    get {
                        return builderResult.name
                    }
                    set (value) {
                        builderResult.hasName = true
                        builderResult.name = value
                    }
                }
                public var hasName:Bool {
                    get {
                        return builderResult.hasName
                    }
                }
                @discardableResult
                public func setName(_ value:String) -> Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder {
                    self.name = value
                    return self
                }
                @discardableResult
                public func clearName() -> Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder{
                    builderResult.hasName = false
                    builderResult.name = ""
                    return self
                }
                public var shape:Array<Int64> {
                    get {
                        return builderResult.shape
                    }
                    set (array) {
                        builderResult.shape = array
                    }
                }
                @discardableResult
                public func setShape(_ value:Array<Int64>) -> Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder {
                    self.shape = value
                    return self
                }
                @discardableResult
                public func clearShape() -> Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder {
                    builderResult.shape.removeAll(keepingCapacity: false)
                    return self
                }
                    public var dtype:Tensorflow.DataType {
                        get {
                            return builderResult.dtype
                        }
                        set (value) {
                            builderResult.hasDtype = true
                            builderResult.dtype = value
                        }
                    }
                    public var hasDtype:Bool{
                        get {
                            return builderResult.hasDtype
                        }
                    }
                @discardableResult
                    public func setDtype(_ value:Tensorflow.DataType) -> Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder {
                      self.dtype = value
                      return self
                    }
                @discardableResult
                    public func clearDtype() -> Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder {
                       builderResult.hasDtype = false
                       builderResult.dtype = .dtInvalid
                       return self
                    }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder {
                    builderResult = Tensorflow.GraphTransferInfo.GraphOutputNodeInfo()
                    return self
                }
                override public func clone() throws -> Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder {
                    return try Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.GraphTransferInfo.GraphOutputNodeInfo {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.GraphTransferInfo.GraphOutputNodeInfo {
                    let returnMe:Tensorflow.GraphTransferInfo.GraphOutputNodeInfo = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.GraphTransferInfo.GraphOutputNodeInfo) throws -> Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder {
                    if other == Tensorflow.GraphTransferInfo.GraphOutputNodeInfo() {
                        return self
                    }
                    if other.hasName {
                        name = other.name
                    }
                    if !other.shape.isEmpty {
                        builderResult.shape += other.shape
                    }
                    if other.hasDtype {
                        dtype = other.dtype
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            name = try codedInputStream.readString()

                        case 18:
                            let length = Int(try codedInputStream.readRawVarint32())
                            let limit = try codedInputStream.pushLimit(byteLimit: length)
                            while (codedInputStream.bytesUntilLimit() > 0) {
                                builderResult.shape.append(try codedInputStream.readInt64())
                            }
                            codedInputStream.popLimit(oldLimit: limit)

                        case 24:
                            let valueIntdtype = try codedInputStream.readEnum()
                            if let enumsdtype = Tensorflow.DataType(rawValue:valueIntdtype){
                                dtype = enumsdtype
                            } else {
                                try unknownFieldsBuilder.mergeVarintField(fieldNumber: 3, value:Int64(valueIntdtype))
                            }

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder {
                    let resultDecodedBuilder = Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder()
                    if let jsonValueName = jsonMap["name"] as? String {
                        resultDecodedBuilder.name = jsonValueName
                    }
                    if let jsonValueShape = jsonMap["shape"] as? Array<String> {
                        var jsonArrayShape:Array<Int64> = []
                        for oneValueShape in jsonValueShape {
                            jsonArrayShape.append(Int64(oneValueShape)!)
                        }
                        resultDecodedBuilder.shape = jsonArrayShape
                    }
                    if let jsonValueDtype = jsonMap["dtype"] as? String {
                        resultDecodedBuilder.dtype = try Tensorflow.DataType.fromString(str: jsonValueDtype)
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



            //Enum type declaration start 

            public enum Destination:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
                case nop = 0
                case hexagon = 1
                public func toString() -> String {
                    switch self {
                    case .nop: return "NOP"
                    case .hexagon: return "HEXAGON"
                    }
                }
                public static func fromString(str:String) throws -> Tensorflow.GraphTransferInfo.Destination {
                    switch str {
                    case "NOP":    return .nop
                    case "HEXAGON":    return .hexagon
                    default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
                    }
                }
                public var debugDescription:String { return getDescription() }
                public var description:String { return getDescription() }
                private func getDescription() -> String { 
                    switch self {
                    case .nop: return ".nop"
                    case .hexagon: return ".hexagon"
                    }
                }
                public var hashValue:Int {
                    return self.rawValue.hashValue
                }
                public static func ==(lhs:Destination, rhs:Destination) -> Bool {
                    return lhs.hashValue == rhs.hashValue
                }
            }

            //Enum type declaration end 

        public fileprivate(set) var nodeInfo:Array<Tensorflow.GraphTransferInfo.NodeInfo>  = Array<Tensorflow.GraphTransferInfo.NodeInfo>()
        public fileprivate(set) var constNodeInfo:Array<Tensorflow.GraphTransferInfo.ConstNodeInfo>  = Array<Tensorflow.GraphTransferInfo.ConstNodeInfo>()
        public fileprivate(set) var nodeInputInfo:Array<Tensorflow.GraphTransferInfo.NodeInputInfo>  = Array<Tensorflow.GraphTransferInfo.NodeInputInfo>()
        public fileprivate(set) var nodeOutputInfo:Array<Tensorflow.GraphTransferInfo.NodeOutputInfo>  = Array<Tensorflow.GraphTransferInfo.NodeOutputInfo>()
        public fileprivate(set) var graphInputNodeInfo:Array<Tensorflow.GraphTransferInfo.GraphInputNodeInfo>  = Array<Tensorflow.GraphTransferInfo.GraphInputNodeInfo>()
        public fileprivate(set) var graphOutputNodeInfo:Array<Tensorflow.GraphTransferInfo.GraphOutputNodeInfo>  = Array<Tensorflow.GraphTransferInfo.GraphOutputNodeInfo>()
        public fileprivate(set) var destination:Tensorflow.GraphTransferInfo.Destination = Tensorflow.GraphTransferInfo.Destination.nop
        public fileprivate(set) var hasDestination:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementNodeInfo in nodeInfo {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementNodeInfo)
            }
            for oneElementConstNodeInfo in constNodeInfo {
                  try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementConstNodeInfo)
            }
            for oneElementNodeInputInfo in nodeInputInfo {
                  try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementNodeInputInfo)
            }
            for oneElementNodeOutputInfo in nodeOutputInfo {
                  try codedOutputStream.writeMessage(fieldNumber: 4, value:oneElementNodeOutputInfo)
            }
            for oneElementGraphInputNodeInfo in graphInputNodeInfo {
                  try codedOutputStream.writeMessage(fieldNumber: 5, value:oneElementGraphInputNodeInfo)
            }
            for oneElementGraphOutputNodeInfo in graphOutputNodeInfo {
                  try codedOutputStream.writeMessage(fieldNumber: 6, value:oneElementGraphOutputNodeInfo)
            }
            if hasDestination {
                try codedOutputStream.writeEnum(fieldNumber: 7, value:destination.rawValue)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementNodeInfo in nodeInfo {
                serialize_size += oneElementNodeInfo.computeMessageSize(fieldNumber: 1)
            }
            for oneElementConstNodeInfo in constNodeInfo {
                serialize_size += oneElementConstNodeInfo.computeMessageSize(fieldNumber: 2)
            }
            for oneElementNodeInputInfo in nodeInputInfo {
                serialize_size += oneElementNodeInputInfo.computeMessageSize(fieldNumber: 3)
            }
            for oneElementNodeOutputInfo in nodeOutputInfo {
                serialize_size += oneElementNodeOutputInfo.computeMessageSize(fieldNumber: 4)
            }
            for oneElementGraphInputNodeInfo in graphInputNodeInfo {
                serialize_size += oneElementGraphInputNodeInfo.computeMessageSize(fieldNumber: 5)
            }
            for oneElementGraphOutputNodeInfo in graphOutputNodeInfo {
                serialize_size += oneElementGraphOutputNodeInfo.computeMessageSize(fieldNumber: 6)
            }
            if (hasDestination) {
                serialize_size += destination.rawValue.computeEnumSize(fieldNumber: 7)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.GraphTransferInfo.Builder {
            return Tensorflow.GraphTransferInfo.classBuilder() as! Tensorflow.GraphTransferInfo.Builder
        }
        public func getBuilder() -> Tensorflow.GraphTransferInfo.Builder {
            return classBuilder() as! Tensorflow.GraphTransferInfo.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.GraphTransferInfo.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.GraphTransferInfo.Builder()
        }
        public func toBuilder() throws -> Tensorflow.GraphTransferInfo.Builder {
            return try Tensorflow.GraphTransferInfo.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.GraphTransferInfo) throws -> Tensorflow.GraphTransferInfo.Builder {
            return try Tensorflow.GraphTransferInfo.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !nodeInfo.isEmpty {
                var jsonArrayNodeInfo:Array<Dictionary<String,Any>> = []
                for oneValueNodeInfo in nodeInfo {
                    let ecodedMessageNodeInfo = try oneValueNodeInfo.encode()
                    jsonArrayNodeInfo.append(ecodedMessageNodeInfo)
                }
                jsonMap["nodeInfo"] = jsonArrayNodeInfo
            }
            if !constNodeInfo.isEmpty {
                var jsonArrayConstNodeInfo:Array<Dictionary<String,Any>> = []
                for oneValueConstNodeInfo in constNodeInfo {
                    let ecodedMessageConstNodeInfo = try oneValueConstNodeInfo.encode()
                    jsonArrayConstNodeInfo.append(ecodedMessageConstNodeInfo)
                }
                jsonMap["constNodeInfo"] = jsonArrayConstNodeInfo
            }
            if !nodeInputInfo.isEmpty {
                var jsonArrayNodeInputInfo:Array<Dictionary<String,Any>> = []
                for oneValueNodeInputInfo in nodeInputInfo {
                    let ecodedMessageNodeInputInfo = try oneValueNodeInputInfo.encode()
                    jsonArrayNodeInputInfo.append(ecodedMessageNodeInputInfo)
                }
                jsonMap["nodeInputInfo"] = jsonArrayNodeInputInfo
            }
            if !nodeOutputInfo.isEmpty {
                var jsonArrayNodeOutputInfo:Array<Dictionary<String,Any>> = []
                for oneValueNodeOutputInfo in nodeOutputInfo {
                    let ecodedMessageNodeOutputInfo = try oneValueNodeOutputInfo.encode()
                    jsonArrayNodeOutputInfo.append(ecodedMessageNodeOutputInfo)
                }
                jsonMap["nodeOutputInfo"] = jsonArrayNodeOutputInfo
            }
            if !graphInputNodeInfo.isEmpty {
                var jsonArrayGraphInputNodeInfo:Array<Dictionary<String,Any>> = []
                for oneValueGraphInputNodeInfo in graphInputNodeInfo {
                    let ecodedMessageGraphInputNodeInfo = try oneValueGraphInputNodeInfo.encode()
                    jsonArrayGraphInputNodeInfo.append(ecodedMessageGraphInputNodeInfo)
                }
                jsonMap["graphInputNodeInfo"] = jsonArrayGraphInputNodeInfo
            }
            if !graphOutputNodeInfo.isEmpty {
                var jsonArrayGraphOutputNodeInfo:Array<Dictionary<String,Any>> = []
                for oneValueGraphOutputNodeInfo in graphOutputNodeInfo {
                    let ecodedMessageGraphOutputNodeInfo = try oneValueGraphOutputNodeInfo.encode()
                    jsonArrayGraphOutputNodeInfo.append(ecodedMessageGraphOutputNodeInfo)
                }
                jsonMap["graphOutputNodeInfo"] = jsonArrayGraphOutputNodeInfo
            }
            if hasDestination {
                jsonMap["destination"] = destination.toString()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.GraphTransferInfo {
            return try Tensorflow.GraphTransferInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.GraphTransferInfo {
            return try Tensorflow.GraphTransferInfo.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var nodeInfoElementIndex:Int = 0
            for oneElementNodeInfo in nodeInfo {
                output += "\(indent) nodeInfo[\(nodeInfoElementIndex)] {\n"
                output += try oneElementNodeInfo.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                nodeInfoElementIndex += 1
            }
            var constNodeInfoElementIndex:Int = 0
            for oneElementConstNodeInfo in constNodeInfo {
                output += "\(indent) constNodeInfo[\(constNodeInfoElementIndex)] {\n"
                output += try oneElementConstNodeInfo.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                constNodeInfoElementIndex += 1
            }
            var nodeInputInfoElementIndex:Int = 0
            for oneElementNodeInputInfo in nodeInputInfo {
                output += "\(indent) nodeInputInfo[\(nodeInputInfoElementIndex)] {\n"
                output += try oneElementNodeInputInfo.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                nodeInputInfoElementIndex += 1
            }
            var nodeOutputInfoElementIndex:Int = 0
            for oneElementNodeOutputInfo in nodeOutputInfo {
                output += "\(indent) nodeOutputInfo[\(nodeOutputInfoElementIndex)] {\n"
                output += try oneElementNodeOutputInfo.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                nodeOutputInfoElementIndex += 1
            }
            var graphInputNodeInfoElementIndex:Int = 0
            for oneElementGraphInputNodeInfo in graphInputNodeInfo {
                output += "\(indent) graphInputNodeInfo[\(graphInputNodeInfoElementIndex)] {\n"
                output += try oneElementGraphInputNodeInfo.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                graphInputNodeInfoElementIndex += 1
            }
            var graphOutputNodeInfoElementIndex:Int = 0
            for oneElementGraphOutputNodeInfo in graphOutputNodeInfo {
                output += "\(indent) graphOutputNodeInfo[\(graphOutputNodeInfoElementIndex)] {\n"
                output += try oneElementGraphOutputNodeInfo.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                graphOutputNodeInfoElementIndex += 1
            }
            if (hasDestination) {
                output += "\(indent) destination: \(destination.description)\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementNodeInfo in nodeInfo {
                    hashCode = (hashCode &* 31) &+ oneElementNodeInfo.hashValue
                }
                for oneElementConstNodeInfo in constNodeInfo {
                    hashCode = (hashCode &* 31) &+ oneElementConstNodeInfo.hashValue
                }
                for oneElementNodeInputInfo in nodeInputInfo {
                    hashCode = (hashCode &* 31) &+ oneElementNodeInputInfo.hashValue
                }
                for oneElementNodeOutputInfo in nodeOutputInfo {
                    hashCode = (hashCode &* 31) &+ oneElementNodeOutputInfo.hashValue
                }
                for oneElementGraphInputNodeInfo in graphInputNodeInfo {
                    hashCode = (hashCode &* 31) &+ oneElementGraphInputNodeInfo.hashValue
                }
                for oneElementGraphOutputNodeInfo in graphOutputNodeInfo {
                    hashCode = (hashCode &* 31) &+ oneElementGraphOutputNodeInfo.hashValue
                }
                if hasDestination {
                     hashCode = (hashCode &* 31) &+ destination.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.GraphTransferInfo"
        }
        override public func className() -> String {
            return "Tensorflow.GraphTransferInfo"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.GraphTransferInfo = Tensorflow.GraphTransferInfo()
            public func getMessage() -> Tensorflow.GraphTransferInfo {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var nodeInfo:Array<Tensorflow.GraphTransferInfo.NodeInfo> {
                get {
                    return builderResult.nodeInfo
                }
                set (value) {
                    builderResult.nodeInfo = value
                }
            }
            @discardableResult
            public func setNodeInfo(_ value:Array<Tensorflow.GraphTransferInfo.NodeInfo>) -> Tensorflow.GraphTransferInfo.Builder {
                self.nodeInfo = value
                return self
            }
            @discardableResult
            public func clearNodeInfo() -> Tensorflow.GraphTransferInfo.Builder {
                builderResult.nodeInfo.removeAll(keepingCapacity: false)
                return self
            }
            public var constNodeInfo:Array<Tensorflow.GraphTransferInfo.ConstNodeInfo> {
                get {
                    return builderResult.constNodeInfo
                }
                set (value) {
                    builderResult.constNodeInfo = value
                }
            }
            @discardableResult
            public func setConstNodeInfo(_ value:Array<Tensorflow.GraphTransferInfo.ConstNodeInfo>) -> Tensorflow.GraphTransferInfo.Builder {
                self.constNodeInfo = value
                return self
            }
            @discardableResult
            public func clearConstNodeInfo() -> Tensorflow.GraphTransferInfo.Builder {
                builderResult.constNodeInfo.removeAll(keepingCapacity: false)
                return self
            }
            public var nodeInputInfo:Array<Tensorflow.GraphTransferInfo.NodeInputInfo> {
                get {
                    return builderResult.nodeInputInfo
                }
                set (value) {
                    builderResult.nodeInputInfo = value
                }
            }
            @discardableResult
            public func setNodeInputInfo(_ value:Array<Tensorflow.GraphTransferInfo.NodeInputInfo>) -> Tensorflow.GraphTransferInfo.Builder {
                self.nodeInputInfo = value
                return self
            }
            @discardableResult
            public func clearNodeInputInfo() -> Tensorflow.GraphTransferInfo.Builder {
                builderResult.nodeInputInfo.removeAll(keepingCapacity: false)
                return self
            }
            public var nodeOutputInfo:Array<Tensorflow.GraphTransferInfo.NodeOutputInfo> {
                get {
                    return builderResult.nodeOutputInfo
                }
                set (value) {
                    builderResult.nodeOutputInfo = value
                }
            }
            @discardableResult
            public func setNodeOutputInfo(_ value:Array<Tensorflow.GraphTransferInfo.NodeOutputInfo>) -> Tensorflow.GraphTransferInfo.Builder {
                self.nodeOutputInfo = value
                return self
            }
            @discardableResult
            public func clearNodeOutputInfo() -> Tensorflow.GraphTransferInfo.Builder {
                builderResult.nodeOutputInfo.removeAll(keepingCapacity: false)
                return self
            }
            /// Input Node parameters of transferred graph
            public var graphInputNodeInfo:Array<Tensorflow.GraphTransferInfo.GraphInputNodeInfo> {
                get {
                    return builderResult.graphInputNodeInfo
                }
                set (value) {
                    builderResult.graphInputNodeInfo = value
                }
            }
            @discardableResult
            public func setGraphInputNodeInfo(_ value:Array<Tensorflow.GraphTransferInfo.GraphInputNodeInfo>) -> Tensorflow.GraphTransferInfo.Builder {
                self.graphInputNodeInfo = value
                return self
            }
            @discardableResult
            public func clearGraphInputNodeInfo() -> Tensorflow.GraphTransferInfo.Builder {
                builderResult.graphInputNodeInfo.removeAll(keepingCapacity: false)
                return self
            }
            public var graphOutputNodeInfo:Array<Tensorflow.GraphTransferInfo.GraphOutputNodeInfo> {
                get {
                    return builderResult.graphOutputNodeInfo
                }
                set (value) {
                    builderResult.graphOutputNodeInfo = value
                }
            }
            @discardableResult
            public func setGraphOutputNodeInfo(_ value:Array<Tensorflow.GraphTransferInfo.GraphOutputNodeInfo>) -> Tensorflow.GraphTransferInfo.Builder {
                self.graphOutputNodeInfo = value
                return self
            }
            @discardableResult
            public func clearGraphOutputNodeInfo() -> Tensorflow.GraphTransferInfo.Builder {
                builderResult.graphOutputNodeInfo.removeAll(keepingCapacity: false)
                return self
            }
            /// Destination of graph transfer
                public var destination:Tensorflow.GraphTransferInfo.Destination {
                    get {
                        return builderResult.destination
                    }
                    set (value) {
                        builderResult.hasDestination = true
                        builderResult.destination = value
                    }
                }
                public var hasDestination:Bool{
                    get {
                        return builderResult.hasDestination
                    }
                }
            @discardableResult
                public func setDestination(_ value:Tensorflow.GraphTransferInfo.Destination) -> Tensorflow.GraphTransferInfo.Builder {
                  self.destination = value
                  return self
                }
            @discardableResult
                public func clearDestination() -> Tensorflow.GraphTransferInfo.Builder {
                   builderResult.hasDestination = false
                   builderResult.destination = .nop
                   return self
                }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.GraphTransferInfo.Builder {
                builderResult = Tensorflow.GraphTransferInfo()
                return self
            }
            override public func clone() throws -> Tensorflow.GraphTransferInfo.Builder {
                return try Tensorflow.GraphTransferInfo.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.GraphTransferInfo {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.GraphTransferInfo {
                let returnMe:Tensorflow.GraphTransferInfo = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.GraphTransferInfo) throws -> Tensorflow.GraphTransferInfo.Builder {
                if other == Tensorflow.GraphTransferInfo() {
                    return self
                }
                if !other.nodeInfo.isEmpty  {
                     builderResult.nodeInfo += other.nodeInfo
                }
                if !other.constNodeInfo.isEmpty  {
                     builderResult.constNodeInfo += other.constNodeInfo
                }
                if !other.nodeInputInfo.isEmpty  {
                     builderResult.nodeInputInfo += other.nodeInputInfo
                }
                if !other.nodeOutputInfo.isEmpty  {
                     builderResult.nodeOutputInfo += other.nodeOutputInfo
                }
                if !other.graphInputNodeInfo.isEmpty  {
                     builderResult.graphInputNodeInfo += other.graphInputNodeInfo
                }
                if !other.graphOutputNodeInfo.isEmpty  {
                     builderResult.graphOutputNodeInfo += other.graphOutputNodeInfo
                }
                if other.hasDestination {
                    destination = other.destination
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.GraphTransferInfo.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphTransferInfo.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Tensorflow.GraphTransferInfo.NodeInfo.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        nodeInfo.append(subBuilder.buildPartial())

                    case 18:
                        let subBuilder = Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        constNodeInfo.append(subBuilder.buildPartial())

                    case 26:
                        let subBuilder = Tensorflow.GraphTransferInfo.NodeInputInfo.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        nodeInputInfo.append(subBuilder.buildPartial())

                    case 34:
                        let subBuilder = Tensorflow.GraphTransferInfo.NodeOutputInfo.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        nodeOutputInfo.append(subBuilder.buildPartial())

                    case 42:
                        let subBuilder = Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        graphInputNodeInfo.append(subBuilder.buildPartial())

                    case 50:
                        let subBuilder = Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        graphOutputNodeInfo.append(subBuilder.buildPartial())

                    case 56:
                        let valueIntdestination = try codedInputStream.readEnum()
                        if let enumsdestination = Tensorflow.GraphTransferInfo.Destination(rawValue:valueIntdestination){
                            destination = enumsdestination
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 7, value:Int64(valueIntdestination))
                        }

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.GraphTransferInfo.Builder {
                let resultDecodedBuilder = Tensorflow.GraphTransferInfo.Builder()
                if let jsonValueNodeInfo = jsonMap["nodeInfo"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayNodeInfo:Array<Tensorflow.GraphTransferInfo.NodeInfo> = []
                    for oneValueNodeInfo in jsonValueNodeInfo {
                        let messageFromStringNodeInfo = try Tensorflow.GraphTransferInfo.NodeInfo.Builder.decodeToBuilder(jsonMap:oneValueNodeInfo).build()

                        jsonArrayNodeInfo.append(messageFromStringNodeInfo)
                    }
                    resultDecodedBuilder.nodeInfo = jsonArrayNodeInfo
                }
                if let jsonValueConstNodeInfo = jsonMap["constNodeInfo"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayConstNodeInfo:Array<Tensorflow.GraphTransferInfo.ConstNodeInfo> = []
                    for oneValueConstNodeInfo in jsonValueConstNodeInfo {
                        let messageFromStringConstNodeInfo = try Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder.decodeToBuilder(jsonMap:oneValueConstNodeInfo).build()

                        jsonArrayConstNodeInfo.append(messageFromStringConstNodeInfo)
                    }
                    resultDecodedBuilder.constNodeInfo = jsonArrayConstNodeInfo
                }
                if let jsonValueNodeInputInfo = jsonMap["nodeInputInfo"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayNodeInputInfo:Array<Tensorflow.GraphTransferInfo.NodeInputInfo> = []
                    for oneValueNodeInputInfo in jsonValueNodeInputInfo {
                        let messageFromStringNodeInputInfo = try Tensorflow.GraphTransferInfo.NodeInputInfo.Builder.decodeToBuilder(jsonMap:oneValueNodeInputInfo).build()

                        jsonArrayNodeInputInfo.append(messageFromStringNodeInputInfo)
                    }
                    resultDecodedBuilder.nodeInputInfo = jsonArrayNodeInputInfo
                }
                if let jsonValueNodeOutputInfo = jsonMap["nodeOutputInfo"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayNodeOutputInfo:Array<Tensorflow.GraphTransferInfo.NodeOutputInfo> = []
                    for oneValueNodeOutputInfo in jsonValueNodeOutputInfo {
                        let messageFromStringNodeOutputInfo = try Tensorflow.GraphTransferInfo.NodeOutputInfo.Builder.decodeToBuilder(jsonMap:oneValueNodeOutputInfo).build()

                        jsonArrayNodeOutputInfo.append(messageFromStringNodeOutputInfo)
                    }
                    resultDecodedBuilder.nodeOutputInfo = jsonArrayNodeOutputInfo
                }
                if let jsonValueGraphInputNodeInfo = jsonMap["graphInputNodeInfo"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayGraphInputNodeInfo:Array<Tensorflow.GraphTransferInfo.GraphInputNodeInfo> = []
                    for oneValueGraphInputNodeInfo in jsonValueGraphInputNodeInfo {
                        let messageFromStringGraphInputNodeInfo = try Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder.decodeToBuilder(jsonMap:oneValueGraphInputNodeInfo).build()

                        jsonArrayGraphInputNodeInfo.append(messageFromStringGraphInputNodeInfo)
                    }
                    resultDecodedBuilder.graphInputNodeInfo = jsonArrayGraphInputNodeInfo
                }
                if let jsonValueGraphOutputNodeInfo = jsonMap["graphOutputNodeInfo"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayGraphOutputNodeInfo:Array<Tensorflow.GraphTransferInfo.GraphOutputNodeInfo> = []
                    for oneValueGraphOutputNodeInfo in jsonValueGraphOutputNodeInfo {
                        let messageFromStringGraphOutputNodeInfo = try Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder.decodeToBuilder(jsonMap:oneValueGraphOutputNodeInfo).build()

                        jsonArrayGraphOutputNodeInfo.append(messageFromStringGraphOutputNodeInfo)
                    }
                    resultDecodedBuilder.graphOutputNodeInfo = jsonArrayGraphOutputNodeInfo
                }
                if let jsonValueDestination = jsonMap["destination"] as? String {
                    resultDecodedBuilder.destination = try Tensorflow.GraphTransferInfo.Destination.fromString(str: jsonValueDestination)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.GraphTransferInfo.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.GraphTransferInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.GraphTransferInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.GraphTransferInfo> {
        var mergedArray = Array<Tensorflow.GraphTransferInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.GraphTransferInfo? {
        return try Tensorflow.GraphTransferInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.GraphTransferInfo {
        return try Tensorflow.GraphTransferInfo.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.GraphTransferInfoRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphTransferInfo {
        return try Tensorflow.GraphTransferInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.GraphTransferInfo {
        return try Tensorflow.GraphTransferInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphTransferInfo {
        return try Tensorflow.GraphTransferInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.GraphTransferInfo {
        return try Tensorflow.GraphTransferInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphTransferInfo {
        return try Tensorflow.GraphTransferInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "nodeInfo": return self.nodeInfo
        case "constNodeInfo": return self.constNodeInfo
        case "nodeInputInfo": return self.nodeInputInfo
        case "nodeOutputInfo": return self.nodeOutputInfo
        case "graphInputNodeInfo": return self.graphInputNodeInfo
        case "graphOutputNodeInfo": return self.graphOutputNodeInfo
        case "destination": return self.destination
        default: return nil
        }
    }
}
extension Tensorflow.GraphTransferInfo.NodeInput: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.GraphTransferInfo.NodeInput> {
        var mergedArray = Array<Tensorflow.GraphTransferInfo.NodeInput>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.GraphTransferInfo.NodeInput? {
        return try Tensorflow.GraphTransferInfo.NodeInput.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.GraphTransferInfo.NodeInput {
        return try Tensorflow.GraphTransferInfo.NodeInput.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.GraphTransferInfoRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphTransferInfo.NodeInput {
        return try Tensorflow.GraphTransferInfo.NodeInput.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.GraphTransferInfo.NodeInput {
        return try Tensorflow.GraphTransferInfo.NodeInput.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphTransferInfo.NodeInput {
        return try Tensorflow.GraphTransferInfo.NodeInput.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.GraphTransferInfo.NodeInput {
        return try Tensorflow.GraphTransferInfo.NodeInput.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphTransferInfo.NodeInput {
        return try Tensorflow.GraphTransferInfo.NodeInput.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "nodeId": return self.nodeId
        case "outputPort": return self.outputPort
        default: return nil
        }
    }
}
extension Tensorflow.GraphTransferInfo.NodeInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.GraphTransferInfo.NodeInfo> {
        var mergedArray = Array<Tensorflow.GraphTransferInfo.NodeInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.GraphTransferInfo.NodeInfo? {
        return try Tensorflow.GraphTransferInfo.NodeInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.GraphTransferInfo.NodeInfo {
        return try Tensorflow.GraphTransferInfo.NodeInfo.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.GraphTransferInfoRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphTransferInfo.NodeInfo {
        return try Tensorflow.GraphTransferInfo.NodeInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.GraphTransferInfo.NodeInfo {
        return try Tensorflow.GraphTransferInfo.NodeInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphTransferInfo.NodeInfo {
        return try Tensorflow.GraphTransferInfo.NodeInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.GraphTransferInfo.NodeInfo {
        return try Tensorflow.GraphTransferInfo.NodeInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphTransferInfo.NodeInfo {
        return try Tensorflow.GraphTransferInfo.NodeInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "name": return self.name
        case "nodeId": return self.nodeId
        case "typeName": return self.typeName
        case "socOpId": return self.socOpId
        case "paddingId": return self.paddingId
        case "inputCount": return self.inputCount
        case "outputCount": return self.outputCount
        default: return nil
        }
    }
}
extension Tensorflow.GraphTransferInfo.ConstNodeInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.GraphTransferInfo.ConstNodeInfo> {
        var mergedArray = Array<Tensorflow.GraphTransferInfo.ConstNodeInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.GraphTransferInfo.ConstNodeInfo? {
        return try Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.GraphTransferInfo.ConstNodeInfo {
        return try Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.GraphTransferInfoRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphTransferInfo.ConstNodeInfo {
        return try Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.GraphTransferInfo.ConstNodeInfo {
        return try Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphTransferInfo.ConstNodeInfo {
        return try Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.GraphTransferInfo.ConstNodeInfo {
        return try Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphTransferInfo.ConstNodeInfo {
        return try Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "name": return self.name
        case "nodeId": return self.nodeId
        case "shape": return self.shape
        case "data": return self.data
        case "dtype": return self.dtype
        default: return nil
        }
    }
}
extension Tensorflow.GraphTransferInfo.NodeInputInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.GraphTransferInfo.NodeInputInfo> {
        var mergedArray = Array<Tensorflow.GraphTransferInfo.NodeInputInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.GraphTransferInfo.NodeInputInfo? {
        return try Tensorflow.GraphTransferInfo.NodeInputInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.GraphTransferInfo.NodeInputInfo {
        return try Tensorflow.GraphTransferInfo.NodeInputInfo.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.GraphTransferInfoRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphTransferInfo.NodeInputInfo {
        return try Tensorflow.GraphTransferInfo.NodeInputInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.GraphTransferInfo.NodeInputInfo {
        return try Tensorflow.GraphTransferInfo.NodeInputInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphTransferInfo.NodeInputInfo {
        return try Tensorflow.GraphTransferInfo.NodeInputInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.GraphTransferInfo.NodeInputInfo {
        return try Tensorflow.GraphTransferInfo.NodeInputInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphTransferInfo.NodeInputInfo {
        return try Tensorflow.GraphTransferInfo.NodeInputInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "nodeId": return self.nodeId
        case "nodeInput": return self.nodeInput
        default: return nil
        }
    }
}
extension Tensorflow.GraphTransferInfo.NodeOutputInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.GraphTransferInfo.NodeOutputInfo> {
        var mergedArray = Array<Tensorflow.GraphTransferInfo.NodeOutputInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.GraphTransferInfo.NodeOutputInfo? {
        return try Tensorflow.GraphTransferInfo.NodeOutputInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.GraphTransferInfo.NodeOutputInfo {
        return try Tensorflow.GraphTransferInfo.NodeOutputInfo.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.GraphTransferInfoRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphTransferInfo.NodeOutputInfo {
        return try Tensorflow.GraphTransferInfo.NodeOutputInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.GraphTransferInfo.NodeOutputInfo {
        return try Tensorflow.GraphTransferInfo.NodeOutputInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphTransferInfo.NodeOutputInfo {
        return try Tensorflow.GraphTransferInfo.NodeOutputInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.GraphTransferInfo.NodeOutputInfo {
        return try Tensorflow.GraphTransferInfo.NodeOutputInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphTransferInfo.NodeOutputInfo {
        return try Tensorflow.GraphTransferInfo.NodeOutputInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "nodeId": return self.nodeId
        case "maxByteSize": return self.maxByteSize
        default: return nil
        }
    }
}
extension Tensorflow.GraphTransferInfo.GraphInputNodeInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.GraphTransferInfo.GraphInputNodeInfo> {
        var mergedArray = Array<Tensorflow.GraphTransferInfo.GraphInputNodeInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.GraphTransferInfo.GraphInputNodeInfo? {
        return try Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.GraphTransferInfo.GraphInputNodeInfo {
        return try Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.GraphTransferInfoRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphTransferInfo.GraphInputNodeInfo {
        return try Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.GraphTransferInfo.GraphInputNodeInfo {
        return try Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphTransferInfo.GraphInputNodeInfo {
        return try Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.GraphTransferInfo.GraphInputNodeInfo {
        return try Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphTransferInfo.GraphInputNodeInfo {
        return try Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "name": return self.name
        case "shape": return self.shape
        case "dtype": return self.dtype
        default: return nil
        }
    }
}
extension Tensorflow.GraphTransferInfo.GraphOutputNodeInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.GraphTransferInfo.GraphOutputNodeInfo> {
        var mergedArray = Array<Tensorflow.GraphTransferInfo.GraphOutputNodeInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.GraphTransferInfo.GraphOutputNodeInfo? {
        return try Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.GraphTransferInfo.GraphOutputNodeInfo {
        return try Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.GraphTransferInfoRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphTransferInfo.GraphOutputNodeInfo {
        return try Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.GraphTransferInfo.GraphOutputNodeInfo {
        return try Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphTransferInfo.GraphOutputNodeInfo {
        return try Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.GraphTransferInfo.GraphOutputNodeInfo {
        return try Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphTransferInfo.GraphOutputNodeInfo {
        return try Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "name": return self.name
        case "shape": return self.shape
        case "dtype": return self.dtype
        default: return nil
        }
    }
}
extension Tensorflow.GraphTransferInfo.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "nodeInfo": return self.nodeInfo
            case "constNodeInfo": return self.constNodeInfo
            case "nodeInputInfo": return self.nodeInputInfo
            case "nodeOutputInfo": return self.nodeOutputInfo
            case "graphInputNodeInfo": return self.graphInputNodeInfo
            case "graphOutputNodeInfo": return self.graphOutputNodeInfo
            case "destination": return self.destination
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "nodeInfo":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.GraphTransferInfo.NodeInfo> else {
                    return
                }
                self.nodeInfo = newSubscriptValue
            case "constNodeInfo":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.GraphTransferInfo.ConstNodeInfo> else {
                    return
                }
                self.constNodeInfo = newSubscriptValue
            case "nodeInputInfo":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.GraphTransferInfo.NodeInputInfo> else {
                    return
                }
                self.nodeInputInfo = newSubscriptValue
            case "nodeOutputInfo":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.GraphTransferInfo.NodeOutputInfo> else {
                    return
                }
                self.nodeOutputInfo = newSubscriptValue
            case "graphInputNodeInfo":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.GraphTransferInfo.GraphInputNodeInfo> else {
                    return
                }
                self.graphInputNodeInfo = newSubscriptValue
            case "graphOutputNodeInfo":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.GraphTransferInfo.GraphOutputNodeInfo> else {
                    return
                }
                self.graphOutputNodeInfo = newSubscriptValue
            case "destination":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.GraphTransferInfo.Destination else {
                    return
                }
                self.destination = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.GraphTransferInfo.NodeInput.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "nodeId": return self.nodeId
            case "outputPort": return self.outputPort
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "nodeId":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.nodeId = newSubscriptValue
            case "outputPort":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.outputPort = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.GraphTransferInfo.NodeInfo.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "name": return self.name
            case "nodeId": return self.nodeId
            case "typeName": return self.typeName
            case "socOpId": return self.socOpId
            case "paddingId": return self.paddingId
            case "inputCount": return self.inputCount
            case "outputCount": return self.outputCount
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "nodeId":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.nodeId = newSubscriptValue
            case "typeName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.typeName = newSubscriptValue
            case "socOpId":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.socOpId = newSubscriptValue
            case "paddingId":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.paddingId = newSubscriptValue
            case "inputCount":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.inputCount = newSubscriptValue
            case "outputCount":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.outputCount = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.GraphTransferInfo.ConstNodeInfo.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "name": return self.name
            case "nodeId": return self.nodeId
            case "shape": return self.shape
            case "data": return self.data
            case "dtype": return self.dtype
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "nodeId":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.nodeId = newSubscriptValue
            case "shape":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.shape = newSubscriptValue
            case "data":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.data = newSubscriptValue
            case "dtype":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.DataType else {
                    return
                }
                self.dtype = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.GraphTransferInfo.NodeInputInfo.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "nodeId": return self.nodeId
            case "nodeInput": return self.nodeInput
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "nodeId":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.nodeId = newSubscriptValue
            case "nodeInput":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.GraphTransferInfo.NodeInput> else {
                    return
                }
                self.nodeInput = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.GraphTransferInfo.NodeOutputInfo.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "nodeId": return self.nodeId
            case "maxByteSize": return self.maxByteSize
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "nodeId":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.nodeId = newSubscriptValue
            case "maxByteSize":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int32> else {
                    return
                }
                self.maxByteSize = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.GraphTransferInfo.GraphInputNodeInfo.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "name": return self.name
            case "shape": return self.shape
            case "dtype": return self.dtype
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "shape":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.shape = newSubscriptValue
            case "dtype":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.DataType else {
                    return
                }
                self.dtype = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.GraphTransferInfo.GraphOutputNodeInfo.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "name": return self.name
            case "shape": return self.shape
            case "dtype": return self.dtype
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "shape":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.shape = newSubscriptValue
            case "dtype":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.DataType else {
                    return
                }
                self.dtype = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

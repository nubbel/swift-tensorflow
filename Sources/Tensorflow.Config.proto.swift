/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "config.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { }

public extension Tensorflow {
    public struct ConfigRoot {
        public static let `default` = ConfigRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Tensorflow.CostGraphRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.GraphRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.StepStatsRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.DebugRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.RewriterConfigRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    final public class Gpuoptions : GeneratedMessage {

        public static func == (lhs: Tensorflow.Gpuoptions, rhs: Tensorflow.Gpuoptions) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasPerProcessGpuMemoryFraction == rhs.hasPerProcessGpuMemoryFraction) && (!lhs.hasPerProcessGpuMemoryFraction || lhs.perProcessGpuMemoryFraction == rhs.perProcessGpuMemoryFraction)
            fieldCheck = fieldCheck && (lhs.hasAllocatorType == rhs.hasAllocatorType) && (!lhs.hasAllocatorType || lhs.allocatorType == rhs.allocatorType)
            fieldCheck = fieldCheck && (lhs.hasDeferredDeletionBytes == rhs.hasDeferredDeletionBytes) && (!lhs.hasDeferredDeletionBytes || lhs.deferredDeletionBytes == rhs.deferredDeletionBytes)
            fieldCheck = fieldCheck && (lhs.hasAllowGrowth == rhs.hasAllowGrowth) && (!lhs.hasAllowGrowth || lhs.allowGrowth == rhs.allowGrowth)
            fieldCheck = fieldCheck && (lhs.hasVisibleDeviceList == rhs.hasVisibleDeviceList) && (!lhs.hasVisibleDeviceList || lhs.visibleDeviceList == rhs.visibleDeviceList)
            fieldCheck = fieldCheck && (lhs.hasPollingActiveDelayUsecs == rhs.hasPollingActiveDelayUsecs) && (!lhs.hasPollingActiveDelayUsecs || lhs.pollingActiveDelayUsecs == rhs.pollingActiveDelayUsecs)
            fieldCheck = fieldCheck && (lhs.hasPollingInactiveDelayMsecs == rhs.hasPollingInactiveDelayMsecs) && (!lhs.hasPollingInactiveDelayMsecs || lhs.pollingInactiveDelayMsecs == rhs.pollingInactiveDelayMsecs)
            fieldCheck = fieldCheck && (lhs.hasForceGpuCompatible == rhs.hasForceGpuCompatible) && (!lhs.hasForceGpuCompatible || lhs.forceGpuCompatible == rhs.forceGpuCompatible)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// A value between 0 and 1 that indicates what fraction of the
        /// available GPU memory to pre-allocate for each process.  1 means
        /// to pre-allocate all of the GPU memory, 0.5 means the process
        /// allocates ~50% of the available GPU memory.
        public fileprivate(set) var perProcessGpuMemoryFraction:Double = Double(0)
        public fileprivate(set) var hasPerProcessGpuMemoryFraction:Bool = false

        /// The type of GPU allocation strategy to use.
        /// Allowed values:
        /// "": The empty string (default) uses a system-chosen default
        ///     which may change over time.
        /// "BFC": A "Best-fit with coalescing" algorithm, simplified from a
        ///        version of dlmalloc.
        public fileprivate(set) var allocatorType:String = ""
        public fileprivate(set) var hasAllocatorType:Bool = false

        /// Delay deletion of up to this many bytes to reduce the number of
        /// interactions with gpu driver code.  If 0, the system chooses
        /// a reasonable default (several MBs).
        public fileprivate(set) var deferredDeletionBytes:Int64 = Int64(0)
        public fileprivate(set) var hasDeferredDeletionBytes:Bool = false

        /// If true, the allocator does not pre-allocate the entire specified
        /// GPU memory region, instead starting small and growing as needed.
        public fileprivate(set) var allowGrowth:Bool = false
        public fileprivate(set) var hasAllowGrowth:Bool = false

        /// A comma-separated list of GPU ids that determines the 'visible'
        /// to 'virtual' mapping of GPU devices.  For example, if TensorFlow
        /// can see 8 GPU devices in the process, and one wanted to map
        /// visible GPU devices 5 and 3 as "/gpu:0", and "/gpu:1", then one
        /// would specify this field as "5,3".  This field is similar in
        /// spirit to the CUDA_VISIBLE_DEVICES environment variable, except
        /// it applies to the visible GPU devices in the process.
        /// NOTE: The GPU driver provides the process with the visible GPUs
        /// in an order which is not guaranteed to have any correlation to
        /// the *physical* GPU id in the machine.  This field is used for
        /// remapping "visible" to "virtual", which means this operates only
        /// after the process starts.  Users are required to use vendor
        /// specific mechanisms (e.g., CUDA_VISIBLE_DEVICES) to control the
        /// physical to visible device mapping prior to invoking TensorFlow.
        public fileprivate(set) var visibleDeviceList:String = ""
        public fileprivate(set) var hasVisibleDeviceList:Bool = false

        /// In the event polling loop sleep this many microseconds between
        /// PollEvents calls, when the queue is not empty.  If value is not
        /// set or set to 0, gets set to a non-zero default.
        public fileprivate(set) var pollingActiveDelayUsecs:Int32 = Int32(0)
        public fileprivate(set) var hasPollingActiveDelayUsecs:Bool = false

        /// In the event polling loop sleep this many millisconds between
        /// PollEvents calls, when the queue is empty.  If value is not
        /// set or set to 0, gets set to a non-zero default.
        public fileprivate(set) var pollingInactiveDelayMsecs:Int32 = Int32(0)
        public fileprivate(set) var hasPollingInactiveDelayMsecs:Bool = false

        /// Force all tensors to be gpu_compatible. On a GPU-enabled TensorFlow,
        /// enabling this option forces all CPU tensors to be allocated with Cuda
        /// pinned memory. Normally, TensorFlow will infer which tensors should be
        /// allocated as the pinned memory. But in case where the inference is
        /// incomplete, this option can significantly speed up the cross-device memory
        /// copy performance as long as it fits the memory.
        /// Note that this option is not something that should be
        /// enabled by default for unknown or very large models, since all Cuda pinned
        /// memory is unpageable, having too much pinned memory might negatively impact
        /// the overall host system performance.
        public fileprivate(set) var forceGpuCompatible:Bool = false
        public fileprivate(set) var hasForceGpuCompatible:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasPerProcessGpuMemoryFraction {
                try codedOutputStream.writeDouble(fieldNumber: 1, value:perProcessGpuMemoryFraction)
            }
            if hasAllocatorType {
                try codedOutputStream.writeString(fieldNumber: 2, value:allocatorType)
            }
            if hasDeferredDeletionBytes {
                try codedOutputStream.writeInt64(fieldNumber: 3, value:deferredDeletionBytes)
            }
            if hasAllowGrowth {
                try codedOutputStream.writeBool(fieldNumber: 4, value:allowGrowth)
            }
            if hasVisibleDeviceList {
                try codedOutputStream.writeString(fieldNumber: 5, value:visibleDeviceList)
            }
            if hasPollingActiveDelayUsecs {
                try codedOutputStream.writeInt32(fieldNumber: 6, value:pollingActiveDelayUsecs)
            }
            if hasPollingInactiveDelayMsecs {
                try codedOutputStream.writeInt32(fieldNumber: 7, value:pollingInactiveDelayMsecs)
            }
            if hasForceGpuCompatible {
                try codedOutputStream.writeBool(fieldNumber: 8, value:forceGpuCompatible)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasPerProcessGpuMemoryFraction {
                serialize_size += perProcessGpuMemoryFraction.computeDoubleSize(fieldNumber: 1)
            }
            if hasAllocatorType {
                serialize_size += allocatorType.computeStringSize(fieldNumber: 2)
            }
            if hasDeferredDeletionBytes {
                serialize_size += deferredDeletionBytes.computeInt64Size(fieldNumber: 3)
            }
            if hasAllowGrowth {
                serialize_size += allowGrowth.computeBoolSize(fieldNumber: 4)
            }
            if hasVisibleDeviceList {
                serialize_size += visibleDeviceList.computeStringSize(fieldNumber: 5)
            }
            if hasPollingActiveDelayUsecs {
                serialize_size += pollingActiveDelayUsecs.computeInt32Size(fieldNumber: 6)
            }
            if hasPollingInactiveDelayMsecs {
                serialize_size += pollingInactiveDelayMsecs.computeInt32Size(fieldNumber: 7)
            }
            if hasForceGpuCompatible {
                serialize_size += forceGpuCompatible.computeBoolSize(fieldNumber: 8)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.Gpuoptions.Builder {
            return Tensorflow.Gpuoptions.classBuilder() as! Tensorflow.Gpuoptions.Builder
        }
        public func getBuilder() -> Tensorflow.Gpuoptions.Builder {
            return classBuilder() as! Tensorflow.Gpuoptions.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Gpuoptions.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Gpuoptions.Builder()
        }
        public func toBuilder() throws -> Tensorflow.Gpuoptions.Builder {
            return try Tensorflow.Gpuoptions.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.Gpuoptions) throws -> Tensorflow.Gpuoptions.Builder {
            return try Tensorflow.Gpuoptions.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasPerProcessGpuMemoryFraction {
                jsonMap["perProcessGpuMemoryFraction"] = Double(perProcessGpuMemoryFraction)
            }
            if hasAllocatorType {
                jsonMap["allocatorType"] = allocatorType
            }
            if hasDeferredDeletionBytes {
                jsonMap["deferredDeletionBytes"] = "\(deferredDeletionBytes)"
            }
            if hasAllowGrowth {
                jsonMap["allowGrowth"] = allowGrowth
            }
            if hasVisibleDeviceList {
                jsonMap["visibleDeviceList"] = visibleDeviceList
            }
            if hasPollingActiveDelayUsecs {
                jsonMap["pollingActiveDelayUsecs"] = Int(pollingActiveDelayUsecs)
            }
            if hasPollingInactiveDelayMsecs {
                jsonMap["pollingInactiveDelayMsecs"] = Int(pollingInactiveDelayMsecs)
            }
            if hasForceGpuCompatible {
                jsonMap["forceGpuCompatible"] = forceGpuCompatible
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Gpuoptions {
            return try Tensorflow.Gpuoptions.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.Gpuoptions {
            return try Tensorflow.Gpuoptions.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasPerProcessGpuMemoryFraction {
                output += "\(indent) perProcessGpuMemoryFraction: \(perProcessGpuMemoryFraction) \n"
            }
            if hasAllocatorType {
                output += "\(indent) allocatorType: \(allocatorType) \n"
            }
            if hasDeferredDeletionBytes {
                output += "\(indent) deferredDeletionBytes: \(deferredDeletionBytes) \n"
            }
            if hasAllowGrowth {
                output += "\(indent) allowGrowth: \(allowGrowth) \n"
            }
            if hasVisibleDeviceList {
                output += "\(indent) visibleDeviceList: \(visibleDeviceList) \n"
            }
            if hasPollingActiveDelayUsecs {
                output += "\(indent) pollingActiveDelayUsecs: \(pollingActiveDelayUsecs) \n"
            }
            if hasPollingInactiveDelayMsecs {
                output += "\(indent) pollingInactiveDelayMsecs: \(pollingInactiveDelayMsecs) \n"
            }
            if hasForceGpuCompatible {
                output += "\(indent) forceGpuCompatible: \(forceGpuCompatible) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasPerProcessGpuMemoryFraction {
                    hashCode = (hashCode &* 31) &+ perProcessGpuMemoryFraction.hashValue
                }
                if hasAllocatorType {
                    hashCode = (hashCode &* 31) &+ allocatorType.hashValue
                }
                if hasDeferredDeletionBytes {
                    hashCode = (hashCode &* 31) &+ deferredDeletionBytes.hashValue
                }
                if hasAllowGrowth {
                    hashCode = (hashCode &* 31) &+ allowGrowth.hashValue
                }
                if hasVisibleDeviceList {
                    hashCode = (hashCode &* 31) &+ visibleDeviceList.hashValue
                }
                if hasPollingActiveDelayUsecs {
                    hashCode = (hashCode &* 31) &+ pollingActiveDelayUsecs.hashValue
                }
                if hasPollingInactiveDelayMsecs {
                    hashCode = (hashCode &* 31) &+ pollingInactiveDelayMsecs.hashValue
                }
                if hasForceGpuCompatible {
                    hashCode = (hashCode &* 31) &+ forceGpuCompatible.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.Gpuoptions"
        }
        override public func className() -> String {
            return "Tensorflow.Gpuoptions"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.Gpuoptions = Tensorflow.Gpuoptions()
            public func getMessage() -> Tensorflow.Gpuoptions {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// A value between 0 and 1 that indicates what fraction of the
            /// available GPU memory to pre-allocate for each process.  1 means
            /// to pre-allocate all of the GPU memory, 0.5 means the process
            /// allocates ~50% of the available GPU memory.
            public var perProcessGpuMemoryFraction:Double {
                get {
                    return builderResult.perProcessGpuMemoryFraction
                }
                set (value) {
                    builderResult.hasPerProcessGpuMemoryFraction = true
                    builderResult.perProcessGpuMemoryFraction = value
                }
            }
            public var hasPerProcessGpuMemoryFraction:Bool {
                get {
                    return builderResult.hasPerProcessGpuMemoryFraction
                }
            }
            @discardableResult
            public func setPerProcessGpuMemoryFraction(_ value:Double) -> Tensorflow.Gpuoptions.Builder {
                self.perProcessGpuMemoryFraction = value
                return self
            }
            @discardableResult
            public func clearPerProcessGpuMemoryFraction() -> Tensorflow.Gpuoptions.Builder{
                builderResult.hasPerProcessGpuMemoryFraction = false
                builderResult.perProcessGpuMemoryFraction = Double(0)
                return self
            }
            /// The type of GPU allocation strategy to use.
            /// Allowed values:
            /// "": The empty string (default) uses a system-chosen default
            ///     which may change over time.
            /// "BFC": A "Best-fit with coalescing" algorithm, simplified from a
            ///        version of dlmalloc.
            public var allocatorType:String {
                get {
                    return builderResult.allocatorType
                }
                set (value) {
                    builderResult.hasAllocatorType = true
                    builderResult.allocatorType = value
                }
            }
            public var hasAllocatorType:Bool {
                get {
                    return builderResult.hasAllocatorType
                }
            }
            @discardableResult
            public func setAllocatorType(_ value:String) -> Tensorflow.Gpuoptions.Builder {
                self.allocatorType = value
                return self
            }
            @discardableResult
            public func clearAllocatorType() -> Tensorflow.Gpuoptions.Builder{
                builderResult.hasAllocatorType = false
                builderResult.allocatorType = ""
                return self
            }
            /// Delay deletion of up to this many bytes to reduce the number of
            /// interactions with gpu driver code.  If 0, the system chooses
            /// a reasonable default (several MBs).
            public var deferredDeletionBytes:Int64 {
                get {
                    return builderResult.deferredDeletionBytes
                }
                set (value) {
                    builderResult.hasDeferredDeletionBytes = true
                    builderResult.deferredDeletionBytes = value
                }
            }
            public var hasDeferredDeletionBytes:Bool {
                get {
                    return builderResult.hasDeferredDeletionBytes
                }
            }
            @discardableResult
            public func setDeferredDeletionBytes(_ value:Int64) -> Tensorflow.Gpuoptions.Builder {
                self.deferredDeletionBytes = value
                return self
            }
            @discardableResult
            public func clearDeferredDeletionBytes() -> Tensorflow.Gpuoptions.Builder{
                builderResult.hasDeferredDeletionBytes = false
                builderResult.deferredDeletionBytes = Int64(0)
                return self
            }
            /// If true, the allocator does not pre-allocate the entire specified
            /// GPU memory region, instead starting small and growing as needed.
            public var allowGrowth:Bool {
                get {
                    return builderResult.allowGrowth
                }
                set (value) {
                    builderResult.hasAllowGrowth = true
                    builderResult.allowGrowth = value
                }
            }
            public var hasAllowGrowth:Bool {
                get {
                    return builderResult.hasAllowGrowth
                }
            }
            @discardableResult
            public func setAllowGrowth(_ value:Bool) -> Tensorflow.Gpuoptions.Builder {
                self.allowGrowth = value
                return self
            }
            @discardableResult
            public func clearAllowGrowth() -> Tensorflow.Gpuoptions.Builder{
                builderResult.hasAllowGrowth = false
                builderResult.allowGrowth = false
                return self
            }
            /// A comma-separated list of GPU ids that determines the 'visible'
            /// to 'virtual' mapping of GPU devices.  For example, if TensorFlow
            /// can see 8 GPU devices in the process, and one wanted to map
            /// visible GPU devices 5 and 3 as "/gpu:0", and "/gpu:1", then one
            /// would specify this field as "5,3".  This field is similar in
            /// spirit to the CUDA_VISIBLE_DEVICES environment variable, except
            /// it applies to the visible GPU devices in the process.
            /// NOTE: The GPU driver provides the process with the visible GPUs
            /// in an order which is not guaranteed to have any correlation to
            /// the *physical* GPU id in the machine.  This field is used for
            /// remapping "visible" to "virtual", which means this operates only
            /// after the process starts.  Users are required to use vendor
            /// specific mechanisms (e.g., CUDA_VISIBLE_DEVICES) to control the
            /// physical to visible device mapping prior to invoking TensorFlow.
            public var visibleDeviceList:String {
                get {
                    return builderResult.visibleDeviceList
                }
                set (value) {
                    builderResult.hasVisibleDeviceList = true
                    builderResult.visibleDeviceList = value
                }
            }
            public var hasVisibleDeviceList:Bool {
                get {
                    return builderResult.hasVisibleDeviceList
                }
            }
            @discardableResult
            public func setVisibleDeviceList(_ value:String) -> Tensorflow.Gpuoptions.Builder {
                self.visibleDeviceList = value
                return self
            }
            @discardableResult
            public func clearVisibleDeviceList() -> Tensorflow.Gpuoptions.Builder{
                builderResult.hasVisibleDeviceList = false
                builderResult.visibleDeviceList = ""
                return self
            }
            /// In the event polling loop sleep this many microseconds between
            /// PollEvents calls, when the queue is not empty.  If value is not
            /// set or set to 0, gets set to a non-zero default.
            public var pollingActiveDelayUsecs:Int32 {
                get {
                    return builderResult.pollingActiveDelayUsecs
                }
                set (value) {
                    builderResult.hasPollingActiveDelayUsecs = true
                    builderResult.pollingActiveDelayUsecs = value
                }
            }
            public var hasPollingActiveDelayUsecs:Bool {
                get {
                    return builderResult.hasPollingActiveDelayUsecs
                }
            }
            @discardableResult
            public func setPollingActiveDelayUsecs(_ value:Int32) -> Tensorflow.Gpuoptions.Builder {
                self.pollingActiveDelayUsecs = value
                return self
            }
            @discardableResult
            public func clearPollingActiveDelayUsecs() -> Tensorflow.Gpuoptions.Builder{
                builderResult.hasPollingActiveDelayUsecs = false
                builderResult.pollingActiveDelayUsecs = Int32(0)
                return self
            }
            /// In the event polling loop sleep this many millisconds between
            /// PollEvents calls, when the queue is empty.  If value is not
            /// set or set to 0, gets set to a non-zero default.
            public var pollingInactiveDelayMsecs:Int32 {
                get {
                    return builderResult.pollingInactiveDelayMsecs
                }
                set (value) {
                    builderResult.hasPollingInactiveDelayMsecs = true
                    builderResult.pollingInactiveDelayMsecs = value
                }
            }
            public var hasPollingInactiveDelayMsecs:Bool {
                get {
                    return builderResult.hasPollingInactiveDelayMsecs
                }
            }
            @discardableResult
            public func setPollingInactiveDelayMsecs(_ value:Int32) -> Tensorflow.Gpuoptions.Builder {
                self.pollingInactiveDelayMsecs = value
                return self
            }
            @discardableResult
            public func clearPollingInactiveDelayMsecs() -> Tensorflow.Gpuoptions.Builder{
                builderResult.hasPollingInactiveDelayMsecs = false
                builderResult.pollingInactiveDelayMsecs = Int32(0)
                return self
            }
            /// Force all tensors to be gpu_compatible. On a GPU-enabled TensorFlow,
            /// enabling this option forces all CPU tensors to be allocated with Cuda
            /// pinned memory. Normally, TensorFlow will infer which tensors should be
            /// allocated as the pinned memory. But in case where the inference is
            /// incomplete, this option can significantly speed up the cross-device memory
            /// copy performance as long as it fits the memory.
            /// Note that this option is not something that should be
            /// enabled by default for unknown or very large models, since all Cuda pinned
            /// memory is unpageable, having too much pinned memory might negatively impact
            /// the overall host system performance.
            public var forceGpuCompatible:Bool {
                get {
                    return builderResult.forceGpuCompatible
                }
                set (value) {
                    builderResult.hasForceGpuCompatible = true
                    builderResult.forceGpuCompatible = value
                }
            }
            public var hasForceGpuCompatible:Bool {
                get {
                    return builderResult.hasForceGpuCompatible
                }
            }
            @discardableResult
            public func setForceGpuCompatible(_ value:Bool) -> Tensorflow.Gpuoptions.Builder {
                self.forceGpuCompatible = value
                return self
            }
            @discardableResult
            public func clearForceGpuCompatible() -> Tensorflow.Gpuoptions.Builder{
                builderResult.hasForceGpuCompatible = false
                builderResult.forceGpuCompatible = false
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.Gpuoptions.Builder {
                builderResult = Tensorflow.Gpuoptions()
                return self
            }
            override public func clone() throws -> Tensorflow.Gpuoptions.Builder {
                return try Tensorflow.Gpuoptions.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.Gpuoptions {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.Gpuoptions {
                let returnMe:Tensorflow.Gpuoptions = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.Gpuoptions) throws -> Tensorflow.Gpuoptions.Builder {
                if other == Tensorflow.Gpuoptions() {
                    return self
                }
                if other.hasPerProcessGpuMemoryFraction {
                    perProcessGpuMemoryFraction = other.perProcessGpuMemoryFraction
                }
                if other.hasAllocatorType {
                    allocatorType = other.allocatorType
                }
                if other.hasDeferredDeletionBytes {
                    deferredDeletionBytes = other.deferredDeletionBytes
                }
                if other.hasAllowGrowth {
                    allowGrowth = other.allowGrowth
                }
                if other.hasVisibleDeviceList {
                    visibleDeviceList = other.visibleDeviceList
                }
                if other.hasPollingActiveDelayUsecs {
                    pollingActiveDelayUsecs = other.pollingActiveDelayUsecs
                }
                if other.hasPollingInactiveDelayMsecs {
                    pollingInactiveDelayMsecs = other.pollingInactiveDelayMsecs
                }
                if other.hasForceGpuCompatible {
                    forceGpuCompatible = other.forceGpuCompatible
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Gpuoptions.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Gpuoptions.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 9:
                        perProcessGpuMemoryFraction = try codedInputStream.readDouble()

                    case 18:
                        allocatorType = try codedInputStream.readString()

                    case 24:
                        deferredDeletionBytes = try codedInputStream.readInt64()

                    case 32:
                        allowGrowth = try codedInputStream.readBool()

                    case 42:
                        visibleDeviceList = try codedInputStream.readString()

                    case 48:
                        pollingActiveDelayUsecs = try codedInputStream.readInt32()

                    case 56:
                        pollingInactiveDelayMsecs = try codedInputStream.readInt32()

                    case 64:
                        forceGpuCompatible = try codedInputStream.readBool()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Gpuoptions.Builder {
                let resultDecodedBuilder = Tensorflow.Gpuoptions.Builder()
                if let jsonValuePerProcessGpuMemoryFraction = jsonMap["perProcessGpuMemoryFraction"] as? Double {
                    resultDecodedBuilder.perProcessGpuMemoryFraction = Double(jsonValuePerProcessGpuMemoryFraction)
                } else if let jsonValuePerProcessGpuMemoryFraction = jsonMap["perProcessGpuMemoryFraction"] as? String {
                    resultDecodedBuilder.perProcessGpuMemoryFraction = Double(jsonValuePerProcessGpuMemoryFraction)!
                }
                if let jsonValueAllocatorType = jsonMap["allocatorType"] as? String {
                    resultDecodedBuilder.allocatorType = jsonValueAllocatorType
                }
                if let jsonValueDeferredDeletionBytes = jsonMap["deferredDeletionBytes"] as? String {
                    resultDecodedBuilder.deferredDeletionBytes = Int64(jsonValueDeferredDeletionBytes)!
                } else if let jsonValueDeferredDeletionBytes = jsonMap["deferredDeletionBytes"] as? Int {
                    resultDecodedBuilder.deferredDeletionBytes = Int64(jsonValueDeferredDeletionBytes)
                }
                if let jsonValueAllowGrowth = jsonMap["allowGrowth"] as? Bool {
                    resultDecodedBuilder.allowGrowth = jsonValueAllowGrowth
                }
                if let jsonValueVisibleDeviceList = jsonMap["visibleDeviceList"] as? String {
                    resultDecodedBuilder.visibleDeviceList = jsonValueVisibleDeviceList
                }
                if let jsonValuePollingActiveDelayUsecs = jsonMap["pollingActiveDelayUsecs"] as? Int {
                    resultDecodedBuilder.pollingActiveDelayUsecs = Int32(jsonValuePollingActiveDelayUsecs)
                } else if let jsonValuePollingActiveDelayUsecs = jsonMap["pollingActiveDelayUsecs"] as? String {
                    resultDecodedBuilder.pollingActiveDelayUsecs = Int32(jsonValuePollingActiveDelayUsecs)!
                }
                if let jsonValuePollingInactiveDelayMsecs = jsonMap["pollingInactiveDelayMsecs"] as? Int {
                    resultDecodedBuilder.pollingInactiveDelayMsecs = Int32(jsonValuePollingInactiveDelayMsecs)
                } else if let jsonValuePollingInactiveDelayMsecs = jsonMap["pollingInactiveDelayMsecs"] as? String {
                    resultDecodedBuilder.pollingInactiveDelayMsecs = Int32(jsonValuePollingInactiveDelayMsecs)!
                }
                if let jsonValueForceGpuCompatible = jsonMap["forceGpuCompatible"] as? Bool {
                    resultDecodedBuilder.forceGpuCompatible = jsonValueForceGpuCompatible
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Gpuoptions.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.Gpuoptions.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Options passed to the graph optimizer
    final public class OptimizerOptions : GeneratedMessage {

        public static func == (lhs: Tensorflow.OptimizerOptions, rhs: Tensorflow.OptimizerOptions) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasDoCommonSubexpressionElimination == rhs.hasDoCommonSubexpressionElimination) && (!lhs.hasDoCommonSubexpressionElimination || lhs.doCommonSubexpressionElimination == rhs.doCommonSubexpressionElimination)
            fieldCheck = fieldCheck && (lhs.hasDoConstantFolding == rhs.hasDoConstantFolding) && (!lhs.hasDoConstantFolding || lhs.doConstantFolding == rhs.doConstantFolding)
            fieldCheck = fieldCheck && (lhs.hasOptLevel == rhs.hasOptLevel) && (!lhs.hasOptLevel || lhs.optLevel == rhs.optLevel)
            fieldCheck = fieldCheck && (lhs.hasDoFunctionInlining == rhs.hasDoFunctionInlining) && (!lhs.hasDoFunctionInlining || lhs.doFunctionInlining == rhs.doFunctionInlining)
            fieldCheck = fieldCheck && (lhs.hasGlobalJitLevel == rhs.hasGlobalJitLevel) && (!lhs.hasGlobalJitLevel || lhs.globalJitLevel == rhs.globalJitLevel)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



            //Enum type declaration start 

            /// Optimization level
            public enum Level:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
                /// L1 is the default level.
                /// Optimization performed at L1 :
                /// 1. Common subexpression elimination
                /// 2. Constant folding
                case l1 = 0

                /// No optimizations
                case l0 = -1
                public func toString() -> String {
                    switch self {
                    case .l1: return "L1"
                    case .l0: return "L0"
                    }
                }
                public static func fromString(str:String) throws -> Tensorflow.OptimizerOptions.Level {
                    switch str {
                    case "L1":    return .l1
                    case "L0":    return .l0
                    default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
                    }
                }
                public var debugDescription:String { return getDescription() }
                public var description:String { return getDescription() }
                private func getDescription() -> String { 
                    switch self {
                    case .l1: return ".l1"
                    case .l0: return ".l0"
                    }
                }
                public var hashValue:Int {
                    return self.rawValue.hashValue
                }
                public static func ==(lhs:Level, rhs:Level) -> Bool {
                    return lhs.hashValue == rhs.hashValue
                }
            }

            //Enum type declaration end 



            //Enum type declaration start 

            /// Control the use of the compiler/jit.  Experimental.
            public enum GlobalJitLevel:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
                /// Default setting ("off" now, but later expected to be "on")
                case `default` = 0
                case off = -1

                /// The following settings turn on compilation, with higher values being
                /// more aggressive.  Higher values may reduce opportunities for parallelism
                /// and may use more memory.  (At present, there is no distinction, but this
                /// is expected to change.)
                case on1 = 1
                case on2 = 2
                public func toString() -> String {
                    switch self {
                    case .`default`: return "DEFAULT"
                    case .off: return "OFF"
                    case .on1: return "ON_1"
                    case .on2: return "ON_2"
                    }
                }
                public static func fromString(str:String) throws -> Tensorflow.OptimizerOptions.GlobalJitLevel {
                    switch str {
                    case "DEFAULT":    return .`default`
                    case "OFF":    return .off
                    case "ON_1":    return .on1
                    case "ON_2":    return .on2
                    default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
                    }
                }
                public var debugDescription:String { return getDescription() }
                public var description:String { return getDescription() }
                private func getDescription() -> String { 
                    switch self {
                    case .`default`: return ".`default`"
                    case .off: return ".off"
                    case .on1: return ".on1"
                    case .on2: return ".on2"
                    }
                }
                public var hashValue:Int {
                    return self.rawValue.hashValue
                }
                public static func ==(lhs:GlobalJitLevel, rhs:GlobalJitLevel) -> Bool {
                    return lhs.hashValue == rhs.hashValue
                }
            }

            //Enum type declaration end 

        /// If true, optimize the graph using common subexpression elimination.
        public fileprivate(set) var doCommonSubexpressionElimination:Bool = false
        public fileprivate(set) var hasDoCommonSubexpressionElimination:Bool = false

        /// If true, perform constant folding optimization on the graph.
        public fileprivate(set) var doConstantFolding:Bool = false
        public fileprivate(set) var hasDoConstantFolding:Bool = false

        /// If true, perform function inlining on the graph.
        public fileprivate(set) var doFunctionInlining:Bool = false
        public fileprivate(set) var hasDoFunctionInlining:Bool = false

        public fileprivate(set) var optLevel:Tensorflow.OptimizerOptions.Level = Tensorflow.OptimizerOptions.Level.l1
        public fileprivate(set) var hasOptLevel:Bool = false
        public fileprivate(set) var globalJitLevel:Tensorflow.OptimizerOptions.GlobalJitLevel = Tensorflow.OptimizerOptions.GlobalJitLevel.`default`
        public fileprivate(set) var hasGlobalJitLevel:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasDoCommonSubexpressionElimination {
                try codedOutputStream.writeBool(fieldNumber: 1, value:doCommonSubexpressionElimination)
            }
            if hasDoConstantFolding {
                try codedOutputStream.writeBool(fieldNumber: 2, value:doConstantFolding)
            }
            if hasOptLevel {
                try codedOutputStream.writeEnum(fieldNumber: 3, value:optLevel.rawValue)
            }
            if hasDoFunctionInlining {
                try codedOutputStream.writeBool(fieldNumber: 4, value:doFunctionInlining)
            }
            if hasGlobalJitLevel {
                try codedOutputStream.writeEnum(fieldNumber: 5, value:globalJitLevel.rawValue)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasDoCommonSubexpressionElimination {
                serialize_size += doCommonSubexpressionElimination.computeBoolSize(fieldNumber: 1)
            }
            if hasDoConstantFolding {
                serialize_size += doConstantFolding.computeBoolSize(fieldNumber: 2)
            }
            if (hasOptLevel) {
                serialize_size += optLevel.rawValue.computeEnumSize(fieldNumber: 3)
            }
            if hasDoFunctionInlining {
                serialize_size += doFunctionInlining.computeBoolSize(fieldNumber: 4)
            }
            if (hasGlobalJitLevel) {
                serialize_size += globalJitLevel.rawValue.computeEnumSize(fieldNumber: 5)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.OptimizerOptions.Builder {
            return Tensorflow.OptimizerOptions.classBuilder() as! Tensorflow.OptimizerOptions.Builder
        }
        public func getBuilder() -> Tensorflow.OptimizerOptions.Builder {
            return classBuilder() as! Tensorflow.OptimizerOptions.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.OptimizerOptions.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.OptimizerOptions.Builder()
        }
        public func toBuilder() throws -> Tensorflow.OptimizerOptions.Builder {
            return try Tensorflow.OptimizerOptions.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.OptimizerOptions) throws -> Tensorflow.OptimizerOptions.Builder {
            return try Tensorflow.OptimizerOptions.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasDoCommonSubexpressionElimination {
                jsonMap["doCommonSubexpressionElimination"] = doCommonSubexpressionElimination
            }
            if hasDoConstantFolding {
                jsonMap["doConstantFolding"] = doConstantFolding
            }
            if hasDoFunctionInlining {
                jsonMap["doFunctionInlining"] = doFunctionInlining
            }
            if hasOptLevel {
                jsonMap["optLevel"] = optLevel.toString()
            }
            if hasGlobalJitLevel {
                jsonMap["globalJitLevel"] = globalJitLevel.toString()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OptimizerOptions {
            return try Tensorflow.OptimizerOptions.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.OptimizerOptions {
            return try Tensorflow.OptimizerOptions.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasDoCommonSubexpressionElimination {
                output += "\(indent) doCommonSubexpressionElimination: \(doCommonSubexpressionElimination) \n"
            }
            if hasDoConstantFolding {
                output += "\(indent) doConstantFolding: \(doConstantFolding) \n"
            }
            if (hasOptLevel) {
                output += "\(indent) optLevel: \(optLevel.description)\n"
            }
            if hasDoFunctionInlining {
                output += "\(indent) doFunctionInlining: \(doFunctionInlining) \n"
            }
            if (hasGlobalJitLevel) {
                output += "\(indent) globalJitLevel: \(globalJitLevel.description)\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasDoCommonSubexpressionElimination {
                    hashCode = (hashCode &* 31) &+ doCommonSubexpressionElimination.hashValue
                }
                if hasDoConstantFolding {
                    hashCode = (hashCode &* 31) &+ doConstantFolding.hashValue
                }
                if hasOptLevel {
                     hashCode = (hashCode &* 31) &+ optLevel.hashValue
                }
                if hasDoFunctionInlining {
                    hashCode = (hashCode &* 31) &+ doFunctionInlining.hashValue
                }
                if hasGlobalJitLevel {
                     hashCode = (hashCode &* 31) &+ globalJitLevel.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.OptimizerOptions"
        }
        override public func className() -> String {
            return "Tensorflow.OptimizerOptions"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.OptimizerOptions = Tensorflow.OptimizerOptions()
            public func getMessage() -> Tensorflow.OptimizerOptions {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// If true, optimize the graph using common subexpression elimination.
            public var doCommonSubexpressionElimination:Bool {
                get {
                    return builderResult.doCommonSubexpressionElimination
                }
                set (value) {
                    builderResult.hasDoCommonSubexpressionElimination = true
                    builderResult.doCommonSubexpressionElimination = value
                }
            }
            public var hasDoCommonSubexpressionElimination:Bool {
                get {
                    return builderResult.hasDoCommonSubexpressionElimination
                }
            }
            @discardableResult
            public func setDoCommonSubexpressionElimination(_ value:Bool) -> Tensorflow.OptimizerOptions.Builder {
                self.doCommonSubexpressionElimination = value
                return self
            }
            @discardableResult
            public func clearDoCommonSubexpressionElimination() -> Tensorflow.OptimizerOptions.Builder{
                builderResult.hasDoCommonSubexpressionElimination = false
                builderResult.doCommonSubexpressionElimination = false
                return self
            }
            /// If true, perform constant folding optimization on the graph.
            public var doConstantFolding:Bool {
                get {
                    return builderResult.doConstantFolding
                }
                set (value) {
                    builderResult.hasDoConstantFolding = true
                    builderResult.doConstantFolding = value
                }
            }
            public var hasDoConstantFolding:Bool {
                get {
                    return builderResult.hasDoConstantFolding
                }
            }
            @discardableResult
            public func setDoConstantFolding(_ value:Bool) -> Tensorflow.OptimizerOptions.Builder {
                self.doConstantFolding = value
                return self
            }
            @discardableResult
            public func clearDoConstantFolding() -> Tensorflow.OptimizerOptions.Builder{
                builderResult.hasDoConstantFolding = false
                builderResult.doConstantFolding = false
                return self
            }
            /// If true, perform function inlining on the graph.
            public var doFunctionInlining:Bool {
                get {
                    return builderResult.doFunctionInlining
                }
                set (value) {
                    builderResult.hasDoFunctionInlining = true
                    builderResult.doFunctionInlining = value
                }
            }
            public var hasDoFunctionInlining:Bool {
                get {
                    return builderResult.hasDoFunctionInlining
                }
            }
            @discardableResult
            public func setDoFunctionInlining(_ value:Bool) -> Tensorflow.OptimizerOptions.Builder {
                self.doFunctionInlining = value
                return self
            }
            @discardableResult
            public func clearDoFunctionInlining() -> Tensorflow.OptimizerOptions.Builder{
                builderResult.hasDoFunctionInlining = false
                builderResult.doFunctionInlining = false
                return self
            }
                public var optLevel:Tensorflow.OptimizerOptions.Level {
                    get {
                        return builderResult.optLevel
                    }
                    set (value) {
                        builderResult.hasOptLevel = true
                        builderResult.optLevel = value
                    }
                }
                public var hasOptLevel:Bool{
                    get {
                        return builderResult.hasOptLevel
                    }
                }
            @discardableResult
                public func setOptLevel(_ value:Tensorflow.OptimizerOptions.Level) -> Tensorflow.OptimizerOptions.Builder {
                  self.optLevel = value
                  return self
                }
            @discardableResult
                public func clearOptLevel() -> Tensorflow.OptimizerOptions.Builder {
                   builderResult.hasOptLevel = false
                   builderResult.optLevel = .l1
                   return self
                }
                public var globalJitLevel:Tensorflow.OptimizerOptions.GlobalJitLevel {
                    get {
                        return builderResult.globalJitLevel
                    }
                    set (value) {
                        builderResult.hasGlobalJitLevel = true
                        builderResult.globalJitLevel = value
                    }
                }
                public var hasGlobalJitLevel:Bool{
                    get {
                        return builderResult.hasGlobalJitLevel
                    }
                }
            @discardableResult
                public func setGlobalJitLevel(_ value:Tensorflow.OptimizerOptions.GlobalJitLevel) -> Tensorflow.OptimizerOptions.Builder {
                  self.globalJitLevel = value
                  return self
                }
            @discardableResult
                public func clearGlobalJitLevel() -> Tensorflow.OptimizerOptions.Builder {
                   builderResult.hasGlobalJitLevel = false
                   builderResult.globalJitLevel = .`default`
                   return self
                }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.OptimizerOptions.Builder {
                builderResult = Tensorflow.OptimizerOptions()
                return self
            }
            override public func clone() throws -> Tensorflow.OptimizerOptions.Builder {
                return try Tensorflow.OptimizerOptions.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.OptimizerOptions {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.OptimizerOptions {
                let returnMe:Tensorflow.OptimizerOptions = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.OptimizerOptions) throws -> Tensorflow.OptimizerOptions.Builder {
                if other == Tensorflow.OptimizerOptions() {
                    return self
                }
                if other.hasDoCommonSubexpressionElimination {
                    doCommonSubexpressionElimination = other.doCommonSubexpressionElimination
                }
                if other.hasDoConstantFolding {
                    doConstantFolding = other.doConstantFolding
                }
                if other.hasDoFunctionInlining {
                    doFunctionInlining = other.doFunctionInlining
                }
                if other.hasOptLevel {
                    optLevel = other.optLevel
                }
                if other.hasGlobalJitLevel {
                    globalJitLevel = other.globalJitLevel
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OptimizerOptions.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OptimizerOptions.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        doCommonSubexpressionElimination = try codedInputStream.readBool()

                    case 16:
                        doConstantFolding = try codedInputStream.readBool()

                    case 24:
                        let valueIntoptLevel = try codedInputStream.readEnum()
                        if let enumsoptLevel = Tensorflow.OptimizerOptions.Level(rawValue:valueIntoptLevel){
                            optLevel = enumsoptLevel
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 3, value:Int64(valueIntoptLevel))
                        }

                    case 32:
                        doFunctionInlining = try codedInputStream.readBool()

                    case 40:
                        let valueIntglobalJitLevel = try codedInputStream.readEnum()
                        if let enumsglobalJitLevel = Tensorflow.OptimizerOptions.GlobalJitLevel(rawValue:valueIntglobalJitLevel){
                            globalJitLevel = enumsglobalJitLevel
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 5, value:Int64(valueIntglobalJitLevel))
                        }

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OptimizerOptions.Builder {
                let resultDecodedBuilder = Tensorflow.OptimizerOptions.Builder()
                if let jsonValueDoCommonSubexpressionElimination = jsonMap["doCommonSubexpressionElimination"] as? Bool {
                    resultDecodedBuilder.doCommonSubexpressionElimination = jsonValueDoCommonSubexpressionElimination
                }
                if let jsonValueDoConstantFolding = jsonMap["doConstantFolding"] as? Bool {
                    resultDecodedBuilder.doConstantFolding = jsonValueDoConstantFolding
                }
                if let jsonValueDoFunctionInlining = jsonMap["doFunctionInlining"] as? Bool {
                    resultDecodedBuilder.doFunctionInlining = jsonValueDoFunctionInlining
                }
                if let jsonValueOptLevel = jsonMap["optLevel"] as? String {
                    resultDecodedBuilder.optLevel = try Tensorflow.OptimizerOptions.Level.fromString(str: jsonValueOptLevel)
                }
                if let jsonValueGlobalJitLevel = jsonMap["globalJitLevel"] as? String {
                    resultDecodedBuilder.globalJitLevel = try Tensorflow.OptimizerOptions.GlobalJitLevel.fromString(str: jsonValueGlobalJitLevel)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.OptimizerOptions.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.OptimizerOptions.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class GraphOptions : GeneratedMessage {

        public static func == (lhs: Tensorflow.GraphOptions, rhs: Tensorflow.GraphOptions) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasEnableRecvScheduling == rhs.hasEnableRecvScheduling) && (!lhs.hasEnableRecvScheduling || lhs.enableRecvScheduling == rhs.enableRecvScheduling)
            fieldCheck = fieldCheck && (lhs.hasOptimizerOptions == rhs.hasOptimizerOptions) && (!lhs.hasOptimizerOptions || lhs.optimizerOptions == rhs.optimizerOptions)
            fieldCheck = fieldCheck && (lhs.hasBuildCostModel == rhs.hasBuildCostModel) && (!lhs.hasBuildCostModel || lhs.buildCostModel == rhs.buildCostModel)
            fieldCheck = fieldCheck && (lhs.hasInferShapes == rhs.hasInferShapes) && (!lhs.hasInferShapes || lhs.inferShapes == rhs.inferShapes)
            fieldCheck = fieldCheck && (lhs.hasPlacePrunedGraph == rhs.hasPlacePrunedGraph) && (!lhs.hasPlacePrunedGraph || lhs.placePrunedGraph == rhs.placePrunedGraph)
            fieldCheck = fieldCheck && (lhs.hasEnableBfloat16Sendrecv == rhs.hasEnableBfloat16Sendrecv) && (!lhs.hasEnableBfloat16Sendrecv || lhs.enableBfloat16Sendrecv == rhs.enableBfloat16Sendrecv)
            fieldCheck = fieldCheck && (lhs.hasTimelineStep == rhs.hasTimelineStep) && (!lhs.hasTimelineStep || lhs.timelineStep == rhs.timelineStep)
            fieldCheck = fieldCheck && (lhs.hasBuildCostModelAfter == rhs.hasBuildCostModelAfter) && (!lhs.hasBuildCostModelAfter || lhs.buildCostModelAfter == rhs.buildCostModelAfter)
            fieldCheck = fieldCheck && (lhs.hasRewriteOptions == rhs.hasRewriteOptions) && (!lhs.hasRewriteOptions || lhs.rewriteOptions == rhs.rewriteOptions)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// If true, use control flow to schedule the activation of Recv nodes.
        /// (Currently ignored.)
        public fileprivate(set) var enableRecvScheduling:Bool = false
        public fileprivate(set) var hasEnableRecvScheduling:Bool = false

        public fileprivate(set) var optimizerOptions:Tensorflow.OptimizerOptions!
        public fileprivate(set) var hasOptimizerOptions:Bool = false
        /// The number of steps to run before returning a cost model detailing
        /// the memory usage and performance of each node of the graph. 0 means
        /// no cost model.
        public fileprivate(set) var buildCostModel:Int64 = Int64(0)
        public fileprivate(set) var hasBuildCostModel:Bool = false

        /// The number of steps to skip before collecting statistics for the
        /// cost model.
        public fileprivate(set) var buildCostModelAfter:Int64 = Int64(0)
        public fileprivate(set) var hasBuildCostModelAfter:Bool = false

        /// Annotate each Node with Op output shape data, to the extent it can
        /// be statically inferred.
        public fileprivate(set) var inferShapes:Bool = false
        public fileprivate(set) var hasInferShapes:Bool = false

        /// Only place the subgraphs that are run, rather than the entire graph.
        /// This is useful for interactive graph building, where one might
        /// produce graphs that cannot be placed during the debugging
        /// process.  In particular, it allows the client to continue work in
        /// a session after adding a node to a graph whose placement
        /// constraints are unsatisfiable.
        public fileprivate(set) var placePrunedGraph:Bool = false
        public fileprivate(set) var hasPlacePrunedGraph:Bool = false

        /// If true, transfer float values between processes as bfloat16.
        public fileprivate(set) var enableBfloat16Sendrecv:Bool = false
        public fileprivate(set) var hasEnableBfloat16Sendrecv:Bool = false

        /// If > 0, record a timeline every this many steps.
        /// EXPERIMENTAL: This currently has no effect in MasterSession.
        public fileprivate(set) var timelineStep:Int32 = Int32(0)
        public fileprivate(set) var hasTimelineStep:Bool = false

        public fileprivate(set) var rewriteOptions:Tensorflow.RewriterConfig!
        public fileprivate(set) var hasRewriteOptions:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasEnableRecvScheduling {
                try codedOutputStream.writeBool(fieldNumber: 2, value:enableRecvScheduling)
            }
            if hasOptimizerOptions {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:optimizerOptions)
            }
            if hasBuildCostModel {
                try codedOutputStream.writeInt64(fieldNumber: 4, value:buildCostModel)
            }
            if hasInferShapes {
                try codedOutputStream.writeBool(fieldNumber: 5, value:inferShapes)
            }
            if hasPlacePrunedGraph {
                try codedOutputStream.writeBool(fieldNumber: 6, value:placePrunedGraph)
            }
            if hasEnableBfloat16Sendrecv {
                try codedOutputStream.writeBool(fieldNumber: 7, value:enableBfloat16Sendrecv)
            }
            if hasTimelineStep {
                try codedOutputStream.writeInt32(fieldNumber: 8, value:timelineStep)
            }
            if hasBuildCostModelAfter {
                try codedOutputStream.writeInt64(fieldNumber: 9, value:buildCostModelAfter)
            }
            if hasRewriteOptions {
                try codedOutputStream.writeMessage(fieldNumber: 10, value:rewriteOptions)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasEnableRecvScheduling {
                serialize_size += enableRecvScheduling.computeBoolSize(fieldNumber: 2)
            }
            if hasOptimizerOptions {
                if let varSizeoptimizerOptions = optimizerOptions?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizeoptimizerOptions
                }
            }
            if hasBuildCostModel {
                serialize_size += buildCostModel.computeInt64Size(fieldNumber: 4)
            }
            if hasInferShapes {
                serialize_size += inferShapes.computeBoolSize(fieldNumber: 5)
            }
            if hasPlacePrunedGraph {
                serialize_size += placePrunedGraph.computeBoolSize(fieldNumber: 6)
            }
            if hasEnableBfloat16Sendrecv {
                serialize_size += enableBfloat16Sendrecv.computeBoolSize(fieldNumber: 7)
            }
            if hasTimelineStep {
                serialize_size += timelineStep.computeInt32Size(fieldNumber: 8)
            }
            if hasBuildCostModelAfter {
                serialize_size += buildCostModelAfter.computeInt64Size(fieldNumber: 9)
            }
            if hasRewriteOptions {
                if let varSizerewriteOptions = rewriteOptions?.computeMessageSize(fieldNumber: 10) {
                    serialize_size += varSizerewriteOptions
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.GraphOptions.Builder {
            return Tensorflow.GraphOptions.classBuilder() as! Tensorflow.GraphOptions.Builder
        }
        public func getBuilder() -> Tensorflow.GraphOptions.Builder {
            return classBuilder() as! Tensorflow.GraphOptions.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.GraphOptions.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.GraphOptions.Builder()
        }
        public func toBuilder() throws -> Tensorflow.GraphOptions.Builder {
            return try Tensorflow.GraphOptions.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.GraphOptions) throws -> Tensorflow.GraphOptions.Builder {
            return try Tensorflow.GraphOptions.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasEnableRecvScheduling {
                jsonMap["enableRecvScheduling"] = enableRecvScheduling
            }
            if hasOptimizerOptions {
                jsonMap["optimizerOptions"] = try optimizerOptions.encode()
            }
            if hasBuildCostModel {
                jsonMap["buildCostModel"] = "\(buildCostModel)"
            }
            if hasBuildCostModelAfter {
                jsonMap["buildCostModelAfter"] = "\(buildCostModelAfter)"
            }
            if hasInferShapes {
                jsonMap["inferShapes"] = inferShapes
            }
            if hasPlacePrunedGraph {
                jsonMap["placePrunedGraph"] = placePrunedGraph
            }
            if hasEnableBfloat16Sendrecv {
                jsonMap["enableBfloat16Sendrecv"] = enableBfloat16Sendrecv
            }
            if hasTimelineStep {
                jsonMap["timelineStep"] = Int(timelineStep)
            }
            if hasRewriteOptions {
                jsonMap["rewriteOptions"] = try rewriteOptions.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.GraphOptions {
            return try Tensorflow.GraphOptions.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.GraphOptions {
            return try Tensorflow.GraphOptions.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasEnableRecvScheduling {
                output += "\(indent) enableRecvScheduling: \(enableRecvScheduling) \n"
            }
            if hasOptimizerOptions {
                output += "\(indent) optimizerOptions {\n"
                if let outDescOptimizerOptions = optimizerOptions {
                    output += try outDescOptimizerOptions.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasBuildCostModel {
                output += "\(indent) buildCostModel: \(buildCostModel) \n"
            }
            if hasInferShapes {
                output += "\(indent) inferShapes: \(inferShapes) \n"
            }
            if hasPlacePrunedGraph {
                output += "\(indent) placePrunedGraph: \(placePrunedGraph) \n"
            }
            if hasEnableBfloat16Sendrecv {
                output += "\(indent) enableBfloat16Sendrecv: \(enableBfloat16Sendrecv) \n"
            }
            if hasTimelineStep {
                output += "\(indent) timelineStep: \(timelineStep) \n"
            }
            if hasBuildCostModelAfter {
                output += "\(indent) buildCostModelAfter: \(buildCostModelAfter) \n"
            }
            if hasRewriteOptions {
                output += "\(indent) rewriteOptions {\n"
                if let outDescRewriteOptions = rewriteOptions {
                    output += try outDescRewriteOptions.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasEnableRecvScheduling {
                    hashCode = (hashCode &* 31) &+ enableRecvScheduling.hashValue
                }
                if hasOptimizerOptions {
                    if let hashValueoptimizerOptions = optimizerOptions?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoptimizerOptions
                    }
                }
                if hasBuildCostModel {
                    hashCode = (hashCode &* 31) &+ buildCostModel.hashValue
                }
                if hasInferShapes {
                    hashCode = (hashCode &* 31) &+ inferShapes.hashValue
                }
                if hasPlacePrunedGraph {
                    hashCode = (hashCode &* 31) &+ placePrunedGraph.hashValue
                }
                if hasEnableBfloat16Sendrecv {
                    hashCode = (hashCode &* 31) &+ enableBfloat16Sendrecv.hashValue
                }
                if hasTimelineStep {
                    hashCode = (hashCode &* 31) &+ timelineStep.hashValue
                }
                if hasBuildCostModelAfter {
                    hashCode = (hashCode &* 31) &+ buildCostModelAfter.hashValue
                }
                if hasRewriteOptions {
                    if let hashValuerewriteOptions = rewriteOptions?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuerewriteOptions
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.GraphOptions"
        }
        override public func className() -> String {
            return "Tensorflow.GraphOptions"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.GraphOptions = Tensorflow.GraphOptions()
            public func getMessage() -> Tensorflow.GraphOptions {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// If true, use control flow to schedule the activation of Recv nodes.
            /// (Currently ignored.)
            public var enableRecvScheduling:Bool {
                get {
                    return builderResult.enableRecvScheduling
                }
                set (value) {
                    builderResult.hasEnableRecvScheduling = true
                    builderResult.enableRecvScheduling = value
                }
            }
            public var hasEnableRecvScheduling:Bool {
                get {
                    return builderResult.hasEnableRecvScheduling
                }
            }
            @discardableResult
            public func setEnableRecvScheduling(_ value:Bool) -> Tensorflow.GraphOptions.Builder {
                self.enableRecvScheduling = value
                return self
            }
            @discardableResult
            public func clearEnableRecvScheduling() -> Tensorflow.GraphOptions.Builder{
                builderResult.hasEnableRecvScheduling = false
                builderResult.enableRecvScheduling = false
                return self
            }
            /// Options controlling how graph is optimized.
            public var optimizerOptions:Tensorflow.OptimizerOptions! {
                get {
                    if optimizerOptionsBuilder_ != nil {
                        builderResult.optimizerOptions = optimizerOptionsBuilder_.getMessage()
                    }
                    return builderResult.optimizerOptions
                }
                set (value) {
                    builderResult.hasOptimizerOptions = true
                    builderResult.optimizerOptions = value
                }
            }
            public var hasOptimizerOptions:Bool {
                get {
                    return builderResult.hasOptimizerOptions
                }
            }
            fileprivate var optimizerOptionsBuilder_:Tensorflow.OptimizerOptions.Builder! {
                didSet {
                    builderResult.hasOptimizerOptions = true
                }
            }
            public func getOptimizerOptionsBuilder() -> Tensorflow.OptimizerOptions.Builder {
                if optimizerOptionsBuilder_ == nil {
                    optimizerOptionsBuilder_ = Tensorflow.OptimizerOptions.Builder()
                    builderResult.optimizerOptions = optimizerOptionsBuilder_.getMessage()
                    if optimizerOptions != nil {
                        try! optimizerOptionsBuilder_.mergeFrom(other: optimizerOptions)
                    }
                }
                return optimizerOptionsBuilder_
            }
            @discardableResult
            public func setOptimizerOptions(_ value:Tensorflow.OptimizerOptions!) -> Tensorflow.GraphOptions.Builder {
                self.optimizerOptions = value
                return self
            }
            @discardableResult
            public func mergeOptimizerOptions(value:Tensorflow.OptimizerOptions) throws -> Tensorflow.GraphOptions.Builder {
                if builderResult.hasOptimizerOptions {
                    builderResult.optimizerOptions = try Tensorflow.OptimizerOptions.builderWithPrototype(prototype:builderResult.optimizerOptions).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.optimizerOptions = value
                }
                builderResult.hasOptimizerOptions = true
                return self
            }
            @discardableResult
            public func clearOptimizerOptions() -> Tensorflow.GraphOptions.Builder {
                optimizerOptionsBuilder_ = nil
                builderResult.hasOptimizerOptions = false
                builderResult.optimizerOptions = nil
                return self
            }
            /// The number of steps to run before returning a cost model detailing
            /// the memory usage and performance of each node of the graph. 0 means
            /// no cost model.
            public var buildCostModel:Int64 {
                get {
                    return builderResult.buildCostModel
                }
                set (value) {
                    builderResult.hasBuildCostModel = true
                    builderResult.buildCostModel = value
                }
            }
            public var hasBuildCostModel:Bool {
                get {
                    return builderResult.hasBuildCostModel
                }
            }
            @discardableResult
            public func setBuildCostModel(_ value:Int64) -> Tensorflow.GraphOptions.Builder {
                self.buildCostModel = value
                return self
            }
            @discardableResult
            public func clearBuildCostModel() -> Tensorflow.GraphOptions.Builder{
                builderResult.hasBuildCostModel = false
                builderResult.buildCostModel = Int64(0)
                return self
            }
            /// The number of steps to skip before collecting statistics for the
            /// cost model.
            public var buildCostModelAfter:Int64 {
                get {
                    return builderResult.buildCostModelAfter
                }
                set (value) {
                    builderResult.hasBuildCostModelAfter = true
                    builderResult.buildCostModelAfter = value
                }
            }
            public var hasBuildCostModelAfter:Bool {
                get {
                    return builderResult.hasBuildCostModelAfter
                }
            }
            @discardableResult
            public func setBuildCostModelAfter(_ value:Int64) -> Tensorflow.GraphOptions.Builder {
                self.buildCostModelAfter = value
                return self
            }
            @discardableResult
            public func clearBuildCostModelAfter() -> Tensorflow.GraphOptions.Builder{
                builderResult.hasBuildCostModelAfter = false
                builderResult.buildCostModelAfter = Int64(0)
                return self
            }
            /// Annotate each Node with Op output shape data, to the extent it can
            /// be statically inferred.
            public var inferShapes:Bool {
                get {
                    return builderResult.inferShapes
                }
                set (value) {
                    builderResult.hasInferShapes = true
                    builderResult.inferShapes = value
                }
            }
            public var hasInferShapes:Bool {
                get {
                    return builderResult.hasInferShapes
                }
            }
            @discardableResult
            public func setInferShapes(_ value:Bool) -> Tensorflow.GraphOptions.Builder {
                self.inferShapes = value
                return self
            }
            @discardableResult
            public func clearInferShapes() -> Tensorflow.GraphOptions.Builder{
                builderResult.hasInferShapes = false
                builderResult.inferShapes = false
                return self
            }
            /// Only place the subgraphs that are run, rather than the entire graph.
            /// This is useful for interactive graph building, where one might
            /// produce graphs that cannot be placed during the debugging
            /// process.  In particular, it allows the client to continue work in
            /// a session after adding a node to a graph whose placement
            /// constraints are unsatisfiable.
            public var placePrunedGraph:Bool {
                get {
                    return builderResult.placePrunedGraph
                }
                set (value) {
                    builderResult.hasPlacePrunedGraph = true
                    builderResult.placePrunedGraph = value
                }
            }
            public var hasPlacePrunedGraph:Bool {
                get {
                    return builderResult.hasPlacePrunedGraph
                }
            }
            @discardableResult
            public func setPlacePrunedGraph(_ value:Bool) -> Tensorflow.GraphOptions.Builder {
                self.placePrunedGraph = value
                return self
            }
            @discardableResult
            public func clearPlacePrunedGraph() -> Tensorflow.GraphOptions.Builder{
                builderResult.hasPlacePrunedGraph = false
                builderResult.placePrunedGraph = false
                return self
            }
            /// If true, transfer float values between processes as bfloat16.
            public var enableBfloat16Sendrecv:Bool {
                get {
                    return builderResult.enableBfloat16Sendrecv
                }
                set (value) {
                    builderResult.hasEnableBfloat16Sendrecv = true
                    builderResult.enableBfloat16Sendrecv = value
                }
            }
            public var hasEnableBfloat16Sendrecv:Bool {
                get {
                    return builderResult.hasEnableBfloat16Sendrecv
                }
            }
            @discardableResult
            public func setEnableBfloat16Sendrecv(_ value:Bool) -> Tensorflow.GraphOptions.Builder {
                self.enableBfloat16Sendrecv = value
                return self
            }
            @discardableResult
            public func clearEnableBfloat16Sendrecv() -> Tensorflow.GraphOptions.Builder{
                builderResult.hasEnableBfloat16Sendrecv = false
                builderResult.enableBfloat16Sendrecv = false
                return self
            }
            /// If > 0, record a timeline every this many steps.
            /// EXPERIMENTAL: This currently has no effect in MasterSession.
            public var timelineStep:Int32 {
                get {
                    return builderResult.timelineStep
                }
                set (value) {
                    builderResult.hasTimelineStep = true
                    builderResult.timelineStep = value
                }
            }
            public var hasTimelineStep:Bool {
                get {
                    return builderResult.hasTimelineStep
                }
            }
            @discardableResult
            public func setTimelineStep(_ value:Int32) -> Tensorflow.GraphOptions.Builder {
                self.timelineStep = value
                return self
            }
            @discardableResult
            public func clearTimelineStep() -> Tensorflow.GraphOptions.Builder{
                builderResult.hasTimelineStep = false
                builderResult.timelineStep = Int32(0)
                return self
            }
            /// Options that control the type and amount of graph rewriting.
            public var rewriteOptions:Tensorflow.RewriterConfig! {
                get {
                    if rewriteOptionsBuilder_ != nil {
                        builderResult.rewriteOptions = rewriteOptionsBuilder_.getMessage()
                    }
                    return builderResult.rewriteOptions
                }
                set (value) {
                    builderResult.hasRewriteOptions = true
                    builderResult.rewriteOptions = value
                }
            }
            public var hasRewriteOptions:Bool {
                get {
                    return builderResult.hasRewriteOptions
                }
            }
            fileprivate var rewriteOptionsBuilder_:Tensorflow.RewriterConfig.Builder! {
                didSet {
                    builderResult.hasRewriteOptions = true
                }
            }
            public func getRewriteOptionsBuilder() -> Tensorflow.RewriterConfig.Builder {
                if rewriteOptionsBuilder_ == nil {
                    rewriteOptionsBuilder_ = Tensorflow.RewriterConfig.Builder()
                    builderResult.rewriteOptions = rewriteOptionsBuilder_.getMessage()
                    if rewriteOptions != nil {
                        try! rewriteOptionsBuilder_.mergeFrom(other: rewriteOptions)
                    }
                }
                return rewriteOptionsBuilder_
            }
            @discardableResult
            public func setRewriteOptions(_ value:Tensorflow.RewriterConfig!) -> Tensorflow.GraphOptions.Builder {
                self.rewriteOptions = value
                return self
            }
            @discardableResult
            public func mergeRewriteOptions(value:Tensorflow.RewriterConfig) throws -> Tensorflow.GraphOptions.Builder {
                if builderResult.hasRewriteOptions {
                    builderResult.rewriteOptions = try Tensorflow.RewriterConfig.builderWithPrototype(prototype:builderResult.rewriteOptions).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.rewriteOptions = value
                }
                builderResult.hasRewriteOptions = true
                return self
            }
            @discardableResult
            public func clearRewriteOptions() -> Tensorflow.GraphOptions.Builder {
                rewriteOptionsBuilder_ = nil
                builderResult.hasRewriteOptions = false
                builderResult.rewriteOptions = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.GraphOptions.Builder {
                builderResult = Tensorflow.GraphOptions()
                return self
            }
            override public func clone() throws -> Tensorflow.GraphOptions.Builder {
                return try Tensorflow.GraphOptions.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.GraphOptions {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.GraphOptions {
                let returnMe:Tensorflow.GraphOptions = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.GraphOptions) throws -> Tensorflow.GraphOptions.Builder {
                if other == Tensorflow.GraphOptions() {
                    return self
                }
                if other.hasEnableRecvScheduling {
                    enableRecvScheduling = other.enableRecvScheduling
                }
                if (other.hasOptimizerOptions) {
                    try mergeOptimizerOptions(value: other.optimizerOptions)
                }
                if other.hasBuildCostModel {
                    buildCostModel = other.buildCostModel
                }
                if other.hasBuildCostModelAfter {
                    buildCostModelAfter = other.buildCostModelAfter
                }
                if other.hasInferShapes {
                    inferShapes = other.inferShapes
                }
                if other.hasPlacePrunedGraph {
                    placePrunedGraph = other.placePrunedGraph
                }
                if other.hasEnableBfloat16Sendrecv {
                    enableBfloat16Sendrecv = other.enableBfloat16Sendrecv
                }
                if other.hasTimelineStep {
                    timelineStep = other.timelineStep
                }
                if (other.hasRewriteOptions) {
                    try mergeRewriteOptions(value: other.rewriteOptions)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.GraphOptions.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphOptions.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 16:
                        enableRecvScheduling = try codedInputStream.readBool()

                    case 26:
                        let subBuilder:Tensorflow.OptimizerOptions.Builder = Tensorflow.OptimizerOptions.Builder()
                        if hasOptimizerOptions {
                            try subBuilder.mergeFrom(other: optimizerOptions)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        optimizerOptions = subBuilder.buildPartial()

                    case 32:
                        buildCostModel = try codedInputStream.readInt64()

                    case 40:
                        inferShapes = try codedInputStream.readBool()

                    case 48:
                        placePrunedGraph = try codedInputStream.readBool()

                    case 56:
                        enableBfloat16Sendrecv = try codedInputStream.readBool()

                    case 64:
                        timelineStep = try codedInputStream.readInt32()

                    case 72:
                        buildCostModelAfter = try codedInputStream.readInt64()

                    case 82:
                        let subBuilder:Tensorflow.RewriterConfig.Builder = Tensorflow.RewriterConfig.Builder()
                        if hasRewriteOptions {
                            try subBuilder.mergeFrom(other: rewriteOptions)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        rewriteOptions = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.GraphOptions.Builder {
                let resultDecodedBuilder = Tensorflow.GraphOptions.Builder()
                if let jsonValueEnableRecvScheduling = jsonMap["enableRecvScheduling"] as? Bool {
                    resultDecodedBuilder.enableRecvScheduling = jsonValueEnableRecvScheduling
                }
                if let jsonValueOptimizerOptions = jsonMap["optimizerOptions"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.optimizerOptions = try Tensorflow.OptimizerOptions.Builder.decodeToBuilder(jsonMap:jsonValueOptimizerOptions).build()

                }
                if let jsonValueBuildCostModel = jsonMap["buildCostModel"] as? String {
                    resultDecodedBuilder.buildCostModel = Int64(jsonValueBuildCostModel)!
                } else if let jsonValueBuildCostModel = jsonMap["buildCostModel"] as? Int {
                    resultDecodedBuilder.buildCostModel = Int64(jsonValueBuildCostModel)
                }
                if let jsonValueBuildCostModelAfter = jsonMap["buildCostModelAfter"] as? String {
                    resultDecodedBuilder.buildCostModelAfter = Int64(jsonValueBuildCostModelAfter)!
                } else if let jsonValueBuildCostModelAfter = jsonMap["buildCostModelAfter"] as? Int {
                    resultDecodedBuilder.buildCostModelAfter = Int64(jsonValueBuildCostModelAfter)
                }
                if let jsonValueInferShapes = jsonMap["inferShapes"] as? Bool {
                    resultDecodedBuilder.inferShapes = jsonValueInferShapes
                }
                if let jsonValuePlacePrunedGraph = jsonMap["placePrunedGraph"] as? Bool {
                    resultDecodedBuilder.placePrunedGraph = jsonValuePlacePrunedGraph
                }
                if let jsonValueEnableBfloat16Sendrecv = jsonMap["enableBfloat16Sendrecv"] as? Bool {
                    resultDecodedBuilder.enableBfloat16Sendrecv = jsonValueEnableBfloat16Sendrecv
                }
                if let jsonValueTimelineStep = jsonMap["timelineStep"] as? Int {
                    resultDecodedBuilder.timelineStep = Int32(jsonValueTimelineStep)
                } else if let jsonValueTimelineStep = jsonMap["timelineStep"] as? String {
                    resultDecodedBuilder.timelineStep = Int32(jsonValueTimelineStep)!
                }
                if let jsonValueRewriteOptions = jsonMap["rewriteOptions"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.rewriteOptions = try Tensorflow.RewriterConfig.Builder.decodeToBuilder(jsonMap:jsonValueRewriteOptions).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.GraphOptions.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.GraphOptions.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ThreadPoolOptionProto : GeneratedMessage {

        public static func == (lhs: Tensorflow.ThreadPoolOptionProto, rhs: Tensorflow.ThreadPoolOptionProto) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasNumThreads == rhs.hasNumThreads) && (!lhs.hasNumThreads || lhs.numThreads == rhs.numThreads)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// The number of threads in the pool.
        /// 0 means the system picks a value based on where this option proto is used
        /// (see the declaration of the specific field for more info).
        public fileprivate(set) var numThreads:Int32 = Int32(0)
        public fileprivate(set) var hasNumThreads:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasNumThreads {
                try codedOutputStream.writeInt32(fieldNumber: 1, value:numThreads)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasNumThreads {
                serialize_size += numThreads.computeInt32Size(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.ThreadPoolOptionProto.Builder {
            return Tensorflow.ThreadPoolOptionProto.classBuilder() as! Tensorflow.ThreadPoolOptionProto.Builder
        }
        public func getBuilder() -> Tensorflow.ThreadPoolOptionProto.Builder {
            return classBuilder() as! Tensorflow.ThreadPoolOptionProto.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.ThreadPoolOptionProto.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.ThreadPoolOptionProto.Builder()
        }
        public func toBuilder() throws -> Tensorflow.ThreadPoolOptionProto.Builder {
            return try Tensorflow.ThreadPoolOptionProto.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.ThreadPoolOptionProto) throws -> Tensorflow.ThreadPoolOptionProto.Builder {
            return try Tensorflow.ThreadPoolOptionProto.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasNumThreads {
                jsonMap["numThreads"] = Int(numThreads)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.ThreadPoolOptionProto {
            return try Tensorflow.ThreadPoolOptionProto.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.ThreadPoolOptionProto {
            return try Tensorflow.ThreadPoolOptionProto.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasNumThreads {
                output += "\(indent) numThreads: \(numThreads) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasNumThreads {
                    hashCode = (hashCode &* 31) &+ numThreads.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.ThreadPoolOptionProto"
        }
        override public func className() -> String {
            return "Tensorflow.ThreadPoolOptionProto"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.ThreadPoolOptionProto = Tensorflow.ThreadPoolOptionProto()
            public func getMessage() -> Tensorflow.ThreadPoolOptionProto {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The number of threads in the pool.
            /// 0 means the system picks a value based on where this option proto is used
            /// (see the declaration of the specific field for more info).
            public var numThreads:Int32 {
                get {
                    return builderResult.numThreads
                }
                set (value) {
                    builderResult.hasNumThreads = true
                    builderResult.numThreads = value
                }
            }
            public var hasNumThreads:Bool {
                get {
                    return builderResult.hasNumThreads
                }
            }
            @discardableResult
            public func setNumThreads(_ value:Int32) -> Tensorflow.ThreadPoolOptionProto.Builder {
                self.numThreads = value
                return self
            }
            @discardableResult
            public func clearNumThreads() -> Tensorflow.ThreadPoolOptionProto.Builder{
                builderResult.hasNumThreads = false
                builderResult.numThreads = Int32(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.ThreadPoolOptionProto.Builder {
                builderResult = Tensorflow.ThreadPoolOptionProto()
                return self
            }
            override public func clone() throws -> Tensorflow.ThreadPoolOptionProto.Builder {
                return try Tensorflow.ThreadPoolOptionProto.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.ThreadPoolOptionProto {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.ThreadPoolOptionProto {
                let returnMe:Tensorflow.ThreadPoolOptionProto = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.ThreadPoolOptionProto) throws -> Tensorflow.ThreadPoolOptionProto.Builder {
                if other == Tensorflow.ThreadPoolOptionProto() {
                    return self
                }
                if other.hasNumThreads {
                    numThreads = other.numThreads
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.ThreadPoolOptionProto.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ThreadPoolOptionProto.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        numThreads = try codedInputStream.readInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.ThreadPoolOptionProto.Builder {
                let resultDecodedBuilder = Tensorflow.ThreadPoolOptionProto.Builder()
                if let jsonValueNumThreads = jsonMap["numThreads"] as? Int {
                    resultDecodedBuilder.numThreads = Int32(jsonValueNumThreads)
                } else if let jsonValueNumThreads = jsonMap["numThreads"] as? String {
                    resultDecodedBuilder.numThreads = Int32(jsonValueNumThreads)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.ThreadPoolOptionProto.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.ThreadPoolOptionProto.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class Rpcoptions : GeneratedMessage {

        public static func == (lhs: Tensorflow.Rpcoptions, rhs: Tensorflow.Rpcoptions) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUseRpcForInprocessMaster == rhs.hasUseRpcForInprocessMaster) && (!lhs.hasUseRpcForInprocessMaster || lhs.useRpcForInprocessMaster == rhs.useRpcForInprocessMaster)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// If true, always use RPC to contact the session target.
        /// If false (the default option), TensorFlow may use an optimized
        /// transport for client-master communication that avoids the RPC
        /// stack. This option is primarily for used testing the RPC stack.
        public fileprivate(set) var useRpcForInprocessMaster:Bool = false
        public fileprivate(set) var hasUseRpcForInprocessMaster:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUseRpcForInprocessMaster {
                try codedOutputStream.writeBool(fieldNumber: 1, value:useRpcForInprocessMaster)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUseRpcForInprocessMaster {
                serialize_size += useRpcForInprocessMaster.computeBoolSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.Rpcoptions.Builder {
            return Tensorflow.Rpcoptions.classBuilder() as! Tensorflow.Rpcoptions.Builder
        }
        public func getBuilder() -> Tensorflow.Rpcoptions.Builder {
            return classBuilder() as! Tensorflow.Rpcoptions.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Rpcoptions.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Rpcoptions.Builder()
        }
        public func toBuilder() throws -> Tensorflow.Rpcoptions.Builder {
            return try Tensorflow.Rpcoptions.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.Rpcoptions) throws -> Tensorflow.Rpcoptions.Builder {
            return try Tensorflow.Rpcoptions.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUseRpcForInprocessMaster {
                jsonMap["useRpcForInprocessMaster"] = useRpcForInprocessMaster
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Rpcoptions {
            return try Tensorflow.Rpcoptions.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.Rpcoptions {
            return try Tensorflow.Rpcoptions.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUseRpcForInprocessMaster {
                output += "\(indent) useRpcForInprocessMaster: \(useRpcForInprocessMaster) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUseRpcForInprocessMaster {
                    hashCode = (hashCode &* 31) &+ useRpcForInprocessMaster.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.Rpcoptions"
        }
        override public func className() -> String {
            return "Tensorflow.Rpcoptions"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.Rpcoptions = Tensorflow.Rpcoptions()
            public func getMessage() -> Tensorflow.Rpcoptions {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// If true, always use RPC to contact the session target.
            /// If false (the default option), TensorFlow may use an optimized
            /// transport for client-master communication that avoids the RPC
            /// stack. This option is primarily for used testing the RPC stack.
            public var useRpcForInprocessMaster:Bool {
                get {
                    return builderResult.useRpcForInprocessMaster
                }
                set (value) {
                    builderResult.hasUseRpcForInprocessMaster = true
                    builderResult.useRpcForInprocessMaster = value
                }
            }
            public var hasUseRpcForInprocessMaster:Bool {
                get {
                    return builderResult.hasUseRpcForInprocessMaster
                }
            }
            @discardableResult
            public func setUseRpcForInprocessMaster(_ value:Bool) -> Tensorflow.Rpcoptions.Builder {
                self.useRpcForInprocessMaster = value
                return self
            }
            @discardableResult
            public func clearUseRpcForInprocessMaster() -> Tensorflow.Rpcoptions.Builder{
                builderResult.hasUseRpcForInprocessMaster = false
                builderResult.useRpcForInprocessMaster = false
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.Rpcoptions.Builder {
                builderResult = Tensorflow.Rpcoptions()
                return self
            }
            override public func clone() throws -> Tensorflow.Rpcoptions.Builder {
                return try Tensorflow.Rpcoptions.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.Rpcoptions {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.Rpcoptions {
                let returnMe:Tensorflow.Rpcoptions = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.Rpcoptions) throws -> Tensorflow.Rpcoptions.Builder {
                if other == Tensorflow.Rpcoptions() {
                    return self
                }
                if other.hasUseRpcForInprocessMaster {
                    useRpcForInprocessMaster = other.useRpcForInprocessMaster
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Rpcoptions.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Rpcoptions.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        useRpcForInprocessMaster = try codedInputStream.readBool()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Rpcoptions.Builder {
                let resultDecodedBuilder = Tensorflow.Rpcoptions.Builder()
                if let jsonValueUseRpcForInprocessMaster = jsonMap["useRpcForInprocessMaster"] as? Bool {
                    resultDecodedBuilder.useRpcForInprocessMaster = jsonValueUseRpcForInprocessMaster
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Rpcoptions.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.Rpcoptions.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Session configuration parameters.
    /// The system picks appropriate values for fields that are not set.
    final public class ConfigProto : GeneratedMessage {

        public static func == (lhs: Tensorflow.ConfigProto, rhs: Tensorflow.ConfigProto) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasDeviceCount == rhs.hasDeviceCount) && (!lhs.hasDeviceCount || lhs.deviceCount == rhs.deviceCount)
            fieldCheck = fieldCheck && (lhs.hasIntraOpParallelismThreads == rhs.hasIntraOpParallelismThreads) && (!lhs.hasIntraOpParallelismThreads || lhs.intraOpParallelismThreads == rhs.intraOpParallelismThreads)
            fieldCheck = fieldCheck && (lhs.hasPlacementPeriod == rhs.hasPlacementPeriod) && (!lhs.hasPlacementPeriod || lhs.placementPeriod == rhs.placementPeriod)
            fieldCheck = fieldCheck && (lhs.deviceFilters == rhs.deviceFilters)
            fieldCheck = fieldCheck && (lhs.hasInterOpParallelismThreads == rhs.hasInterOpParallelismThreads) && (!lhs.hasInterOpParallelismThreads || lhs.interOpParallelismThreads == rhs.interOpParallelismThreads)
            fieldCheck = fieldCheck && (lhs.hasGpuOptions == rhs.hasGpuOptions) && (!lhs.hasGpuOptions || lhs.gpuOptions == rhs.gpuOptions)
            fieldCheck = fieldCheck && (lhs.hasAllowSoftPlacement == rhs.hasAllowSoftPlacement) && (!lhs.hasAllowSoftPlacement || lhs.allowSoftPlacement == rhs.allowSoftPlacement)
            fieldCheck = fieldCheck && (lhs.hasLogDevicePlacement == rhs.hasLogDevicePlacement) && (!lhs.hasLogDevicePlacement || lhs.logDevicePlacement == rhs.logDevicePlacement)
            fieldCheck = fieldCheck && (lhs.hasUsePerSessionThreads == rhs.hasUsePerSessionThreads) && (!lhs.hasUsePerSessionThreads || lhs.usePerSessionThreads == rhs.usePerSessionThreads)
            fieldCheck = fieldCheck && (lhs.hasGraphOptions == rhs.hasGraphOptions) && (!lhs.hasGraphOptions || lhs.graphOptions == rhs.graphOptions)
            fieldCheck = fieldCheck && (lhs.hasOperationTimeoutInMs == rhs.hasOperationTimeoutInMs) && (!lhs.hasOperationTimeoutInMs || lhs.operationTimeoutInMs == rhs.operationTimeoutInMs)
            fieldCheck = fieldCheck && (lhs.sessionInterOpThreadPool == rhs.sessionInterOpThreadPool)
            fieldCheck = fieldCheck && (lhs.hasRpcOptions == rhs.hasRpcOptions) && (!lhs.hasRpcOptions || lhs.rpcOptions == rhs.rpcOptions)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        final public class DeviceCountEntry : GeneratedMessage {

            public static func == (lhs: Tensorflow.ConfigProto.DeviceCountEntry, rhs: Tensorflow.ConfigProto.DeviceCountEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:String = ""
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:Int32 = Int32(0)
            public fileprivate(set) var hasValue:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeString(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeInt32(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeStringSize(fieldNumber: 1)
                }
                if hasValue {
                    serialize_size += value.computeInt32Size(fieldNumber: 2)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.ConfigProto.DeviceCountEntry.Builder {
                return Tensorflow.ConfigProto.DeviceCountEntry.classBuilder() as! Tensorflow.ConfigProto.DeviceCountEntry.Builder
            }
            public func getBuilder() -> Tensorflow.ConfigProto.DeviceCountEntry.Builder {
                return classBuilder() as! Tensorflow.ConfigProto.DeviceCountEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.ConfigProto.DeviceCountEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.ConfigProto.DeviceCountEntry.Builder()
            }
            public func toBuilder() throws -> Tensorflow.ConfigProto.DeviceCountEntry.Builder {
                return try Tensorflow.ConfigProto.DeviceCountEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.ConfigProto.DeviceCountEntry) throws -> Tensorflow.ConfigProto.DeviceCountEntry.Builder {
                return try Tensorflow.ConfigProto.DeviceCountEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = key
                }
                if hasValue {
                    jsonMap["value"] = Int(value)
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.ConfigProto.DeviceCountEntry {
                return try Tensorflow.ConfigProto.DeviceCountEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.ConfigProto.DeviceCountEntry {
                return try Tensorflow.ConfigProto.DeviceCountEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value: \(value) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        hashCode = (hashCode &* 31) &+ value.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.ConfigProto.DeviceCountEntry"
            }
            override public func className() -> String {
                return "Tensorflow.ConfigProto.DeviceCountEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.ConfigProto.DeviceCountEntry = Tensorflow.ConfigProto.DeviceCountEntry()
                public func getMessage() -> Tensorflow.ConfigProto.DeviceCountEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:String {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:String) -> Tensorflow.ConfigProto.DeviceCountEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> Tensorflow.ConfigProto.DeviceCountEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = ""
                    return self
                }
                public var value:Int32 {
                    get {
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                @discardableResult
                public func setValue(_ value:Int32) -> Tensorflow.ConfigProto.DeviceCountEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.ConfigProto.DeviceCountEntry.Builder{
                    builderResult.hasValue = false
                    builderResult.value = Int32(0)
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.ConfigProto.DeviceCountEntry.Builder {
                    builderResult = Tensorflow.ConfigProto.DeviceCountEntry()
                    return self
                }
                override public func clone() throws -> Tensorflow.ConfigProto.DeviceCountEntry.Builder {
                    return try Tensorflow.ConfigProto.DeviceCountEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.ConfigProto.DeviceCountEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.ConfigProto.DeviceCountEntry {
                    let returnMe:Tensorflow.ConfigProto.DeviceCountEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.ConfigProto.DeviceCountEntry) throws -> Tensorflow.ConfigProto.DeviceCountEntry.Builder {
                    if other == Tensorflow.ConfigProto.DeviceCountEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if other.hasValue {
                        value = other.value
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.ConfigProto.DeviceCountEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ConfigProto.DeviceCountEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            key = try codedInputStream.readString()

                        case 16:
                            value = try codedInputStream.readInt32()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.ConfigProto.DeviceCountEntry.Builder {
                    let resultDecodedBuilder = Tensorflow.ConfigProto.DeviceCountEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = jsonValueKey
                    }
                    if let jsonValueValue = jsonMap["value"] as? Int {
                        resultDecodedBuilder.value = Int32(jsonValueValue)
                    } else if let jsonValueValue = jsonMap["value"] as? String {
                        resultDecodedBuilder.value = Int32(jsonValueValue)!
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.ConfigProto.DeviceCountEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.ConfigProto.DeviceCountEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        /// Map from device type name (e.g., "CPU" or "GPU" ) to maximum
        /// number of devices of that type to use.  If a particular device
        /// type is not found in the map, the system picks an appropriate
        /// number.
        public fileprivate(set) var deviceCount:Dictionary<String,Int32> = Dictionary<String,Int32>()

        public fileprivate(set) var hasDeviceCount:Bool = false
        /// The execution of an individual op (for some op types) can be
        /// parallelized on a pool of intra_op_parallelism_threads.
        /// 0 means the system picks an appropriate number.
        public fileprivate(set) var intraOpParallelismThreads:Int32 = Int32(0)
        public fileprivate(set) var hasIntraOpParallelismThreads:Bool = false

        /// Nodes that perform blocking operations are enqueued on a pool of
        /// inter_op_parallelism_threads available in each process.
        /// 0 means the system picks an appropriate number.
        /// Note that the first Session created in the process sets the
        /// number of threads for all future sessions unless use_per_session_threads is
        /// true or session_inter_op_thread_pool is configured.
        public fileprivate(set) var interOpParallelismThreads:Int32 = Int32(0)
        public fileprivate(set) var hasInterOpParallelismThreads:Bool = false

        /// If true, use a new set of threads for this session rather than the global
        /// pool of threads. Only supported by direct sessions.
        /// If false, use the global threads created by the first session, or the
        /// per-session thread pools configured by session_inter_op_thread_pool.
        /// This option is deprecated. The same effect can be achieved by setting
        /// session_inter_op_thread_pool to have one element, whose num_threads equals
        /// inter_op_parallelism_threads.
        public fileprivate(set) var usePerSessionThreads:Bool = false
        public fileprivate(set) var hasUsePerSessionThreads:Bool = false

        public fileprivate(set) var sessionInterOpThreadPool:Array<Tensorflow.ThreadPoolOptionProto>  = Array<Tensorflow.ThreadPoolOptionProto>()
        /// Assignment of Nodes to Devices is recomputed every placement_period
        /// steps until the system warms up (at which point the recomputation
        /// typically slows down automatically).
        public fileprivate(set) var placementPeriod:Int32 = Int32(0)
        public fileprivate(set) var hasPlacementPeriod:Bool = false

        /// When any filters are present sessions will ignore all devices which do not
        /// match the filters. Each filter can be partially specified, e.g. "/job:ps"
        /// "/job:worker/replica:3", etc.
        public fileprivate(set) var deviceFilters:Array<String> = Array<String>()
        public fileprivate(set) var gpuOptions:Tensorflow.Gpuoptions!
        public fileprivate(set) var hasGpuOptions:Bool = false
        /// Whether soft placement is allowed. If allow_soft_placement is true,
        /// an op will be placed on CPU if
        ///   1. there's no GPU implementation for the OP
        /// or
        ///   2. no GPU devices are known or registered
        /// or
        ///   3. need to co-locate with reftype input(s) which are from CPU.
        public fileprivate(set) var allowSoftPlacement:Bool = false
        public fileprivate(set) var hasAllowSoftPlacement:Bool = false

        /// Whether device placements should be logged.
        public fileprivate(set) var logDevicePlacement:Bool = false
        public fileprivate(set) var hasLogDevicePlacement:Bool = false

        public fileprivate(set) var graphOptions:Tensorflow.GraphOptions!
        public fileprivate(set) var hasGraphOptions:Bool = false
        /// Global timeout for all blocking operations in this session.  If non-zero,
        /// and not overridden on a per-operation basis, this value will be used as the
        /// deadline for all blocking operations.
        public fileprivate(set) var operationTimeoutInMs:Int64 = Int64(0)
        public fileprivate(set) var hasOperationTimeoutInMs:Bool = false

        public fileprivate(set) var rpcOptions:Tensorflow.Rpcoptions!
        public fileprivate(set) var hasRpcOptions:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasDeviceCount {
                for (keyDeviceCount, valueDeviceCount) in deviceCount {
                    let valueOfDeviceCount = try! Tensorflow.ConfigProto.DeviceCountEntry.Builder().setKey(keyDeviceCount).setValue(valueDeviceCount).build()
                      try codedOutputStream.writeMessage(fieldNumber: 1, value:valueOfDeviceCount)
                  }
            }
            if hasIntraOpParallelismThreads {
                try codedOutputStream.writeInt32(fieldNumber: 2, value:intraOpParallelismThreads)
            }
            if hasPlacementPeriod {
                try codedOutputStream.writeInt32(fieldNumber: 3, value:placementPeriod)
            }
            if !deviceFilters.isEmpty {
                for oneValuedeviceFilters in deviceFilters {
                    try codedOutputStream.writeString(fieldNumber: 4, value:oneValuedeviceFilters)
                }
            }
            if hasInterOpParallelismThreads {
                try codedOutputStream.writeInt32(fieldNumber: 5, value:interOpParallelismThreads)
            }
            if hasGpuOptions {
                try codedOutputStream.writeMessage(fieldNumber: 6, value:gpuOptions)
            }
            if hasAllowSoftPlacement {
                try codedOutputStream.writeBool(fieldNumber: 7, value:allowSoftPlacement)
            }
            if hasLogDevicePlacement {
                try codedOutputStream.writeBool(fieldNumber: 8, value:logDevicePlacement)
            }
            if hasUsePerSessionThreads {
                try codedOutputStream.writeBool(fieldNumber: 9, value:usePerSessionThreads)
            }
            if hasGraphOptions {
                try codedOutputStream.writeMessage(fieldNumber: 10, value:graphOptions)
            }
            if hasOperationTimeoutInMs {
                try codedOutputStream.writeInt64(fieldNumber: 11, value:operationTimeoutInMs)
            }
            for oneElementSessionInterOpThreadPool in sessionInterOpThreadPool {
                  try codedOutputStream.writeMessage(fieldNumber: 12, value:oneElementSessionInterOpThreadPool)
            }
            if hasRpcOptions {
                try codedOutputStream.writeMessage(fieldNumber: 13, value:rpcOptions)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasDeviceCount {
                  for (keyDeviceCount, valueDeviceCount) in deviceCount {
                      let valueOfDeviceCount = try! Tensorflow.ConfigProto.DeviceCountEntry.Builder().setKey(keyDeviceCount).setValue(valueDeviceCount).build()
                serialize_size += valueOfDeviceCount.computeMessageSize(fieldNumber: 1)
                }
            }
            if hasIntraOpParallelismThreads {
                serialize_size += intraOpParallelismThreads.computeInt32Size(fieldNumber: 2)
            }
            if hasPlacementPeriod {
                serialize_size += placementPeriod.computeInt32Size(fieldNumber: 3)
            }
            var dataSizeDeviceFilters:Int32 = 0
            for oneValuedeviceFilters in deviceFilters {
                dataSizeDeviceFilters += oneValuedeviceFilters.computeStringSizeNoTag()
            }
            serialize_size += dataSizeDeviceFilters
            serialize_size += 1 * Int32(deviceFilters.count)
            if hasInterOpParallelismThreads {
                serialize_size += interOpParallelismThreads.computeInt32Size(fieldNumber: 5)
            }
            if hasGpuOptions {
                if let varSizegpuOptions = gpuOptions?.computeMessageSize(fieldNumber: 6) {
                    serialize_size += varSizegpuOptions
                }
            }
            if hasAllowSoftPlacement {
                serialize_size += allowSoftPlacement.computeBoolSize(fieldNumber: 7)
            }
            if hasLogDevicePlacement {
                serialize_size += logDevicePlacement.computeBoolSize(fieldNumber: 8)
            }
            if hasUsePerSessionThreads {
                serialize_size += usePerSessionThreads.computeBoolSize(fieldNumber: 9)
            }
            if hasGraphOptions {
                if let varSizegraphOptions = graphOptions?.computeMessageSize(fieldNumber: 10) {
                    serialize_size += varSizegraphOptions
                }
            }
            if hasOperationTimeoutInMs {
                serialize_size += operationTimeoutInMs.computeInt64Size(fieldNumber: 11)
            }
            for oneElementSessionInterOpThreadPool in sessionInterOpThreadPool {
                serialize_size += oneElementSessionInterOpThreadPool.computeMessageSize(fieldNumber: 12)
            }
            if hasRpcOptions {
                if let varSizerpcOptions = rpcOptions?.computeMessageSize(fieldNumber: 13) {
                    serialize_size += varSizerpcOptions
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.ConfigProto.Builder {
            return Tensorflow.ConfigProto.classBuilder() as! Tensorflow.ConfigProto.Builder
        }
        public func getBuilder() -> Tensorflow.ConfigProto.Builder {
            return classBuilder() as! Tensorflow.ConfigProto.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.ConfigProto.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.ConfigProto.Builder()
        }
        public func toBuilder() throws -> Tensorflow.ConfigProto.Builder {
            return try Tensorflow.ConfigProto.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.ConfigProto) throws -> Tensorflow.ConfigProto.Builder {
            return try Tensorflow.ConfigProto.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasDeviceCount {
                var mapDeviceCount = Dictionary<String, Int>()
                for (keyDeviceCount, valueDeviceCount) in deviceCount {
                    mapDeviceCount["\(keyDeviceCount)"] = Int(valueDeviceCount)
                }
                jsonMap["deviceCount"] = mapDeviceCount
            }
            if hasIntraOpParallelismThreads {
                jsonMap["intraOpParallelismThreads"] = Int(intraOpParallelismThreads)
            }
            if hasInterOpParallelismThreads {
                jsonMap["interOpParallelismThreads"] = Int(interOpParallelismThreads)
            }
            if hasUsePerSessionThreads {
                jsonMap["usePerSessionThreads"] = usePerSessionThreads
            }
            if !sessionInterOpThreadPool.isEmpty {
                var jsonArraySessionInterOpThreadPool:Array<Dictionary<String,Any>> = []
                for oneValueSessionInterOpThreadPool in sessionInterOpThreadPool {
                    let ecodedMessageSessionInterOpThreadPool = try oneValueSessionInterOpThreadPool.encode()
                    jsonArraySessionInterOpThreadPool.append(ecodedMessageSessionInterOpThreadPool)
                }
                jsonMap["sessionInterOpThreadPool"] = jsonArraySessionInterOpThreadPool
            }
            if hasPlacementPeriod {
                jsonMap["placementPeriod"] = Int(placementPeriod)
            }
            if !deviceFilters.isEmpty {
                var jsonArrayDeviceFilters:Array<String> = []
                for oneValueDeviceFilters in deviceFilters {
                    jsonArrayDeviceFilters.append(oneValueDeviceFilters)
                }
                jsonMap["deviceFilters"] = jsonArrayDeviceFilters
            }
            if hasGpuOptions {
                jsonMap["gpuOptions"] = try gpuOptions.encode()
            }
            if hasAllowSoftPlacement {
                jsonMap["allowSoftPlacement"] = allowSoftPlacement
            }
            if hasLogDevicePlacement {
                jsonMap["logDevicePlacement"] = logDevicePlacement
            }
            if hasGraphOptions {
                jsonMap["graphOptions"] = try graphOptions.encode()
            }
            if hasOperationTimeoutInMs {
                jsonMap["operationTimeoutInMs"] = "\(operationTimeoutInMs)"
            }
            if hasRpcOptions {
                jsonMap["rpcOptions"] = try rpcOptions.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.ConfigProto {
            return try Tensorflow.ConfigProto.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.ConfigProto {
            return try Tensorflow.ConfigProto.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasDeviceCount {
                output += "\(indent) deviceCount: \(deviceCount) \n"
            }
            if hasIntraOpParallelismThreads {
                output += "\(indent) intraOpParallelismThreads: \(intraOpParallelismThreads) \n"
            }
            if hasPlacementPeriod {
                output += "\(indent) placementPeriod: \(placementPeriod) \n"
            }
            var deviceFiltersElementIndex:Int = 0
            for oneValueDeviceFilters in deviceFilters  {
                output += "\(indent) deviceFilters[\(deviceFiltersElementIndex)]: \(oneValueDeviceFilters)\n"
                deviceFiltersElementIndex += 1
            }
            if hasInterOpParallelismThreads {
                output += "\(indent) interOpParallelismThreads: \(interOpParallelismThreads) \n"
            }
            if hasGpuOptions {
                output += "\(indent) gpuOptions {\n"
                if let outDescGpuOptions = gpuOptions {
                    output += try outDescGpuOptions.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasAllowSoftPlacement {
                output += "\(indent) allowSoftPlacement: \(allowSoftPlacement) \n"
            }
            if hasLogDevicePlacement {
                output += "\(indent) logDevicePlacement: \(logDevicePlacement) \n"
            }
            if hasUsePerSessionThreads {
                output += "\(indent) usePerSessionThreads: \(usePerSessionThreads) \n"
            }
            if hasGraphOptions {
                output += "\(indent) graphOptions {\n"
                if let outDescGraphOptions = graphOptions {
                    output += try outDescGraphOptions.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasOperationTimeoutInMs {
                output += "\(indent) operationTimeoutInMs: \(operationTimeoutInMs) \n"
            }
            var sessionInterOpThreadPoolElementIndex:Int = 0
            for oneElementSessionInterOpThreadPool in sessionInterOpThreadPool {
                output += "\(indent) sessionInterOpThreadPool[\(sessionInterOpThreadPoolElementIndex)] {\n"
                output += try oneElementSessionInterOpThreadPool.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                sessionInterOpThreadPoolElementIndex += 1
            }
            if hasRpcOptions {
                output += "\(indent) rpcOptions {\n"
                if let outDescRpcOptions = rpcOptions {
                    output += try outDescRpcOptions.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasDeviceCount {
                    for (keyDeviceCount, valueDeviceCount) in deviceCount {
                        hashCode = (hashCode &* 31) &+ keyDeviceCount.hashValue
                        hashCode = (hashCode &* 31) &+ valueDeviceCount.hashValue
                    }
                }
                if hasIntraOpParallelismThreads {
                    hashCode = (hashCode &* 31) &+ intraOpParallelismThreads.hashValue
                }
                if hasPlacementPeriod {
                    hashCode = (hashCode &* 31) &+ placementPeriod.hashValue
                }
                for oneValueDeviceFilters in deviceFilters {
                    hashCode = (hashCode &* 31) &+ oneValueDeviceFilters.hashValue
                }
                if hasInterOpParallelismThreads {
                    hashCode = (hashCode &* 31) &+ interOpParallelismThreads.hashValue
                }
                if hasGpuOptions {
                    if let hashValuegpuOptions = gpuOptions?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuegpuOptions
                    }
                }
                if hasAllowSoftPlacement {
                    hashCode = (hashCode &* 31) &+ allowSoftPlacement.hashValue
                }
                if hasLogDevicePlacement {
                    hashCode = (hashCode &* 31) &+ logDevicePlacement.hashValue
                }
                if hasUsePerSessionThreads {
                    hashCode = (hashCode &* 31) &+ usePerSessionThreads.hashValue
                }
                if hasGraphOptions {
                    if let hashValuegraphOptions = graphOptions?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuegraphOptions
                    }
                }
                if hasOperationTimeoutInMs {
                    hashCode = (hashCode &* 31) &+ operationTimeoutInMs.hashValue
                }
                for oneElementSessionInterOpThreadPool in sessionInterOpThreadPool {
                    hashCode = (hashCode &* 31) &+ oneElementSessionInterOpThreadPool.hashValue
                }
                if hasRpcOptions {
                    if let hashValuerpcOptions = rpcOptions?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuerpcOptions
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.ConfigProto"
        }
        override public func className() -> String {
            return "Tensorflow.ConfigProto"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.ConfigProto = Tensorflow.ConfigProto()
            public func getMessage() -> Tensorflow.ConfigProto {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Map from device type name (e.g., "CPU" or "GPU" ) to maximum
            /// number of devices of that type to use.  If a particular device
            /// type is not found in the map, the system picks an appropriate
            /// number.
            public var hasDeviceCount:Bool {
                get {
                    return builderResult.hasDeviceCount
                }
            }
            public var deviceCount:Dictionary<String,Int32> {
                get {
                    return builderResult.deviceCount
                }
                set (value) {
                    builderResult.hasDeviceCount = true
                    builderResult.deviceCount = value
                }
            }
            @discardableResult
            public func setDeviceCount(_ value:Dictionary<String,Int32>) -> Tensorflow.ConfigProto.Builder {
                self.deviceCount = value
                return self
            }
            @discardableResult
            public func clearDeviceCount() -> Tensorflow.ConfigProto.Builder{
                builderResult.hasDeviceCount = false
                builderResult.deviceCount = Dictionary<String,Int32>()
                return self
            }
            /// The execution of an individual op (for some op types) can be
            /// parallelized on a pool of intra_op_parallelism_threads.
            /// 0 means the system picks an appropriate number.
            public var intraOpParallelismThreads:Int32 {
                get {
                    return builderResult.intraOpParallelismThreads
                }
                set (value) {
                    builderResult.hasIntraOpParallelismThreads = true
                    builderResult.intraOpParallelismThreads = value
                }
            }
            public var hasIntraOpParallelismThreads:Bool {
                get {
                    return builderResult.hasIntraOpParallelismThreads
                }
            }
            @discardableResult
            public func setIntraOpParallelismThreads(_ value:Int32) -> Tensorflow.ConfigProto.Builder {
                self.intraOpParallelismThreads = value
                return self
            }
            @discardableResult
            public func clearIntraOpParallelismThreads() -> Tensorflow.ConfigProto.Builder{
                builderResult.hasIntraOpParallelismThreads = false
                builderResult.intraOpParallelismThreads = Int32(0)
                return self
            }
            /// Nodes that perform blocking operations are enqueued on a pool of
            /// inter_op_parallelism_threads available in each process.
            /// 0 means the system picks an appropriate number.
            /// Note that the first Session created in the process sets the
            /// number of threads for all future sessions unless use_per_session_threads is
            /// true or session_inter_op_thread_pool is configured.
            public var interOpParallelismThreads:Int32 {
                get {
                    return builderResult.interOpParallelismThreads
                }
                set (value) {
                    builderResult.hasInterOpParallelismThreads = true
                    builderResult.interOpParallelismThreads = value
                }
            }
            public var hasInterOpParallelismThreads:Bool {
                get {
                    return builderResult.hasInterOpParallelismThreads
                }
            }
            @discardableResult
            public func setInterOpParallelismThreads(_ value:Int32) -> Tensorflow.ConfigProto.Builder {
                self.interOpParallelismThreads = value
                return self
            }
            @discardableResult
            public func clearInterOpParallelismThreads() -> Tensorflow.ConfigProto.Builder{
                builderResult.hasInterOpParallelismThreads = false
                builderResult.interOpParallelismThreads = Int32(0)
                return self
            }
            /// If true, use a new set of threads for this session rather than the global
            /// pool of threads. Only supported by direct sessions.
            /// If false, use the global threads created by the first session, or the
            /// per-session thread pools configured by session_inter_op_thread_pool.
            /// This option is deprecated. The same effect can be achieved by setting
            /// session_inter_op_thread_pool to have one element, whose num_threads equals
            /// inter_op_parallelism_threads.
            public var usePerSessionThreads:Bool {
                get {
                    return builderResult.usePerSessionThreads
                }
                set (value) {
                    builderResult.hasUsePerSessionThreads = true
                    builderResult.usePerSessionThreads = value
                }
            }
            public var hasUsePerSessionThreads:Bool {
                get {
                    return builderResult.hasUsePerSessionThreads
                }
            }
            @discardableResult
            public func setUsePerSessionThreads(_ value:Bool) -> Tensorflow.ConfigProto.Builder {
                self.usePerSessionThreads = value
                return self
            }
            @discardableResult
            public func clearUsePerSessionThreads() -> Tensorflow.ConfigProto.Builder{
                builderResult.hasUsePerSessionThreads = false
                builderResult.usePerSessionThreads = false
                return self
            }
            /// This option is experimental - it may be replaced with a different mechanism
            /// in the future. The intended use is for when some session invocations need
            /// to run in a background pool limited to a small number of threads.
            /// Configures session thread pools. If this is configured, then RunOptions for
            /// a Run call can select the thread pool to use.
            /// If a pool's num_threads is 0, then inter_op_parallelism_threads is used.
            public var sessionInterOpThreadPool:Array<Tensorflow.ThreadPoolOptionProto> {
                get {
                    return builderResult.sessionInterOpThreadPool
                }
                set (value) {
                    builderResult.sessionInterOpThreadPool = value
                }
            }
            @discardableResult
            public func setSessionInterOpThreadPool(_ value:Array<Tensorflow.ThreadPoolOptionProto>) -> Tensorflow.ConfigProto.Builder {
                self.sessionInterOpThreadPool = value
                return self
            }
            @discardableResult
            public func clearSessionInterOpThreadPool() -> Tensorflow.ConfigProto.Builder {
                builderResult.sessionInterOpThreadPool.removeAll(keepingCapacity: false)
                return self
            }
            /// Assignment of Nodes to Devices is recomputed every placement_period
            /// steps until the system warms up (at which point the recomputation
            /// typically slows down automatically).
            public var placementPeriod:Int32 {
                get {
                    return builderResult.placementPeriod
                }
                set (value) {
                    builderResult.hasPlacementPeriod = true
                    builderResult.placementPeriod = value
                }
            }
            public var hasPlacementPeriod:Bool {
                get {
                    return builderResult.hasPlacementPeriod
                }
            }
            @discardableResult
            public func setPlacementPeriod(_ value:Int32) -> Tensorflow.ConfigProto.Builder {
                self.placementPeriod = value
                return self
            }
            @discardableResult
            public func clearPlacementPeriod() -> Tensorflow.ConfigProto.Builder{
                builderResult.hasPlacementPeriod = false
                builderResult.placementPeriod = Int32(0)
                return self
            }
            /// When any filters are present sessions will ignore all devices which do not
            /// match the filters. Each filter can be partially specified, e.g. "/job:ps"
            /// "/job:worker/replica:3", etc.
            public var deviceFilters:Array<String> {
                get {
                    return builderResult.deviceFilters
                }
                set (array) {
                    builderResult.deviceFilters = array
                }
            }
            @discardableResult
            public func setDeviceFilters(_ value:Array<String>) -> Tensorflow.ConfigProto.Builder {
                self.deviceFilters = value
                return self
            }
            @discardableResult
            public func clearDeviceFilters() -> Tensorflow.ConfigProto.Builder {
                builderResult.deviceFilters.removeAll(keepingCapacity: false)
                return self
            }
            /// Options that apply to all GPUs.
            public var gpuOptions:Tensorflow.Gpuoptions! {
                get {
                    if gpuOptionsBuilder_ != nil {
                        builderResult.gpuOptions = gpuOptionsBuilder_.getMessage()
                    }
                    return builderResult.gpuOptions
                }
                set (value) {
                    builderResult.hasGpuOptions = true
                    builderResult.gpuOptions = value
                }
            }
            public var hasGpuOptions:Bool {
                get {
                    return builderResult.hasGpuOptions
                }
            }
            fileprivate var gpuOptionsBuilder_:Tensorflow.Gpuoptions.Builder! {
                didSet {
                    builderResult.hasGpuOptions = true
                }
            }
            public func getGpuOptionsBuilder() -> Tensorflow.Gpuoptions.Builder {
                if gpuOptionsBuilder_ == nil {
                    gpuOptionsBuilder_ = Tensorflow.Gpuoptions.Builder()
                    builderResult.gpuOptions = gpuOptionsBuilder_.getMessage()
                    if gpuOptions != nil {
                        try! gpuOptionsBuilder_.mergeFrom(other: gpuOptions)
                    }
                }
                return gpuOptionsBuilder_
            }
            @discardableResult
            public func setGpuOptions(_ value:Tensorflow.Gpuoptions!) -> Tensorflow.ConfigProto.Builder {
                self.gpuOptions = value
                return self
            }
            @discardableResult
            public func mergeGpuOptions(value:Tensorflow.Gpuoptions) throws -> Tensorflow.ConfigProto.Builder {
                if builderResult.hasGpuOptions {
                    builderResult.gpuOptions = try Tensorflow.Gpuoptions.builderWithPrototype(prototype:builderResult.gpuOptions).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.gpuOptions = value
                }
                builderResult.hasGpuOptions = true
                return self
            }
            @discardableResult
            public func clearGpuOptions() -> Tensorflow.ConfigProto.Builder {
                gpuOptionsBuilder_ = nil
                builderResult.hasGpuOptions = false
                builderResult.gpuOptions = nil
                return self
            }
            /// Whether soft placement is allowed. If allow_soft_placement is true,
            /// an op will be placed on CPU if
            ///   1. there's no GPU implementation for the OP
            /// or
            ///   2. no GPU devices are known or registered
            /// or
            ///   3. need to co-locate with reftype input(s) which are from CPU.
            public var allowSoftPlacement:Bool {
                get {
                    return builderResult.allowSoftPlacement
                }
                set (value) {
                    builderResult.hasAllowSoftPlacement = true
                    builderResult.allowSoftPlacement = value
                }
            }
            public var hasAllowSoftPlacement:Bool {
                get {
                    return builderResult.hasAllowSoftPlacement
                }
            }
            @discardableResult
            public func setAllowSoftPlacement(_ value:Bool) -> Tensorflow.ConfigProto.Builder {
                self.allowSoftPlacement = value
                return self
            }
            @discardableResult
            public func clearAllowSoftPlacement() -> Tensorflow.ConfigProto.Builder{
                builderResult.hasAllowSoftPlacement = false
                builderResult.allowSoftPlacement = false
                return self
            }
            /// Whether device placements should be logged.
            public var logDevicePlacement:Bool {
                get {
                    return builderResult.logDevicePlacement
                }
                set (value) {
                    builderResult.hasLogDevicePlacement = true
                    builderResult.logDevicePlacement = value
                }
            }
            public var hasLogDevicePlacement:Bool {
                get {
                    return builderResult.hasLogDevicePlacement
                }
            }
            @discardableResult
            public func setLogDevicePlacement(_ value:Bool) -> Tensorflow.ConfigProto.Builder {
                self.logDevicePlacement = value
                return self
            }
            @discardableResult
            public func clearLogDevicePlacement() -> Tensorflow.ConfigProto.Builder{
                builderResult.hasLogDevicePlacement = false
                builderResult.logDevicePlacement = false
                return self
            }
            /// Options that apply to all graphs.
            public var graphOptions:Tensorflow.GraphOptions! {
                get {
                    if graphOptionsBuilder_ != nil {
                        builderResult.graphOptions = graphOptionsBuilder_.getMessage()
                    }
                    return builderResult.graphOptions
                }
                set (value) {
                    builderResult.hasGraphOptions = true
                    builderResult.graphOptions = value
                }
            }
            public var hasGraphOptions:Bool {
                get {
                    return builderResult.hasGraphOptions
                }
            }
            fileprivate var graphOptionsBuilder_:Tensorflow.GraphOptions.Builder! {
                didSet {
                    builderResult.hasGraphOptions = true
                }
            }
            public func getGraphOptionsBuilder() -> Tensorflow.GraphOptions.Builder {
                if graphOptionsBuilder_ == nil {
                    graphOptionsBuilder_ = Tensorflow.GraphOptions.Builder()
                    builderResult.graphOptions = graphOptionsBuilder_.getMessage()
                    if graphOptions != nil {
                        try! graphOptionsBuilder_.mergeFrom(other: graphOptions)
                    }
                }
                return graphOptionsBuilder_
            }
            @discardableResult
            public func setGraphOptions(_ value:Tensorflow.GraphOptions!) -> Tensorflow.ConfigProto.Builder {
                self.graphOptions = value
                return self
            }
            @discardableResult
            public func mergeGraphOptions(value:Tensorflow.GraphOptions) throws -> Tensorflow.ConfigProto.Builder {
                if builderResult.hasGraphOptions {
                    builderResult.graphOptions = try Tensorflow.GraphOptions.builderWithPrototype(prototype:builderResult.graphOptions).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.graphOptions = value
                }
                builderResult.hasGraphOptions = true
                return self
            }
            @discardableResult
            public func clearGraphOptions() -> Tensorflow.ConfigProto.Builder {
                graphOptionsBuilder_ = nil
                builderResult.hasGraphOptions = false
                builderResult.graphOptions = nil
                return self
            }
            /// Global timeout for all blocking operations in this session.  If non-zero,
            /// and not overridden on a per-operation basis, this value will be used as the
            /// deadline for all blocking operations.
            public var operationTimeoutInMs:Int64 {
                get {
                    return builderResult.operationTimeoutInMs
                }
                set (value) {
                    builderResult.hasOperationTimeoutInMs = true
                    builderResult.operationTimeoutInMs = value
                }
            }
            public var hasOperationTimeoutInMs:Bool {
                get {
                    return builderResult.hasOperationTimeoutInMs
                }
            }
            @discardableResult
            public func setOperationTimeoutInMs(_ value:Int64) -> Tensorflow.ConfigProto.Builder {
                self.operationTimeoutInMs = value
                return self
            }
            @discardableResult
            public func clearOperationTimeoutInMs() -> Tensorflow.ConfigProto.Builder{
                builderResult.hasOperationTimeoutInMs = false
                builderResult.operationTimeoutInMs = Int64(0)
                return self
            }
            /// Options that apply when this session uses the distributed runtime.
            public var rpcOptions:Tensorflow.Rpcoptions! {
                get {
                    if rpcOptionsBuilder_ != nil {
                        builderResult.rpcOptions = rpcOptionsBuilder_.getMessage()
                    }
                    return builderResult.rpcOptions
                }
                set (value) {
                    builderResult.hasRpcOptions = true
                    builderResult.rpcOptions = value
                }
            }
            public var hasRpcOptions:Bool {
                get {
                    return builderResult.hasRpcOptions
                }
            }
            fileprivate var rpcOptionsBuilder_:Tensorflow.Rpcoptions.Builder! {
                didSet {
                    builderResult.hasRpcOptions = true
                }
            }
            public func getRpcOptionsBuilder() -> Tensorflow.Rpcoptions.Builder {
                if rpcOptionsBuilder_ == nil {
                    rpcOptionsBuilder_ = Tensorflow.Rpcoptions.Builder()
                    builderResult.rpcOptions = rpcOptionsBuilder_.getMessage()
                    if rpcOptions != nil {
                        try! rpcOptionsBuilder_.mergeFrom(other: rpcOptions)
                    }
                }
                return rpcOptionsBuilder_
            }
            @discardableResult
            public func setRpcOptions(_ value:Tensorflow.Rpcoptions!) -> Tensorflow.ConfigProto.Builder {
                self.rpcOptions = value
                return self
            }
            @discardableResult
            public func mergeRpcOptions(value:Tensorflow.Rpcoptions) throws -> Tensorflow.ConfigProto.Builder {
                if builderResult.hasRpcOptions {
                    builderResult.rpcOptions = try Tensorflow.Rpcoptions.builderWithPrototype(prototype:builderResult.rpcOptions).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.rpcOptions = value
                }
                builderResult.hasRpcOptions = true
                return self
            }
            @discardableResult
            public func clearRpcOptions() -> Tensorflow.ConfigProto.Builder {
                rpcOptionsBuilder_ = nil
                builderResult.hasRpcOptions = false
                builderResult.rpcOptions = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.ConfigProto.Builder {
                builderResult = Tensorflow.ConfigProto()
                return self
            }
            override public func clone() throws -> Tensorflow.ConfigProto.Builder {
                return try Tensorflow.ConfigProto.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.ConfigProto {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.ConfigProto {
                let returnMe:Tensorflow.ConfigProto = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.ConfigProto) throws -> Tensorflow.ConfigProto.Builder {
                if other == Tensorflow.ConfigProto() {
                    return self
                }
                if other.hasDeviceCount {
                    deviceCount = other.deviceCount
                }
                if other.hasIntraOpParallelismThreads {
                    intraOpParallelismThreads = other.intraOpParallelismThreads
                }
                if other.hasInterOpParallelismThreads {
                    interOpParallelismThreads = other.interOpParallelismThreads
                }
                if other.hasUsePerSessionThreads {
                    usePerSessionThreads = other.usePerSessionThreads
                }
                if !other.sessionInterOpThreadPool.isEmpty  {
                     builderResult.sessionInterOpThreadPool += other.sessionInterOpThreadPool
                }
                if other.hasPlacementPeriod {
                    placementPeriod = other.placementPeriod
                }
                if !other.deviceFilters.isEmpty {
                    builderResult.deviceFilters += other.deviceFilters
                }
                if (other.hasGpuOptions) {
                    try mergeGpuOptions(value: other.gpuOptions)
                }
                if other.hasAllowSoftPlacement {
                    allowSoftPlacement = other.allowSoftPlacement
                }
                if other.hasLogDevicePlacement {
                    logDevicePlacement = other.logDevicePlacement
                }
                if (other.hasGraphOptions) {
                    try mergeGraphOptions(value: other.graphOptions)
                }
                if other.hasOperationTimeoutInMs {
                    operationTimeoutInMs = other.operationTimeoutInMs
                }
                if (other.hasRpcOptions) {
                    try mergeRpcOptions(value: other.rpcOptions)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.ConfigProto.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ConfigProto.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Tensorflow.ConfigProto.DeviceCountEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfDeviceCount = subBuilder.buildPartial()
                        deviceCount[buildOfDeviceCount.key] = buildOfDeviceCount.value

                    case 16:
                        intraOpParallelismThreads = try codedInputStream.readInt32()

                    case 24:
                        placementPeriod = try codedInputStream.readInt32()

                    case 34:
                        deviceFilters += [try codedInputStream.readString()]

                    case 40:
                        interOpParallelismThreads = try codedInputStream.readInt32()

                    case 50:
                        let subBuilder:Tensorflow.Gpuoptions.Builder = Tensorflow.Gpuoptions.Builder()
                        if hasGpuOptions {
                            try subBuilder.mergeFrom(other: gpuOptions)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        gpuOptions = subBuilder.buildPartial()

                    case 56:
                        allowSoftPlacement = try codedInputStream.readBool()

                    case 64:
                        logDevicePlacement = try codedInputStream.readBool()

                    case 72:
                        usePerSessionThreads = try codedInputStream.readBool()

                    case 82:
                        let subBuilder:Tensorflow.GraphOptions.Builder = Tensorflow.GraphOptions.Builder()
                        if hasGraphOptions {
                            try subBuilder.mergeFrom(other: graphOptions)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        graphOptions = subBuilder.buildPartial()

                    case 88:
                        operationTimeoutInMs = try codedInputStream.readInt64()

                    case 98:
                        let subBuilder = Tensorflow.ThreadPoolOptionProto.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        sessionInterOpThreadPool.append(subBuilder.buildPartial())

                    case 106:
                        let subBuilder:Tensorflow.Rpcoptions.Builder = Tensorflow.Rpcoptions.Builder()
                        if hasRpcOptions {
                            try subBuilder.mergeFrom(other: rpcOptions)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        rpcOptions = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.ConfigProto.Builder {
                let resultDecodedBuilder = Tensorflow.ConfigProto.Builder()
                if let jsonValueDeviceCount = jsonMap["deviceCount"] as? Dictionary<String, Int> {
                    var mapDeviceCount = Dictionary<String, Int32>()
                    for (keyDeviceCount, valueDeviceCount) in jsonValueDeviceCount {
                        guard let keyFromDeviceCount = String(keyDeviceCount) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapDeviceCount[keyFromDeviceCount] = Int32(valueDeviceCount)
                    }
                    resultDecodedBuilder.deviceCount = mapDeviceCount
                }
                if let jsonValueIntraOpParallelismThreads = jsonMap["intraOpParallelismThreads"] as? Int {
                    resultDecodedBuilder.intraOpParallelismThreads = Int32(jsonValueIntraOpParallelismThreads)
                } else if let jsonValueIntraOpParallelismThreads = jsonMap["intraOpParallelismThreads"] as? String {
                    resultDecodedBuilder.intraOpParallelismThreads = Int32(jsonValueIntraOpParallelismThreads)!
                }
                if let jsonValueInterOpParallelismThreads = jsonMap["interOpParallelismThreads"] as? Int {
                    resultDecodedBuilder.interOpParallelismThreads = Int32(jsonValueInterOpParallelismThreads)
                } else if let jsonValueInterOpParallelismThreads = jsonMap["interOpParallelismThreads"] as? String {
                    resultDecodedBuilder.interOpParallelismThreads = Int32(jsonValueInterOpParallelismThreads)!
                }
                if let jsonValueUsePerSessionThreads = jsonMap["usePerSessionThreads"] as? Bool {
                    resultDecodedBuilder.usePerSessionThreads = jsonValueUsePerSessionThreads
                }
                if let jsonValueSessionInterOpThreadPool = jsonMap["sessionInterOpThreadPool"] as? Array<Dictionary<String,Any>> {
                    var jsonArraySessionInterOpThreadPool:Array<Tensorflow.ThreadPoolOptionProto> = []
                    for oneValueSessionInterOpThreadPool in jsonValueSessionInterOpThreadPool {
                        let messageFromStringSessionInterOpThreadPool = try Tensorflow.ThreadPoolOptionProto.Builder.decodeToBuilder(jsonMap:oneValueSessionInterOpThreadPool).build()

                        jsonArraySessionInterOpThreadPool.append(messageFromStringSessionInterOpThreadPool)
                    }
                    resultDecodedBuilder.sessionInterOpThreadPool = jsonArraySessionInterOpThreadPool
                }
                if let jsonValuePlacementPeriod = jsonMap["placementPeriod"] as? Int {
                    resultDecodedBuilder.placementPeriod = Int32(jsonValuePlacementPeriod)
                } else if let jsonValuePlacementPeriod = jsonMap["placementPeriod"] as? String {
                    resultDecodedBuilder.placementPeriod = Int32(jsonValuePlacementPeriod)!
                }
                if let jsonValueDeviceFilters = jsonMap["deviceFilters"] as? Array<String> {
                    var jsonArrayDeviceFilters:Array<String> = []
                    for oneValueDeviceFilters in jsonValueDeviceFilters {
                        jsonArrayDeviceFilters.append(oneValueDeviceFilters)
                    }
                    resultDecodedBuilder.deviceFilters = jsonArrayDeviceFilters
                }
                if let jsonValueGpuOptions = jsonMap["gpuOptions"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.gpuOptions = try Tensorflow.Gpuoptions.Builder.decodeToBuilder(jsonMap:jsonValueGpuOptions).build()

                }
                if let jsonValueAllowSoftPlacement = jsonMap["allowSoftPlacement"] as? Bool {
                    resultDecodedBuilder.allowSoftPlacement = jsonValueAllowSoftPlacement
                }
                if let jsonValueLogDevicePlacement = jsonMap["logDevicePlacement"] as? Bool {
                    resultDecodedBuilder.logDevicePlacement = jsonValueLogDevicePlacement
                }
                if let jsonValueGraphOptions = jsonMap["graphOptions"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.graphOptions = try Tensorflow.GraphOptions.Builder.decodeToBuilder(jsonMap:jsonValueGraphOptions).build()

                }
                if let jsonValueOperationTimeoutInMs = jsonMap["operationTimeoutInMs"] as? String {
                    resultDecodedBuilder.operationTimeoutInMs = Int64(jsonValueOperationTimeoutInMs)!
                } else if let jsonValueOperationTimeoutInMs = jsonMap["operationTimeoutInMs"] as? Int {
                    resultDecodedBuilder.operationTimeoutInMs = Int64(jsonValueOperationTimeoutInMs)
                }
                if let jsonValueRpcOptions = jsonMap["rpcOptions"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.rpcOptions = try Tensorflow.Rpcoptions.Builder.decodeToBuilder(jsonMap:jsonValueRpcOptions).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.ConfigProto.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.ConfigProto.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Options for a single Run() call.
    final public class RunOptions : GeneratedMessage {

        public static func == (lhs: Tensorflow.RunOptions, rhs: Tensorflow.RunOptions) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasTraceLevel == rhs.hasTraceLevel) && (!lhs.hasTraceLevel || lhs.traceLevel == rhs.traceLevel)
            fieldCheck = fieldCheck && (lhs.hasTimeoutInMs == rhs.hasTimeoutInMs) && (!lhs.hasTimeoutInMs || lhs.timeoutInMs == rhs.timeoutInMs)
            fieldCheck = fieldCheck && (lhs.hasInterOpThreadPool == rhs.hasInterOpThreadPool) && (!lhs.hasInterOpThreadPool || lhs.interOpThreadPool == rhs.interOpThreadPool)
            fieldCheck = fieldCheck && (lhs.hasOutputPartitionGraphs == rhs.hasOutputPartitionGraphs) && (!lhs.hasOutputPartitionGraphs || lhs.outputPartitionGraphs == rhs.outputPartitionGraphs)
            fieldCheck = fieldCheck && (lhs.hasDebugOptions == rhs.hasDebugOptions) && (!lhs.hasDebugOptions || lhs.debugOptions == rhs.debugOptions)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



            //Enum type declaration start 

            /// TODO(pbar) Turn this into a TraceOptions proto which allows
            /// tracing to be controlled in a more orthogonal manner?
            public enum TraceLevel:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
                case noTrace = 0
                case softwareTrace = 1
                case hardwareTrace = 2
                case fullTrace = 3
                public func toString() -> String {
                    switch self {
                    case .noTrace: return "NO_TRACE"
                    case .softwareTrace: return "SOFTWARE_TRACE"
                    case .hardwareTrace: return "HARDWARE_TRACE"
                    case .fullTrace: return "FULL_TRACE"
                    }
                }
                public static func fromString(str:String) throws -> Tensorflow.RunOptions.TraceLevel {
                    switch str {
                    case "NO_TRACE":    return .noTrace
                    case "SOFTWARE_TRACE":    return .softwareTrace
                    case "HARDWARE_TRACE":    return .hardwareTrace
                    case "FULL_TRACE":    return .fullTrace
                    default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
                    }
                }
                public var debugDescription:String { return getDescription() }
                public var description:String { return getDescription() }
                private func getDescription() -> String { 
                    switch self {
                    case .noTrace: return ".noTrace"
                    case .softwareTrace: return ".softwareTrace"
                    case .hardwareTrace: return ".hardwareTrace"
                    case .fullTrace: return ".fullTrace"
                    }
                }
                public var hashValue:Int {
                    return self.rawValue.hashValue
                }
                public static func ==(lhs:TraceLevel, rhs:TraceLevel) -> Bool {
                    return lhs.hashValue == rhs.hashValue
                }
            }

            //Enum type declaration end 

        public fileprivate(set) var traceLevel:Tensorflow.RunOptions.TraceLevel = Tensorflow.RunOptions.TraceLevel.noTrace
        public fileprivate(set) var hasTraceLevel:Bool = false
        /// Time to wait for operation to complete in milliseconds.
        public fileprivate(set) var timeoutInMs:Int64 = Int64(0)
        public fileprivate(set) var hasTimeoutInMs:Bool = false

        /// The thread pool to use, if session_inter_op_thread_pool is configured.
        public fileprivate(set) var interOpThreadPool:Int32 = Int32(0)
        public fileprivate(set) var hasInterOpThreadPool:Bool = false

        /// Whether the partition graph(s) executed by the executor(s) should be
        /// outputted via RunMetadata.
        public fileprivate(set) var outputPartitionGraphs:Bool = false
        public fileprivate(set) var hasOutputPartitionGraphs:Bool = false

        public fileprivate(set) var debugOptions:Tensorflow.DebugOptions!
        public fileprivate(set) var hasDebugOptions:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasTraceLevel {
                try codedOutputStream.writeEnum(fieldNumber: 1, value:traceLevel.rawValue)
            }
            if hasTimeoutInMs {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:timeoutInMs)
            }
            if hasInterOpThreadPool {
                try codedOutputStream.writeInt32(fieldNumber: 3, value:interOpThreadPool)
            }
            if hasOutputPartitionGraphs {
                try codedOutputStream.writeBool(fieldNumber: 5, value:outputPartitionGraphs)
            }
            if hasDebugOptions {
                try codedOutputStream.writeMessage(fieldNumber: 6, value:debugOptions)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if (hasTraceLevel) {
                serialize_size += traceLevel.rawValue.computeEnumSize(fieldNumber: 1)
            }
            if hasTimeoutInMs {
                serialize_size += timeoutInMs.computeInt64Size(fieldNumber: 2)
            }
            if hasInterOpThreadPool {
                serialize_size += interOpThreadPool.computeInt32Size(fieldNumber: 3)
            }
            if hasOutputPartitionGraphs {
                serialize_size += outputPartitionGraphs.computeBoolSize(fieldNumber: 5)
            }
            if hasDebugOptions {
                if let varSizedebugOptions = debugOptions?.computeMessageSize(fieldNumber: 6) {
                    serialize_size += varSizedebugOptions
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.RunOptions.Builder {
            return Tensorflow.RunOptions.classBuilder() as! Tensorflow.RunOptions.Builder
        }
        public func getBuilder() -> Tensorflow.RunOptions.Builder {
            return classBuilder() as! Tensorflow.RunOptions.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.RunOptions.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.RunOptions.Builder()
        }
        public func toBuilder() throws -> Tensorflow.RunOptions.Builder {
            return try Tensorflow.RunOptions.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.RunOptions) throws -> Tensorflow.RunOptions.Builder {
            return try Tensorflow.RunOptions.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasTraceLevel {
                jsonMap["traceLevel"] = traceLevel.toString()
            }
            if hasTimeoutInMs {
                jsonMap["timeoutInMs"] = "\(timeoutInMs)"
            }
            if hasInterOpThreadPool {
                jsonMap["interOpThreadPool"] = Int(interOpThreadPool)
            }
            if hasOutputPartitionGraphs {
                jsonMap["outputPartitionGraphs"] = outputPartitionGraphs
            }
            if hasDebugOptions {
                jsonMap["debugOptions"] = try debugOptions.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.RunOptions {
            return try Tensorflow.RunOptions.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.RunOptions {
            return try Tensorflow.RunOptions.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if (hasTraceLevel) {
                output += "\(indent) traceLevel: \(traceLevel.description)\n"
            }
            if hasTimeoutInMs {
                output += "\(indent) timeoutInMs: \(timeoutInMs) \n"
            }
            if hasInterOpThreadPool {
                output += "\(indent) interOpThreadPool: \(interOpThreadPool) \n"
            }
            if hasOutputPartitionGraphs {
                output += "\(indent) outputPartitionGraphs: \(outputPartitionGraphs) \n"
            }
            if hasDebugOptions {
                output += "\(indent) debugOptions {\n"
                if let outDescDebugOptions = debugOptions {
                    output += try outDescDebugOptions.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasTraceLevel {
                     hashCode = (hashCode &* 31) &+ traceLevel.hashValue
                }
                if hasTimeoutInMs {
                    hashCode = (hashCode &* 31) &+ timeoutInMs.hashValue
                }
                if hasInterOpThreadPool {
                    hashCode = (hashCode &* 31) &+ interOpThreadPool.hashValue
                }
                if hasOutputPartitionGraphs {
                    hashCode = (hashCode &* 31) &+ outputPartitionGraphs.hashValue
                }
                if hasDebugOptions {
                    if let hashValuedebugOptions = debugOptions?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuedebugOptions
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.RunOptions"
        }
        override public func className() -> String {
            return "Tensorflow.RunOptions"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.RunOptions = Tensorflow.RunOptions()
            public func getMessage() -> Tensorflow.RunOptions {
                return builderResult
            }

            required override public init () {
                super.init()
            }
                public var traceLevel:Tensorflow.RunOptions.TraceLevel {
                    get {
                        return builderResult.traceLevel
                    }
                    set (value) {
                        builderResult.hasTraceLevel = true
                        builderResult.traceLevel = value
                    }
                }
                public var hasTraceLevel:Bool{
                    get {
                        return builderResult.hasTraceLevel
                    }
                }
            @discardableResult
                public func setTraceLevel(_ value:Tensorflow.RunOptions.TraceLevel) -> Tensorflow.RunOptions.Builder {
                  self.traceLevel = value
                  return self
                }
            @discardableResult
                public func clearTraceLevel() -> Tensorflow.RunOptions.Builder {
                   builderResult.hasTraceLevel = false
                   builderResult.traceLevel = .noTrace
                   return self
                }
            /// Time to wait for operation to complete in milliseconds.
            public var timeoutInMs:Int64 {
                get {
                    return builderResult.timeoutInMs
                }
                set (value) {
                    builderResult.hasTimeoutInMs = true
                    builderResult.timeoutInMs = value
                }
            }
            public var hasTimeoutInMs:Bool {
                get {
                    return builderResult.hasTimeoutInMs
                }
            }
            @discardableResult
            public func setTimeoutInMs(_ value:Int64) -> Tensorflow.RunOptions.Builder {
                self.timeoutInMs = value
                return self
            }
            @discardableResult
            public func clearTimeoutInMs() -> Tensorflow.RunOptions.Builder{
                builderResult.hasTimeoutInMs = false
                builderResult.timeoutInMs = Int64(0)
                return self
            }
            /// The thread pool to use, if session_inter_op_thread_pool is configured.
            public var interOpThreadPool:Int32 {
                get {
                    return builderResult.interOpThreadPool
                }
                set (value) {
                    builderResult.hasInterOpThreadPool = true
                    builderResult.interOpThreadPool = value
                }
            }
            public var hasInterOpThreadPool:Bool {
                get {
                    return builderResult.hasInterOpThreadPool
                }
            }
            @discardableResult
            public func setInterOpThreadPool(_ value:Int32) -> Tensorflow.RunOptions.Builder {
                self.interOpThreadPool = value
                return self
            }
            @discardableResult
            public func clearInterOpThreadPool() -> Tensorflow.RunOptions.Builder{
                builderResult.hasInterOpThreadPool = false
                builderResult.interOpThreadPool = Int32(0)
                return self
            }
            /// Whether the partition graph(s) executed by the executor(s) should be
            /// outputted via RunMetadata.
            public var outputPartitionGraphs:Bool {
                get {
                    return builderResult.outputPartitionGraphs
                }
                set (value) {
                    builderResult.hasOutputPartitionGraphs = true
                    builderResult.outputPartitionGraphs = value
                }
            }
            public var hasOutputPartitionGraphs:Bool {
                get {
                    return builderResult.hasOutputPartitionGraphs
                }
            }
            @discardableResult
            public func setOutputPartitionGraphs(_ value:Bool) -> Tensorflow.RunOptions.Builder {
                self.outputPartitionGraphs = value
                return self
            }
            @discardableResult
            public func clearOutputPartitionGraphs() -> Tensorflow.RunOptions.Builder{
                builderResult.hasOutputPartitionGraphs = false
                builderResult.outputPartitionGraphs = false
                return self
            }
            /// EXPERIMENTAL.  Options used to initialize DebuggerState, if enabled.
            public var debugOptions:Tensorflow.DebugOptions! {
                get {
                    if debugOptionsBuilder_ != nil {
                        builderResult.debugOptions = debugOptionsBuilder_.getMessage()
                    }
                    return builderResult.debugOptions
                }
                set (value) {
                    builderResult.hasDebugOptions = true
                    builderResult.debugOptions = value
                }
            }
            public var hasDebugOptions:Bool {
                get {
                    return builderResult.hasDebugOptions
                }
            }
            fileprivate var debugOptionsBuilder_:Tensorflow.DebugOptions.Builder! {
                didSet {
                    builderResult.hasDebugOptions = true
                }
            }
            public func getDebugOptionsBuilder() -> Tensorflow.DebugOptions.Builder {
                if debugOptionsBuilder_ == nil {
                    debugOptionsBuilder_ = Tensorflow.DebugOptions.Builder()
                    builderResult.debugOptions = debugOptionsBuilder_.getMessage()
                    if debugOptions != nil {
                        try! debugOptionsBuilder_.mergeFrom(other: debugOptions)
                    }
                }
                return debugOptionsBuilder_
            }
            @discardableResult
            public func setDebugOptions(_ value:Tensorflow.DebugOptions!) -> Tensorflow.RunOptions.Builder {
                self.debugOptions = value
                return self
            }
            @discardableResult
            public func mergeDebugOptions(value:Tensorflow.DebugOptions) throws -> Tensorflow.RunOptions.Builder {
                if builderResult.hasDebugOptions {
                    builderResult.debugOptions = try Tensorflow.DebugOptions.builderWithPrototype(prototype:builderResult.debugOptions).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.debugOptions = value
                }
                builderResult.hasDebugOptions = true
                return self
            }
            @discardableResult
            public func clearDebugOptions() -> Tensorflow.RunOptions.Builder {
                debugOptionsBuilder_ = nil
                builderResult.hasDebugOptions = false
                builderResult.debugOptions = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.RunOptions.Builder {
                builderResult = Tensorflow.RunOptions()
                return self
            }
            override public func clone() throws -> Tensorflow.RunOptions.Builder {
                return try Tensorflow.RunOptions.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.RunOptions {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.RunOptions {
                let returnMe:Tensorflow.RunOptions = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.RunOptions) throws -> Tensorflow.RunOptions.Builder {
                if other == Tensorflow.RunOptions() {
                    return self
                }
                if other.hasTraceLevel {
                    traceLevel = other.traceLevel
                }
                if other.hasTimeoutInMs {
                    timeoutInMs = other.timeoutInMs
                }
                if other.hasInterOpThreadPool {
                    interOpThreadPool = other.interOpThreadPool
                }
                if other.hasOutputPartitionGraphs {
                    outputPartitionGraphs = other.outputPartitionGraphs
                }
                if (other.hasDebugOptions) {
                    try mergeDebugOptions(value: other.debugOptions)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.RunOptions.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RunOptions.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        let valueInttraceLevel = try codedInputStream.readEnum()
                        if let enumstraceLevel = Tensorflow.RunOptions.TraceLevel(rawValue:valueInttraceLevel){
                            traceLevel = enumstraceLevel
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueInttraceLevel))
                        }

                    case 16:
                        timeoutInMs = try codedInputStream.readInt64()

                    case 24:
                        interOpThreadPool = try codedInputStream.readInt32()

                    case 40:
                        outputPartitionGraphs = try codedInputStream.readBool()

                    case 50:
                        let subBuilder:Tensorflow.DebugOptions.Builder = Tensorflow.DebugOptions.Builder()
                        if hasDebugOptions {
                            try subBuilder.mergeFrom(other: debugOptions)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        debugOptions = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.RunOptions.Builder {
                let resultDecodedBuilder = Tensorflow.RunOptions.Builder()
                if let jsonValueTraceLevel = jsonMap["traceLevel"] as? String {
                    resultDecodedBuilder.traceLevel = try Tensorflow.RunOptions.TraceLevel.fromString(str: jsonValueTraceLevel)
                }
                if let jsonValueTimeoutInMs = jsonMap["timeoutInMs"] as? String {
                    resultDecodedBuilder.timeoutInMs = Int64(jsonValueTimeoutInMs)!
                } else if let jsonValueTimeoutInMs = jsonMap["timeoutInMs"] as? Int {
                    resultDecodedBuilder.timeoutInMs = Int64(jsonValueTimeoutInMs)
                }
                if let jsonValueInterOpThreadPool = jsonMap["interOpThreadPool"] as? Int {
                    resultDecodedBuilder.interOpThreadPool = Int32(jsonValueInterOpThreadPool)
                } else if let jsonValueInterOpThreadPool = jsonMap["interOpThreadPool"] as? String {
                    resultDecodedBuilder.interOpThreadPool = Int32(jsonValueInterOpThreadPool)!
                }
                if let jsonValueOutputPartitionGraphs = jsonMap["outputPartitionGraphs"] as? Bool {
                    resultDecodedBuilder.outputPartitionGraphs = jsonValueOutputPartitionGraphs
                }
                if let jsonValueDebugOptions = jsonMap["debugOptions"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.debugOptions = try Tensorflow.DebugOptions.Builder.decodeToBuilder(jsonMap:jsonValueDebugOptions).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.RunOptions.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.RunOptions.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Metadata output (i.e., non-Tensor) for a single Run() call.
    final public class RunMetadata : GeneratedMessage {

        public static func == (lhs: Tensorflow.RunMetadata, rhs: Tensorflow.RunMetadata) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasStepStats == rhs.hasStepStats) && (!lhs.hasStepStats || lhs.stepStats == rhs.stepStats)
            fieldCheck = fieldCheck && (lhs.hasCostGraph == rhs.hasCostGraph) && (!lhs.hasCostGraph || lhs.costGraph == rhs.costGraph)
            fieldCheck = fieldCheck && (lhs.partitionGraphs == rhs.partitionGraphs)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var stepStats:Tensorflow.StepStats!
        public fileprivate(set) var hasStepStats:Bool = false
        public fileprivate(set) var costGraph:Tensorflow.CostGraphDef!
        public fileprivate(set) var hasCostGraph:Bool = false
        public fileprivate(set) var partitionGraphs:Array<Tensorflow.GraphDef>  = Array<Tensorflow.GraphDef>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasStepStats {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:stepStats)
            }
            if hasCostGraph {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:costGraph)
            }
            for oneElementPartitionGraphs in partitionGraphs {
                  try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementPartitionGraphs)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasStepStats {
                if let varSizestepStats = stepStats?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizestepStats
                }
            }
            if hasCostGraph {
                if let varSizecostGraph = costGraph?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizecostGraph
                }
            }
            for oneElementPartitionGraphs in partitionGraphs {
                serialize_size += oneElementPartitionGraphs.computeMessageSize(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.RunMetadata.Builder {
            return Tensorflow.RunMetadata.classBuilder() as! Tensorflow.RunMetadata.Builder
        }
        public func getBuilder() -> Tensorflow.RunMetadata.Builder {
            return classBuilder() as! Tensorflow.RunMetadata.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.RunMetadata.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.RunMetadata.Builder()
        }
        public func toBuilder() throws -> Tensorflow.RunMetadata.Builder {
            return try Tensorflow.RunMetadata.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.RunMetadata) throws -> Tensorflow.RunMetadata.Builder {
            return try Tensorflow.RunMetadata.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasStepStats {
                jsonMap["stepStats"] = try stepStats.encode()
            }
            if hasCostGraph {
                jsonMap["costGraph"] = try costGraph.encode()
            }
            if !partitionGraphs.isEmpty {
                var jsonArrayPartitionGraphs:Array<Dictionary<String,Any>> = []
                for oneValuePartitionGraphs in partitionGraphs {
                    let ecodedMessagePartitionGraphs = try oneValuePartitionGraphs.encode()
                    jsonArrayPartitionGraphs.append(ecodedMessagePartitionGraphs)
                }
                jsonMap["partitionGraphs"] = jsonArrayPartitionGraphs
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.RunMetadata {
            return try Tensorflow.RunMetadata.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.RunMetadata {
            return try Tensorflow.RunMetadata.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasStepStats {
                output += "\(indent) stepStats {\n"
                if let outDescStepStats = stepStats {
                    output += try outDescStepStats.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasCostGraph {
                output += "\(indent) costGraph {\n"
                if let outDescCostGraph = costGraph {
                    output += try outDescCostGraph.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            var partitionGraphsElementIndex:Int = 0
            for oneElementPartitionGraphs in partitionGraphs {
                output += "\(indent) partitionGraphs[\(partitionGraphsElementIndex)] {\n"
                output += try oneElementPartitionGraphs.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                partitionGraphsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasStepStats {
                    if let hashValuestepStats = stepStats?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuestepStats
                    }
                }
                if hasCostGraph {
                    if let hashValuecostGraph = costGraph?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecostGraph
                    }
                }
                for oneElementPartitionGraphs in partitionGraphs {
                    hashCode = (hashCode &* 31) &+ oneElementPartitionGraphs.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.RunMetadata"
        }
        override public func className() -> String {
            return "Tensorflow.RunMetadata"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.RunMetadata = Tensorflow.RunMetadata()
            public func getMessage() -> Tensorflow.RunMetadata {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Statistics traced for this step. Populated if tracing is turned on via the
            /// "RunOptions" proto.
            /// EXPERIMENTAL: The format and set of events may change in future versions.
            public var stepStats:Tensorflow.StepStats! {
                get {
                    if stepStatsBuilder_ != nil {
                        builderResult.stepStats = stepStatsBuilder_.getMessage()
                    }
                    return builderResult.stepStats
                }
                set (value) {
                    builderResult.hasStepStats = true
                    builderResult.stepStats = value
                }
            }
            public var hasStepStats:Bool {
                get {
                    return builderResult.hasStepStats
                }
            }
            fileprivate var stepStatsBuilder_:Tensorflow.StepStats.Builder! {
                didSet {
                    builderResult.hasStepStats = true
                }
            }
            public func getStepStatsBuilder() -> Tensorflow.StepStats.Builder {
                if stepStatsBuilder_ == nil {
                    stepStatsBuilder_ = Tensorflow.StepStats.Builder()
                    builderResult.stepStats = stepStatsBuilder_.getMessage()
                    if stepStats != nil {
                        try! stepStatsBuilder_.mergeFrom(other: stepStats)
                    }
                }
                return stepStatsBuilder_
            }
            @discardableResult
            public func setStepStats(_ value:Tensorflow.StepStats!) -> Tensorflow.RunMetadata.Builder {
                self.stepStats = value
                return self
            }
            @discardableResult
            public func mergeStepStats(value:Tensorflow.StepStats) throws -> Tensorflow.RunMetadata.Builder {
                if builderResult.hasStepStats {
                    builderResult.stepStats = try Tensorflow.StepStats.builderWithPrototype(prototype:builderResult.stepStats).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.stepStats = value
                }
                builderResult.hasStepStats = true
                return self
            }
            @discardableResult
            public func clearStepStats() -> Tensorflow.RunMetadata.Builder {
                stepStatsBuilder_ = nil
                builderResult.hasStepStats = false
                builderResult.stepStats = nil
                return self
            }
            /// The cost graph for the computation defined by the run call.
            public var costGraph:Tensorflow.CostGraphDef! {
                get {
                    if costGraphBuilder_ != nil {
                        builderResult.costGraph = costGraphBuilder_.getMessage()
                    }
                    return builderResult.costGraph
                }
                set (value) {
                    builderResult.hasCostGraph = true
                    builderResult.costGraph = value
                }
            }
            public var hasCostGraph:Bool {
                get {
                    return builderResult.hasCostGraph
                }
            }
            fileprivate var costGraphBuilder_:Tensorflow.CostGraphDef.Builder! {
                didSet {
                    builderResult.hasCostGraph = true
                }
            }
            public func getCostGraphBuilder() -> Tensorflow.CostGraphDef.Builder {
                if costGraphBuilder_ == nil {
                    costGraphBuilder_ = Tensorflow.CostGraphDef.Builder()
                    builderResult.costGraph = costGraphBuilder_.getMessage()
                    if costGraph != nil {
                        try! costGraphBuilder_.mergeFrom(other: costGraph)
                    }
                }
                return costGraphBuilder_
            }
            @discardableResult
            public func setCostGraph(_ value:Tensorflow.CostGraphDef!) -> Tensorflow.RunMetadata.Builder {
                self.costGraph = value
                return self
            }
            @discardableResult
            public func mergeCostGraph(value:Tensorflow.CostGraphDef) throws -> Tensorflow.RunMetadata.Builder {
                if builderResult.hasCostGraph {
                    builderResult.costGraph = try Tensorflow.CostGraphDef.builderWithPrototype(prototype:builderResult.costGraph).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.costGraph = value
                }
                builderResult.hasCostGraph = true
                return self
            }
            @discardableResult
            public func clearCostGraph() -> Tensorflow.RunMetadata.Builder {
                costGraphBuilder_ = nil
                builderResult.hasCostGraph = false
                builderResult.costGraph = nil
                return self
            }
            /// Graphs of the partitions executed by executors.
            public var partitionGraphs:Array<Tensorflow.GraphDef> {
                get {
                    return builderResult.partitionGraphs
                }
                set (value) {
                    builderResult.partitionGraphs = value
                }
            }
            @discardableResult
            public func setPartitionGraphs(_ value:Array<Tensorflow.GraphDef>) -> Tensorflow.RunMetadata.Builder {
                self.partitionGraphs = value
                return self
            }
            @discardableResult
            public func clearPartitionGraphs() -> Tensorflow.RunMetadata.Builder {
                builderResult.partitionGraphs.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.RunMetadata.Builder {
                builderResult = Tensorflow.RunMetadata()
                return self
            }
            override public func clone() throws -> Tensorflow.RunMetadata.Builder {
                return try Tensorflow.RunMetadata.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.RunMetadata {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.RunMetadata {
                let returnMe:Tensorflow.RunMetadata = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.RunMetadata) throws -> Tensorflow.RunMetadata.Builder {
                if other == Tensorflow.RunMetadata() {
                    return self
                }
                if (other.hasStepStats) {
                    try mergeStepStats(value: other.stepStats)
                }
                if (other.hasCostGraph) {
                    try mergeCostGraph(value: other.costGraph)
                }
                if !other.partitionGraphs.isEmpty  {
                     builderResult.partitionGraphs += other.partitionGraphs
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.RunMetadata.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RunMetadata.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Tensorflow.StepStats.Builder = Tensorflow.StepStats.Builder()
                        if hasStepStats {
                            try subBuilder.mergeFrom(other: stepStats)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        stepStats = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Tensorflow.CostGraphDef.Builder = Tensorflow.CostGraphDef.Builder()
                        if hasCostGraph {
                            try subBuilder.mergeFrom(other: costGraph)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        costGraph = subBuilder.buildPartial()

                    case 26:
                        let subBuilder = Tensorflow.GraphDef.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        partitionGraphs.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.RunMetadata.Builder {
                let resultDecodedBuilder = Tensorflow.RunMetadata.Builder()
                if let jsonValueStepStats = jsonMap["stepStats"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.stepStats = try Tensorflow.StepStats.Builder.decodeToBuilder(jsonMap:jsonValueStepStats).build()

                }
                if let jsonValueCostGraph = jsonMap["costGraph"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.costGraph = try Tensorflow.CostGraphDef.Builder.decodeToBuilder(jsonMap:jsonValueCostGraph).build()

                }
                if let jsonValuePartitionGraphs = jsonMap["partitionGraphs"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayPartitionGraphs:Array<Tensorflow.GraphDef> = []
                    for oneValuePartitionGraphs in jsonValuePartitionGraphs {
                        let messageFromStringPartitionGraphs = try Tensorflow.GraphDef.Builder.decodeToBuilder(jsonMap:oneValuePartitionGraphs).build()

                        jsonArrayPartitionGraphs.append(messageFromStringPartitionGraphs)
                    }
                    resultDecodedBuilder.partitionGraphs = jsonArrayPartitionGraphs
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.RunMetadata.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.RunMetadata.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.Gpuoptions: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Gpuoptions> {
        var mergedArray = Array<Tensorflow.Gpuoptions>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Gpuoptions? {
        return try Tensorflow.Gpuoptions.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Gpuoptions {
        return try Tensorflow.Gpuoptions.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.ConfigRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Gpuoptions {
        return try Tensorflow.Gpuoptions.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Gpuoptions {
        return try Tensorflow.Gpuoptions.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Gpuoptions {
        return try Tensorflow.Gpuoptions.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Gpuoptions {
        return try Tensorflow.Gpuoptions.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Gpuoptions {
        return try Tensorflow.Gpuoptions.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "perProcessGpuMemoryFraction": return self.perProcessGpuMemoryFraction
        case "allocatorType": return self.allocatorType
        case "deferredDeletionBytes": return self.deferredDeletionBytes
        case "allowGrowth": return self.allowGrowth
        case "visibleDeviceList": return self.visibleDeviceList
        case "pollingActiveDelayUsecs": return self.pollingActiveDelayUsecs
        case "pollingInactiveDelayMsecs": return self.pollingInactiveDelayMsecs
        case "forceGpuCompatible": return self.forceGpuCompatible
        default: return nil
        }
    }
}
extension Tensorflow.Gpuoptions.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "perProcessGpuMemoryFraction": return self.perProcessGpuMemoryFraction
            case "allocatorType": return self.allocatorType
            case "deferredDeletionBytes": return self.deferredDeletionBytes
            case "allowGrowth": return self.allowGrowth
            case "visibleDeviceList": return self.visibleDeviceList
            case "pollingActiveDelayUsecs": return self.pollingActiveDelayUsecs
            case "pollingInactiveDelayMsecs": return self.pollingInactiveDelayMsecs
            case "forceGpuCompatible": return self.forceGpuCompatible
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "perProcessGpuMemoryFraction":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.perProcessGpuMemoryFraction = newSubscriptValue
            case "allocatorType":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.allocatorType = newSubscriptValue
            case "deferredDeletionBytes":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.deferredDeletionBytes = newSubscriptValue
            case "allowGrowth":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.allowGrowth = newSubscriptValue
            case "visibleDeviceList":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.visibleDeviceList = newSubscriptValue
            case "pollingActiveDelayUsecs":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.pollingActiveDelayUsecs = newSubscriptValue
            case "pollingInactiveDelayMsecs":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.pollingInactiveDelayMsecs = newSubscriptValue
            case "forceGpuCompatible":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.forceGpuCompatible = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.OptimizerOptions: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.OptimizerOptions> {
        var mergedArray = Array<Tensorflow.OptimizerOptions>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.OptimizerOptions? {
        return try Tensorflow.OptimizerOptions.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.OptimizerOptions {
        return try Tensorflow.OptimizerOptions.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.ConfigRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OptimizerOptions {
        return try Tensorflow.OptimizerOptions.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.OptimizerOptions {
        return try Tensorflow.OptimizerOptions.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OptimizerOptions {
        return try Tensorflow.OptimizerOptions.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OptimizerOptions {
        return try Tensorflow.OptimizerOptions.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OptimizerOptions {
        return try Tensorflow.OptimizerOptions.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "doCommonSubexpressionElimination": return self.doCommonSubexpressionElimination
        case "doConstantFolding": return self.doConstantFolding
        case "doFunctionInlining": return self.doFunctionInlining
        case "optLevel": return self.optLevel
        case "globalJitLevel": return self.globalJitLevel
        default: return nil
        }
    }
}
extension Tensorflow.OptimizerOptions.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "doCommonSubexpressionElimination": return self.doCommonSubexpressionElimination
            case "doConstantFolding": return self.doConstantFolding
            case "doFunctionInlining": return self.doFunctionInlining
            case "optLevel": return self.optLevel
            case "globalJitLevel": return self.globalJitLevel
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "doCommonSubexpressionElimination":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.doCommonSubexpressionElimination = newSubscriptValue
            case "doConstantFolding":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.doConstantFolding = newSubscriptValue
            case "doFunctionInlining":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.doFunctionInlining = newSubscriptValue
            case "optLevel":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.OptimizerOptions.Level else {
                    return
                }
                self.optLevel = newSubscriptValue
            case "globalJitLevel":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.OptimizerOptions.GlobalJitLevel else {
                    return
                }
                self.globalJitLevel = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.GraphOptions: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.GraphOptions> {
        var mergedArray = Array<Tensorflow.GraphOptions>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.GraphOptions? {
        return try Tensorflow.GraphOptions.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.GraphOptions {
        return try Tensorflow.GraphOptions.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.ConfigRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphOptions {
        return try Tensorflow.GraphOptions.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.GraphOptions {
        return try Tensorflow.GraphOptions.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphOptions {
        return try Tensorflow.GraphOptions.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.GraphOptions {
        return try Tensorflow.GraphOptions.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphOptions {
        return try Tensorflow.GraphOptions.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "enableRecvScheduling": return self.enableRecvScheduling
        case "optimizerOptions": return self.optimizerOptions
        case "buildCostModel": return self.buildCostModel
        case "buildCostModelAfter": return self.buildCostModelAfter
        case "inferShapes": return self.inferShapes
        case "placePrunedGraph": return self.placePrunedGraph
        case "enableBfloat16Sendrecv": return self.enableBfloat16Sendrecv
        case "timelineStep": return self.timelineStep
        case "rewriteOptions": return self.rewriteOptions
        default: return nil
        }
    }
}
extension Tensorflow.GraphOptions.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "enableRecvScheduling": return self.enableRecvScheduling
            case "optimizerOptions": return self.optimizerOptions
            case "buildCostModel": return self.buildCostModel
            case "buildCostModelAfter": return self.buildCostModelAfter
            case "inferShapes": return self.inferShapes
            case "placePrunedGraph": return self.placePrunedGraph
            case "enableBfloat16Sendrecv": return self.enableBfloat16Sendrecv
            case "timelineStep": return self.timelineStep
            case "rewriteOptions": return self.rewriteOptions
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "enableRecvScheduling":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.enableRecvScheduling = newSubscriptValue
            case "optimizerOptions":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.OptimizerOptions else {
                    return
                }
                self.optimizerOptions = newSubscriptValue
            case "buildCostModel":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.buildCostModel = newSubscriptValue
            case "buildCostModelAfter":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.buildCostModelAfter = newSubscriptValue
            case "inferShapes":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.inferShapes = newSubscriptValue
            case "placePrunedGraph":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.placePrunedGraph = newSubscriptValue
            case "enableBfloat16Sendrecv":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.enableBfloat16Sendrecv = newSubscriptValue
            case "timelineStep":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.timelineStep = newSubscriptValue
            case "rewriteOptions":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.RewriterConfig else {
                    return
                }
                self.rewriteOptions = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.ThreadPoolOptionProto: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.ThreadPoolOptionProto> {
        var mergedArray = Array<Tensorflow.ThreadPoolOptionProto>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.ThreadPoolOptionProto? {
        return try Tensorflow.ThreadPoolOptionProto.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.ThreadPoolOptionProto {
        return try Tensorflow.ThreadPoolOptionProto.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.ConfigRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ThreadPoolOptionProto {
        return try Tensorflow.ThreadPoolOptionProto.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.ThreadPoolOptionProto {
        return try Tensorflow.ThreadPoolOptionProto.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ThreadPoolOptionProto {
        return try Tensorflow.ThreadPoolOptionProto.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.ThreadPoolOptionProto {
        return try Tensorflow.ThreadPoolOptionProto.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ThreadPoolOptionProto {
        return try Tensorflow.ThreadPoolOptionProto.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "numThreads": return self.numThreads
        default: return nil
        }
    }
}
extension Tensorflow.ThreadPoolOptionProto.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "numThreads": return self.numThreads
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "numThreads":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.numThreads = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Rpcoptions: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Rpcoptions> {
        var mergedArray = Array<Tensorflow.Rpcoptions>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Rpcoptions? {
        return try Tensorflow.Rpcoptions.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Rpcoptions {
        return try Tensorflow.Rpcoptions.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.ConfigRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Rpcoptions {
        return try Tensorflow.Rpcoptions.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Rpcoptions {
        return try Tensorflow.Rpcoptions.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Rpcoptions {
        return try Tensorflow.Rpcoptions.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Rpcoptions {
        return try Tensorflow.Rpcoptions.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Rpcoptions {
        return try Tensorflow.Rpcoptions.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "useRpcForInprocessMaster": return self.useRpcForInprocessMaster
        default: return nil
        }
    }
}
extension Tensorflow.Rpcoptions.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "useRpcForInprocessMaster": return self.useRpcForInprocessMaster
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "useRpcForInprocessMaster":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.useRpcForInprocessMaster = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.ConfigProto: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.ConfigProto> {
        var mergedArray = Array<Tensorflow.ConfigProto>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.ConfigProto? {
        return try Tensorflow.ConfigProto.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.ConfigProto {
        return try Tensorflow.ConfigProto.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.ConfigRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ConfigProto {
        return try Tensorflow.ConfigProto.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.ConfigProto {
        return try Tensorflow.ConfigProto.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ConfigProto {
        return try Tensorflow.ConfigProto.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.ConfigProto {
        return try Tensorflow.ConfigProto.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ConfigProto {
        return try Tensorflow.ConfigProto.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "deviceCount": return self.deviceCount
        case "intraOpParallelismThreads": return self.intraOpParallelismThreads
        case "interOpParallelismThreads": return self.interOpParallelismThreads
        case "usePerSessionThreads": return self.usePerSessionThreads
        case "sessionInterOpThreadPool": return self.sessionInterOpThreadPool
        case "placementPeriod": return self.placementPeriod
        case "deviceFilters": return self.deviceFilters
        case "gpuOptions": return self.gpuOptions
        case "allowSoftPlacement": return self.allowSoftPlacement
        case "logDevicePlacement": return self.logDevicePlacement
        case "graphOptions": return self.graphOptions
        case "operationTimeoutInMs": return self.operationTimeoutInMs
        case "rpcOptions": return self.rpcOptions
        default: return nil
        }
    }
}
extension Tensorflow.ConfigProto.DeviceCountEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.ConfigProto.DeviceCountEntry> {
        var mergedArray = Array<Tensorflow.ConfigProto.DeviceCountEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.ConfigProto.DeviceCountEntry? {
        return try Tensorflow.ConfigProto.DeviceCountEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.ConfigProto.DeviceCountEntry {
        return try Tensorflow.ConfigProto.DeviceCountEntry.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.ConfigRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ConfigProto.DeviceCountEntry {
        return try Tensorflow.ConfigProto.DeviceCountEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.ConfigProto.DeviceCountEntry {
        return try Tensorflow.ConfigProto.DeviceCountEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ConfigProto.DeviceCountEntry {
        return try Tensorflow.ConfigProto.DeviceCountEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.ConfigProto.DeviceCountEntry {
        return try Tensorflow.ConfigProto.DeviceCountEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ConfigProto.DeviceCountEntry {
        return try Tensorflow.ConfigProto.DeviceCountEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.ConfigProto.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "deviceCount": return self.deviceCount
            case "intraOpParallelismThreads": return self.intraOpParallelismThreads
            case "interOpParallelismThreads": return self.interOpParallelismThreads
            case "usePerSessionThreads": return self.usePerSessionThreads
            case "sessionInterOpThreadPool": return self.sessionInterOpThreadPool
            case "placementPeriod": return self.placementPeriod
            case "deviceFilters": return self.deviceFilters
            case "gpuOptions": return self.gpuOptions
            case "allowSoftPlacement": return self.allowSoftPlacement
            case "logDevicePlacement": return self.logDevicePlacement
            case "graphOptions": return self.graphOptions
            case "operationTimeoutInMs": return self.operationTimeoutInMs
            case "rpcOptions": return self.rpcOptions
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "deviceCount":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,Int32> else {
                    return
                }
                self.deviceCount = newSubscriptValue
            case "intraOpParallelismThreads":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.intraOpParallelismThreads = newSubscriptValue
            case "interOpParallelismThreads":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.interOpParallelismThreads = newSubscriptValue
            case "usePerSessionThreads":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.usePerSessionThreads = newSubscriptValue
            case "sessionInterOpThreadPool":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.ThreadPoolOptionProto> else {
                    return
                }
                self.sessionInterOpThreadPool = newSubscriptValue
            case "placementPeriod":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.placementPeriod = newSubscriptValue
            case "deviceFilters":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.deviceFilters = newSubscriptValue
            case "gpuOptions":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Gpuoptions else {
                    return
                }
                self.gpuOptions = newSubscriptValue
            case "allowSoftPlacement":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.allowSoftPlacement = newSubscriptValue
            case "logDevicePlacement":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.logDevicePlacement = newSubscriptValue
            case "graphOptions":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.GraphOptions else {
                    return
                }
                self.graphOptions = newSubscriptValue
            case "operationTimeoutInMs":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.operationTimeoutInMs = newSubscriptValue
            case "rpcOptions":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Rpcoptions else {
                    return
                }
                self.rpcOptions = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.ConfigProto.DeviceCountEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.RunOptions: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.RunOptions> {
        var mergedArray = Array<Tensorflow.RunOptions>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.RunOptions? {
        return try Tensorflow.RunOptions.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.RunOptions {
        return try Tensorflow.RunOptions.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.ConfigRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RunOptions {
        return try Tensorflow.RunOptions.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.RunOptions {
        return try Tensorflow.RunOptions.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RunOptions {
        return try Tensorflow.RunOptions.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.RunOptions {
        return try Tensorflow.RunOptions.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RunOptions {
        return try Tensorflow.RunOptions.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "traceLevel": return self.traceLevel
        case "timeoutInMs": return self.timeoutInMs
        case "interOpThreadPool": return self.interOpThreadPool
        case "outputPartitionGraphs": return self.outputPartitionGraphs
        case "debugOptions": return self.debugOptions
        default: return nil
        }
    }
}
extension Tensorflow.RunOptions.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "traceLevel": return self.traceLevel
            case "timeoutInMs": return self.timeoutInMs
            case "interOpThreadPool": return self.interOpThreadPool
            case "outputPartitionGraphs": return self.outputPartitionGraphs
            case "debugOptions": return self.debugOptions
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "traceLevel":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.RunOptions.TraceLevel else {
                    return
                }
                self.traceLevel = newSubscriptValue
            case "timeoutInMs":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.timeoutInMs = newSubscriptValue
            case "interOpThreadPool":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.interOpThreadPool = newSubscriptValue
            case "outputPartitionGraphs":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.outputPartitionGraphs = newSubscriptValue
            case "debugOptions":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.DebugOptions else {
                    return
                }
                self.debugOptions = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.RunMetadata: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.RunMetadata> {
        var mergedArray = Array<Tensorflow.RunMetadata>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.RunMetadata? {
        return try Tensorflow.RunMetadata.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.RunMetadata {
        return try Tensorflow.RunMetadata.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.ConfigRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RunMetadata {
        return try Tensorflow.RunMetadata.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.RunMetadata {
        return try Tensorflow.RunMetadata.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RunMetadata {
        return try Tensorflow.RunMetadata.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.RunMetadata {
        return try Tensorflow.RunMetadata.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RunMetadata {
        return try Tensorflow.RunMetadata.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "stepStats": return self.stepStats
        case "costGraph": return self.costGraph
        case "partitionGraphs": return self.partitionGraphs
        default: return nil
        }
    }
}
extension Tensorflow.RunMetadata.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "stepStats": return self.stepStats
            case "costGraph": return self.costGraph
            case "partitionGraphs": return self.partitionGraphs
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "stepStats":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.StepStats else {
                    return
                }
                self.stepStats = newSubscriptValue
            case "costGraph":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.CostGraphDef else {
                    return
                }
                self.costGraph = newSubscriptValue
            case "partitionGraphs":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.GraphDef> else {
                    return
                }
                self.partitionGraphs = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

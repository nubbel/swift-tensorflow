/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "variable.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { }

public extension Tensorflow {
    public struct VariableRoot {
        public static let `default` = VariableRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    /// Protocol buffer representing a Variable.
    final public class VariableDef : GeneratedMessage {

        public static func == (lhs: Tensorflow.VariableDef, rhs: Tensorflow.VariableDef) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasVariableName == rhs.hasVariableName) && (!lhs.hasVariableName || lhs.variableName == rhs.variableName)
            fieldCheck = fieldCheck && (lhs.hasInitializerName == rhs.hasInitializerName) && (!lhs.hasInitializerName || lhs.initializerName == rhs.initializerName)
            fieldCheck = fieldCheck && (lhs.hasSnapshotName == rhs.hasSnapshotName) && (!lhs.hasSnapshotName || lhs.snapshotName == rhs.snapshotName)
            fieldCheck = fieldCheck && (lhs.hasSaveSliceInfoDef == rhs.hasSaveSliceInfoDef) && (!lhs.hasSaveSliceInfoDef || lhs.saveSliceInfoDef == rhs.saveSliceInfoDef)
            fieldCheck = fieldCheck && (lhs.hasIsResource == rhs.hasIsResource) && (!lhs.hasIsResource || lhs.isResource == rhs.isResource)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Name of the variable tensor.
        public fileprivate(set) var variableName:String = ""
        public fileprivate(set) var hasVariableName:Bool = false

        /// Name of the initializer op.
        public fileprivate(set) var initializerName:String = ""
        public fileprivate(set) var hasInitializerName:Bool = false

        /// Name of the snapshot tensor.
        public fileprivate(set) var snapshotName:String = ""
        public fileprivate(set) var hasSnapshotName:Bool = false

        public fileprivate(set) var saveSliceInfoDef:Tensorflow.SaveSliceInfoDef!
        public fileprivate(set) var hasSaveSliceInfoDef:Bool = false
        /// Whether to represent this as a ResourceVariable.
        public fileprivate(set) var isResource:Bool = false
        public fileprivate(set) var hasIsResource:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasVariableName {
                try codedOutputStream.writeString(fieldNumber: 1, value:variableName)
            }
            if hasInitializerName {
                try codedOutputStream.writeString(fieldNumber: 2, value:initializerName)
            }
            if hasSnapshotName {
                try codedOutputStream.writeString(fieldNumber: 3, value:snapshotName)
            }
            if hasSaveSliceInfoDef {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:saveSliceInfoDef)
            }
            if hasIsResource {
                try codedOutputStream.writeBool(fieldNumber: 5, value:isResource)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasVariableName {
                serialize_size += variableName.computeStringSize(fieldNumber: 1)
            }
            if hasInitializerName {
                serialize_size += initializerName.computeStringSize(fieldNumber: 2)
            }
            if hasSnapshotName {
                serialize_size += snapshotName.computeStringSize(fieldNumber: 3)
            }
            if hasSaveSliceInfoDef {
                if let varSizesaveSliceInfoDef = saveSliceInfoDef?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizesaveSliceInfoDef
                }
            }
            if hasIsResource {
                serialize_size += isResource.computeBoolSize(fieldNumber: 5)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.VariableDef.Builder {
            return Tensorflow.VariableDef.classBuilder() as! Tensorflow.VariableDef.Builder
        }
        public func getBuilder() -> Tensorflow.VariableDef.Builder {
            return classBuilder() as! Tensorflow.VariableDef.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.VariableDef.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.VariableDef.Builder()
        }
        public func toBuilder() throws -> Tensorflow.VariableDef.Builder {
            return try Tensorflow.VariableDef.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.VariableDef) throws -> Tensorflow.VariableDef.Builder {
            return try Tensorflow.VariableDef.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasVariableName {
                jsonMap["variableName"] = variableName
            }
            if hasInitializerName {
                jsonMap["initializerName"] = initializerName
            }
            if hasSnapshotName {
                jsonMap["snapshotName"] = snapshotName
            }
            if hasSaveSliceInfoDef {
                jsonMap["saveSliceInfoDef"] = try saveSliceInfoDef.encode()
            }
            if hasIsResource {
                jsonMap["isResource"] = isResource
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.VariableDef {
            return try Tensorflow.VariableDef.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.VariableDef {
            return try Tensorflow.VariableDef.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasVariableName {
                output += "\(indent) variableName: \(variableName) \n"
            }
            if hasInitializerName {
                output += "\(indent) initializerName: \(initializerName) \n"
            }
            if hasSnapshotName {
                output += "\(indent) snapshotName: \(snapshotName) \n"
            }
            if hasSaveSliceInfoDef {
                output += "\(indent) saveSliceInfoDef {\n"
                if let outDescSaveSliceInfoDef = saveSliceInfoDef {
                    output += try outDescSaveSliceInfoDef.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasIsResource {
                output += "\(indent) isResource: \(isResource) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasVariableName {
                    hashCode = (hashCode &* 31) &+ variableName.hashValue
                }
                if hasInitializerName {
                    hashCode = (hashCode &* 31) &+ initializerName.hashValue
                }
                if hasSnapshotName {
                    hashCode = (hashCode &* 31) &+ snapshotName.hashValue
                }
                if hasSaveSliceInfoDef {
                    if let hashValuesaveSliceInfoDef = saveSliceInfoDef?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuesaveSliceInfoDef
                    }
                }
                if hasIsResource {
                    hashCode = (hashCode &* 31) &+ isResource.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.VariableDef"
        }
        override public func className() -> String {
            return "Tensorflow.VariableDef"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.VariableDef = Tensorflow.VariableDef()
            public func getMessage() -> Tensorflow.VariableDef {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Name of the variable tensor.
            public var variableName:String {
                get {
                    return builderResult.variableName
                }
                set (value) {
                    builderResult.hasVariableName = true
                    builderResult.variableName = value
                }
            }
            public var hasVariableName:Bool {
                get {
                    return builderResult.hasVariableName
                }
            }
            @discardableResult
            public func setVariableName(_ value:String) -> Tensorflow.VariableDef.Builder {
                self.variableName = value
                return self
            }
            @discardableResult
            public func clearVariableName() -> Tensorflow.VariableDef.Builder{
                builderResult.hasVariableName = false
                builderResult.variableName = ""
                return self
            }
            /// Name of the initializer op.
            public var initializerName:String {
                get {
                    return builderResult.initializerName
                }
                set (value) {
                    builderResult.hasInitializerName = true
                    builderResult.initializerName = value
                }
            }
            public var hasInitializerName:Bool {
                get {
                    return builderResult.hasInitializerName
                }
            }
            @discardableResult
            public func setInitializerName(_ value:String) -> Tensorflow.VariableDef.Builder {
                self.initializerName = value
                return self
            }
            @discardableResult
            public func clearInitializerName() -> Tensorflow.VariableDef.Builder{
                builderResult.hasInitializerName = false
                builderResult.initializerName = ""
                return self
            }
            /// Name of the snapshot tensor.
            public var snapshotName:String {
                get {
                    return builderResult.snapshotName
                }
                set (value) {
                    builderResult.hasSnapshotName = true
                    builderResult.snapshotName = value
                }
            }
            public var hasSnapshotName:Bool {
                get {
                    return builderResult.hasSnapshotName
                }
            }
            @discardableResult
            public func setSnapshotName(_ value:String) -> Tensorflow.VariableDef.Builder {
                self.snapshotName = value
                return self
            }
            @discardableResult
            public func clearSnapshotName() -> Tensorflow.VariableDef.Builder{
                builderResult.hasSnapshotName = false
                builderResult.snapshotName = ""
                return self
            }
            /// Support for saving variables as slices of a larger variable.
            public var saveSliceInfoDef:Tensorflow.SaveSliceInfoDef! {
                get {
                    if saveSliceInfoDefBuilder_ != nil {
                        builderResult.saveSliceInfoDef = saveSliceInfoDefBuilder_.getMessage()
                    }
                    return builderResult.saveSliceInfoDef
                }
                set (value) {
                    builderResult.hasSaveSliceInfoDef = true
                    builderResult.saveSliceInfoDef = value
                }
            }
            public var hasSaveSliceInfoDef:Bool {
                get {
                    return builderResult.hasSaveSliceInfoDef
                }
            }
            fileprivate var saveSliceInfoDefBuilder_:Tensorflow.SaveSliceInfoDef.Builder! {
                didSet {
                    builderResult.hasSaveSliceInfoDef = true
                }
            }
            public func getSaveSliceInfoDefBuilder() -> Tensorflow.SaveSliceInfoDef.Builder {
                if saveSliceInfoDefBuilder_ == nil {
                    saveSliceInfoDefBuilder_ = Tensorflow.SaveSliceInfoDef.Builder()
                    builderResult.saveSliceInfoDef = saveSliceInfoDefBuilder_.getMessage()
                    if saveSliceInfoDef != nil {
                        try! saveSliceInfoDefBuilder_.mergeFrom(other: saveSliceInfoDef)
                    }
                }
                return saveSliceInfoDefBuilder_
            }
            @discardableResult
            public func setSaveSliceInfoDef(_ value:Tensorflow.SaveSliceInfoDef!) -> Tensorflow.VariableDef.Builder {
                self.saveSliceInfoDef = value
                return self
            }
            @discardableResult
            public func mergeSaveSliceInfoDef(value:Tensorflow.SaveSliceInfoDef) throws -> Tensorflow.VariableDef.Builder {
                if builderResult.hasSaveSliceInfoDef {
                    builderResult.saveSliceInfoDef = try Tensorflow.SaveSliceInfoDef.builderWithPrototype(prototype:builderResult.saveSliceInfoDef).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.saveSliceInfoDef = value
                }
                builderResult.hasSaveSliceInfoDef = true
                return self
            }
            @discardableResult
            public func clearSaveSliceInfoDef() -> Tensorflow.VariableDef.Builder {
                saveSliceInfoDefBuilder_ = nil
                builderResult.hasSaveSliceInfoDef = false
                builderResult.saveSliceInfoDef = nil
                return self
            }
            /// Whether to represent this as a ResourceVariable.
            public var isResource:Bool {
                get {
                    return builderResult.isResource
                }
                set (value) {
                    builderResult.hasIsResource = true
                    builderResult.isResource = value
                }
            }
            public var hasIsResource:Bool {
                get {
                    return builderResult.hasIsResource
                }
            }
            @discardableResult
            public func setIsResource(_ value:Bool) -> Tensorflow.VariableDef.Builder {
                self.isResource = value
                return self
            }
            @discardableResult
            public func clearIsResource() -> Tensorflow.VariableDef.Builder{
                builderResult.hasIsResource = false
                builderResult.isResource = false
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.VariableDef.Builder {
                builderResult = Tensorflow.VariableDef()
                return self
            }
            override public func clone() throws -> Tensorflow.VariableDef.Builder {
                return try Tensorflow.VariableDef.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.VariableDef {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.VariableDef {
                let returnMe:Tensorflow.VariableDef = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.VariableDef) throws -> Tensorflow.VariableDef.Builder {
                if other == Tensorflow.VariableDef() {
                    return self
                }
                if other.hasVariableName {
                    variableName = other.variableName
                }
                if other.hasInitializerName {
                    initializerName = other.initializerName
                }
                if other.hasSnapshotName {
                    snapshotName = other.snapshotName
                }
                if (other.hasSaveSliceInfoDef) {
                    try mergeSaveSliceInfoDef(value: other.saveSliceInfoDef)
                }
                if other.hasIsResource {
                    isResource = other.isResource
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.VariableDef.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.VariableDef.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        variableName = try codedInputStream.readString()

                    case 18:
                        initializerName = try codedInputStream.readString()

                    case 26:
                        snapshotName = try codedInputStream.readString()

                    case 34:
                        let subBuilder:Tensorflow.SaveSliceInfoDef.Builder = Tensorflow.SaveSliceInfoDef.Builder()
                        if hasSaveSliceInfoDef {
                            try subBuilder.mergeFrom(other: saveSliceInfoDef)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        saveSliceInfoDef = subBuilder.buildPartial()

                    case 40:
                        isResource = try codedInputStream.readBool()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.VariableDef.Builder {
                let resultDecodedBuilder = Tensorflow.VariableDef.Builder()
                if let jsonValueVariableName = jsonMap["variableName"] as? String {
                    resultDecodedBuilder.variableName = jsonValueVariableName
                }
                if let jsonValueInitializerName = jsonMap["initializerName"] as? String {
                    resultDecodedBuilder.initializerName = jsonValueInitializerName
                }
                if let jsonValueSnapshotName = jsonMap["snapshotName"] as? String {
                    resultDecodedBuilder.snapshotName = jsonValueSnapshotName
                }
                if let jsonValueSaveSliceInfoDef = jsonMap["saveSliceInfoDef"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.saveSliceInfoDef = try Tensorflow.SaveSliceInfoDef.Builder.decodeToBuilder(jsonMap:jsonValueSaveSliceInfoDef).build()

                }
                if let jsonValueIsResource = jsonMap["isResource"] as? Bool {
                    resultDecodedBuilder.isResource = jsonValueIsResource
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.VariableDef.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.VariableDef.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class SaveSliceInfoDef : GeneratedMessage {

        public static func == (lhs: Tensorflow.SaveSliceInfoDef, rhs: Tensorflow.SaveSliceInfoDef) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasFullName == rhs.hasFullName) && (!lhs.hasFullName || lhs.fullName == rhs.fullName)
            fieldCheck = fieldCheck && (lhs.fullShape == rhs.fullShape)
            fieldCheck = fieldCheck && (lhs.varOffset == rhs.varOffset)
            fieldCheck = fieldCheck && (lhs.varShape == rhs.varShape)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Name of the full variable of which this is a slice.
        public fileprivate(set) var fullName:String = ""
        public fileprivate(set) var hasFullName:Bool = false

        /// Shape of the full variable.
        public fileprivate(set) var fullShape:Array<Int64> = Array<Int64>()
        private var fullShapeMemoizedSerializedSize:Int32 = -1
        /// Offset of this variable into the full variable.
        public fileprivate(set) var varOffset:Array<Int64> = Array<Int64>()
        private var varOffsetMemoizedSerializedSize:Int32 = -1
        /// Shape of this variable.
        public fileprivate(set) var varShape:Array<Int64> = Array<Int64>()
        private var varShapeMemoizedSerializedSize:Int32 = -1
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasFullName {
                try codedOutputStream.writeString(fieldNumber: 1, value:fullName)
            }
            if !fullShape.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 18)
                try codedOutputStream.writeRawVarint32(value: fullShapeMemoizedSerializedSize)
                for oneValuefullShape in fullShape {
                    try codedOutputStream.writeInt64NoTag(value: oneValuefullShape)
                }
            }
            if !varOffset.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 26)
                try codedOutputStream.writeRawVarint32(value: varOffsetMemoizedSerializedSize)
                for oneValuevarOffset in varOffset {
                    try codedOutputStream.writeInt64NoTag(value: oneValuevarOffset)
                }
            }
            if !varShape.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 34)
                try codedOutputStream.writeRawVarint32(value: varShapeMemoizedSerializedSize)
                for oneValuevarShape in varShape {
                    try codedOutputStream.writeInt64NoTag(value: oneValuevarShape)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasFullName {
                serialize_size += fullName.computeStringSize(fieldNumber: 1)
            }
            var dataSizeFullShape:Int32 = 0
            for oneValuefullShape in fullShape {
                dataSizeFullShape += oneValuefullShape.computeInt64SizeNoTag()
            }
            serialize_size += dataSizeFullShape
            if !fullShape.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeFullShape.computeInt32SizeNoTag()
            }
            fullShapeMemoizedSerializedSize = dataSizeFullShape
            var dataSizeVarOffset:Int32 = 0
            for oneValuevarOffset in varOffset {
                dataSizeVarOffset += oneValuevarOffset.computeInt64SizeNoTag()
            }
            serialize_size += dataSizeVarOffset
            if !varOffset.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeVarOffset.computeInt32SizeNoTag()
            }
            varOffsetMemoizedSerializedSize = dataSizeVarOffset
            var dataSizeVarShape:Int32 = 0
            for oneValuevarShape in varShape {
                dataSizeVarShape += oneValuevarShape.computeInt64SizeNoTag()
            }
            serialize_size += dataSizeVarShape
            if !varShape.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeVarShape.computeInt32SizeNoTag()
            }
            varShapeMemoizedSerializedSize = dataSizeVarShape
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.SaveSliceInfoDef.Builder {
            return Tensorflow.SaveSliceInfoDef.classBuilder() as! Tensorflow.SaveSliceInfoDef.Builder
        }
        public func getBuilder() -> Tensorflow.SaveSliceInfoDef.Builder {
            return classBuilder() as! Tensorflow.SaveSliceInfoDef.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.SaveSliceInfoDef.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.SaveSliceInfoDef.Builder()
        }
        public func toBuilder() throws -> Tensorflow.SaveSliceInfoDef.Builder {
            return try Tensorflow.SaveSliceInfoDef.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.SaveSliceInfoDef) throws -> Tensorflow.SaveSliceInfoDef.Builder {
            return try Tensorflow.SaveSliceInfoDef.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasFullName {
                jsonMap["fullName"] = fullName
            }
            if !fullShape.isEmpty {
                var jsonArrayFullShape:Array<String> = []
                for oneValueFullShape in fullShape {
                    jsonArrayFullShape.append("\(oneValueFullShape)")
                }
                jsonMap["fullShape"] = jsonArrayFullShape
            }
            if !varOffset.isEmpty {
                var jsonArrayVarOffset:Array<String> = []
                for oneValueVarOffset in varOffset {
                    jsonArrayVarOffset.append("\(oneValueVarOffset)")
                }
                jsonMap["varOffset"] = jsonArrayVarOffset
            }
            if !varShape.isEmpty {
                var jsonArrayVarShape:Array<String> = []
                for oneValueVarShape in varShape {
                    jsonArrayVarShape.append("\(oneValueVarShape)")
                }
                jsonMap["varShape"] = jsonArrayVarShape
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.SaveSliceInfoDef {
            return try Tensorflow.SaveSliceInfoDef.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.SaveSliceInfoDef {
            return try Tensorflow.SaveSliceInfoDef.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasFullName {
                output += "\(indent) fullName: \(fullName) \n"
            }
            var fullShapeElementIndex:Int = 0
            for oneValueFullShape in fullShape  {
                output += "\(indent) fullShape[\(fullShapeElementIndex)]: \(oneValueFullShape)\n"
                fullShapeElementIndex += 1
            }
            var varOffsetElementIndex:Int = 0
            for oneValueVarOffset in varOffset  {
                output += "\(indent) varOffset[\(varOffsetElementIndex)]: \(oneValueVarOffset)\n"
                varOffsetElementIndex += 1
            }
            var varShapeElementIndex:Int = 0
            for oneValueVarShape in varShape  {
                output += "\(indent) varShape[\(varShapeElementIndex)]: \(oneValueVarShape)\n"
                varShapeElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasFullName {
                    hashCode = (hashCode &* 31) &+ fullName.hashValue
                }
                for oneValueFullShape in fullShape {
                    hashCode = (hashCode &* 31) &+ oneValueFullShape.hashValue
                }
                for oneValueVarOffset in varOffset {
                    hashCode = (hashCode &* 31) &+ oneValueVarOffset.hashValue
                }
                for oneValueVarShape in varShape {
                    hashCode = (hashCode &* 31) &+ oneValueVarShape.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.SaveSliceInfoDef"
        }
        override public func className() -> String {
            return "Tensorflow.SaveSliceInfoDef"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.SaveSliceInfoDef = Tensorflow.SaveSliceInfoDef()
            public func getMessage() -> Tensorflow.SaveSliceInfoDef {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Name of the full variable of which this is a slice.
            public var fullName:String {
                get {
                    return builderResult.fullName
                }
                set (value) {
                    builderResult.hasFullName = true
                    builderResult.fullName = value
                }
            }
            public var hasFullName:Bool {
                get {
                    return builderResult.hasFullName
                }
            }
            @discardableResult
            public func setFullName(_ value:String) -> Tensorflow.SaveSliceInfoDef.Builder {
                self.fullName = value
                return self
            }
            @discardableResult
            public func clearFullName() -> Tensorflow.SaveSliceInfoDef.Builder{
                builderResult.hasFullName = false
                builderResult.fullName = ""
                return self
            }
            /// Shape of the full variable.
            public var fullShape:Array<Int64> {
                get {
                    return builderResult.fullShape
                }
                set (array) {
                    builderResult.fullShape = array
                }
            }
            @discardableResult
            public func setFullShape(_ value:Array<Int64>) -> Tensorflow.SaveSliceInfoDef.Builder {
                self.fullShape = value
                return self
            }
            @discardableResult
            public func clearFullShape() -> Tensorflow.SaveSliceInfoDef.Builder {
                builderResult.fullShape.removeAll(keepingCapacity: false)
                return self
            }
            /// Offset of this variable into the full variable.
            public var varOffset:Array<Int64> {
                get {
                    return builderResult.varOffset
                }
                set (array) {
                    builderResult.varOffset = array
                }
            }
            @discardableResult
            public func setVarOffset(_ value:Array<Int64>) -> Tensorflow.SaveSliceInfoDef.Builder {
                self.varOffset = value
                return self
            }
            @discardableResult
            public func clearVarOffset() -> Tensorflow.SaveSliceInfoDef.Builder {
                builderResult.varOffset.removeAll(keepingCapacity: false)
                return self
            }
            /// Shape of this variable.
            public var varShape:Array<Int64> {
                get {
                    return builderResult.varShape
                }
                set (array) {
                    builderResult.varShape = array
                }
            }
            @discardableResult
            public func setVarShape(_ value:Array<Int64>) -> Tensorflow.SaveSliceInfoDef.Builder {
                self.varShape = value
                return self
            }
            @discardableResult
            public func clearVarShape() -> Tensorflow.SaveSliceInfoDef.Builder {
                builderResult.varShape.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.SaveSliceInfoDef.Builder {
                builderResult = Tensorflow.SaveSliceInfoDef()
                return self
            }
            override public func clone() throws -> Tensorflow.SaveSliceInfoDef.Builder {
                return try Tensorflow.SaveSliceInfoDef.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.SaveSliceInfoDef {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.SaveSliceInfoDef {
                let returnMe:Tensorflow.SaveSliceInfoDef = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.SaveSliceInfoDef) throws -> Tensorflow.SaveSliceInfoDef.Builder {
                if other == Tensorflow.SaveSliceInfoDef() {
                    return self
                }
                if other.hasFullName {
                    fullName = other.fullName
                }
                if !other.fullShape.isEmpty {
                    builderResult.fullShape += other.fullShape
                }
                if !other.varOffset.isEmpty {
                    builderResult.varOffset += other.varOffset
                }
                if !other.varShape.isEmpty {
                    builderResult.varShape += other.varShape
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.SaveSliceInfoDef.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.SaveSliceInfoDef.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        fullName = try codedInputStream.readString()

                    case 18:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.fullShape.append(try codedInputStream.readInt64())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 26:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.varOffset.append(try codedInputStream.readInt64())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 34:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.varShape.append(try codedInputStream.readInt64())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.SaveSliceInfoDef.Builder {
                let resultDecodedBuilder = Tensorflow.SaveSliceInfoDef.Builder()
                if let jsonValueFullName = jsonMap["fullName"] as? String {
                    resultDecodedBuilder.fullName = jsonValueFullName
                }
                if let jsonValueFullShape = jsonMap["fullShape"] as? Array<String> {
                    var jsonArrayFullShape:Array<Int64> = []
                    for oneValueFullShape in jsonValueFullShape {
                        jsonArrayFullShape.append(Int64(oneValueFullShape)!)
                    }
                    resultDecodedBuilder.fullShape = jsonArrayFullShape
                }
                if let jsonValueVarOffset = jsonMap["varOffset"] as? Array<String> {
                    var jsonArrayVarOffset:Array<Int64> = []
                    for oneValueVarOffset in jsonValueVarOffset {
                        jsonArrayVarOffset.append(Int64(oneValueVarOffset)!)
                    }
                    resultDecodedBuilder.varOffset = jsonArrayVarOffset
                }
                if let jsonValueVarShape = jsonMap["varShape"] as? Array<String> {
                    var jsonArrayVarShape:Array<Int64> = []
                    for oneValueVarShape in jsonValueVarShape {
                        jsonArrayVarShape.append(Int64(oneValueVarShape)!)
                    }
                    resultDecodedBuilder.varShape = jsonArrayVarShape
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.SaveSliceInfoDef.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.SaveSliceInfoDef.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.VariableDef: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.VariableDef> {
        var mergedArray = Array<Tensorflow.VariableDef>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.VariableDef? {
        return try Tensorflow.VariableDef.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.VariableDef {
        return try Tensorflow.VariableDef.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.VariableRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.VariableDef {
        return try Tensorflow.VariableDef.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.VariableDef {
        return try Tensorflow.VariableDef.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.VariableDef {
        return try Tensorflow.VariableDef.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.VariableDef {
        return try Tensorflow.VariableDef.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.VariableDef {
        return try Tensorflow.VariableDef.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "variableName": return self.variableName
        case "initializerName": return self.initializerName
        case "snapshotName": return self.snapshotName
        case "saveSliceInfoDef": return self.saveSliceInfoDef
        case "isResource": return self.isResource
        default: return nil
        }
    }
}
extension Tensorflow.VariableDef.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "variableName": return self.variableName
            case "initializerName": return self.initializerName
            case "snapshotName": return self.snapshotName
            case "saveSliceInfoDef": return self.saveSliceInfoDef
            case "isResource": return self.isResource
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "variableName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.variableName = newSubscriptValue
            case "initializerName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.initializerName = newSubscriptValue
            case "snapshotName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.snapshotName = newSubscriptValue
            case "saveSliceInfoDef":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.SaveSliceInfoDef else {
                    return
                }
                self.saveSliceInfoDef = newSubscriptValue
            case "isResource":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.isResource = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.SaveSliceInfoDef: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.SaveSliceInfoDef> {
        var mergedArray = Array<Tensorflow.SaveSliceInfoDef>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.SaveSliceInfoDef? {
        return try Tensorflow.SaveSliceInfoDef.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.SaveSliceInfoDef {
        return try Tensorflow.SaveSliceInfoDef.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.VariableRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.SaveSliceInfoDef {
        return try Tensorflow.SaveSliceInfoDef.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.SaveSliceInfoDef {
        return try Tensorflow.SaveSliceInfoDef.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.SaveSliceInfoDef {
        return try Tensorflow.SaveSliceInfoDef.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.SaveSliceInfoDef {
        return try Tensorflow.SaveSliceInfoDef.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.SaveSliceInfoDef {
        return try Tensorflow.SaveSliceInfoDef.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "fullName": return self.fullName
        case "fullShape": return self.fullShape
        case "varOffset": return self.varOffset
        case "varShape": return self.varShape
        default: return nil
        }
    }
}
extension Tensorflow.SaveSliceInfoDef.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "fullName": return self.fullName
            case "fullShape": return self.fullShape
            case "varOffset": return self.varOffset
            case "varShape": return self.varShape
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "fullName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.fullName = newSubscriptValue
            case "fullShape":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.fullShape = newSubscriptValue
            case "varOffset":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.varOffset = newSubscriptValue
            case "varShape":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.varShape = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

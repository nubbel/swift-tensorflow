/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "step_stats.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { }

public extension Tensorflow {
    public struct StepStatsRoot {
        public static let `default` = StepStatsRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Tensorflow.AllocationDescriptionRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.TensorDescriptionRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    final public class AllocatorMemoryUsed : GeneratedMessage {

        public static func == (lhs: Tensorflow.AllocatorMemoryUsed, rhs: Tensorflow.AllocatorMemoryUsed) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasAllocatorName == rhs.hasAllocatorName) && (!lhs.hasAllocatorName || lhs.allocatorName == rhs.allocatorName)
            fieldCheck = fieldCheck && (lhs.hasTotalBytes == rhs.hasTotalBytes) && (!lhs.hasTotalBytes || lhs.totalBytes == rhs.totalBytes)
            fieldCheck = fieldCheck && (lhs.hasPeakBytes == rhs.hasPeakBytes) && (!lhs.hasPeakBytes || lhs.peakBytes == rhs.peakBytes)
            fieldCheck = fieldCheck && (lhs.hasLiveBytes == rhs.hasLiveBytes) && (!lhs.hasLiveBytes || lhs.liveBytes == rhs.liveBytes)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var allocatorName:String = ""
        public fileprivate(set) var hasAllocatorName:Bool = false

        public fileprivate(set) var totalBytes:Int64 = Int64(0)
        public fileprivate(set) var hasTotalBytes:Bool = false

        public fileprivate(set) var peakBytes:Int64 = Int64(0)
        public fileprivate(set) var hasPeakBytes:Bool = false

        /// The bytes that are not deallocated.
        public fileprivate(set) var liveBytes:Int64 = Int64(0)
        public fileprivate(set) var hasLiveBytes:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasAllocatorName {
                try codedOutputStream.writeString(fieldNumber: 1, value:allocatorName)
            }
            if hasTotalBytes {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:totalBytes)
            }
            if hasPeakBytes {
                try codedOutputStream.writeInt64(fieldNumber: 3, value:peakBytes)
            }
            if hasLiveBytes {
                try codedOutputStream.writeInt64(fieldNumber: 4, value:liveBytes)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasAllocatorName {
                serialize_size += allocatorName.computeStringSize(fieldNumber: 1)
            }
            if hasTotalBytes {
                serialize_size += totalBytes.computeInt64Size(fieldNumber: 2)
            }
            if hasPeakBytes {
                serialize_size += peakBytes.computeInt64Size(fieldNumber: 3)
            }
            if hasLiveBytes {
                serialize_size += liveBytes.computeInt64Size(fieldNumber: 4)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.AllocatorMemoryUsed.Builder {
            return Tensorflow.AllocatorMemoryUsed.classBuilder() as! Tensorflow.AllocatorMemoryUsed.Builder
        }
        public func getBuilder() -> Tensorflow.AllocatorMemoryUsed.Builder {
            return classBuilder() as! Tensorflow.AllocatorMemoryUsed.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.AllocatorMemoryUsed.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.AllocatorMemoryUsed.Builder()
        }
        public func toBuilder() throws -> Tensorflow.AllocatorMemoryUsed.Builder {
            return try Tensorflow.AllocatorMemoryUsed.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.AllocatorMemoryUsed) throws -> Tensorflow.AllocatorMemoryUsed.Builder {
            return try Tensorflow.AllocatorMemoryUsed.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasAllocatorName {
                jsonMap["allocatorName"] = allocatorName
            }
            if hasTotalBytes {
                jsonMap["totalBytes"] = "\(totalBytes)"
            }
            if hasPeakBytes {
                jsonMap["peakBytes"] = "\(peakBytes)"
            }
            if hasLiveBytes {
                jsonMap["liveBytes"] = "\(liveBytes)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.AllocatorMemoryUsed {
            return try Tensorflow.AllocatorMemoryUsed.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.AllocatorMemoryUsed {
            return try Tensorflow.AllocatorMemoryUsed.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasAllocatorName {
                output += "\(indent) allocatorName: \(allocatorName) \n"
            }
            if hasTotalBytes {
                output += "\(indent) totalBytes: \(totalBytes) \n"
            }
            if hasPeakBytes {
                output += "\(indent) peakBytes: \(peakBytes) \n"
            }
            if hasLiveBytes {
                output += "\(indent) liveBytes: \(liveBytes) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasAllocatorName {
                    hashCode = (hashCode &* 31) &+ allocatorName.hashValue
                }
                if hasTotalBytes {
                    hashCode = (hashCode &* 31) &+ totalBytes.hashValue
                }
                if hasPeakBytes {
                    hashCode = (hashCode &* 31) &+ peakBytes.hashValue
                }
                if hasLiveBytes {
                    hashCode = (hashCode &* 31) &+ liveBytes.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.AllocatorMemoryUsed"
        }
        override public func className() -> String {
            return "Tensorflow.AllocatorMemoryUsed"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.AllocatorMemoryUsed = Tensorflow.AllocatorMemoryUsed()
            public func getMessage() -> Tensorflow.AllocatorMemoryUsed {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var allocatorName:String {
                get {
                    return builderResult.allocatorName
                }
                set (value) {
                    builderResult.hasAllocatorName = true
                    builderResult.allocatorName = value
                }
            }
            public var hasAllocatorName:Bool {
                get {
                    return builderResult.hasAllocatorName
                }
            }
            @discardableResult
            public func setAllocatorName(_ value:String) -> Tensorflow.AllocatorMemoryUsed.Builder {
                self.allocatorName = value
                return self
            }
            @discardableResult
            public func clearAllocatorName() -> Tensorflow.AllocatorMemoryUsed.Builder{
                builderResult.hasAllocatorName = false
                builderResult.allocatorName = ""
                return self
            }
            public var totalBytes:Int64 {
                get {
                    return builderResult.totalBytes
                }
                set (value) {
                    builderResult.hasTotalBytes = true
                    builderResult.totalBytes = value
                }
            }
            public var hasTotalBytes:Bool {
                get {
                    return builderResult.hasTotalBytes
                }
            }
            @discardableResult
            public func setTotalBytes(_ value:Int64) -> Tensorflow.AllocatorMemoryUsed.Builder {
                self.totalBytes = value
                return self
            }
            @discardableResult
            public func clearTotalBytes() -> Tensorflow.AllocatorMemoryUsed.Builder{
                builderResult.hasTotalBytes = false
                builderResult.totalBytes = Int64(0)
                return self
            }
            public var peakBytes:Int64 {
                get {
                    return builderResult.peakBytes
                }
                set (value) {
                    builderResult.hasPeakBytes = true
                    builderResult.peakBytes = value
                }
            }
            public var hasPeakBytes:Bool {
                get {
                    return builderResult.hasPeakBytes
                }
            }
            @discardableResult
            public func setPeakBytes(_ value:Int64) -> Tensorflow.AllocatorMemoryUsed.Builder {
                self.peakBytes = value
                return self
            }
            @discardableResult
            public func clearPeakBytes() -> Tensorflow.AllocatorMemoryUsed.Builder{
                builderResult.hasPeakBytes = false
                builderResult.peakBytes = Int64(0)
                return self
            }
            /// The bytes that are not deallocated.
            public var liveBytes:Int64 {
                get {
                    return builderResult.liveBytes
                }
                set (value) {
                    builderResult.hasLiveBytes = true
                    builderResult.liveBytes = value
                }
            }
            public var hasLiveBytes:Bool {
                get {
                    return builderResult.hasLiveBytes
                }
            }
            @discardableResult
            public func setLiveBytes(_ value:Int64) -> Tensorflow.AllocatorMemoryUsed.Builder {
                self.liveBytes = value
                return self
            }
            @discardableResult
            public func clearLiveBytes() -> Tensorflow.AllocatorMemoryUsed.Builder{
                builderResult.hasLiveBytes = false
                builderResult.liveBytes = Int64(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.AllocatorMemoryUsed.Builder {
                builderResult = Tensorflow.AllocatorMemoryUsed()
                return self
            }
            override public func clone() throws -> Tensorflow.AllocatorMemoryUsed.Builder {
                return try Tensorflow.AllocatorMemoryUsed.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.AllocatorMemoryUsed {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.AllocatorMemoryUsed {
                let returnMe:Tensorflow.AllocatorMemoryUsed = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.AllocatorMemoryUsed) throws -> Tensorflow.AllocatorMemoryUsed.Builder {
                if other == Tensorflow.AllocatorMemoryUsed() {
                    return self
                }
                if other.hasAllocatorName {
                    allocatorName = other.allocatorName
                }
                if other.hasTotalBytes {
                    totalBytes = other.totalBytes
                }
                if other.hasPeakBytes {
                    peakBytes = other.peakBytes
                }
                if other.hasLiveBytes {
                    liveBytes = other.liveBytes
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.AllocatorMemoryUsed.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.AllocatorMemoryUsed.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        allocatorName = try codedInputStream.readString()

                    case 16:
                        totalBytes = try codedInputStream.readInt64()

                    case 24:
                        peakBytes = try codedInputStream.readInt64()

                    case 32:
                        liveBytes = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.AllocatorMemoryUsed.Builder {
                let resultDecodedBuilder = Tensorflow.AllocatorMemoryUsed.Builder()
                if let jsonValueAllocatorName = jsonMap["allocatorName"] as? String {
                    resultDecodedBuilder.allocatorName = jsonValueAllocatorName
                }
                if let jsonValueTotalBytes = jsonMap["totalBytes"] as? String {
                    resultDecodedBuilder.totalBytes = Int64(jsonValueTotalBytes)!
                } else if let jsonValueTotalBytes = jsonMap["totalBytes"] as? Int {
                    resultDecodedBuilder.totalBytes = Int64(jsonValueTotalBytes)
                }
                if let jsonValuePeakBytes = jsonMap["peakBytes"] as? String {
                    resultDecodedBuilder.peakBytes = Int64(jsonValuePeakBytes)!
                } else if let jsonValuePeakBytes = jsonMap["peakBytes"] as? Int {
                    resultDecodedBuilder.peakBytes = Int64(jsonValuePeakBytes)
                }
                if let jsonValueLiveBytes = jsonMap["liveBytes"] as? String {
                    resultDecodedBuilder.liveBytes = Int64(jsonValueLiveBytes)!
                } else if let jsonValueLiveBytes = jsonMap["liveBytes"] as? Int {
                    resultDecodedBuilder.liveBytes = Int64(jsonValueLiveBytes)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.AllocatorMemoryUsed.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.AllocatorMemoryUsed.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Output sizes recorded for a single execution of a graph node.
    final public class NodeOutput : GeneratedMessage {

        public static func == (lhs: Tensorflow.NodeOutput, rhs: Tensorflow.NodeOutput) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasSlot == rhs.hasSlot) && (!lhs.hasSlot || lhs.slot == rhs.slot)
            fieldCheck = fieldCheck && (lhs.hasTensorDescription == rhs.hasTensorDescription) && (!lhs.hasTensorDescription || lhs.tensorDescription == rhs.tensorDescription)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var slot:Int32 = Int32(0)
        public fileprivate(set) var hasSlot:Bool = false

        public fileprivate(set) var tensorDescription:Tensorflow.TensorDescription!
        public fileprivate(set) var hasTensorDescription:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasSlot {
                try codedOutputStream.writeInt32(fieldNumber: 1, value:slot)
            }
            if hasTensorDescription {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:tensorDescription)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasSlot {
                serialize_size += slot.computeInt32Size(fieldNumber: 1)
            }
            if hasTensorDescription {
                if let varSizetensorDescription = tensorDescription?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizetensorDescription
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.NodeOutput.Builder {
            return Tensorflow.NodeOutput.classBuilder() as! Tensorflow.NodeOutput.Builder
        }
        public func getBuilder() -> Tensorflow.NodeOutput.Builder {
            return classBuilder() as! Tensorflow.NodeOutput.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.NodeOutput.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.NodeOutput.Builder()
        }
        public func toBuilder() throws -> Tensorflow.NodeOutput.Builder {
            return try Tensorflow.NodeOutput.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.NodeOutput) throws -> Tensorflow.NodeOutput.Builder {
            return try Tensorflow.NodeOutput.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasSlot {
                jsonMap["slot"] = Int(slot)
            }
            if hasTensorDescription {
                jsonMap["tensorDescription"] = try tensorDescription.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.NodeOutput {
            return try Tensorflow.NodeOutput.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.NodeOutput {
            return try Tensorflow.NodeOutput.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasSlot {
                output += "\(indent) slot: \(slot) \n"
            }
            if hasTensorDescription {
                output += "\(indent) tensorDescription {\n"
                if let outDescTensorDescription = tensorDescription {
                    output += try outDescTensorDescription.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasSlot {
                    hashCode = (hashCode &* 31) &+ slot.hashValue
                }
                if hasTensorDescription {
                    if let hashValuetensorDescription = tensorDescription?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuetensorDescription
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.NodeOutput"
        }
        override public func className() -> String {
            return "Tensorflow.NodeOutput"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.NodeOutput = Tensorflow.NodeOutput()
            public func getMessage() -> Tensorflow.NodeOutput {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var slot:Int32 {
                get {
                    return builderResult.slot
                }
                set (value) {
                    builderResult.hasSlot = true
                    builderResult.slot = value
                }
            }
            public var hasSlot:Bool {
                get {
                    return builderResult.hasSlot
                }
            }
            @discardableResult
            public func setSlot(_ value:Int32) -> Tensorflow.NodeOutput.Builder {
                self.slot = value
                return self
            }
            @discardableResult
            public func clearSlot() -> Tensorflow.NodeOutput.Builder{
                builderResult.hasSlot = false
                builderResult.slot = Int32(0)
                return self
            }
            public var tensorDescription:Tensorflow.TensorDescription! {
                get {
                    if tensorDescriptionBuilder_ != nil {
                        builderResult.tensorDescription = tensorDescriptionBuilder_.getMessage()
                    }
                    return builderResult.tensorDescription
                }
                set (value) {
                    builderResult.hasTensorDescription = true
                    builderResult.tensorDescription = value
                }
            }
            public var hasTensorDescription:Bool {
                get {
                    return builderResult.hasTensorDescription
                }
            }
            fileprivate var tensorDescriptionBuilder_:Tensorflow.TensorDescription.Builder! {
                didSet {
                    builderResult.hasTensorDescription = true
                }
            }
            public func getTensorDescriptionBuilder() -> Tensorflow.TensorDescription.Builder {
                if tensorDescriptionBuilder_ == nil {
                    tensorDescriptionBuilder_ = Tensorflow.TensorDescription.Builder()
                    builderResult.tensorDescription = tensorDescriptionBuilder_.getMessage()
                    if tensorDescription != nil {
                        try! tensorDescriptionBuilder_.mergeFrom(other: tensorDescription)
                    }
                }
                return tensorDescriptionBuilder_
            }
            @discardableResult
            public func setTensorDescription(_ value:Tensorflow.TensorDescription!) -> Tensorflow.NodeOutput.Builder {
                self.tensorDescription = value
                return self
            }
            @discardableResult
            public func mergeTensorDescription(value:Tensorflow.TensorDescription) throws -> Tensorflow.NodeOutput.Builder {
                if builderResult.hasTensorDescription {
                    builderResult.tensorDescription = try Tensorflow.TensorDescription.builderWithPrototype(prototype:builderResult.tensorDescription).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.tensorDescription = value
                }
                builderResult.hasTensorDescription = true
                return self
            }
            @discardableResult
            public func clearTensorDescription() -> Tensorflow.NodeOutput.Builder {
                tensorDescriptionBuilder_ = nil
                builderResult.hasTensorDescription = false
                builderResult.tensorDescription = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.NodeOutput.Builder {
                builderResult = Tensorflow.NodeOutput()
                return self
            }
            override public func clone() throws -> Tensorflow.NodeOutput.Builder {
                return try Tensorflow.NodeOutput.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.NodeOutput {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.NodeOutput {
                let returnMe:Tensorflow.NodeOutput = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.NodeOutput) throws -> Tensorflow.NodeOutput.Builder {
                if other == Tensorflow.NodeOutput() {
                    return self
                }
                if other.hasSlot {
                    slot = other.slot
                }
                if (other.hasTensorDescription) {
                    try mergeTensorDescription(value: other.tensorDescription)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.NodeOutput.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.NodeOutput.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        slot = try codedInputStream.readInt32()

                    case 26:
                        let subBuilder:Tensorflow.TensorDescription.Builder = Tensorflow.TensorDescription.Builder()
                        if hasTensorDescription {
                            try subBuilder.mergeFrom(other: tensorDescription)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        tensorDescription = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.NodeOutput.Builder {
                let resultDecodedBuilder = Tensorflow.NodeOutput.Builder()
                if let jsonValueSlot = jsonMap["slot"] as? Int {
                    resultDecodedBuilder.slot = Int32(jsonValueSlot)
                } else if let jsonValueSlot = jsonMap["slot"] as? String {
                    resultDecodedBuilder.slot = Int32(jsonValueSlot)!
                }
                if let jsonValueTensorDescription = jsonMap["tensorDescription"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.tensorDescription = try Tensorflow.TensorDescription.Builder.decodeToBuilder(jsonMap:jsonValueTensorDescription).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.NodeOutput.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.NodeOutput.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// For memory tracking.
    final public class MemoryStats : GeneratedMessage {

        public static func == (lhs: Tensorflow.MemoryStats, rhs: Tensorflow.MemoryStats) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasHostTempMemorySize == rhs.hasHostTempMemorySize) && (!lhs.hasHostTempMemorySize || lhs.hostTempMemorySize == rhs.hostTempMemorySize)
            fieldCheck = fieldCheck && (lhs.hasDeviceTempMemorySize == rhs.hasDeviceTempMemorySize) && (!lhs.hasDeviceTempMemorySize || lhs.deviceTempMemorySize == rhs.deviceTempMemorySize)
            fieldCheck = fieldCheck && (lhs.hasHostPersistentMemorySize == rhs.hasHostPersistentMemorySize) && (!lhs.hasHostPersistentMemorySize || lhs.hostPersistentMemorySize == rhs.hostPersistentMemorySize)
            fieldCheck = fieldCheck && (lhs.hasDevicePersistentMemorySize == rhs.hasDevicePersistentMemorySize) && (!lhs.hasDevicePersistentMemorySize || lhs.devicePersistentMemorySize == rhs.devicePersistentMemorySize)
            fieldCheck = fieldCheck && (lhs.hostPersistentTensorAllocIds == rhs.hostPersistentTensorAllocIds)
            fieldCheck = fieldCheck && (lhs.devicePersistentTensorAllocIds == rhs.devicePersistentTensorAllocIds)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var hostTempMemorySize:Int64 = Int64(0)
        public fileprivate(set) var hasHostTempMemorySize:Bool = false

        public fileprivate(set) var deviceTempMemorySize:Int64 = Int64(0)
        public fileprivate(set) var hasDeviceTempMemorySize:Bool = false

        public fileprivate(set) var hostPersistentMemorySize:Int64 = Int64(0)
        public fileprivate(set) var hasHostPersistentMemorySize:Bool = false

        public fileprivate(set) var devicePersistentMemorySize:Int64 = Int64(0)
        public fileprivate(set) var hasDevicePersistentMemorySize:Bool = false

        public fileprivate(set) var hostPersistentTensorAllocIds:Array<Int64> = Array<Int64>()
        private var hostPersistentTensorAllocIdsMemoizedSerializedSize:Int32 = -1
        public fileprivate(set) var devicePersistentTensorAllocIds:Array<Int64> = Array<Int64>()
        private var devicePersistentTensorAllocIdsMemoizedSerializedSize:Int32 = -1
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasHostTempMemorySize {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:hostTempMemorySize)
            }
            if hasDeviceTempMemorySize {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:deviceTempMemorySize)
            }
            if hasHostPersistentMemorySize {
                try codedOutputStream.writeInt64(fieldNumber: 3, value:hostPersistentMemorySize)
            }
            if hasDevicePersistentMemorySize {
                try codedOutputStream.writeInt64(fieldNumber: 4, value:devicePersistentMemorySize)
            }
            if !hostPersistentTensorAllocIds.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 42)
                try codedOutputStream.writeRawVarint32(value: hostPersistentTensorAllocIdsMemoizedSerializedSize)
                for oneValuehostPersistentTensorAllocIds in hostPersistentTensorAllocIds {
                    try codedOutputStream.writeInt64NoTag(value: oneValuehostPersistentTensorAllocIds)
                }
            }
            if !devicePersistentTensorAllocIds.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 50)
                try codedOutputStream.writeRawVarint32(value: devicePersistentTensorAllocIdsMemoizedSerializedSize)
                for oneValuedevicePersistentTensorAllocIds in devicePersistentTensorAllocIds {
                    try codedOutputStream.writeInt64NoTag(value: oneValuedevicePersistentTensorAllocIds)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasHostTempMemorySize {
                serialize_size += hostTempMemorySize.computeInt64Size(fieldNumber: 1)
            }
            if hasDeviceTempMemorySize {
                serialize_size += deviceTempMemorySize.computeInt64Size(fieldNumber: 2)
            }
            if hasHostPersistentMemorySize {
                serialize_size += hostPersistentMemorySize.computeInt64Size(fieldNumber: 3)
            }
            if hasDevicePersistentMemorySize {
                serialize_size += devicePersistentMemorySize.computeInt64Size(fieldNumber: 4)
            }
            var dataSizeHostPersistentTensorAllocIds:Int32 = 0
            for oneValuehostPersistentTensorAllocIds in hostPersistentTensorAllocIds {
                dataSizeHostPersistentTensorAllocIds += oneValuehostPersistentTensorAllocIds.computeInt64SizeNoTag()
            }
            serialize_size += dataSizeHostPersistentTensorAllocIds
            if !hostPersistentTensorAllocIds.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeHostPersistentTensorAllocIds.computeInt32SizeNoTag()
            }
            hostPersistentTensorAllocIdsMemoizedSerializedSize = dataSizeHostPersistentTensorAllocIds
            var dataSizeDevicePersistentTensorAllocIds:Int32 = 0
            for oneValuedevicePersistentTensorAllocIds in devicePersistentTensorAllocIds {
                dataSizeDevicePersistentTensorAllocIds += oneValuedevicePersistentTensorAllocIds.computeInt64SizeNoTag()
            }
            serialize_size += dataSizeDevicePersistentTensorAllocIds
            if !devicePersistentTensorAllocIds.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeDevicePersistentTensorAllocIds.computeInt32SizeNoTag()
            }
            devicePersistentTensorAllocIdsMemoizedSerializedSize = dataSizeDevicePersistentTensorAllocIds
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.MemoryStats.Builder {
            return Tensorflow.MemoryStats.classBuilder() as! Tensorflow.MemoryStats.Builder
        }
        public func getBuilder() -> Tensorflow.MemoryStats.Builder {
            return classBuilder() as! Tensorflow.MemoryStats.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.MemoryStats.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.MemoryStats.Builder()
        }
        public func toBuilder() throws -> Tensorflow.MemoryStats.Builder {
            return try Tensorflow.MemoryStats.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.MemoryStats) throws -> Tensorflow.MemoryStats.Builder {
            return try Tensorflow.MemoryStats.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasHostTempMemorySize {
                jsonMap["hostTempMemorySize"] = "\(hostTempMemorySize)"
            }
            if hasDeviceTempMemorySize {
                jsonMap["deviceTempMemorySize"] = "\(deviceTempMemorySize)"
            }
            if hasHostPersistentMemorySize {
                jsonMap["hostPersistentMemorySize"] = "\(hostPersistentMemorySize)"
            }
            if hasDevicePersistentMemorySize {
                jsonMap["devicePersistentMemorySize"] = "\(devicePersistentMemorySize)"
            }
            if !hostPersistentTensorAllocIds.isEmpty {
                var jsonArrayHostPersistentTensorAllocIds:Array<String> = []
                for oneValueHostPersistentTensorAllocIds in hostPersistentTensorAllocIds {
                    jsonArrayHostPersistentTensorAllocIds.append("\(oneValueHostPersistentTensorAllocIds)")
                }
                jsonMap["hostPersistentTensorAllocIds"] = jsonArrayHostPersistentTensorAllocIds
            }
            if !devicePersistentTensorAllocIds.isEmpty {
                var jsonArrayDevicePersistentTensorAllocIds:Array<String> = []
                for oneValueDevicePersistentTensorAllocIds in devicePersistentTensorAllocIds {
                    jsonArrayDevicePersistentTensorAllocIds.append("\(oneValueDevicePersistentTensorAllocIds)")
                }
                jsonMap["devicePersistentTensorAllocIds"] = jsonArrayDevicePersistentTensorAllocIds
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.MemoryStats {
            return try Tensorflow.MemoryStats.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.MemoryStats {
            return try Tensorflow.MemoryStats.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasHostTempMemorySize {
                output += "\(indent) hostTempMemorySize: \(hostTempMemorySize) \n"
            }
            if hasDeviceTempMemorySize {
                output += "\(indent) deviceTempMemorySize: \(deviceTempMemorySize) \n"
            }
            if hasHostPersistentMemorySize {
                output += "\(indent) hostPersistentMemorySize: \(hostPersistentMemorySize) \n"
            }
            if hasDevicePersistentMemorySize {
                output += "\(indent) devicePersistentMemorySize: \(devicePersistentMemorySize) \n"
            }
            var hostPersistentTensorAllocIdsElementIndex:Int = 0
            for oneValueHostPersistentTensorAllocIds in hostPersistentTensorAllocIds  {
                output += "\(indent) hostPersistentTensorAllocIds[\(hostPersistentTensorAllocIdsElementIndex)]: \(oneValueHostPersistentTensorAllocIds)\n"
                hostPersistentTensorAllocIdsElementIndex += 1
            }
            var devicePersistentTensorAllocIdsElementIndex:Int = 0
            for oneValueDevicePersistentTensorAllocIds in devicePersistentTensorAllocIds  {
                output += "\(indent) devicePersistentTensorAllocIds[\(devicePersistentTensorAllocIdsElementIndex)]: \(oneValueDevicePersistentTensorAllocIds)\n"
                devicePersistentTensorAllocIdsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasHostTempMemorySize {
                    hashCode = (hashCode &* 31) &+ hostTempMemorySize.hashValue
                }
                if hasDeviceTempMemorySize {
                    hashCode = (hashCode &* 31) &+ deviceTempMemorySize.hashValue
                }
                if hasHostPersistentMemorySize {
                    hashCode = (hashCode &* 31) &+ hostPersistentMemorySize.hashValue
                }
                if hasDevicePersistentMemorySize {
                    hashCode = (hashCode &* 31) &+ devicePersistentMemorySize.hashValue
                }
                for oneValueHostPersistentTensorAllocIds in hostPersistentTensorAllocIds {
                    hashCode = (hashCode &* 31) &+ oneValueHostPersistentTensorAllocIds.hashValue
                }
                for oneValueDevicePersistentTensorAllocIds in devicePersistentTensorAllocIds {
                    hashCode = (hashCode &* 31) &+ oneValueDevicePersistentTensorAllocIds.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.MemoryStats"
        }
        override public func className() -> String {
            return "Tensorflow.MemoryStats"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.MemoryStats = Tensorflow.MemoryStats()
            public func getMessage() -> Tensorflow.MemoryStats {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var hostTempMemorySize:Int64 {
                get {
                    return builderResult.hostTempMemorySize
                }
                set (value) {
                    builderResult.hasHostTempMemorySize = true
                    builderResult.hostTempMemorySize = value
                }
            }
            public var hasHostTempMemorySize:Bool {
                get {
                    return builderResult.hasHostTempMemorySize
                }
            }
            @discardableResult
            public func setHostTempMemorySize(_ value:Int64) -> Tensorflow.MemoryStats.Builder {
                self.hostTempMemorySize = value
                return self
            }
            @discardableResult
            public func clearHostTempMemorySize() -> Tensorflow.MemoryStats.Builder{
                builderResult.hasHostTempMemorySize = false
                builderResult.hostTempMemorySize = Int64(0)
                return self
            }
            public var deviceTempMemorySize:Int64 {
                get {
                    return builderResult.deviceTempMemorySize
                }
                set (value) {
                    builderResult.hasDeviceTempMemorySize = true
                    builderResult.deviceTempMemorySize = value
                }
            }
            public var hasDeviceTempMemorySize:Bool {
                get {
                    return builderResult.hasDeviceTempMemorySize
                }
            }
            @discardableResult
            public func setDeviceTempMemorySize(_ value:Int64) -> Tensorflow.MemoryStats.Builder {
                self.deviceTempMemorySize = value
                return self
            }
            @discardableResult
            public func clearDeviceTempMemorySize() -> Tensorflow.MemoryStats.Builder{
                builderResult.hasDeviceTempMemorySize = false
                builderResult.deviceTempMemorySize = Int64(0)
                return self
            }
            public var hostPersistentMemorySize:Int64 {
                get {
                    return builderResult.hostPersistentMemorySize
                }
                set (value) {
                    builderResult.hasHostPersistentMemorySize = true
                    builderResult.hostPersistentMemorySize = value
                }
            }
            public var hasHostPersistentMemorySize:Bool {
                get {
                    return builderResult.hasHostPersistentMemorySize
                }
            }
            @discardableResult
            public func setHostPersistentMemorySize(_ value:Int64) -> Tensorflow.MemoryStats.Builder {
                self.hostPersistentMemorySize = value
                return self
            }
            @discardableResult
            public func clearHostPersistentMemorySize() -> Tensorflow.MemoryStats.Builder{
                builderResult.hasHostPersistentMemorySize = false
                builderResult.hostPersistentMemorySize = Int64(0)
                return self
            }
            public var devicePersistentMemorySize:Int64 {
                get {
                    return builderResult.devicePersistentMemorySize
                }
                set (value) {
                    builderResult.hasDevicePersistentMemorySize = true
                    builderResult.devicePersistentMemorySize = value
                }
            }
            public var hasDevicePersistentMemorySize:Bool {
                get {
                    return builderResult.hasDevicePersistentMemorySize
                }
            }
            @discardableResult
            public func setDevicePersistentMemorySize(_ value:Int64) -> Tensorflow.MemoryStats.Builder {
                self.devicePersistentMemorySize = value
                return self
            }
            @discardableResult
            public func clearDevicePersistentMemorySize() -> Tensorflow.MemoryStats.Builder{
                builderResult.hasDevicePersistentMemorySize = false
                builderResult.devicePersistentMemorySize = Int64(0)
                return self
            }
            public var hostPersistentTensorAllocIds:Array<Int64> {
                get {
                    return builderResult.hostPersistentTensorAllocIds
                }
                set (array) {
                    builderResult.hostPersistentTensorAllocIds = array
                }
            }
            @discardableResult
            public func setHostPersistentTensorAllocIds(_ value:Array<Int64>) -> Tensorflow.MemoryStats.Builder {
                self.hostPersistentTensorAllocIds = value
                return self
            }
            @discardableResult
            public func clearHostPersistentTensorAllocIds() -> Tensorflow.MemoryStats.Builder {
                builderResult.hostPersistentTensorAllocIds.removeAll(keepingCapacity: false)
                return self
            }
            public var devicePersistentTensorAllocIds:Array<Int64> {
                get {
                    return builderResult.devicePersistentTensorAllocIds
                }
                set (array) {
                    builderResult.devicePersistentTensorAllocIds = array
                }
            }
            @discardableResult
            public func setDevicePersistentTensorAllocIds(_ value:Array<Int64>) -> Tensorflow.MemoryStats.Builder {
                self.devicePersistentTensorAllocIds = value
                return self
            }
            @discardableResult
            public func clearDevicePersistentTensorAllocIds() -> Tensorflow.MemoryStats.Builder {
                builderResult.devicePersistentTensorAllocIds.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.MemoryStats.Builder {
                builderResult = Tensorflow.MemoryStats()
                return self
            }
            override public func clone() throws -> Tensorflow.MemoryStats.Builder {
                return try Tensorflow.MemoryStats.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.MemoryStats {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.MemoryStats {
                let returnMe:Tensorflow.MemoryStats = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.MemoryStats) throws -> Tensorflow.MemoryStats.Builder {
                if other == Tensorflow.MemoryStats() {
                    return self
                }
                if other.hasHostTempMemorySize {
                    hostTempMemorySize = other.hostTempMemorySize
                }
                if other.hasDeviceTempMemorySize {
                    deviceTempMemorySize = other.deviceTempMemorySize
                }
                if other.hasHostPersistentMemorySize {
                    hostPersistentMemorySize = other.hostPersistentMemorySize
                }
                if other.hasDevicePersistentMemorySize {
                    devicePersistentMemorySize = other.devicePersistentMemorySize
                }
                if !other.hostPersistentTensorAllocIds.isEmpty {
                    builderResult.hostPersistentTensorAllocIds += other.hostPersistentTensorAllocIds
                }
                if !other.devicePersistentTensorAllocIds.isEmpty {
                    builderResult.devicePersistentTensorAllocIds += other.devicePersistentTensorAllocIds
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.MemoryStats.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryStats.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        hostTempMemorySize = try codedInputStream.readInt64()

                    case 16:
                        deviceTempMemorySize = try codedInputStream.readInt64()

                    case 24:
                        hostPersistentMemorySize = try codedInputStream.readInt64()

                    case 32:
                        devicePersistentMemorySize = try codedInputStream.readInt64()

                    case 42:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.hostPersistentTensorAllocIds.append(try codedInputStream.readInt64())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 50:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.devicePersistentTensorAllocIds.append(try codedInputStream.readInt64())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.MemoryStats.Builder {
                let resultDecodedBuilder = Tensorflow.MemoryStats.Builder()
                if let jsonValueHostTempMemorySize = jsonMap["hostTempMemorySize"] as? String {
                    resultDecodedBuilder.hostTempMemorySize = Int64(jsonValueHostTempMemorySize)!
                } else if let jsonValueHostTempMemorySize = jsonMap["hostTempMemorySize"] as? Int {
                    resultDecodedBuilder.hostTempMemorySize = Int64(jsonValueHostTempMemorySize)
                }
                if let jsonValueDeviceTempMemorySize = jsonMap["deviceTempMemorySize"] as? String {
                    resultDecodedBuilder.deviceTempMemorySize = Int64(jsonValueDeviceTempMemorySize)!
                } else if let jsonValueDeviceTempMemorySize = jsonMap["deviceTempMemorySize"] as? Int {
                    resultDecodedBuilder.deviceTempMemorySize = Int64(jsonValueDeviceTempMemorySize)
                }
                if let jsonValueHostPersistentMemorySize = jsonMap["hostPersistentMemorySize"] as? String {
                    resultDecodedBuilder.hostPersistentMemorySize = Int64(jsonValueHostPersistentMemorySize)!
                } else if let jsonValueHostPersistentMemorySize = jsonMap["hostPersistentMemorySize"] as? Int {
                    resultDecodedBuilder.hostPersistentMemorySize = Int64(jsonValueHostPersistentMemorySize)
                }
                if let jsonValueDevicePersistentMemorySize = jsonMap["devicePersistentMemorySize"] as? String {
                    resultDecodedBuilder.devicePersistentMemorySize = Int64(jsonValueDevicePersistentMemorySize)!
                } else if let jsonValueDevicePersistentMemorySize = jsonMap["devicePersistentMemorySize"] as? Int {
                    resultDecodedBuilder.devicePersistentMemorySize = Int64(jsonValueDevicePersistentMemorySize)
                }
                if let jsonValueHostPersistentTensorAllocIds = jsonMap["hostPersistentTensorAllocIds"] as? Array<String> {
                    var jsonArrayHostPersistentTensorAllocIds:Array<Int64> = []
                    for oneValueHostPersistentTensorAllocIds in jsonValueHostPersistentTensorAllocIds {
                        jsonArrayHostPersistentTensorAllocIds.append(Int64(oneValueHostPersistentTensorAllocIds)!)
                    }
                    resultDecodedBuilder.hostPersistentTensorAllocIds = jsonArrayHostPersistentTensorAllocIds
                }
                if let jsonValueDevicePersistentTensorAllocIds = jsonMap["devicePersistentTensorAllocIds"] as? Array<String> {
                    var jsonArrayDevicePersistentTensorAllocIds:Array<Int64> = []
                    for oneValueDevicePersistentTensorAllocIds in jsonValueDevicePersistentTensorAllocIds {
                        jsonArrayDevicePersistentTensorAllocIds.append(Int64(oneValueDevicePersistentTensorAllocIds)!)
                    }
                    resultDecodedBuilder.devicePersistentTensorAllocIds = jsonArrayDevicePersistentTensorAllocIds
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.MemoryStats.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.MemoryStats.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Time/size stats recorded for a single execution of a graph node.
    final public class NodeExecStats : GeneratedMessage {

        public static func == (lhs: Tensorflow.NodeExecStats, rhs: Tensorflow.NodeExecStats) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasNodeName == rhs.hasNodeName) && (!lhs.hasNodeName || lhs.nodeName == rhs.nodeName)
            fieldCheck = fieldCheck && (lhs.hasAllStartMicros == rhs.hasAllStartMicros) && (!lhs.hasAllStartMicros || lhs.allStartMicros == rhs.allStartMicros)
            fieldCheck = fieldCheck && (lhs.hasOpStartRelMicros == rhs.hasOpStartRelMicros) && (!lhs.hasOpStartRelMicros || lhs.opStartRelMicros == rhs.opStartRelMicros)
            fieldCheck = fieldCheck && (lhs.hasOpEndRelMicros == rhs.hasOpEndRelMicros) && (!lhs.hasOpEndRelMicros || lhs.opEndRelMicros == rhs.opEndRelMicros)
            fieldCheck = fieldCheck && (lhs.hasAllEndRelMicros == rhs.hasAllEndRelMicros) && (!lhs.hasAllEndRelMicros || lhs.allEndRelMicros == rhs.allEndRelMicros)
            fieldCheck = fieldCheck && (lhs.memory == rhs.memory)
            fieldCheck = fieldCheck && (lhs.output == rhs.output)
            fieldCheck = fieldCheck && (lhs.hasTimelineLabel == rhs.hasTimelineLabel) && (!lhs.hasTimelineLabel || lhs.timelineLabel == rhs.timelineLabel)
            fieldCheck = fieldCheck && (lhs.hasScheduledMicros == rhs.hasScheduledMicros) && (!lhs.hasScheduledMicros || lhs.scheduledMicros == rhs.scheduledMicros)
            fieldCheck = fieldCheck && (lhs.hasThreadId == rhs.hasThreadId) && (!lhs.hasThreadId || lhs.threadId == rhs.threadId)
            fieldCheck = fieldCheck && (lhs.referencedTensor == rhs.referencedTensor)
            fieldCheck = fieldCheck && (lhs.hasMemoryStats == rhs.hasMemoryStats) && (!lhs.hasMemoryStats || lhs.memoryStats == rhs.memoryStats)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// TODO(tucker): Use some more compact form of node identity than
        /// the full string name.  Either all processes should agree on a
        /// global id (cost_id?) for each node, or we should use a hash of
        /// the name.
        public fileprivate(set) var nodeName:String = ""
        public fileprivate(set) var hasNodeName:Bool = false

        public fileprivate(set) var allStartMicros:Int64 = Int64(0)
        public fileprivate(set) var hasAllStartMicros:Bool = false

        public fileprivate(set) var opStartRelMicros:Int64 = Int64(0)
        public fileprivate(set) var hasOpStartRelMicros:Bool = false

        public fileprivate(set) var opEndRelMicros:Int64 = Int64(0)
        public fileprivate(set) var hasOpEndRelMicros:Bool = false

        public fileprivate(set) var allEndRelMicros:Int64 = Int64(0)
        public fileprivate(set) var hasAllEndRelMicros:Bool = false

        public fileprivate(set) var memory:Array<Tensorflow.AllocatorMemoryUsed>  = Array<Tensorflow.AllocatorMemoryUsed>()
        public fileprivate(set) var output:Array<Tensorflow.NodeOutput>  = Array<Tensorflow.NodeOutput>()
        public fileprivate(set) var timelineLabel:String = ""
        public fileprivate(set) var hasTimelineLabel:Bool = false

        public fileprivate(set) var scheduledMicros:Int64 = Int64(0)
        public fileprivate(set) var hasScheduledMicros:Bool = false

        public fileprivate(set) var threadId:UInt32 = UInt32(0)
        public fileprivate(set) var hasThreadId:Bool = false

        public fileprivate(set) var referencedTensor:Array<Tensorflow.AllocationDescription>  = Array<Tensorflow.AllocationDescription>()
        public fileprivate(set) var memoryStats:Tensorflow.MemoryStats!
        public fileprivate(set) var hasMemoryStats:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasNodeName {
                try codedOutputStream.writeString(fieldNumber: 1, value:nodeName)
            }
            if hasAllStartMicros {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:allStartMicros)
            }
            if hasOpStartRelMicros {
                try codedOutputStream.writeInt64(fieldNumber: 3, value:opStartRelMicros)
            }
            if hasOpEndRelMicros {
                try codedOutputStream.writeInt64(fieldNumber: 4, value:opEndRelMicros)
            }
            if hasAllEndRelMicros {
                try codedOutputStream.writeInt64(fieldNumber: 5, value:allEndRelMicros)
            }
            for oneElementMemory in memory {
                  try codedOutputStream.writeMessage(fieldNumber: 6, value:oneElementMemory)
            }
            for oneElementOutput in output {
                  try codedOutputStream.writeMessage(fieldNumber: 7, value:oneElementOutput)
            }
            if hasTimelineLabel {
                try codedOutputStream.writeString(fieldNumber: 8, value:timelineLabel)
            }
            if hasScheduledMicros {
                try codedOutputStream.writeInt64(fieldNumber: 9, value:scheduledMicros)
            }
            if hasThreadId {
                try codedOutputStream.writeUInt32(fieldNumber: 10, value:threadId)
            }
            for oneElementReferencedTensor in referencedTensor {
                  try codedOutputStream.writeMessage(fieldNumber: 11, value:oneElementReferencedTensor)
            }
            if hasMemoryStats {
                try codedOutputStream.writeMessage(fieldNumber: 12, value:memoryStats)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasNodeName {
                serialize_size += nodeName.computeStringSize(fieldNumber: 1)
            }
            if hasAllStartMicros {
                serialize_size += allStartMicros.computeInt64Size(fieldNumber: 2)
            }
            if hasOpStartRelMicros {
                serialize_size += opStartRelMicros.computeInt64Size(fieldNumber: 3)
            }
            if hasOpEndRelMicros {
                serialize_size += opEndRelMicros.computeInt64Size(fieldNumber: 4)
            }
            if hasAllEndRelMicros {
                serialize_size += allEndRelMicros.computeInt64Size(fieldNumber: 5)
            }
            for oneElementMemory in memory {
                serialize_size += oneElementMemory.computeMessageSize(fieldNumber: 6)
            }
            for oneElementOutput in output {
                serialize_size += oneElementOutput.computeMessageSize(fieldNumber: 7)
            }
            if hasTimelineLabel {
                serialize_size += timelineLabel.computeStringSize(fieldNumber: 8)
            }
            if hasScheduledMicros {
                serialize_size += scheduledMicros.computeInt64Size(fieldNumber: 9)
            }
            if hasThreadId {
                serialize_size += threadId.computeUInt32Size(fieldNumber: 10)
            }
            for oneElementReferencedTensor in referencedTensor {
                serialize_size += oneElementReferencedTensor.computeMessageSize(fieldNumber: 11)
            }
            if hasMemoryStats {
                if let varSizememoryStats = memoryStats?.computeMessageSize(fieldNumber: 12) {
                    serialize_size += varSizememoryStats
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.NodeExecStats.Builder {
            return Tensorflow.NodeExecStats.classBuilder() as! Tensorflow.NodeExecStats.Builder
        }
        public func getBuilder() -> Tensorflow.NodeExecStats.Builder {
            return classBuilder() as! Tensorflow.NodeExecStats.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.NodeExecStats.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.NodeExecStats.Builder()
        }
        public func toBuilder() throws -> Tensorflow.NodeExecStats.Builder {
            return try Tensorflow.NodeExecStats.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.NodeExecStats) throws -> Tensorflow.NodeExecStats.Builder {
            return try Tensorflow.NodeExecStats.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasNodeName {
                jsonMap["nodeName"] = nodeName
            }
            if hasAllStartMicros {
                jsonMap["allStartMicros"] = "\(allStartMicros)"
            }
            if hasOpStartRelMicros {
                jsonMap["opStartRelMicros"] = "\(opStartRelMicros)"
            }
            if hasOpEndRelMicros {
                jsonMap["opEndRelMicros"] = "\(opEndRelMicros)"
            }
            if hasAllEndRelMicros {
                jsonMap["allEndRelMicros"] = "\(allEndRelMicros)"
            }
            if !memory.isEmpty {
                var jsonArrayMemory:Array<Dictionary<String,Any>> = []
                for oneValueMemory in memory {
                    let ecodedMessageMemory = try oneValueMemory.encode()
                    jsonArrayMemory.append(ecodedMessageMemory)
                }
                jsonMap["memory"] = jsonArrayMemory
            }
            if !output.isEmpty {
                var jsonArrayOutput:Array<Dictionary<String,Any>> = []
                for oneValueOutput in output {
                    let ecodedMessageOutput = try oneValueOutput.encode()
                    jsonArrayOutput.append(ecodedMessageOutput)
                }
                jsonMap["output"] = jsonArrayOutput
            }
            if hasTimelineLabel {
                jsonMap["timelineLabel"] = timelineLabel
            }
            if hasScheduledMicros {
                jsonMap["scheduledMicros"] = "\(scheduledMicros)"
            }
            if hasThreadId {
                jsonMap["threadId"] = UInt(threadId)
            }
            if !referencedTensor.isEmpty {
                var jsonArrayReferencedTensor:Array<Dictionary<String,Any>> = []
                for oneValueReferencedTensor in referencedTensor {
                    let ecodedMessageReferencedTensor = try oneValueReferencedTensor.encode()
                    jsonArrayReferencedTensor.append(ecodedMessageReferencedTensor)
                }
                jsonMap["referencedTensor"] = jsonArrayReferencedTensor
            }
            if hasMemoryStats {
                jsonMap["memoryStats"] = try memoryStats.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.NodeExecStats {
            return try Tensorflow.NodeExecStats.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.NodeExecStats {
            return try Tensorflow.NodeExecStats.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasNodeName {
                output += "\(indent) nodeName: \(nodeName) \n"
            }
            if hasAllStartMicros {
                output += "\(indent) allStartMicros: \(allStartMicros) \n"
            }
            if hasOpStartRelMicros {
                output += "\(indent) opStartRelMicros: \(opStartRelMicros) \n"
            }
            if hasOpEndRelMicros {
                output += "\(indent) opEndRelMicros: \(opEndRelMicros) \n"
            }
            if hasAllEndRelMicros {
                output += "\(indent) allEndRelMicros: \(allEndRelMicros) \n"
            }
            var memoryElementIndex:Int = 0
            for oneElementMemory in memory {
                output += "\(indent) memory[\(memoryElementIndex)] {\n"
                output += try oneElementMemory.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                memoryElementIndex += 1
            }
            var outputElementIndex:Int = 0
            for oneElementOutput in output {
                output += "\(indent) output[\(outputElementIndex)] {\n"
                output += try oneElementOutput.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                outputElementIndex += 1
            }
            if hasTimelineLabel {
                output += "\(indent) timelineLabel: \(timelineLabel) \n"
            }
            if hasScheduledMicros {
                output += "\(indent) scheduledMicros: \(scheduledMicros) \n"
            }
            if hasThreadId {
                output += "\(indent) threadId: \(threadId) \n"
            }
            var referencedTensorElementIndex:Int = 0
            for oneElementReferencedTensor in referencedTensor {
                output += "\(indent) referencedTensor[\(referencedTensorElementIndex)] {\n"
                output += try oneElementReferencedTensor.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                referencedTensorElementIndex += 1
            }
            if hasMemoryStats {
                output += "\(indent) memoryStats {\n"
                if let outDescMemoryStats = memoryStats {
                    output += try outDescMemoryStats.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasNodeName {
                    hashCode = (hashCode &* 31) &+ nodeName.hashValue
                }
                if hasAllStartMicros {
                    hashCode = (hashCode &* 31) &+ allStartMicros.hashValue
                }
                if hasOpStartRelMicros {
                    hashCode = (hashCode &* 31) &+ opStartRelMicros.hashValue
                }
                if hasOpEndRelMicros {
                    hashCode = (hashCode &* 31) &+ opEndRelMicros.hashValue
                }
                if hasAllEndRelMicros {
                    hashCode = (hashCode &* 31) &+ allEndRelMicros.hashValue
                }
                for oneElementMemory in memory {
                    hashCode = (hashCode &* 31) &+ oneElementMemory.hashValue
                }
                for oneElementOutput in output {
                    hashCode = (hashCode &* 31) &+ oneElementOutput.hashValue
                }
                if hasTimelineLabel {
                    hashCode = (hashCode &* 31) &+ timelineLabel.hashValue
                }
                if hasScheduledMicros {
                    hashCode = (hashCode &* 31) &+ scheduledMicros.hashValue
                }
                if hasThreadId {
                    hashCode = (hashCode &* 31) &+ threadId.hashValue
                }
                for oneElementReferencedTensor in referencedTensor {
                    hashCode = (hashCode &* 31) &+ oneElementReferencedTensor.hashValue
                }
                if hasMemoryStats {
                    if let hashValuememoryStats = memoryStats?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuememoryStats
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.NodeExecStats"
        }
        override public func className() -> String {
            return "Tensorflow.NodeExecStats"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.NodeExecStats = Tensorflow.NodeExecStats()
            public func getMessage() -> Tensorflow.NodeExecStats {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// TODO(tucker): Use some more compact form of node identity than
            /// the full string name.  Either all processes should agree on a
            /// global id (cost_id?) for each node, or we should use a hash of
            /// the name.
            public var nodeName:String {
                get {
                    return builderResult.nodeName
                }
                set (value) {
                    builderResult.hasNodeName = true
                    builderResult.nodeName = value
                }
            }
            public var hasNodeName:Bool {
                get {
                    return builderResult.hasNodeName
                }
            }
            @discardableResult
            public func setNodeName(_ value:String) -> Tensorflow.NodeExecStats.Builder {
                self.nodeName = value
                return self
            }
            @discardableResult
            public func clearNodeName() -> Tensorflow.NodeExecStats.Builder{
                builderResult.hasNodeName = false
                builderResult.nodeName = ""
                return self
            }
            public var allStartMicros:Int64 {
                get {
                    return builderResult.allStartMicros
                }
                set (value) {
                    builderResult.hasAllStartMicros = true
                    builderResult.allStartMicros = value
                }
            }
            public var hasAllStartMicros:Bool {
                get {
                    return builderResult.hasAllStartMicros
                }
            }
            @discardableResult
            public func setAllStartMicros(_ value:Int64) -> Tensorflow.NodeExecStats.Builder {
                self.allStartMicros = value
                return self
            }
            @discardableResult
            public func clearAllStartMicros() -> Tensorflow.NodeExecStats.Builder{
                builderResult.hasAllStartMicros = false
                builderResult.allStartMicros = Int64(0)
                return self
            }
            public var opStartRelMicros:Int64 {
                get {
                    return builderResult.opStartRelMicros
                }
                set (value) {
                    builderResult.hasOpStartRelMicros = true
                    builderResult.opStartRelMicros = value
                }
            }
            public var hasOpStartRelMicros:Bool {
                get {
                    return builderResult.hasOpStartRelMicros
                }
            }
            @discardableResult
            public func setOpStartRelMicros(_ value:Int64) -> Tensorflow.NodeExecStats.Builder {
                self.opStartRelMicros = value
                return self
            }
            @discardableResult
            public func clearOpStartRelMicros() -> Tensorflow.NodeExecStats.Builder{
                builderResult.hasOpStartRelMicros = false
                builderResult.opStartRelMicros = Int64(0)
                return self
            }
            public var opEndRelMicros:Int64 {
                get {
                    return builderResult.opEndRelMicros
                }
                set (value) {
                    builderResult.hasOpEndRelMicros = true
                    builderResult.opEndRelMicros = value
                }
            }
            public var hasOpEndRelMicros:Bool {
                get {
                    return builderResult.hasOpEndRelMicros
                }
            }
            @discardableResult
            public func setOpEndRelMicros(_ value:Int64) -> Tensorflow.NodeExecStats.Builder {
                self.opEndRelMicros = value
                return self
            }
            @discardableResult
            public func clearOpEndRelMicros() -> Tensorflow.NodeExecStats.Builder{
                builderResult.hasOpEndRelMicros = false
                builderResult.opEndRelMicros = Int64(0)
                return self
            }
            public var allEndRelMicros:Int64 {
                get {
                    return builderResult.allEndRelMicros
                }
                set (value) {
                    builderResult.hasAllEndRelMicros = true
                    builderResult.allEndRelMicros = value
                }
            }
            public var hasAllEndRelMicros:Bool {
                get {
                    return builderResult.hasAllEndRelMicros
                }
            }
            @discardableResult
            public func setAllEndRelMicros(_ value:Int64) -> Tensorflow.NodeExecStats.Builder {
                self.allEndRelMicros = value
                return self
            }
            @discardableResult
            public func clearAllEndRelMicros() -> Tensorflow.NodeExecStats.Builder{
                builderResult.hasAllEndRelMicros = false
                builderResult.allEndRelMicros = Int64(0)
                return self
            }
            public var memory:Array<Tensorflow.AllocatorMemoryUsed> {
                get {
                    return builderResult.memory
                }
                set (value) {
                    builderResult.memory = value
                }
            }
            @discardableResult
            public func setMemory(_ value:Array<Tensorflow.AllocatorMemoryUsed>) -> Tensorflow.NodeExecStats.Builder {
                self.memory = value
                return self
            }
            @discardableResult
            public func clearMemory() -> Tensorflow.NodeExecStats.Builder {
                builderResult.memory.removeAll(keepingCapacity: false)
                return self
            }
            public var output:Array<Tensorflow.NodeOutput> {
                get {
                    return builderResult.output
                }
                set (value) {
                    builderResult.output = value
                }
            }
            @discardableResult
            public func setOutput(_ value:Array<Tensorflow.NodeOutput>) -> Tensorflow.NodeExecStats.Builder {
                self.output = value
                return self
            }
            @discardableResult
            public func clearOutput() -> Tensorflow.NodeExecStats.Builder {
                builderResult.output.removeAll(keepingCapacity: false)
                return self
            }
            public var timelineLabel:String {
                get {
                    return builderResult.timelineLabel
                }
                set (value) {
                    builderResult.hasTimelineLabel = true
                    builderResult.timelineLabel = value
                }
            }
            public var hasTimelineLabel:Bool {
                get {
                    return builderResult.hasTimelineLabel
                }
            }
            @discardableResult
            public func setTimelineLabel(_ value:String) -> Tensorflow.NodeExecStats.Builder {
                self.timelineLabel = value
                return self
            }
            @discardableResult
            public func clearTimelineLabel() -> Tensorflow.NodeExecStats.Builder{
                builderResult.hasTimelineLabel = false
                builderResult.timelineLabel = ""
                return self
            }
            public var scheduledMicros:Int64 {
                get {
                    return builderResult.scheduledMicros
                }
                set (value) {
                    builderResult.hasScheduledMicros = true
                    builderResult.scheduledMicros = value
                }
            }
            public var hasScheduledMicros:Bool {
                get {
                    return builderResult.hasScheduledMicros
                }
            }
            @discardableResult
            public func setScheduledMicros(_ value:Int64) -> Tensorflow.NodeExecStats.Builder {
                self.scheduledMicros = value
                return self
            }
            @discardableResult
            public func clearScheduledMicros() -> Tensorflow.NodeExecStats.Builder{
                builderResult.hasScheduledMicros = false
                builderResult.scheduledMicros = Int64(0)
                return self
            }
            public var threadId:UInt32 {
                get {
                    return builderResult.threadId
                }
                set (value) {
                    builderResult.hasThreadId = true
                    builderResult.threadId = value
                }
            }
            public var hasThreadId:Bool {
                get {
                    return builderResult.hasThreadId
                }
            }
            @discardableResult
            public func setThreadId(_ value:UInt32) -> Tensorflow.NodeExecStats.Builder {
                self.threadId = value
                return self
            }
            @discardableResult
            public func clearThreadId() -> Tensorflow.NodeExecStats.Builder{
                builderResult.hasThreadId = false
                builderResult.threadId = UInt32(0)
                return self
            }
            public var referencedTensor:Array<Tensorflow.AllocationDescription> {
                get {
                    return builderResult.referencedTensor
                }
                set (value) {
                    builderResult.referencedTensor = value
                }
            }
            @discardableResult
            public func setReferencedTensor(_ value:Array<Tensorflow.AllocationDescription>) -> Tensorflow.NodeExecStats.Builder {
                self.referencedTensor = value
                return self
            }
            @discardableResult
            public func clearReferencedTensor() -> Tensorflow.NodeExecStats.Builder {
                builderResult.referencedTensor.removeAll(keepingCapacity: false)
                return self
            }
            public var memoryStats:Tensorflow.MemoryStats! {
                get {
                    if memoryStatsBuilder_ != nil {
                        builderResult.memoryStats = memoryStatsBuilder_.getMessage()
                    }
                    return builderResult.memoryStats
                }
                set (value) {
                    builderResult.hasMemoryStats = true
                    builderResult.memoryStats = value
                }
            }
            public var hasMemoryStats:Bool {
                get {
                    return builderResult.hasMemoryStats
                }
            }
            fileprivate var memoryStatsBuilder_:Tensorflow.MemoryStats.Builder! {
                didSet {
                    builderResult.hasMemoryStats = true
                }
            }
            public func getMemoryStatsBuilder() -> Tensorflow.MemoryStats.Builder {
                if memoryStatsBuilder_ == nil {
                    memoryStatsBuilder_ = Tensorflow.MemoryStats.Builder()
                    builderResult.memoryStats = memoryStatsBuilder_.getMessage()
                    if memoryStats != nil {
                        try! memoryStatsBuilder_.mergeFrom(other: memoryStats)
                    }
                }
                return memoryStatsBuilder_
            }
            @discardableResult
            public func setMemoryStats(_ value:Tensorflow.MemoryStats!) -> Tensorflow.NodeExecStats.Builder {
                self.memoryStats = value
                return self
            }
            @discardableResult
            public func mergeMemoryStats(value:Tensorflow.MemoryStats) throws -> Tensorflow.NodeExecStats.Builder {
                if builderResult.hasMemoryStats {
                    builderResult.memoryStats = try Tensorflow.MemoryStats.builderWithPrototype(prototype:builderResult.memoryStats).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.memoryStats = value
                }
                builderResult.hasMemoryStats = true
                return self
            }
            @discardableResult
            public func clearMemoryStats() -> Tensorflow.NodeExecStats.Builder {
                memoryStatsBuilder_ = nil
                builderResult.hasMemoryStats = false
                builderResult.memoryStats = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.NodeExecStats.Builder {
                builderResult = Tensorflow.NodeExecStats()
                return self
            }
            override public func clone() throws -> Tensorflow.NodeExecStats.Builder {
                return try Tensorflow.NodeExecStats.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.NodeExecStats {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.NodeExecStats {
                let returnMe:Tensorflow.NodeExecStats = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.NodeExecStats) throws -> Tensorflow.NodeExecStats.Builder {
                if other == Tensorflow.NodeExecStats() {
                    return self
                }
                if other.hasNodeName {
                    nodeName = other.nodeName
                }
                if other.hasAllStartMicros {
                    allStartMicros = other.allStartMicros
                }
                if other.hasOpStartRelMicros {
                    opStartRelMicros = other.opStartRelMicros
                }
                if other.hasOpEndRelMicros {
                    opEndRelMicros = other.opEndRelMicros
                }
                if other.hasAllEndRelMicros {
                    allEndRelMicros = other.allEndRelMicros
                }
                if !other.memory.isEmpty  {
                     builderResult.memory += other.memory
                }
                if !other.output.isEmpty  {
                     builderResult.output += other.output
                }
                if other.hasTimelineLabel {
                    timelineLabel = other.timelineLabel
                }
                if other.hasScheduledMicros {
                    scheduledMicros = other.scheduledMicros
                }
                if other.hasThreadId {
                    threadId = other.threadId
                }
                if !other.referencedTensor.isEmpty  {
                     builderResult.referencedTensor += other.referencedTensor
                }
                if (other.hasMemoryStats) {
                    try mergeMemoryStats(value: other.memoryStats)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.NodeExecStats.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.NodeExecStats.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        nodeName = try codedInputStream.readString()

                    case 16:
                        allStartMicros = try codedInputStream.readInt64()

                    case 24:
                        opStartRelMicros = try codedInputStream.readInt64()

                    case 32:
                        opEndRelMicros = try codedInputStream.readInt64()

                    case 40:
                        allEndRelMicros = try codedInputStream.readInt64()

                    case 50:
                        let subBuilder = Tensorflow.AllocatorMemoryUsed.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        memory.append(subBuilder.buildPartial())

                    case 58:
                        let subBuilder = Tensorflow.NodeOutput.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        output.append(subBuilder.buildPartial())

                    case 66:
                        timelineLabel = try codedInputStream.readString()

                    case 72:
                        scheduledMicros = try codedInputStream.readInt64()

                    case 80:
                        threadId = try codedInputStream.readUInt32()

                    case 90:
                        let subBuilder = Tensorflow.AllocationDescription.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        referencedTensor.append(subBuilder.buildPartial())

                    case 98:
                        let subBuilder:Tensorflow.MemoryStats.Builder = Tensorflow.MemoryStats.Builder()
                        if hasMemoryStats {
                            try subBuilder.mergeFrom(other: memoryStats)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        memoryStats = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.NodeExecStats.Builder {
                let resultDecodedBuilder = Tensorflow.NodeExecStats.Builder()
                if let jsonValueNodeName = jsonMap["nodeName"] as? String {
                    resultDecodedBuilder.nodeName = jsonValueNodeName
                }
                if let jsonValueAllStartMicros = jsonMap["allStartMicros"] as? String {
                    resultDecodedBuilder.allStartMicros = Int64(jsonValueAllStartMicros)!
                } else if let jsonValueAllStartMicros = jsonMap["allStartMicros"] as? Int {
                    resultDecodedBuilder.allStartMicros = Int64(jsonValueAllStartMicros)
                }
                if let jsonValueOpStartRelMicros = jsonMap["opStartRelMicros"] as? String {
                    resultDecodedBuilder.opStartRelMicros = Int64(jsonValueOpStartRelMicros)!
                } else if let jsonValueOpStartRelMicros = jsonMap["opStartRelMicros"] as? Int {
                    resultDecodedBuilder.opStartRelMicros = Int64(jsonValueOpStartRelMicros)
                }
                if let jsonValueOpEndRelMicros = jsonMap["opEndRelMicros"] as? String {
                    resultDecodedBuilder.opEndRelMicros = Int64(jsonValueOpEndRelMicros)!
                } else if let jsonValueOpEndRelMicros = jsonMap["opEndRelMicros"] as? Int {
                    resultDecodedBuilder.opEndRelMicros = Int64(jsonValueOpEndRelMicros)
                }
                if let jsonValueAllEndRelMicros = jsonMap["allEndRelMicros"] as? String {
                    resultDecodedBuilder.allEndRelMicros = Int64(jsonValueAllEndRelMicros)!
                } else if let jsonValueAllEndRelMicros = jsonMap["allEndRelMicros"] as? Int {
                    resultDecodedBuilder.allEndRelMicros = Int64(jsonValueAllEndRelMicros)
                }
                if let jsonValueMemory = jsonMap["memory"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayMemory:Array<Tensorflow.AllocatorMemoryUsed> = []
                    for oneValueMemory in jsonValueMemory {
                        let messageFromStringMemory = try Tensorflow.AllocatorMemoryUsed.Builder.decodeToBuilder(jsonMap:oneValueMemory).build()

                        jsonArrayMemory.append(messageFromStringMemory)
                    }
                    resultDecodedBuilder.memory = jsonArrayMemory
                }
                if let jsonValueOutput = jsonMap["output"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayOutput:Array<Tensorflow.NodeOutput> = []
                    for oneValueOutput in jsonValueOutput {
                        let messageFromStringOutput = try Tensorflow.NodeOutput.Builder.decodeToBuilder(jsonMap:oneValueOutput).build()

                        jsonArrayOutput.append(messageFromStringOutput)
                    }
                    resultDecodedBuilder.output = jsonArrayOutput
                }
                if let jsonValueTimelineLabel = jsonMap["timelineLabel"] as? String {
                    resultDecodedBuilder.timelineLabel = jsonValueTimelineLabel
                }
                if let jsonValueScheduledMicros = jsonMap["scheduledMicros"] as? String {
                    resultDecodedBuilder.scheduledMicros = Int64(jsonValueScheduledMicros)!
                } else if let jsonValueScheduledMicros = jsonMap["scheduledMicros"] as? Int {
                    resultDecodedBuilder.scheduledMicros = Int64(jsonValueScheduledMicros)
                }
                if let jsonValueThreadId = jsonMap["threadId"] as? UInt {
                    resultDecodedBuilder.threadId = UInt32(jsonValueThreadId)
                } else if let jsonValueThreadId = jsonMap["threadId"] as? String {
                    resultDecodedBuilder.threadId = UInt32(jsonValueThreadId)!
                }
                if let jsonValueReferencedTensor = jsonMap["referencedTensor"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayReferencedTensor:Array<Tensorflow.AllocationDescription> = []
                    for oneValueReferencedTensor in jsonValueReferencedTensor {
                        let messageFromStringReferencedTensor = try Tensorflow.AllocationDescription.Builder.decodeToBuilder(jsonMap:oneValueReferencedTensor).build()

                        jsonArrayReferencedTensor.append(messageFromStringReferencedTensor)
                    }
                    resultDecodedBuilder.referencedTensor = jsonArrayReferencedTensor
                }
                if let jsonValueMemoryStats = jsonMap["memoryStats"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.memoryStats = try Tensorflow.MemoryStats.Builder.decodeToBuilder(jsonMap:jsonValueMemoryStats).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.NodeExecStats.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.NodeExecStats.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class DeviceStepStats : GeneratedMessage {

        public static func == (lhs: Tensorflow.DeviceStepStats, rhs: Tensorflow.DeviceStepStats) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasDevice == rhs.hasDevice) && (!lhs.hasDevice || lhs.device == rhs.device)
            fieldCheck = fieldCheck && (lhs.nodeStats == rhs.nodeStats)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var device:String = ""
        public fileprivate(set) var hasDevice:Bool = false

        public fileprivate(set) var nodeStats:Array<Tensorflow.NodeExecStats>  = Array<Tensorflow.NodeExecStats>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasDevice {
                try codedOutputStream.writeString(fieldNumber: 1, value:device)
            }
            for oneElementNodeStats in nodeStats {
                  try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementNodeStats)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasDevice {
                serialize_size += device.computeStringSize(fieldNumber: 1)
            }
            for oneElementNodeStats in nodeStats {
                serialize_size += oneElementNodeStats.computeMessageSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.DeviceStepStats.Builder {
            return Tensorflow.DeviceStepStats.classBuilder() as! Tensorflow.DeviceStepStats.Builder
        }
        public func getBuilder() -> Tensorflow.DeviceStepStats.Builder {
            return classBuilder() as! Tensorflow.DeviceStepStats.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.DeviceStepStats.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.DeviceStepStats.Builder()
        }
        public func toBuilder() throws -> Tensorflow.DeviceStepStats.Builder {
            return try Tensorflow.DeviceStepStats.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.DeviceStepStats) throws -> Tensorflow.DeviceStepStats.Builder {
            return try Tensorflow.DeviceStepStats.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasDevice {
                jsonMap["device"] = device
            }
            if !nodeStats.isEmpty {
                var jsonArrayNodeStats:Array<Dictionary<String,Any>> = []
                for oneValueNodeStats in nodeStats {
                    let ecodedMessageNodeStats = try oneValueNodeStats.encode()
                    jsonArrayNodeStats.append(ecodedMessageNodeStats)
                }
                jsonMap["nodeStats"] = jsonArrayNodeStats
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.DeviceStepStats {
            return try Tensorflow.DeviceStepStats.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.DeviceStepStats {
            return try Tensorflow.DeviceStepStats.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasDevice {
                output += "\(indent) device: \(device) \n"
            }
            var nodeStatsElementIndex:Int = 0
            for oneElementNodeStats in nodeStats {
                output += "\(indent) nodeStats[\(nodeStatsElementIndex)] {\n"
                output += try oneElementNodeStats.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                nodeStatsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasDevice {
                    hashCode = (hashCode &* 31) &+ device.hashValue
                }
                for oneElementNodeStats in nodeStats {
                    hashCode = (hashCode &* 31) &+ oneElementNodeStats.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.DeviceStepStats"
        }
        override public func className() -> String {
            return "Tensorflow.DeviceStepStats"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.DeviceStepStats = Tensorflow.DeviceStepStats()
            public func getMessage() -> Tensorflow.DeviceStepStats {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var device:String {
                get {
                    return builderResult.device
                }
                set (value) {
                    builderResult.hasDevice = true
                    builderResult.device = value
                }
            }
            public var hasDevice:Bool {
                get {
                    return builderResult.hasDevice
                }
            }
            @discardableResult
            public func setDevice(_ value:String) -> Tensorflow.DeviceStepStats.Builder {
                self.device = value
                return self
            }
            @discardableResult
            public func clearDevice() -> Tensorflow.DeviceStepStats.Builder{
                builderResult.hasDevice = false
                builderResult.device = ""
                return self
            }
            public var nodeStats:Array<Tensorflow.NodeExecStats> {
                get {
                    return builderResult.nodeStats
                }
                set (value) {
                    builderResult.nodeStats = value
                }
            }
            @discardableResult
            public func setNodeStats(_ value:Array<Tensorflow.NodeExecStats>) -> Tensorflow.DeviceStepStats.Builder {
                self.nodeStats = value
                return self
            }
            @discardableResult
            public func clearNodeStats() -> Tensorflow.DeviceStepStats.Builder {
                builderResult.nodeStats.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.DeviceStepStats.Builder {
                builderResult = Tensorflow.DeviceStepStats()
                return self
            }
            override public func clone() throws -> Tensorflow.DeviceStepStats.Builder {
                return try Tensorflow.DeviceStepStats.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.DeviceStepStats {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.DeviceStepStats {
                let returnMe:Tensorflow.DeviceStepStats = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.DeviceStepStats) throws -> Tensorflow.DeviceStepStats.Builder {
                if other == Tensorflow.DeviceStepStats() {
                    return self
                }
                if other.hasDevice {
                    device = other.device
                }
                if !other.nodeStats.isEmpty  {
                     builderResult.nodeStats += other.nodeStats
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.DeviceStepStats.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.DeviceStepStats.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        device = try codedInputStream.readString()

                    case 18:
                        let subBuilder = Tensorflow.NodeExecStats.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        nodeStats.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.DeviceStepStats.Builder {
                let resultDecodedBuilder = Tensorflow.DeviceStepStats.Builder()
                if let jsonValueDevice = jsonMap["device"] as? String {
                    resultDecodedBuilder.device = jsonValueDevice
                }
                if let jsonValueNodeStats = jsonMap["nodeStats"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayNodeStats:Array<Tensorflow.NodeExecStats> = []
                    for oneValueNodeStats in jsonValueNodeStats {
                        let messageFromStringNodeStats = try Tensorflow.NodeExecStats.Builder.decodeToBuilder(jsonMap:oneValueNodeStats).build()

                        jsonArrayNodeStats.append(messageFromStringNodeStats)
                    }
                    resultDecodedBuilder.nodeStats = jsonArrayNodeStats
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.DeviceStepStats.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.DeviceStepStats.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class StepStats : GeneratedMessage {

        public static func == (lhs: Tensorflow.StepStats, rhs: Tensorflow.StepStats) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.devStats == rhs.devStats)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var devStats:Array<Tensorflow.DeviceStepStats>  = Array<Tensorflow.DeviceStepStats>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementDevStats in devStats {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementDevStats)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementDevStats in devStats {
                serialize_size += oneElementDevStats.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.StepStats.Builder {
            return Tensorflow.StepStats.classBuilder() as! Tensorflow.StepStats.Builder
        }
        public func getBuilder() -> Tensorflow.StepStats.Builder {
            return classBuilder() as! Tensorflow.StepStats.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.StepStats.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.StepStats.Builder()
        }
        public func toBuilder() throws -> Tensorflow.StepStats.Builder {
            return try Tensorflow.StepStats.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.StepStats) throws -> Tensorflow.StepStats.Builder {
            return try Tensorflow.StepStats.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !devStats.isEmpty {
                var jsonArrayDevStats:Array<Dictionary<String,Any>> = []
                for oneValueDevStats in devStats {
                    let ecodedMessageDevStats = try oneValueDevStats.encode()
                    jsonArrayDevStats.append(ecodedMessageDevStats)
                }
                jsonMap["devStats"] = jsonArrayDevStats
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.StepStats {
            return try Tensorflow.StepStats.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.StepStats {
            return try Tensorflow.StepStats.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var devStatsElementIndex:Int = 0
            for oneElementDevStats in devStats {
                output += "\(indent) devStats[\(devStatsElementIndex)] {\n"
                output += try oneElementDevStats.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                devStatsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementDevStats in devStats {
                    hashCode = (hashCode &* 31) &+ oneElementDevStats.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.StepStats"
        }
        override public func className() -> String {
            return "Tensorflow.StepStats"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.StepStats = Tensorflow.StepStats()
            public func getMessage() -> Tensorflow.StepStats {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var devStats:Array<Tensorflow.DeviceStepStats> {
                get {
                    return builderResult.devStats
                }
                set (value) {
                    builderResult.devStats = value
                }
            }
            @discardableResult
            public func setDevStats(_ value:Array<Tensorflow.DeviceStepStats>) -> Tensorflow.StepStats.Builder {
                self.devStats = value
                return self
            }
            @discardableResult
            public func clearDevStats() -> Tensorflow.StepStats.Builder {
                builderResult.devStats.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.StepStats.Builder {
                builderResult = Tensorflow.StepStats()
                return self
            }
            override public func clone() throws -> Tensorflow.StepStats.Builder {
                return try Tensorflow.StepStats.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.StepStats {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.StepStats {
                let returnMe:Tensorflow.StepStats = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.StepStats) throws -> Tensorflow.StepStats.Builder {
                if other == Tensorflow.StepStats() {
                    return self
                }
                if !other.devStats.isEmpty  {
                     builderResult.devStats += other.devStats
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.StepStats.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.StepStats.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Tensorflow.DeviceStepStats.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        devStats.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.StepStats.Builder {
                let resultDecodedBuilder = Tensorflow.StepStats.Builder()
                if let jsonValueDevStats = jsonMap["devStats"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayDevStats:Array<Tensorflow.DeviceStepStats> = []
                    for oneValueDevStats in jsonValueDevStats {
                        let messageFromStringDevStats = try Tensorflow.DeviceStepStats.Builder.decodeToBuilder(jsonMap:oneValueDevStats).build()

                        jsonArrayDevStats.append(messageFromStringDevStats)
                    }
                    resultDecodedBuilder.devStats = jsonArrayDevStats
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.StepStats.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.StepStats.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.AllocatorMemoryUsed: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.AllocatorMemoryUsed> {
        var mergedArray = Array<Tensorflow.AllocatorMemoryUsed>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.AllocatorMemoryUsed? {
        return try Tensorflow.AllocatorMemoryUsed.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.AllocatorMemoryUsed {
        return try Tensorflow.AllocatorMemoryUsed.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.StepStatsRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.AllocatorMemoryUsed {
        return try Tensorflow.AllocatorMemoryUsed.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.AllocatorMemoryUsed {
        return try Tensorflow.AllocatorMemoryUsed.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.AllocatorMemoryUsed {
        return try Tensorflow.AllocatorMemoryUsed.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.AllocatorMemoryUsed {
        return try Tensorflow.AllocatorMemoryUsed.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.AllocatorMemoryUsed {
        return try Tensorflow.AllocatorMemoryUsed.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "allocatorName": return self.allocatorName
        case "totalBytes": return self.totalBytes
        case "peakBytes": return self.peakBytes
        case "liveBytes": return self.liveBytes
        default: return nil
        }
    }
}
extension Tensorflow.AllocatorMemoryUsed.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "allocatorName": return self.allocatorName
            case "totalBytes": return self.totalBytes
            case "peakBytes": return self.peakBytes
            case "liveBytes": return self.liveBytes
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "allocatorName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.allocatorName = newSubscriptValue
            case "totalBytes":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.totalBytes = newSubscriptValue
            case "peakBytes":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.peakBytes = newSubscriptValue
            case "liveBytes":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.liveBytes = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.NodeOutput: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.NodeOutput> {
        var mergedArray = Array<Tensorflow.NodeOutput>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.NodeOutput? {
        return try Tensorflow.NodeOutput.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.NodeOutput {
        return try Tensorflow.NodeOutput.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.StepStatsRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.NodeOutput {
        return try Tensorflow.NodeOutput.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.NodeOutput {
        return try Tensorflow.NodeOutput.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.NodeOutput {
        return try Tensorflow.NodeOutput.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.NodeOutput {
        return try Tensorflow.NodeOutput.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.NodeOutput {
        return try Tensorflow.NodeOutput.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "slot": return self.slot
        case "tensorDescription": return self.tensorDescription
        default: return nil
        }
    }
}
extension Tensorflow.NodeOutput.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "slot": return self.slot
            case "tensorDescription": return self.tensorDescription
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "slot":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.slot = newSubscriptValue
            case "tensorDescription":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.TensorDescription else {
                    return
                }
                self.tensorDescription = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.MemoryStats: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.MemoryStats> {
        var mergedArray = Array<Tensorflow.MemoryStats>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.MemoryStats? {
        return try Tensorflow.MemoryStats.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.MemoryStats {
        return try Tensorflow.MemoryStats.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.StepStatsRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryStats {
        return try Tensorflow.MemoryStats.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.MemoryStats {
        return try Tensorflow.MemoryStats.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryStats {
        return try Tensorflow.MemoryStats.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.MemoryStats {
        return try Tensorflow.MemoryStats.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryStats {
        return try Tensorflow.MemoryStats.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "hostTempMemorySize": return self.hostTempMemorySize
        case "deviceTempMemorySize": return self.deviceTempMemorySize
        case "hostPersistentMemorySize": return self.hostPersistentMemorySize
        case "devicePersistentMemorySize": return self.devicePersistentMemorySize
        case "hostPersistentTensorAllocIds": return self.hostPersistentTensorAllocIds
        case "devicePersistentTensorAllocIds": return self.devicePersistentTensorAllocIds
        default: return nil
        }
    }
}
extension Tensorflow.MemoryStats.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "hostTempMemorySize": return self.hostTempMemorySize
            case "deviceTempMemorySize": return self.deviceTempMemorySize
            case "hostPersistentMemorySize": return self.hostPersistentMemorySize
            case "devicePersistentMemorySize": return self.devicePersistentMemorySize
            case "hostPersistentTensorAllocIds": return self.hostPersistentTensorAllocIds
            case "devicePersistentTensorAllocIds": return self.devicePersistentTensorAllocIds
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "hostTempMemorySize":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.hostTempMemorySize = newSubscriptValue
            case "deviceTempMemorySize":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.deviceTempMemorySize = newSubscriptValue
            case "hostPersistentMemorySize":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.hostPersistentMemorySize = newSubscriptValue
            case "devicePersistentMemorySize":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.devicePersistentMemorySize = newSubscriptValue
            case "hostPersistentTensorAllocIds":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.hostPersistentTensorAllocIds = newSubscriptValue
            case "devicePersistentTensorAllocIds":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.devicePersistentTensorAllocIds = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.NodeExecStats: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.NodeExecStats> {
        var mergedArray = Array<Tensorflow.NodeExecStats>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.NodeExecStats? {
        return try Tensorflow.NodeExecStats.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.NodeExecStats {
        return try Tensorflow.NodeExecStats.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.StepStatsRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.NodeExecStats {
        return try Tensorflow.NodeExecStats.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.NodeExecStats {
        return try Tensorflow.NodeExecStats.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.NodeExecStats {
        return try Tensorflow.NodeExecStats.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.NodeExecStats {
        return try Tensorflow.NodeExecStats.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.NodeExecStats {
        return try Tensorflow.NodeExecStats.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "nodeName": return self.nodeName
        case "allStartMicros": return self.allStartMicros
        case "opStartRelMicros": return self.opStartRelMicros
        case "opEndRelMicros": return self.opEndRelMicros
        case "allEndRelMicros": return self.allEndRelMicros
        case "memory": return self.memory
        case "output": return self.output
        case "timelineLabel": return self.timelineLabel
        case "scheduledMicros": return self.scheduledMicros
        case "threadId": return self.threadId
        case "referencedTensor": return self.referencedTensor
        case "memoryStats": return self.memoryStats
        default: return nil
        }
    }
}
extension Tensorflow.NodeExecStats.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "nodeName": return self.nodeName
            case "allStartMicros": return self.allStartMicros
            case "opStartRelMicros": return self.opStartRelMicros
            case "opEndRelMicros": return self.opEndRelMicros
            case "allEndRelMicros": return self.allEndRelMicros
            case "memory": return self.memory
            case "output": return self.output
            case "timelineLabel": return self.timelineLabel
            case "scheduledMicros": return self.scheduledMicros
            case "threadId": return self.threadId
            case "referencedTensor": return self.referencedTensor
            case "memoryStats": return self.memoryStats
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "nodeName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.nodeName = newSubscriptValue
            case "allStartMicros":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.allStartMicros = newSubscriptValue
            case "opStartRelMicros":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.opStartRelMicros = newSubscriptValue
            case "opEndRelMicros":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.opEndRelMicros = newSubscriptValue
            case "allEndRelMicros":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.allEndRelMicros = newSubscriptValue
            case "memory":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.AllocatorMemoryUsed> else {
                    return
                }
                self.memory = newSubscriptValue
            case "output":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.NodeOutput> else {
                    return
                }
                self.output = newSubscriptValue
            case "timelineLabel":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.timelineLabel = newSubscriptValue
            case "scheduledMicros":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.scheduledMicros = newSubscriptValue
            case "threadId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.threadId = newSubscriptValue
            case "referencedTensor":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.AllocationDescription> else {
                    return
                }
                self.referencedTensor = newSubscriptValue
            case "memoryStats":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.MemoryStats else {
                    return
                }
                self.memoryStats = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.DeviceStepStats: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.DeviceStepStats> {
        var mergedArray = Array<Tensorflow.DeviceStepStats>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.DeviceStepStats? {
        return try Tensorflow.DeviceStepStats.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.DeviceStepStats {
        return try Tensorflow.DeviceStepStats.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.StepStatsRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.DeviceStepStats {
        return try Tensorflow.DeviceStepStats.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.DeviceStepStats {
        return try Tensorflow.DeviceStepStats.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.DeviceStepStats {
        return try Tensorflow.DeviceStepStats.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.DeviceStepStats {
        return try Tensorflow.DeviceStepStats.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.DeviceStepStats {
        return try Tensorflow.DeviceStepStats.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "device": return self.device
        case "nodeStats": return self.nodeStats
        default: return nil
        }
    }
}
extension Tensorflow.DeviceStepStats.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "device": return self.device
            case "nodeStats": return self.nodeStats
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "device":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.device = newSubscriptValue
            case "nodeStats":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.NodeExecStats> else {
                    return
                }
                self.nodeStats = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.StepStats: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.StepStats> {
        var mergedArray = Array<Tensorflow.StepStats>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.StepStats? {
        return try Tensorflow.StepStats.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.StepStats {
        return try Tensorflow.StepStats.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.StepStatsRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.StepStats {
        return try Tensorflow.StepStats.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.StepStats {
        return try Tensorflow.StepStats.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.StepStats {
        return try Tensorflow.StepStats.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.StepStats {
        return try Tensorflow.StepStats.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.StepStats {
        return try Tensorflow.StepStats.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "devStats": return self.devStats
        default: return nil
        }
    }
}
extension Tensorflow.StepStats.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "devStats": return self.devStats
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "devStats":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.DeviceStepStats> else {
                    return
                }
                self.devStats = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

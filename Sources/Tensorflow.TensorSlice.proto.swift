/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "tensor_slice.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { }

public extension Tensorflow {
    public struct TensorSliceRoot {
        public static let `default` = TensorSliceRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    /// Can only be interpreted if you know the corresponding TensorShape.
    final public class TensorSliceProto : GeneratedMessage {

        public static func == (lhs: Tensorflow.TensorSliceProto, rhs: Tensorflow.TensorSliceProto) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.extent == rhs.extent)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        /// Extent of the slice in one dimension.
        final public class Extent : GeneratedMessage {

            public static func == (lhs: Tensorflow.TensorSliceProto.Extent, rhs: Tensorflow.TensorSliceProto.Extent) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasStart == rhs.hasStart) && (!lhs.hasStart || lhs.start == rhs.start)
                fieldCheck = fieldCheck && (lhs.hasLength == rhs.hasLength) && (!lhs.hasLength || lhs.length == rhs.length)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }



            //OneOf declaration start

            /// Length of the slice: if the length is missing or -1 we will
            /// interpret this as "everything in this dimension".  We use
            /// "oneof" to preserve information about whether the length is
            /// present without changing the serialization format from the
            /// prior proto2 version of this proto.
            public enum HasLength {
                case OneOfHasLengthNotSet

                public func checkOneOfIsSet() -> Bool {
                    switch self {
                    case .OneOfHasLengthNotSet: return false
                    default: return true
                    }
                }
                case Length(Int64)

                public static func getLength(_ value:HasLength) -> Int64? {
                    switch value {
                    case .Length(let enumValue): return enumValue
                    default: return nil
                    }
                }
            }
            //OneOf declaration end

            fileprivate var storageHasLength:TensorSliceProto.Extent.HasLength =  TensorSliceProto.Extent.HasLength.OneOfHasLengthNotSet
            public func getOneOfHasLength() ->  TensorSliceProto.Extent.HasLength {
                let copyObjectHasLength = storageHasLength
                return copyObjectHasLength
            }
            /// Start index of the slice, starting at 0.
            public fileprivate(set) var start:Int64 = Int64(0)
            public fileprivate(set) var hasStart:Bool = false

            public fileprivate(set) var length:Int64!{
                get {
                    return TensorSliceProto.Extent.HasLength.getLength(storageHasLength)
                }
                set (newvalue) {
                    storageHasLength = TensorSliceProto.Extent.HasLength.Length(newvalue)
                }
            }
            public fileprivate(set) var hasLength:Bool {
                get {
                    guard let _ = TensorSliceProto.Extent.HasLength.getLength(storageHasLength) else {
                        return false
                    }
                    return true
                }
                set(newValue) {
                }
            }
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasStart {
                    try codedOutputStream.writeInt64(fieldNumber: 1, value:start)
                }
                if hasLength {
                    try codedOutputStream.writeInt64(fieldNumber: 2, value:length)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasStart {
                    serialize_size += start.computeInt64Size(fieldNumber: 1)
                }
                if hasLength {
                    serialize_size += length.computeInt64Size(fieldNumber: 2)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.TensorSliceProto.Extent.Builder {
                return Tensorflow.TensorSliceProto.Extent.classBuilder() as! Tensorflow.TensorSliceProto.Extent.Builder
            }
            public func getBuilder() -> Tensorflow.TensorSliceProto.Extent.Builder {
                return classBuilder() as! Tensorflow.TensorSliceProto.Extent.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.TensorSliceProto.Extent.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.TensorSliceProto.Extent.Builder()
            }
            public func toBuilder() throws -> Tensorflow.TensorSliceProto.Extent.Builder {
                return try Tensorflow.TensorSliceProto.Extent.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.TensorSliceProto.Extent) throws -> Tensorflow.TensorSliceProto.Extent.Builder {
                return try Tensorflow.TensorSliceProto.Extent.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasStart {
                    jsonMap["start"] = "\(start)"
                }
                if hasLength {
                    jsonMap["length"] = "\(length)"
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.TensorSliceProto.Extent {
                return try Tensorflow.TensorSliceProto.Extent.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.TensorSliceProto.Extent {
                return try Tensorflow.TensorSliceProto.Extent.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasStart {
                    output += "\(indent) start: \(start) \n"
                }
                if hasLength {
                    output += "\(indent) length: \(length) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasStart {
                        hashCode = (hashCode &* 31) &+ start.hashValue
                    }
                    if hasLength {
                        hashCode = (hashCode &* 31) &+ length.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.TensorSliceProto.Extent"
            }
            override public func className() -> String {
                return "Tensorflow.TensorSliceProto.Extent"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.TensorSliceProto.Extent = Tensorflow.TensorSliceProto.Extent()
                public func getMessage() -> Tensorflow.TensorSliceProto.Extent {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                /// Start index of the slice, starting at 0.
                public var start:Int64 {
                    get {
                        return builderResult.start
                    }
                    set (value) {
                        builderResult.hasStart = true
                        builderResult.start = value
                    }
                }
                public var hasStart:Bool {
                    get {
                        return builderResult.hasStart
                    }
                }
                @discardableResult
                public func setStart(_ value:Int64) -> Tensorflow.TensorSliceProto.Extent.Builder {
                    self.start = value
                    return self
                }
                @discardableResult
                public func clearStart() -> Tensorflow.TensorSliceProto.Extent.Builder{
                    builderResult.hasStart = false
                    builderResult.start = Int64(0)
                    return self
                }
                public var length:Int64 {
                    get {
                        return builderResult.length
                    }
                    set (value) {
                        builderResult.hasLength = true
                        builderResult.length = value
                    }
                }
                public var hasLength:Bool {
                    get {
                        return builderResult.hasLength
                    }
                }
                @discardableResult
                public func setLength(_ value:Int64) -> Tensorflow.TensorSliceProto.Extent.Builder {
                    self.length = value
                    return self
                }
                @discardableResult
                public func clearLength() -> Tensorflow.TensorSliceProto.Extent.Builder{
                    builderResult.hasLength = false
                    builderResult.length = Int64(0)
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.TensorSliceProto.Extent.Builder {
                    builderResult = Tensorflow.TensorSliceProto.Extent()
                    return self
                }
                override public func clone() throws -> Tensorflow.TensorSliceProto.Extent.Builder {
                    return try Tensorflow.TensorSliceProto.Extent.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.TensorSliceProto.Extent {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.TensorSliceProto.Extent {
                    let returnMe:Tensorflow.TensorSliceProto.Extent = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.TensorSliceProto.Extent) throws -> Tensorflow.TensorSliceProto.Extent.Builder {
                    if other == Tensorflow.TensorSliceProto.Extent() {
                        return self
                    }
                    if other.hasStart {
                        start = other.start
                    }
                    if other.hasLength {
                        length = other.length
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.TensorSliceProto.Extent.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.TensorSliceProto.Extent.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 8:
                            start = try codedInputStream.readInt64()

                        case 16:
                            length = try codedInputStream.readInt64()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.TensorSliceProto.Extent.Builder {
                    let resultDecodedBuilder = Tensorflow.TensorSliceProto.Extent.Builder()
                    if let jsonValueStart = jsonMap["start"] as? String {
                        resultDecodedBuilder.start = Int64(jsonValueStart)!
                    } else if let jsonValueStart = jsonMap["start"] as? Int {
                        resultDecodedBuilder.start = Int64(jsonValueStart)
                    }
                    if let jsonValueLength = jsonMap["length"] as? String {
                        resultDecodedBuilder.length = Int64(jsonValueLength)!
                    } else if let jsonValueLength = jsonMap["length"] as? Int {
                        resultDecodedBuilder.length = Int64(jsonValueLength)
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.TensorSliceProto.Extent.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.TensorSliceProto.Extent.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        public fileprivate(set) var extent:Array<Tensorflow.TensorSliceProto.Extent>  = Array<Tensorflow.TensorSliceProto.Extent>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementExtent in extent {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementExtent)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementExtent in extent {
                serialize_size += oneElementExtent.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.TensorSliceProto.Builder {
            return Tensorflow.TensorSliceProto.classBuilder() as! Tensorflow.TensorSliceProto.Builder
        }
        public func getBuilder() -> Tensorflow.TensorSliceProto.Builder {
            return classBuilder() as! Tensorflow.TensorSliceProto.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.TensorSliceProto.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.TensorSliceProto.Builder()
        }
        public func toBuilder() throws -> Tensorflow.TensorSliceProto.Builder {
            return try Tensorflow.TensorSliceProto.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.TensorSliceProto) throws -> Tensorflow.TensorSliceProto.Builder {
            return try Tensorflow.TensorSliceProto.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !extent.isEmpty {
                var jsonArrayExtent:Array<Dictionary<String,Any>> = []
                for oneValueExtent in extent {
                    let ecodedMessageExtent = try oneValueExtent.encode()
                    jsonArrayExtent.append(ecodedMessageExtent)
                }
                jsonMap["extent"] = jsonArrayExtent
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.TensorSliceProto {
            return try Tensorflow.TensorSliceProto.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.TensorSliceProto {
            return try Tensorflow.TensorSliceProto.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var extentElementIndex:Int = 0
            for oneElementExtent in extent {
                output += "\(indent) extent[\(extentElementIndex)] {\n"
                output += try oneElementExtent.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                extentElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementExtent in extent {
                    hashCode = (hashCode &* 31) &+ oneElementExtent.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.TensorSliceProto"
        }
        override public func className() -> String {
            return "Tensorflow.TensorSliceProto"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.TensorSliceProto = Tensorflow.TensorSliceProto()
            public func getMessage() -> Tensorflow.TensorSliceProto {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Extent of the slice in all tensor dimensions.
            /// Must have one entry for each of the dimension of the tensor that this
            /// slice belongs to.  The order of sizes is the same as the order of
            /// dimensions in the TensorShape.
            public var extent:Array<Tensorflow.TensorSliceProto.Extent> {
                get {
                    return builderResult.extent
                }
                set (value) {
                    builderResult.extent = value
                }
            }
            @discardableResult
            public func setExtent(_ value:Array<Tensorflow.TensorSliceProto.Extent>) -> Tensorflow.TensorSliceProto.Builder {
                self.extent = value
                return self
            }
            @discardableResult
            public func clearExtent() -> Tensorflow.TensorSliceProto.Builder {
                builderResult.extent.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.TensorSliceProto.Builder {
                builderResult = Tensorflow.TensorSliceProto()
                return self
            }
            override public func clone() throws -> Tensorflow.TensorSliceProto.Builder {
                return try Tensorflow.TensorSliceProto.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.TensorSliceProto {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.TensorSliceProto {
                let returnMe:Tensorflow.TensorSliceProto = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.TensorSliceProto) throws -> Tensorflow.TensorSliceProto.Builder {
                if other == Tensorflow.TensorSliceProto() {
                    return self
                }
                if !other.extent.isEmpty  {
                     builderResult.extent += other.extent
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.TensorSliceProto.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.TensorSliceProto.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Tensorflow.TensorSliceProto.Extent.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        extent.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.TensorSliceProto.Builder {
                let resultDecodedBuilder = Tensorflow.TensorSliceProto.Builder()
                if let jsonValueExtent = jsonMap["extent"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayExtent:Array<Tensorflow.TensorSliceProto.Extent> = []
                    for oneValueExtent in jsonValueExtent {
                        let messageFromStringExtent = try Tensorflow.TensorSliceProto.Extent.Builder.decodeToBuilder(jsonMap:oneValueExtent).build()

                        jsonArrayExtent.append(messageFromStringExtent)
                    }
                    resultDecodedBuilder.extent = jsonArrayExtent
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.TensorSliceProto.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.TensorSliceProto.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.TensorSliceProto: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.TensorSliceProto> {
        var mergedArray = Array<Tensorflow.TensorSliceProto>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.TensorSliceProto? {
        return try Tensorflow.TensorSliceProto.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.TensorSliceProto {
        return try Tensorflow.TensorSliceProto.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.TensorSliceRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.TensorSliceProto {
        return try Tensorflow.TensorSliceProto.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.TensorSliceProto {
        return try Tensorflow.TensorSliceProto.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.TensorSliceProto {
        return try Tensorflow.TensorSliceProto.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.TensorSliceProto {
        return try Tensorflow.TensorSliceProto.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.TensorSliceProto {
        return try Tensorflow.TensorSliceProto.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "extent": return self.extent
        default: return nil
        }
    }
}
extension Tensorflow.TensorSliceProto.Extent: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.TensorSliceProto.Extent> {
        var mergedArray = Array<Tensorflow.TensorSliceProto.Extent>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.TensorSliceProto.Extent? {
        return try Tensorflow.TensorSliceProto.Extent.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.TensorSliceProto.Extent {
        return try Tensorflow.TensorSliceProto.Extent.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.TensorSliceRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.TensorSliceProto.Extent {
        return try Tensorflow.TensorSliceProto.Extent.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.TensorSliceProto.Extent {
        return try Tensorflow.TensorSliceProto.Extent.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.TensorSliceProto.Extent {
        return try Tensorflow.TensorSliceProto.Extent.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.TensorSliceProto.Extent {
        return try Tensorflow.TensorSliceProto.Extent.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.TensorSliceProto.Extent {
        return try Tensorflow.TensorSliceProto.Extent.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "start": return self.start
        case "length": return self.length
        default: return nil
        }
    }
}
extension Tensorflow.TensorSliceProto.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "extent": return self.extent
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "extent":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.TensorSliceProto.Extent> else {
                    return
                }
                self.extent = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.TensorSliceProto.Extent.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "start": return self.start
            case "length": return self.length
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "start":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.start = newSubscriptValue
            case "length":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.length = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

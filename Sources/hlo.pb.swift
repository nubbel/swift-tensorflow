// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tensorflow/compiler/xla/service/hlo.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2017 The TensorFlow Authors. All Rights Reserved.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.
//==============================================================================

// DO NOT USE THESE PROTO MESSAGES FOR ANYTHING OTHER THAN DEBUGGING.
//
// Don't use these protos in the real compilation or execution codepaths. The
// data format is meant for debugging only, and may change without notice.
//
// Many of the protos below are simple 1-to-1 serializations of the
// corresponding C++ classes.
//
// FIELD NAMES ARE IMPORTANT
//
// Unlike most protos, you can't safely change the names of fields, even if you
// keep the numeric ids the same. This is because we sometimes serialize these
// protos as JSON, which includes the field names in the serialization.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Serialization of HloInstruction.
public struct Xla_HloInstructionProto: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".HloInstructionProto"

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var opcode: String {
    get {return _storage._opcode}
    set {_uniqueStorage()._opcode = newValue}
  }

  public var shape: Xla_Shape {
    get {return _storage._shape ?? Xla_Shape()}
    set {_uniqueStorage()._shape = newValue}
  }
  /// Returns true if `shape` has been explicitly set.
  public var hasShape: Bool {return _storage._shape != nil}
  /// Clears the value of `shape`. Subsequent reads from it will return its default value.
  public mutating func clearShape() {_storage._shape = nil}

  /// TODO(b/67782397): Replace instruction names with HloInstruction ids.
  public var operandNames: [String] {
    get {return _storage._operandNames}
    set {_uniqueStorage()._operandNames = newValue}
  }

  public var controlPredecessorNames: [String] {
    get {return _storage._controlPredecessorNames}
    set {_uniqueStorage()._controlPredecessorNames = newValue}
  }

  public var calledComputationNames: [String] {
    get {return _storage._calledComputationNames}
    set {_uniqueStorage()._calledComputationNames = newValue}
  }

  public var metadata: Xla_OpMetadata {
    get {return _storage._metadata ?? Xla_OpMetadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {_storage._metadata = nil}

  /// Literal, only present for kConstant.
  public var literal: Xla_LiteralProto {
    get {return _storage._literal ?? Xla_LiteralProto()}
    set {_uniqueStorage()._literal = newValue}
  }
  /// Returns true if `literal` has been explicitly set.
  public var hasLiteral: Bool {return _storage._literal != nil}
  /// Clears the value of `literal`. Subsequent reads from it will return its default value.
  public mutating func clearLiteral() {_storage._literal = nil}

  /// Parameter info, only present for kParameter.
  public var parameterNumber: Int64 {
    get {return _storage._parameterNumber}
    set {_uniqueStorage()._parameterNumber = newValue}
  }

  public var parameterName: String {
    get {return _storage._parameterName}
    set {_uniqueStorage()._parameterName = newValue}
  }

  /// Fusion state, only present for kFusion.
  public var fusionKind: String {
    get {return _storage._fusionKind}
    set {_uniqueStorage()._fusionKind = newValue}
  }

  public var fusedInstructionsComputation: Xla_HloComputationProto {
    get {return _storage._fusedInstructionsComputation ?? Xla_HloComputationProto()}
    set {_uniqueStorage()._fusedInstructionsComputation = newValue}
  }
  /// Returns true if `fusedInstructionsComputation` has been explicitly set.
  public var hasFusedInstructionsComputation: Bool {return _storage._fusedInstructionsComputation != nil}
  /// Clears the value of `fusedInstructionsComputation`. Subsequent reads from it will return its default value.
  public mutating func clearFusedInstructionsComputation() {_storage._fusedInstructionsComputation = nil}

  /// Index for kGetTupleElement.
  public var tupleIndex: Int64 {
    get {return _storage._tupleIndex}
    set {_uniqueStorage()._tupleIndex = newValue}
  }

  /// Dimensions present for some operations that require reshaping or
  /// broadcasting, including Reshape, Reduce, ReduceWindow, and Reverse.
  public var dimensions: [Int64] {
    get {return _storage._dimensions}
    set {_uniqueStorage()._dimensions = newValue}
  }

  /// Describes the window in a windowed operation such as convolution.
  public var window: Xla_Window {
    get {return _storage._window ?? Xla_Window()}
    set {_uniqueStorage()._window = newValue}
  }
  /// Returns true if `window` has been explicitly set.
  public var hasWindow: Bool {return _storage._window != nil}
  /// Clears the value of `window`. Subsequent reads from it will return its default value.
  public mutating func clearWindow() {_storage._window = nil}

  /// Describes the dimension numbers used for a convolution.
  public var convolutionDimensionNumbers: Xla_ConvolutionDimensionNumbers {
    get {return _storage._convolutionDimensionNumbers ?? Xla_ConvolutionDimensionNumbers()}
    set {_uniqueStorage()._convolutionDimensionNumbers = newValue}
  }
  /// Returns true if `convolutionDimensionNumbers` has been explicitly set.
  public var hasConvolutionDimensionNumbers: Bool {return _storage._convolutionDimensionNumbers != nil}
  /// Clears the value of `convolutionDimensionNumbers`. Subsequent reads from it will return its default value.
  public mutating func clearConvolutionDimensionNumbers() {_storage._convolutionDimensionNumbers = nil}

  public var sliceDimensions: [Xla_HloInstructionProto.SliceDimensions] {
    get {return _storage._sliceDimensions}
    set {_uniqueStorage()._sliceDimensions = newValue}
  }

  /// The bit sizes for a reduce-precision operation.
  public var exponentBits: Int32 {
    get {return _storage._exponentBits}
    set {_uniqueStorage()._exponentBits = newValue}
  }

  public var mantissaBits: Int32 {
    get {return _storage._mantissaBits}
    set {_uniqueStorage()._mantissaBits = newValue}
  }

  /// Describes the [start, start + size) range size for a dynamic slice
  /// ('start' is specified dynamically in the second operand of the operation).
  public var dynamicSliceSizes: [Int64] {
    get {return _storage._dynamicSliceSizes}
    set {_uniqueStorage()._dynamicSliceSizes = newValue}
  }

  /// The padding configuration that describes the edge padding and interior
  /// padding of this pad instruction. Only set for pad instructions.
  public var paddingConfig: Xla_PaddingConfig {
    get {return _storage._paddingConfig ?? Xla_PaddingConfig()}
    set {_uniqueStorage()._paddingConfig = newValue}
  }
  /// Returns true if `paddingConfig` has been explicitly set.
  public var hasPaddingConfig: Bool {return _storage._paddingConfig != nil}
  /// Clears the value of `paddingConfig`. Subsequent reads from it will return its default value.
  public mutating func clearPaddingConfig() {_storage._paddingConfig = nil}

  /// Outfeed configuration information, only present for kOutfeed.
  public var outfeedConfig: Data {
    get {return _storage._outfeedConfig}
    set {_uniqueStorage()._outfeedConfig = newValue}
  }

  /// The distribution requested for random number generation.
  /// Only present for kRng.
  public var distribution: Xla_RandomDistribution {
    get {return _storage._distribution}
    set {_uniqueStorage()._distribution = newValue}
  }

  /// A small float number added to the variance to avoid divide-by-zero error.
  /// Only present for kBatchNormTraining.
  public var epsilon: Float {
    get {return _storage._epsilon}
    set {_uniqueStorage()._epsilon = newValue}
  }

  /// An integer value representing the index of the feature dimension.
  /// Only present for kBatchNormTraining.
  public var featureIndex: Int64 {
    get {return _storage._featureIndex}
    set {_uniqueStorage()._featureIndex = newValue}
  }

  /// Represents a unique identifier for each Send/Recv instruction pair.
  /// Only present for kSend or kRecv.
  public var channelID: Int64 {
    get {return _storage._channelID}
    set {_uniqueStorage()._channelID = newValue}
  }

  /// The string representation of the infeed configuration.
  public var infeedConfig: Data {
    get {return _storage._infeedConfig}
    set {_uniqueStorage()._infeedConfig = newValue}
  }

  /// Name of a global symbol to call, only present for kCustomCall.
  public var customCallTarget: String {
    get {return _storage._customCallTarget}
    set {_uniqueStorage()._customCallTarget = newValue}
  }

  /// Shape of outfeed request.
  public var outfeedShape: Xla_Shape {
    get {return _storage._outfeedShape ?? Xla_Shape()}
    set {_uniqueStorage()._outfeedShape = newValue}
  }
  /// Returns true if `outfeedShape` has been explicitly set.
  public var hasOutfeedShape: Bool {return _storage._outfeedShape != nil}
  /// Clears the value of `outfeedShape`. Subsequent reads from it will return its default value.
  public mutating func clearOutfeedShape() {_storage._outfeedShape = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Describes the [begin, end) index range and stride for slices.
  public struct SliceDimensions: SwiftProtobuf.Message {
    public static let protoMessageName: String = Xla_HloInstructionProto.protoMessageName + ".SliceDimensions"

    public var start: Int64 = 0

    public var limit: Int64 = 0

    public var stride: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt64Field(value: &self.start)
        case 2: try decoder.decodeSingularInt64Field(value: &self.limit)
        case 3: try decoder.decodeSingularInt64Field(value: &self.stride)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if self.start != 0 {
        try visitor.visitSingularInt64Field(value: self.start, fieldNumber: 1)
      }
      if self.limit != 0 {
        try visitor.visitSingularInt64Field(value: self.limit, fieldNumber: 2)
      }
      if self.stride != 0 {
        try visitor.visitSingularInt64Field(value: self.stride, fieldNumber: 3)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularStringField(value: &_storage._opcode)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._shape)
        case 4: try decoder.decodeRepeatedStringField(value: &_storage._operandNames)
        case 5: try decoder.decodeRepeatedStringField(value: &_storage._controlPredecessorNames)
        case 6: try decoder.decodeRepeatedStringField(value: &_storage._calledComputationNames)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._literal)
        case 9: try decoder.decodeSingularInt64Field(value: &_storage._parameterNumber)
        case 10: try decoder.decodeSingularStringField(value: &_storage._parameterName)
        case 11: try decoder.decodeSingularStringField(value: &_storage._fusionKind)
        case 12: try decoder.decodeSingularMessageField(value: &_storage._fusedInstructionsComputation)
        case 13: try decoder.decodeSingularInt64Field(value: &_storage._tupleIndex)
        case 14: try decoder.decodeRepeatedInt64Field(value: &_storage._dimensions)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._window)
        case 16: try decoder.decodeSingularMessageField(value: &_storage._convolutionDimensionNumbers)
        case 17: try decoder.decodeRepeatedMessageField(value: &_storage._sliceDimensions)
        case 18: try decoder.decodeSingularInt32Field(value: &_storage._exponentBits)
        case 19: try decoder.decodeSingularInt32Field(value: &_storage._mantissaBits)
        case 20: try decoder.decodeRepeatedInt64Field(value: &_storage._dynamicSliceSizes)
        case 21: try decoder.decodeSingularMessageField(value: &_storage._paddingConfig)
        case 22: try decoder.decodeSingularBytesField(value: &_storage._outfeedConfig)
        case 23: try decoder.decodeSingularEnumField(value: &_storage._distribution)
        case 24: try decoder.decodeSingularFloatField(value: &_storage._epsilon)
        case 25: try decoder.decodeSingularInt64Field(value: &_storage._featureIndex)
        case 26: try decoder.decodeSingularInt64Field(value: &_storage._channelID)
        case 27: try decoder.decodeSingularBytesField(value: &_storage._infeedConfig)
        case 28: try decoder.decodeSingularStringField(value: &_storage._customCallTarget)
        case 29: try decoder.decodeSingularMessageField(value: &_storage._outfeedShape)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._opcode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._opcode, fieldNumber: 2)
      }
      if let v = _storage._shape {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._operandNames.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._operandNames, fieldNumber: 4)
      }
      if !_storage._controlPredecessorNames.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._controlPredecessorNames, fieldNumber: 5)
      }
      if !_storage._calledComputationNames.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._calledComputationNames, fieldNumber: 6)
      }
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._literal {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if _storage._parameterNumber != 0 {
        try visitor.visitSingularInt64Field(value: _storage._parameterNumber, fieldNumber: 9)
      }
      if !_storage._parameterName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._parameterName, fieldNumber: 10)
      }
      if !_storage._fusionKind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._fusionKind, fieldNumber: 11)
      }
      if let v = _storage._fusedInstructionsComputation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if _storage._tupleIndex != 0 {
        try visitor.visitSingularInt64Field(value: _storage._tupleIndex, fieldNumber: 13)
      }
      if !_storage._dimensions.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._dimensions, fieldNumber: 14)
      }
      if let v = _storage._window {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if let v = _storage._convolutionDimensionNumbers {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if !_storage._sliceDimensions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sliceDimensions, fieldNumber: 17)
      }
      if _storage._exponentBits != 0 {
        try visitor.visitSingularInt32Field(value: _storage._exponentBits, fieldNumber: 18)
      }
      if _storage._mantissaBits != 0 {
        try visitor.visitSingularInt32Field(value: _storage._mantissaBits, fieldNumber: 19)
      }
      if !_storage._dynamicSliceSizes.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._dynamicSliceSizes, fieldNumber: 20)
      }
      if let v = _storage._paddingConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }
      if !_storage._outfeedConfig.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._outfeedConfig, fieldNumber: 22)
      }
      if _storage._distribution != .rngInvalid {
        try visitor.visitSingularEnumField(value: _storage._distribution, fieldNumber: 23)
      }
      if _storage._epsilon != 0 {
        try visitor.visitSingularFloatField(value: _storage._epsilon, fieldNumber: 24)
      }
      if _storage._featureIndex != 0 {
        try visitor.visitSingularInt64Field(value: _storage._featureIndex, fieldNumber: 25)
      }
      if _storage._channelID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._channelID, fieldNumber: 26)
      }
      if !_storage._infeedConfig.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._infeedConfig, fieldNumber: 27)
      }
      if !_storage._customCallTarget.isEmpty {
        try visitor.visitSingularStringField(value: _storage._customCallTarget, fieldNumber: 28)
      }
      if let v = _storage._outfeedShape {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Serialization of HloComputation.
public struct Xla_HloComputationProto: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".HloComputationProto"

  public var name: String = String()

  /// The array of instructions is always in a valid dependency order, where
  /// operands appear before their users.
  public var instructions: [Xla_HloInstructionProto] = []

  /// The name of the root of the computation.
  public var rootName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.instructions)
      case 3: try decoder.decodeSingularStringField(value: &self.rootName)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.instructions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instructions, fieldNumber: 2)
    }
    if !self.rootName.isEmpty {
      try visitor.visitSingularStringField(value: self.rootName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

/// Serialization of HloModule.
public struct Xla_HloModuleProto: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".HloModuleProto"

  public var name: String = String()

  public var entryComputationName: String = String()

  /// The array of computations is always in a valid dependency order, where
  /// callees appear before their callers.
  public var computations: [Xla_HloComputationProto] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularStringField(value: &self.entryComputationName)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.computations)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.entryComputationName.isEmpty {
      try visitor.visitSingularStringField(value: self.entryComputationName, fieldNumber: 2)
    }
    if !self.computations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.computations, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

/// Serialization of HloOrdering.
public struct Xla_HloOrderingProto: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".HloOrderingProto"

  public var sequentialComputations: [Xla_HloOrderingProto.SequentialComputation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// NOTE: currently only sequential orderings are serialized.
  public struct SequentialComputation: SwiftProtobuf.Message {
    public static let protoMessageName: String = Xla_HloOrderingProto.protoMessageName + ".SequentialComputation"

    public var computationName: String = String()

    public var instructionNames: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &self.computationName)
        case 2: try decoder.decodeRepeatedStringField(value: &self.instructionNames)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.computationName.isEmpty {
        try visitor.visitSingularStringField(value: self.computationName, fieldNumber: 1)
      }
      if !self.instructionNames.isEmpty {
        try visitor.visitRepeatedStringField(value: self.instructionNames, fieldNumber: 2)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.sequentialComputations)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sequentialComputations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sequentialComputations, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

/// Serialization of LogicalBuffer.
public struct Xla_LogicalBufferProto: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".LogicalBufferProto"

  public var id: Int64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var size: Int64 {
    get {return _storage._size}
    set {_uniqueStorage()._size = newValue}
  }

  /// The location where the buffer is defined.
  public var definedAt: Xla_LogicalBufferProto.Location {
    get {return _storage._definedAt ?? Xla_LogicalBufferProto.Location()}
    set {_uniqueStorage()._definedAt = newValue}
  }
  /// Returns true if `definedAt` has been explicitly set.
  public var hasDefinedAt: Bool {return _storage._definedAt != nil}
  /// Clears the value of `definedAt`. Subsequent reads from it will return its default value.
  public mutating func clearDefinedAt() {_storage._definedAt = nil}

  public var color: Int64 {
    get {return _storage._color}
    set {_uniqueStorage()._color = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Location represents an instruction and its shape index, which uniquely
  /// identifies a point where a buffer is needed.
  public struct Location: SwiftProtobuf.Message {
    public static let protoMessageName: String = Xla_LogicalBufferProto.protoMessageName + ".Location"

    /// NOTE: module_name isn't necessary, since all LogicalBuffers are
    /// associated with a single HloModule.
    public var computationName: String = String()

    public var instructionName: String = String()

    public var shapeIndex: [Int64] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &self.computationName)
        case 2: try decoder.decodeSingularStringField(value: &self.instructionName)
        case 3: try decoder.decodeRepeatedInt64Field(value: &self.shapeIndex)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.computationName.isEmpty {
        try visitor.visitSingularStringField(value: self.computationName, fieldNumber: 1)
      }
      if !self.instructionName.isEmpty {
        try visitor.visitSingularStringField(value: self.instructionName, fieldNumber: 2)
      }
      if !self.shapeIndex.isEmpty {
        try visitor.visitPackedInt64Field(value: self.shapeIndex, fieldNumber: 3)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt64Field(value: &_storage._id)
        case 2: try decoder.decodeSingularInt64Field(value: &_storage._size)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._definedAt)
        case 4: try decoder.decodeSingularInt64Field(value: &_storage._color)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id != 0 {
        try visitor.visitSingularInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._size != 0 {
        try visitor.visitSingularInt64Field(value: _storage._size, fieldNumber: 2)
      }
      if let v = _storage._definedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if _storage._color != 0 {
        try visitor.visitSingularInt64Field(value: _storage._color, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Serialization of BufferAllocation.
public struct Xla_BufferAllocationProto: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".BufferAllocationProto"

  public var index: Int64 = 0

  public var size: Int64 = 0

  public var isThreadLocal: Bool = false

  public var isReusable: Bool = false

  public var isEntryComputationParameter: Bool = false

  public var parameterNumber: Int64 = 0

  public var maybeLiveOut: Bool = false

  public var color: Int64 = 0

  public var assigned: [Xla_BufferAllocationProto.Assigned] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Assigned represents a single LogicalBuffer that is assigned to this
  /// BufferAllocation.
  public struct Assigned: SwiftProtobuf.Message {
    public static let protoMessageName: String = Xla_BufferAllocationProto.protoMessageName + ".Assigned"

    public var logicalBufferID: Int64 = 0

    public var offset: Int64 = 0

    public var size: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt64Field(value: &self.logicalBufferID)
        case 2: try decoder.decodeSingularInt64Field(value: &self.offset)
        case 3: try decoder.decodeSingularInt64Field(value: &self.size)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if self.logicalBufferID != 0 {
        try visitor.visitSingularInt64Field(value: self.logicalBufferID, fieldNumber: 1)
      }
      if self.offset != 0 {
        try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 2)
      }
      if self.size != 0 {
        try visitor.visitSingularInt64Field(value: self.size, fieldNumber: 3)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.index)
      case 2: try decoder.decodeSingularInt64Field(value: &self.size)
      case 3: try decoder.decodeSingularBoolField(value: &self.isThreadLocal)
      case 4: try decoder.decodeSingularBoolField(value: &self.isReusable)
      case 5: try decoder.decodeSingularBoolField(value: &self.isEntryComputationParameter)
      case 6: try decoder.decodeSingularInt64Field(value: &self.parameterNumber)
      case 7: try decoder.decodeSingularBoolField(value: &self.maybeLiveOut)
      case 8: try decoder.decodeSingularInt64Field(value: &self.color)
      case 9: try decoder.decodeRepeatedMessageField(value: &self.assigned)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt64Field(value: self.size, fieldNumber: 2)
    }
    if self.isThreadLocal != false {
      try visitor.visitSingularBoolField(value: self.isThreadLocal, fieldNumber: 3)
    }
    if self.isReusable != false {
      try visitor.visitSingularBoolField(value: self.isReusable, fieldNumber: 4)
    }
    if self.isEntryComputationParameter != false {
      try visitor.visitSingularBoolField(value: self.isEntryComputationParameter, fieldNumber: 5)
    }
    if self.parameterNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.parameterNumber, fieldNumber: 6)
    }
    if self.maybeLiveOut != false {
      try visitor.visitSingularBoolField(value: self.maybeLiveOut, fieldNumber: 7)
    }
    if self.color != 0 {
      try visitor.visitSingularInt64Field(value: self.color, fieldNumber: 8)
    }
    if !self.assigned.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.assigned, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

/// A trace of a HeapSimulator run.
public struct Xla_HeapSimulatorTrace: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".HeapSimulatorTrace"

  public var events: [Xla_HeapSimulatorTrace.Event] = []

  public var wholeModuleSimulation: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The trace includes a list of events, where each event describes one action
  /// performed by the heap simulator.
  public struct Event: SwiftProtobuf.Message {
    public static let protoMessageName: String = Xla_HeapSimulatorTrace.protoMessageName + ".Event"

    public var kind: Xla_HeapSimulatorTrace.Event.Kind = .alloc

    /// The id of the LogicalBuffer that the event applies to.
    public var bufferID: Int64 = 0

    /// The HloInstruction that the simulation was processing that caused this
    /// event to occur, identified by its computation and instruction name. E.g.
    /// buffers defined by instruction A are allocated when processing A.
    public var computationName: String = String()

    public var instructionName: String = String()

    /// The id of the canonical LogicalBuffer that the buffer shares with. Only
    /// set for SHARE_WITH events.
    public var shareWithCanonicalID: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Kind: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// A memory region was allocated for the buffer.
      case alloc // = 0

      /// A memory region was freed for the buffer.
      case free // = 1

      /// A buffer was shared with another (canonical) buffer. This is similar to
      /// ALLOC, except that instead of allocating a new region of memory, the
      /// memory region of the canonical buffer is directly re-used. Multiple
      /// buffers may share with the same canonical buffer. The lifetime of the
      /// canonical buffer is extended to the union of all lifetimes.
      case shareWith // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .alloc
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .alloc
        case 1: self = .free
        case 2: self = .shareWith
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .alloc: return 0
        case .free: return 1
        case .shareWith: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &self.kind)
        case 2: try decoder.decodeSingularInt64Field(value: &self.bufferID)
        case 3: try decoder.decodeSingularStringField(value: &self.computationName)
        case 4: try decoder.decodeSingularStringField(value: &self.instructionName)
        case 5: try decoder.decodeSingularInt64Field(value: &self.shareWithCanonicalID)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if self.kind != .alloc {
        try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
      }
      if self.bufferID != 0 {
        try visitor.visitSingularInt64Field(value: self.bufferID, fieldNumber: 2)
      }
      if !self.computationName.isEmpty {
        try visitor.visitSingularStringField(value: self.computationName, fieldNumber: 3)
      }
      if !self.instructionName.isEmpty {
        try visitor.visitSingularStringField(value: self.instructionName, fieldNumber: 4)
      }
      if self.shareWithCanonicalID != 0 {
        try visitor.visitSingularInt64Field(value: self.shareWithCanonicalID, fieldNumber: 5)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.events)
      case 2: try decoder.decodeSingularBoolField(value: &self.wholeModuleSimulation)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 1)
    }
    if self.wholeModuleSimulation != false {
      try visitor.visitSingularBoolField(value: self.wholeModuleSimulation, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

/// Serialization of BufferAssignment.
public struct Xla_BufferAssignmentProto: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".BufferAssignmentProto"

  public var logicalBuffers: [Xla_LogicalBufferProto] = []

  public var bufferAliases: [Xla_BufferAssignmentProto.BufferAlias] = []

  public var bufferAllocations: [Xla_BufferAllocationProto] = []

  public var heapSimulatorTraces: [Xla_HeapSimulatorTrace] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Alias represents a source LogicalBuffer, and the buffer location that
  /// aliases it.
  public struct BufferAlias: SwiftProtobuf.Message {
    public static let protoMessageName: String = Xla_BufferAssignmentProto.protoMessageName + ".BufferAlias"

    public var sourceBufferID: Int64 {
      get {return _storage._sourceBufferID}
      set {_uniqueStorage()._sourceBufferID = newValue}
    }

    public var location: Xla_LogicalBufferProto.Location {
      get {return _storage._location ?? Xla_LogicalBufferProto.Location()}
      set {_uniqueStorage()._location = newValue}
    }
    /// Returns true if `location` has been explicitly set.
    public var hasLocation: Bool {return _storage._location != nil}
    /// Clears the value of `location`. Subsequent reads from it will return its default value.
    public mutating func clearLocation() {_storage._location = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      _ = _uniqueStorage()
      try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        while let fieldNumber = try decoder.nextFieldNumber() {
          switch fieldNumber {
          case 1: try decoder.decodeSingularInt64Field(value: &_storage._sourceBufferID)
          case 2: try decoder.decodeSingularMessageField(value: &_storage._location)
          default: break
          }
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        if _storage._sourceBufferID != 0 {
          try visitor.visitSingularInt64Field(value: _storage._sourceBufferID, fieldNumber: 1)
        }
        if let v = _storage._location {
          try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        }
      }
      try unknownFields.traverse(visitor: &visitor)
    }

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.logicalBuffers)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.bufferAliases)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.bufferAllocations)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.heapSimulatorTraces)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.logicalBuffers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.logicalBuffers, fieldNumber: 1)
    }
    if !self.bufferAliases.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bufferAliases, fieldNumber: 2)
    }
    if !self.bufferAllocations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bufferAllocations, fieldNumber: 3)
    }
    if !self.heapSimulatorTraces.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.heapSimulatorTraces, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

/// Grouping message that contains all of the information above.
public struct Xla_HloProto: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".HloProto"

  public var hloModule: Xla_HloModuleProto {
    get {return _storage._hloModule ?? Xla_HloModuleProto()}
    set {_uniqueStorage()._hloModule = newValue}
  }
  /// Returns true if `hloModule` has been explicitly set.
  public var hasHloModule: Bool {return _storage._hloModule != nil}
  /// Clears the value of `hloModule`. Subsequent reads from it will return its default value.
  public mutating func clearHloModule() {_storage._hloModule = nil}

  public var hloOrdering: Xla_HloOrderingProto {
    get {return _storage._hloOrdering ?? Xla_HloOrderingProto()}
    set {_uniqueStorage()._hloOrdering = newValue}
  }
  /// Returns true if `hloOrdering` has been explicitly set.
  public var hasHloOrdering: Bool {return _storage._hloOrdering != nil}
  /// Clears the value of `hloOrdering`. Subsequent reads from it will return its default value.
  public mutating func clearHloOrdering() {_storage._hloOrdering = nil}

  public var bufferAssignment: Xla_BufferAssignmentProto {
    get {return _storage._bufferAssignment ?? Xla_BufferAssignmentProto()}
    set {_uniqueStorage()._bufferAssignment = newValue}
  }
  /// Returns true if `bufferAssignment` has been explicitly set.
  public var hasBufferAssignment: Bool {return _storage._bufferAssignment != nil}
  /// Clears the value of `bufferAssignment`. Subsequent reads from it will return its default value.
  public mutating func clearBufferAssignment() {_storage._bufferAssignment = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._hloModule)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._hloOrdering)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._bufferAssignment)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._hloModule {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._hloOrdering {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._bufferAssignment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Xla_HloProtos: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".HloProtos"

  public var hloProtos: [Xla_HloProto] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.hloProtos)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hloProtos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hloProtos, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "xla"

extension Xla_HloInstructionProto: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "opcode"),
    3: .same(proto: "shape"),
    4: .standard(proto: "operand_names"),
    5: .standard(proto: "control_predecessor_names"),
    6: .standard(proto: "called_computation_names"),
    7: .same(proto: "metadata"),
    8: .same(proto: "literal"),
    9: .standard(proto: "parameter_number"),
    10: .standard(proto: "parameter_name"),
    11: .standard(proto: "fusion_kind"),
    12: .standard(proto: "fused_instructions_computation"),
    13: .standard(proto: "tuple_index"),
    14: .same(proto: "dimensions"),
    15: .same(proto: "window"),
    16: .standard(proto: "convolution_dimension_numbers"),
    17: .standard(proto: "slice_dimensions"),
    18: .standard(proto: "exponent_bits"),
    19: .standard(proto: "mantissa_bits"),
    20: .standard(proto: "dynamic_slice_sizes"),
    21: .standard(proto: "padding_config"),
    22: .standard(proto: "outfeed_config"),
    23: .same(proto: "distribution"),
    24: .same(proto: "epsilon"),
    25: .standard(proto: "feature_index"),
    26: .standard(proto: "channel_id"),
    27: .standard(proto: "infeed_config"),
    28: .standard(proto: "custom_call_target"),
    29: .standard(proto: "outfeed_shape"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _opcode: String = String()
    var _shape: Xla_Shape? = nil
    var _operandNames: [String] = []
    var _controlPredecessorNames: [String] = []
    var _calledComputationNames: [String] = []
    var _metadata: Xla_OpMetadata? = nil
    var _literal: Xla_LiteralProto? = nil
    var _parameterNumber: Int64 = 0
    var _parameterName: String = String()
    var _fusionKind: String = String()
    var _fusedInstructionsComputation: Xla_HloComputationProto? = nil
    var _tupleIndex: Int64 = 0
    var _dimensions: [Int64] = []
    var _window: Xla_Window? = nil
    var _convolutionDimensionNumbers: Xla_ConvolutionDimensionNumbers? = nil
    var _sliceDimensions: [Xla_HloInstructionProto.SliceDimensions] = []
    var _exponentBits: Int32 = 0
    var _mantissaBits: Int32 = 0
    var _dynamicSliceSizes: [Int64] = []
    var _paddingConfig: Xla_PaddingConfig? = nil
    var _outfeedConfig: Data = SwiftProtobuf.Internal.emptyData
    var _distribution: Xla_RandomDistribution = .rngInvalid
    var _epsilon: Float = 0
    var _featureIndex: Int64 = 0
    var _channelID: Int64 = 0
    var _infeedConfig: Data = SwiftProtobuf.Internal.emptyData
    var _customCallTarget: String = String()
    var _outfeedShape: Xla_Shape? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _opcode = source._opcode
      _shape = source._shape
      _operandNames = source._operandNames
      _controlPredecessorNames = source._controlPredecessorNames
      _calledComputationNames = source._calledComputationNames
      _metadata = source._metadata
      _literal = source._literal
      _parameterNumber = source._parameterNumber
      _parameterName = source._parameterName
      _fusionKind = source._fusionKind
      _fusedInstructionsComputation = source._fusedInstructionsComputation
      _tupleIndex = source._tupleIndex
      _dimensions = source._dimensions
      _window = source._window
      _convolutionDimensionNumbers = source._convolutionDimensionNumbers
      _sliceDimensions = source._sliceDimensions
      _exponentBits = source._exponentBits
      _mantissaBits = source._mantissaBits
      _dynamicSliceSizes = source._dynamicSliceSizes
      _paddingConfig = source._paddingConfig
      _outfeedConfig = source._outfeedConfig
      _distribution = source._distribution
      _epsilon = source._epsilon
      _featureIndex = source._featureIndex
      _channelID = source._channelID
      _infeedConfig = source._infeedConfig
      _customCallTarget = source._customCallTarget
      _outfeedShape = source._outfeedShape
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Xla_HloInstructionProto) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_storage, other_storage) in
        if _storage._name != other_storage._name {return false}
        if _storage._opcode != other_storage._opcode {return false}
        if _storage._shape != other_storage._shape {return false}
        if _storage._operandNames != other_storage._operandNames {return false}
        if _storage._controlPredecessorNames != other_storage._controlPredecessorNames {return false}
        if _storage._calledComputationNames != other_storage._calledComputationNames {return false}
        if _storage._metadata != other_storage._metadata {return false}
        if _storage._literal != other_storage._literal {return false}
        if _storage._parameterNumber != other_storage._parameterNumber {return false}
        if _storage._parameterName != other_storage._parameterName {return false}
        if _storage._fusionKind != other_storage._fusionKind {return false}
        if _storage._fusedInstructionsComputation != other_storage._fusedInstructionsComputation {return false}
        if _storage._tupleIndex != other_storage._tupleIndex {return false}
        if _storage._dimensions != other_storage._dimensions {return false}
        if _storage._window != other_storage._window {return false}
        if _storage._convolutionDimensionNumbers != other_storage._convolutionDimensionNumbers {return false}
        if _storage._sliceDimensions != other_storage._sliceDimensions {return false}
        if _storage._exponentBits != other_storage._exponentBits {return false}
        if _storage._mantissaBits != other_storage._mantissaBits {return false}
        if _storage._dynamicSliceSizes != other_storage._dynamicSliceSizes {return false}
        if _storage._paddingConfig != other_storage._paddingConfig {return false}
        if _storage._outfeedConfig != other_storage._outfeedConfig {return false}
        if _storage._distribution != other_storage._distribution {return false}
        if _storage._epsilon != other_storage._epsilon {return false}
        if _storage._featureIndex != other_storage._featureIndex {return false}
        if _storage._channelID != other_storage._channelID {return false}
        if _storage._infeedConfig != other_storage._infeedConfig {return false}
        if _storage._customCallTarget != other_storage._customCallTarget {return false}
        if _storage._outfeedShape != other_storage._outfeedShape {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_HloInstructionProto.SliceDimensions: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "limit"),
    3: .same(proto: "stride"),
  ]

  public func _protobuf_generated_isEqualTo(other: Xla_HloInstructionProto.SliceDimensions) -> Bool {
    if self.start != other.start {return false}
    if self.limit != other.limit {return false}
    if self.stride != other.stride {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_HloComputationProto: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "instructions"),
    3: .standard(proto: "root_name"),
  ]

  public func _protobuf_generated_isEqualTo(other: Xla_HloComputationProto) -> Bool {
    if self.name != other.name {return false}
    if self.instructions != other.instructions {return false}
    if self.rootName != other.rootName {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_HloModuleProto: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "entry_computation_name"),
    3: .same(proto: "computations"),
  ]

  public func _protobuf_generated_isEqualTo(other: Xla_HloModuleProto) -> Bool {
    if self.name != other.name {return false}
    if self.entryComputationName != other.entryComputationName {return false}
    if self.computations != other.computations {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_HloOrderingProto: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sequential_computations"),
  ]

  public func _protobuf_generated_isEqualTo(other: Xla_HloOrderingProto) -> Bool {
    if self.sequentialComputations != other.sequentialComputations {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_HloOrderingProto.SequentialComputation: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "computation_name"),
    2: .standard(proto: "instruction_names"),
  ]

  public func _protobuf_generated_isEqualTo(other: Xla_HloOrderingProto.SequentialComputation) -> Bool {
    if self.computationName != other.computationName {return false}
    if self.instructionNames != other.instructionNames {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_LogicalBufferProto: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "size"),
    3: .standard(proto: "defined_at"),
    4: .same(proto: "color"),
  ]

  fileprivate class _StorageClass {
    var _id: Int64 = 0
    var _size: Int64 = 0
    var _definedAt: Xla_LogicalBufferProto.Location? = nil
    var _color: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _size = source._size
      _definedAt = source._definedAt
      _color = source._color
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Xla_LogicalBufferProto) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_storage, other_storage) in
        if _storage._id != other_storage._id {return false}
        if _storage._size != other_storage._size {return false}
        if _storage._definedAt != other_storage._definedAt {return false}
        if _storage._color != other_storage._color {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_LogicalBufferProto.Location: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "computation_name"),
    2: .standard(proto: "instruction_name"),
    3: .standard(proto: "shape_index"),
  ]

  public func _protobuf_generated_isEqualTo(other: Xla_LogicalBufferProto.Location) -> Bool {
    if self.computationName != other.computationName {return false}
    if self.instructionName != other.instructionName {return false}
    if self.shapeIndex != other.shapeIndex {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_BufferAllocationProto: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "size"),
    3: .standard(proto: "is_thread_local"),
    4: .standard(proto: "is_reusable"),
    5: .standard(proto: "is_entry_computation_parameter"),
    6: .standard(proto: "parameter_number"),
    7: .standard(proto: "maybe_live_out"),
    8: .same(proto: "color"),
    9: .same(proto: "assigned"),
  ]

  public func _protobuf_generated_isEqualTo(other: Xla_BufferAllocationProto) -> Bool {
    if self.index != other.index {return false}
    if self.size != other.size {return false}
    if self.isThreadLocal != other.isThreadLocal {return false}
    if self.isReusable != other.isReusable {return false}
    if self.isEntryComputationParameter != other.isEntryComputationParameter {return false}
    if self.parameterNumber != other.parameterNumber {return false}
    if self.maybeLiveOut != other.maybeLiveOut {return false}
    if self.color != other.color {return false}
    if self.assigned != other.assigned {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_BufferAllocationProto.Assigned: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "logical_buffer_id"),
    2: .same(proto: "offset"),
    3: .same(proto: "size"),
  ]

  public func _protobuf_generated_isEqualTo(other: Xla_BufferAllocationProto.Assigned) -> Bool {
    if self.logicalBufferID != other.logicalBufferID {return false}
    if self.offset != other.offset {return false}
    if self.size != other.size {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_HeapSimulatorTrace: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "events"),
    2: .standard(proto: "whole_module_simulation"),
  ]

  public func _protobuf_generated_isEqualTo(other: Xla_HeapSimulatorTrace) -> Bool {
    if self.events != other.events {return false}
    if self.wholeModuleSimulation != other.wholeModuleSimulation {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_HeapSimulatorTrace.Event: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .standard(proto: "buffer_id"),
    3: .standard(proto: "computation_name"),
    4: .standard(proto: "instruction_name"),
    5: .standard(proto: "share_with_canonical_id"),
  ]

  public func _protobuf_generated_isEqualTo(other: Xla_HeapSimulatorTrace.Event) -> Bool {
    if self.kind != other.kind {return false}
    if self.bufferID != other.bufferID {return false}
    if self.computationName != other.computationName {return false}
    if self.instructionName != other.instructionName {return false}
    if self.shareWithCanonicalID != other.shareWithCanonicalID {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_HeapSimulatorTrace.Event.Kind: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOC"),
    1: .same(proto: "FREE"),
    2: .same(proto: "SHARE_WITH"),
  ]
}

extension Xla_BufferAssignmentProto: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "logical_buffers"),
    2: .standard(proto: "buffer_aliases"),
    3: .standard(proto: "buffer_allocations"),
    4: .standard(proto: "heap_simulator_traces"),
  ]

  public func _protobuf_generated_isEqualTo(other: Xla_BufferAssignmentProto) -> Bool {
    if self.logicalBuffers != other.logicalBuffers {return false}
    if self.bufferAliases != other.bufferAliases {return false}
    if self.bufferAllocations != other.bufferAllocations {return false}
    if self.heapSimulatorTraces != other.heapSimulatorTraces {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_BufferAssignmentProto.BufferAlias: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "source_buffer_id"),
    2: .same(proto: "location"),
  ]

  fileprivate class _StorageClass {
    var _sourceBufferID: Int64 = 0
    var _location: Xla_LogicalBufferProto.Location? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sourceBufferID = source._sourceBufferID
      _location = source._location
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Xla_BufferAssignmentProto.BufferAlias) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_storage, other_storage) in
        if _storage._sourceBufferID != other_storage._sourceBufferID {return false}
        if _storage._location != other_storage._location {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_HloProto: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hlo_module"),
    2: .standard(proto: "hlo_ordering"),
    3: .standard(proto: "buffer_assignment"),
  ]

  fileprivate class _StorageClass {
    var _hloModule: Xla_HloModuleProto? = nil
    var _hloOrdering: Xla_HloOrderingProto? = nil
    var _bufferAssignment: Xla_BufferAssignmentProto? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _hloModule = source._hloModule
      _hloOrdering = source._hloOrdering
      _bufferAssignment = source._bufferAssignment
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Xla_HloProto) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_storage, other_storage) in
        if _storage._hloModule != other_storage._hloModule {return false}
        if _storage._hloOrdering != other_storage._hloOrdering {return false}
        if _storage._bufferAssignment != other_storage._bufferAssignment {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_HloProtos: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hlo_protos"),
  ]

  public func _protobuf_generated_isEqualTo(other: Xla_HloProtos) -> Bool {
    if self.hloProtos != other.hloProtos {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

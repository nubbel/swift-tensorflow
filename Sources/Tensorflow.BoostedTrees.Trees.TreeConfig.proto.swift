/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "tree_config.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { public struct BoostedTrees { public struct Trees { }}}

public extension Tensorflow.BoostedTrees.Trees {
    public struct TreeConfigRoot {
        public static let `default` = TreeConfigRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    /// TreeNode describes a node in a tree.
    final public class TreeNode : GeneratedMessage {

        public static func == (lhs: Tensorflow.BoostedTrees.Trees.TreeNode, rhs: Tensorflow.BoostedTrees.Trees.TreeNode) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasLeaf == rhs.hasLeaf) && (!lhs.hasLeaf || lhs.leaf == rhs.leaf)
            fieldCheck = fieldCheck && (lhs.hasDenseFloatBinarySplit == rhs.hasDenseFloatBinarySplit) && (!lhs.hasDenseFloatBinarySplit || lhs.denseFloatBinarySplit == rhs.denseFloatBinarySplit)
            fieldCheck = fieldCheck && (lhs.hasSparseFloatBinarySplitDefaultLeft == rhs.hasSparseFloatBinarySplitDefaultLeft) && (!lhs.hasSparseFloatBinarySplitDefaultLeft || lhs.sparseFloatBinarySplitDefaultLeft == rhs.sparseFloatBinarySplitDefaultLeft)
            fieldCheck = fieldCheck && (lhs.hasSparseFloatBinarySplitDefaultRight == rhs.hasSparseFloatBinarySplitDefaultRight) && (!lhs.hasSparseFloatBinarySplitDefaultRight || lhs.sparseFloatBinarySplitDefaultRight == rhs.sparseFloatBinarySplitDefaultRight)
            fieldCheck = fieldCheck && (lhs.hasCategoricalIdBinarySplit == rhs.hasCategoricalIdBinarySplit) && (!lhs.hasCategoricalIdBinarySplit || lhs.categoricalIdBinarySplit == rhs.categoricalIdBinarySplit)
            fieldCheck = fieldCheck && (lhs.hasCategoricalIdSetMembershipBinarySplit == rhs.hasCategoricalIdSetMembershipBinarySplit) && (!lhs.hasCategoricalIdSetMembershipBinarySplit || lhs.categoricalIdSetMembershipBinarySplit == rhs.categoricalIdSetMembershipBinarySplit)
            fieldCheck = fieldCheck && (lhs.hasNodeMetadata == rhs.hasNodeMetadata) && (!lhs.hasNodeMetadata || lhs.nodeMetadata == rhs.nodeMetadata)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //OneOf declaration start

        public enum Node {
            case OneOfNodeNotSet

            public func checkOneOfIsSet() -> Bool {
                switch self {
                case .OneOfNodeNotSet: return false
                default: return true
                }
            }
            case Leaf(Tensorflow.BoostedTrees.Trees.Leaf)

            public static func getLeaf(_ value:Node) -> Tensorflow.BoostedTrees.Trees.Leaf? {
                switch value {
                case .Leaf(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case DenseFloatBinarySplit(Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit)

            public static func getDenseFloatBinarySplit(_ value:Node) -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit? {
                switch value {
                case .DenseFloatBinarySplit(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case SparseFloatBinarySplitDefaultLeft(Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft)

            public static func getSparseFloatBinarySplitDefaultLeft(_ value:Node) -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft? {
                switch value {
                case .SparseFloatBinarySplitDefaultLeft(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case SparseFloatBinarySplitDefaultRight(Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight)

            public static func getSparseFloatBinarySplitDefaultRight(_ value:Node) -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight? {
                switch value {
                case .SparseFloatBinarySplitDefaultRight(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case CategoricalIdBinarySplit(Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit)

            public static func getCategoricalIdBinarySplit(_ value:Node) -> Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit? {
                switch value {
                case .CategoricalIdBinarySplit(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case CategoricalIdSetMembershipBinarySplit(Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit)

            public static func getCategoricalIdSetMembershipBinarySplit(_ value:Node) -> Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit? {
                switch value {
                case .CategoricalIdSetMembershipBinarySplit(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
        }
        //OneOf declaration end

        fileprivate var storageNode:TreeNode.Node =  TreeNode.Node.OneOfNodeNotSet
        public func getOneOfNode() ->  TreeNode.Node {
            let copyObjectNode = storageNode
            return copyObjectNode
        }
        public fileprivate(set) var leaf:Tensorflow.BoostedTrees.Trees.Leaf!{
            get {
                return TreeNode.Node.getLeaf(storageNode)
            }
            set (newvalue) {
                storageNode = TreeNode.Node.Leaf(newvalue)
            }
        }
        public fileprivate(set) var hasLeaf:Bool {
            get {
                guard let _ = TreeNode.Node.getLeaf(storageNode) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var denseFloatBinarySplit:Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit!{
            get {
                return TreeNode.Node.getDenseFloatBinarySplit(storageNode)
            }
            set (newvalue) {
                storageNode = TreeNode.Node.DenseFloatBinarySplit(newvalue)
            }
        }
        public fileprivate(set) var hasDenseFloatBinarySplit:Bool {
            get {
                guard let _ = TreeNode.Node.getDenseFloatBinarySplit(storageNode) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var sparseFloatBinarySplitDefaultLeft:Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft!{
            get {
                return TreeNode.Node.getSparseFloatBinarySplitDefaultLeft(storageNode)
            }
            set (newvalue) {
                storageNode = TreeNode.Node.SparseFloatBinarySplitDefaultLeft(newvalue)
            }
        }
        public fileprivate(set) var hasSparseFloatBinarySplitDefaultLeft:Bool {
            get {
                guard let _ = TreeNode.Node.getSparseFloatBinarySplitDefaultLeft(storageNode) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var sparseFloatBinarySplitDefaultRight:Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight!{
            get {
                return TreeNode.Node.getSparseFloatBinarySplitDefaultRight(storageNode)
            }
            set (newvalue) {
                storageNode = TreeNode.Node.SparseFloatBinarySplitDefaultRight(newvalue)
            }
        }
        public fileprivate(set) var hasSparseFloatBinarySplitDefaultRight:Bool {
            get {
                guard let _ = TreeNode.Node.getSparseFloatBinarySplitDefaultRight(storageNode) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var categoricalIdBinarySplit:Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit!{
            get {
                return TreeNode.Node.getCategoricalIdBinarySplit(storageNode)
            }
            set (newvalue) {
                storageNode = TreeNode.Node.CategoricalIdBinarySplit(newvalue)
            }
        }
        public fileprivate(set) var hasCategoricalIdBinarySplit:Bool {
            get {
                guard let _ = TreeNode.Node.getCategoricalIdBinarySplit(storageNode) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var categoricalIdSetMembershipBinarySplit:Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit!{
            get {
                return TreeNode.Node.getCategoricalIdSetMembershipBinarySplit(storageNode)
            }
            set (newvalue) {
                storageNode = TreeNode.Node.CategoricalIdSetMembershipBinarySplit(newvalue)
            }
        }
        public fileprivate(set) var hasCategoricalIdSetMembershipBinarySplit:Bool {
            get {
                guard let _ = TreeNode.Node.getCategoricalIdSetMembershipBinarySplit(storageNode) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var nodeMetadata:Tensorflow.BoostedTrees.Trees.TreeNodeMetadata!
        public fileprivate(set) var hasNodeMetadata:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasLeaf {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:leaf)
            }
            if hasDenseFloatBinarySplit {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:denseFloatBinarySplit)
            }
            if hasSparseFloatBinarySplitDefaultLeft {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:sparseFloatBinarySplitDefaultLeft)
            }
            if hasSparseFloatBinarySplitDefaultRight {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:sparseFloatBinarySplitDefaultRight)
            }
            if hasCategoricalIdBinarySplit {
                try codedOutputStream.writeMessage(fieldNumber: 5, value:categoricalIdBinarySplit)
            }
            if hasCategoricalIdSetMembershipBinarySplit {
                try codedOutputStream.writeMessage(fieldNumber: 6, value:categoricalIdSetMembershipBinarySplit)
            }
            if hasNodeMetadata {
                try codedOutputStream.writeMessage(fieldNumber: 777, value:nodeMetadata)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasLeaf {
                if let varSizeleaf = leaf?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeleaf
                }
            }
            if hasDenseFloatBinarySplit {
                if let varSizedenseFloatBinarySplit = denseFloatBinarySplit?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizedenseFloatBinarySplit
                }
            }
            if hasSparseFloatBinarySplitDefaultLeft {
                if let varSizesparseFloatBinarySplitDefaultLeft = sparseFloatBinarySplitDefaultLeft?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizesparseFloatBinarySplitDefaultLeft
                }
            }
            if hasSparseFloatBinarySplitDefaultRight {
                if let varSizesparseFloatBinarySplitDefaultRight = sparseFloatBinarySplitDefaultRight?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizesparseFloatBinarySplitDefaultRight
                }
            }
            if hasCategoricalIdBinarySplit {
                if let varSizecategoricalIdBinarySplit = categoricalIdBinarySplit?.computeMessageSize(fieldNumber: 5) {
                    serialize_size += varSizecategoricalIdBinarySplit
                }
            }
            if hasCategoricalIdSetMembershipBinarySplit {
                if let varSizecategoricalIdSetMembershipBinarySplit = categoricalIdSetMembershipBinarySplit?.computeMessageSize(fieldNumber: 6) {
                    serialize_size += varSizecategoricalIdSetMembershipBinarySplit
                }
            }
            if hasNodeMetadata {
                if let varSizenodeMetadata = nodeMetadata?.computeMessageSize(fieldNumber: 777) {
                    serialize_size += varSizenodeMetadata
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.BoostedTrees.Trees.TreeNode.Builder {
            return Tensorflow.BoostedTrees.Trees.TreeNode.classBuilder() as! Tensorflow.BoostedTrees.Trees.TreeNode.Builder
        }
        public func getBuilder() -> Tensorflow.BoostedTrees.Trees.TreeNode.Builder {
            return classBuilder() as! Tensorflow.BoostedTrees.Trees.TreeNode.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Trees.TreeNode.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Trees.TreeNode.Builder()
        }
        public func toBuilder() throws -> Tensorflow.BoostedTrees.Trees.TreeNode.Builder {
            return try Tensorflow.BoostedTrees.Trees.TreeNode.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.BoostedTrees.Trees.TreeNode) throws -> Tensorflow.BoostedTrees.Trees.TreeNode.Builder {
            return try Tensorflow.BoostedTrees.Trees.TreeNode.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasLeaf {
                jsonMap["leaf"] = try leaf.encode()
            }
            if hasDenseFloatBinarySplit {
                jsonMap["denseFloatBinarySplit"] = try denseFloatBinarySplit.encode()
            }
            if hasSparseFloatBinarySplitDefaultLeft {
                jsonMap["sparseFloatBinarySplitDefaultLeft"] = try sparseFloatBinarySplitDefaultLeft.encode()
            }
            if hasSparseFloatBinarySplitDefaultRight {
                jsonMap["sparseFloatBinarySplitDefaultRight"] = try sparseFloatBinarySplitDefaultRight.encode()
            }
            if hasCategoricalIdBinarySplit {
                jsonMap["categoricalIdBinarySplit"] = try categoricalIdBinarySplit.encode()
            }
            if hasCategoricalIdSetMembershipBinarySplit {
                jsonMap["categoricalIdSetMembershipBinarySplit"] = try categoricalIdSetMembershipBinarySplit.encode()
            }
            if hasNodeMetadata {
                jsonMap["nodeMetadata"] = try nodeMetadata.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Trees.TreeNode {
            return try Tensorflow.BoostedTrees.Trees.TreeNode.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.BoostedTrees.Trees.TreeNode {
            return try Tensorflow.BoostedTrees.Trees.TreeNode.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasLeaf {
                output += "\(indent) leaf {\n"
                if let outDescLeaf = leaf {
                    output += try outDescLeaf.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasDenseFloatBinarySplit {
                output += "\(indent) denseFloatBinarySplit {\n"
                if let outDescDenseFloatBinarySplit = denseFloatBinarySplit {
                    output += try outDescDenseFloatBinarySplit.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasSparseFloatBinarySplitDefaultLeft {
                output += "\(indent) sparseFloatBinarySplitDefaultLeft {\n"
                if let outDescSparseFloatBinarySplitDefaultLeft = sparseFloatBinarySplitDefaultLeft {
                    output += try outDescSparseFloatBinarySplitDefaultLeft.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasSparseFloatBinarySplitDefaultRight {
                output += "\(indent) sparseFloatBinarySplitDefaultRight {\n"
                if let outDescSparseFloatBinarySplitDefaultRight = sparseFloatBinarySplitDefaultRight {
                    output += try outDescSparseFloatBinarySplitDefaultRight.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasCategoricalIdBinarySplit {
                output += "\(indent) categoricalIdBinarySplit {\n"
                if let outDescCategoricalIdBinarySplit = categoricalIdBinarySplit {
                    output += try outDescCategoricalIdBinarySplit.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasCategoricalIdSetMembershipBinarySplit {
                output += "\(indent) categoricalIdSetMembershipBinarySplit {\n"
                if let outDescCategoricalIdSetMembershipBinarySplit = categoricalIdSetMembershipBinarySplit {
                    output += try outDescCategoricalIdSetMembershipBinarySplit.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasNodeMetadata {
                output += "\(indent) nodeMetadata {\n"
                if let outDescNodeMetadata = nodeMetadata {
                    output += try outDescNodeMetadata.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasLeaf {
                    if let hashValueleaf = leaf?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueleaf
                    }
                }
                if hasDenseFloatBinarySplit {
                    if let hashValuedenseFloatBinarySplit = denseFloatBinarySplit?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuedenseFloatBinarySplit
                    }
                }
                if hasSparseFloatBinarySplitDefaultLeft {
                    if let hashValuesparseFloatBinarySplitDefaultLeft = sparseFloatBinarySplitDefaultLeft?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuesparseFloatBinarySplitDefaultLeft
                    }
                }
                if hasSparseFloatBinarySplitDefaultRight {
                    if let hashValuesparseFloatBinarySplitDefaultRight = sparseFloatBinarySplitDefaultRight?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuesparseFloatBinarySplitDefaultRight
                    }
                }
                if hasCategoricalIdBinarySplit {
                    if let hashValuecategoricalIdBinarySplit = categoricalIdBinarySplit?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecategoricalIdBinarySplit
                    }
                }
                if hasCategoricalIdSetMembershipBinarySplit {
                    if let hashValuecategoricalIdSetMembershipBinarySplit = categoricalIdSetMembershipBinarySplit?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecategoricalIdSetMembershipBinarySplit
                    }
                }
                if hasNodeMetadata {
                    if let hashValuenodeMetadata = nodeMetadata?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuenodeMetadata
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.BoostedTrees.Trees.TreeNode"
        }
        override public func className() -> String {
            return "Tensorflow.BoostedTrees.Trees.TreeNode"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.BoostedTrees.Trees.TreeNode = Tensorflow.BoostedTrees.Trees.TreeNode()
            public func getMessage() -> Tensorflow.BoostedTrees.Trees.TreeNode {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var leaf:Tensorflow.BoostedTrees.Trees.Leaf! {
                get {
                    if leafBuilder_ != nil {
                        builderResult.leaf = leafBuilder_.getMessage()
                    }
                    return builderResult.leaf
                }
                set (value) {
                    builderResult.hasLeaf = true
                    builderResult.leaf = value
                }
            }
            public var hasLeaf:Bool {
                get {
                    return builderResult.hasLeaf
                }
            }
            fileprivate var leafBuilder_:Tensorflow.BoostedTrees.Trees.Leaf.Builder! {
                didSet {
                    builderResult.hasLeaf = true
                }
            }
            public func getLeafBuilder() -> Tensorflow.BoostedTrees.Trees.Leaf.Builder {
                if leafBuilder_ == nil {
                    leafBuilder_ = Tensorflow.BoostedTrees.Trees.Leaf.Builder()
                    builderResult.leaf = leafBuilder_.getMessage()
                    if leaf != nil {
                        try! leafBuilder_.mergeFrom(other: leaf)
                    }
                }
                return leafBuilder_
            }
            @discardableResult
            public func setLeaf(_ value:Tensorflow.BoostedTrees.Trees.Leaf!) -> Tensorflow.BoostedTrees.Trees.TreeNode.Builder {
                self.leaf = value
                return self
            }
            @discardableResult
            public func mergeLeaf(value:Tensorflow.BoostedTrees.Trees.Leaf) throws -> Tensorflow.BoostedTrees.Trees.TreeNode.Builder {
                if builderResult.hasLeaf {
                    builderResult.leaf = try Tensorflow.BoostedTrees.Trees.Leaf.builderWithPrototype(prototype:builderResult.leaf).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.leaf = value
                }
                builderResult.hasLeaf = true
                return self
            }
            @discardableResult
            public func clearLeaf() -> Tensorflow.BoostedTrees.Trees.TreeNode.Builder {
                leafBuilder_ = nil
                builderResult.hasLeaf = false
                builderResult.leaf = nil
                return self
            }
            public var denseFloatBinarySplit:Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit! {
                get {
                    if denseFloatBinarySplitBuilder_ != nil {
                        builderResult.denseFloatBinarySplit = denseFloatBinarySplitBuilder_.getMessage()
                    }
                    return builderResult.denseFloatBinarySplit
                }
                set (value) {
                    builderResult.hasDenseFloatBinarySplit = true
                    builderResult.denseFloatBinarySplit = value
                }
            }
            public var hasDenseFloatBinarySplit:Bool {
                get {
                    return builderResult.hasDenseFloatBinarySplit
                }
            }
            fileprivate var denseFloatBinarySplitBuilder_:Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder! {
                didSet {
                    builderResult.hasDenseFloatBinarySplit = true
                }
            }
            public func getDenseFloatBinarySplitBuilder() -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder {
                if denseFloatBinarySplitBuilder_ == nil {
                    denseFloatBinarySplitBuilder_ = Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder()
                    builderResult.denseFloatBinarySplit = denseFloatBinarySplitBuilder_.getMessage()
                    if denseFloatBinarySplit != nil {
                        try! denseFloatBinarySplitBuilder_.mergeFrom(other: denseFloatBinarySplit)
                    }
                }
                return denseFloatBinarySplitBuilder_
            }
            @discardableResult
            public func setDenseFloatBinarySplit(_ value:Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit!) -> Tensorflow.BoostedTrees.Trees.TreeNode.Builder {
                self.denseFloatBinarySplit = value
                return self
            }
            @discardableResult
            public func mergeDenseFloatBinarySplit(value:Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit) throws -> Tensorflow.BoostedTrees.Trees.TreeNode.Builder {
                if builderResult.hasDenseFloatBinarySplit {
                    builderResult.denseFloatBinarySplit = try Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.builderWithPrototype(prototype:builderResult.denseFloatBinarySplit).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.denseFloatBinarySplit = value
                }
                builderResult.hasDenseFloatBinarySplit = true
                return self
            }
            @discardableResult
            public func clearDenseFloatBinarySplit() -> Tensorflow.BoostedTrees.Trees.TreeNode.Builder {
                denseFloatBinarySplitBuilder_ = nil
                builderResult.hasDenseFloatBinarySplit = false
                builderResult.denseFloatBinarySplit = nil
                return self
            }
            public var sparseFloatBinarySplitDefaultLeft:Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft! {
                get {
                    if sparseFloatBinarySplitDefaultLeftBuilder_ != nil {
                        builderResult.sparseFloatBinarySplitDefaultLeft = sparseFloatBinarySplitDefaultLeftBuilder_.getMessage()
                    }
                    return builderResult.sparseFloatBinarySplitDefaultLeft
                }
                set (value) {
                    builderResult.hasSparseFloatBinarySplitDefaultLeft = true
                    builderResult.sparseFloatBinarySplitDefaultLeft = value
                }
            }
            public var hasSparseFloatBinarySplitDefaultLeft:Bool {
                get {
                    return builderResult.hasSparseFloatBinarySplitDefaultLeft
                }
            }
            fileprivate var sparseFloatBinarySplitDefaultLeftBuilder_:Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder! {
                didSet {
                    builderResult.hasSparseFloatBinarySplitDefaultLeft = true
                }
            }
            public func getSparseFloatBinarySplitDefaultLeftBuilder() -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder {
                if sparseFloatBinarySplitDefaultLeftBuilder_ == nil {
                    sparseFloatBinarySplitDefaultLeftBuilder_ = Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder()
                    builderResult.sparseFloatBinarySplitDefaultLeft = sparseFloatBinarySplitDefaultLeftBuilder_.getMessage()
                    if sparseFloatBinarySplitDefaultLeft != nil {
                        try! sparseFloatBinarySplitDefaultLeftBuilder_.mergeFrom(other: sparseFloatBinarySplitDefaultLeft)
                    }
                }
                return sparseFloatBinarySplitDefaultLeftBuilder_
            }
            @discardableResult
            public func setSparseFloatBinarySplitDefaultLeft(_ value:Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft!) -> Tensorflow.BoostedTrees.Trees.TreeNode.Builder {
                self.sparseFloatBinarySplitDefaultLeft = value
                return self
            }
            @discardableResult
            public func mergeSparseFloatBinarySplitDefaultLeft(value:Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft) throws -> Tensorflow.BoostedTrees.Trees.TreeNode.Builder {
                if builderResult.hasSparseFloatBinarySplitDefaultLeft {
                    builderResult.sparseFloatBinarySplitDefaultLeft = try Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.builderWithPrototype(prototype:builderResult.sparseFloatBinarySplitDefaultLeft).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.sparseFloatBinarySplitDefaultLeft = value
                }
                builderResult.hasSparseFloatBinarySplitDefaultLeft = true
                return self
            }
            @discardableResult
            public func clearSparseFloatBinarySplitDefaultLeft() -> Tensorflow.BoostedTrees.Trees.TreeNode.Builder {
                sparseFloatBinarySplitDefaultLeftBuilder_ = nil
                builderResult.hasSparseFloatBinarySplitDefaultLeft = false
                builderResult.sparseFloatBinarySplitDefaultLeft = nil
                return self
            }
            public var sparseFloatBinarySplitDefaultRight:Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight! {
                get {
                    if sparseFloatBinarySplitDefaultRightBuilder_ != nil {
                        builderResult.sparseFloatBinarySplitDefaultRight = sparseFloatBinarySplitDefaultRightBuilder_.getMessage()
                    }
                    return builderResult.sparseFloatBinarySplitDefaultRight
                }
                set (value) {
                    builderResult.hasSparseFloatBinarySplitDefaultRight = true
                    builderResult.sparseFloatBinarySplitDefaultRight = value
                }
            }
            public var hasSparseFloatBinarySplitDefaultRight:Bool {
                get {
                    return builderResult.hasSparseFloatBinarySplitDefaultRight
                }
            }
            fileprivate var sparseFloatBinarySplitDefaultRightBuilder_:Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder! {
                didSet {
                    builderResult.hasSparseFloatBinarySplitDefaultRight = true
                }
            }
            public func getSparseFloatBinarySplitDefaultRightBuilder() -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder {
                if sparseFloatBinarySplitDefaultRightBuilder_ == nil {
                    sparseFloatBinarySplitDefaultRightBuilder_ = Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder()
                    builderResult.sparseFloatBinarySplitDefaultRight = sparseFloatBinarySplitDefaultRightBuilder_.getMessage()
                    if sparseFloatBinarySplitDefaultRight != nil {
                        try! sparseFloatBinarySplitDefaultRightBuilder_.mergeFrom(other: sparseFloatBinarySplitDefaultRight)
                    }
                }
                return sparseFloatBinarySplitDefaultRightBuilder_
            }
            @discardableResult
            public func setSparseFloatBinarySplitDefaultRight(_ value:Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight!) -> Tensorflow.BoostedTrees.Trees.TreeNode.Builder {
                self.sparseFloatBinarySplitDefaultRight = value
                return self
            }
            @discardableResult
            public func mergeSparseFloatBinarySplitDefaultRight(value:Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight) throws -> Tensorflow.BoostedTrees.Trees.TreeNode.Builder {
                if builderResult.hasSparseFloatBinarySplitDefaultRight {
                    builderResult.sparseFloatBinarySplitDefaultRight = try Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.builderWithPrototype(prototype:builderResult.sparseFloatBinarySplitDefaultRight).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.sparseFloatBinarySplitDefaultRight = value
                }
                builderResult.hasSparseFloatBinarySplitDefaultRight = true
                return self
            }
            @discardableResult
            public func clearSparseFloatBinarySplitDefaultRight() -> Tensorflow.BoostedTrees.Trees.TreeNode.Builder {
                sparseFloatBinarySplitDefaultRightBuilder_ = nil
                builderResult.hasSparseFloatBinarySplitDefaultRight = false
                builderResult.sparseFloatBinarySplitDefaultRight = nil
                return self
            }
            public var categoricalIdBinarySplit:Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit! {
                get {
                    if categoricalIdBinarySplitBuilder_ != nil {
                        builderResult.categoricalIdBinarySplit = categoricalIdBinarySplitBuilder_.getMessage()
                    }
                    return builderResult.categoricalIdBinarySplit
                }
                set (value) {
                    builderResult.hasCategoricalIdBinarySplit = true
                    builderResult.categoricalIdBinarySplit = value
                }
            }
            public var hasCategoricalIdBinarySplit:Bool {
                get {
                    return builderResult.hasCategoricalIdBinarySplit
                }
            }
            fileprivate var categoricalIdBinarySplitBuilder_:Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder! {
                didSet {
                    builderResult.hasCategoricalIdBinarySplit = true
                }
            }
            public func getCategoricalIdBinarySplitBuilder() -> Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder {
                if categoricalIdBinarySplitBuilder_ == nil {
                    categoricalIdBinarySplitBuilder_ = Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder()
                    builderResult.categoricalIdBinarySplit = categoricalIdBinarySplitBuilder_.getMessage()
                    if categoricalIdBinarySplit != nil {
                        try! categoricalIdBinarySplitBuilder_.mergeFrom(other: categoricalIdBinarySplit)
                    }
                }
                return categoricalIdBinarySplitBuilder_
            }
            @discardableResult
            public func setCategoricalIdBinarySplit(_ value:Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit!) -> Tensorflow.BoostedTrees.Trees.TreeNode.Builder {
                self.categoricalIdBinarySplit = value
                return self
            }
            @discardableResult
            public func mergeCategoricalIdBinarySplit(value:Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit) throws -> Tensorflow.BoostedTrees.Trees.TreeNode.Builder {
                if builderResult.hasCategoricalIdBinarySplit {
                    builderResult.categoricalIdBinarySplit = try Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.builderWithPrototype(prototype:builderResult.categoricalIdBinarySplit).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.categoricalIdBinarySplit = value
                }
                builderResult.hasCategoricalIdBinarySplit = true
                return self
            }
            @discardableResult
            public func clearCategoricalIdBinarySplit() -> Tensorflow.BoostedTrees.Trees.TreeNode.Builder {
                categoricalIdBinarySplitBuilder_ = nil
                builderResult.hasCategoricalIdBinarySplit = false
                builderResult.categoricalIdBinarySplit = nil
                return self
            }
            public var categoricalIdSetMembershipBinarySplit:Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit! {
                get {
                    if categoricalIdSetMembershipBinarySplitBuilder_ != nil {
                        builderResult.categoricalIdSetMembershipBinarySplit = categoricalIdSetMembershipBinarySplitBuilder_.getMessage()
                    }
                    return builderResult.categoricalIdSetMembershipBinarySplit
                }
                set (value) {
                    builderResult.hasCategoricalIdSetMembershipBinarySplit = true
                    builderResult.categoricalIdSetMembershipBinarySplit = value
                }
            }
            public var hasCategoricalIdSetMembershipBinarySplit:Bool {
                get {
                    return builderResult.hasCategoricalIdSetMembershipBinarySplit
                }
            }
            fileprivate var categoricalIdSetMembershipBinarySplitBuilder_:Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder! {
                didSet {
                    builderResult.hasCategoricalIdSetMembershipBinarySplit = true
                }
            }
            public func getCategoricalIdSetMembershipBinarySplitBuilder() -> Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder {
                if categoricalIdSetMembershipBinarySplitBuilder_ == nil {
                    categoricalIdSetMembershipBinarySplitBuilder_ = Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder()
                    builderResult.categoricalIdSetMembershipBinarySplit = categoricalIdSetMembershipBinarySplitBuilder_.getMessage()
                    if categoricalIdSetMembershipBinarySplit != nil {
                        try! categoricalIdSetMembershipBinarySplitBuilder_.mergeFrom(other: categoricalIdSetMembershipBinarySplit)
                    }
                }
                return categoricalIdSetMembershipBinarySplitBuilder_
            }
            @discardableResult
            public func setCategoricalIdSetMembershipBinarySplit(_ value:Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit!) -> Tensorflow.BoostedTrees.Trees.TreeNode.Builder {
                self.categoricalIdSetMembershipBinarySplit = value
                return self
            }
            @discardableResult
            public func mergeCategoricalIdSetMembershipBinarySplit(value:Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit) throws -> Tensorflow.BoostedTrees.Trees.TreeNode.Builder {
                if builderResult.hasCategoricalIdSetMembershipBinarySplit {
                    builderResult.categoricalIdSetMembershipBinarySplit = try Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.builderWithPrototype(prototype:builderResult.categoricalIdSetMembershipBinarySplit).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.categoricalIdSetMembershipBinarySplit = value
                }
                builderResult.hasCategoricalIdSetMembershipBinarySplit = true
                return self
            }
            @discardableResult
            public func clearCategoricalIdSetMembershipBinarySplit() -> Tensorflow.BoostedTrees.Trees.TreeNode.Builder {
                categoricalIdSetMembershipBinarySplitBuilder_ = nil
                builderResult.hasCategoricalIdSetMembershipBinarySplit = false
                builderResult.categoricalIdSetMembershipBinarySplit = nil
                return self
            }
            public var nodeMetadata:Tensorflow.BoostedTrees.Trees.TreeNodeMetadata! {
                get {
                    if nodeMetadataBuilder_ != nil {
                        builderResult.nodeMetadata = nodeMetadataBuilder_.getMessage()
                    }
                    return builderResult.nodeMetadata
                }
                set (value) {
                    builderResult.hasNodeMetadata = true
                    builderResult.nodeMetadata = value
                }
            }
            public var hasNodeMetadata:Bool {
                get {
                    return builderResult.hasNodeMetadata
                }
            }
            fileprivate var nodeMetadataBuilder_:Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder! {
                didSet {
                    builderResult.hasNodeMetadata = true
                }
            }
            public func getNodeMetadataBuilder() -> Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder {
                if nodeMetadataBuilder_ == nil {
                    nodeMetadataBuilder_ = Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder()
                    builderResult.nodeMetadata = nodeMetadataBuilder_.getMessage()
                    if nodeMetadata != nil {
                        try! nodeMetadataBuilder_.mergeFrom(other: nodeMetadata)
                    }
                }
                return nodeMetadataBuilder_
            }
            @discardableResult
            public func setNodeMetadata(_ value:Tensorflow.BoostedTrees.Trees.TreeNodeMetadata!) -> Tensorflow.BoostedTrees.Trees.TreeNode.Builder {
                self.nodeMetadata = value
                return self
            }
            @discardableResult
            public func mergeNodeMetadata(value:Tensorflow.BoostedTrees.Trees.TreeNodeMetadata) throws -> Tensorflow.BoostedTrees.Trees.TreeNode.Builder {
                if builderResult.hasNodeMetadata {
                    builderResult.nodeMetadata = try Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.builderWithPrototype(prototype:builderResult.nodeMetadata).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.nodeMetadata = value
                }
                builderResult.hasNodeMetadata = true
                return self
            }
            @discardableResult
            public func clearNodeMetadata() -> Tensorflow.BoostedTrees.Trees.TreeNode.Builder {
                nodeMetadataBuilder_ = nil
                builderResult.hasNodeMetadata = false
                builderResult.nodeMetadata = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.BoostedTrees.Trees.TreeNode.Builder {
                builderResult = Tensorflow.BoostedTrees.Trees.TreeNode()
                return self
            }
            override public func clone() throws -> Tensorflow.BoostedTrees.Trees.TreeNode.Builder {
                return try Tensorflow.BoostedTrees.Trees.TreeNode.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.BoostedTrees.Trees.TreeNode {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.BoostedTrees.Trees.TreeNode {
                let returnMe:Tensorflow.BoostedTrees.Trees.TreeNode = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.BoostedTrees.Trees.TreeNode) throws -> Tensorflow.BoostedTrees.Trees.TreeNode.Builder {
                if other == Tensorflow.BoostedTrees.Trees.TreeNode() {
                    return self
                }
                if (other.hasLeaf) {
                    try mergeLeaf(value: other.leaf)
                }
                if (other.hasDenseFloatBinarySplit) {
                    try mergeDenseFloatBinarySplit(value: other.denseFloatBinarySplit)
                }
                if (other.hasSparseFloatBinarySplitDefaultLeft) {
                    try mergeSparseFloatBinarySplitDefaultLeft(value: other.sparseFloatBinarySplitDefaultLeft)
                }
                if (other.hasSparseFloatBinarySplitDefaultRight) {
                    try mergeSparseFloatBinarySplitDefaultRight(value: other.sparseFloatBinarySplitDefaultRight)
                }
                if (other.hasCategoricalIdBinarySplit) {
                    try mergeCategoricalIdBinarySplit(value: other.categoricalIdBinarySplit)
                }
                if (other.hasCategoricalIdSetMembershipBinarySplit) {
                    try mergeCategoricalIdSetMembershipBinarySplit(value: other.categoricalIdSetMembershipBinarySplit)
                }
                if (other.hasNodeMetadata) {
                    try mergeNodeMetadata(value: other.nodeMetadata)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Trees.TreeNode.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.TreeNode.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Tensorflow.BoostedTrees.Trees.Leaf.Builder = Tensorflow.BoostedTrees.Trees.Leaf.Builder()
                        if hasLeaf {
                            try subBuilder.mergeFrom(other: leaf)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        leaf = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder = Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder()
                        if hasDenseFloatBinarySplit {
                            try subBuilder.mergeFrom(other: denseFloatBinarySplit)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        denseFloatBinarySplit = subBuilder.buildPartial()

                    case 26:
                        let subBuilder:Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder = Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder()
                        if hasSparseFloatBinarySplitDefaultLeft {
                            try subBuilder.mergeFrom(other: sparseFloatBinarySplitDefaultLeft)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        sparseFloatBinarySplitDefaultLeft = subBuilder.buildPartial()

                    case 34:
                        let subBuilder:Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder = Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder()
                        if hasSparseFloatBinarySplitDefaultRight {
                            try subBuilder.mergeFrom(other: sparseFloatBinarySplitDefaultRight)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        sparseFloatBinarySplitDefaultRight = subBuilder.buildPartial()

                    case 42:
                        let subBuilder:Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder = Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder()
                        if hasCategoricalIdBinarySplit {
                            try subBuilder.mergeFrom(other: categoricalIdBinarySplit)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        categoricalIdBinarySplit = subBuilder.buildPartial()

                    case 50:
                        let subBuilder:Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder = Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder()
                        if hasCategoricalIdSetMembershipBinarySplit {
                            try subBuilder.mergeFrom(other: categoricalIdSetMembershipBinarySplit)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        categoricalIdSetMembershipBinarySplit = subBuilder.buildPartial()

                    case 6218:
                        let subBuilder:Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder = Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder()
                        if hasNodeMetadata {
                            try subBuilder.mergeFrom(other: nodeMetadata)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        nodeMetadata = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Trees.TreeNode.Builder {
                let resultDecodedBuilder = Tensorflow.BoostedTrees.Trees.TreeNode.Builder()
                if let jsonValueLeaf = jsonMap["leaf"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.leaf = try Tensorflow.BoostedTrees.Trees.Leaf.Builder.decodeToBuilder(jsonMap:jsonValueLeaf).build()

                }
                if let jsonValueDenseFloatBinarySplit = jsonMap["denseFloatBinarySplit"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.denseFloatBinarySplit = try Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder.decodeToBuilder(jsonMap:jsonValueDenseFloatBinarySplit).build()

                }
                if let jsonValueSparseFloatBinarySplitDefaultLeft = jsonMap["sparseFloatBinarySplitDefaultLeft"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.sparseFloatBinarySplitDefaultLeft = try Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder.decodeToBuilder(jsonMap:jsonValueSparseFloatBinarySplitDefaultLeft).build()

                }
                if let jsonValueSparseFloatBinarySplitDefaultRight = jsonMap["sparseFloatBinarySplitDefaultRight"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.sparseFloatBinarySplitDefaultRight = try Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder.decodeToBuilder(jsonMap:jsonValueSparseFloatBinarySplitDefaultRight).build()

                }
                if let jsonValueCategoricalIdBinarySplit = jsonMap["categoricalIdBinarySplit"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.categoricalIdBinarySplit = try Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder.decodeToBuilder(jsonMap:jsonValueCategoricalIdBinarySplit).build()

                }
                if let jsonValueCategoricalIdSetMembershipBinarySplit = jsonMap["categoricalIdSetMembershipBinarySplit"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.categoricalIdSetMembershipBinarySplit = try Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder.decodeToBuilder(jsonMap:jsonValueCategoricalIdSetMembershipBinarySplit).build()

                }
                if let jsonValueNodeMetadata = jsonMap["nodeMetadata"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.nodeMetadata = try Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder.decodeToBuilder(jsonMap:jsonValueNodeMetadata).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.BoostedTrees.Trees.TreeNode.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.BoostedTrees.Trees.TreeNode.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// TreeNodeMetadata encodes metadata associated with each node in a tree.
    final public class TreeNodeMetadata : GeneratedMessage {

        public static func == (lhs: Tensorflow.BoostedTrees.Trees.TreeNodeMetadata, rhs: Tensorflow.BoostedTrees.Trees.TreeNodeMetadata) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasGain == rhs.hasGain) && (!lhs.hasGain || lhs.gain == rhs.gain)
            fieldCheck = fieldCheck && (lhs.hasOriginalLeaf == rhs.hasOriginalLeaf) && (!lhs.hasOriginalLeaf || lhs.originalLeaf == rhs.originalLeaf)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// The gain associated with this node.
        public fileprivate(set) var gain:Float = Float(0)
        public fileprivate(set) var hasGain:Bool = false

        public fileprivate(set) var originalLeaf:Tensorflow.BoostedTrees.Trees.Leaf!
        public fileprivate(set) var hasOriginalLeaf:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasGain {
                try codedOutputStream.writeFloat(fieldNumber: 1, value:gain)
            }
            if hasOriginalLeaf {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:originalLeaf)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasGain {
                serialize_size += gain.computeFloatSize(fieldNumber: 1)
            }
            if hasOriginalLeaf {
                if let varSizeoriginalLeaf = originalLeaf?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeoriginalLeaf
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder {
            return Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.classBuilder() as! Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder
        }
        public func getBuilder() -> Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder {
            return classBuilder() as! Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder()
        }
        public func toBuilder() throws -> Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder {
            return try Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.BoostedTrees.Trees.TreeNodeMetadata) throws -> Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder {
            return try Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasGain {
                jsonMap["gain"] = Float(gain)
            }
            if hasOriginalLeaf {
                jsonMap["originalLeaf"] = try originalLeaf.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Trees.TreeNodeMetadata {
            return try Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.BoostedTrees.Trees.TreeNodeMetadata {
            return try Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasGain {
                output += "\(indent) gain: \(gain) \n"
            }
            if hasOriginalLeaf {
                output += "\(indent) originalLeaf {\n"
                if let outDescOriginalLeaf = originalLeaf {
                    output += try outDescOriginalLeaf.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasGain {
                    hashCode = (hashCode &* 31) &+ gain.hashValue
                }
                if hasOriginalLeaf {
                    if let hashValueoriginalLeaf = originalLeaf?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoriginalLeaf
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.BoostedTrees.Trees.TreeNodeMetadata"
        }
        override public func className() -> String {
            return "Tensorflow.BoostedTrees.Trees.TreeNodeMetadata"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.BoostedTrees.Trees.TreeNodeMetadata = Tensorflow.BoostedTrees.Trees.TreeNodeMetadata()
            public func getMessage() -> Tensorflow.BoostedTrees.Trees.TreeNodeMetadata {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The gain associated with this node.
            public var gain:Float {
                get {
                    return builderResult.gain
                }
                set (value) {
                    builderResult.hasGain = true
                    builderResult.gain = value
                }
            }
            public var hasGain:Bool {
                get {
                    return builderResult.hasGain
                }
            }
            @discardableResult
            public func setGain(_ value:Float) -> Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder {
                self.gain = value
                return self
            }
            @discardableResult
            public func clearGain() -> Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder{
                builderResult.hasGain = false
                builderResult.gain = Float(0)
                return self
            }
            /// The original leaf node before this node was split.
            public var originalLeaf:Tensorflow.BoostedTrees.Trees.Leaf! {
                get {
                    if originalLeafBuilder_ != nil {
                        builderResult.originalLeaf = originalLeafBuilder_.getMessage()
                    }
                    return builderResult.originalLeaf
                }
                set (value) {
                    builderResult.hasOriginalLeaf = true
                    builderResult.originalLeaf = value
                }
            }
            public var hasOriginalLeaf:Bool {
                get {
                    return builderResult.hasOriginalLeaf
                }
            }
            fileprivate var originalLeafBuilder_:Tensorflow.BoostedTrees.Trees.Leaf.Builder! {
                didSet {
                    builderResult.hasOriginalLeaf = true
                }
            }
            public func getOriginalLeafBuilder() -> Tensorflow.BoostedTrees.Trees.Leaf.Builder {
                if originalLeafBuilder_ == nil {
                    originalLeafBuilder_ = Tensorflow.BoostedTrees.Trees.Leaf.Builder()
                    builderResult.originalLeaf = originalLeafBuilder_.getMessage()
                    if originalLeaf != nil {
                        try! originalLeafBuilder_.mergeFrom(other: originalLeaf)
                    }
                }
                return originalLeafBuilder_
            }
            @discardableResult
            public func setOriginalLeaf(_ value:Tensorflow.BoostedTrees.Trees.Leaf!) -> Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder {
                self.originalLeaf = value
                return self
            }
            @discardableResult
            public func mergeOriginalLeaf(value:Tensorflow.BoostedTrees.Trees.Leaf) throws -> Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder {
                if builderResult.hasOriginalLeaf {
                    builderResult.originalLeaf = try Tensorflow.BoostedTrees.Trees.Leaf.builderWithPrototype(prototype:builderResult.originalLeaf).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.originalLeaf = value
                }
                builderResult.hasOriginalLeaf = true
                return self
            }
            @discardableResult
            public func clearOriginalLeaf() -> Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder {
                originalLeafBuilder_ = nil
                builderResult.hasOriginalLeaf = false
                builderResult.originalLeaf = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder {
                builderResult = Tensorflow.BoostedTrees.Trees.TreeNodeMetadata()
                return self
            }
            override public func clone() throws -> Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder {
                return try Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.BoostedTrees.Trees.TreeNodeMetadata {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.BoostedTrees.Trees.TreeNodeMetadata {
                let returnMe:Tensorflow.BoostedTrees.Trees.TreeNodeMetadata = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.BoostedTrees.Trees.TreeNodeMetadata) throws -> Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder {
                if other == Tensorflow.BoostedTrees.Trees.TreeNodeMetadata() {
                    return self
                }
                if other.hasGain {
                    gain = other.gain
                }
                if (other.hasOriginalLeaf) {
                    try mergeOriginalLeaf(value: other.originalLeaf)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 13:
                        gain = try codedInputStream.readFloat()

                    case 18:
                        let subBuilder:Tensorflow.BoostedTrees.Trees.Leaf.Builder = Tensorflow.BoostedTrees.Trees.Leaf.Builder()
                        if hasOriginalLeaf {
                            try subBuilder.mergeFrom(other: originalLeaf)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        originalLeaf = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder {
                let resultDecodedBuilder = Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder()
                if let jsonValueGain = jsonMap["gain"] as? Float {
                    resultDecodedBuilder.gain = Float(jsonValueGain)
                } else if let jsonValueGain = jsonMap["gain"] as? String {
                    resultDecodedBuilder.gain = Float(jsonValueGain)!
                }
                if let jsonValueOriginalLeaf = jsonMap["originalLeaf"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.originalLeaf = try Tensorflow.BoostedTrees.Trees.Leaf.Builder.decodeToBuilder(jsonMap:jsonValueOriginalLeaf).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Leaves can either hold dense or sparse information.
    final public class Leaf : GeneratedMessage {

        public static func == (lhs: Tensorflow.BoostedTrees.Trees.Leaf, rhs: Tensorflow.BoostedTrees.Trees.Leaf) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasVector == rhs.hasVector) && (!lhs.hasVector || lhs.vector == rhs.vector)
            fieldCheck = fieldCheck && (lhs.hasSparseVector == rhs.hasSparseVector) && (!lhs.hasSparseVector || lhs.sparseVector == rhs.sparseVector)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //OneOf declaration start

        public enum Leaf {
            case OneOfLeafNotSet

            public func checkOneOfIsSet() -> Bool {
                switch self {
                case .OneOfLeafNotSet: return false
                default: return true
                }
            }
            case Vector(Tensorflow.BoostedTrees.Trees.Vector)

            public static func getVector(_ value:Leaf) -> Tensorflow.BoostedTrees.Trees.Vector? {
                switch value {
                case .Vector(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case SparseVector(Tensorflow.BoostedTrees.Trees.SparseVector)

            public static func getSparseVector(_ value:Leaf) -> Tensorflow.BoostedTrees.Trees.SparseVector? {
                switch value {
                case .SparseVector(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
        }
        //OneOf declaration end

        fileprivate var storageLeaf:Leaf.Leaf =  Leaf.Leaf.OneOfLeafNotSet
        public func getOneOfLeaf() ->  Leaf.Leaf {
            let copyObjectLeaf = storageLeaf
            return copyObjectLeaf
        }
        public fileprivate(set) var vector:Tensorflow.BoostedTrees.Trees.Vector!{
            get {
                return Leaf.Leaf.getVector(storageLeaf)
            }
            set (newvalue) {
                storageLeaf = Leaf.Leaf.Vector(newvalue)
            }
        }
        public fileprivate(set) var hasVector:Bool {
            get {
                guard let _ = Leaf.Leaf.getVector(storageLeaf) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var sparseVector:Tensorflow.BoostedTrees.Trees.SparseVector!{
            get {
                return Leaf.Leaf.getSparseVector(storageLeaf)
            }
            set (newvalue) {
                storageLeaf = Leaf.Leaf.SparseVector(newvalue)
            }
        }
        public fileprivate(set) var hasSparseVector:Bool {
            get {
                guard let _ = Leaf.Leaf.getSparseVector(storageLeaf) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasVector {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:vector)
            }
            if hasSparseVector {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:sparseVector)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasVector {
                if let varSizevector = vector?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizevector
                }
            }
            if hasSparseVector {
                if let varSizesparseVector = sparseVector?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizesparseVector
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.BoostedTrees.Trees.Leaf.Builder {
            return Tensorflow.BoostedTrees.Trees.Leaf.classBuilder() as! Tensorflow.BoostedTrees.Trees.Leaf.Builder
        }
        public func getBuilder() -> Tensorflow.BoostedTrees.Trees.Leaf.Builder {
            return classBuilder() as! Tensorflow.BoostedTrees.Trees.Leaf.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Trees.Leaf.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Trees.Leaf.Builder()
        }
        public func toBuilder() throws -> Tensorflow.BoostedTrees.Trees.Leaf.Builder {
            return try Tensorflow.BoostedTrees.Trees.Leaf.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.BoostedTrees.Trees.Leaf) throws -> Tensorflow.BoostedTrees.Trees.Leaf.Builder {
            return try Tensorflow.BoostedTrees.Trees.Leaf.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasVector {
                jsonMap["vector"] = try vector.encode()
            }
            if hasSparseVector {
                jsonMap["sparseVector"] = try sparseVector.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Trees.Leaf {
            return try Tensorflow.BoostedTrees.Trees.Leaf.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.BoostedTrees.Trees.Leaf {
            return try Tensorflow.BoostedTrees.Trees.Leaf.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasVector {
                output += "\(indent) vector {\n"
                if let outDescVector = vector {
                    output += try outDescVector.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasSparseVector {
                output += "\(indent) sparseVector {\n"
                if let outDescSparseVector = sparseVector {
                    output += try outDescSparseVector.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasVector {
                    if let hashValuevector = vector?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuevector
                    }
                }
                if hasSparseVector {
                    if let hashValuesparseVector = sparseVector?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuesparseVector
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.BoostedTrees.Trees.Leaf"
        }
        override public func className() -> String {
            return "Tensorflow.BoostedTrees.Trees.Leaf"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.BoostedTrees.Trees.Leaf = Tensorflow.BoostedTrees.Trees.Leaf()
            public func getMessage() -> Tensorflow.BoostedTrees.Trees.Leaf {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// See learning/decision_trees/proto/generic_tree_model.proto?l=133
            /// for a description of how vector and sparse_vector might be used.
            public var vector:Tensorflow.BoostedTrees.Trees.Vector! {
                get {
                    if vectorBuilder_ != nil {
                        builderResult.vector = vectorBuilder_.getMessage()
                    }
                    return builderResult.vector
                }
                set (value) {
                    builderResult.hasVector = true
                    builderResult.vector = value
                }
            }
            public var hasVector:Bool {
                get {
                    return builderResult.hasVector
                }
            }
            fileprivate var vectorBuilder_:Tensorflow.BoostedTrees.Trees.Vector.Builder! {
                didSet {
                    builderResult.hasVector = true
                }
            }
            public func getVectorBuilder() -> Tensorflow.BoostedTrees.Trees.Vector.Builder {
                if vectorBuilder_ == nil {
                    vectorBuilder_ = Tensorflow.BoostedTrees.Trees.Vector.Builder()
                    builderResult.vector = vectorBuilder_.getMessage()
                    if vector != nil {
                        try! vectorBuilder_.mergeFrom(other: vector)
                    }
                }
                return vectorBuilder_
            }
            @discardableResult
            public func setVector(_ value:Tensorflow.BoostedTrees.Trees.Vector!) -> Tensorflow.BoostedTrees.Trees.Leaf.Builder {
                self.vector = value
                return self
            }
            @discardableResult
            public func mergeVector(value:Tensorflow.BoostedTrees.Trees.Vector) throws -> Tensorflow.BoostedTrees.Trees.Leaf.Builder {
                if builderResult.hasVector {
                    builderResult.vector = try Tensorflow.BoostedTrees.Trees.Vector.builderWithPrototype(prototype:builderResult.vector).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.vector = value
                }
                builderResult.hasVector = true
                return self
            }
            @discardableResult
            public func clearVector() -> Tensorflow.BoostedTrees.Trees.Leaf.Builder {
                vectorBuilder_ = nil
                builderResult.hasVector = false
                builderResult.vector = nil
                return self
            }
            public var sparseVector:Tensorflow.BoostedTrees.Trees.SparseVector! {
                get {
                    if sparseVectorBuilder_ != nil {
                        builderResult.sparseVector = sparseVectorBuilder_.getMessage()
                    }
                    return builderResult.sparseVector
                }
                set (value) {
                    builderResult.hasSparseVector = true
                    builderResult.sparseVector = value
                }
            }
            public var hasSparseVector:Bool {
                get {
                    return builderResult.hasSparseVector
                }
            }
            fileprivate var sparseVectorBuilder_:Tensorflow.BoostedTrees.Trees.SparseVector.Builder! {
                didSet {
                    builderResult.hasSparseVector = true
                }
            }
            public func getSparseVectorBuilder() -> Tensorflow.BoostedTrees.Trees.SparseVector.Builder {
                if sparseVectorBuilder_ == nil {
                    sparseVectorBuilder_ = Tensorflow.BoostedTrees.Trees.SparseVector.Builder()
                    builderResult.sparseVector = sparseVectorBuilder_.getMessage()
                    if sparseVector != nil {
                        try! sparseVectorBuilder_.mergeFrom(other: sparseVector)
                    }
                }
                return sparseVectorBuilder_
            }
            @discardableResult
            public func setSparseVector(_ value:Tensorflow.BoostedTrees.Trees.SparseVector!) -> Tensorflow.BoostedTrees.Trees.Leaf.Builder {
                self.sparseVector = value
                return self
            }
            @discardableResult
            public func mergeSparseVector(value:Tensorflow.BoostedTrees.Trees.SparseVector) throws -> Tensorflow.BoostedTrees.Trees.Leaf.Builder {
                if builderResult.hasSparseVector {
                    builderResult.sparseVector = try Tensorflow.BoostedTrees.Trees.SparseVector.builderWithPrototype(prototype:builderResult.sparseVector).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.sparseVector = value
                }
                builderResult.hasSparseVector = true
                return self
            }
            @discardableResult
            public func clearSparseVector() -> Tensorflow.BoostedTrees.Trees.Leaf.Builder {
                sparseVectorBuilder_ = nil
                builderResult.hasSparseVector = false
                builderResult.sparseVector = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.BoostedTrees.Trees.Leaf.Builder {
                builderResult = Tensorflow.BoostedTrees.Trees.Leaf()
                return self
            }
            override public func clone() throws -> Tensorflow.BoostedTrees.Trees.Leaf.Builder {
                return try Tensorflow.BoostedTrees.Trees.Leaf.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.BoostedTrees.Trees.Leaf {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.BoostedTrees.Trees.Leaf {
                let returnMe:Tensorflow.BoostedTrees.Trees.Leaf = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.BoostedTrees.Trees.Leaf) throws -> Tensorflow.BoostedTrees.Trees.Leaf.Builder {
                if other == Tensorflow.BoostedTrees.Trees.Leaf() {
                    return self
                }
                if (other.hasVector) {
                    try mergeVector(value: other.vector)
                }
                if (other.hasSparseVector) {
                    try mergeSparseVector(value: other.sparseVector)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Trees.Leaf.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.Leaf.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Tensorflow.BoostedTrees.Trees.Vector.Builder = Tensorflow.BoostedTrees.Trees.Vector.Builder()
                        if hasVector {
                            try subBuilder.mergeFrom(other: vector)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        vector = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Tensorflow.BoostedTrees.Trees.SparseVector.Builder = Tensorflow.BoostedTrees.Trees.SparseVector.Builder()
                        if hasSparseVector {
                            try subBuilder.mergeFrom(other: sparseVector)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        sparseVector = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Trees.Leaf.Builder {
                let resultDecodedBuilder = Tensorflow.BoostedTrees.Trees.Leaf.Builder()
                if let jsonValueVector = jsonMap["vector"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.vector = try Tensorflow.BoostedTrees.Trees.Vector.Builder.decodeToBuilder(jsonMap:jsonValueVector).build()

                }
                if let jsonValueSparseVector = jsonMap["sparseVector"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.sparseVector = try Tensorflow.BoostedTrees.Trees.SparseVector.Builder.decodeToBuilder(jsonMap:jsonValueSparseVector).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.BoostedTrees.Trees.Leaf.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.BoostedTrees.Trees.Leaf.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class Vector : GeneratedMessage {

        public static func == (lhs: Tensorflow.BoostedTrees.Trees.Vector, rhs: Tensorflow.BoostedTrees.Trees.Vector) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.value == rhs.value)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var value:Array<Float> = Array<Float>()
        private var valueMemoizedSerializedSize:Int32 = -1
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if !value.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 10)
                try codedOutputStream.writeRawVarint32(value: valueMemoizedSerializedSize)
                for oneValuevalue in value {
                    try codedOutputStream.writeFloatNoTag(value: oneValuevalue)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            var dataSizeValue:Int32 = 0
            dataSizeValue = 4 * Int32(value.count)
            serialize_size += dataSizeValue
            if !value.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeValue.computeInt32SizeNoTag()
            }
            valueMemoizedSerializedSize = dataSizeValue
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.BoostedTrees.Trees.Vector.Builder {
            return Tensorflow.BoostedTrees.Trees.Vector.classBuilder() as! Tensorflow.BoostedTrees.Trees.Vector.Builder
        }
        public func getBuilder() -> Tensorflow.BoostedTrees.Trees.Vector.Builder {
            return classBuilder() as! Tensorflow.BoostedTrees.Trees.Vector.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Trees.Vector.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Trees.Vector.Builder()
        }
        public func toBuilder() throws -> Tensorflow.BoostedTrees.Trees.Vector.Builder {
            return try Tensorflow.BoostedTrees.Trees.Vector.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.BoostedTrees.Trees.Vector) throws -> Tensorflow.BoostedTrees.Trees.Vector.Builder {
            return try Tensorflow.BoostedTrees.Trees.Vector.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !value.isEmpty {
                var jsonArrayValue:Array<Float> = []
                for oneValueValue in value {
                    jsonArrayValue.append(Float(oneValueValue))
                }
                jsonMap["value"] = jsonArrayValue
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Trees.Vector {
            return try Tensorflow.BoostedTrees.Trees.Vector.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.BoostedTrees.Trees.Vector {
            return try Tensorflow.BoostedTrees.Trees.Vector.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var valueElementIndex:Int = 0
            for oneValueValue in value  {
                output += "\(indent) value[\(valueElementIndex)]: \(oneValueValue)\n"
                valueElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneValueValue in value {
                    hashCode = (hashCode &* 31) &+ oneValueValue.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.BoostedTrees.Trees.Vector"
        }
        override public func className() -> String {
            return "Tensorflow.BoostedTrees.Trees.Vector"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.BoostedTrees.Trees.Vector = Tensorflow.BoostedTrees.Trees.Vector()
            public func getMessage() -> Tensorflow.BoostedTrees.Trees.Vector {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var value:Array<Float> {
                get {
                    return builderResult.value
                }
                set (array) {
                    builderResult.value = array
                }
            }
            @discardableResult
            public func setValue(_ value:Array<Float>) -> Tensorflow.BoostedTrees.Trees.Vector.Builder {
                self.value = value
                return self
            }
            @discardableResult
            public func clearValue() -> Tensorflow.BoostedTrees.Trees.Vector.Builder {
                builderResult.value.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.BoostedTrees.Trees.Vector.Builder {
                builderResult = Tensorflow.BoostedTrees.Trees.Vector()
                return self
            }
            override public func clone() throws -> Tensorflow.BoostedTrees.Trees.Vector.Builder {
                return try Tensorflow.BoostedTrees.Trees.Vector.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.BoostedTrees.Trees.Vector {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.BoostedTrees.Trees.Vector {
                let returnMe:Tensorflow.BoostedTrees.Trees.Vector = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.BoostedTrees.Trees.Vector) throws -> Tensorflow.BoostedTrees.Trees.Vector.Builder {
                if other == Tensorflow.BoostedTrees.Trees.Vector() {
                    return self
                }
                if !other.value.isEmpty {
                    builderResult.value += other.value
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Trees.Vector.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.Vector.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.value.append(try codedInputStream.readFloat())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Trees.Vector.Builder {
                let resultDecodedBuilder = Tensorflow.BoostedTrees.Trees.Vector.Builder()
                if let jsonValueValue = jsonMap["value"] as? Array<Float> {
                    var jsonArrayValue:Array<Float> = []
                    for oneValueValue in jsonValueValue {
                        jsonArrayValue.append(Float(oneValueValue))
                    }
                    resultDecodedBuilder.value = jsonArrayValue
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.BoostedTrees.Trees.Vector.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.BoostedTrees.Trees.Vector.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class SparseVector : GeneratedMessage {

        public static func == (lhs: Tensorflow.BoostedTrees.Trees.SparseVector, rhs: Tensorflow.BoostedTrees.Trees.SparseVector) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.index == rhs.index)
            fieldCheck = fieldCheck && (lhs.value == rhs.value)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var index:Array<Int32> = Array<Int32>()
        private var indexMemoizedSerializedSize:Int32 = -1
        public fileprivate(set) var value:Array<Float> = Array<Float>()
        private var valueMemoizedSerializedSize:Int32 = -1
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if !index.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 10)
                try codedOutputStream.writeRawVarint32(value: indexMemoizedSerializedSize)
                for oneValueindex in index {
                    try codedOutputStream.writeInt32NoTag(value: oneValueindex)
                }
            }
            if !value.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 18)
                try codedOutputStream.writeRawVarint32(value: valueMemoizedSerializedSize)
                for oneValuevalue in value {
                    try codedOutputStream.writeFloatNoTag(value: oneValuevalue)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            var dataSizeIndex:Int32 = 0
            for oneValueindex in index {
                dataSizeIndex += oneValueindex.computeInt32SizeNoTag()
            }
            serialize_size += dataSizeIndex
            if !index.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeIndex.computeInt32SizeNoTag()
            }
            indexMemoizedSerializedSize = dataSizeIndex
            var dataSizeValue:Int32 = 0
            dataSizeValue = 4 * Int32(value.count)
            serialize_size += dataSizeValue
            if !value.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeValue.computeInt32SizeNoTag()
            }
            valueMemoizedSerializedSize = dataSizeValue
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.BoostedTrees.Trees.SparseVector.Builder {
            return Tensorflow.BoostedTrees.Trees.SparseVector.classBuilder() as! Tensorflow.BoostedTrees.Trees.SparseVector.Builder
        }
        public func getBuilder() -> Tensorflow.BoostedTrees.Trees.SparseVector.Builder {
            return classBuilder() as! Tensorflow.BoostedTrees.Trees.SparseVector.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Trees.SparseVector.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Trees.SparseVector.Builder()
        }
        public func toBuilder() throws -> Tensorflow.BoostedTrees.Trees.SparseVector.Builder {
            return try Tensorflow.BoostedTrees.Trees.SparseVector.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.BoostedTrees.Trees.SparseVector) throws -> Tensorflow.BoostedTrees.Trees.SparseVector.Builder {
            return try Tensorflow.BoostedTrees.Trees.SparseVector.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !index.isEmpty {
                var jsonArrayIndex:Array<Int> = []
                for oneValueIndex in index {
                    jsonArrayIndex.append(Int(oneValueIndex))
                }
                jsonMap["index"] = jsonArrayIndex
            }
            if !value.isEmpty {
                var jsonArrayValue:Array<Float> = []
                for oneValueValue in value {
                    jsonArrayValue.append(Float(oneValueValue))
                }
                jsonMap["value"] = jsonArrayValue
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Trees.SparseVector {
            return try Tensorflow.BoostedTrees.Trees.SparseVector.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.BoostedTrees.Trees.SparseVector {
            return try Tensorflow.BoostedTrees.Trees.SparseVector.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var indexElementIndex:Int = 0
            for oneValueIndex in index  {
                output += "\(indent) index[\(indexElementIndex)]: \(oneValueIndex)\n"
                indexElementIndex += 1
            }
            var valueElementIndex:Int = 0
            for oneValueValue in value  {
                output += "\(indent) value[\(valueElementIndex)]: \(oneValueValue)\n"
                valueElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneValueIndex in index {
                    hashCode = (hashCode &* 31) &+ oneValueIndex.hashValue
                }
                for oneValueValue in value {
                    hashCode = (hashCode &* 31) &+ oneValueValue.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.BoostedTrees.Trees.SparseVector"
        }
        override public func className() -> String {
            return "Tensorflow.BoostedTrees.Trees.SparseVector"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.BoostedTrees.Trees.SparseVector = Tensorflow.BoostedTrees.Trees.SparseVector()
            public func getMessage() -> Tensorflow.BoostedTrees.Trees.SparseVector {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var index:Array<Int32> {
                get {
                    return builderResult.index
                }
                set (array) {
                    builderResult.index = array
                }
            }
            @discardableResult
            public func setIndex(_ value:Array<Int32>) -> Tensorflow.BoostedTrees.Trees.SparseVector.Builder {
                self.index = value
                return self
            }
            @discardableResult
            public func clearIndex() -> Tensorflow.BoostedTrees.Trees.SparseVector.Builder {
                builderResult.index.removeAll(keepingCapacity: false)
                return self
            }
            public var value:Array<Float> {
                get {
                    return builderResult.value
                }
                set (array) {
                    builderResult.value = array
                }
            }
            @discardableResult
            public func setValue(_ value:Array<Float>) -> Tensorflow.BoostedTrees.Trees.SparseVector.Builder {
                self.value = value
                return self
            }
            @discardableResult
            public func clearValue() -> Tensorflow.BoostedTrees.Trees.SparseVector.Builder {
                builderResult.value.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.BoostedTrees.Trees.SparseVector.Builder {
                builderResult = Tensorflow.BoostedTrees.Trees.SparseVector()
                return self
            }
            override public func clone() throws -> Tensorflow.BoostedTrees.Trees.SparseVector.Builder {
                return try Tensorflow.BoostedTrees.Trees.SparseVector.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.BoostedTrees.Trees.SparseVector {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.BoostedTrees.Trees.SparseVector {
                let returnMe:Tensorflow.BoostedTrees.Trees.SparseVector = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.BoostedTrees.Trees.SparseVector) throws -> Tensorflow.BoostedTrees.Trees.SparseVector.Builder {
                if other == Tensorflow.BoostedTrees.Trees.SparseVector() {
                    return self
                }
                if !other.index.isEmpty {
                    builderResult.index += other.index
                }
                if !other.value.isEmpty {
                    builderResult.value += other.value
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Trees.SparseVector.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.SparseVector.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.index.append(try codedInputStream.readInt32())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 18:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.value.append(try codedInputStream.readFloat())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Trees.SparseVector.Builder {
                let resultDecodedBuilder = Tensorflow.BoostedTrees.Trees.SparseVector.Builder()
                if let jsonValueIndex = jsonMap["index"] as? Array<Int> {
                    var jsonArrayIndex:Array<Int32> = []
                    for oneValueIndex in jsonValueIndex {
                        jsonArrayIndex.append(Int32(oneValueIndex))
                    }
                    resultDecodedBuilder.index = jsonArrayIndex
                }
                if let jsonValueValue = jsonMap["value"] as? Array<Float> {
                    var jsonArrayValue:Array<Float> = []
                    for oneValueValue in jsonValueValue {
                        jsonArrayValue.append(Float(oneValueValue))
                    }
                    resultDecodedBuilder.value = jsonArrayValue
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.BoostedTrees.Trees.SparseVector.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.BoostedTrees.Trees.SparseVector.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Split rule for dense float features.
    final public class DenseFloatBinarySplit : GeneratedMessage {

        public static func == (lhs: Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit, rhs: Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasFeatureColumn == rhs.hasFeatureColumn) && (!lhs.hasFeatureColumn || lhs.featureColumn == rhs.featureColumn)
            fieldCheck = fieldCheck && (lhs.hasThreshold == rhs.hasThreshold) && (!lhs.hasThreshold || lhs.threshold == rhs.threshold)
            fieldCheck = fieldCheck && (lhs.hasLeftId == rhs.hasLeftId) && (!lhs.hasLeftId || lhs.leftId == rhs.leftId)
            fieldCheck = fieldCheck && (lhs.hasRightId == rhs.hasRightId) && (!lhs.hasRightId || lhs.rightId == rhs.rightId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Float feature column and split threshold describing
        /// the rule feature <= threshold.
        public fileprivate(set) var featureColumn:Int32 = Int32(0)
        public fileprivate(set) var hasFeatureColumn:Bool = false

        public fileprivate(set) var threshold:Float = Float(0)
        public fileprivate(set) var hasThreshold:Bool = false

        /// Node children indexing into a contiguous
        /// vector of nodes starting from the root.
        public fileprivate(set) var leftId:Int32 = Int32(0)
        public fileprivate(set) var hasLeftId:Bool = false

        public fileprivate(set) var rightId:Int32 = Int32(0)
        public fileprivate(set) var hasRightId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasFeatureColumn {
                try codedOutputStream.writeInt32(fieldNumber: 1, value:featureColumn)
            }
            if hasThreshold {
                try codedOutputStream.writeFloat(fieldNumber: 2, value:threshold)
            }
            if hasLeftId {
                try codedOutputStream.writeInt32(fieldNumber: 3, value:leftId)
            }
            if hasRightId {
                try codedOutputStream.writeInt32(fieldNumber: 4, value:rightId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasFeatureColumn {
                serialize_size += featureColumn.computeInt32Size(fieldNumber: 1)
            }
            if hasThreshold {
                serialize_size += threshold.computeFloatSize(fieldNumber: 2)
            }
            if hasLeftId {
                serialize_size += leftId.computeInt32Size(fieldNumber: 3)
            }
            if hasRightId {
                serialize_size += rightId.computeInt32Size(fieldNumber: 4)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder {
            return Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.classBuilder() as! Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder
        }
        public func getBuilder() -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder {
            return classBuilder() as! Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder()
        }
        public func toBuilder() throws -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder {
            return try Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit) throws -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder {
            return try Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasFeatureColumn {
                jsonMap["featureColumn"] = Int(featureColumn)
            }
            if hasThreshold {
                jsonMap["threshold"] = Float(threshold)
            }
            if hasLeftId {
                jsonMap["leftId"] = Int(leftId)
            }
            if hasRightId {
                jsonMap["rightId"] = Int(rightId)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit {
            return try Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit {
            return try Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasFeatureColumn {
                output += "\(indent) featureColumn: \(featureColumn) \n"
            }
            if hasThreshold {
                output += "\(indent) threshold: \(threshold) \n"
            }
            if hasLeftId {
                output += "\(indent) leftId: \(leftId) \n"
            }
            if hasRightId {
                output += "\(indent) rightId: \(rightId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasFeatureColumn {
                    hashCode = (hashCode &* 31) &+ featureColumn.hashValue
                }
                if hasThreshold {
                    hashCode = (hashCode &* 31) &+ threshold.hashValue
                }
                if hasLeftId {
                    hashCode = (hashCode &* 31) &+ leftId.hashValue
                }
                if hasRightId {
                    hashCode = (hashCode &* 31) &+ rightId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit"
        }
        override public func className() -> String {
            return "Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit = Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit()
            public func getMessage() -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Float feature column and split threshold describing
            /// the rule feature <= threshold.
            public var featureColumn:Int32 {
                get {
                    return builderResult.featureColumn
                }
                set (value) {
                    builderResult.hasFeatureColumn = true
                    builderResult.featureColumn = value
                }
            }
            public var hasFeatureColumn:Bool {
                get {
                    return builderResult.hasFeatureColumn
                }
            }
            @discardableResult
            public func setFeatureColumn(_ value:Int32) -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder {
                self.featureColumn = value
                return self
            }
            @discardableResult
            public func clearFeatureColumn() -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder{
                builderResult.hasFeatureColumn = false
                builderResult.featureColumn = Int32(0)
                return self
            }
            public var threshold:Float {
                get {
                    return builderResult.threshold
                }
                set (value) {
                    builderResult.hasThreshold = true
                    builderResult.threshold = value
                }
            }
            public var hasThreshold:Bool {
                get {
                    return builderResult.hasThreshold
                }
            }
            @discardableResult
            public func setThreshold(_ value:Float) -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder {
                self.threshold = value
                return self
            }
            @discardableResult
            public func clearThreshold() -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder{
                builderResult.hasThreshold = false
                builderResult.threshold = Float(0)
                return self
            }
            /// Node children indexing into a contiguous
            /// vector of nodes starting from the root.
            public var leftId:Int32 {
                get {
                    return builderResult.leftId
                }
                set (value) {
                    builderResult.hasLeftId = true
                    builderResult.leftId = value
                }
            }
            public var hasLeftId:Bool {
                get {
                    return builderResult.hasLeftId
                }
            }
            @discardableResult
            public func setLeftId(_ value:Int32) -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder {
                self.leftId = value
                return self
            }
            @discardableResult
            public func clearLeftId() -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder{
                builderResult.hasLeftId = false
                builderResult.leftId = Int32(0)
                return self
            }
            public var rightId:Int32 {
                get {
                    return builderResult.rightId
                }
                set (value) {
                    builderResult.hasRightId = true
                    builderResult.rightId = value
                }
            }
            public var hasRightId:Bool {
                get {
                    return builderResult.hasRightId
                }
            }
            @discardableResult
            public func setRightId(_ value:Int32) -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder {
                self.rightId = value
                return self
            }
            @discardableResult
            public func clearRightId() -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder{
                builderResult.hasRightId = false
                builderResult.rightId = Int32(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder {
                builderResult = Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit()
                return self
            }
            override public func clone() throws -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder {
                return try Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit {
                let returnMe:Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit) throws -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder {
                if other == Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit() {
                    return self
                }
                if other.hasFeatureColumn {
                    featureColumn = other.featureColumn
                }
                if other.hasThreshold {
                    threshold = other.threshold
                }
                if other.hasLeftId {
                    leftId = other.leftId
                }
                if other.hasRightId {
                    rightId = other.rightId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        featureColumn = try codedInputStream.readInt32()

                    case 21:
                        threshold = try codedInputStream.readFloat()

                    case 24:
                        leftId = try codedInputStream.readInt32()

                    case 32:
                        rightId = try codedInputStream.readInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder {
                let resultDecodedBuilder = Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder()
                if let jsonValueFeatureColumn = jsonMap["featureColumn"] as? Int {
                    resultDecodedBuilder.featureColumn = Int32(jsonValueFeatureColumn)
                } else if let jsonValueFeatureColumn = jsonMap["featureColumn"] as? String {
                    resultDecodedBuilder.featureColumn = Int32(jsonValueFeatureColumn)!
                }
                if let jsonValueThreshold = jsonMap["threshold"] as? Float {
                    resultDecodedBuilder.threshold = Float(jsonValueThreshold)
                } else if let jsonValueThreshold = jsonMap["threshold"] as? String {
                    resultDecodedBuilder.threshold = Float(jsonValueThreshold)!
                }
                if let jsonValueLeftId = jsonMap["leftId"] as? Int {
                    resultDecodedBuilder.leftId = Int32(jsonValueLeftId)
                } else if let jsonValueLeftId = jsonMap["leftId"] as? String {
                    resultDecodedBuilder.leftId = Int32(jsonValueLeftId)!
                }
                if let jsonValueRightId = jsonMap["rightId"] as? Int {
                    resultDecodedBuilder.rightId = Int32(jsonValueRightId)
                } else if let jsonValueRightId = jsonMap["rightId"] as? String {
                    resultDecodedBuilder.rightId = Int32(jsonValueRightId)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Split rule for sparse float features defaulting left for missing features.
    final public class SparseFloatBinarySplitDefaultLeft : GeneratedMessage {

        public static func == (lhs: Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft, rhs: Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasSplit == rhs.hasSplit) && (!lhs.hasSplit || lhs.split == rhs.split)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var split:Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit!
        public fileprivate(set) var hasSplit:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasSplit {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:split)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasSplit {
                if let varSizesplit = split?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizesplit
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder {
            return Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.classBuilder() as! Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder
        }
        public func getBuilder() -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder {
            return classBuilder() as! Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder()
        }
        public func toBuilder() throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder {
            return try Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft) throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder {
            return try Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasSplit {
                jsonMap["split"] = try split.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft {
            return try Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft {
            return try Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasSplit {
                output += "\(indent) split {\n"
                if let outDescSplit = split {
                    output += try outDescSplit.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasSplit {
                    if let hashValuesplit = split?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuesplit
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft"
        }
        override public func className() -> String {
            return "Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft = Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft()
            public func getMessage() -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var split:Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit! {
                get {
                    if splitBuilder_ != nil {
                        builderResult.split = splitBuilder_.getMessage()
                    }
                    return builderResult.split
                }
                set (value) {
                    builderResult.hasSplit = true
                    builderResult.split = value
                }
            }
            public var hasSplit:Bool {
                get {
                    return builderResult.hasSplit
                }
            }
            fileprivate var splitBuilder_:Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder! {
                didSet {
                    builderResult.hasSplit = true
                }
            }
            public func getSplitBuilder() -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder {
                if splitBuilder_ == nil {
                    splitBuilder_ = Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder()
                    builderResult.split = splitBuilder_.getMessage()
                    if split != nil {
                        try! splitBuilder_.mergeFrom(other: split)
                    }
                }
                return splitBuilder_
            }
            @discardableResult
            public func setSplit(_ value:Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit!) -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder {
                self.split = value
                return self
            }
            @discardableResult
            public func mergeSplit(value:Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit) throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder {
                if builderResult.hasSplit {
                    builderResult.split = try Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.builderWithPrototype(prototype:builderResult.split).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.split = value
                }
                builderResult.hasSplit = true
                return self
            }
            @discardableResult
            public func clearSplit() -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder {
                splitBuilder_ = nil
                builderResult.hasSplit = false
                builderResult.split = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder {
                builderResult = Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft()
                return self
            }
            override public func clone() throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder {
                return try Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft {
                let returnMe:Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft) throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder {
                if other == Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft() {
                    return self
                }
                if (other.hasSplit) {
                    try mergeSplit(value: other.split)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder = Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder()
                        if hasSplit {
                            try subBuilder.mergeFrom(other: split)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        split = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder {
                let resultDecodedBuilder = Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder()
                if let jsonValueSplit = jsonMap["split"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.split = try Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder.decodeToBuilder(jsonMap:jsonValueSplit).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Split rule for sparse float features defaulting right for missing features.
    final public class SparseFloatBinarySplitDefaultRight : GeneratedMessage {

        public static func == (lhs: Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight, rhs: Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasSplit == rhs.hasSplit) && (!lhs.hasSplit || lhs.split == rhs.split)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var split:Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit!
        public fileprivate(set) var hasSplit:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasSplit {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:split)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasSplit {
                if let varSizesplit = split?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizesplit
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder {
            return Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.classBuilder() as! Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder
        }
        public func getBuilder() -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder {
            return classBuilder() as! Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder()
        }
        public func toBuilder() throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder {
            return try Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight) throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder {
            return try Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasSplit {
                jsonMap["split"] = try split.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight {
            return try Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight {
            return try Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasSplit {
                output += "\(indent) split {\n"
                if let outDescSplit = split {
                    output += try outDescSplit.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasSplit {
                    if let hashValuesplit = split?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuesplit
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight"
        }
        override public func className() -> String {
            return "Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight = Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight()
            public func getMessage() -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var split:Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit! {
                get {
                    if splitBuilder_ != nil {
                        builderResult.split = splitBuilder_.getMessage()
                    }
                    return builderResult.split
                }
                set (value) {
                    builderResult.hasSplit = true
                    builderResult.split = value
                }
            }
            public var hasSplit:Bool {
                get {
                    return builderResult.hasSplit
                }
            }
            fileprivate var splitBuilder_:Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder! {
                didSet {
                    builderResult.hasSplit = true
                }
            }
            public func getSplitBuilder() -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder {
                if splitBuilder_ == nil {
                    splitBuilder_ = Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder()
                    builderResult.split = splitBuilder_.getMessage()
                    if split != nil {
                        try! splitBuilder_.mergeFrom(other: split)
                    }
                }
                return splitBuilder_
            }
            @discardableResult
            public func setSplit(_ value:Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit!) -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder {
                self.split = value
                return self
            }
            @discardableResult
            public func mergeSplit(value:Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit) throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder {
                if builderResult.hasSplit {
                    builderResult.split = try Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.builderWithPrototype(prototype:builderResult.split).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.split = value
                }
                builderResult.hasSplit = true
                return self
            }
            @discardableResult
            public func clearSplit() -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder {
                splitBuilder_ = nil
                builderResult.hasSplit = false
                builderResult.split = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder {
                builderResult = Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight()
                return self
            }
            override public func clone() throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder {
                return try Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight {
                let returnMe:Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight) throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder {
                if other == Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight() {
                    return self
                }
                if (other.hasSplit) {
                    try mergeSplit(value: other.split)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder = Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder()
                        if hasSplit {
                            try subBuilder.mergeFrom(other: split)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        split = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder {
                let resultDecodedBuilder = Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder()
                if let jsonValueSplit = jsonMap["split"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.split = try Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder.decodeToBuilder(jsonMap:jsonValueSplit).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Split rule for categorical features with a single feature Id.
    final public class CategoricalIdBinarySplit : GeneratedMessage {

        public static func == (lhs: Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit, rhs: Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasFeatureColumn == rhs.hasFeatureColumn) && (!lhs.hasFeatureColumn || lhs.featureColumn == rhs.featureColumn)
            fieldCheck = fieldCheck && (lhs.hasFeatureId == rhs.hasFeatureId) && (!lhs.hasFeatureId || lhs.featureId == rhs.featureId)
            fieldCheck = fieldCheck && (lhs.hasLeftId == rhs.hasLeftId) && (!lhs.hasLeftId || lhs.leftId == rhs.leftId)
            fieldCheck = fieldCheck && (lhs.hasRightId == rhs.hasRightId) && (!lhs.hasRightId || lhs.rightId == rhs.rightId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Categorical feature column and Id describing
        /// the rule feature == Id.
        public fileprivate(set) var featureColumn:Int32 = Int32(0)
        public fileprivate(set) var hasFeatureColumn:Bool = false

        public fileprivate(set) var featureId:Int64 = Int64(0)
        public fileprivate(set) var hasFeatureId:Bool = false

        /// Node children indexing into a contiguous
        /// vector of nodes starting from the root.
        public fileprivate(set) var leftId:Int32 = Int32(0)
        public fileprivate(set) var hasLeftId:Bool = false

        public fileprivate(set) var rightId:Int32 = Int32(0)
        public fileprivate(set) var hasRightId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasFeatureColumn {
                try codedOutputStream.writeInt32(fieldNumber: 1, value:featureColumn)
            }
            if hasFeatureId {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:featureId)
            }
            if hasLeftId {
                try codedOutputStream.writeInt32(fieldNumber: 3, value:leftId)
            }
            if hasRightId {
                try codedOutputStream.writeInt32(fieldNumber: 4, value:rightId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasFeatureColumn {
                serialize_size += featureColumn.computeInt32Size(fieldNumber: 1)
            }
            if hasFeatureId {
                serialize_size += featureId.computeInt64Size(fieldNumber: 2)
            }
            if hasLeftId {
                serialize_size += leftId.computeInt32Size(fieldNumber: 3)
            }
            if hasRightId {
                serialize_size += rightId.computeInt32Size(fieldNumber: 4)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder {
            return Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.classBuilder() as! Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder
        }
        public func getBuilder() -> Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder {
            return classBuilder() as! Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder()
        }
        public func toBuilder() throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder {
            return try Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit) throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder {
            return try Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasFeatureColumn {
                jsonMap["featureColumn"] = Int(featureColumn)
            }
            if hasFeatureId {
                jsonMap["featureId"] = "\(featureId)"
            }
            if hasLeftId {
                jsonMap["leftId"] = Int(leftId)
            }
            if hasRightId {
                jsonMap["rightId"] = Int(rightId)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit {
            return try Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit {
            return try Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasFeatureColumn {
                output += "\(indent) featureColumn: \(featureColumn) \n"
            }
            if hasFeatureId {
                output += "\(indent) featureId: \(featureId) \n"
            }
            if hasLeftId {
                output += "\(indent) leftId: \(leftId) \n"
            }
            if hasRightId {
                output += "\(indent) rightId: \(rightId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasFeatureColumn {
                    hashCode = (hashCode &* 31) &+ featureColumn.hashValue
                }
                if hasFeatureId {
                    hashCode = (hashCode &* 31) &+ featureId.hashValue
                }
                if hasLeftId {
                    hashCode = (hashCode &* 31) &+ leftId.hashValue
                }
                if hasRightId {
                    hashCode = (hashCode &* 31) &+ rightId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit"
        }
        override public func className() -> String {
            return "Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit = Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit()
            public func getMessage() -> Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Categorical feature column and Id describing
            /// the rule feature == Id.
            public var featureColumn:Int32 {
                get {
                    return builderResult.featureColumn
                }
                set (value) {
                    builderResult.hasFeatureColumn = true
                    builderResult.featureColumn = value
                }
            }
            public var hasFeatureColumn:Bool {
                get {
                    return builderResult.hasFeatureColumn
                }
            }
            @discardableResult
            public func setFeatureColumn(_ value:Int32) -> Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder {
                self.featureColumn = value
                return self
            }
            @discardableResult
            public func clearFeatureColumn() -> Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder{
                builderResult.hasFeatureColumn = false
                builderResult.featureColumn = Int32(0)
                return self
            }
            public var featureId:Int64 {
                get {
                    return builderResult.featureId
                }
                set (value) {
                    builderResult.hasFeatureId = true
                    builderResult.featureId = value
                }
            }
            public var hasFeatureId:Bool {
                get {
                    return builderResult.hasFeatureId
                }
            }
            @discardableResult
            public func setFeatureId(_ value:Int64) -> Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder {
                self.featureId = value
                return self
            }
            @discardableResult
            public func clearFeatureId() -> Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder{
                builderResult.hasFeatureId = false
                builderResult.featureId = Int64(0)
                return self
            }
            /// Node children indexing into a contiguous
            /// vector of nodes starting from the root.
            public var leftId:Int32 {
                get {
                    return builderResult.leftId
                }
                set (value) {
                    builderResult.hasLeftId = true
                    builderResult.leftId = value
                }
            }
            public var hasLeftId:Bool {
                get {
                    return builderResult.hasLeftId
                }
            }
            @discardableResult
            public func setLeftId(_ value:Int32) -> Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder {
                self.leftId = value
                return self
            }
            @discardableResult
            public func clearLeftId() -> Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder{
                builderResult.hasLeftId = false
                builderResult.leftId = Int32(0)
                return self
            }
            public var rightId:Int32 {
                get {
                    return builderResult.rightId
                }
                set (value) {
                    builderResult.hasRightId = true
                    builderResult.rightId = value
                }
            }
            public var hasRightId:Bool {
                get {
                    return builderResult.hasRightId
                }
            }
            @discardableResult
            public func setRightId(_ value:Int32) -> Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder {
                self.rightId = value
                return self
            }
            @discardableResult
            public func clearRightId() -> Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder{
                builderResult.hasRightId = false
                builderResult.rightId = Int32(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder {
                builderResult = Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit()
                return self
            }
            override public func clone() throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder {
                return try Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit {
                let returnMe:Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit) throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder {
                if other == Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit() {
                    return self
                }
                if other.hasFeatureColumn {
                    featureColumn = other.featureColumn
                }
                if other.hasFeatureId {
                    featureId = other.featureId
                }
                if other.hasLeftId {
                    leftId = other.leftId
                }
                if other.hasRightId {
                    rightId = other.rightId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        featureColumn = try codedInputStream.readInt32()

                    case 16:
                        featureId = try codedInputStream.readInt64()

                    case 24:
                        leftId = try codedInputStream.readInt32()

                    case 32:
                        rightId = try codedInputStream.readInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder {
                let resultDecodedBuilder = Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder()
                if let jsonValueFeatureColumn = jsonMap["featureColumn"] as? Int {
                    resultDecodedBuilder.featureColumn = Int32(jsonValueFeatureColumn)
                } else if let jsonValueFeatureColumn = jsonMap["featureColumn"] as? String {
                    resultDecodedBuilder.featureColumn = Int32(jsonValueFeatureColumn)!
                }
                if let jsonValueFeatureId = jsonMap["featureId"] as? String {
                    resultDecodedBuilder.featureId = Int64(jsonValueFeatureId)!
                } else if let jsonValueFeatureId = jsonMap["featureId"] as? Int {
                    resultDecodedBuilder.featureId = Int64(jsonValueFeatureId)
                }
                if let jsonValueLeftId = jsonMap["leftId"] as? Int {
                    resultDecodedBuilder.leftId = Int32(jsonValueLeftId)
                } else if let jsonValueLeftId = jsonMap["leftId"] as? String {
                    resultDecodedBuilder.leftId = Int32(jsonValueLeftId)!
                }
                if let jsonValueRightId = jsonMap["rightId"] as? Int {
                    resultDecodedBuilder.rightId = Int32(jsonValueRightId)
                } else if let jsonValueRightId = jsonMap["rightId"] as? String {
                    resultDecodedBuilder.rightId = Int32(jsonValueRightId)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Split rule for categorical features with a set of feature Ids.
    final public class CategoricalIdSetMembershipBinarySplit : GeneratedMessage {

        public static func == (lhs: Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit, rhs: Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasFeatureColumn == rhs.hasFeatureColumn) && (!lhs.hasFeatureColumn || lhs.featureColumn == rhs.featureColumn)
            fieldCheck = fieldCheck && (lhs.featureIds == rhs.featureIds)
            fieldCheck = fieldCheck && (lhs.hasLeftId == rhs.hasLeftId) && (!lhs.hasLeftId || lhs.leftId == rhs.leftId)
            fieldCheck = fieldCheck && (lhs.hasRightId == rhs.hasRightId) && (!lhs.hasRightId || lhs.rightId == rhs.rightId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Categorical feature column and Id describing
        /// the rule feature  feature_ids.
        public fileprivate(set) var featureColumn:Int32 = Int32(0)
        public fileprivate(set) var hasFeatureColumn:Bool = false

        /// Sorted list of Ids in the set.
        public fileprivate(set) var featureIds:Array<Int64> = Array<Int64>()
        private var featureIdsMemoizedSerializedSize:Int32 = -1
        /// Node children indexing into a contiguous
        /// vector of nodes starting from the root.
        public fileprivate(set) var leftId:Int32 = Int32(0)
        public fileprivate(set) var hasLeftId:Bool = false

        public fileprivate(set) var rightId:Int32 = Int32(0)
        public fileprivate(set) var hasRightId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasFeatureColumn {
                try codedOutputStream.writeInt32(fieldNumber: 1, value:featureColumn)
            }
            if !featureIds.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 18)
                try codedOutputStream.writeRawVarint32(value: featureIdsMemoizedSerializedSize)
                for oneValuefeatureIds in featureIds {
                    try codedOutputStream.writeInt64NoTag(value: oneValuefeatureIds)
                }
            }
            if hasLeftId {
                try codedOutputStream.writeInt32(fieldNumber: 3, value:leftId)
            }
            if hasRightId {
                try codedOutputStream.writeInt32(fieldNumber: 4, value:rightId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasFeatureColumn {
                serialize_size += featureColumn.computeInt32Size(fieldNumber: 1)
            }
            var dataSizeFeatureIds:Int32 = 0
            for oneValuefeatureIds in featureIds {
                dataSizeFeatureIds += oneValuefeatureIds.computeInt64SizeNoTag()
            }
            serialize_size += dataSizeFeatureIds
            if !featureIds.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeFeatureIds.computeInt32SizeNoTag()
            }
            featureIdsMemoizedSerializedSize = dataSizeFeatureIds
            if hasLeftId {
                serialize_size += leftId.computeInt32Size(fieldNumber: 3)
            }
            if hasRightId {
                serialize_size += rightId.computeInt32Size(fieldNumber: 4)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder {
            return Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.classBuilder() as! Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder
        }
        public func getBuilder() -> Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder {
            return classBuilder() as! Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder()
        }
        public func toBuilder() throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder {
            return try Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit) throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder {
            return try Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasFeatureColumn {
                jsonMap["featureColumn"] = Int(featureColumn)
            }
            if !featureIds.isEmpty {
                var jsonArrayFeatureIds:Array<String> = []
                for oneValueFeatureIds in featureIds {
                    jsonArrayFeatureIds.append("\(oneValueFeatureIds)")
                }
                jsonMap["featureIds"] = jsonArrayFeatureIds
            }
            if hasLeftId {
                jsonMap["leftId"] = Int(leftId)
            }
            if hasRightId {
                jsonMap["rightId"] = Int(rightId)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit {
            return try Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit {
            return try Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasFeatureColumn {
                output += "\(indent) featureColumn: \(featureColumn) \n"
            }
            var featureIdsElementIndex:Int = 0
            for oneValueFeatureIds in featureIds  {
                output += "\(indent) featureIds[\(featureIdsElementIndex)]: \(oneValueFeatureIds)\n"
                featureIdsElementIndex += 1
            }
            if hasLeftId {
                output += "\(indent) leftId: \(leftId) \n"
            }
            if hasRightId {
                output += "\(indent) rightId: \(rightId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasFeatureColumn {
                    hashCode = (hashCode &* 31) &+ featureColumn.hashValue
                }
                for oneValueFeatureIds in featureIds {
                    hashCode = (hashCode &* 31) &+ oneValueFeatureIds.hashValue
                }
                if hasLeftId {
                    hashCode = (hashCode &* 31) &+ leftId.hashValue
                }
                if hasRightId {
                    hashCode = (hashCode &* 31) &+ rightId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit"
        }
        override public func className() -> String {
            return "Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit = Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit()
            public func getMessage() -> Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Categorical feature column and Id describing
            /// the rule feature  feature_ids.
            public var featureColumn:Int32 {
                get {
                    return builderResult.featureColumn
                }
                set (value) {
                    builderResult.hasFeatureColumn = true
                    builderResult.featureColumn = value
                }
            }
            public var hasFeatureColumn:Bool {
                get {
                    return builderResult.hasFeatureColumn
                }
            }
            @discardableResult
            public func setFeatureColumn(_ value:Int32) -> Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder {
                self.featureColumn = value
                return self
            }
            @discardableResult
            public func clearFeatureColumn() -> Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder{
                builderResult.hasFeatureColumn = false
                builderResult.featureColumn = Int32(0)
                return self
            }
            /// Sorted list of Ids in the set.
            public var featureIds:Array<Int64> {
                get {
                    return builderResult.featureIds
                }
                set (array) {
                    builderResult.featureIds = array
                }
            }
            @discardableResult
            public func setFeatureIds(_ value:Array<Int64>) -> Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder {
                self.featureIds = value
                return self
            }
            @discardableResult
            public func clearFeatureIds() -> Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder {
                builderResult.featureIds.removeAll(keepingCapacity: false)
                return self
            }
            /// Node children indexing into a contiguous
            /// vector of nodes starting from the root.
            public var leftId:Int32 {
                get {
                    return builderResult.leftId
                }
                set (value) {
                    builderResult.hasLeftId = true
                    builderResult.leftId = value
                }
            }
            public var hasLeftId:Bool {
                get {
                    return builderResult.hasLeftId
                }
            }
            @discardableResult
            public func setLeftId(_ value:Int32) -> Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder {
                self.leftId = value
                return self
            }
            @discardableResult
            public func clearLeftId() -> Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder{
                builderResult.hasLeftId = false
                builderResult.leftId = Int32(0)
                return self
            }
            public var rightId:Int32 {
                get {
                    return builderResult.rightId
                }
                set (value) {
                    builderResult.hasRightId = true
                    builderResult.rightId = value
                }
            }
            public var hasRightId:Bool {
                get {
                    return builderResult.hasRightId
                }
            }
            @discardableResult
            public func setRightId(_ value:Int32) -> Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder {
                self.rightId = value
                return self
            }
            @discardableResult
            public func clearRightId() -> Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder{
                builderResult.hasRightId = false
                builderResult.rightId = Int32(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder {
                builderResult = Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit()
                return self
            }
            override public func clone() throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder {
                return try Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit {
                let returnMe:Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit) throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder {
                if other == Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit() {
                    return self
                }
                if other.hasFeatureColumn {
                    featureColumn = other.featureColumn
                }
                if !other.featureIds.isEmpty {
                    builderResult.featureIds += other.featureIds
                }
                if other.hasLeftId {
                    leftId = other.leftId
                }
                if other.hasRightId {
                    rightId = other.rightId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        featureColumn = try codedInputStream.readInt32()

                    case 18:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.featureIds.append(try codedInputStream.readInt64())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 24:
                        leftId = try codedInputStream.readInt32()

                    case 32:
                        rightId = try codedInputStream.readInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder {
                let resultDecodedBuilder = Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder()
                if let jsonValueFeatureColumn = jsonMap["featureColumn"] as? Int {
                    resultDecodedBuilder.featureColumn = Int32(jsonValueFeatureColumn)
                } else if let jsonValueFeatureColumn = jsonMap["featureColumn"] as? String {
                    resultDecodedBuilder.featureColumn = Int32(jsonValueFeatureColumn)!
                }
                if let jsonValueFeatureIds = jsonMap["featureIds"] as? Array<String> {
                    var jsonArrayFeatureIds:Array<Int64> = []
                    for oneValueFeatureIds in jsonValueFeatureIds {
                        jsonArrayFeatureIds.append(Int64(oneValueFeatureIds)!)
                    }
                    resultDecodedBuilder.featureIds = jsonArrayFeatureIds
                }
                if let jsonValueLeftId = jsonMap["leftId"] as? Int {
                    resultDecodedBuilder.leftId = Int32(jsonValueLeftId)
                } else if let jsonValueLeftId = jsonMap["leftId"] as? String {
                    resultDecodedBuilder.leftId = Int32(jsonValueLeftId)!
                }
                if let jsonValueRightId = jsonMap["rightId"] as? Int {
                    resultDecodedBuilder.rightId = Int32(jsonValueRightId)
                } else if let jsonValueRightId = jsonMap["rightId"] as? String {
                    resultDecodedBuilder.rightId = Int32(jsonValueRightId)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// DecisionTreeConfig describes a list of connected nodes.
    /// Node 0 must be the root and can carry any payload including a leaf
    /// in the case of representing the bias.
    /// Note that each node id is implicitly its index in the list of nodes.
    final public class DecisionTreeConfig : GeneratedMessage {

        public static func == (lhs: Tensorflow.BoostedTrees.Trees.DecisionTreeConfig, rhs: Tensorflow.BoostedTrees.Trees.DecisionTreeConfig) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.nodes == rhs.nodes)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var nodes:Array<Tensorflow.BoostedTrees.Trees.TreeNode>  = Array<Tensorflow.BoostedTrees.Trees.TreeNode>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementNodes in nodes {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementNodes)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementNodes in nodes {
                serialize_size += oneElementNodes.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.Builder {
            return Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.classBuilder() as! Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.Builder
        }
        public func getBuilder() -> Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.Builder {
            return classBuilder() as! Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.Builder()
        }
        public func toBuilder() throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.Builder {
            return try Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.BoostedTrees.Trees.DecisionTreeConfig) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.Builder {
            return try Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !nodes.isEmpty {
                var jsonArrayNodes:Array<Dictionary<String,Any>> = []
                for oneValueNodes in nodes {
                    let ecodedMessageNodes = try oneValueNodes.encode()
                    jsonArrayNodes.append(ecodedMessageNodes)
                }
                jsonMap["nodes"] = jsonArrayNodes
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeConfig {
            return try Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeConfig {
            return try Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var nodesElementIndex:Int = 0
            for oneElementNodes in nodes {
                output += "\(indent) nodes[\(nodesElementIndex)] {\n"
                output += try oneElementNodes.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                nodesElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementNodes in nodes {
                    hashCode = (hashCode &* 31) &+ oneElementNodes.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.BoostedTrees.Trees.DecisionTreeConfig"
        }
        override public func className() -> String {
            return "Tensorflow.BoostedTrees.Trees.DecisionTreeConfig"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.BoostedTrees.Trees.DecisionTreeConfig = Tensorflow.BoostedTrees.Trees.DecisionTreeConfig()
            public func getMessage() -> Tensorflow.BoostedTrees.Trees.DecisionTreeConfig {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var nodes:Array<Tensorflow.BoostedTrees.Trees.TreeNode> {
                get {
                    return builderResult.nodes
                }
                set (value) {
                    builderResult.nodes = value
                }
            }
            @discardableResult
            public func setNodes(_ value:Array<Tensorflow.BoostedTrees.Trees.TreeNode>) -> Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.Builder {
                self.nodes = value
                return self
            }
            @discardableResult
            public func clearNodes() -> Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.Builder {
                builderResult.nodes.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.Builder {
                builderResult = Tensorflow.BoostedTrees.Trees.DecisionTreeConfig()
                return self
            }
            override public func clone() throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.Builder {
                return try Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeConfig {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.BoostedTrees.Trees.DecisionTreeConfig {
                let returnMe:Tensorflow.BoostedTrees.Trees.DecisionTreeConfig = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.BoostedTrees.Trees.DecisionTreeConfig) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.Builder {
                if other == Tensorflow.BoostedTrees.Trees.DecisionTreeConfig() {
                    return self
                }
                if !other.nodes.isEmpty  {
                     builderResult.nodes += other.nodes
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Tensorflow.BoostedTrees.Trees.TreeNode.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        nodes.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.Builder {
                let resultDecodedBuilder = Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.Builder()
                if let jsonValueNodes = jsonMap["nodes"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayNodes:Array<Tensorflow.BoostedTrees.Trees.TreeNode> = []
                    for oneValueNodes in jsonValueNodes {
                        let messageFromStringNodes = try Tensorflow.BoostedTrees.Trees.TreeNode.Builder.decodeToBuilder(jsonMap:oneValueNodes).build()

                        jsonArrayNodes.append(messageFromStringNodes)
                    }
                    resultDecodedBuilder.nodes = jsonArrayNodes
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class DecisionTreeMetadata : GeneratedMessage {

        public static func == (lhs: Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata, rhs: Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasNumTreeWeightUpdates == rhs.hasNumTreeWeightUpdates) && (!lhs.hasNumTreeWeightUpdates || lhs.numTreeWeightUpdates == rhs.numTreeWeightUpdates)
            fieldCheck = fieldCheck && (lhs.hasNumLayersGrown == rhs.hasNumLayersGrown) && (!lhs.hasNumLayersGrown || lhs.numLayersGrown == rhs.numLayersGrown)
            fieldCheck = fieldCheck && (lhs.hasIsFinalized == rhs.hasIsFinalized) && (!lhs.hasIsFinalized || lhs.isFinalized == rhs.isFinalized)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// How many times tree weight was updated (due to reweighting of the final
        /// ensemble, dropout, shrinkage etc).
        public fileprivate(set) var numTreeWeightUpdates:Int32 = Int32(0)
        public fileprivate(set) var hasNumTreeWeightUpdates:Bool = false

        /// Number of layers grown for this tree.
        public fileprivate(set) var numLayersGrown:Int32 = Int32(0)
        public fileprivate(set) var hasNumLayersGrown:Bool = false

        /// Whether the tree is finalized in that no more layers can be grown.
        public fileprivate(set) var isFinalized:Bool = false
        public fileprivate(set) var hasIsFinalized:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasNumTreeWeightUpdates {
                try codedOutputStream.writeInt32(fieldNumber: 1, value:numTreeWeightUpdates)
            }
            if hasNumLayersGrown {
                try codedOutputStream.writeInt32(fieldNumber: 2, value:numLayersGrown)
            }
            if hasIsFinalized {
                try codedOutputStream.writeBool(fieldNumber: 3, value:isFinalized)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasNumTreeWeightUpdates {
                serialize_size += numTreeWeightUpdates.computeInt32Size(fieldNumber: 1)
            }
            if hasNumLayersGrown {
                serialize_size += numLayersGrown.computeInt32Size(fieldNumber: 2)
            }
            if hasIsFinalized {
                serialize_size += isFinalized.computeBoolSize(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder {
            return Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.classBuilder() as! Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder
        }
        public func getBuilder() -> Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder {
            return classBuilder() as! Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder()
        }
        public func toBuilder() throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder {
            return try Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder {
            return try Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasNumTreeWeightUpdates {
                jsonMap["numTreeWeightUpdates"] = Int(numTreeWeightUpdates)
            }
            if hasNumLayersGrown {
                jsonMap["numLayersGrown"] = Int(numLayersGrown)
            }
            if hasIsFinalized {
                jsonMap["isFinalized"] = isFinalized
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata {
            return try Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata {
            return try Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasNumTreeWeightUpdates {
                output += "\(indent) numTreeWeightUpdates: \(numTreeWeightUpdates) \n"
            }
            if hasNumLayersGrown {
                output += "\(indent) numLayersGrown: \(numLayersGrown) \n"
            }
            if hasIsFinalized {
                output += "\(indent) isFinalized: \(isFinalized) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasNumTreeWeightUpdates {
                    hashCode = (hashCode &* 31) &+ numTreeWeightUpdates.hashValue
                }
                if hasNumLayersGrown {
                    hashCode = (hashCode &* 31) &+ numLayersGrown.hashValue
                }
                if hasIsFinalized {
                    hashCode = (hashCode &* 31) &+ isFinalized.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata"
        }
        override public func className() -> String {
            return "Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata = Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata()
            public func getMessage() -> Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// How many times tree weight was updated (due to reweighting of the final
            /// ensemble, dropout, shrinkage etc).
            public var numTreeWeightUpdates:Int32 {
                get {
                    return builderResult.numTreeWeightUpdates
                }
                set (value) {
                    builderResult.hasNumTreeWeightUpdates = true
                    builderResult.numTreeWeightUpdates = value
                }
            }
            public var hasNumTreeWeightUpdates:Bool {
                get {
                    return builderResult.hasNumTreeWeightUpdates
                }
            }
            @discardableResult
            public func setNumTreeWeightUpdates(_ value:Int32) -> Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder {
                self.numTreeWeightUpdates = value
                return self
            }
            @discardableResult
            public func clearNumTreeWeightUpdates() -> Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder{
                builderResult.hasNumTreeWeightUpdates = false
                builderResult.numTreeWeightUpdates = Int32(0)
                return self
            }
            /// Number of layers grown for this tree.
            public var numLayersGrown:Int32 {
                get {
                    return builderResult.numLayersGrown
                }
                set (value) {
                    builderResult.hasNumLayersGrown = true
                    builderResult.numLayersGrown = value
                }
            }
            public var hasNumLayersGrown:Bool {
                get {
                    return builderResult.hasNumLayersGrown
                }
            }
            @discardableResult
            public func setNumLayersGrown(_ value:Int32) -> Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder {
                self.numLayersGrown = value
                return self
            }
            @discardableResult
            public func clearNumLayersGrown() -> Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder{
                builderResult.hasNumLayersGrown = false
                builderResult.numLayersGrown = Int32(0)
                return self
            }
            /// Whether the tree is finalized in that no more layers can be grown.
            public var isFinalized:Bool {
                get {
                    return builderResult.isFinalized
                }
                set (value) {
                    builderResult.hasIsFinalized = true
                    builderResult.isFinalized = value
                }
            }
            public var hasIsFinalized:Bool {
                get {
                    return builderResult.hasIsFinalized
                }
            }
            @discardableResult
            public func setIsFinalized(_ value:Bool) -> Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder {
                self.isFinalized = value
                return self
            }
            @discardableResult
            public func clearIsFinalized() -> Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder{
                builderResult.hasIsFinalized = false
                builderResult.isFinalized = false
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder {
                builderResult = Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata()
                return self
            }
            override public func clone() throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder {
                return try Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata {
                let returnMe:Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder {
                if other == Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata() {
                    return self
                }
                if other.hasNumTreeWeightUpdates {
                    numTreeWeightUpdates = other.numTreeWeightUpdates
                }
                if other.hasNumLayersGrown {
                    numLayersGrown = other.numLayersGrown
                }
                if other.hasIsFinalized {
                    isFinalized = other.isFinalized
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        numTreeWeightUpdates = try codedInputStream.readInt32()

                    case 16:
                        numLayersGrown = try codedInputStream.readInt32()

                    case 24:
                        isFinalized = try codedInputStream.readBool()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder {
                let resultDecodedBuilder = Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder()
                if let jsonValueNumTreeWeightUpdates = jsonMap["numTreeWeightUpdates"] as? Int {
                    resultDecodedBuilder.numTreeWeightUpdates = Int32(jsonValueNumTreeWeightUpdates)
                } else if let jsonValueNumTreeWeightUpdates = jsonMap["numTreeWeightUpdates"] as? String {
                    resultDecodedBuilder.numTreeWeightUpdates = Int32(jsonValueNumTreeWeightUpdates)!
                }
                if let jsonValueNumLayersGrown = jsonMap["numLayersGrown"] as? Int {
                    resultDecodedBuilder.numLayersGrown = Int32(jsonValueNumLayersGrown)
                } else if let jsonValueNumLayersGrown = jsonMap["numLayersGrown"] as? String {
                    resultDecodedBuilder.numLayersGrown = Int32(jsonValueNumLayersGrown)!
                }
                if let jsonValueIsFinalized = jsonMap["isFinalized"] as? Bool {
                    resultDecodedBuilder.isFinalized = jsonValueIsFinalized
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// DecisionTreeEnsembleConfig describes an ensemble of decision trees.
    final public class DecisionTreeEnsembleConfig : GeneratedMessage {

        public static func == (lhs: Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig, rhs: Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.trees == rhs.trees)
            fieldCheck = fieldCheck && (lhs.treeWeights == rhs.treeWeights)
            fieldCheck = fieldCheck && (lhs.treeMetadata == rhs.treeMetadata)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var trees:Array<Tensorflow.BoostedTrees.Trees.DecisionTreeConfig>  = Array<Tensorflow.BoostedTrees.Trees.DecisionTreeConfig>()
        public fileprivate(set) var treeWeights:Array<Float> = Array<Float>()
        private var treeWeightsMemoizedSerializedSize:Int32 = -1
        public fileprivate(set) var treeMetadata:Array<Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata>  = Array<Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementTrees in trees {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementTrees)
            }
            if !treeWeights.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 18)
                try codedOutputStream.writeRawVarint32(value: treeWeightsMemoizedSerializedSize)
                for oneValuetreeWeights in treeWeights {
                    try codedOutputStream.writeFloatNoTag(value: oneValuetreeWeights)
                }
            }
            for oneElementTreeMetadata in treeMetadata {
                  try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementTreeMetadata)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementTrees in trees {
                serialize_size += oneElementTrees.computeMessageSize(fieldNumber: 1)
            }
            var dataSizeTreeWeights:Int32 = 0
            dataSizeTreeWeights = 4 * Int32(treeWeights.count)
            serialize_size += dataSizeTreeWeights
            if !treeWeights.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeTreeWeights.computeInt32SizeNoTag()
            }
            treeWeightsMemoizedSerializedSize = dataSizeTreeWeights
            for oneElementTreeMetadata in treeMetadata {
                serialize_size += oneElementTreeMetadata.computeMessageSize(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.Builder {
            return Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.classBuilder() as! Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.Builder
        }
        public func getBuilder() -> Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.Builder {
            return classBuilder() as! Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.Builder()
        }
        public func toBuilder() throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.Builder {
            return try Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.Builder {
            return try Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !trees.isEmpty {
                var jsonArrayTrees:Array<Dictionary<String,Any>> = []
                for oneValueTrees in trees {
                    let ecodedMessageTrees = try oneValueTrees.encode()
                    jsonArrayTrees.append(ecodedMessageTrees)
                }
                jsonMap["trees"] = jsonArrayTrees
            }
            if !treeWeights.isEmpty {
                var jsonArrayTreeWeights:Array<Float> = []
                for oneValueTreeWeights in treeWeights {
                    jsonArrayTreeWeights.append(Float(oneValueTreeWeights))
                }
                jsonMap["treeWeights"] = jsonArrayTreeWeights
            }
            if !treeMetadata.isEmpty {
                var jsonArrayTreeMetadata:Array<Dictionary<String,Any>> = []
                for oneValueTreeMetadata in treeMetadata {
                    let ecodedMessageTreeMetadata = try oneValueTreeMetadata.encode()
                    jsonArrayTreeMetadata.append(ecodedMessageTreeMetadata)
                }
                jsonMap["treeMetadata"] = jsonArrayTreeMetadata
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig {
            return try Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig {
            return try Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var treesElementIndex:Int = 0
            for oneElementTrees in trees {
                output += "\(indent) trees[\(treesElementIndex)] {\n"
                output += try oneElementTrees.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                treesElementIndex += 1
            }
            var treeWeightsElementIndex:Int = 0
            for oneValueTreeWeights in treeWeights  {
                output += "\(indent) treeWeights[\(treeWeightsElementIndex)]: \(oneValueTreeWeights)\n"
                treeWeightsElementIndex += 1
            }
            var treeMetadataElementIndex:Int = 0
            for oneElementTreeMetadata in treeMetadata {
                output += "\(indent) treeMetadata[\(treeMetadataElementIndex)] {\n"
                output += try oneElementTreeMetadata.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                treeMetadataElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementTrees in trees {
                    hashCode = (hashCode &* 31) &+ oneElementTrees.hashValue
                }
                for oneValueTreeWeights in treeWeights {
                    hashCode = (hashCode &* 31) &+ oneValueTreeWeights.hashValue
                }
                for oneElementTreeMetadata in treeMetadata {
                    hashCode = (hashCode &* 31) &+ oneElementTreeMetadata.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig"
        }
        override public func className() -> String {
            return "Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig = Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig()
            public func getMessage() -> Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var trees:Array<Tensorflow.BoostedTrees.Trees.DecisionTreeConfig> {
                get {
                    return builderResult.trees
                }
                set (value) {
                    builderResult.trees = value
                }
            }
            @discardableResult
            public func setTrees(_ value:Array<Tensorflow.BoostedTrees.Trees.DecisionTreeConfig>) -> Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.Builder {
                self.trees = value
                return self
            }
            @discardableResult
            public func clearTrees() -> Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.Builder {
                builderResult.trees.removeAll(keepingCapacity: false)
                return self
            }
            public var treeWeights:Array<Float> {
                get {
                    return builderResult.treeWeights
                }
                set (array) {
                    builderResult.treeWeights = array
                }
            }
            @discardableResult
            public func setTreeWeights(_ value:Array<Float>) -> Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.Builder {
                self.treeWeights = value
                return self
            }
            @discardableResult
            public func clearTreeWeights() -> Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.Builder {
                builderResult.treeWeights.removeAll(keepingCapacity: false)
                return self
            }
            public var treeMetadata:Array<Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata> {
                get {
                    return builderResult.treeMetadata
                }
                set (value) {
                    builderResult.treeMetadata = value
                }
            }
            @discardableResult
            public func setTreeMetadata(_ value:Array<Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata>) -> Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.Builder {
                self.treeMetadata = value
                return self
            }
            @discardableResult
            public func clearTreeMetadata() -> Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.Builder {
                builderResult.treeMetadata.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.Builder {
                builderResult = Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig()
                return self
            }
            override public func clone() throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.Builder {
                return try Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig {
                let returnMe:Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.Builder {
                if other == Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig() {
                    return self
                }
                if !other.trees.isEmpty  {
                     builderResult.trees += other.trees
                }
                if !other.treeWeights.isEmpty {
                    builderResult.treeWeights += other.treeWeights
                }
                if !other.treeMetadata.isEmpty  {
                     builderResult.treeMetadata += other.treeMetadata
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        trees.append(subBuilder.buildPartial())

                    case 18:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.treeWeights.append(try codedInputStream.readFloat())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 26:
                        let subBuilder = Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        treeMetadata.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.Builder {
                let resultDecodedBuilder = Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.Builder()
                if let jsonValueTrees = jsonMap["trees"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayTrees:Array<Tensorflow.BoostedTrees.Trees.DecisionTreeConfig> = []
                    for oneValueTrees in jsonValueTrees {
                        let messageFromStringTrees = try Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.Builder.decodeToBuilder(jsonMap:oneValueTrees).build()

                        jsonArrayTrees.append(messageFromStringTrees)
                    }
                    resultDecodedBuilder.trees = jsonArrayTrees
                }
                if let jsonValueTreeWeights = jsonMap["treeWeights"] as? Array<Float> {
                    var jsonArrayTreeWeights:Array<Float> = []
                    for oneValueTreeWeights in jsonValueTreeWeights {
                        jsonArrayTreeWeights.append(Float(oneValueTreeWeights))
                    }
                    resultDecodedBuilder.treeWeights = jsonArrayTreeWeights
                }
                if let jsonValueTreeMetadata = jsonMap["treeMetadata"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayTreeMetadata:Array<Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata> = []
                    for oneValueTreeMetadata in jsonValueTreeMetadata {
                        let messageFromStringTreeMetadata = try Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder.decodeToBuilder(jsonMap:oneValueTreeMetadata).build()

                        jsonArrayTreeMetadata.append(messageFromStringTreeMetadata)
                    }
                    resultDecodedBuilder.treeMetadata = jsonArrayTreeMetadata
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.BoostedTrees.Trees.TreeNode: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.BoostedTrees.Trees.TreeNode> {
        var mergedArray = Array<Tensorflow.BoostedTrees.Trees.TreeNode>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Trees.TreeNode? {
        return try Tensorflow.BoostedTrees.Trees.TreeNode.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.BoostedTrees.Trees.TreeNode {
        return try Tensorflow.BoostedTrees.Trees.TreeNode.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.BoostedTrees.Trees.TreeConfigRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.TreeNode {
        return try Tensorflow.BoostedTrees.Trees.TreeNode.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Trees.TreeNode {
        return try Tensorflow.BoostedTrees.Trees.TreeNode.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.TreeNode {
        return try Tensorflow.BoostedTrees.Trees.TreeNode.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Trees.TreeNode {
        return try Tensorflow.BoostedTrees.Trees.TreeNode.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.TreeNode {
        return try Tensorflow.BoostedTrees.Trees.TreeNode.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "leaf": return self.leaf
        case "denseFloatBinarySplit": return self.denseFloatBinarySplit
        case "sparseFloatBinarySplitDefaultLeft": return self.sparseFloatBinarySplitDefaultLeft
        case "sparseFloatBinarySplitDefaultRight": return self.sparseFloatBinarySplitDefaultRight
        case "categoricalIdBinarySplit": return self.categoricalIdBinarySplit
        case "categoricalIdSetMembershipBinarySplit": return self.categoricalIdSetMembershipBinarySplit
        case "nodeMetadata": return self.nodeMetadata
        default: return nil
        }
    }
}
extension Tensorflow.BoostedTrees.Trees.TreeNode.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "leaf": return self.leaf
            case "denseFloatBinarySplit": return self.denseFloatBinarySplit
            case "sparseFloatBinarySplitDefaultLeft": return self.sparseFloatBinarySplitDefaultLeft
            case "sparseFloatBinarySplitDefaultRight": return self.sparseFloatBinarySplitDefaultRight
            case "categoricalIdBinarySplit": return self.categoricalIdBinarySplit
            case "categoricalIdSetMembershipBinarySplit": return self.categoricalIdSetMembershipBinarySplit
            case "nodeMetadata": return self.nodeMetadata
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "leaf":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.BoostedTrees.Trees.Leaf else {
                    return
                }
                self.leaf = newSubscriptValue
            case "denseFloatBinarySplit":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit else {
                    return
                }
                self.denseFloatBinarySplit = newSubscriptValue
            case "sparseFloatBinarySplitDefaultLeft":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft else {
                    return
                }
                self.sparseFloatBinarySplitDefaultLeft = newSubscriptValue
            case "sparseFloatBinarySplitDefaultRight":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight else {
                    return
                }
                self.sparseFloatBinarySplitDefaultRight = newSubscriptValue
            case "categoricalIdBinarySplit":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit else {
                    return
                }
                self.categoricalIdBinarySplit = newSubscriptValue
            case "categoricalIdSetMembershipBinarySplit":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit else {
                    return
                }
                self.categoricalIdSetMembershipBinarySplit = newSubscriptValue
            case "nodeMetadata":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.BoostedTrees.Trees.TreeNodeMetadata else {
                    return
                }
                self.nodeMetadata = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.BoostedTrees.Trees.TreeNodeMetadata: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.BoostedTrees.Trees.TreeNodeMetadata> {
        var mergedArray = Array<Tensorflow.BoostedTrees.Trees.TreeNodeMetadata>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Trees.TreeNodeMetadata? {
        return try Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.BoostedTrees.Trees.TreeNodeMetadata {
        return try Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.BoostedTrees.Trees.TreeConfigRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.TreeNodeMetadata {
        return try Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Trees.TreeNodeMetadata {
        return try Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.TreeNodeMetadata {
        return try Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Trees.TreeNodeMetadata {
        return try Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.TreeNodeMetadata {
        return try Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "gain": return self.gain
        case "originalLeaf": return self.originalLeaf
        default: return nil
        }
    }
}
extension Tensorflow.BoostedTrees.Trees.TreeNodeMetadata.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "gain": return self.gain
            case "originalLeaf": return self.originalLeaf
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "gain":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.gain = newSubscriptValue
            case "originalLeaf":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.BoostedTrees.Trees.Leaf else {
                    return
                }
                self.originalLeaf = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.BoostedTrees.Trees.Leaf: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.BoostedTrees.Trees.Leaf> {
        var mergedArray = Array<Tensorflow.BoostedTrees.Trees.Leaf>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Trees.Leaf? {
        return try Tensorflow.BoostedTrees.Trees.Leaf.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.BoostedTrees.Trees.Leaf {
        return try Tensorflow.BoostedTrees.Trees.Leaf.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.BoostedTrees.Trees.TreeConfigRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.Leaf {
        return try Tensorflow.BoostedTrees.Trees.Leaf.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Trees.Leaf {
        return try Tensorflow.BoostedTrees.Trees.Leaf.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.Leaf {
        return try Tensorflow.BoostedTrees.Trees.Leaf.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Trees.Leaf {
        return try Tensorflow.BoostedTrees.Trees.Leaf.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.Leaf {
        return try Tensorflow.BoostedTrees.Trees.Leaf.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "vector": return self.vector
        case "sparseVector": return self.sparseVector
        default: return nil
        }
    }
}
extension Tensorflow.BoostedTrees.Trees.Leaf.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "vector": return self.vector
            case "sparseVector": return self.sparseVector
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "vector":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.BoostedTrees.Trees.Vector else {
                    return
                }
                self.vector = newSubscriptValue
            case "sparseVector":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.BoostedTrees.Trees.SparseVector else {
                    return
                }
                self.sparseVector = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.BoostedTrees.Trees.Vector: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.BoostedTrees.Trees.Vector> {
        var mergedArray = Array<Tensorflow.BoostedTrees.Trees.Vector>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Trees.Vector? {
        return try Tensorflow.BoostedTrees.Trees.Vector.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.BoostedTrees.Trees.Vector {
        return try Tensorflow.BoostedTrees.Trees.Vector.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.BoostedTrees.Trees.TreeConfigRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.Vector {
        return try Tensorflow.BoostedTrees.Trees.Vector.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Trees.Vector {
        return try Tensorflow.BoostedTrees.Trees.Vector.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.Vector {
        return try Tensorflow.BoostedTrees.Trees.Vector.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Trees.Vector {
        return try Tensorflow.BoostedTrees.Trees.Vector.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.Vector {
        return try Tensorflow.BoostedTrees.Trees.Vector.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.BoostedTrees.Trees.Vector.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Array<Float> else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.BoostedTrees.Trees.SparseVector: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.BoostedTrees.Trees.SparseVector> {
        var mergedArray = Array<Tensorflow.BoostedTrees.Trees.SparseVector>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Trees.SparseVector? {
        return try Tensorflow.BoostedTrees.Trees.SparseVector.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.BoostedTrees.Trees.SparseVector {
        return try Tensorflow.BoostedTrees.Trees.SparseVector.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.BoostedTrees.Trees.TreeConfigRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.SparseVector {
        return try Tensorflow.BoostedTrees.Trees.SparseVector.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Trees.SparseVector {
        return try Tensorflow.BoostedTrees.Trees.SparseVector.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.SparseVector {
        return try Tensorflow.BoostedTrees.Trees.SparseVector.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Trees.SparseVector {
        return try Tensorflow.BoostedTrees.Trees.SparseVector.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.SparseVector {
        return try Tensorflow.BoostedTrees.Trees.SparseVector.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "index": return self.index
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.BoostedTrees.Trees.SparseVector.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "index": return self.index
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "index":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int32> else {
                    return
                }
                self.index = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Array<Float> else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit> {
        var mergedArray = Array<Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit? {
        return try Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit {
        return try Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.BoostedTrees.Trees.TreeConfigRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit {
        return try Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit {
        return try Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit {
        return try Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit {
        return try Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit {
        return try Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "featureColumn": return self.featureColumn
        case "threshold": return self.threshold
        case "leftId": return self.leftId
        case "rightId": return self.rightId
        default: return nil
        }
    }
}
extension Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "featureColumn": return self.featureColumn
            case "threshold": return self.threshold
            case "leftId": return self.leftId
            case "rightId": return self.rightId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "featureColumn":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.featureColumn = newSubscriptValue
            case "threshold":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.threshold = newSubscriptValue
            case "leftId":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.leftId = newSubscriptValue
            case "rightId":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.rightId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft> {
        var mergedArray = Array<Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft? {
        return try Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft {
        return try Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.BoostedTrees.Trees.TreeConfigRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft {
        return try Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft {
        return try Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft {
        return try Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft {
        return try Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft {
        return try Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "split": return self.split
        default: return nil
        }
    }
}
extension Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultLeft.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "split": return self.split
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "split":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit else {
                    return
                }
                self.split = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight> {
        var mergedArray = Array<Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight? {
        return try Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight {
        return try Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.BoostedTrees.Trees.TreeConfigRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight {
        return try Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight {
        return try Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight {
        return try Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight {
        return try Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight {
        return try Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "split": return self.split
        default: return nil
        }
    }
}
extension Tensorflow.BoostedTrees.Trees.SparseFloatBinarySplitDefaultRight.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "split": return self.split
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "split":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.BoostedTrees.Trees.DenseFloatBinarySplit else {
                    return
                }
                self.split = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit> {
        var mergedArray = Array<Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit? {
        return try Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit {
        return try Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.BoostedTrees.Trees.TreeConfigRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit {
        return try Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit {
        return try Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit {
        return try Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit {
        return try Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit {
        return try Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "featureColumn": return self.featureColumn
        case "featureId": return self.featureId
        case "leftId": return self.leftId
        case "rightId": return self.rightId
        default: return nil
        }
    }
}
extension Tensorflow.BoostedTrees.Trees.CategoricalIdBinarySplit.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "featureColumn": return self.featureColumn
            case "featureId": return self.featureId
            case "leftId": return self.leftId
            case "rightId": return self.rightId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "featureColumn":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.featureColumn = newSubscriptValue
            case "featureId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.featureId = newSubscriptValue
            case "leftId":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.leftId = newSubscriptValue
            case "rightId":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.rightId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit> {
        var mergedArray = Array<Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit? {
        return try Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit {
        return try Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.BoostedTrees.Trees.TreeConfigRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit {
        return try Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit {
        return try Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit {
        return try Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit {
        return try Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit {
        return try Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "featureColumn": return self.featureColumn
        case "featureIds": return self.featureIds
        case "leftId": return self.leftId
        case "rightId": return self.rightId
        default: return nil
        }
    }
}
extension Tensorflow.BoostedTrees.Trees.CategoricalIdSetMembershipBinarySplit.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "featureColumn": return self.featureColumn
            case "featureIds": return self.featureIds
            case "leftId": return self.leftId
            case "rightId": return self.rightId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "featureColumn":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.featureColumn = newSubscriptValue
            case "featureIds":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.featureIds = newSubscriptValue
            case "leftId":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.leftId = newSubscriptValue
            case "rightId":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.rightId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.BoostedTrees.Trees.DecisionTreeConfig: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.BoostedTrees.Trees.DecisionTreeConfig> {
        var mergedArray = Array<Tensorflow.BoostedTrees.Trees.DecisionTreeConfig>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeConfig? {
        return try Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeConfig {
        return try Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.BoostedTrees.Trees.TreeConfigRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeConfig {
        return try Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeConfig {
        return try Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeConfig {
        return try Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeConfig {
        return try Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeConfig {
        return try Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "nodes": return self.nodes
        default: return nil
        }
    }
}
extension Tensorflow.BoostedTrees.Trees.DecisionTreeConfig.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "nodes": return self.nodes
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "nodes":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.BoostedTrees.Trees.TreeNode> else {
                    return
                }
                self.nodes = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata> {
        var mergedArray = Array<Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata? {
        return try Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata {
        return try Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.BoostedTrees.Trees.TreeConfigRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata {
        return try Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata {
        return try Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata {
        return try Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata {
        return try Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata {
        return try Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "numTreeWeightUpdates": return self.numTreeWeightUpdates
        case "numLayersGrown": return self.numLayersGrown
        case "isFinalized": return self.isFinalized
        default: return nil
        }
    }
}
extension Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "numTreeWeightUpdates": return self.numTreeWeightUpdates
            case "numLayersGrown": return self.numLayersGrown
            case "isFinalized": return self.isFinalized
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "numTreeWeightUpdates":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.numTreeWeightUpdates = newSubscriptValue
            case "numLayersGrown":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.numLayersGrown = newSubscriptValue
            case "isFinalized":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.isFinalized = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig> {
        var mergedArray = Array<Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig? {
        return try Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig {
        return try Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.BoostedTrees.Trees.TreeConfigRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig {
        return try Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig {
        return try Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig {
        return try Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig {
        return try Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig {
        return try Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "trees": return self.trees
        case "treeWeights": return self.treeWeights
        case "treeMetadata": return self.treeMetadata
        default: return nil
        }
    }
}
extension Tensorflow.BoostedTrees.Trees.DecisionTreeEnsembleConfig.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "trees": return self.trees
            case "treeWeights": return self.treeWeights
            case "treeMetadata": return self.treeMetadata
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "trees":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.BoostedTrees.Trees.DecisionTreeConfig> else {
                    return
                }
                self.trees = newSubscriptValue
            case "treeWeights":
                guard let newSubscriptValue = newSubscriptValue as? Array<Float> else {
                    return
                }
                self.treeWeights = newSubscriptValue
            case "treeMetadata":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.BoostedTrees.Trees.DecisionTreeMetadata> else {
                    return
                }
                self.treeMetadata = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "saver.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { }

public extension Tensorflow {
    public struct SaverRoot {
        public static let `default` = SaverRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    /// Protocol buffer representing the configuration of a Saver.
    final public class SaverDef : GeneratedMessage {

        public static func == (lhs: Tensorflow.SaverDef, rhs: Tensorflow.SaverDef) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasFilenameTensorName == rhs.hasFilenameTensorName) && (!lhs.hasFilenameTensorName || lhs.filenameTensorName == rhs.filenameTensorName)
            fieldCheck = fieldCheck && (lhs.hasSaveTensorName == rhs.hasSaveTensorName) && (!lhs.hasSaveTensorName || lhs.saveTensorName == rhs.saveTensorName)
            fieldCheck = fieldCheck && (lhs.hasRestoreOpName == rhs.hasRestoreOpName) && (!lhs.hasRestoreOpName || lhs.restoreOpName == rhs.restoreOpName)
            fieldCheck = fieldCheck && (lhs.hasMaxToKeep == rhs.hasMaxToKeep) && (!lhs.hasMaxToKeep || lhs.maxToKeep == rhs.maxToKeep)
            fieldCheck = fieldCheck && (lhs.hasSharded == rhs.hasSharded) && (!lhs.hasSharded || lhs.sharded == rhs.sharded)
            fieldCheck = fieldCheck && (lhs.hasKeepCheckpointEveryNHours == rhs.hasKeepCheckpointEveryNHours) && (!lhs.hasKeepCheckpointEveryNHours || lhs.keepCheckpointEveryNHours == rhs.keepCheckpointEveryNHours)
            fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



            //Enum type declaration start 

            /// A version number that identifies a different on-disk checkpoint format.
            /// Usually, each subclass of BaseSaverBuilder works with a particular
            /// version/format.  However, it is possible that the same builder may be
            /// upgraded to support a newer checkpoint format in the future.
            public enum CheckpointFormatVersion:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
                /// Internal legacy format.
                case legacy = 0

                /// Current format: tf.Saver() which works with tensorflow::table::Table.
                case v1 = 1

                /// Experimental format under development.
                case v2 = 2
                public func toString() -> String {
                    switch self {
                    case .legacy: return "LEGACY"
                    case .v1: return "V1"
                    case .v2: return "V2"
                    }
                }
                public static func fromString(str:String) throws -> Tensorflow.SaverDef.CheckpointFormatVersion {
                    switch str {
                    case "LEGACY":    return .legacy
                    case "V1":    return .v1
                    case "V2":    return .v2
                    default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
                    }
                }
                public var debugDescription:String { return getDescription() }
                public var description:String { return getDescription() }
                private func getDescription() -> String { 
                    switch self {
                    case .legacy: return ".legacy"
                    case .v1: return ".v1"
                    case .v2: return ".v2"
                    }
                }
                public var hashValue:Int {
                    return self.rawValue.hashValue
                }
                public static func ==(lhs:CheckpointFormatVersion, rhs:CheckpointFormatVersion) -> Bool {
                    return lhs.hashValue == rhs.hashValue
                }
            }

            //Enum type declaration end 

        /// The name of the tensor in which to specify the filename when saving or
        /// restoring a model checkpoint.
        public fileprivate(set) var filenameTensorName:String = ""
        public fileprivate(set) var hasFilenameTensorName:Bool = false

        /// The operation to run when saving a model checkpoint.
        public fileprivate(set) var saveTensorName:String = ""
        public fileprivate(set) var hasSaveTensorName:Bool = false

        /// The operation to run when restoring a model checkpoint.
        public fileprivate(set) var restoreOpName:String = ""
        public fileprivate(set) var hasRestoreOpName:Bool = false

        /// Maximum number of checkpoints to keep.  If 0, no checkpoints are deleted.
        public fileprivate(set) var maxToKeep:Int32 = Int32(0)
        public fileprivate(set) var hasMaxToKeep:Bool = false

        /// Shard the save files, one per device that has Variable nodes.
        public fileprivate(set) var sharded:Bool = false
        public fileprivate(set) var hasSharded:Bool = false

        /// How often to keep an additional checkpoint. If not specified, only the last
        /// "max_to_keep" checkpoints are kept; if specified, in addition to keeping
        /// the last "max_to_keep" checkpoints, an additional checkpoint will be kept
        /// for every n hours of training.
        public fileprivate(set) var keepCheckpointEveryNHours:Float = Float(0)
        public fileprivate(set) var hasKeepCheckpointEveryNHours:Bool = false

        public fileprivate(set) var version:Tensorflow.SaverDef.CheckpointFormatVersion = Tensorflow.SaverDef.CheckpointFormatVersion.legacy
        public fileprivate(set) var hasVersion:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasFilenameTensorName {
                try codedOutputStream.writeString(fieldNumber: 1, value:filenameTensorName)
            }
            if hasSaveTensorName {
                try codedOutputStream.writeString(fieldNumber: 2, value:saveTensorName)
            }
            if hasRestoreOpName {
                try codedOutputStream.writeString(fieldNumber: 3, value:restoreOpName)
            }
            if hasMaxToKeep {
                try codedOutputStream.writeInt32(fieldNumber: 4, value:maxToKeep)
            }
            if hasSharded {
                try codedOutputStream.writeBool(fieldNumber: 5, value:sharded)
            }
            if hasKeepCheckpointEveryNHours {
                try codedOutputStream.writeFloat(fieldNumber: 6, value:keepCheckpointEveryNHours)
            }
            if hasVersion {
                try codedOutputStream.writeEnum(fieldNumber: 7, value:version.rawValue)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasFilenameTensorName {
                serialize_size += filenameTensorName.computeStringSize(fieldNumber: 1)
            }
            if hasSaveTensorName {
                serialize_size += saveTensorName.computeStringSize(fieldNumber: 2)
            }
            if hasRestoreOpName {
                serialize_size += restoreOpName.computeStringSize(fieldNumber: 3)
            }
            if hasMaxToKeep {
                serialize_size += maxToKeep.computeInt32Size(fieldNumber: 4)
            }
            if hasSharded {
                serialize_size += sharded.computeBoolSize(fieldNumber: 5)
            }
            if hasKeepCheckpointEveryNHours {
                serialize_size += keepCheckpointEveryNHours.computeFloatSize(fieldNumber: 6)
            }
            if (hasVersion) {
                serialize_size += version.rawValue.computeEnumSize(fieldNumber: 7)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.SaverDef.Builder {
            return Tensorflow.SaverDef.classBuilder() as! Tensorflow.SaverDef.Builder
        }
        public func getBuilder() -> Tensorflow.SaverDef.Builder {
            return classBuilder() as! Tensorflow.SaverDef.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.SaverDef.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.SaverDef.Builder()
        }
        public func toBuilder() throws -> Tensorflow.SaverDef.Builder {
            return try Tensorflow.SaverDef.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.SaverDef) throws -> Tensorflow.SaverDef.Builder {
            return try Tensorflow.SaverDef.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasFilenameTensorName {
                jsonMap["filenameTensorName"] = filenameTensorName
            }
            if hasSaveTensorName {
                jsonMap["saveTensorName"] = saveTensorName
            }
            if hasRestoreOpName {
                jsonMap["restoreOpName"] = restoreOpName
            }
            if hasMaxToKeep {
                jsonMap["maxToKeep"] = Int(maxToKeep)
            }
            if hasSharded {
                jsonMap["sharded"] = sharded
            }
            if hasKeepCheckpointEveryNHours {
                jsonMap["keepCheckpointEveryNHours"] = Float(keepCheckpointEveryNHours)
            }
            if hasVersion {
                jsonMap["version"] = version.toString()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.SaverDef {
            return try Tensorflow.SaverDef.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.SaverDef {
            return try Tensorflow.SaverDef.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasFilenameTensorName {
                output += "\(indent) filenameTensorName: \(filenameTensorName) \n"
            }
            if hasSaveTensorName {
                output += "\(indent) saveTensorName: \(saveTensorName) \n"
            }
            if hasRestoreOpName {
                output += "\(indent) restoreOpName: \(restoreOpName) \n"
            }
            if hasMaxToKeep {
                output += "\(indent) maxToKeep: \(maxToKeep) \n"
            }
            if hasSharded {
                output += "\(indent) sharded: \(sharded) \n"
            }
            if hasKeepCheckpointEveryNHours {
                output += "\(indent) keepCheckpointEveryNHours: \(keepCheckpointEveryNHours) \n"
            }
            if (hasVersion) {
                output += "\(indent) version: \(version.description)\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasFilenameTensorName {
                    hashCode = (hashCode &* 31) &+ filenameTensorName.hashValue
                }
                if hasSaveTensorName {
                    hashCode = (hashCode &* 31) &+ saveTensorName.hashValue
                }
                if hasRestoreOpName {
                    hashCode = (hashCode &* 31) &+ restoreOpName.hashValue
                }
                if hasMaxToKeep {
                    hashCode = (hashCode &* 31) &+ maxToKeep.hashValue
                }
                if hasSharded {
                    hashCode = (hashCode &* 31) &+ sharded.hashValue
                }
                if hasKeepCheckpointEveryNHours {
                    hashCode = (hashCode &* 31) &+ keepCheckpointEveryNHours.hashValue
                }
                if hasVersion {
                     hashCode = (hashCode &* 31) &+ version.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.SaverDef"
        }
        override public func className() -> String {
            return "Tensorflow.SaverDef"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.SaverDef = Tensorflow.SaverDef()
            public func getMessage() -> Tensorflow.SaverDef {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The name of the tensor in which to specify the filename when saving or
            /// restoring a model checkpoint.
            public var filenameTensorName:String {
                get {
                    return builderResult.filenameTensorName
                }
                set (value) {
                    builderResult.hasFilenameTensorName = true
                    builderResult.filenameTensorName = value
                }
            }
            public var hasFilenameTensorName:Bool {
                get {
                    return builderResult.hasFilenameTensorName
                }
            }
            @discardableResult
            public func setFilenameTensorName(_ value:String) -> Tensorflow.SaverDef.Builder {
                self.filenameTensorName = value
                return self
            }
            @discardableResult
            public func clearFilenameTensorName() -> Tensorflow.SaverDef.Builder{
                builderResult.hasFilenameTensorName = false
                builderResult.filenameTensorName = ""
                return self
            }
            /// The operation to run when saving a model checkpoint.
            public var saveTensorName:String {
                get {
                    return builderResult.saveTensorName
                }
                set (value) {
                    builderResult.hasSaveTensorName = true
                    builderResult.saveTensorName = value
                }
            }
            public var hasSaveTensorName:Bool {
                get {
                    return builderResult.hasSaveTensorName
                }
            }
            @discardableResult
            public func setSaveTensorName(_ value:String) -> Tensorflow.SaverDef.Builder {
                self.saveTensorName = value
                return self
            }
            @discardableResult
            public func clearSaveTensorName() -> Tensorflow.SaverDef.Builder{
                builderResult.hasSaveTensorName = false
                builderResult.saveTensorName = ""
                return self
            }
            /// The operation to run when restoring a model checkpoint.
            public var restoreOpName:String {
                get {
                    return builderResult.restoreOpName
                }
                set (value) {
                    builderResult.hasRestoreOpName = true
                    builderResult.restoreOpName = value
                }
            }
            public var hasRestoreOpName:Bool {
                get {
                    return builderResult.hasRestoreOpName
                }
            }
            @discardableResult
            public func setRestoreOpName(_ value:String) -> Tensorflow.SaverDef.Builder {
                self.restoreOpName = value
                return self
            }
            @discardableResult
            public func clearRestoreOpName() -> Tensorflow.SaverDef.Builder{
                builderResult.hasRestoreOpName = false
                builderResult.restoreOpName = ""
                return self
            }
            /// Maximum number of checkpoints to keep.  If 0, no checkpoints are deleted.
            public var maxToKeep:Int32 {
                get {
                    return builderResult.maxToKeep
                }
                set (value) {
                    builderResult.hasMaxToKeep = true
                    builderResult.maxToKeep = value
                }
            }
            public var hasMaxToKeep:Bool {
                get {
                    return builderResult.hasMaxToKeep
                }
            }
            @discardableResult
            public func setMaxToKeep(_ value:Int32) -> Tensorflow.SaverDef.Builder {
                self.maxToKeep = value
                return self
            }
            @discardableResult
            public func clearMaxToKeep() -> Tensorflow.SaverDef.Builder{
                builderResult.hasMaxToKeep = false
                builderResult.maxToKeep = Int32(0)
                return self
            }
            /// Shard the save files, one per device that has Variable nodes.
            public var sharded:Bool {
                get {
                    return builderResult.sharded
                }
                set (value) {
                    builderResult.hasSharded = true
                    builderResult.sharded = value
                }
            }
            public var hasSharded:Bool {
                get {
                    return builderResult.hasSharded
                }
            }
            @discardableResult
            public func setSharded(_ value:Bool) -> Tensorflow.SaverDef.Builder {
                self.sharded = value
                return self
            }
            @discardableResult
            public func clearSharded() -> Tensorflow.SaverDef.Builder{
                builderResult.hasSharded = false
                builderResult.sharded = false
                return self
            }
            /// How often to keep an additional checkpoint. If not specified, only the last
            /// "max_to_keep" checkpoints are kept; if specified, in addition to keeping
            /// the last "max_to_keep" checkpoints, an additional checkpoint will be kept
            /// for every n hours of training.
            public var keepCheckpointEveryNHours:Float {
                get {
                    return builderResult.keepCheckpointEveryNHours
                }
                set (value) {
                    builderResult.hasKeepCheckpointEveryNHours = true
                    builderResult.keepCheckpointEveryNHours = value
                }
            }
            public var hasKeepCheckpointEveryNHours:Bool {
                get {
                    return builderResult.hasKeepCheckpointEveryNHours
                }
            }
            @discardableResult
            public func setKeepCheckpointEveryNHours(_ value:Float) -> Tensorflow.SaverDef.Builder {
                self.keepCheckpointEveryNHours = value
                return self
            }
            @discardableResult
            public func clearKeepCheckpointEveryNHours() -> Tensorflow.SaverDef.Builder{
                builderResult.hasKeepCheckpointEveryNHours = false
                builderResult.keepCheckpointEveryNHours = Float(0)
                return self
            }
                public var version:Tensorflow.SaverDef.CheckpointFormatVersion {
                    get {
                        return builderResult.version
                    }
                    set (value) {
                        builderResult.hasVersion = true
                        builderResult.version = value
                    }
                }
                public var hasVersion:Bool{
                    get {
                        return builderResult.hasVersion
                    }
                }
            @discardableResult
                public func setVersion(_ value:Tensorflow.SaverDef.CheckpointFormatVersion) -> Tensorflow.SaverDef.Builder {
                  self.version = value
                  return self
                }
            @discardableResult
                public func clearVersion() -> Tensorflow.SaverDef.Builder {
                   builderResult.hasVersion = false
                   builderResult.version = .legacy
                   return self
                }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.SaverDef.Builder {
                builderResult = Tensorflow.SaverDef()
                return self
            }
            override public func clone() throws -> Tensorflow.SaverDef.Builder {
                return try Tensorflow.SaverDef.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.SaverDef {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.SaverDef {
                let returnMe:Tensorflow.SaverDef = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.SaverDef) throws -> Tensorflow.SaverDef.Builder {
                if other == Tensorflow.SaverDef() {
                    return self
                }
                if other.hasFilenameTensorName {
                    filenameTensorName = other.filenameTensorName
                }
                if other.hasSaveTensorName {
                    saveTensorName = other.saveTensorName
                }
                if other.hasRestoreOpName {
                    restoreOpName = other.restoreOpName
                }
                if other.hasMaxToKeep {
                    maxToKeep = other.maxToKeep
                }
                if other.hasSharded {
                    sharded = other.sharded
                }
                if other.hasKeepCheckpointEveryNHours {
                    keepCheckpointEveryNHours = other.keepCheckpointEveryNHours
                }
                if other.hasVersion {
                    version = other.version
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.SaverDef.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.SaverDef.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        filenameTensorName = try codedInputStream.readString()

                    case 18:
                        saveTensorName = try codedInputStream.readString()

                    case 26:
                        restoreOpName = try codedInputStream.readString()

                    case 32:
                        maxToKeep = try codedInputStream.readInt32()

                    case 40:
                        sharded = try codedInputStream.readBool()

                    case 53:
                        keepCheckpointEveryNHours = try codedInputStream.readFloat()

                    case 56:
                        let valueIntversion = try codedInputStream.readEnum()
                        if let enumsversion = Tensorflow.SaverDef.CheckpointFormatVersion(rawValue:valueIntversion){
                            version = enumsversion
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 7, value:Int64(valueIntversion))
                        }

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.SaverDef.Builder {
                let resultDecodedBuilder = Tensorflow.SaverDef.Builder()
                if let jsonValueFilenameTensorName = jsonMap["filenameTensorName"] as? String {
                    resultDecodedBuilder.filenameTensorName = jsonValueFilenameTensorName
                }
                if let jsonValueSaveTensorName = jsonMap["saveTensorName"] as? String {
                    resultDecodedBuilder.saveTensorName = jsonValueSaveTensorName
                }
                if let jsonValueRestoreOpName = jsonMap["restoreOpName"] as? String {
                    resultDecodedBuilder.restoreOpName = jsonValueRestoreOpName
                }
                if let jsonValueMaxToKeep = jsonMap["maxToKeep"] as? Int {
                    resultDecodedBuilder.maxToKeep = Int32(jsonValueMaxToKeep)
                } else if let jsonValueMaxToKeep = jsonMap["maxToKeep"] as? String {
                    resultDecodedBuilder.maxToKeep = Int32(jsonValueMaxToKeep)!
                }
                if let jsonValueSharded = jsonMap["sharded"] as? Bool {
                    resultDecodedBuilder.sharded = jsonValueSharded
                }
                if let jsonValueKeepCheckpointEveryNHours = jsonMap["keepCheckpointEveryNHours"] as? Float {
                    resultDecodedBuilder.keepCheckpointEveryNHours = Float(jsonValueKeepCheckpointEveryNHours)
                } else if let jsonValueKeepCheckpointEveryNHours = jsonMap["keepCheckpointEveryNHours"] as? String {
                    resultDecodedBuilder.keepCheckpointEveryNHours = Float(jsonValueKeepCheckpointEveryNHours)!
                }
                if let jsonValueVersion = jsonMap["version"] as? String {
                    resultDecodedBuilder.version = try Tensorflow.SaverDef.CheckpointFormatVersion.fromString(str: jsonValueVersion)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.SaverDef.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.SaverDef.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.SaverDef: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.SaverDef> {
        var mergedArray = Array<Tensorflow.SaverDef>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.SaverDef? {
        return try Tensorflow.SaverDef.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.SaverDef {
        return try Tensorflow.SaverDef.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.SaverRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.SaverDef {
        return try Tensorflow.SaverDef.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.SaverDef {
        return try Tensorflow.SaverDef.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.SaverDef {
        return try Tensorflow.SaverDef.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.SaverDef {
        return try Tensorflow.SaverDef.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.SaverDef {
        return try Tensorflow.SaverDef.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "filenameTensorName": return self.filenameTensorName
        case "saveTensorName": return self.saveTensorName
        case "restoreOpName": return self.restoreOpName
        case "maxToKeep": return self.maxToKeep
        case "sharded": return self.sharded
        case "keepCheckpointEveryNHours": return self.keepCheckpointEveryNHours
        case "version": return self.version
        default: return nil
        }
    }
}
extension Tensorflow.SaverDef.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "filenameTensorName": return self.filenameTensorName
            case "saveTensorName": return self.saveTensorName
            case "restoreOpName": return self.restoreOpName
            case "maxToKeep": return self.maxToKeep
            case "sharded": return self.sharded
            case "keepCheckpointEveryNHours": return self.keepCheckpointEveryNHours
            case "version": return self.version
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "filenameTensorName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.filenameTensorName = newSubscriptValue
            case "saveTensorName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.saveTensorName = newSubscriptValue
            case "restoreOpName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.restoreOpName = newSubscriptValue
            case "maxToKeep":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.maxToKeep = newSubscriptValue
            case "sharded":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.sharded = newSubscriptValue
            case "keepCheckpointEveryNHours":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.keepCheckpointEveryNHours = newSubscriptValue
            case "version":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.SaverDef.CheckpointFormatVersion else {
                    return
                }
                self.version = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

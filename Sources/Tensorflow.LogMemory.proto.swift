/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "log_memory.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { }

public extension Tensorflow {
    public struct LogMemoryRoot {
        public static let `default` = LogMemoryRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Tensorflow.TensorDescriptionRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    final public class MemoryLogStep : GeneratedMessage {

        public static func == (lhs: Tensorflow.MemoryLogStep, rhs: Tensorflow.MemoryLogStep) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasStepId == rhs.hasStepId) && (!lhs.hasStepId || lhs.stepId == rhs.stepId)
            fieldCheck = fieldCheck && (lhs.hasHandle == rhs.hasHandle) && (!lhs.hasHandle || lhs.handle == rhs.handle)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Process-unique step id.
        public fileprivate(set) var stepId:Int64 = Int64(0)
        public fileprivate(set) var hasStepId:Bool = false

        /// Handle describing the feeds and fetches of the step.
        public fileprivate(set) var handle:String = ""
        public fileprivate(set) var hasHandle:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasStepId {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:stepId)
            }
            if hasHandle {
                try codedOutputStream.writeString(fieldNumber: 2, value:handle)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasStepId {
                serialize_size += stepId.computeInt64Size(fieldNumber: 1)
            }
            if hasHandle {
                serialize_size += handle.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.MemoryLogStep.Builder {
            return Tensorflow.MemoryLogStep.classBuilder() as! Tensorflow.MemoryLogStep.Builder
        }
        public func getBuilder() -> Tensorflow.MemoryLogStep.Builder {
            return classBuilder() as! Tensorflow.MemoryLogStep.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.MemoryLogStep.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.MemoryLogStep.Builder()
        }
        public func toBuilder() throws -> Tensorflow.MemoryLogStep.Builder {
            return try Tensorflow.MemoryLogStep.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.MemoryLogStep) throws -> Tensorflow.MemoryLogStep.Builder {
            return try Tensorflow.MemoryLogStep.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasStepId {
                jsonMap["stepId"] = "\(stepId)"
            }
            if hasHandle {
                jsonMap["handle"] = handle
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.MemoryLogStep {
            return try Tensorflow.MemoryLogStep.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.MemoryLogStep {
            return try Tensorflow.MemoryLogStep.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasStepId {
                output += "\(indent) stepId: \(stepId) \n"
            }
            if hasHandle {
                output += "\(indent) handle: \(handle) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasStepId {
                    hashCode = (hashCode &* 31) &+ stepId.hashValue
                }
                if hasHandle {
                    hashCode = (hashCode &* 31) &+ handle.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.MemoryLogStep"
        }
        override public func className() -> String {
            return "Tensorflow.MemoryLogStep"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.MemoryLogStep = Tensorflow.MemoryLogStep()
            public func getMessage() -> Tensorflow.MemoryLogStep {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Process-unique step id.
            public var stepId:Int64 {
                get {
                    return builderResult.stepId
                }
                set (value) {
                    builderResult.hasStepId = true
                    builderResult.stepId = value
                }
            }
            public var hasStepId:Bool {
                get {
                    return builderResult.hasStepId
                }
            }
            @discardableResult
            public func setStepId(_ value:Int64) -> Tensorflow.MemoryLogStep.Builder {
                self.stepId = value
                return self
            }
            @discardableResult
            public func clearStepId() -> Tensorflow.MemoryLogStep.Builder{
                builderResult.hasStepId = false
                builderResult.stepId = Int64(0)
                return self
            }
            /// Handle describing the feeds and fetches of the step.
            public var handle:String {
                get {
                    return builderResult.handle
                }
                set (value) {
                    builderResult.hasHandle = true
                    builderResult.handle = value
                }
            }
            public var hasHandle:Bool {
                get {
                    return builderResult.hasHandle
                }
            }
            @discardableResult
            public func setHandle(_ value:String) -> Tensorflow.MemoryLogStep.Builder {
                self.handle = value
                return self
            }
            @discardableResult
            public func clearHandle() -> Tensorflow.MemoryLogStep.Builder{
                builderResult.hasHandle = false
                builderResult.handle = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.MemoryLogStep.Builder {
                builderResult = Tensorflow.MemoryLogStep()
                return self
            }
            override public func clone() throws -> Tensorflow.MemoryLogStep.Builder {
                return try Tensorflow.MemoryLogStep.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.MemoryLogStep {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.MemoryLogStep {
                let returnMe:Tensorflow.MemoryLogStep = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.MemoryLogStep) throws -> Tensorflow.MemoryLogStep.Builder {
                if other == Tensorflow.MemoryLogStep() {
                    return self
                }
                if other.hasStepId {
                    stepId = other.stepId
                }
                if other.hasHandle {
                    handle = other.handle
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.MemoryLogStep.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryLogStep.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        stepId = try codedInputStream.readInt64()

                    case 18:
                        handle = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.MemoryLogStep.Builder {
                let resultDecodedBuilder = Tensorflow.MemoryLogStep.Builder()
                if let jsonValueStepId = jsonMap["stepId"] as? String {
                    resultDecodedBuilder.stepId = Int64(jsonValueStepId)!
                } else if let jsonValueStepId = jsonMap["stepId"] as? Int {
                    resultDecodedBuilder.stepId = Int64(jsonValueStepId)
                }
                if let jsonValueHandle = jsonMap["handle"] as? String {
                    resultDecodedBuilder.handle = jsonValueHandle
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.MemoryLogStep.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.MemoryLogStep.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class MemoryLogTensorAllocation : GeneratedMessage {

        public static func == (lhs: Tensorflow.MemoryLogTensorAllocation, rhs: Tensorflow.MemoryLogTensorAllocation) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasStepId == rhs.hasStepId) && (!lhs.hasStepId || lhs.stepId == rhs.stepId)
            fieldCheck = fieldCheck && (lhs.hasKernelName == rhs.hasKernelName) && (!lhs.hasKernelName || lhs.kernelName == rhs.kernelName)
            fieldCheck = fieldCheck && (lhs.hasTensor == rhs.hasTensor) && (!lhs.hasTensor || lhs.tensor == rhs.tensor)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Process-unique step id.
        public fileprivate(set) var stepId:Int64 = Int64(0)
        public fileprivate(set) var hasStepId:Bool = false

        /// Name of the kernel making the allocation as set in GraphDef,
        /// e.g., "affine2/weights/Assign".
        public fileprivate(set) var kernelName:String = ""
        public fileprivate(set) var hasKernelName:Bool = false

        public fileprivate(set) var tensor:Tensorflow.TensorDescription!
        public fileprivate(set) var hasTensor:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasStepId {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:stepId)
            }
            if hasKernelName {
                try codedOutputStream.writeString(fieldNumber: 2, value:kernelName)
            }
            if hasTensor {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:tensor)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasStepId {
                serialize_size += stepId.computeInt64Size(fieldNumber: 1)
            }
            if hasKernelName {
                serialize_size += kernelName.computeStringSize(fieldNumber: 2)
            }
            if hasTensor {
                if let varSizetensor = tensor?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizetensor
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.MemoryLogTensorAllocation.Builder {
            return Tensorflow.MemoryLogTensorAllocation.classBuilder() as! Tensorflow.MemoryLogTensorAllocation.Builder
        }
        public func getBuilder() -> Tensorflow.MemoryLogTensorAllocation.Builder {
            return classBuilder() as! Tensorflow.MemoryLogTensorAllocation.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.MemoryLogTensorAllocation.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.MemoryLogTensorAllocation.Builder()
        }
        public func toBuilder() throws -> Tensorflow.MemoryLogTensorAllocation.Builder {
            return try Tensorflow.MemoryLogTensorAllocation.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.MemoryLogTensorAllocation) throws -> Tensorflow.MemoryLogTensorAllocation.Builder {
            return try Tensorflow.MemoryLogTensorAllocation.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasStepId {
                jsonMap["stepId"] = "\(stepId)"
            }
            if hasKernelName {
                jsonMap["kernelName"] = kernelName
            }
            if hasTensor {
                jsonMap["tensor"] = try tensor.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.MemoryLogTensorAllocation {
            return try Tensorflow.MemoryLogTensorAllocation.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.MemoryLogTensorAllocation {
            return try Tensorflow.MemoryLogTensorAllocation.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasStepId {
                output += "\(indent) stepId: \(stepId) \n"
            }
            if hasKernelName {
                output += "\(indent) kernelName: \(kernelName) \n"
            }
            if hasTensor {
                output += "\(indent) tensor {\n"
                if let outDescTensor = tensor {
                    output += try outDescTensor.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasStepId {
                    hashCode = (hashCode &* 31) &+ stepId.hashValue
                }
                if hasKernelName {
                    hashCode = (hashCode &* 31) &+ kernelName.hashValue
                }
                if hasTensor {
                    if let hashValuetensor = tensor?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuetensor
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.MemoryLogTensorAllocation"
        }
        override public func className() -> String {
            return "Tensorflow.MemoryLogTensorAllocation"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.MemoryLogTensorAllocation = Tensorflow.MemoryLogTensorAllocation()
            public func getMessage() -> Tensorflow.MemoryLogTensorAllocation {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Process-unique step id.
            public var stepId:Int64 {
                get {
                    return builderResult.stepId
                }
                set (value) {
                    builderResult.hasStepId = true
                    builderResult.stepId = value
                }
            }
            public var hasStepId:Bool {
                get {
                    return builderResult.hasStepId
                }
            }
            @discardableResult
            public func setStepId(_ value:Int64) -> Tensorflow.MemoryLogTensorAllocation.Builder {
                self.stepId = value
                return self
            }
            @discardableResult
            public func clearStepId() -> Tensorflow.MemoryLogTensorAllocation.Builder{
                builderResult.hasStepId = false
                builderResult.stepId = Int64(0)
                return self
            }
            /// Name of the kernel making the allocation as set in GraphDef,
            /// e.g., "affine2/weights/Assign".
            public var kernelName:String {
                get {
                    return builderResult.kernelName
                }
                set (value) {
                    builderResult.hasKernelName = true
                    builderResult.kernelName = value
                }
            }
            public var hasKernelName:Bool {
                get {
                    return builderResult.hasKernelName
                }
            }
            @discardableResult
            public func setKernelName(_ value:String) -> Tensorflow.MemoryLogTensorAllocation.Builder {
                self.kernelName = value
                return self
            }
            @discardableResult
            public func clearKernelName() -> Tensorflow.MemoryLogTensorAllocation.Builder{
                builderResult.hasKernelName = false
                builderResult.kernelName = ""
                return self
            }
            /// Allocated tensor details.
            public var tensor:Tensorflow.TensorDescription! {
                get {
                    if tensorBuilder_ != nil {
                        builderResult.tensor = tensorBuilder_.getMessage()
                    }
                    return builderResult.tensor
                }
                set (value) {
                    builderResult.hasTensor = true
                    builderResult.tensor = value
                }
            }
            public var hasTensor:Bool {
                get {
                    return builderResult.hasTensor
                }
            }
            fileprivate var tensorBuilder_:Tensorflow.TensorDescription.Builder! {
                didSet {
                    builderResult.hasTensor = true
                }
            }
            public func getTensorBuilder() -> Tensorflow.TensorDescription.Builder {
                if tensorBuilder_ == nil {
                    tensorBuilder_ = Tensorflow.TensorDescription.Builder()
                    builderResult.tensor = tensorBuilder_.getMessage()
                    if tensor != nil {
                        try! tensorBuilder_.mergeFrom(other: tensor)
                    }
                }
                return tensorBuilder_
            }
            @discardableResult
            public func setTensor(_ value:Tensorflow.TensorDescription!) -> Tensorflow.MemoryLogTensorAllocation.Builder {
                self.tensor = value
                return self
            }
            @discardableResult
            public func mergeTensor(value:Tensorflow.TensorDescription) throws -> Tensorflow.MemoryLogTensorAllocation.Builder {
                if builderResult.hasTensor {
                    builderResult.tensor = try Tensorflow.TensorDescription.builderWithPrototype(prototype:builderResult.tensor).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.tensor = value
                }
                builderResult.hasTensor = true
                return self
            }
            @discardableResult
            public func clearTensor() -> Tensorflow.MemoryLogTensorAllocation.Builder {
                tensorBuilder_ = nil
                builderResult.hasTensor = false
                builderResult.tensor = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.MemoryLogTensorAllocation.Builder {
                builderResult = Tensorflow.MemoryLogTensorAllocation()
                return self
            }
            override public func clone() throws -> Tensorflow.MemoryLogTensorAllocation.Builder {
                return try Tensorflow.MemoryLogTensorAllocation.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.MemoryLogTensorAllocation {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.MemoryLogTensorAllocation {
                let returnMe:Tensorflow.MemoryLogTensorAllocation = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.MemoryLogTensorAllocation) throws -> Tensorflow.MemoryLogTensorAllocation.Builder {
                if other == Tensorflow.MemoryLogTensorAllocation() {
                    return self
                }
                if other.hasStepId {
                    stepId = other.stepId
                }
                if other.hasKernelName {
                    kernelName = other.kernelName
                }
                if (other.hasTensor) {
                    try mergeTensor(value: other.tensor)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.MemoryLogTensorAllocation.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryLogTensorAllocation.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        stepId = try codedInputStream.readInt64()

                    case 18:
                        kernelName = try codedInputStream.readString()

                    case 26:
                        let subBuilder:Tensorflow.TensorDescription.Builder = Tensorflow.TensorDescription.Builder()
                        if hasTensor {
                            try subBuilder.mergeFrom(other: tensor)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        tensor = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.MemoryLogTensorAllocation.Builder {
                let resultDecodedBuilder = Tensorflow.MemoryLogTensorAllocation.Builder()
                if let jsonValueStepId = jsonMap["stepId"] as? String {
                    resultDecodedBuilder.stepId = Int64(jsonValueStepId)!
                } else if let jsonValueStepId = jsonMap["stepId"] as? Int {
                    resultDecodedBuilder.stepId = Int64(jsonValueStepId)
                }
                if let jsonValueKernelName = jsonMap["kernelName"] as? String {
                    resultDecodedBuilder.kernelName = jsonValueKernelName
                }
                if let jsonValueTensor = jsonMap["tensor"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.tensor = try Tensorflow.TensorDescription.Builder.decodeToBuilder(jsonMap:jsonValueTensor).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.MemoryLogTensorAllocation.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.MemoryLogTensorAllocation.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class MemoryLogTensorDeallocation : GeneratedMessage {

        public static func == (lhs: Tensorflow.MemoryLogTensorDeallocation, rhs: Tensorflow.MemoryLogTensorDeallocation) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasAllocationId == rhs.hasAllocationId) && (!lhs.hasAllocationId || lhs.allocationId == rhs.allocationId)
            fieldCheck = fieldCheck && (lhs.hasAllocatorName == rhs.hasAllocatorName) && (!lhs.hasAllocatorName || lhs.allocatorName == rhs.allocatorName)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Id of the tensor buffer being deallocated, used to match to a
        /// corresponding allocation.
        public fileprivate(set) var allocationId:Int64 = Int64(0)
        public fileprivate(set) var hasAllocationId:Bool = false

        /// Name of the allocator used.
        public fileprivate(set) var allocatorName:String = ""
        public fileprivate(set) var hasAllocatorName:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasAllocationId {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:allocationId)
            }
            if hasAllocatorName {
                try codedOutputStream.writeString(fieldNumber: 2, value:allocatorName)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasAllocationId {
                serialize_size += allocationId.computeInt64Size(fieldNumber: 1)
            }
            if hasAllocatorName {
                serialize_size += allocatorName.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.MemoryLogTensorDeallocation.Builder {
            return Tensorflow.MemoryLogTensorDeallocation.classBuilder() as! Tensorflow.MemoryLogTensorDeallocation.Builder
        }
        public func getBuilder() -> Tensorflow.MemoryLogTensorDeallocation.Builder {
            return classBuilder() as! Tensorflow.MemoryLogTensorDeallocation.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.MemoryLogTensorDeallocation.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.MemoryLogTensorDeallocation.Builder()
        }
        public func toBuilder() throws -> Tensorflow.MemoryLogTensorDeallocation.Builder {
            return try Tensorflow.MemoryLogTensorDeallocation.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.MemoryLogTensorDeallocation) throws -> Tensorflow.MemoryLogTensorDeallocation.Builder {
            return try Tensorflow.MemoryLogTensorDeallocation.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasAllocationId {
                jsonMap["allocationId"] = "\(allocationId)"
            }
            if hasAllocatorName {
                jsonMap["allocatorName"] = allocatorName
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.MemoryLogTensorDeallocation {
            return try Tensorflow.MemoryLogTensorDeallocation.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.MemoryLogTensorDeallocation {
            return try Tensorflow.MemoryLogTensorDeallocation.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasAllocationId {
                output += "\(indent) allocationId: \(allocationId) \n"
            }
            if hasAllocatorName {
                output += "\(indent) allocatorName: \(allocatorName) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasAllocationId {
                    hashCode = (hashCode &* 31) &+ allocationId.hashValue
                }
                if hasAllocatorName {
                    hashCode = (hashCode &* 31) &+ allocatorName.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.MemoryLogTensorDeallocation"
        }
        override public func className() -> String {
            return "Tensorflow.MemoryLogTensorDeallocation"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.MemoryLogTensorDeallocation = Tensorflow.MemoryLogTensorDeallocation()
            public func getMessage() -> Tensorflow.MemoryLogTensorDeallocation {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Id of the tensor buffer being deallocated, used to match to a
            /// corresponding allocation.
            public var allocationId:Int64 {
                get {
                    return builderResult.allocationId
                }
                set (value) {
                    builderResult.hasAllocationId = true
                    builderResult.allocationId = value
                }
            }
            public var hasAllocationId:Bool {
                get {
                    return builderResult.hasAllocationId
                }
            }
            @discardableResult
            public func setAllocationId(_ value:Int64) -> Tensorflow.MemoryLogTensorDeallocation.Builder {
                self.allocationId = value
                return self
            }
            @discardableResult
            public func clearAllocationId() -> Tensorflow.MemoryLogTensorDeallocation.Builder{
                builderResult.hasAllocationId = false
                builderResult.allocationId = Int64(0)
                return self
            }
            /// Name of the allocator used.
            public var allocatorName:String {
                get {
                    return builderResult.allocatorName
                }
                set (value) {
                    builderResult.hasAllocatorName = true
                    builderResult.allocatorName = value
                }
            }
            public var hasAllocatorName:Bool {
                get {
                    return builderResult.hasAllocatorName
                }
            }
            @discardableResult
            public func setAllocatorName(_ value:String) -> Tensorflow.MemoryLogTensorDeallocation.Builder {
                self.allocatorName = value
                return self
            }
            @discardableResult
            public func clearAllocatorName() -> Tensorflow.MemoryLogTensorDeallocation.Builder{
                builderResult.hasAllocatorName = false
                builderResult.allocatorName = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.MemoryLogTensorDeallocation.Builder {
                builderResult = Tensorflow.MemoryLogTensorDeallocation()
                return self
            }
            override public func clone() throws -> Tensorflow.MemoryLogTensorDeallocation.Builder {
                return try Tensorflow.MemoryLogTensorDeallocation.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.MemoryLogTensorDeallocation {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.MemoryLogTensorDeallocation {
                let returnMe:Tensorflow.MemoryLogTensorDeallocation = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.MemoryLogTensorDeallocation) throws -> Tensorflow.MemoryLogTensorDeallocation.Builder {
                if other == Tensorflow.MemoryLogTensorDeallocation() {
                    return self
                }
                if other.hasAllocationId {
                    allocationId = other.allocationId
                }
                if other.hasAllocatorName {
                    allocatorName = other.allocatorName
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.MemoryLogTensorDeallocation.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryLogTensorDeallocation.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        allocationId = try codedInputStream.readInt64()

                    case 18:
                        allocatorName = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.MemoryLogTensorDeallocation.Builder {
                let resultDecodedBuilder = Tensorflow.MemoryLogTensorDeallocation.Builder()
                if let jsonValueAllocationId = jsonMap["allocationId"] as? String {
                    resultDecodedBuilder.allocationId = Int64(jsonValueAllocationId)!
                } else if let jsonValueAllocationId = jsonMap["allocationId"] as? Int {
                    resultDecodedBuilder.allocationId = Int64(jsonValueAllocationId)
                }
                if let jsonValueAllocatorName = jsonMap["allocatorName"] as? String {
                    resultDecodedBuilder.allocatorName = jsonValueAllocatorName
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.MemoryLogTensorDeallocation.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.MemoryLogTensorDeallocation.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class MemoryLogTensorOutput : GeneratedMessage {

        public static func == (lhs: Tensorflow.MemoryLogTensorOutput, rhs: Tensorflow.MemoryLogTensorOutput) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasStepId == rhs.hasStepId) && (!lhs.hasStepId || lhs.stepId == rhs.stepId)
            fieldCheck = fieldCheck && (lhs.hasKernelName == rhs.hasKernelName) && (!lhs.hasKernelName || lhs.kernelName == rhs.kernelName)
            fieldCheck = fieldCheck && (lhs.hasIndex == rhs.hasIndex) && (!lhs.hasIndex || lhs.index == rhs.index)
            fieldCheck = fieldCheck && (lhs.hasTensor == rhs.hasTensor) && (!lhs.hasTensor || lhs.tensor == rhs.tensor)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Process-unique step id.
        public fileprivate(set) var stepId:Int64 = Int64(0)
        public fileprivate(set) var hasStepId:Bool = false

        /// Name of the kernel producing an output as set in GraphDef, e.g.,
        /// "affine2/weights/Assign".
        public fileprivate(set) var kernelName:String = ""
        public fileprivate(set) var hasKernelName:Bool = false

        /// Index of the output being set.
        public fileprivate(set) var index:Int32 = Int32(0)
        public fileprivate(set) var hasIndex:Bool = false

        public fileprivate(set) var tensor:Tensorflow.TensorDescription!
        public fileprivate(set) var hasTensor:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasStepId {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:stepId)
            }
            if hasKernelName {
                try codedOutputStream.writeString(fieldNumber: 2, value:kernelName)
            }
            if hasIndex {
                try codedOutputStream.writeInt32(fieldNumber: 3, value:index)
            }
            if hasTensor {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:tensor)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasStepId {
                serialize_size += stepId.computeInt64Size(fieldNumber: 1)
            }
            if hasKernelName {
                serialize_size += kernelName.computeStringSize(fieldNumber: 2)
            }
            if hasIndex {
                serialize_size += index.computeInt32Size(fieldNumber: 3)
            }
            if hasTensor {
                if let varSizetensor = tensor?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizetensor
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.MemoryLogTensorOutput.Builder {
            return Tensorflow.MemoryLogTensorOutput.classBuilder() as! Tensorflow.MemoryLogTensorOutput.Builder
        }
        public func getBuilder() -> Tensorflow.MemoryLogTensorOutput.Builder {
            return classBuilder() as! Tensorflow.MemoryLogTensorOutput.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.MemoryLogTensorOutput.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.MemoryLogTensorOutput.Builder()
        }
        public func toBuilder() throws -> Tensorflow.MemoryLogTensorOutput.Builder {
            return try Tensorflow.MemoryLogTensorOutput.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.MemoryLogTensorOutput) throws -> Tensorflow.MemoryLogTensorOutput.Builder {
            return try Tensorflow.MemoryLogTensorOutput.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasStepId {
                jsonMap["stepId"] = "\(stepId)"
            }
            if hasKernelName {
                jsonMap["kernelName"] = kernelName
            }
            if hasIndex {
                jsonMap["index"] = Int(index)
            }
            if hasTensor {
                jsonMap["tensor"] = try tensor.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.MemoryLogTensorOutput {
            return try Tensorflow.MemoryLogTensorOutput.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.MemoryLogTensorOutput {
            return try Tensorflow.MemoryLogTensorOutput.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasStepId {
                output += "\(indent) stepId: \(stepId) \n"
            }
            if hasKernelName {
                output += "\(indent) kernelName: \(kernelName) \n"
            }
            if hasIndex {
                output += "\(indent) index: \(index) \n"
            }
            if hasTensor {
                output += "\(indent) tensor {\n"
                if let outDescTensor = tensor {
                    output += try outDescTensor.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasStepId {
                    hashCode = (hashCode &* 31) &+ stepId.hashValue
                }
                if hasKernelName {
                    hashCode = (hashCode &* 31) &+ kernelName.hashValue
                }
                if hasIndex {
                    hashCode = (hashCode &* 31) &+ index.hashValue
                }
                if hasTensor {
                    if let hashValuetensor = tensor?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuetensor
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.MemoryLogTensorOutput"
        }
        override public func className() -> String {
            return "Tensorflow.MemoryLogTensorOutput"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.MemoryLogTensorOutput = Tensorflow.MemoryLogTensorOutput()
            public func getMessage() -> Tensorflow.MemoryLogTensorOutput {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Process-unique step id.
            public var stepId:Int64 {
                get {
                    return builderResult.stepId
                }
                set (value) {
                    builderResult.hasStepId = true
                    builderResult.stepId = value
                }
            }
            public var hasStepId:Bool {
                get {
                    return builderResult.hasStepId
                }
            }
            @discardableResult
            public func setStepId(_ value:Int64) -> Tensorflow.MemoryLogTensorOutput.Builder {
                self.stepId = value
                return self
            }
            @discardableResult
            public func clearStepId() -> Tensorflow.MemoryLogTensorOutput.Builder{
                builderResult.hasStepId = false
                builderResult.stepId = Int64(0)
                return self
            }
            /// Name of the kernel producing an output as set in GraphDef, e.g.,
            /// "affine2/weights/Assign".
            public var kernelName:String {
                get {
                    return builderResult.kernelName
                }
                set (value) {
                    builderResult.hasKernelName = true
                    builderResult.kernelName = value
                }
            }
            public var hasKernelName:Bool {
                get {
                    return builderResult.hasKernelName
                }
            }
            @discardableResult
            public func setKernelName(_ value:String) -> Tensorflow.MemoryLogTensorOutput.Builder {
                self.kernelName = value
                return self
            }
            @discardableResult
            public func clearKernelName() -> Tensorflow.MemoryLogTensorOutput.Builder{
                builderResult.hasKernelName = false
                builderResult.kernelName = ""
                return self
            }
            /// Index of the output being set.
            public var index:Int32 {
                get {
                    return builderResult.index
                }
                set (value) {
                    builderResult.hasIndex = true
                    builderResult.index = value
                }
            }
            public var hasIndex:Bool {
                get {
                    return builderResult.hasIndex
                }
            }
            @discardableResult
            public func setIndex(_ value:Int32) -> Tensorflow.MemoryLogTensorOutput.Builder {
                self.index = value
                return self
            }
            @discardableResult
            public func clearIndex() -> Tensorflow.MemoryLogTensorOutput.Builder{
                builderResult.hasIndex = false
                builderResult.index = Int32(0)
                return self
            }
            /// Output tensor details.
            public var tensor:Tensorflow.TensorDescription! {
                get {
                    if tensorBuilder_ != nil {
                        builderResult.tensor = tensorBuilder_.getMessage()
                    }
                    return builderResult.tensor
                }
                set (value) {
                    builderResult.hasTensor = true
                    builderResult.tensor = value
                }
            }
            public var hasTensor:Bool {
                get {
                    return builderResult.hasTensor
                }
            }
            fileprivate var tensorBuilder_:Tensorflow.TensorDescription.Builder! {
                didSet {
                    builderResult.hasTensor = true
                }
            }
            public func getTensorBuilder() -> Tensorflow.TensorDescription.Builder {
                if tensorBuilder_ == nil {
                    tensorBuilder_ = Tensorflow.TensorDescription.Builder()
                    builderResult.tensor = tensorBuilder_.getMessage()
                    if tensor != nil {
                        try! tensorBuilder_.mergeFrom(other: tensor)
                    }
                }
                return tensorBuilder_
            }
            @discardableResult
            public func setTensor(_ value:Tensorflow.TensorDescription!) -> Tensorflow.MemoryLogTensorOutput.Builder {
                self.tensor = value
                return self
            }
            @discardableResult
            public func mergeTensor(value:Tensorflow.TensorDescription) throws -> Tensorflow.MemoryLogTensorOutput.Builder {
                if builderResult.hasTensor {
                    builderResult.tensor = try Tensorflow.TensorDescription.builderWithPrototype(prototype:builderResult.tensor).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.tensor = value
                }
                builderResult.hasTensor = true
                return self
            }
            @discardableResult
            public func clearTensor() -> Tensorflow.MemoryLogTensorOutput.Builder {
                tensorBuilder_ = nil
                builderResult.hasTensor = false
                builderResult.tensor = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.MemoryLogTensorOutput.Builder {
                builderResult = Tensorflow.MemoryLogTensorOutput()
                return self
            }
            override public func clone() throws -> Tensorflow.MemoryLogTensorOutput.Builder {
                return try Tensorflow.MemoryLogTensorOutput.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.MemoryLogTensorOutput {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.MemoryLogTensorOutput {
                let returnMe:Tensorflow.MemoryLogTensorOutput = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.MemoryLogTensorOutput) throws -> Tensorflow.MemoryLogTensorOutput.Builder {
                if other == Tensorflow.MemoryLogTensorOutput() {
                    return self
                }
                if other.hasStepId {
                    stepId = other.stepId
                }
                if other.hasKernelName {
                    kernelName = other.kernelName
                }
                if other.hasIndex {
                    index = other.index
                }
                if (other.hasTensor) {
                    try mergeTensor(value: other.tensor)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.MemoryLogTensorOutput.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryLogTensorOutput.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        stepId = try codedInputStream.readInt64()

                    case 18:
                        kernelName = try codedInputStream.readString()

                    case 24:
                        index = try codedInputStream.readInt32()

                    case 34:
                        let subBuilder:Tensorflow.TensorDescription.Builder = Tensorflow.TensorDescription.Builder()
                        if hasTensor {
                            try subBuilder.mergeFrom(other: tensor)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        tensor = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.MemoryLogTensorOutput.Builder {
                let resultDecodedBuilder = Tensorflow.MemoryLogTensorOutput.Builder()
                if let jsonValueStepId = jsonMap["stepId"] as? String {
                    resultDecodedBuilder.stepId = Int64(jsonValueStepId)!
                } else if let jsonValueStepId = jsonMap["stepId"] as? Int {
                    resultDecodedBuilder.stepId = Int64(jsonValueStepId)
                }
                if let jsonValueKernelName = jsonMap["kernelName"] as? String {
                    resultDecodedBuilder.kernelName = jsonValueKernelName
                }
                if let jsonValueIndex = jsonMap["index"] as? Int {
                    resultDecodedBuilder.index = Int32(jsonValueIndex)
                } else if let jsonValueIndex = jsonMap["index"] as? String {
                    resultDecodedBuilder.index = Int32(jsonValueIndex)!
                }
                if let jsonValueTensor = jsonMap["tensor"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.tensor = try Tensorflow.TensorDescription.Builder.decodeToBuilder(jsonMap:jsonValueTensor).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.MemoryLogTensorOutput.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.MemoryLogTensorOutput.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class MemoryLogRawAllocation : GeneratedMessage {

        public static func == (lhs: Tensorflow.MemoryLogRawAllocation, rhs: Tensorflow.MemoryLogRawAllocation) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasStepId == rhs.hasStepId) && (!lhs.hasStepId || lhs.stepId == rhs.stepId)
            fieldCheck = fieldCheck && (lhs.hasOperation == rhs.hasOperation) && (!lhs.hasOperation || lhs.operation == rhs.operation)
            fieldCheck = fieldCheck && (lhs.hasNumBytes == rhs.hasNumBytes) && (!lhs.hasNumBytes || lhs.numBytes == rhs.numBytes)
            fieldCheck = fieldCheck && (lhs.hasPtr == rhs.hasPtr) && (!lhs.hasPtr || lhs.ptr == rhs.ptr)
            fieldCheck = fieldCheck && (lhs.hasAllocationId == rhs.hasAllocationId) && (!lhs.hasAllocationId || lhs.allocationId == rhs.allocationId)
            fieldCheck = fieldCheck && (lhs.hasAllocatorName == rhs.hasAllocatorName) && (!lhs.hasAllocatorName || lhs.allocatorName == rhs.allocatorName)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Process-unique step id.
        public fileprivate(set) var stepId:Int64 = Int64(0)
        public fileprivate(set) var hasStepId:Bool = false

        /// Name of the operation making the allocation.
        public fileprivate(set) var operation:String = ""
        public fileprivate(set) var hasOperation:Bool = false

        /// Number of bytes in the allocation.
        public fileprivate(set) var numBytes:Int64 = Int64(0)
        public fileprivate(set) var hasNumBytes:Bool = false

        /// Address of the allocation.
        public fileprivate(set) var ptr:UInt64 = UInt64(0)
        public fileprivate(set) var hasPtr:Bool = false

        /// Id of the tensor buffer being allocated, used to match to a
        /// corresponding deallocation.
        public fileprivate(set) var allocationId:Int64 = Int64(0)
        public fileprivate(set) var hasAllocationId:Bool = false

        /// Name of the allocator used.
        public fileprivate(set) var allocatorName:String = ""
        public fileprivate(set) var hasAllocatorName:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasStepId {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:stepId)
            }
            if hasOperation {
                try codedOutputStream.writeString(fieldNumber: 2, value:operation)
            }
            if hasNumBytes {
                try codedOutputStream.writeInt64(fieldNumber: 3, value:numBytes)
            }
            if hasPtr {
                try codedOutputStream.writeUInt64(fieldNumber: 4, value:ptr)
            }
            if hasAllocationId {
                try codedOutputStream.writeInt64(fieldNumber: 5, value:allocationId)
            }
            if hasAllocatorName {
                try codedOutputStream.writeString(fieldNumber: 6, value:allocatorName)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasStepId {
                serialize_size += stepId.computeInt64Size(fieldNumber: 1)
            }
            if hasOperation {
                serialize_size += operation.computeStringSize(fieldNumber: 2)
            }
            if hasNumBytes {
                serialize_size += numBytes.computeInt64Size(fieldNumber: 3)
            }
            if hasPtr {
                serialize_size += ptr.computeUInt64Size(fieldNumber: 4)
            }
            if hasAllocationId {
                serialize_size += allocationId.computeInt64Size(fieldNumber: 5)
            }
            if hasAllocatorName {
                serialize_size += allocatorName.computeStringSize(fieldNumber: 6)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.MemoryLogRawAllocation.Builder {
            return Tensorflow.MemoryLogRawAllocation.classBuilder() as! Tensorflow.MemoryLogRawAllocation.Builder
        }
        public func getBuilder() -> Tensorflow.MemoryLogRawAllocation.Builder {
            return classBuilder() as! Tensorflow.MemoryLogRawAllocation.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.MemoryLogRawAllocation.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.MemoryLogRawAllocation.Builder()
        }
        public func toBuilder() throws -> Tensorflow.MemoryLogRawAllocation.Builder {
            return try Tensorflow.MemoryLogRawAllocation.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.MemoryLogRawAllocation) throws -> Tensorflow.MemoryLogRawAllocation.Builder {
            return try Tensorflow.MemoryLogRawAllocation.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasStepId {
                jsonMap["stepId"] = "\(stepId)"
            }
            if hasOperation {
                jsonMap["operation"] = operation
            }
            if hasNumBytes {
                jsonMap["numBytes"] = "\(numBytes)"
            }
            if hasPtr {
                jsonMap["ptr"] = "\(ptr)"
            }
            if hasAllocationId {
                jsonMap["allocationId"] = "\(allocationId)"
            }
            if hasAllocatorName {
                jsonMap["allocatorName"] = allocatorName
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.MemoryLogRawAllocation {
            return try Tensorflow.MemoryLogRawAllocation.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.MemoryLogRawAllocation {
            return try Tensorflow.MemoryLogRawAllocation.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasStepId {
                output += "\(indent) stepId: \(stepId) \n"
            }
            if hasOperation {
                output += "\(indent) operation: \(operation) \n"
            }
            if hasNumBytes {
                output += "\(indent) numBytes: \(numBytes) \n"
            }
            if hasPtr {
                output += "\(indent) ptr: \(ptr) \n"
            }
            if hasAllocationId {
                output += "\(indent) allocationId: \(allocationId) \n"
            }
            if hasAllocatorName {
                output += "\(indent) allocatorName: \(allocatorName) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasStepId {
                    hashCode = (hashCode &* 31) &+ stepId.hashValue
                }
                if hasOperation {
                    hashCode = (hashCode &* 31) &+ operation.hashValue
                }
                if hasNumBytes {
                    hashCode = (hashCode &* 31) &+ numBytes.hashValue
                }
                if hasPtr {
                    hashCode = (hashCode &* 31) &+ ptr.hashValue
                }
                if hasAllocationId {
                    hashCode = (hashCode &* 31) &+ allocationId.hashValue
                }
                if hasAllocatorName {
                    hashCode = (hashCode &* 31) &+ allocatorName.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.MemoryLogRawAllocation"
        }
        override public func className() -> String {
            return "Tensorflow.MemoryLogRawAllocation"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.MemoryLogRawAllocation = Tensorflow.MemoryLogRawAllocation()
            public func getMessage() -> Tensorflow.MemoryLogRawAllocation {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Process-unique step id.
            public var stepId:Int64 {
                get {
                    return builderResult.stepId
                }
                set (value) {
                    builderResult.hasStepId = true
                    builderResult.stepId = value
                }
            }
            public var hasStepId:Bool {
                get {
                    return builderResult.hasStepId
                }
            }
            @discardableResult
            public func setStepId(_ value:Int64) -> Tensorflow.MemoryLogRawAllocation.Builder {
                self.stepId = value
                return self
            }
            @discardableResult
            public func clearStepId() -> Tensorflow.MemoryLogRawAllocation.Builder{
                builderResult.hasStepId = false
                builderResult.stepId = Int64(0)
                return self
            }
            /// Name of the operation making the allocation.
            public var operation:String {
                get {
                    return builderResult.operation
                }
                set (value) {
                    builderResult.hasOperation = true
                    builderResult.operation = value
                }
            }
            public var hasOperation:Bool {
                get {
                    return builderResult.hasOperation
                }
            }
            @discardableResult
            public func setOperation(_ value:String) -> Tensorflow.MemoryLogRawAllocation.Builder {
                self.operation = value
                return self
            }
            @discardableResult
            public func clearOperation() -> Tensorflow.MemoryLogRawAllocation.Builder{
                builderResult.hasOperation = false
                builderResult.operation = ""
                return self
            }
            /// Number of bytes in the allocation.
            public var numBytes:Int64 {
                get {
                    return builderResult.numBytes
                }
                set (value) {
                    builderResult.hasNumBytes = true
                    builderResult.numBytes = value
                }
            }
            public var hasNumBytes:Bool {
                get {
                    return builderResult.hasNumBytes
                }
            }
            @discardableResult
            public func setNumBytes(_ value:Int64) -> Tensorflow.MemoryLogRawAllocation.Builder {
                self.numBytes = value
                return self
            }
            @discardableResult
            public func clearNumBytes() -> Tensorflow.MemoryLogRawAllocation.Builder{
                builderResult.hasNumBytes = false
                builderResult.numBytes = Int64(0)
                return self
            }
            /// Address of the allocation.
            public var ptr:UInt64 {
                get {
                    return builderResult.ptr
                }
                set (value) {
                    builderResult.hasPtr = true
                    builderResult.ptr = value
                }
            }
            public var hasPtr:Bool {
                get {
                    return builderResult.hasPtr
                }
            }
            @discardableResult
            public func setPtr(_ value:UInt64) -> Tensorflow.MemoryLogRawAllocation.Builder {
                self.ptr = value
                return self
            }
            @discardableResult
            public func clearPtr() -> Tensorflow.MemoryLogRawAllocation.Builder{
                builderResult.hasPtr = false
                builderResult.ptr = UInt64(0)
                return self
            }
            /// Id of the tensor buffer being allocated, used to match to a
            /// corresponding deallocation.
            public var allocationId:Int64 {
                get {
                    return builderResult.allocationId
                }
                set (value) {
                    builderResult.hasAllocationId = true
                    builderResult.allocationId = value
                }
            }
            public var hasAllocationId:Bool {
                get {
                    return builderResult.hasAllocationId
                }
            }
            @discardableResult
            public func setAllocationId(_ value:Int64) -> Tensorflow.MemoryLogRawAllocation.Builder {
                self.allocationId = value
                return self
            }
            @discardableResult
            public func clearAllocationId() -> Tensorflow.MemoryLogRawAllocation.Builder{
                builderResult.hasAllocationId = false
                builderResult.allocationId = Int64(0)
                return self
            }
            /// Name of the allocator used.
            public var allocatorName:String {
                get {
                    return builderResult.allocatorName
                }
                set (value) {
                    builderResult.hasAllocatorName = true
                    builderResult.allocatorName = value
                }
            }
            public var hasAllocatorName:Bool {
                get {
                    return builderResult.hasAllocatorName
                }
            }
            @discardableResult
            public func setAllocatorName(_ value:String) -> Tensorflow.MemoryLogRawAllocation.Builder {
                self.allocatorName = value
                return self
            }
            @discardableResult
            public func clearAllocatorName() -> Tensorflow.MemoryLogRawAllocation.Builder{
                builderResult.hasAllocatorName = false
                builderResult.allocatorName = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.MemoryLogRawAllocation.Builder {
                builderResult = Tensorflow.MemoryLogRawAllocation()
                return self
            }
            override public func clone() throws -> Tensorflow.MemoryLogRawAllocation.Builder {
                return try Tensorflow.MemoryLogRawAllocation.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.MemoryLogRawAllocation {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.MemoryLogRawAllocation {
                let returnMe:Tensorflow.MemoryLogRawAllocation = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.MemoryLogRawAllocation) throws -> Tensorflow.MemoryLogRawAllocation.Builder {
                if other == Tensorflow.MemoryLogRawAllocation() {
                    return self
                }
                if other.hasStepId {
                    stepId = other.stepId
                }
                if other.hasOperation {
                    operation = other.operation
                }
                if other.hasNumBytes {
                    numBytes = other.numBytes
                }
                if other.hasPtr {
                    ptr = other.ptr
                }
                if other.hasAllocationId {
                    allocationId = other.allocationId
                }
                if other.hasAllocatorName {
                    allocatorName = other.allocatorName
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.MemoryLogRawAllocation.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryLogRawAllocation.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        stepId = try codedInputStream.readInt64()

                    case 18:
                        operation = try codedInputStream.readString()

                    case 24:
                        numBytes = try codedInputStream.readInt64()

                    case 32:
                        ptr = try codedInputStream.readUInt64()

                    case 40:
                        allocationId = try codedInputStream.readInt64()

                    case 50:
                        allocatorName = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.MemoryLogRawAllocation.Builder {
                let resultDecodedBuilder = Tensorflow.MemoryLogRawAllocation.Builder()
                if let jsonValueStepId = jsonMap["stepId"] as? String {
                    resultDecodedBuilder.stepId = Int64(jsonValueStepId)!
                } else if let jsonValueStepId = jsonMap["stepId"] as? Int {
                    resultDecodedBuilder.stepId = Int64(jsonValueStepId)
                }
                if let jsonValueOperation = jsonMap["operation"] as? String {
                    resultDecodedBuilder.operation = jsonValueOperation
                }
                if let jsonValueNumBytes = jsonMap["numBytes"] as? String {
                    resultDecodedBuilder.numBytes = Int64(jsonValueNumBytes)!
                } else if let jsonValueNumBytes = jsonMap["numBytes"] as? Int {
                    resultDecodedBuilder.numBytes = Int64(jsonValueNumBytes)
                }
                if let jsonValuePtr = jsonMap["ptr"] as? String {
                    resultDecodedBuilder.ptr = UInt64(jsonValuePtr)!
                } else if let jsonValuePtr = jsonMap["ptr"] as? UInt {
                    resultDecodedBuilder.ptr = UInt64(jsonValuePtr)
                }
                if let jsonValueAllocationId = jsonMap["allocationId"] as? String {
                    resultDecodedBuilder.allocationId = Int64(jsonValueAllocationId)!
                } else if let jsonValueAllocationId = jsonMap["allocationId"] as? Int {
                    resultDecodedBuilder.allocationId = Int64(jsonValueAllocationId)
                }
                if let jsonValueAllocatorName = jsonMap["allocatorName"] as? String {
                    resultDecodedBuilder.allocatorName = jsonValueAllocatorName
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.MemoryLogRawAllocation.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.MemoryLogRawAllocation.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class MemoryLogRawDeallocation : GeneratedMessage {

        public static func == (lhs: Tensorflow.MemoryLogRawDeallocation, rhs: Tensorflow.MemoryLogRawDeallocation) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasStepId == rhs.hasStepId) && (!lhs.hasStepId || lhs.stepId == rhs.stepId)
            fieldCheck = fieldCheck && (lhs.hasOperation == rhs.hasOperation) && (!lhs.hasOperation || lhs.operation == rhs.operation)
            fieldCheck = fieldCheck && (lhs.hasAllocationId == rhs.hasAllocationId) && (!lhs.hasAllocationId || lhs.allocationId == rhs.allocationId)
            fieldCheck = fieldCheck && (lhs.hasAllocatorName == rhs.hasAllocatorName) && (!lhs.hasAllocatorName || lhs.allocatorName == rhs.allocatorName)
            fieldCheck = fieldCheck && (lhs.hasDeferred == rhs.hasDeferred) && (!lhs.hasDeferred || lhs.deferred == rhs.deferred)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Process-unique step id.
        public fileprivate(set) var stepId:Int64 = Int64(0)
        public fileprivate(set) var hasStepId:Bool = false

        /// Name of the operation making the deallocation.
        public fileprivate(set) var operation:String = ""
        public fileprivate(set) var hasOperation:Bool = false

        /// Id of the tensor buffer being deallocated, used to match to a
        /// corresponding allocation.
        public fileprivate(set) var allocationId:Int64 = Int64(0)
        public fileprivate(set) var hasAllocationId:Bool = false

        /// Name of the allocator used.
        public fileprivate(set) var allocatorName:String = ""
        public fileprivate(set) var hasAllocatorName:Bool = false

        /// True if the deallocation is queued and will be performed later,
        /// e.g. for GPU lazy freeing of buffers.
        public fileprivate(set) var deferred:Bool = false
        public fileprivate(set) var hasDeferred:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasStepId {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:stepId)
            }
            if hasOperation {
                try codedOutputStream.writeString(fieldNumber: 2, value:operation)
            }
            if hasAllocationId {
                try codedOutputStream.writeInt64(fieldNumber: 3, value:allocationId)
            }
            if hasAllocatorName {
                try codedOutputStream.writeString(fieldNumber: 4, value:allocatorName)
            }
            if hasDeferred {
                try codedOutputStream.writeBool(fieldNumber: 5, value:deferred)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasStepId {
                serialize_size += stepId.computeInt64Size(fieldNumber: 1)
            }
            if hasOperation {
                serialize_size += operation.computeStringSize(fieldNumber: 2)
            }
            if hasAllocationId {
                serialize_size += allocationId.computeInt64Size(fieldNumber: 3)
            }
            if hasAllocatorName {
                serialize_size += allocatorName.computeStringSize(fieldNumber: 4)
            }
            if hasDeferred {
                serialize_size += deferred.computeBoolSize(fieldNumber: 5)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.MemoryLogRawDeallocation.Builder {
            return Tensorflow.MemoryLogRawDeallocation.classBuilder() as! Tensorflow.MemoryLogRawDeallocation.Builder
        }
        public func getBuilder() -> Tensorflow.MemoryLogRawDeallocation.Builder {
            return classBuilder() as! Tensorflow.MemoryLogRawDeallocation.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.MemoryLogRawDeallocation.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.MemoryLogRawDeallocation.Builder()
        }
        public func toBuilder() throws -> Tensorflow.MemoryLogRawDeallocation.Builder {
            return try Tensorflow.MemoryLogRawDeallocation.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.MemoryLogRawDeallocation) throws -> Tensorflow.MemoryLogRawDeallocation.Builder {
            return try Tensorflow.MemoryLogRawDeallocation.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasStepId {
                jsonMap["stepId"] = "\(stepId)"
            }
            if hasOperation {
                jsonMap["operation"] = operation
            }
            if hasAllocationId {
                jsonMap["allocationId"] = "\(allocationId)"
            }
            if hasAllocatorName {
                jsonMap["allocatorName"] = allocatorName
            }
            if hasDeferred {
                jsonMap["deferred"] = deferred
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.MemoryLogRawDeallocation {
            return try Tensorflow.MemoryLogRawDeallocation.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.MemoryLogRawDeallocation {
            return try Tensorflow.MemoryLogRawDeallocation.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasStepId {
                output += "\(indent) stepId: \(stepId) \n"
            }
            if hasOperation {
                output += "\(indent) operation: \(operation) \n"
            }
            if hasAllocationId {
                output += "\(indent) allocationId: \(allocationId) \n"
            }
            if hasAllocatorName {
                output += "\(indent) allocatorName: \(allocatorName) \n"
            }
            if hasDeferred {
                output += "\(indent) deferred: \(deferred) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasStepId {
                    hashCode = (hashCode &* 31) &+ stepId.hashValue
                }
                if hasOperation {
                    hashCode = (hashCode &* 31) &+ operation.hashValue
                }
                if hasAllocationId {
                    hashCode = (hashCode &* 31) &+ allocationId.hashValue
                }
                if hasAllocatorName {
                    hashCode = (hashCode &* 31) &+ allocatorName.hashValue
                }
                if hasDeferred {
                    hashCode = (hashCode &* 31) &+ deferred.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.MemoryLogRawDeallocation"
        }
        override public func className() -> String {
            return "Tensorflow.MemoryLogRawDeallocation"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.MemoryLogRawDeallocation = Tensorflow.MemoryLogRawDeallocation()
            public func getMessage() -> Tensorflow.MemoryLogRawDeallocation {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Process-unique step id.
            public var stepId:Int64 {
                get {
                    return builderResult.stepId
                }
                set (value) {
                    builderResult.hasStepId = true
                    builderResult.stepId = value
                }
            }
            public var hasStepId:Bool {
                get {
                    return builderResult.hasStepId
                }
            }
            @discardableResult
            public func setStepId(_ value:Int64) -> Tensorflow.MemoryLogRawDeallocation.Builder {
                self.stepId = value
                return self
            }
            @discardableResult
            public func clearStepId() -> Tensorflow.MemoryLogRawDeallocation.Builder{
                builderResult.hasStepId = false
                builderResult.stepId = Int64(0)
                return self
            }
            /// Name of the operation making the deallocation.
            public var operation:String {
                get {
                    return builderResult.operation
                }
                set (value) {
                    builderResult.hasOperation = true
                    builderResult.operation = value
                }
            }
            public var hasOperation:Bool {
                get {
                    return builderResult.hasOperation
                }
            }
            @discardableResult
            public func setOperation(_ value:String) -> Tensorflow.MemoryLogRawDeallocation.Builder {
                self.operation = value
                return self
            }
            @discardableResult
            public func clearOperation() -> Tensorflow.MemoryLogRawDeallocation.Builder{
                builderResult.hasOperation = false
                builderResult.operation = ""
                return self
            }
            /// Id of the tensor buffer being deallocated, used to match to a
            /// corresponding allocation.
            public var allocationId:Int64 {
                get {
                    return builderResult.allocationId
                }
                set (value) {
                    builderResult.hasAllocationId = true
                    builderResult.allocationId = value
                }
            }
            public var hasAllocationId:Bool {
                get {
                    return builderResult.hasAllocationId
                }
            }
            @discardableResult
            public func setAllocationId(_ value:Int64) -> Tensorflow.MemoryLogRawDeallocation.Builder {
                self.allocationId = value
                return self
            }
            @discardableResult
            public func clearAllocationId() -> Tensorflow.MemoryLogRawDeallocation.Builder{
                builderResult.hasAllocationId = false
                builderResult.allocationId = Int64(0)
                return self
            }
            /// Name of the allocator used.
            public var allocatorName:String {
                get {
                    return builderResult.allocatorName
                }
                set (value) {
                    builderResult.hasAllocatorName = true
                    builderResult.allocatorName = value
                }
            }
            public var hasAllocatorName:Bool {
                get {
                    return builderResult.hasAllocatorName
                }
            }
            @discardableResult
            public func setAllocatorName(_ value:String) -> Tensorflow.MemoryLogRawDeallocation.Builder {
                self.allocatorName = value
                return self
            }
            @discardableResult
            public func clearAllocatorName() -> Tensorflow.MemoryLogRawDeallocation.Builder{
                builderResult.hasAllocatorName = false
                builderResult.allocatorName = ""
                return self
            }
            /// True if the deallocation is queued and will be performed later,
            /// e.g. for GPU lazy freeing of buffers.
            public var deferred:Bool {
                get {
                    return builderResult.deferred
                }
                set (value) {
                    builderResult.hasDeferred = true
                    builderResult.deferred = value
                }
            }
            public var hasDeferred:Bool {
                get {
                    return builderResult.hasDeferred
                }
            }
            @discardableResult
            public func setDeferred(_ value:Bool) -> Tensorflow.MemoryLogRawDeallocation.Builder {
                self.deferred = value
                return self
            }
            @discardableResult
            public func clearDeferred() -> Tensorflow.MemoryLogRawDeallocation.Builder{
                builderResult.hasDeferred = false
                builderResult.deferred = false
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.MemoryLogRawDeallocation.Builder {
                builderResult = Tensorflow.MemoryLogRawDeallocation()
                return self
            }
            override public func clone() throws -> Tensorflow.MemoryLogRawDeallocation.Builder {
                return try Tensorflow.MemoryLogRawDeallocation.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.MemoryLogRawDeallocation {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.MemoryLogRawDeallocation {
                let returnMe:Tensorflow.MemoryLogRawDeallocation = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.MemoryLogRawDeallocation) throws -> Tensorflow.MemoryLogRawDeallocation.Builder {
                if other == Tensorflow.MemoryLogRawDeallocation() {
                    return self
                }
                if other.hasStepId {
                    stepId = other.stepId
                }
                if other.hasOperation {
                    operation = other.operation
                }
                if other.hasAllocationId {
                    allocationId = other.allocationId
                }
                if other.hasAllocatorName {
                    allocatorName = other.allocatorName
                }
                if other.hasDeferred {
                    deferred = other.deferred
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.MemoryLogRawDeallocation.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryLogRawDeallocation.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        stepId = try codedInputStream.readInt64()

                    case 18:
                        operation = try codedInputStream.readString()

                    case 24:
                        allocationId = try codedInputStream.readInt64()

                    case 34:
                        allocatorName = try codedInputStream.readString()

                    case 40:
                        deferred = try codedInputStream.readBool()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.MemoryLogRawDeallocation.Builder {
                let resultDecodedBuilder = Tensorflow.MemoryLogRawDeallocation.Builder()
                if let jsonValueStepId = jsonMap["stepId"] as? String {
                    resultDecodedBuilder.stepId = Int64(jsonValueStepId)!
                } else if let jsonValueStepId = jsonMap["stepId"] as? Int {
                    resultDecodedBuilder.stepId = Int64(jsonValueStepId)
                }
                if let jsonValueOperation = jsonMap["operation"] as? String {
                    resultDecodedBuilder.operation = jsonValueOperation
                }
                if let jsonValueAllocationId = jsonMap["allocationId"] as? String {
                    resultDecodedBuilder.allocationId = Int64(jsonValueAllocationId)!
                } else if let jsonValueAllocationId = jsonMap["allocationId"] as? Int {
                    resultDecodedBuilder.allocationId = Int64(jsonValueAllocationId)
                }
                if let jsonValueAllocatorName = jsonMap["allocatorName"] as? String {
                    resultDecodedBuilder.allocatorName = jsonValueAllocatorName
                }
                if let jsonValueDeferred = jsonMap["deferred"] as? Bool {
                    resultDecodedBuilder.deferred = jsonValueDeferred
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.MemoryLogRawDeallocation.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.MemoryLogRawDeallocation.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.MemoryLogStep: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.MemoryLogStep> {
        var mergedArray = Array<Tensorflow.MemoryLogStep>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.MemoryLogStep? {
        return try Tensorflow.MemoryLogStep.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.MemoryLogStep {
        return try Tensorflow.MemoryLogStep.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.LogMemoryRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryLogStep {
        return try Tensorflow.MemoryLogStep.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.MemoryLogStep {
        return try Tensorflow.MemoryLogStep.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryLogStep {
        return try Tensorflow.MemoryLogStep.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.MemoryLogStep {
        return try Tensorflow.MemoryLogStep.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryLogStep {
        return try Tensorflow.MemoryLogStep.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "stepId": return self.stepId
        case "handle": return self.handle
        default: return nil
        }
    }
}
extension Tensorflow.MemoryLogStep.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "stepId": return self.stepId
            case "handle": return self.handle
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "stepId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.stepId = newSubscriptValue
            case "handle":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.handle = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.MemoryLogTensorAllocation: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.MemoryLogTensorAllocation> {
        var mergedArray = Array<Tensorflow.MemoryLogTensorAllocation>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.MemoryLogTensorAllocation? {
        return try Tensorflow.MemoryLogTensorAllocation.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.MemoryLogTensorAllocation {
        return try Tensorflow.MemoryLogTensorAllocation.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.LogMemoryRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryLogTensorAllocation {
        return try Tensorflow.MemoryLogTensorAllocation.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.MemoryLogTensorAllocation {
        return try Tensorflow.MemoryLogTensorAllocation.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryLogTensorAllocation {
        return try Tensorflow.MemoryLogTensorAllocation.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.MemoryLogTensorAllocation {
        return try Tensorflow.MemoryLogTensorAllocation.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryLogTensorAllocation {
        return try Tensorflow.MemoryLogTensorAllocation.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "stepId": return self.stepId
        case "kernelName": return self.kernelName
        case "tensor": return self.tensor
        default: return nil
        }
    }
}
extension Tensorflow.MemoryLogTensorAllocation.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "stepId": return self.stepId
            case "kernelName": return self.kernelName
            case "tensor": return self.tensor
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "stepId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.stepId = newSubscriptValue
            case "kernelName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.kernelName = newSubscriptValue
            case "tensor":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.TensorDescription else {
                    return
                }
                self.tensor = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.MemoryLogTensorDeallocation: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.MemoryLogTensorDeallocation> {
        var mergedArray = Array<Tensorflow.MemoryLogTensorDeallocation>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.MemoryLogTensorDeallocation? {
        return try Tensorflow.MemoryLogTensorDeallocation.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.MemoryLogTensorDeallocation {
        return try Tensorflow.MemoryLogTensorDeallocation.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.LogMemoryRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryLogTensorDeallocation {
        return try Tensorflow.MemoryLogTensorDeallocation.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.MemoryLogTensorDeallocation {
        return try Tensorflow.MemoryLogTensorDeallocation.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryLogTensorDeallocation {
        return try Tensorflow.MemoryLogTensorDeallocation.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.MemoryLogTensorDeallocation {
        return try Tensorflow.MemoryLogTensorDeallocation.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryLogTensorDeallocation {
        return try Tensorflow.MemoryLogTensorDeallocation.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "allocationId": return self.allocationId
        case "allocatorName": return self.allocatorName
        default: return nil
        }
    }
}
extension Tensorflow.MemoryLogTensorDeallocation.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "allocationId": return self.allocationId
            case "allocatorName": return self.allocatorName
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "allocationId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.allocationId = newSubscriptValue
            case "allocatorName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.allocatorName = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.MemoryLogTensorOutput: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.MemoryLogTensorOutput> {
        var mergedArray = Array<Tensorflow.MemoryLogTensorOutput>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.MemoryLogTensorOutput? {
        return try Tensorflow.MemoryLogTensorOutput.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.MemoryLogTensorOutput {
        return try Tensorflow.MemoryLogTensorOutput.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.LogMemoryRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryLogTensorOutput {
        return try Tensorflow.MemoryLogTensorOutput.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.MemoryLogTensorOutput {
        return try Tensorflow.MemoryLogTensorOutput.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryLogTensorOutput {
        return try Tensorflow.MemoryLogTensorOutput.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.MemoryLogTensorOutput {
        return try Tensorflow.MemoryLogTensorOutput.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryLogTensorOutput {
        return try Tensorflow.MemoryLogTensorOutput.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "stepId": return self.stepId
        case "kernelName": return self.kernelName
        case "index": return self.index
        case "tensor": return self.tensor
        default: return nil
        }
    }
}
extension Tensorflow.MemoryLogTensorOutput.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "stepId": return self.stepId
            case "kernelName": return self.kernelName
            case "index": return self.index
            case "tensor": return self.tensor
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "stepId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.stepId = newSubscriptValue
            case "kernelName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.kernelName = newSubscriptValue
            case "index":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.index = newSubscriptValue
            case "tensor":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.TensorDescription else {
                    return
                }
                self.tensor = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.MemoryLogRawAllocation: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.MemoryLogRawAllocation> {
        var mergedArray = Array<Tensorflow.MemoryLogRawAllocation>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.MemoryLogRawAllocation? {
        return try Tensorflow.MemoryLogRawAllocation.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.MemoryLogRawAllocation {
        return try Tensorflow.MemoryLogRawAllocation.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.LogMemoryRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryLogRawAllocation {
        return try Tensorflow.MemoryLogRawAllocation.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.MemoryLogRawAllocation {
        return try Tensorflow.MemoryLogRawAllocation.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryLogRawAllocation {
        return try Tensorflow.MemoryLogRawAllocation.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.MemoryLogRawAllocation {
        return try Tensorflow.MemoryLogRawAllocation.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryLogRawAllocation {
        return try Tensorflow.MemoryLogRawAllocation.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "stepId": return self.stepId
        case "operation": return self.operation
        case "numBytes": return self.numBytes
        case "ptr": return self.ptr
        case "allocationId": return self.allocationId
        case "allocatorName": return self.allocatorName
        default: return nil
        }
    }
}
extension Tensorflow.MemoryLogRawAllocation.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "stepId": return self.stepId
            case "operation": return self.operation
            case "numBytes": return self.numBytes
            case "ptr": return self.ptr
            case "allocationId": return self.allocationId
            case "allocatorName": return self.allocatorName
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "stepId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.stepId = newSubscriptValue
            case "operation":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.operation = newSubscriptValue
            case "numBytes":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.numBytes = newSubscriptValue
            case "ptr":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.ptr = newSubscriptValue
            case "allocationId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.allocationId = newSubscriptValue
            case "allocatorName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.allocatorName = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.MemoryLogRawDeallocation: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.MemoryLogRawDeallocation> {
        var mergedArray = Array<Tensorflow.MemoryLogRawDeallocation>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.MemoryLogRawDeallocation? {
        return try Tensorflow.MemoryLogRawDeallocation.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.MemoryLogRawDeallocation {
        return try Tensorflow.MemoryLogRawDeallocation.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.LogMemoryRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryLogRawDeallocation {
        return try Tensorflow.MemoryLogRawDeallocation.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.MemoryLogRawDeallocation {
        return try Tensorflow.MemoryLogRawDeallocation.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryLogRawDeallocation {
        return try Tensorflow.MemoryLogRawDeallocation.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.MemoryLogRawDeallocation {
        return try Tensorflow.MemoryLogRawDeallocation.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryLogRawDeallocation {
        return try Tensorflow.MemoryLogRawDeallocation.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "stepId": return self.stepId
        case "operation": return self.operation
        case "allocationId": return self.allocationId
        case "allocatorName": return self.allocatorName
        case "deferred": return self.deferred
        default: return nil
        }
    }
}
extension Tensorflow.MemoryLogRawDeallocation.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "stepId": return self.stepId
            case "operation": return self.operation
            case "allocationId": return self.allocationId
            case "allocatorName": return self.allocatorName
            case "deferred": return self.deferred
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "stepId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.stepId = newSubscriptValue
            case "operation":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.operation = newSubscriptValue
            case "allocationId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.allocationId = newSubscriptValue
            case "allocatorName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.allocatorName = newSubscriptValue
            case "deferred":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.deferred = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

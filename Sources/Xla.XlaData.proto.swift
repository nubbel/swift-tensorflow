/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "xla_data.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Xla { }

public extension Xla {
    public struct XlaDataRoot {
        public static let `default` = XlaDataRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }



    //Enum type declaration start 

    /// Primitive types are the individual values that can be held in rectangular
    /// multidimensional arrays. A description of the rectangular multidimensional
    /// array dimensions / primitive type is given by Shape, below.
    public enum PrimitiveType:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
        /// Invalid primitive type to serve as default.
        case primitiveTypeInvalid = 0

        /// Predicates are two-state booleans.
        case pred = 1

        /// Signed integral values of fixed width.
        case s8 = 2
        case s16 = 3
        case s32 = 4
        case s64 = 5

        /// Unsigned integral values of fixed width.
        case u8 = 6
        case u16 = 7
        case u32 = 8
        case u64 = 9

        /// Floating-point values of fixed width.
        /// Note: if f16s are not natively supported on the device, they will be
        /// converted to f16 from f32 at arbirary points in the computation.
        case f16 = 10
        case f32 = 11
        case f64 = 12

        /// A tuple is a polymorphic sequence; e.g. a shape that holds different
        /// sub-shapes. They are used for things like returning multiple values from a
        /// computation; e.g. a computation that returns weights and biases may have a
        /// signature that results in a tuple like (f32[784x2000], f32[2000])
        /// Tuples are currently special in that they may only be rank 0.
        case tuple = 13

        /// An opaque type used for passing context specific data to a custom
        /// operation.
        case opaque = 14
        public func toString() -> String {
            switch self {
            case .primitiveTypeInvalid: return "PRIMITIVE_TYPE_INVALID"
            case .pred: return "PRED"
            case .s8: return "S8"
            case .s16: return "S16"
            case .s32: return "S32"
            case .s64: return "S64"
            case .u8: return "U8"
            case .u16: return "U16"
            case .u32: return "U32"
            case .u64: return "U64"
            case .f16: return "F16"
            case .f32: return "F32"
            case .f64: return "F64"
            case .tuple: return "TUPLE"
            case .opaque: return "OPAQUE"
            }
        }
        public static func fromString(str:String) throws -> Xla.PrimitiveType {
            switch str {
            case "PRIMITIVE_TYPE_INVALID":    return .primitiveTypeInvalid
            case "PRED":    return .pred
            case "S8":    return .s8
            case "S16":    return .s16
            case "S32":    return .s32
            case "S64":    return .s64
            case "U8":    return .u8
            case "U16":    return .u16
            case "U32":    return .u32
            case "U64":    return .u64
            case "F16":    return .f16
            case "F32":    return .f32
            case "F64":    return .f64
            case "TUPLE":    return .tuple
            case "OPAQUE":    return .opaque
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .primitiveTypeInvalid: return ".primitiveTypeInvalid"
            case .pred: return ".pred"
            case .s8: return ".s8"
            case .s16: return ".s16"
            case .s32: return ".s32"
            case .s64: return ".s64"
            case .u8: return ".u8"
            case .u16: return ".u16"
            case .u32: return ".u32"
            case .u64: return ".u64"
            case .f16: return ".f16"
            case .f32: return ".f32"
            case .f64: return ".f64"
            case .tuple: return ".tuple"
            case .opaque: return ".opaque"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:PrimitiveType, rhs:PrimitiveType) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    /// Describes the value held inside padding elements.
    public enum PaddingValue:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
        case invalidPad = 0

        /// Zero padding must be 0-values that correspond to the shape's element type.
        case zeroPad = 1

        /// One padding must be 1-values that correspond to the shape's element type.
        case onePad = 2

        /// "Lowest" padding must be the lowest values in the shape's element type,
        /// used as padding for operations like max-accumulation.
        case lowestPad = 3

        /// "Highest" padding must be the largest values in the shape's element type,
        /// used as padding for operations like min-accumulation.
        case highestPad = 4

        /// Unknown padding could be anything; e.g. floating NaNs!
        case unknownPad = 5
        public func toString() -> String {
            switch self {
            case .invalidPad: return "INVALID_PAD"
            case .zeroPad: return "ZERO_PAD"
            case .onePad: return "ONE_PAD"
            case .lowestPad: return "LOWEST_PAD"
            case .highestPad: return "HIGHEST_PAD"
            case .unknownPad: return "UNKNOWN_PAD"
            }
        }
        public static func fromString(str:String) throws -> Xla.PaddingValue {
            switch str {
            case "INVALID_PAD":    return .invalidPad
            case "ZERO_PAD":    return .zeroPad
            case "ONE_PAD":    return .onePad
            case "LOWEST_PAD":    return .lowestPad
            case "HIGHEST_PAD":    return .highestPad
            case "UNKNOWN_PAD":    return .unknownPad
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .invalidPad: return ".invalidPad"
            case .zeroPad: return ".zeroPad"
            case .onePad: return ".onePad"
            case .lowestPad: return ".lowestPad"
            case .highestPad: return ".highestPad"
            case .unknownPad: return ".unknownPad"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:PaddingValue, rhs:PaddingValue) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    public enum UnaryOperation:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
        case unopInvalid = 0

        /// Elementwise, logical negation
        case unopLogicalNot = 1

        /// Elementwise, computes e^x.
        case unopExp = 2

        /// Elementwise, computes -x.
        case unopNegate = 3

        /// Puts the elements in the operand into sorted order.
        case unopSort = 4

        /// Elementwise, computes tanh(x).
        case unopTanh = 5

        /// Elementwise, computes the natural logarithm of x.
        case unopLog = 6

        /// Elementwise, computes the floor of x.
        case unopFloor = 7

        /// Elementwise, computes the ceil of x.
        case unopCeil = 8

        /// Elementwise, computes the abs of x.
        case unopAbs = 9

        /// Elementwise, computes the sign of x.
        case unopSign = 10

        /// Elementwise, tests if values are finite (not NaN or inf)
        case unopIsFinite = 11
        public func toString() -> String {
            switch self {
            case .unopInvalid: return "UNOP_INVALID"
            case .unopLogicalNot: return "UNOP_LOGICAL_NOT"
            case .unopExp: return "UNOP_EXP"
            case .unopNegate: return "UNOP_NEGATE"
            case .unopSort: return "UNOP_SORT"
            case .unopTanh: return "UNOP_TANH"
            case .unopLog: return "UNOP_LOG"
            case .unopFloor: return "UNOP_FLOOR"
            case .unopCeil: return "UNOP_CEIL"
            case .unopAbs: return "UNOP_ABS"
            case .unopSign: return "UNOP_SIGN"
            case .unopIsFinite: return "UNOP_IS_FINITE"
            }
        }
        public static func fromString(str:String) throws -> Xla.UnaryOperation {
            switch str {
            case "UNOP_INVALID":    return .unopInvalid
            case "UNOP_LOGICAL_NOT":    return .unopLogicalNot
            case "UNOP_EXP":    return .unopExp
            case "UNOP_NEGATE":    return .unopNegate
            case "UNOP_SORT":    return .unopSort
            case "UNOP_TANH":    return .unopTanh
            case "UNOP_LOG":    return .unopLog
            case "UNOP_FLOOR":    return .unopFloor
            case "UNOP_CEIL":    return .unopCeil
            case "UNOP_ABS":    return .unopAbs
            case "UNOP_SIGN":    return .unopSign
            case "UNOP_IS_FINITE":    return .unopIsFinite
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .unopInvalid: return ".unopInvalid"
            case .unopLogicalNot: return ".unopLogicalNot"
            case .unopExp: return ".unopExp"
            case .unopNegate: return ".unopNegate"
            case .unopSort: return ".unopSort"
            case .unopTanh: return ".unopTanh"
            case .unopLog: return ".unopLog"
            case .unopFloor: return ".unopFloor"
            case .unopCeil: return ".unopCeil"
            case .unopAbs: return ".unopAbs"
            case .unopSign: return ".unopSign"
            case .unopIsFinite: return ".unopIsFinite"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:UnaryOperation, rhs:UnaryOperation) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    public enum BinaryOperation:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
        case binopInvalid = 0

        /// Arithmetic operations.
        case binopAdd = 1
        case binopDiv = 2
        case binopMul = 3
        case binopSub = 4

        /// Comparison operators.
        case binopEq = 5
        case binopGe = 6
        case binopGt = 7
        case binopLe = 8
        case binopLt = 9
        case binopNe = 10

        /// Dot product, matrix multiply.
        case binopDot = 12

        /// Indexes into the LHS with the RHS.
        /// If the RHS is higher-rank, this is a gather operation.
        /// Note: currently out of bounds indices may crash the underlying XLA
        /// machine.
        case binopIndex = 13

        /// Element-wise maximum.
        case binopMax = 14

        /// Element-wise minimum.
        case binopMin = 15

        /// Raises the left-hand-side to the right-hand-side power.
        case binopPow = 16

        /// Remainder operation.
        case binopRem = 17

        /// Logical operators
        case binopLogicalAnd = 18
        case binopLogicalOr = 19
        public func toString() -> String {
            switch self {
            case .binopInvalid: return "BINOP_INVALID"
            case .binopAdd: return "BINOP_ADD"
            case .binopDiv: return "BINOP_DIV"
            case .binopMul: return "BINOP_MUL"
            case .binopSub: return "BINOP_SUB"
            case .binopEq: return "BINOP_EQ"
            case .binopGe: return "BINOP_GE"
            case .binopGt: return "BINOP_GT"
            case .binopLe: return "BINOP_LE"
            case .binopLt: return "BINOP_LT"
            case .binopNe: return "BINOP_NE"
            case .binopDot: return "BINOP_DOT"
            case .binopIndex: return "BINOP_INDEX"
            case .binopMax: return "BINOP_MAX"
            case .binopMin: return "BINOP_MIN"
            case .binopPow: return "BINOP_POW"
            case .binopRem: return "BINOP_REM"
            case .binopLogicalAnd: return "BINOP_LOGICAL_AND"
            case .binopLogicalOr: return "BINOP_LOGICAL_OR"
            }
        }
        public static func fromString(str:String) throws -> Xla.BinaryOperation {
            switch str {
            case "BINOP_INVALID":    return .binopInvalid
            case "BINOP_ADD":    return .binopAdd
            case "BINOP_DIV":    return .binopDiv
            case "BINOP_MUL":    return .binopMul
            case "BINOP_SUB":    return .binopSub
            case "BINOP_EQ":    return .binopEq
            case "BINOP_GE":    return .binopGe
            case "BINOP_GT":    return .binopGt
            case "BINOP_LE":    return .binopLe
            case "BINOP_LT":    return .binopLt
            case "BINOP_NE":    return .binopNe
            case "BINOP_DOT":    return .binopDot
            case "BINOP_INDEX":    return .binopIndex
            case "BINOP_MAX":    return .binopMax
            case "BINOP_MIN":    return .binopMin
            case "BINOP_POW":    return .binopPow
            case "BINOP_REM":    return .binopRem
            case "BINOP_LOGICAL_AND":    return .binopLogicalAnd
            case "BINOP_LOGICAL_OR":    return .binopLogicalOr
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .binopInvalid: return ".binopInvalid"
            case .binopAdd: return ".binopAdd"
            case .binopDiv: return ".binopDiv"
            case .binopMul: return ".binopMul"
            case .binopSub: return ".binopSub"
            case .binopEq: return ".binopEq"
            case .binopGe: return ".binopGe"
            case .binopGt: return ".binopGt"
            case .binopLe: return ".binopLe"
            case .binopLt: return ".binopLt"
            case .binopNe: return ".binopNe"
            case .binopDot: return ".binopDot"
            case .binopIndex: return ".binopIndex"
            case .binopMax: return ".binopMax"
            case .binopMin: return ".binopMin"
            case .binopPow: return ".binopPow"
            case .binopRem: return ".binopRem"
            case .binopLogicalAnd: return ".binopLogicalAnd"
            case .binopLogicalOr: return ".binopLogicalOr"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:BinaryOperation, rhs:BinaryOperation) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    public enum RandomDistribution:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
        case rngInvalid = 0

        /// Creates a uniform-distribution-generated random number on the semi-open
        /// interval [parameter[0], parameter[1]).
        case rngUniform = 1

        /// Creates a normal-distribution-generated random number with mean
        /// parameter[0] and standard deviation parameter[1].
        case rngNormal = 2

        /// Creates a Bernoulli-distribution-generated random number with mean
        /// parameter[0].
        case rngBernoulli = 3
        public func toString() -> String {
            switch self {
            case .rngInvalid: return "RNG_INVALID"
            case .rngUniform: return "RNG_UNIFORM"
            case .rngNormal: return "RNG_NORMAL"
            case .rngBernoulli: return "RNG_BERNOULLI"
            }
        }
        public static func fromString(str:String) throws -> Xla.RandomDistribution {
            switch str {
            case "RNG_INVALID":    return .rngInvalid
            case "RNG_UNIFORM":    return .rngUniform
            case "RNG_NORMAL":    return .rngNormal
            case "RNG_BERNOULLI":    return .rngBernoulli
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .rngInvalid: return ".rngInvalid"
            case .rngUniform: return ".rngUniform"
            case .rngNormal: return ".rngNormal"
            case .rngBernoulli: return ".rngBernoulli"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:RandomDistribution, rhs:RandomDistribution) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    public enum TernaryOperation:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
        case triopInvalid = 0

        /// Given a predicate and two operands, selects operand0 if the predicate is
        /// true and operand1 if the predicate is false.
        case triopSelect = 1

        /// Updates operand0 at index operand1 with value operand2 and outputs the
        /// updated value.
        case triopUpdate = 2

        /// Given a min, max and an operand returns the operand if between min and max,
        /// else returns min if operand is less than min or max if operand is greater
        /// than max.
        case triopClamp = 3
        public func toString() -> String {
            switch self {
            case .triopInvalid: return "TRIOP_INVALID"
            case .triopSelect: return "TRIOP_SELECT"
            case .triopUpdate: return "TRIOP_UPDATE"
            case .triopClamp: return "TRIOP_CLAMP"
            }
        }
        public static func fromString(str:String) throws -> Xla.TernaryOperation {
            switch str {
            case "TRIOP_INVALID":    return .triopInvalid
            case "TRIOP_SELECT":    return .triopSelect
            case "TRIOP_UPDATE":    return .triopUpdate
            case "TRIOP_CLAMP":    return .triopClamp
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .triopInvalid: return ".triopInvalid"
            case .triopSelect: return ".triopSelect"
            case .triopUpdate: return ".triopUpdate"
            case .triopClamp: return ".triopClamp"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:TernaryOperation, rhs:TernaryOperation) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    public enum VariadicOperation:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
        case varopInvalid = 0

        /// Creates a tuple from its operands.
        case varopTuple = 1
        public func toString() -> String {
            switch self {
            case .varopInvalid: return "VAROP_INVALID"
            case .varopTuple: return "VAROP_TUPLE"
            }
        }
        public static func fromString(str:String) throws -> Xla.VariadicOperation {
            switch str {
            case "VAROP_INVALID":    return .varopInvalid
            case "VAROP_TUPLE":    return .varopTuple
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .varopInvalid: return ".varopInvalid"
            case .varopTuple: return ".varopTuple"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:VariadicOperation, rhs:VariadicOperation) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 

    /// Describes the padding configuration for Pad operation. The padding amount on
    /// both edges as well as between the elements are specified for each dimension.
    final public class PaddingConfig : GeneratedMessage {

        public static func == (lhs: Xla.PaddingConfig, rhs: Xla.PaddingConfig) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.dimensions == rhs.dimensions)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        /// Describes the padding configuration for a dimension.
        final public class PaddingConfigDimension : GeneratedMessage {

            public static func == (lhs: Xla.PaddingConfig.PaddingConfigDimension, rhs: Xla.PaddingConfig.PaddingConfigDimension) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasEdgePaddingLow == rhs.hasEdgePaddingLow) && (!lhs.hasEdgePaddingLow || lhs.edgePaddingLow == rhs.edgePaddingLow)
                fieldCheck = fieldCheck && (lhs.hasEdgePaddingHigh == rhs.hasEdgePaddingHigh) && (!lhs.hasEdgePaddingHigh || lhs.edgePaddingHigh == rhs.edgePaddingHigh)
                fieldCheck = fieldCheck && (lhs.hasInteriorPadding == rhs.hasInteriorPadding) && (!lhs.hasInteriorPadding || lhs.interiorPadding == rhs.interiorPadding)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            /// Padding amount on the low-end (next to the index 0).
            public fileprivate(set) var edgePaddingLow:Int64 = Int64(0)
            public fileprivate(set) var hasEdgePaddingLow:Bool = false

            /// Padding amount on the high-end (next to the highest index).
            public fileprivate(set) var edgePaddingHigh:Int64 = Int64(0)
            public fileprivate(set) var hasEdgePaddingHigh:Bool = false

            /// Padding amount between the elements.
            public fileprivate(set) var interiorPadding:Int64 = Int64(0)
            public fileprivate(set) var hasInteriorPadding:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasEdgePaddingLow {
                    try codedOutputStream.writeInt64(fieldNumber: 1, value:edgePaddingLow)
                }
                if hasEdgePaddingHigh {
                    try codedOutputStream.writeInt64(fieldNumber: 2, value:edgePaddingHigh)
                }
                if hasInteriorPadding {
                    try codedOutputStream.writeInt64(fieldNumber: 3, value:interiorPadding)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasEdgePaddingLow {
                    serialize_size += edgePaddingLow.computeInt64Size(fieldNumber: 1)
                }
                if hasEdgePaddingHigh {
                    serialize_size += edgePaddingHigh.computeInt64Size(fieldNumber: 2)
                }
                if hasInteriorPadding {
                    serialize_size += interiorPadding.computeInt64Size(fieldNumber: 3)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Xla.PaddingConfig.PaddingConfigDimension.Builder {
                return Xla.PaddingConfig.PaddingConfigDimension.classBuilder() as! Xla.PaddingConfig.PaddingConfigDimension.Builder
            }
            public func getBuilder() -> Xla.PaddingConfig.PaddingConfigDimension.Builder {
                return classBuilder() as! Xla.PaddingConfig.PaddingConfigDimension.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Xla.PaddingConfig.PaddingConfigDimension.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Xla.PaddingConfig.PaddingConfigDimension.Builder()
            }
            public func toBuilder() throws -> Xla.PaddingConfig.PaddingConfigDimension.Builder {
                return try Xla.PaddingConfig.PaddingConfigDimension.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Xla.PaddingConfig.PaddingConfigDimension) throws -> Xla.PaddingConfig.PaddingConfigDimension.Builder {
                return try Xla.PaddingConfig.PaddingConfigDimension.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasEdgePaddingLow {
                    jsonMap["edgePaddingLow"] = "\(edgePaddingLow)"
                }
                if hasEdgePaddingHigh {
                    jsonMap["edgePaddingHigh"] = "\(edgePaddingHigh)"
                }
                if hasInteriorPadding {
                    jsonMap["interiorPadding"] = "\(interiorPadding)"
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.PaddingConfig.PaddingConfigDimension {
                return try Xla.PaddingConfig.PaddingConfigDimension.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Xla.PaddingConfig.PaddingConfigDimension {
                return try Xla.PaddingConfig.PaddingConfigDimension.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasEdgePaddingLow {
                    output += "\(indent) edgePaddingLow: \(edgePaddingLow) \n"
                }
                if hasEdgePaddingHigh {
                    output += "\(indent) edgePaddingHigh: \(edgePaddingHigh) \n"
                }
                if hasInteriorPadding {
                    output += "\(indent) interiorPadding: \(interiorPadding) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasEdgePaddingLow {
                        hashCode = (hashCode &* 31) &+ edgePaddingLow.hashValue
                    }
                    if hasEdgePaddingHigh {
                        hashCode = (hashCode &* 31) &+ edgePaddingHigh.hashValue
                    }
                    if hasInteriorPadding {
                        hashCode = (hashCode &* 31) &+ interiorPadding.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Xla.PaddingConfig.PaddingConfigDimension"
            }
            override public func className() -> String {
                return "Xla.PaddingConfig.PaddingConfigDimension"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Xla.PaddingConfig.PaddingConfigDimension = Xla.PaddingConfig.PaddingConfigDimension()
                public func getMessage() -> Xla.PaddingConfig.PaddingConfigDimension {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                /// Padding amount on the low-end (next to the index 0).
                public var edgePaddingLow:Int64 {
                    get {
                        return builderResult.edgePaddingLow
                    }
                    set (value) {
                        builderResult.hasEdgePaddingLow = true
                        builderResult.edgePaddingLow = value
                    }
                }
                public var hasEdgePaddingLow:Bool {
                    get {
                        return builderResult.hasEdgePaddingLow
                    }
                }
                @discardableResult
                public func setEdgePaddingLow(_ value:Int64) -> Xla.PaddingConfig.PaddingConfigDimension.Builder {
                    self.edgePaddingLow = value
                    return self
                }
                @discardableResult
                public func clearEdgePaddingLow() -> Xla.PaddingConfig.PaddingConfigDimension.Builder{
                    builderResult.hasEdgePaddingLow = false
                    builderResult.edgePaddingLow = Int64(0)
                    return self
                }
                /// Padding amount on the high-end (next to the highest index).
                public var edgePaddingHigh:Int64 {
                    get {
                        return builderResult.edgePaddingHigh
                    }
                    set (value) {
                        builderResult.hasEdgePaddingHigh = true
                        builderResult.edgePaddingHigh = value
                    }
                }
                public var hasEdgePaddingHigh:Bool {
                    get {
                        return builderResult.hasEdgePaddingHigh
                    }
                }
                @discardableResult
                public func setEdgePaddingHigh(_ value:Int64) -> Xla.PaddingConfig.PaddingConfigDimension.Builder {
                    self.edgePaddingHigh = value
                    return self
                }
                @discardableResult
                public func clearEdgePaddingHigh() -> Xla.PaddingConfig.PaddingConfigDimension.Builder{
                    builderResult.hasEdgePaddingHigh = false
                    builderResult.edgePaddingHigh = Int64(0)
                    return self
                }
                /// Padding amount between the elements.
                public var interiorPadding:Int64 {
                    get {
                        return builderResult.interiorPadding
                    }
                    set (value) {
                        builderResult.hasInteriorPadding = true
                        builderResult.interiorPadding = value
                    }
                }
                public var hasInteriorPadding:Bool {
                    get {
                        return builderResult.hasInteriorPadding
                    }
                }
                @discardableResult
                public func setInteriorPadding(_ value:Int64) -> Xla.PaddingConfig.PaddingConfigDimension.Builder {
                    self.interiorPadding = value
                    return self
                }
                @discardableResult
                public func clearInteriorPadding() -> Xla.PaddingConfig.PaddingConfigDimension.Builder{
                    builderResult.hasInteriorPadding = false
                    builderResult.interiorPadding = Int64(0)
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Xla.PaddingConfig.PaddingConfigDimension.Builder {
                    builderResult = Xla.PaddingConfig.PaddingConfigDimension()
                    return self
                }
                override public func clone() throws -> Xla.PaddingConfig.PaddingConfigDimension.Builder {
                    return try Xla.PaddingConfig.PaddingConfigDimension.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Xla.PaddingConfig.PaddingConfigDimension {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Xla.PaddingConfig.PaddingConfigDimension {
                    let returnMe:Xla.PaddingConfig.PaddingConfigDimension = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Xla.PaddingConfig.PaddingConfigDimension) throws -> Xla.PaddingConfig.PaddingConfigDimension.Builder {
                    if other == Xla.PaddingConfig.PaddingConfigDimension() {
                        return self
                    }
                    if other.hasEdgePaddingLow {
                        edgePaddingLow = other.edgePaddingLow
                    }
                    if other.hasEdgePaddingHigh {
                        edgePaddingHigh = other.edgePaddingHigh
                    }
                    if other.hasInteriorPadding {
                        interiorPadding = other.interiorPadding
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.PaddingConfig.PaddingConfigDimension.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.PaddingConfig.PaddingConfigDimension.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 8:
                            edgePaddingLow = try codedInputStream.readInt64()

                        case 16:
                            edgePaddingHigh = try codedInputStream.readInt64()

                        case 24:
                            interiorPadding = try codedInputStream.readInt64()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.PaddingConfig.PaddingConfigDimension.Builder {
                    let resultDecodedBuilder = Xla.PaddingConfig.PaddingConfigDimension.Builder()
                    if let jsonValueEdgePaddingLow = jsonMap["edgePaddingLow"] as? String {
                        resultDecodedBuilder.edgePaddingLow = Int64(jsonValueEdgePaddingLow)!
                    } else if let jsonValueEdgePaddingLow = jsonMap["edgePaddingLow"] as? Int {
                        resultDecodedBuilder.edgePaddingLow = Int64(jsonValueEdgePaddingLow)
                    }
                    if let jsonValueEdgePaddingHigh = jsonMap["edgePaddingHigh"] as? String {
                        resultDecodedBuilder.edgePaddingHigh = Int64(jsonValueEdgePaddingHigh)!
                    } else if let jsonValueEdgePaddingHigh = jsonMap["edgePaddingHigh"] as? Int {
                        resultDecodedBuilder.edgePaddingHigh = Int64(jsonValueEdgePaddingHigh)
                    }
                    if let jsonValueInteriorPadding = jsonMap["interiorPadding"] as? String {
                        resultDecodedBuilder.interiorPadding = Int64(jsonValueInteriorPadding)!
                    } else if let jsonValueInteriorPadding = jsonMap["interiorPadding"] as? Int {
                        resultDecodedBuilder.interiorPadding = Int64(jsonValueInteriorPadding)
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Xla.PaddingConfig.PaddingConfigDimension.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Xla.PaddingConfig.PaddingConfigDimension.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        public fileprivate(set) var dimensions:Array<Xla.PaddingConfig.PaddingConfigDimension>  = Array<Xla.PaddingConfig.PaddingConfigDimension>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementDimensions in dimensions {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementDimensions)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementDimensions in dimensions {
                serialize_size += oneElementDimensions.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.PaddingConfig.Builder {
            return Xla.PaddingConfig.classBuilder() as! Xla.PaddingConfig.Builder
        }
        public func getBuilder() -> Xla.PaddingConfig.Builder {
            return classBuilder() as! Xla.PaddingConfig.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.PaddingConfig.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.PaddingConfig.Builder()
        }
        public func toBuilder() throws -> Xla.PaddingConfig.Builder {
            return try Xla.PaddingConfig.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.PaddingConfig) throws -> Xla.PaddingConfig.Builder {
            return try Xla.PaddingConfig.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !dimensions.isEmpty {
                var jsonArrayDimensions:Array<Dictionary<String,Any>> = []
                for oneValueDimensions in dimensions {
                    let ecodedMessageDimensions = try oneValueDimensions.encode()
                    jsonArrayDimensions.append(ecodedMessageDimensions)
                }
                jsonMap["dimensions"] = jsonArrayDimensions
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.PaddingConfig {
            return try Xla.PaddingConfig.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.PaddingConfig {
            return try Xla.PaddingConfig.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var dimensionsElementIndex:Int = 0
            for oneElementDimensions in dimensions {
                output += "\(indent) dimensions[\(dimensionsElementIndex)] {\n"
                output += try oneElementDimensions.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                dimensionsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementDimensions in dimensions {
                    hashCode = (hashCode &* 31) &+ oneElementDimensions.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.PaddingConfig"
        }
        override public func className() -> String {
            return "Xla.PaddingConfig"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.PaddingConfig = Xla.PaddingConfig()
            public func getMessage() -> Xla.PaddingConfig {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The padding configuration for all dimensions.
            public var dimensions:Array<Xla.PaddingConfig.PaddingConfigDimension> {
                get {
                    return builderResult.dimensions
                }
                set (value) {
                    builderResult.dimensions = value
                }
            }
            @discardableResult
            public func setDimensions(_ value:Array<Xla.PaddingConfig.PaddingConfigDimension>) -> Xla.PaddingConfig.Builder {
                self.dimensions = value
                return self
            }
            @discardableResult
            public func clearDimensions() -> Xla.PaddingConfig.Builder {
                builderResult.dimensions.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.PaddingConfig.Builder {
                builderResult = Xla.PaddingConfig()
                return self
            }
            override public func clone() throws -> Xla.PaddingConfig.Builder {
                return try Xla.PaddingConfig.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.PaddingConfig {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.PaddingConfig {
                let returnMe:Xla.PaddingConfig = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.PaddingConfig) throws -> Xla.PaddingConfig.Builder {
                if other == Xla.PaddingConfig() {
                    return self
                }
                if !other.dimensions.isEmpty  {
                     builderResult.dimensions += other.dimensions
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.PaddingConfig.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.PaddingConfig.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Xla.PaddingConfig.PaddingConfigDimension.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        dimensions.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.PaddingConfig.Builder {
                let resultDecodedBuilder = Xla.PaddingConfig.Builder()
                if let jsonValueDimensions = jsonMap["dimensions"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayDimensions:Array<Xla.PaddingConfig.PaddingConfigDimension> = []
                    for oneValueDimensions in jsonValueDimensions {
                        let messageFromStringDimensions = try Xla.PaddingConfig.PaddingConfigDimension.Builder.decodeToBuilder(jsonMap:oneValueDimensions).build()

                        jsonArrayDimensions.append(messageFromStringDimensions)
                    }
                    resultDecodedBuilder.dimensions = jsonArrayDimensions
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.PaddingConfig.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.PaddingConfig.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// A layout describes how the array is placed in (1D) memory space.  This
    /// includes the minor-to-major ordering of dimensions within a shape, as well as
    /// any padding present in those dimensions.
    /// Clients must specify the layouts of input Literals to the
    /// computation. Layouts specified in interior operations which take Shapes (for
    /// example, Convert) are ignored.
    /// See the XLA documentation for more information on shapes and layouts.
    final public class Layout : GeneratedMessage {

        public static func == (lhs: Xla.Layout, rhs: Xla.Layout) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.minorToMajor == rhs.minorToMajor)
            fieldCheck = fieldCheck && (lhs.paddedDimensions == rhs.paddedDimensions)
            fieldCheck = fieldCheck && (lhs.hasPaddingValue == rhs.hasPaddingValue) && (!lhs.hasPaddingValue || lhs.paddingValue == rhs.paddingValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Sequence of dimension numbers, from minor (fastest varying index) to major
        /// (slowest varying index). This field is required.
        public fileprivate(set) var minorToMajor:Array<Int64> = Array<Int64>()
        private var minorToMajorMemoizedSerializedSize:Int32 = -1
        /// The width to which the layout of each dimension is padded up
        /// to. If present, the size of the padded_dimensions must equal the
        /// rank of the shape. The padding appears at the end of a dimension,
        /// not at the beginning. This kind of padding, unlike padding in
        /// e.g. convolution, is not part of the shape.
        public fileprivate(set) var paddedDimensions:Array<Int64> = Array<Int64>()
        private var paddedDimensionsMemoizedSerializedSize:Int32 = -1
        public fileprivate(set) var paddingValue:Xla.PaddingValue = Xla.PaddingValue.invalidPad
        public fileprivate(set) var hasPaddingValue:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if !minorToMajor.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 10)
                try codedOutputStream.writeRawVarint32(value: minorToMajorMemoizedSerializedSize)
                for oneValueminorToMajor in minorToMajor {
                    try codedOutputStream.writeInt64NoTag(value: oneValueminorToMajor)
                }
            }
            if !paddedDimensions.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 18)
                try codedOutputStream.writeRawVarint32(value: paddedDimensionsMemoizedSerializedSize)
                for oneValuepaddedDimensions in paddedDimensions {
                    try codedOutputStream.writeInt64NoTag(value: oneValuepaddedDimensions)
                }
            }
            if hasPaddingValue {
                try codedOutputStream.writeEnum(fieldNumber: 3, value:paddingValue.rawValue)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            var dataSizeMinorToMajor:Int32 = 0
            for oneValueminorToMajor in minorToMajor {
                dataSizeMinorToMajor += oneValueminorToMajor.computeInt64SizeNoTag()
            }
            serialize_size += dataSizeMinorToMajor
            if !minorToMajor.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeMinorToMajor.computeInt32SizeNoTag()
            }
            minorToMajorMemoizedSerializedSize = dataSizeMinorToMajor
            var dataSizePaddedDimensions:Int32 = 0
            for oneValuepaddedDimensions in paddedDimensions {
                dataSizePaddedDimensions += oneValuepaddedDimensions.computeInt64SizeNoTag()
            }
            serialize_size += dataSizePaddedDimensions
            if !paddedDimensions.isEmpty {
                serialize_size += 1
                serialize_size += dataSizePaddedDimensions.computeInt32SizeNoTag()
            }
            paddedDimensionsMemoizedSerializedSize = dataSizePaddedDimensions
            if (hasPaddingValue) {
                serialize_size += paddingValue.rawValue.computeEnumSize(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.Layout.Builder {
            return Xla.Layout.classBuilder() as! Xla.Layout.Builder
        }
        public func getBuilder() -> Xla.Layout.Builder {
            return classBuilder() as! Xla.Layout.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.Layout.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.Layout.Builder()
        }
        public func toBuilder() throws -> Xla.Layout.Builder {
            return try Xla.Layout.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.Layout) throws -> Xla.Layout.Builder {
            return try Xla.Layout.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !minorToMajor.isEmpty {
                var jsonArrayMinorToMajor:Array<String> = []
                for oneValueMinorToMajor in minorToMajor {
                    jsonArrayMinorToMajor.append("\(oneValueMinorToMajor)")
                }
                jsonMap["minorToMajor"] = jsonArrayMinorToMajor
            }
            if !paddedDimensions.isEmpty {
                var jsonArrayPaddedDimensions:Array<String> = []
                for oneValuePaddedDimensions in paddedDimensions {
                    jsonArrayPaddedDimensions.append("\(oneValuePaddedDimensions)")
                }
                jsonMap["paddedDimensions"] = jsonArrayPaddedDimensions
            }
            if hasPaddingValue {
                jsonMap["paddingValue"] = paddingValue.toString()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.Layout {
            return try Xla.Layout.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.Layout {
            return try Xla.Layout.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var minorToMajorElementIndex:Int = 0
            for oneValueMinorToMajor in minorToMajor  {
                output += "\(indent) minorToMajor[\(minorToMajorElementIndex)]: \(oneValueMinorToMajor)\n"
                minorToMajorElementIndex += 1
            }
            var paddedDimensionsElementIndex:Int = 0
            for oneValuePaddedDimensions in paddedDimensions  {
                output += "\(indent) paddedDimensions[\(paddedDimensionsElementIndex)]: \(oneValuePaddedDimensions)\n"
                paddedDimensionsElementIndex += 1
            }
            if (hasPaddingValue) {
                output += "\(indent) paddingValue: \(paddingValue.description)\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneValueMinorToMajor in minorToMajor {
                    hashCode = (hashCode &* 31) &+ oneValueMinorToMajor.hashValue
                }
                for oneValuePaddedDimensions in paddedDimensions {
                    hashCode = (hashCode &* 31) &+ oneValuePaddedDimensions.hashValue
                }
                if hasPaddingValue {
                     hashCode = (hashCode &* 31) &+ paddingValue.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.Layout"
        }
        override public func className() -> String {
            return "Xla.Layout"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.Layout = Xla.Layout()
            public func getMessage() -> Xla.Layout {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Sequence of dimension numbers, from minor (fastest varying index) to major
            /// (slowest varying index). This field is required.
            public var minorToMajor:Array<Int64> {
                get {
                    return builderResult.minorToMajor
                }
                set (array) {
                    builderResult.minorToMajor = array
                }
            }
            @discardableResult
            public func setMinorToMajor(_ value:Array<Int64>) -> Xla.Layout.Builder {
                self.minorToMajor = value
                return self
            }
            @discardableResult
            public func clearMinorToMajor() -> Xla.Layout.Builder {
                builderResult.minorToMajor.removeAll(keepingCapacity: false)
                return self
            }
            /// The width to which the layout of each dimension is padded up
            /// to. If present, the size of the padded_dimensions must equal the
            /// rank of the shape. The padding appears at the end of a dimension,
            /// not at the beginning. This kind of padding, unlike padding in
            /// e.g. convolution, is not part of the shape.
            public var paddedDimensions:Array<Int64> {
                get {
                    return builderResult.paddedDimensions
                }
                set (array) {
                    builderResult.paddedDimensions = array
                }
            }
            @discardableResult
            public func setPaddedDimensions(_ value:Array<Int64>) -> Xla.Layout.Builder {
                self.paddedDimensions = value
                return self
            }
            @discardableResult
            public func clearPaddedDimensions() -> Xla.Layout.Builder {
                builderResult.paddedDimensions.removeAll(keepingCapacity: false)
                return self
            }
            /// Describes the values in the padding specified by
            /// padded_dimensions.
                public var paddingValue:Xla.PaddingValue {
                    get {
                        return builderResult.paddingValue
                    }
                    set (value) {
                        builderResult.hasPaddingValue = true
                        builderResult.paddingValue = value
                    }
                }
                public var hasPaddingValue:Bool{
                    get {
                        return builderResult.hasPaddingValue
                    }
                }
            @discardableResult
                public func setPaddingValue(_ value:Xla.PaddingValue) -> Xla.Layout.Builder {
                  self.paddingValue = value
                  return self
                }
            @discardableResult
                public func clearPaddingValue() -> Xla.Layout.Builder {
                   builderResult.hasPaddingValue = false
                   builderResult.paddingValue = .invalidPad
                   return self
                }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.Layout.Builder {
                builderResult = Xla.Layout()
                return self
            }
            override public func clone() throws -> Xla.Layout.Builder {
                return try Xla.Layout.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.Layout {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.Layout {
                let returnMe:Xla.Layout = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.Layout) throws -> Xla.Layout.Builder {
                if other == Xla.Layout() {
                    return self
                }
                if !other.minorToMajor.isEmpty {
                    builderResult.minorToMajor += other.minorToMajor
                }
                if !other.paddedDimensions.isEmpty {
                    builderResult.paddedDimensions += other.paddedDimensions
                }
                if other.hasPaddingValue {
                    paddingValue = other.paddingValue
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.Layout.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.Layout.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.minorToMajor.append(try codedInputStream.readInt64())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 18:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.paddedDimensions.append(try codedInputStream.readInt64())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 24:
                        let valueIntpaddingValue = try codedInputStream.readEnum()
                        if let enumspaddingValue = Xla.PaddingValue(rawValue:valueIntpaddingValue){
                            paddingValue = enumspaddingValue
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 3, value:Int64(valueIntpaddingValue))
                        }

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.Layout.Builder {
                let resultDecodedBuilder = Xla.Layout.Builder()
                if let jsonValueMinorToMajor = jsonMap["minorToMajor"] as? Array<String> {
                    var jsonArrayMinorToMajor:Array<Int64> = []
                    for oneValueMinorToMajor in jsonValueMinorToMajor {
                        jsonArrayMinorToMajor.append(Int64(oneValueMinorToMajor)!)
                    }
                    resultDecodedBuilder.minorToMajor = jsonArrayMinorToMajor
                }
                if let jsonValuePaddedDimensions = jsonMap["paddedDimensions"] as? Array<String> {
                    var jsonArrayPaddedDimensions:Array<Int64> = []
                    for oneValuePaddedDimensions in jsonValuePaddedDimensions {
                        jsonArrayPaddedDimensions.append(Int64(oneValuePaddedDimensions)!)
                    }
                    resultDecodedBuilder.paddedDimensions = jsonArrayPaddedDimensions
                }
                if let jsonValuePaddingValue = jsonMap["paddingValue"] as? String {
                    resultDecodedBuilder.paddingValue = try Xla.PaddingValue.fromString(str: jsonValuePaddingValue)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.Layout.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.Layout.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// A shape describes the number of dimensions in the array, the size of each
    /// dimension, and the primitive component type.
    /// Tuples are a special case in that they have rank zero and have tuple_shapes
    /// defined.
    /// See the XLA documentation for more information on shapes and layouts.
    final public class Shape : GeneratedMessage {

        public static func == (lhs: Xla.Shape, rhs: Xla.Shape) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasElementType == rhs.hasElementType) && (!lhs.hasElementType || lhs.elementType == rhs.elementType)
            fieldCheck = fieldCheck && (lhs.dimensions == rhs.dimensions)
            fieldCheck = fieldCheck && (lhs.tupleShapes == rhs.tupleShapes)
            fieldCheck = fieldCheck && (lhs.hasLayout == rhs.hasLayout) && (!lhs.hasLayout || lhs.layout == rhs.layout)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var elementType:Xla.PrimitiveType = Xla.PrimitiveType.primitiveTypeInvalid
        public fileprivate(set) var hasElementType:Bool = false
        /// The size (number of elements) for each dimension.
        /// In XLA, dimensions are numbered from 0 to N-1 for an
        /// N-dimensional array. The first element of 'dimensions' is the size of
        /// dimension 0, the second element is the size of dimension 1, and so forth.
        /// Empty list indicates a scalar.
        public fileprivate(set) var dimensions:Array<Int64> = Array<Int64>()
        private var dimensionsMemoizedSerializedSize:Int32 = -1
        public fileprivate(set) var tupleShapes:Array<Xla.Shape>  = Array<Xla.Shape>()
        public fileprivate(set) var layout:Xla.Layout!
        public fileprivate(set) var hasLayout:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasElementType {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:elementType.rawValue)
            }
            if !dimensions.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 26)
                try codedOutputStream.writeRawVarint32(value: dimensionsMemoizedSerializedSize)
                for oneValuedimensions in dimensions {
                    try codedOutputStream.writeInt64NoTag(value: oneValuedimensions)
                }
            }
            for oneElementTupleShapes in tupleShapes {
                  try codedOutputStream.writeMessage(fieldNumber: 4, value:oneElementTupleShapes)
            }
            if hasLayout {
                try codedOutputStream.writeMessage(fieldNumber: 5, value:layout)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if (hasElementType) {
                serialize_size += elementType.rawValue.computeEnumSize(fieldNumber: 2)
            }
            var dataSizeDimensions:Int32 = 0
            for oneValuedimensions in dimensions {
                dataSizeDimensions += oneValuedimensions.computeInt64SizeNoTag()
            }
            serialize_size += dataSizeDimensions
            if !dimensions.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeDimensions.computeInt32SizeNoTag()
            }
            dimensionsMemoizedSerializedSize = dataSizeDimensions
            for oneElementTupleShapes in tupleShapes {
                serialize_size += oneElementTupleShapes.computeMessageSize(fieldNumber: 4)
            }
            if hasLayout {
                if let varSizelayout = layout?.computeMessageSize(fieldNumber: 5) {
                    serialize_size += varSizelayout
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.Shape.Builder {
            return Xla.Shape.classBuilder() as! Xla.Shape.Builder
        }
        public func getBuilder() -> Xla.Shape.Builder {
            return classBuilder() as! Xla.Shape.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.Shape.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.Shape.Builder()
        }
        public func toBuilder() throws -> Xla.Shape.Builder {
            return try Xla.Shape.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.Shape) throws -> Xla.Shape.Builder {
            return try Xla.Shape.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasElementType {
                jsonMap["elementType"] = elementType.toString()
            }
            if !dimensions.isEmpty {
                var jsonArrayDimensions:Array<String> = []
                for oneValueDimensions in dimensions {
                    jsonArrayDimensions.append("\(oneValueDimensions)")
                }
                jsonMap["dimensions"] = jsonArrayDimensions
            }
            if !tupleShapes.isEmpty {
                var jsonArrayTupleShapes:Array<Dictionary<String,Any>> = []
                for oneValueTupleShapes in tupleShapes {
                    let ecodedMessageTupleShapes = try oneValueTupleShapes.encode()
                    jsonArrayTupleShapes.append(ecodedMessageTupleShapes)
                }
                jsonMap["tupleShapes"] = jsonArrayTupleShapes
            }
            if hasLayout {
                jsonMap["layout"] = try layout.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.Shape {
            return try Xla.Shape.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.Shape {
            return try Xla.Shape.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if (hasElementType) {
                output += "\(indent) elementType: \(elementType.description)\n"
            }
            var dimensionsElementIndex:Int = 0
            for oneValueDimensions in dimensions  {
                output += "\(indent) dimensions[\(dimensionsElementIndex)]: \(oneValueDimensions)\n"
                dimensionsElementIndex += 1
            }
            var tupleShapesElementIndex:Int = 0
            for oneElementTupleShapes in tupleShapes {
                output += "\(indent) tupleShapes[\(tupleShapesElementIndex)] {\n"
                output += try oneElementTupleShapes.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                tupleShapesElementIndex += 1
            }
            if hasLayout {
                output += "\(indent) layout {\n"
                if let outDescLayout = layout {
                    output += try outDescLayout.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasElementType {
                     hashCode = (hashCode &* 31) &+ elementType.hashValue
                }
                for oneValueDimensions in dimensions {
                    hashCode = (hashCode &* 31) &+ oneValueDimensions.hashValue
                }
                for oneElementTupleShapes in tupleShapes {
                    hashCode = (hashCode &* 31) &+ oneElementTupleShapes.hashValue
                }
                if hasLayout {
                    if let hashValuelayout = layout?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuelayout
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.Shape"
        }
        override public func className() -> String {
            return "Xla.Shape"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.Shape = Xla.Shape()
            public func getMessage() -> Xla.Shape {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The element type for this shape.
                public var elementType:Xla.PrimitiveType {
                    get {
                        return builderResult.elementType
                    }
                    set (value) {
                        builderResult.hasElementType = true
                        builderResult.elementType = value
                    }
                }
                public var hasElementType:Bool{
                    get {
                        return builderResult.hasElementType
                    }
                }
            @discardableResult
                public func setElementType(_ value:Xla.PrimitiveType) -> Xla.Shape.Builder {
                  self.elementType = value
                  return self
                }
            @discardableResult
                public func clearElementType() -> Xla.Shape.Builder {
                   builderResult.hasElementType = false
                   builderResult.elementType = .primitiveTypeInvalid
                   return self
                }
            /// The size (number of elements) for each dimension.
            /// In XLA, dimensions are numbered from 0 to N-1 for an
            /// N-dimensional array. The first element of 'dimensions' is the size of
            /// dimension 0, the second element is the size of dimension 1, and so forth.
            /// Empty list indicates a scalar.
            public var dimensions:Array<Int64> {
                get {
                    return builderResult.dimensions
                }
                set (array) {
                    builderResult.dimensions = array
                }
            }
            @discardableResult
            public func setDimensions(_ value:Array<Int64>) -> Xla.Shape.Builder {
                self.dimensions = value
                return self
            }
            @discardableResult
            public func clearDimensions() -> Xla.Shape.Builder {
                builderResult.dimensions.removeAll(keepingCapacity: false)
                return self
            }
            /// For tuples only, the shapes of constitutent shapes in the tuple sequence.
            public var tupleShapes:Array<Xla.Shape> {
                get {
                    return builderResult.tupleShapes
                }
                set (value) {
                    builderResult.tupleShapes = value
                }
            }
            @discardableResult
            public func setTupleShapes(_ value:Array<Xla.Shape>) -> Xla.Shape.Builder {
                self.tupleShapes = value
                return self
            }
            @discardableResult
            public func clearTupleShapes() -> Xla.Shape.Builder {
                builderResult.tupleShapes.removeAll(keepingCapacity: false)
                return self
            }
            /// The layout used to back this shape.
            public var layout:Xla.Layout! {
                get {
                    if layoutBuilder_ != nil {
                        builderResult.layout = layoutBuilder_.getMessage()
                    }
                    return builderResult.layout
                }
                set (value) {
                    builderResult.hasLayout = true
                    builderResult.layout = value
                }
            }
            public var hasLayout:Bool {
                get {
                    return builderResult.hasLayout
                }
            }
            fileprivate var layoutBuilder_:Xla.Layout.Builder! {
                didSet {
                    builderResult.hasLayout = true
                }
            }
            public func getLayoutBuilder() -> Xla.Layout.Builder {
                if layoutBuilder_ == nil {
                    layoutBuilder_ = Xla.Layout.Builder()
                    builderResult.layout = layoutBuilder_.getMessage()
                    if layout != nil {
                        try! layoutBuilder_.mergeFrom(other: layout)
                    }
                }
                return layoutBuilder_
            }
            @discardableResult
            public func setLayout(_ value:Xla.Layout!) -> Xla.Shape.Builder {
                self.layout = value
                return self
            }
            @discardableResult
            public func mergeLayout(value:Xla.Layout) throws -> Xla.Shape.Builder {
                if builderResult.hasLayout {
                    builderResult.layout = try Xla.Layout.builderWithPrototype(prototype:builderResult.layout).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.layout = value
                }
                builderResult.hasLayout = true
                return self
            }
            @discardableResult
            public func clearLayout() -> Xla.Shape.Builder {
                layoutBuilder_ = nil
                builderResult.hasLayout = false
                builderResult.layout = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.Shape.Builder {
                builderResult = Xla.Shape()
                return self
            }
            override public func clone() throws -> Xla.Shape.Builder {
                return try Xla.Shape.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.Shape {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.Shape {
                let returnMe:Xla.Shape = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.Shape) throws -> Xla.Shape.Builder {
                if other == Xla.Shape() {
                    return self
                }
                if other.hasElementType {
                    elementType = other.elementType
                }
                if !other.dimensions.isEmpty {
                    builderResult.dimensions += other.dimensions
                }
                if !other.tupleShapes.isEmpty  {
                     builderResult.tupleShapes += other.tupleShapes
                }
                if (other.hasLayout) {
                    try mergeLayout(value: other.layout)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.Shape.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.Shape.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 16:
                        let valueIntelementType = try codedInputStream.readEnum()
                        if let enumselementType = Xla.PrimitiveType(rawValue:valueIntelementType){
                            elementType = enumselementType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntelementType))
                        }

                    case 26:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.dimensions.append(try codedInputStream.readInt64())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 34:
                        let subBuilder = Xla.Shape.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        tupleShapes.append(subBuilder.buildPartial())

                    case 42:
                        let subBuilder:Xla.Layout.Builder = Xla.Layout.Builder()
                        if hasLayout {
                            try subBuilder.mergeFrom(other: layout)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        layout = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.Shape.Builder {
                let resultDecodedBuilder = Xla.Shape.Builder()
                if let jsonValueElementType = jsonMap["elementType"] as? String {
                    resultDecodedBuilder.elementType = try Xla.PrimitiveType.fromString(str: jsonValueElementType)
                }
                if let jsonValueDimensions = jsonMap["dimensions"] as? Array<String> {
                    var jsonArrayDimensions:Array<Int64> = []
                    for oneValueDimensions in jsonValueDimensions {
                        jsonArrayDimensions.append(Int64(oneValueDimensions)!)
                    }
                    resultDecodedBuilder.dimensions = jsonArrayDimensions
                }
                if let jsonValueTupleShapes = jsonMap["tupleShapes"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayTupleShapes:Array<Xla.Shape> = []
                    for oneValueTupleShapes in jsonValueTupleShapes {
                        let messageFromStringTupleShapes = try Xla.Shape.Builder.decodeToBuilder(jsonMap:oneValueTupleShapes).build()

                        jsonArrayTupleShapes.append(messageFromStringTupleShapes)
                    }
                    resultDecodedBuilder.tupleShapes = jsonArrayTupleShapes
                }
                if let jsonValueLayout = jsonMap["layout"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.layout = try Xla.Layout.Builder.decodeToBuilder(jsonMap:jsonValueLayout).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.Shape.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.Shape.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Shape of the parameters and output of a computation (like a traditional
    /// function signature).
    final public class ProgramShape : GeneratedMessage {

        public static func == (lhs: Xla.ProgramShape, rhs: Xla.ProgramShape) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.parameters == rhs.parameters)
            fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
            fieldCheck = fieldCheck && (lhs.parameterNames == rhs.parameterNames)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var parameters:Array<Xla.Shape>  = Array<Xla.Shape>()
        public fileprivate(set) var result:Xla.Shape!
        public fileprivate(set) var hasResult:Bool = false
        public fileprivate(set) var parameterNames:Array<String> = Array<String>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementParameters in parameters {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementParameters)
            }
            if hasResult {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:result)
            }
            if !parameterNames.isEmpty {
                for oneValueparameterNames in parameterNames {
                    try codedOutputStream.writeString(fieldNumber: 3, value:oneValueparameterNames)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementParameters in parameters {
                serialize_size += oneElementParameters.computeMessageSize(fieldNumber: 1)
            }
            if hasResult {
                if let varSizeresult = result?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeresult
                }
            }
            var dataSizeParameterNames:Int32 = 0
            for oneValueparameterNames in parameterNames {
                dataSizeParameterNames += oneValueparameterNames.computeStringSizeNoTag()
            }
            serialize_size += dataSizeParameterNames
            serialize_size += 1 * Int32(parameterNames.count)
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.ProgramShape.Builder {
            return Xla.ProgramShape.classBuilder() as! Xla.ProgramShape.Builder
        }
        public func getBuilder() -> Xla.ProgramShape.Builder {
            return classBuilder() as! Xla.ProgramShape.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ProgramShape.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ProgramShape.Builder()
        }
        public func toBuilder() throws -> Xla.ProgramShape.Builder {
            return try Xla.ProgramShape.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.ProgramShape) throws -> Xla.ProgramShape.Builder {
            return try Xla.ProgramShape.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !parameters.isEmpty {
                var jsonArrayParameters:Array<Dictionary<String,Any>> = []
                for oneValueParameters in parameters {
                    let ecodedMessageParameters = try oneValueParameters.encode()
                    jsonArrayParameters.append(ecodedMessageParameters)
                }
                jsonMap["parameters"] = jsonArrayParameters
            }
            if hasResult {
                jsonMap["result"] = try result.encode()
            }
            if !parameterNames.isEmpty {
                var jsonArrayParameterNames:Array<String> = []
                for oneValueParameterNames in parameterNames {
                    jsonArrayParameterNames.append(oneValueParameterNames)
                }
                jsonMap["parameterNames"] = jsonArrayParameterNames
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.ProgramShape {
            return try Xla.ProgramShape.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.ProgramShape {
            return try Xla.ProgramShape.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var parametersElementIndex:Int = 0
            for oneElementParameters in parameters {
                output += "\(indent) parameters[\(parametersElementIndex)] {\n"
                output += try oneElementParameters.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                parametersElementIndex += 1
            }
            if hasResult {
                output += "\(indent) result {\n"
                if let outDescResult = result {
                    output += try outDescResult.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            var parameterNamesElementIndex:Int = 0
            for oneValueParameterNames in parameterNames  {
                output += "\(indent) parameterNames[\(parameterNamesElementIndex)]: \(oneValueParameterNames)\n"
                parameterNamesElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementParameters in parameters {
                    hashCode = (hashCode &* 31) &+ oneElementParameters.hashValue
                }
                if hasResult {
                    if let hashValueresult = result?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueresult
                    }
                }
                for oneValueParameterNames in parameterNames {
                    hashCode = (hashCode &* 31) &+ oneValueParameterNames.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.ProgramShape"
        }
        override public func className() -> String {
            return "Xla.ProgramShape"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.ProgramShape = Xla.ProgramShape()
            public func getMessage() -> Xla.ProgramShape {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var parameters:Array<Xla.Shape> {
                get {
                    return builderResult.parameters
                }
                set (value) {
                    builderResult.parameters = value
                }
            }
            @discardableResult
            public func setParameters(_ value:Array<Xla.Shape>) -> Xla.ProgramShape.Builder {
                self.parameters = value
                return self
            }
            @discardableResult
            public func clearParameters() -> Xla.ProgramShape.Builder {
                builderResult.parameters.removeAll(keepingCapacity: false)
                return self
            }
            public var result:Xla.Shape! {
                get {
                    if resultBuilder_ != nil {
                        builderResult.result = resultBuilder_.getMessage()
                    }
                    return builderResult.result
                }
                set (value) {
                    builderResult.hasResult = true
                    builderResult.result = value
                }
            }
            public var hasResult:Bool {
                get {
                    return builderResult.hasResult
                }
            }
            fileprivate var resultBuilder_:Xla.Shape.Builder! {
                didSet {
                    builderResult.hasResult = true
                }
            }
            public func getResultBuilder() -> Xla.Shape.Builder {
                if resultBuilder_ == nil {
                    resultBuilder_ = Xla.Shape.Builder()
                    builderResult.result = resultBuilder_.getMessage()
                    if result != nil {
                        try! resultBuilder_.mergeFrom(other: result)
                    }
                }
                return resultBuilder_
            }
            @discardableResult
            public func setResult(_ value:Xla.Shape!) -> Xla.ProgramShape.Builder {
                self.result = value
                return self
            }
            @discardableResult
            public func mergeResult(value:Xla.Shape) throws -> Xla.ProgramShape.Builder {
                if builderResult.hasResult {
                    builderResult.result = try Xla.Shape.builderWithPrototype(prototype:builderResult.result).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.result = value
                }
                builderResult.hasResult = true
                return self
            }
            @discardableResult
            public func clearResult() -> Xla.ProgramShape.Builder {
                resultBuilder_ = nil
                builderResult.hasResult = false
                builderResult.result = nil
                return self
            }
            public var parameterNames:Array<String> {
                get {
                    return builderResult.parameterNames
                }
                set (array) {
                    builderResult.parameterNames = array
                }
            }
            @discardableResult
            public func setParameterNames(_ value:Array<String>) -> Xla.ProgramShape.Builder {
                self.parameterNames = value
                return self
            }
            @discardableResult
            public func clearParameterNames() -> Xla.ProgramShape.Builder {
                builderResult.parameterNames.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.ProgramShape.Builder {
                builderResult = Xla.ProgramShape()
                return self
            }
            override public func clone() throws -> Xla.ProgramShape.Builder {
                return try Xla.ProgramShape.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.ProgramShape {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.ProgramShape {
                let returnMe:Xla.ProgramShape = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.ProgramShape) throws -> Xla.ProgramShape.Builder {
                if other == Xla.ProgramShape() {
                    return self
                }
                if !other.parameters.isEmpty  {
                     builderResult.parameters += other.parameters
                }
                if (other.hasResult) {
                    try mergeResult(value: other.result)
                }
                if !other.parameterNames.isEmpty {
                    builderResult.parameterNames += other.parameterNames
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.ProgramShape.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ProgramShape.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Xla.Shape.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        parameters.append(subBuilder.buildPartial())

                    case 18:
                        let subBuilder:Xla.Shape.Builder = Xla.Shape.Builder()
                        if hasResult {
                            try subBuilder.mergeFrom(other: result)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        result = subBuilder.buildPartial()

                    case 26:
                        parameterNames += [try codedInputStream.readString()]

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.ProgramShape.Builder {
                let resultDecodedBuilder = Xla.ProgramShape.Builder()
                if let jsonValueParameters = jsonMap["parameters"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayParameters:Array<Xla.Shape> = []
                    for oneValueParameters in jsonValueParameters {
                        let messageFromStringParameters = try Xla.Shape.Builder.decodeToBuilder(jsonMap:oneValueParameters).build()

                        jsonArrayParameters.append(messageFromStringParameters)
                    }
                    resultDecodedBuilder.parameters = jsonArrayParameters
                }
                if let jsonValueResult = jsonMap["result"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.result = try Xla.Shape.Builder.decodeToBuilder(jsonMap:jsonValueResult).build()

                }
                if let jsonValueParameterNames = jsonMap["parameterNames"] as? Array<String> {
                    var jsonArrayParameterNames:Array<String> = []
                    for oneValueParameterNames in jsonValueParameterNames {
                        jsonArrayParameterNames.append(oneValueParameterNames)
                    }
                    resultDecodedBuilder.parameterNames = jsonArrayParameterNames
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.ProgramShape.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.ProgramShape.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Statistics of a computation.
    final public class ComputationStats : GeneratedMessage {

        public static func == (lhs: Xla.ComputationStats, rhs: Xla.ComputationStats) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasFlopCount == rhs.hasFlopCount) && (!lhs.hasFlopCount || lhs.flopCount == rhs.flopCount)
            fieldCheck = fieldCheck && (lhs.hasTranscendentalCount == rhs.hasTranscendentalCount) && (!lhs.hasTranscendentalCount || lhs.transcendentalCount == rhs.transcendentalCount)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// The number of floating point operations in the computation.
        public fileprivate(set) var flopCount:Double = Double(0)
        public fileprivate(set) var hasFlopCount:Bool = false

        /// The number of transcendental operations (e.g., exp) in the computation.
        public fileprivate(set) var transcendentalCount:Double = Double(0)
        public fileprivate(set) var hasTranscendentalCount:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasFlopCount {
                try codedOutputStream.writeDouble(fieldNumber: 1, value:flopCount)
            }
            if hasTranscendentalCount {
                try codedOutputStream.writeDouble(fieldNumber: 2, value:transcendentalCount)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasFlopCount {
                serialize_size += flopCount.computeDoubleSize(fieldNumber: 1)
            }
            if hasTranscendentalCount {
                serialize_size += transcendentalCount.computeDoubleSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.ComputationStats.Builder {
            return Xla.ComputationStats.classBuilder() as! Xla.ComputationStats.Builder
        }
        public func getBuilder() -> Xla.ComputationStats.Builder {
            return classBuilder() as! Xla.ComputationStats.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ComputationStats.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ComputationStats.Builder()
        }
        public func toBuilder() throws -> Xla.ComputationStats.Builder {
            return try Xla.ComputationStats.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.ComputationStats) throws -> Xla.ComputationStats.Builder {
            return try Xla.ComputationStats.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasFlopCount {
                jsonMap["flopCount"] = Double(flopCount)
            }
            if hasTranscendentalCount {
                jsonMap["transcendentalCount"] = Double(transcendentalCount)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.ComputationStats {
            return try Xla.ComputationStats.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.ComputationStats {
            return try Xla.ComputationStats.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasFlopCount {
                output += "\(indent) flopCount: \(flopCount) \n"
            }
            if hasTranscendentalCount {
                output += "\(indent) transcendentalCount: \(transcendentalCount) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasFlopCount {
                    hashCode = (hashCode &* 31) &+ flopCount.hashValue
                }
                if hasTranscendentalCount {
                    hashCode = (hashCode &* 31) &+ transcendentalCount.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.ComputationStats"
        }
        override public func className() -> String {
            return "Xla.ComputationStats"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.ComputationStats = Xla.ComputationStats()
            public func getMessage() -> Xla.ComputationStats {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The number of floating point operations in the computation.
            public var flopCount:Double {
                get {
                    return builderResult.flopCount
                }
                set (value) {
                    builderResult.hasFlopCount = true
                    builderResult.flopCount = value
                }
            }
            public var hasFlopCount:Bool {
                get {
                    return builderResult.hasFlopCount
                }
            }
            @discardableResult
            public func setFlopCount(_ value:Double) -> Xla.ComputationStats.Builder {
                self.flopCount = value
                return self
            }
            @discardableResult
            public func clearFlopCount() -> Xla.ComputationStats.Builder{
                builderResult.hasFlopCount = false
                builderResult.flopCount = Double(0)
                return self
            }
            /// The number of transcendental operations (e.g., exp) in the computation.
            public var transcendentalCount:Double {
                get {
                    return builderResult.transcendentalCount
                }
                set (value) {
                    builderResult.hasTranscendentalCount = true
                    builderResult.transcendentalCount = value
                }
            }
            public var hasTranscendentalCount:Bool {
                get {
                    return builderResult.hasTranscendentalCount
                }
            }
            @discardableResult
            public func setTranscendentalCount(_ value:Double) -> Xla.ComputationStats.Builder {
                self.transcendentalCount = value
                return self
            }
            @discardableResult
            public func clearTranscendentalCount() -> Xla.ComputationStats.Builder{
                builderResult.hasTranscendentalCount = false
                builderResult.transcendentalCount = Double(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.ComputationStats.Builder {
                builderResult = Xla.ComputationStats()
                return self
            }
            override public func clone() throws -> Xla.ComputationStats.Builder {
                return try Xla.ComputationStats.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.ComputationStats {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.ComputationStats {
                let returnMe:Xla.ComputationStats = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.ComputationStats) throws -> Xla.ComputationStats.Builder {
                if other == Xla.ComputationStats() {
                    return self
                }
                if other.hasFlopCount {
                    flopCount = other.flopCount
                }
                if other.hasTranscendentalCount {
                    transcendentalCount = other.transcendentalCount
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.ComputationStats.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputationStats.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 9:
                        flopCount = try codedInputStream.readDouble()

                    case 17:
                        transcendentalCount = try codedInputStream.readDouble()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.ComputationStats.Builder {
                let resultDecodedBuilder = Xla.ComputationStats.Builder()
                if let jsonValueFlopCount = jsonMap["flopCount"] as? Double {
                    resultDecodedBuilder.flopCount = Double(jsonValueFlopCount)
                } else if let jsonValueFlopCount = jsonMap["flopCount"] as? String {
                    resultDecodedBuilder.flopCount = Double(jsonValueFlopCount)!
                }
                if let jsonValueTranscendentalCount = jsonMap["transcendentalCount"] as? Double {
                    resultDecodedBuilder.transcendentalCount = Double(jsonValueTranscendentalCount)
                } else if let jsonValueTranscendentalCount = jsonMap["transcendentalCount"] as? String {
                    resultDecodedBuilder.transcendentalCount = Double(jsonValueTranscendentalCount)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.ComputationStats.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.ComputationStats.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Symbolization metadata for HLO Instructions.
    /// This metadata is used for debugging XLA code generation, as well as
    /// performance profiling of XLA-generated executables.
    final public class OpMetadata : GeneratedMessage {

        public static func == (lhs: Xla.OpMetadata, rhs: Xla.OpMetadata) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasOpType == rhs.hasOpType) && (!lhs.hasOpType || lhs.opType == rhs.opType)
            fieldCheck = fieldCheck && (lhs.hasOpName == rhs.hasOpName) && (!lhs.hasOpName || lhs.opName == rhs.opName)
            fieldCheck = fieldCheck && (lhs.hasSourceFile == rhs.hasSourceFile) && (!lhs.hasSourceFile || lhs.sourceFile == rhs.sourceFile)
            fieldCheck = fieldCheck && (lhs.hasSourceLine == rhs.hasSourceLine) && (!lhs.hasSourceLine || lhs.sourceLine == rhs.sourceLine)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// The framework op name that generated this XLA op.
        /// Frameworks that build on top of XLA should mirror the names of their ops
        /// back to users by specifying the op_type. In this way, even if the
        /// framework's "ops" are implemented as multiple XLA HLO Ops, they can be
        /// grouped appropriately. (e.g. if a SoftMax layer is emitted into XLA as
        /// multiple ops, then each op should have the op_type be "SoftMax".)
        public fileprivate(set) var opType:String = ""
        public fileprivate(set) var hasOpType:Bool = false

        /// The user-specified name of the op.
        /// This name is often unique within a computation. Note: some frameworks
        /// add auto-generated names if the user does not provide one.
        public fileprivate(set) var opName:String = ""
        public fileprivate(set) var hasOpName:Bool = false

        /// Indicate a file and line that this op is associated to in a user's program.
        /// e.g. it could be be the file and line of user code that generated the op.
        public fileprivate(set) var sourceFile:String = ""
        public fileprivate(set) var hasSourceFile:Bool = false

        public fileprivate(set) var sourceLine:Int32 = Int32(0)
        public fileprivate(set) var hasSourceLine:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasOpType {
                try codedOutputStream.writeString(fieldNumber: 1, value:opType)
            }
            if hasOpName {
                try codedOutputStream.writeString(fieldNumber: 2, value:opName)
            }
            if hasSourceFile {
                try codedOutputStream.writeString(fieldNumber: 3, value:sourceFile)
            }
            if hasSourceLine {
                try codedOutputStream.writeInt32(fieldNumber: 4, value:sourceLine)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasOpType {
                serialize_size += opType.computeStringSize(fieldNumber: 1)
            }
            if hasOpName {
                serialize_size += opName.computeStringSize(fieldNumber: 2)
            }
            if hasSourceFile {
                serialize_size += sourceFile.computeStringSize(fieldNumber: 3)
            }
            if hasSourceLine {
                serialize_size += sourceLine.computeInt32Size(fieldNumber: 4)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.OpMetadata.Builder {
            return Xla.OpMetadata.classBuilder() as! Xla.OpMetadata.Builder
        }
        public func getBuilder() -> Xla.OpMetadata.Builder {
            return classBuilder() as! Xla.OpMetadata.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.OpMetadata.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.OpMetadata.Builder()
        }
        public func toBuilder() throws -> Xla.OpMetadata.Builder {
            return try Xla.OpMetadata.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.OpMetadata) throws -> Xla.OpMetadata.Builder {
            return try Xla.OpMetadata.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasOpType {
                jsonMap["opType"] = opType
            }
            if hasOpName {
                jsonMap["opName"] = opName
            }
            if hasSourceFile {
                jsonMap["sourceFile"] = sourceFile
            }
            if hasSourceLine {
                jsonMap["sourceLine"] = Int(sourceLine)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.OpMetadata {
            return try Xla.OpMetadata.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.OpMetadata {
            return try Xla.OpMetadata.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasOpType {
                output += "\(indent) opType: \(opType) \n"
            }
            if hasOpName {
                output += "\(indent) opName: \(opName) \n"
            }
            if hasSourceFile {
                output += "\(indent) sourceFile: \(sourceFile) \n"
            }
            if hasSourceLine {
                output += "\(indent) sourceLine: \(sourceLine) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasOpType {
                    hashCode = (hashCode &* 31) &+ opType.hashValue
                }
                if hasOpName {
                    hashCode = (hashCode &* 31) &+ opName.hashValue
                }
                if hasSourceFile {
                    hashCode = (hashCode &* 31) &+ sourceFile.hashValue
                }
                if hasSourceLine {
                    hashCode = (hashCode &* 31) &+ sourceLine.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.OpMetadata"
        }
        override public func className() -> String {
            return "Xla.OpMetadata"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.OpMetadata = Xla.OpMetadata()
            public func getMessage() -> Xla.OpMetadata {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The framework op name that generated this XLA op.
            /// Frameworks that build on top of XLA should mirror the names of their ops
            /// back to users by specifying the op_type. In this way, even if the
            /// framework's "ops" are implemented as multiple XLA HLO Ops, they can be
            /// grouped appropriately. (e.g. if a SoftMax layer is emitted into XLA as
            /// multiple ops, then each op should have the op_type be "SoftMax".)
            public var opType:String {
                get {
                    return builderResult.opType
                }
                set (value) {
                    builderResult.hasOpType = true
                    builderResult.opType = value
                }
            }
            public var hasOpType:Bool {
                get {
                    return builderResult.hasOpType
                }
            }
            @discardableResult
            public func setOpType(_ value:String) -> Xla.OpMetadata.Builder {
                self.opType = value
                return self
            }
            @discardableResult
            public func clearOpType() -> Xla.OpMetadata.Builder{
                builderResult.hasOpType = false
                builderResult.opType = ""
                return self
            }
            /// The user-specified name of the op.
            /// This name is often unique within a computation. Note: some frameworks
            /// add auto-generated names if the user does not provide one.
            public var opName:String {
                get {
                    return builderResult.opName
                }
                set (value) {
                    builderResult.hasOpName = true
                    builderResult.opName = value
                }
            }
            public var hasOpName:Bool {
                get {
                    return builderResult.hasOpName
                }
            }
            @discardableResult
            public func setOpName(_ value:String) -> Xla.OpMetadata.Builder {
                self.opName = value
                return self
            }
            @discardableResult
            public func clearOpName() -> Xla.OpMetadata.Builder{
                builderResult.hasOpName = false
                builderResult.opName = ""
                return self
            }
            /// Indicate a file and line that this op is associated to in a user's program.
            /// e.g. it could be be the file and line of user code that generated the op.
            public var sourceFile:String {
                get {
                    return builderResult.sourceFile
                }
                set (value) {
                    builderResult.hasSourceFile = true
                    builderResult.sourceFile = value
                }
            }
            public var hasSourceFile:Bool {
                get {
                    return builderResult.hasSourceFile
                }
            }
            @discardableResult
            public func setSourceFile(_ value:String) -> Xla.OpMetadata.Builder {
                self.sourceFile = value
                return self
            }
            @discardableResult
            public func clearSourceFile() -> Xla.OpMetadata.Builder{
                builderResult.hasSourceFile = false
                builderResult.sourceFile = ""
                return self
            }
            public var sourceLine:Int32 {
                get {
                    return builderResult.sourceLine
                }
                set (value) {
                    builderResult.hasSourceLine = true
                    builderResult.sourceLine = value
                }
            }
            public var hasSourceLine:Bool {
                get {
                    return builderResult.hasSourceLine
                }
            }
            @discardableResult
            public func setSourceLine(_ value:Int32) -> Xla.OpMetadata.Builder {
                self.sourceLine = value
                return self
            }
            @discardableResult
            public func clearSourceLine() -> Xla.OpMetadata.Builder{
                builderResult.hasSourceLine = false
                builderResult.sourceLine = Int32(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.OpMetadata.Builder {
                builderResult = Xla.OpMetadata()
                return self
            }
            override public func clone() throws -> Xla.OpMetadata.Builder {
                return try Xla.OpMetadata.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.OpMetadata {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.OpMetadata {
                let returnMe:Xla.OpMetadata = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.OpMetadata) throws -> Xla.OpMetadata.Builder {
                if other == Xla.OpMetadata() {
                    return self
                }
                if other.hasOpType {
                    opType = other.opType
                }
                if other.hasOpName {
                    opName = other.opName
                }
                if other.hasSourceFile {
                    sourceFile = other.sourceFile
                }
                if other.hasSourceLine {
                    sourceLine = other.sourceLine
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.OpMetadata.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.OpMetadata.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        opType = try codedInputStream.readString()

                    case 18:
                        opName = try codedInputStream.readString()

                    case 26:
                        sourceFile = try codedInputStream.readString()

                    case 32:
                        sourceLine = try codedInputStream.readInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.OpMetadata.Builder {
                let resultDecodedBuilder = Xla.OpMetadata.Builder()
                if let jsonValueOpType = jsonMap["opType"] as? String {
                    resultDecodedBuilder.opType = jsonValueOpType
                }
                if let jsonValueOpName = jsonMap["opName"] as? String {
                    resultDecodedBuilder.opName = jsonValueOpName
                }
                if let jsonValueSourceFile = jsonMap["sourceFile"] as? String {
                    resultDecodedBuilder.sourceFile = jsonValueSourceFile
                }
                if let jsonValueSourceLine = jsonMap["sourceLine"] as? Int {
                    resultDecodedBuilder.sourceLine = Int32(jsonValueSourceLine)
                } else if let jsonValueSourceLine = jsonMap["sourceLine"] as? String {
                    resultDecodedBuilder.sourceLine = Int32(jsonValueSourceLine)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.OpMetadata.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.OpMetadata.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Profile data from the execution of a computation.
    final public class ExecutionProfile : GeneratedMessage {

        public static func == (lhs: Xla.ExecutionProfile, rhs: Xla.ExecutionProfile) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasCompilationCacheHit == rhs.hasCompilationCacheHit) && (!lhs.hasCompilationCacheHit || lhs.compilationCacheHit == rhs.compilationCacheHit)
            fieldCheck = fieldCheck && (lhs.hasCompileTimeMs == rhs.hasCompileTimeMs) && (!lhs.hasCompileTimeMs || lhs.compileTimeMs == rhs.compileTimeMs)
            fieldCheck = fieldCheck && (lhs.hasComputeCycleCount == rhs.hasComputeCycleCount) && (!lhs.hasComputeCycleCount || lhs.computeCycleCount == rhs.computeCycleCount)
            fieldCheck = fieldCheck && (lhs.hasComputeTimeNs == rhs.hasComputeTimeNs) && (!lhs.hasComputeTimeNs || lhs.computeTimeNs == rhs.computeTimeNs)
            fieldCheck = fieldCheck && (lhs.hasComputeAndTransferTimeNs == rhs.hasComputeAndTransferTimeNs) && (!lhs.hasComputeAndTransferTimeNs || lhs.computeAndTransferTimeNs == rhs.computeAndTransferTimeNs)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Whether the executable was read from the compilation cache.
        public fileprivate(set) var compilationCacheHit:Bool = false
        public fileprivate(set) var hasCompilationCacheHit:Bool = false

        /// The time in milliseconds spent to compile the computation. This only set if
        /// the executable was not read from the compilation cache
        /// (compilation_cache_hit == false).
        public fileprivate(set) var compileTimeMs:Int64 = Int64(0)
        public fileprivate(set) var hasCompileTimeMs:Bool = false

        /// The number of cycles spent for the computation. This does not include the
        /// time taken for the data transfers between the host and the device. This is
        /// a target-dependent field and only used for debugging purposes.
        public fileprivate(set) var computeCycleCount:Int64 = Int64(0)
        public fileprivate(set) var hasComputeCycleCount:Bool = false

        /// The time in nanoseconds spent for the computation, without data transfer.
        public fileprivate(set) var computeTimeNs:Int64 = Int64(0)
        public fileprivate(set) var hasComputeTimeNs:Bool = false

        /// The time in nanoseconds spent for the entire computation, including the
        /// result data transfer time. Current implementation does not spend any cycles
        /// for the input data transfer since the memory is initialized with the proper
        /// values before the execution.
        public fileprivate(set) var computeAndTransferTimeNs:Int64 = Int64(0)
        public fileprivate(set) var hasComputeAndTransferTimeNs:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasCompilationCacheHit {
                try codedOutputStream.writeBool(fieldNumber: 1, value:compilationCacheHit)
            }
            if hasCompileTimeMs {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:compileTimeMs)
            }
            if hasComputeCycleCount {
                try codedOutputStream.writeInt64(fieldNumber: 3, value:computeCycleCount)
            }
            if hasComputeTimeNs {
                try codedOutputStream.writeInt64(fieldNumber: 4, value:computeTimeNs)
            }
            if hasComputeAndTransferTimeNs {
                try codedOutputStream.writeInt64(fieldNumber: 5, value:computeAndTransferTimeNs)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasCompilationCacheHit {
                serialize_size += compilationCacheHit.computeBoolSize(fieldNumber: 1)
            }
            if hasCompileTimeMs {
                serialize_size += compileTimeMs.computeInt64Size(fieldNumber: 2)
            }
            if hasComputeCycleCount {
                serialize_size += computeCycleCount.computeInt64Size(fieldNumber: 3)
            }
            if hasComputeTimeNs {
                serialize_size += computeTimeNs.computeInt64Size(fieldNumber: 4)
            }
            if hasComputeAndTransferTimeNs {
                serialize_size += computeAndTransferTimeNs.computeInt64Size(fieldNumber: 5)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.ExecutionProfile.Builder {
            return Xla.ExecutionProfile.classBuilder() as! Xla.ExecutionProfile.Builder
        }
        public func getBuilder() -> Xla.ExecutionProfile.Builder {
            return classBuilder() as! Xla.ExecutionProfile.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ExecutionProfile.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ExecutionProfile.Builder()
        }
        public func toBuilder() throws -> Xla.ExecutionProfile.Builder {
            return try Xla.ExecutionProfile.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.ExecutionProfile) throws -> Xla.ExecutionProfile.Builder {
            return try Xla.ExecutionProfile.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasCompilationCacheHit {
                jsonMap["compilationCacheHit"] = compilationCacheHit
            }
            if hasCompileTimeMs {
                jsonMap["compileTimeMs"] = "\(compileTimeMs)"
            }
            if hasComputeCycleCount {
                jsonMap["computeCycleCount"] = "\(computeCycleCount)"
            }
            if hasComputeTimeNs {
                jsonMap["computeTimeNs"] = "\(computeTimeNs)"
            }
            if hasComputeAndTransferTimeNs {
                jsonMap["computeAndTransferTimeNs"] = "\(computeAndTransferTimeNs)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.ExecutionProfile {
            return try Xla.ExecutionProfile.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.ExecutionProfile {
            return try Xla.ExecutionProfile.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasCompilationCacheHit {
                output += "\(indent) compilationCacheHit: \(compilationCacheHit) \n"
            }
            if hasCompileTimeMs {
                output += "\(indent) compileTimeMs: \(compileTimeMs) \n"
            }
            if hasComputeCycleCount {
                output += "\(indent) computeCycleCount: \(computeCycleCount) \n"
            }
            if hasComputeTimeNs {
                output += "\(indent) computeTimeNs: \(computeTimeNs) \n"
            }
            if hasComputeAndTransferTimeNs {
                output += "\(indent) computeAndTransferTimeNs: \(computeAndTransferTimeNs) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasCompilationCacheHit {
                    hashCode = (hashCode &* 31) &+ compilationCacheHit.hashValue
                }
                if hasCompileTimeMs {
                    hashCode = (hashCode &* 31) &+ compileTimeMs.hashValue
                }
                if hasComputeCycleCount {
                    hashCode = (hashCode &* 31) &+ computeCycleCount.hashValue
                }
                if hasComputeTimeNs {
                    hashCode = (hashCode &* 31) &+ computeTimeNs.hashValue
                }
                if hasComputeAndTransferTimeNs {
                    hashCode = (hashCode &* 31) &+ computeAndTransferTimeNs.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.ExecutionProfile"
        }
        override public func className() -> String {
            return "Xla.ExecutionProfile"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.ExecutionProfile = Xla.ExecutionProfile()
            public func getMessage() -> Xla.ExecutionProfile {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Whether the executable was read from the compilation cache.
            public var compilationCacheHit:Bool {
                get {
                    return builderResult.compilationCacheHit
                }
                set (value) {
                    builderResult.hasCompilationCacheHit = true
                    builderResult.compilationCacheHit = value
                }
            }
            public var hasCompilationCacheHit:Bool {
                get {
                    return builderResult.hasCompilationCacheHit
                }
            }
            @discardableResult
            public func setCompilationCacheHit(_ value:Bool) -> Xla.ExecutionProfile.Builder {
                self.compilationCacheHit = value
                return self
            }
            @discardableResult
            public func clearCompilationCacheHit() -> Xla.ExecutionProfile.Builder{
                builderResult.hasCompilationCacheHit = false
                builderResult.compilationCacheHit = false
                return self
            }
            /// The time in milliseconds spent to compile the computation. This only set if
            /// the executable was not read from the compilation cache
            /// (compilation_cache_hit == false).
            public var compileTimeMs:Int64 {
                get {
                    return builderResult.compileTimeMs
                }
                set (value) {
                    builderResult.hasCompileTimeMs = true
                    builderResult.compileTimeMs = value
                }
            }
            public var hasCompileTimeMs:Bool {
                get {
                    return builderResult.hasCompileTimeMs
                }
            }
            @discardableResult
            public func setCompileTimeMs(_ value:Int64) -> Xla.ExecutionProfile.Builder {
                self.compileTimeMs = value
                return self
            }
            @discardableResult
            public func clearCompileTimeMs() -> Xla.ExecutionProfile.Builder{
                builderResult.hasCompileTimeMs = false
                builderResult.compileTimeMs = Int64(0)
                return self
            }
            /// The number of cycles spent for the computation. This does not include the
            /// time taken for the data transfers between the host and the device. This is
            /// a target-dependent field and only used for debugging purposes.
            public var computeCycleCount:Int64 {
                get {
                    return builderResult.computeCycleCount
                }
                set (value) {
                    builderResult.hasComputeCycleCount = true
                    builderResult.computeCycleCount = value
                }
            }
            public var hasComputeCycleCount:Bool {
                get {
                    return builderResult.hasComputeCycleCount
                }
            }
            @discardableResult
            public func setComputeCycleCount(_ value:Int64) -> Xla.ExecutionProfile.Builder {
                self.computeCycleCount = value
                return self
            }
            @discardableResult
            public func clearComputeCycleCount() -> Xla.ExecutionProfile.Builder{
                builderResult.hasComputeCycleCount = false
                builderResult.computeCycleCount = Int64(0)
                return self
            }
            /// The time in nanoseconds spent for the computation, without data transfer.
            public var computeTimeNs:Int64 {
                get {
                    return builderResult.computeTimeNs
                }
                set (value) {
                    builderResult.hasComputeTimeNs = true
                    builderResult.computeTimeNs = value
                }
            }
            public var hasComputeTimeNs:Bool {
                get {
                    return builderResult.hasComputeTimeNs
                }
            }
            @discardableResult
            public func setComputeTimeNs(_ value:Int64) -> Xla.ExecutionProfile.Builder {
                self.computeTimeNs = value
                return self
            }
            @discardableResult
            public func clearComputeTimeNs() -> Xla.ExecutionProfile.Builder{
                builderResult.hasComputeTimeNs = false
                builderResult.computeTimeNs = Int64(0)
                return self
            }
            /// The time in nanoseconds spent for the entire computation, including the
            /// result data transfer time. Current implementation does not spend any cycles
            /// for the input data transfer since the memory is initialized with the proper
            /// values before the execution.
            public var computeAndTransferTimeNs:Int64 {
                get {
                    return builderResult.computeAndTransferTimeNs
                }
                set (value) {
                    builderResult.hasComputeAndTransferTimeNs = true
                    builderResult.computeAndTransferTimeNs = value
                }
            }
            public var hasComputeAndTransferTimeNs:Bool {
                get {
                    return builderResult.hasComputeAndTransferTimeNs
                }
            }
            @discardableResult
            public func setComputeAndTransferTimeNs(_ value:Int64) -> Xla.ExecutionProfile.Builder {
                self.computeAndTransferTimeNs = value
                return self
            }
            @discardableResult
            public func clearComputeAndTransferTimeNs() -> Xla.ExecutionProfile.Builder{
                builderResult.hasComputeAndTransferTimeNs = false
                builderResult.computeAndTransferTimeNs = Int64(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.ExecutionProfile.Builder {
                builderResult = Xla.ExecutionProfile()
                return self
            }
            override public func clone() throws -> Xla.ExecutionProfile.Builder {
                return try Xla.ExecutionProfile.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.ExecutionProfile {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.ExecutionProfile {
                let returnMe:Xla.ExecutionProfile = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.ExecutionProfile) throws -> Xla.ExecutionProfile.Builder {
                if other == Xla.ExecutionProfile() {
                    return self
                }
                if other.hasCompilationCacheHit {
                    compilationCacheHit = other.compilationCacheHit
                }
                if other.hasCompileTimeMs {
                    compileTimeMs = other.compileTimeMs
                }
                if other.hasComputeCycleCount {
                    computeCycleCount = other.computeCycleCount
                }
                if other.hasComputeTimeNs {
                    computeTimeNs = other.computeTimeNs
                }
                if other.hasComputeAndTransferTimeNs {
                    computeAndTransferTimeNs = other.computeAndTransferTimeNs
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.ExecutionProfile.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecutionProfile.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        compilationCacheHit = try codedInputStream.readBool()

                    case 16:
                        compileTimeMs = try codedInputStream.readInt64()

                    case 24:
                        computeCycleCount = try codedInputStream.readInt64()

                    case 32:
                        computeTimeNs = try codedInputStream.readInt64()

                    case 40:
                        computeAndTransferTimeNs = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.ExecutionProfile.Builder {
                let resultDecodedBuilder = Xla.ExecutionProfile.Builder()
                if let jsonValueCompilationCacheHit = jsonMap["compilationCacheHit"] as? Bool {
                    resultDecodedBuilder.compilationCacheHit = jsonValueCompilationCacheHit
                }
                if let jsonValueCompileTimeMs = jsonMap["compileTimeMs"] as? String {
                    resultDecodedBuilder.compileTimeMs = Int64(jsonValueCompileTimeMs)!
                } else if let jsonValueCompileTimeMs = jsonMap["compileTimeMs"] as? Int {
                    resultDecodedBuilder.compileTimeMs = Int64(jsonValueCompileTimeMs)
                }
                if let jsonValueComputeCycleCount = jsonMap["computeCycleCount"] as? String {
                    resultDecodedBuilder.computeCycleCount = Int64(jsonValueComputeCycleCount)!
                } else if let jsonValueComputeCycleCount = jsonMap["computeCycleCount"] as? Int {
                    resultDecodedBuilder.computeCycleCount = Int64(jsonValueComputeCycleCount)
                }
                if let jsonValueComputeTimeNs = jsonMap["computeTimeNs"] as? String {
                    resultDecodedBuilder.computeTimeNs = Int64(jsonValueComputeTimeNs)!
                } else if let jsonValueComputeTimeNs = jsonMap["computeTimeNs"] as? Int {
                    resultDecodedBuilder.computeTimeNs = Int64(jsonValueComputeTimeNs)
                }
                if let jsonValueComputeAndTransferTimeNs = jsonMap["computeAndTransferTimeNs"] as? String {
                    resultDecodedBuilder.computeAndTransferTimeNs = Int64(jsonValueComputeAndTransferTimeNs)!
                } else if let jsonValueComputeAndTransferTimeNs = jsonMap["computeAndTransferTimeNs"] as? Int {
                    resultDecodedBuilder.computeAndTransferTimeNs = Int64(jsonValueComputeAndTransferTimeNs)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.ExecutionProfile.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.ExecutionProfile.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Handle given to a user that represents a computation that the user builds up
    /// before execution.
    final public class ComputationHandle : GeneratedMessage {

        public static func == (lhs: Xla.ComputationHandle, rhs: Xla.ComputationHandle) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasHandle == rhs.hasHandle) && (!lhs.hasHandle || lhs.handle == rhs.handle)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var handle:Int64 = Int64(0)
        public fileprivate(set) var hasHandle:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasHandle {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:handle)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasHandle {
                serialize_size += handle.computeInt64Size(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.ComputationHandle.Builder {
            return Xla.ComputationHandle.classBuilder() as! Xla.ComputationHandle.Builder
        }
        public func getBuilder() -> Xla.ComputationHandle.Builder {
            return classBuilder() as! Xla.ComputationHandle.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ComputationHandle.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ComputationHandle.Builder()
        }
        public func toBuilder() throws -> Xla.ComputationHandle.Builder {
            return try Xla.ComputationHandle.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.ComputationHandle) throws -> Xla.ComputationHandle.Builder {
            return try Xla.ComputationHandle.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasHandle {
                jsonMap["handle"] = "\(handle)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.ComputationHandle {
            return try Xla.ComputationHandle.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.ComputationHandle {
            return try Xla.ComputationHandle.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasHandle {
                output += "\(indent) handle: \(handle) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasHandle {
                    hashCode = (hashCode &* 31) &+ handle.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.ComputationHandle"
        }
        override public func className() -> String {
            return "Xla.ComputationHandle"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.ComputationHandle = Xla.ComputationHandle()
            public func getMessage() -> Xla.ComputationHandle {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var handle:Int64 {
                get {
                    return builderResult.handle
                }
                set (value) {
                    builderResult.hasHandle = true
                    builderResult.handle = value
                }
            }
            public var hasHandle:Bool {
                get {
                    return builderResult.hasHandle
                }
            }
            @discardableResult
            public func setHandle(_ value:Int64) -> Xla.ComputationHandle.Builder {
                self.handle = value
                return self
            }
            @discardableResult
            public func clearHandle() -> Xla.ComputationHandle.Builder{
                builderResult.hasHandle = false
                builderResult.handle = Int64(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.ComputationHandle.Builder {
                builderResult = Xla.ComputationHandle()
                return self
            }
            override public func clone() throws -> Xla.ComputationHandle.Builder {
                return try Xla.ComputationHandle.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.ComputationHandle {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.ComputationHandle {
                let returnMe:Xla.ComputationHandle = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.ComputationHandle) throws -> Xla.ComputationHandle.Builder {
                if other == Xla.ComputationHandle() {
                    return self
                }
                if other.hasHandle {
                    handle = other.handle
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.ComputationHandle.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputationHandle.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        handle = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.ComputationHandle.Builder {
                let resultDecodedBuilder = Xla.ComputationHandle.Builder()
                if let jsonValueHandle = jsonMap["handle"] as? String {
                    resultDecodedBuilder.handle = Int64(jsonValueHandle)!
                } else if let jsonValueHandle = jsonMap["handle"] as? Int {
                    resultDecodedBuilder.handle = Int64(jsonValueHandle)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.ComputationHandle.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.ComputationHandle.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Handle given to a user that represents an execution that the user launched
    /// asynchronously on the device.
    final public class ExecutionHandle : GeneratedMessage {

        public static func == (lhs: Xla.ExecutionHandle, rhs: Xla.ExecutionHandle) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasHandle == rhs.hasHandle) && (!lhs.hasHandle || lhs.handle == rhs.handle)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var handle:Int64 = Int64(0)
        public fileprivate(set) var hasHandle:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasHandle {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:handle)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasHandle {
                serialize_size += handle.computeInt64Size(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.ExecutionHandle.Builder {
            return Xla.ExecutionHandle.classBuilder() as! Xla.ExecutionHandle.Builder
        }
        public func getBuilder() -> Xla.ExecutionHandle.Builder {
            return classBuilder() as! Xla.ExecutionHandle.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ExecutionHandle.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ExecutionHandle.Builder()
        }
        public func toBuilder() throws -> Xla.ExecutionHandle.Builder {
            return try Xla.ExecutionHandle.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.ExecutionHandle) throws -> Xla.ExecutionHandle.Builder {
            return try Xla.ExecutionHandle.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasHandle {
                jsonMap["handle"] = "\(handle)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.ExecutionHandle {
            return try Xla.ExecutionHandle.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.ExecutionHandle {
            return try Xla.ExecutionHandle.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasHandle {
                output += "\(indent) handle: \(handle) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasHandle {
                    hashCode = (hashCode &* 31) &+ handle.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.ExecutionHandle"
        }
        override public func className() -> String {
            return "Xla.ExecutionHandle"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.ExecutionHandle = Xla.ExecutionHandle()
            public func getMessage() -> Xla.ExecutionHandle {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var handle:Int64 {
                get {
                    return builderResult.handle
                }
                set (value) {
                    builderResult.hasHandle = true
                    builderResult.handle = value
                }
            }
            public var hasHandle:Bool {
                get {
                    return builderResult.hasHandle
                }
            }
            @discardableResult
            public func setHandle(_ value:Int64) -> Xla.ExecutionHandle.Builder {
                self.handle = value
                return self
            }
            @discardableResult
            public func clearHandle() -> Xla.ExecutionHandle.Builder{
                builderResult.hasHandle = false
                builderResult.handle = Int64(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.ExecutionHandle.Builder {
                builderResult = Xla.ExecutionHandle()
                return self
            }
            override public func clone() throws -> Xla.ExecutionHandle.Builder {
                return try Xla.ExecutionHandle.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.ExecutionHandle {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.ExecutionHandle {
                let returnMe:Xla.ExecutionHandle = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.ExecutionHandle) throws -> Xla.ExecutionHandle.Builder {
                if other == Xla.ExecutionHandle() {
                    return self
                }
                if other.hasHandle {
                    handle = other.handle
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.ExecutionHandle.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecutionHandle.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        handle = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.ExecutionHandle.Builder {
                let resultDecodedBuilder = Xla.ExecutionHandle.Builder()
                if let jsonValueHandle = jsonMap["handle"] as? String {
                    resultDecodedBuilder.handle = Int64(jsonValueHandle)!
                } else if let jsonValueHandle = jsonMap["handle"] as? Int {
                    resultDecodedBuilder.handle = Int64(jsonValueHandle)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.ExecutionHandle.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.ExecutionHandle.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Handle given to a user that represents a globally accessible allocation.
    /// Contrast this against a ComputationDataHandle, which is not globally
    /// accessible, since it only exists within a specific computation.
    final public class GlobalDataHandle : GeneratedMessage {

        public static func == (lhs: Xla.GlobalDataHandle, rhs: Xla.GlobalDataHandle) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasHandle == rhs.hasHandle) && (!lhs.hasHandle || lhs.handle == rhs.handle)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var handle:Int64 = Int64(0)
        public fileprivate(set) var hasHandle:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasHandle {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:handle)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasHandle {
                serialize_size += handle.computeInt64Size(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.GlobalDataHandle.Builder {
            return Xla.GlobalDataHandle.classBuilder() as! Xla.GlobalDataHandle.Builder
        }
        public func getBuilder() -> Xla.GlobalDataHandle.Builder {
            return classBuilder() as! Xla.GlobalDataHandle.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.GlobalDataHandle.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.GlobalDataHandle.Builder()
        }
        public func toBuilder() throws -> Xla.GlobalDataHandle.Builder {
            return try Xla.GlobalDataHandle.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.GlobalDataHandle) throws -> Xla.GlobalDataHandle.Builder {
            return try Xla.GlobalDataHandle.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasHandle {
                jsonMap["handle"] = "\(handle)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.GlobalDataHandle {
            return try Xla.GlobalDataHandle.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.GlobalDataHandle {
            return try Xla.GlobalDataHandle.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasHandle {
                output += "\(indent) handle: \(handle) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasHandle {
                    hashCode = (hashCode &* 31) &+ handle.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.GlobalDataHandle"
        }
        override public func className() -> String {
            return "Xla.GlobalDataHandle"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.GlobalDataHandle = Xla.GlobalDataHandle()
            public func getMessage() -> Xla.GlobalDataHandle {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var handle:Int64 {
                get {
                    return builderResult.handle
                }
                set (value) {
                    builderResult.hasHandle = true
                    builderResult.handle = value
                }
            }
            public var hasHandle:Bool {
                get {
                    return builderResult.hasHandle
                }
            }
            @discardableResult
            public func setHandle(_ value:Int64) -> Xla.GlobalDataHandle.Builder {
                self.handle = value
                return self
            }
            @discardableResult
            public func clearHandle() -> Xla.GlobalDataHandle.Builder{
                builderResult.hasHandle = false
                builderResult.handle = Int64(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.GlobalDataHandle.Builder {
                builderResult = Xla.GlobalDataHandle()
                return self
            }
            override public func clone() throws -> Xla.GlobalDataHandle.Builder {
                return try Xla.GlobalDataHandle.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.GlobalDataHandle {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.GlobalDataHandle {
                let returnMe:Xla.GlobalDataHandle = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.GlobalDataHandle) throws -> Xla.GlobalDataHandle.Builder {
                if other == Xla.GlobalDataHandle() {
                    return self
                }
                if other.hasHandle {
                    handle = other.handle
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.GlobalDataHandle.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.GlobalDataHandle.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        handle = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.GlobalDataHandle.Builder {
                let resultDecodedBuilder = Xla.GlobalDataHandle.Builder()
                if let jsonValueHandle = jsonMap["handle"] as? String {
                    resultDecodedBuilder.handle = Int64(jsonValueHandle)!
                } else if let jsonValueHandle = jsonMap["handle"] as? Int {
                    resultDecodedBuilder.handle = Int64(jsonValueHandle)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.GlobalDataHandle.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.GlobalDataHandle.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Handle given to a user that represents a data result in a computation.
    /// This is used to pass to subsequent computations that depends upon the data as
    /// an operand.
    final public class ComputationDataHandle : GeneratedMessage {

        public static func == (lhs: Xla.ComputationDataHandle, rhs: Xla.ComputationDataHandle) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasHandle == rhs.hasHandle) && (!lhs.hasHandle || lhs.handle == rhs.handle)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var handle:Int64 = Int64(0)
        public fileprivate(set) var hasHandle:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasHandle {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:handle)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasHandle {
                serialize_size += handle.computeInt64Size(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.ComputationDataHandle.Builder {
            return Xla.ComputationDataHandle.classBuilder() as! Xla.ComputationDataHandle.Builder
        }
        public func getBuilder() -> Xla.ComputationDataHandle.Builder {
            return classBuilder() as! Xla.ComputationDataHandle.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ComputationDataHandle.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ComputationDataHandle.Builder()
        }
        public func toBuilder() throws -> Xla.ComputationDataHandle.Builder {
            return try Xla.ComputationDataHandle.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.ComputationDataHandle) throws -> Xla.ComputationDataHandle.Builder {
            return try Xla.ComputationDataHandle.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasHandle {
                jsonMap["handle"] = "\(handle)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.ComputationDataHandle {
            return try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.ComputationDataHandle {
            return try Xla.ComputationDataHandle.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasHandle {
                output += "\(indent) handle: \(handle) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasHandle {
                    hashCode = (hashCode &* 31) &+ handle.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.ComputationDataHandle"
        }
        override public func className() -> String {
            return "Xla.ComputationDataHandle"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.ComputationDataHandle = Xla.ComputationDataHandle()
            public func getMessage() -> Xla.ComputationDataHandle {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var handle:Int64 {
                get {
                    return builderResult.handle
                }
                set (value) {
                    builderResult.hasHandle = true
                    builderResult.handle = value
                }
            }
            public var hasHandle:Bool {
                get {
                    return builderResult.hasHandle
                }
            }
            @discardableResult
            public func setHandle(_ value:Int64) -> Xla.ComputationDataHandle.Builder {
                self.handle = value
                return self
            }
            @discardableResult
            public func clearHandle() -> Xla.ComputationDataHandle.Builder{
                builderResult.hasHandle = false
                builderResult.handle = Int64(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.ComputationDataHandle.Builder {
                builderResult = Xla.ComputationDataHandle()
                return self
            }
            override public func clone() throws -> Xla.ComputationDataHandle.Builder {
                return try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.ComputationDataHandle {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.ComputationDataHandle {
                let returnMe:Xla.ComputationDataHandle = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.ComputationDataHandle) throws -> Xla.ComputationDataHandle.Builder {
                if other == Xla.ComputationDataHandle() {
                    return self
                }
                if other.hasHandle {
                    handle = other.handle
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.ComputationDataHandle.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputationDataHandle.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        handle = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.ComputationDataHandle.Builder {
                let resultDecodedBuilder = Xla.ComputationDataHandle.Builder()
                if let jsonValueHandle = jsonMap["handle"] as? String {
                    resultDecodedBuilder.handle = Int64(jsonValueHandle)!
                } else if let jsonValueHandle = jsonMap["handle"] as? Int {
                    resultDecodedBuilder.handle = Int64(jsonValueHandle)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.ComputationDataHandle.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Handle given to a user that represents a device to execute a computation.
    /// When replication is enabled, the device handle represents the device for the
    /// replica id 0.
    final public class DeviceHandle : GeneratedMessage {

        public static func == (lhs: Xla.DeviceHandle, rhs: Xla.DeviceHandle) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasHandle == rhs.hasHandle) && (!lhs.hasHandle || lhs.handle == rhs.handle)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var handle:Int64 = Int64(0)
        public fileprivate(set) var hasHandle:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasHandle {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:handle)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasHandle {
                serialize_size += handle.computeInt64Size(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.DeviceHandle.Builder {
            return Xla.DeviceHandle.classBuilder() as! Xla.DeviceHandle.Builder
        }
        public func getBuilder() -> Xla.DeviceHandle.Builder {
            return classBuilder() as! Xla.DeviceHandle.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.DeviceHandle.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.DeviceHandle.Builder()
        }
        public func toBuilder() throws -> Xla.DeviceHandle.Builder {
            return try Xla.DeviceHandle.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.DeviceHandle) throws -> Xla.DeviceHandle.Builder {
            return try Xla.DeviceHandle.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasHandle {
                jsonMap["handle"] = "\(handle)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.DeviceHandle {
            return try Xla.DeviceHandle.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.DeviceHandle {
            return try Xla.DeviceHandle.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasHandle {
                output += "\(indent) handle: \(handle) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasHandle {
                    hashCode = (hashCode &* 31) &+ handle.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.DeviceHandle"
        }
        override public func className() -> String {
            return "Xla.DeviceHandle"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.DeviceHandle = Xla.DeviceHandle()
            public func getMessage() -> Xla.DeviceHandle {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var handle:Int64 {
                get {
                    return builderResult.handle
                }
                set (value) {
                    builderResult.hasHandle = true
                    builderResult.handle = value
                }
            }
            public var hasHandle:Bool {
                get {
                    return builderResult.hasHandle
                }
            }
            @discardableResult
            public func setHandle(_ value:Int64) -> Xla.DeviceHandle.Builder {
                self.handle = value
                return self
            }
            @discardableResult
            public func clearHandle() -> Xla.DeviceHandle.Builder{
                builderResult.hasHandle = false
                builderResult.handle = Int64(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.DeviceHandle.Builder {
                builderResult = Xla.DeviceHandle()
                return self
            }
            override public func clone() throws -> Xla.DeviceHandle.Builder {
                return try Xla.DeviceHandle.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.DeviceHandle {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.DeviceHandle {
                let returnMe:Xla.DeviceHandle = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.DeviceHandle) throws -> Xla.DeviceHandle.Builder {
                if other == Xla.DeviceHandle() {
                    return self
                }
                if other.hasHandle {
                    handle = other.handle
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.DeviceHandle.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.DeviceHandle.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        handle = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.DeviceHandle.Builder {
                let resultDecodedBuilder = Xla.DeviceHandle.Builder()
                if let jsonValueHandle = jsonMap["handle"] as? String {
                    resultDecodedBuilder.handle = Int64(jsonValueHandle)!
                } else if let jsonValueHandle = jsonMap["handle"] as? Int {
                    resultDecodedBuilder.handle = Int64(jsonValueHandle)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.DeviceHandle.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.DeviceHandle.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Handle given to a user to represent a channel between two computations
    /// via a Send and Recv instruction pair. Channels are unbuffered, so Send
    /// Send instructions will be blocked until the data is transferred.
    final public class ChannelHandle : GeneratedMessage {

        public static func == (lhs: Xla.ChannelHandle, rhs: Xla.ChannelHandle) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasHandle == rhs.hasHandle) && (!lhs.hasHandle || lhs.handle == rhs.handle)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var handle:Int64 = Int64(0)
        public fileprivate(set) var hasHandle:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasHandle {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:handle)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasHandle {
                serialize_size += handle.computeInt64Size(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.ChannelHandle.Builder {
            return Xla.ChannelHandle.classBuilder() as! Xla.ChannelHandle.Builder
        }
        public func getBuilder() -> Xla.ChannelHandle.Builder {
            return classBuilder() as! Xla.ChannelHandle.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ChannelHandle.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ChannelHandle.Builder()
        }
        public func toBuilder() throws -> Xla.ChannelHandle.Builder {
            return try Xla.ChannelHandle.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.ChannelHandle) throws -> Xla.ChannelHandle.Builder {
            return try Xla.ChannelHandle.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasHandle {
                jsonMap["handle"] = "\(handle)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.ChannelHandle {
            return try Xla.ChannelHandle.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.ChannelHandle {
            return try Xla.ChannelHandle.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasHandle {
                output += "\(indent) handle: \(handle) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasHandle {
                    hashCode = (hashCode &* 31) &+ handle.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.ChannelHandle"
        }
        override public func className() -> String {
            return "Xla.ChannelHandle"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.ChannelHandle = Xla.ChannelHandle()
            public func getMessage() -> Xla.ChannelHandle {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var handle:Int64 {
                get {
                    return builderResult.handle
                }
                set (value) {
                    builderResult.hasHandle = true
                    builderResult.handle = value
                }
            }
            public var hasHandle:Bool {
                get {
                    return builderResult.hasHandle
                }
            }
            @discardableResult
            public func setHandle(_ value:Int64) -> Xla.ChannelHandle.Builder {
                self.handle = value
                return self
            }
            @discardableResult
            public func clearHandle() -> Xla.ChannelHandle.Builder{
                builderResult.hasHandle = false
                builderResult.handle = Int64(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.ChannelHandle.Builder {
                builderResult = Xla.ChannelHandle()
                return self
            }
            override public func clone() throws -> Xla.ChannelHandle.Builder {
                return try Xla.ChannelHandle.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.ChannelHandle {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.ChannelHandle {
                let returnMe:Xla.ChannelHandle = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.ChannelHandle) throws -> Xla.ChannelHandle.Builder {
                if other == Xla.ChannelHandle() {
                    return self
                }
                if other.hasHandle {
                    handle = other.handle
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.ChannelHandle.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ChannelHandle.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        handle = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.ChannelHandle.Builder {
                let resultDecodedBuilder = Xla.ChannelHandle.Builder()
                if let jsonValueHandle = jsonMap["handle"] as? String {
                    resultDecodedBuilder.handle = Int64(jsonValueHandle)!
                } else if let jsonValueHandle = jsonMap["handle"] as? Int {
                    resultDecodedBuilder.handle = Int64(jsonValueHandle)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.ChannelHandle.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.ChannelHandle.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Literals are used when the server and client need to exchange materialized
    /// data / results. Literals are also used to describe constants used in
    /// computations.
    /// Transfers to/from the client are encoded in literal form, and the structure
    /// of the repeated fields is implied by the shape.
    final public class Literal : GeneratedMessage {

        public static func == (lhs: Xla.Literal, rhs: Xla.Literal) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasShape == rhs.hasShape) && (!lhs.hasShape || lhs.shape == rhs.shape)
            fieldCheck = fieldCheck && (lhs.preds == rhs.preds)
            fieldCheck = fieldCheck && (lhs.hasU8S == rhs.hasU8S) && (!lhs.hasU8S || lhs.u8S == rhs.u8S)
            fieldCheck = fieldCheck && (lhs.s32S == rhs.s32S)
            fieldCheck = fieldCheck && (lhs.s64S == rhs.s64S)
            fieldCheck = fieldCheck && (lhs.u32S == rhs.u32S)
            fieldCheck = fieldCheck && (lhs.u64S == rhs.u64S)
            fieldCheck = fieldCheck && (lhs.f32S == rhs.f32S)
            fieldCheck = fieldCheck && (lhs.f64S == rhs.f64S)
            fieldCheck = fieldCheck && (lhs.tupleLiterals == rhs.tupleLiterals)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var shape:Xla.Shape!
        public fileprivate(set) var hasShape:Bool = false
        public fileprivate(set) var preds:Array<Bool> = Array<Bool>()
        private var predsMemoizedSerializedSize:Int32 = -1
        public fileprivate(set) var u8S:Data = Data()
        public fileprivate(set) var hasU8S:Bool = false

        public fileprivate(set) var s32S:Array<Int32> = Array<Int32>()
        private var s32SMemoizedSerializedSize:Int32 = -1
        public fileprivate(set) var s64S:Array<Int64> = Array<Int64>()
        private var s64SMemoizedSerializedSize:Int32 = -1
        public fileprivate(set) var u32S:Array<UInt32> = Array<UInt32>()
        private var u32SMemoizedSerializedSize:Int32 = -1
        public fileprivate(set) var u64S:Array<UInt64> = Array<UInt64>()
        private var u64SMemoizedSerializedSize:Int32 = -1
        public fileprivate(set) var f32S:Array<Float> = Array<Float>()
        private var f32SMemoizedSerializedSize:Int32 = -1
        public fileprivate(set) var f64S:Array<Double> = Array<Double>()
        private var f64SMemoizedSerializedSize:Int32 = -1
        public fileprivate(set) var tupleLiterals:Array<Xla.Literal>  = Array<Xla.Literal>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasShape {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:shape)
            }
            if !preds.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 18)
                try codedOutputStream.writeRawVarint32(value: predsMemoizedSerializedSize)
                for oneValuepreds in preds {
                    try codedOutputStream.writeBoolNoTag(value: oneValuepreds)
                }
            }
            if hasU8S {
                try codedOutputStream.writeData(fieldNumber: 3, value:u8S)
            }
            if !s32S.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 34)
                try codedOutputStream.writeRawVarint32(value: s32SMemoizedSerializedSize)
                for oneValues32S in s32S {
                    try codedOutputStream.writeInt32NoTag(value: oneValues32S)
                }
            }
            if !s64S.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 42)
                try codedOutputStream.writeRawVarint32(value: s64SMemoizedSerializedSize)
                for oneValues64S in s64S {
                    try codedOutputStream.writeInt64NoTag(value: oneValues64S)
                }
            }
            if !u32S.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 50)
                try codedOutputStream.writeRawVarint32(value: u32SMemoizedSerializedSize)
                for oneValueu32S in u32S {
                    try codedOutputStream.writeUInt32NoTag(value: oneValueu32S)
                }
            }
            if !u64S.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 58)
                try codedOutputStream.writeRawVarint32(value: u64SMemoizedSerializedSize)
                for oneValueu64S in u64S {
                    try codedOutputStream.writeUInt64NoTag(value: oneValueu64S)
                }
            }
            if !f32S.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 66)
                try codedOutputStream.writeRawVarint32(value: f32SMemoizedSerializedSize)
                for oneValuef32S in f32S {
                    try codedOutputStream.writeFloatNoTag(value: oneValuef32S)
                }
            }
            if !f64S.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 74)
                try codedOutputStream.writeRawVarint32(value: f64SMemoizedSerializedSize)
                for oneValuef64S in f64S {
                    try codedOutputStream.writeDoubleNoTag(value: oneValuef64S)
                }
            }
            for oneElementTupleLiterals in tupleLiterals {
                  try codedOutputStream.writeMessage(fieldNumber: 10, value:oneElementTupleLiterals)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasShape {
                if let varSizeshape = shape?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeshape
                }
            }
            var dataSizePreds:Int32 = 0
            dataSizePreds = 1 * Int32(preds.count)
            serialize_size += dataSizePreds
            if !preds.isEmpty {
                serialize_size += 1
                serialize_size += dataSizePreds.computeInt32SizeNoTag()
            }
            predsMemoizedSerializedSize = dataSizePreds
            if hasU8S {
                serialize_size += u8S.computeDataSize(fieldNumber: 3)
            }
            var dataSizeS32S:Int32 = 0
            for oneValues32S in s32S {
                dataSizeS32S += oneValues32S.computeInt32SizeNoTag()
            }
            serialize_size += dataSizeS32S
            if !s32S.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeS32S.computeInt32SizeNoTag()
            }
            s32SMemoizedSerializedSize = dataSizeS32S
            var dataSizeS64S:Int32 = 0
            for oneValues64S in s64S {
                dataSizeS64S += oneValues64S.computeInt64SizeNoTag()
            }
            serialize_size += dataSizeS64S
            if !s64S.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeS64S.computeInt32SizeNoTag()
            }
            s64SMemoizedSerializedSize = dataSizeS64S
            var dataSizeU32S:Int32 = 0
            for oneValueu32S in u32S {
                dataSizeU32S += oneValueu32S.computeUInt32SizeNoTag()
            }
            serialize_size += dataSizeU32S
            if !u32S.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeU32S.computeInt32SizeNoTag()
            }
            u32SMemoizedSerializedSize = dataSizeU32S
            var dataSizeU64S:Int32 = 0
            for oneValueu64S in u64S {
                dataSizeU64S += oneValueu64S.computeUInt64SizeNoTag()
            }
            serialize_size += dataSizeU64S
            if !u64S.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeU64S.computeInt32SizeNoTag()
            }
            u64SMemoizedSerializedSize = dataSizeU64S
            var dataSizeF32S:Int32 = 0
            dataSizeF32S = 4 * Int32(f32S.count)
            serialize_size += dataSizeF32S
            if !f32S.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeF32S.computeInt32SizeNoTag()
            }
            f32SMemoizedSerializedSize = dataSizeF32S
            var dataSizeF64S:Int32 = 0
            dataSizeF64S = 8 * Int32(f64S.count)
            serialize_size += dataSizeF64S
            if !f64S.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeF64S.computeInt32SizeNoTag()
            }
            f64SMemoizedSerializedSize = dataSizeF64S
            for oneElementTupleLiterals in tupleLiterals {
                serialize_size += oneElementTupleLiterals.computeMessageSize(fieldNumber: 10)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.Literal.Builder {
            return Xla.Literal.classBuilder() as! Xla.Literal.Builder
        }
        public func getBuilder() -> Xla.Literal.Builder {
            return classBuilder() as! Xla.Literal.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.Literal.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.Literal.Builder()
        }
        public func toBuilder() throws -> Xla.Literal.Builder {
            return try Xla.Literal.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.Literal) throws -> Xla.Literal.Builder {
            return try Xla.Literal.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasShape {
                jsonMap["shape"] = try shape.encode()
            }
            if !preds.isEmpty {
                var jsonArrayPreds:Array<Bool> = []
                for oneValuePreds in preds {
                    jsonArrayPreds.append(oneValuePreds)
                }
                jsonMap["preds"] = jsonArrayPreds
            }
            if hasU8S {
                jsonMap["u8s"] = u8S.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            if !s32S.isEmpty {
                var jsonArrayS32S:Array<Int> = []
                for oneValueS32S in s32S {
                    jsonArrayS32S.append(Int(oneValueS32S))
                }
                jsonMap["s32s"] = jsonArrayS32S
            }
            if !s64S.isEmpty {
                var jsonArrayS64S:Array<String> = []
                for oneValueS64S in s64S {
                    jsonArrayS64S.append("\(oneValueS64S)")
                }
                jsonMap["s64s"] = jsonArrayS64S
            }
            if !u32S.isEmpty {
                var jsonArrayU32S:Array<UInt> = []
                for oneValueU32S in u32S {
                    jsonArrayU32S.append(UInt(oneValueU32S))
                }
                jsonMap["u32s"] = jsonArrayU32S
            }
            if !u64S.isEmpty {
                var jsonArrayU64S:Array<String> = []
                for oneValueU64S in u64S {
                    jsonArrayU64S.append("\(oneValueU64S)")
                }
                jsonMap["u64s"] = jsonArrayU64S
            }
            if !f32S.isEmpty {
                var jsonArrayF32S:Array<Float> = []
                for oneValueF32S in f32S {
                    jsonArrayF32S.append(Float(oneValueF32S))
                }
                jsonMap["f32s"] = jsonArrayF32S
            }
            if !f64S.isEmpty {
                var jsonArrayF64S:Array<Double> = []
                for oneValueF64S in f64S {
                    jsonArrayF64S.append(Double(oneValueF64S))
                }
                jsonMap["f64s"] = jsonArrayF64S
            }
            if !tupleLiterals.isEmpty {
                var jsonArrayTupleLiterals:Array<Dictionary<String,Any>> = []
                for oneValueTupleLiterals in tupleLiterals {
                    let ecodedMessageTupleLiterals = try oneValueTupleLiterals.encode()
                    jsonArrayTupleLiterals.append(ecodedMessageTupleLiterals)
                }
                jsonMap["tupleLiterals"] = jsonArrayTupleLiterals
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.Literal {
            return try Xla.Literal.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.Literal {
            return try Xla.Literal.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasShape {
                output += "\(indent) shape {\n"
                if let outDescShape = shape {
                    output += try outDescShape.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            var predsElementIndex:Int = 0
            for oneValuePreds in preds  {
                output += "\(indent) preds[\(predsElementIndex)]: \(oneValuePreds)\n"
                predsElementIndex += 1
            }
            if hasU8S {
                output += "\(indent) u8S: \(u8S) \n"
            }
            var s32SElementIndex:Int = 0
            for oneValueS32S in s32S  {
                output += "\(indent) s32S[\(s32SElementIndex)]: \(oneValueS32S)\n"
                s32SElementIndex += 1
            }
            var s64SElementIndex:Int = 0
            for oneValueS64S in s64S  {
                output += "\(indent) s64S[\(s64SElementIndex)]: \(oneValueS64S)\n"
                s64SElementIndex += 1
            }
            var u32SElementIndex:Int = 0
            for oneValueU32S in u32S  {
                output += "\(indent) u32S[\(u32SElementIndex)]: \(oneValueU32S)\n"
                u32SElementIndex += 1
            }
            var u64SElementIndex:Int = 0
            for oneValueU64S in u64S  {
                output += "\(indent) u64S[\(u64SElementIndex)]: \(oneValueU64S)\n"
                u64SElementIndex += 1
            }
            var f32SElementIndex:Int = 0
            for oneValueF32S in f32S  {
                output += "\(indent) f32S[\(f32SElementIndex)]: \(oneValueF32S)\n"
                f32SElementIndex += 1
            }
            var f64SElementIndex:Int = 0
            for oneValueF64S in f64S  {
                output += "\(indent) f64S[\(f64SElementIndex)]: \(oneValueF64S)\n"
                f64SElementIndex += 1
            }
            var tupleLiteralsElementIndex:Int = 0
            for oneElementTupleLiterals in tupleLiterals {
                output += "\(indent) tupleLiterals[\(tupleLiteralsElementIndex)] {\n"
                output += try oneElementTupleLiterals.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                tupleLiteralsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasShape {
                    if let hashValueshape = shape?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueshape
                    }
                }
                for oneValuePreds in preds {
                    hashCode = (hashCode &* 31) &+ oneValuePreds.hashValue
                }
                if hasU8S {
                    hashCode = (hashCode &* 31) &+ u8S.hashValue
                }
                for oneValueS32S in s32S {
                    hashCode = (hashCode &* 31) &+ oneValueS32S.hashValue
                }
                for oneValueS64S in s64S {
                    hashCode = (hashCode &* 31) &+ oneValueS64S.hashValue
                }
                for oneValueU32S in u32S {
                    hashCode = (hashCode &* 31) &+ oneValueU32S.hashValue
                }
                for oneValueU64S in u64S {
                    hashCode = (hashCode &* 31) &+ oneValueU64S.hashValue
                }
                for oneValueF32S in f32S {
                    hashCode = (hashCode &* 31) &+ oneValueF32S.hashValue
                }
                for oneValueF64S in f64S {
                    hashCode = (hashCode &* 31) &+ oneValueF64S.hashValue
                }
                for oneElementTupleLiterals in tupleLiterals {
                    hashCode = (hashCode &* 31) &+ oneElementTupleLiterals.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.Literal"
        }
        override public func className() -> String {
            return "Xla.Literal"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.Literal = Xla.Literal()
            public func getMessage() -> Xla.Literal {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var shape:Xla.Shape! {
                get {
                    if shapeBuilder_ != nil {
                        builderResult.shape = shapeBuilder_.getMessage()
                    }
                    return builderResult.shape
                }
                set (value) {
                    builderResult.hasShape = true
                    builderResult.shape = value
                }
            }
            public var hasShape:Bool {
                get {
                    return builderResult.hasShape
                }
            }
            fileprivate var shapeBuilder_:Xla.Shape.Builder! {
                didSet {
                    builderResult.hasShape = true
                }
            }
            public func getShapeBuilder() -> Xla.Shape.Builder {
                if shapeBuilder_ == nil {
                    shapeBuilder_ = Xla.Shape.Builder()
                    builderResult.shape = shapeBuilder_.getMessage()
                    if shape != nil {
                        try! shapeBuilder_.mergeFrom(other: shape)
                    }
                }
                return shapeBuilder_
            }
            @discardableResult
            public func setShape(_ value:Xla.Shape!) -> Xla.Literal.Builder {
                self.shape = value
                return self
            }
            @discardableResult
            public func mergeShape(value:Xla.Shape) throws -> Xla.Literal.Builder {
                if builderResult.hasShape {
                    builderResult.shape = try Xla.Shape.builderWithPrototype(prototype:builderResult.shape).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.shape = value
                }
                builderResult.hasShape = true
                return self
            }
            @discardableResult
            public func clearShape() -> Xla.Literal.Builder {
                shapeBuilder_ = nil
                builderResult.hasShape = false
                builderResult.shape = nil
                return self
            }
            public var preds:Array<Bool> {
                get {
                    return builderResult.preds
                }
                set (array) {
                    builderResult.preds = array
                }
            }
            @discardableResult
            public func setPreds(_ value:Array<Bool>) -> Xla.Literal.Builder {
                self.preds = value
                return self
            }
            @discardableResult
            public func clearPreds() -> Xla.Literal.Builder {
                builderResult.preds.removeAll(keepingCapacity: false)
                return self
            }
            public var u8S:Data {
                get {
                    return builderResult.u8S
                }
                set (value) {
                    builderResult.hasU8S = true
                    builderResult.u8S = value
                }
            }
            public var hasU8S:Bool {
                get {
                    return builderResult.hasU8S
                }
            }
            @discardableResult
            public func setU8S(_ value:Data) -> Xla.Literal.Builder {
                self.u8S = value
                return self
            }
            @discardableResult
            public func clearU8S() -> Xla.Literal.Builder{
                builderResult.hasU8S = false
                builderResult.u8S = Data()
                return self
            }
            public var s32S:Array<Int32> {
                get {
                    return builderResult.s32S
                }
                set (array) {
                    builderResult.s32S = array
                }
            }
            @discardableResult
            public func setS32S(_ value:Array<Int32>) -> Xla.Literal.Builder {
                self.s32S = value
                return self
            }
            @discardableResult
            public func clearS32S() -> Xla.Literal.Builder {
                builderResult.s32S.removeAll(keepingCapacity: false)
                return self
            }
            public var s64S:Array<Int64> {
                get {
                    return builderResult.s64S
                }
                set (array) {
                    builderResult.s64S = array
                }
            }
            @discardableResult
            public func setS64S(_ value:Array<Int64>) -> Xla.Literal.Builder {
                self.s64S = value
                return self
            }
            @discardableResult
            public func clearS64S() -> Xla.Literal.Builder {
                builderResult.s64S.removeAll(keepingCapacity: false)
                return self
            }
            public var u32S:Array<UInt32> {
                get {
                    return builderResult.u32S
                }
                set (array) {
                    builderResult.u32S = array
                }
            }
            @discardableResult
            public func setU32S(_ value:Array<UInt32>) -> Xla.Literal.Builder {
                self.u32S = value
                return self
            }
            @discardableResult
            public func clearU32S() -> Xla.Literal.Builder {
                builderResult.u32S.removeAll(keepingCapacity: false)
                return self
            }
            public var u64S:Array<UInt64> {
                get {
                    return builderResult.u64S
                }
                set (array) {
                    builderResult.u64S = array
                }
            }
            @discardableResult
            public func setU64S(_ value:Array<UInt64>) -> Xla.Literal.Builder {
                self.u64S = value
                return self
            }
            @discardableResult
            public func clearU64S() -> Xla.Literal.Builder {
                builderResult.u64S.removeAll(keepingCapacity: false)
                return self
            }
            public var f32S:Array<Float> {
                get {
                    return builderResult.f32S
                }
                set (array) {
                    builderResult.f32S = array
                }
            }
            @discardableResult
            public func setF32S(_ value:Array<Float>) -> Xla.Literal.Builder {
                self.f32S = value
                return self
            }
            @discardableResult
            public func clearF32S() -> Xla.Literal.Builder {
                builderResult.f32S.removeAll(keepingCapacity: false)
                return self
            }
            public var f64S:Array<Double> {
                get {
                    return builderResult.f64S
                }
                set (array) {
                    builderResult.f64S = array
                }
            }
            @discardableResult
            public func setF64S(_ value:Array<Double>) -> Xla.Literal.Builder {
                self.f64S = value
                return self
            }
            @discardableResult
            public func clearF64S() -> Xla.Literal.Builder {
                builderResult.f64S.removeAll(keepingCapacity: false)
                return self
            }
            public var tupleLiterals:Array<Xla.Literal> {
                get {
                    return builderResult.tupleLiterals
                }
                set (value) {
                    builderResult.tupleLiterals = value
                }
            }
            @discardableResult
            public func setTupleLiterals(_ value:Array<Xla.Literal>) -> Xla.Literal.Builder {
                self.tupleLiterals = value
                return self
            }
            @discardableResult
            public func clearTupleLiterals() -> Xla.Literal.Builder {
                builderResult.tupleLiterals.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.Literal.Builder {
                builderResult = Xla.Literal()
                return self
            }
            override public func clone() throws -> Xla.Literal.Builder {
                return try Xla.Literal.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.Literal {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.Literal {
                let returnMe:Xla.Literal = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.Literal) throws -> Xla.Literal.Builder {
                if other == Xla.Literal() {
                    return self
                }
                if (other.hasShape) {
                    try mergeShape(value: other.shape)
                }
                if !other.preds.isEmpty {
                    builderResult.preds += other.preds
                }
                if other.hasU8S {
                    u8S = other.u8S
                }
                if !other.s32S.isEmpty {
                    builderResult.s32S += other.s32S
                }
                if !other.s64S.isEmpty {
                    builderResult.s64S += other.s64S
                }
                if !other.u32S.isEmpty {
                    builderResult.u32S += other.u32S
                }
                if !other.u64S.isEmpty {
                    builderResult.u64S += other.u64S
                }
                if !other.f32S.isEmpty {
                    builderResult.f32S += other.f32S
                }
                if !other.f64S.isEmpty {
                    builderResult.f64S += other.f64S
                }
                if !other.tupleLiterals.isEmpty  {
                     builderResult.tupleLiterals += other.tupleLiterals
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.Literal.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.Literal.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.Shape.Builder = Xla.Shape.Builder()
                        if hasShape {
                            try subBuilder.mergeFrom(other: shape)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        shape = subBuilder.buildPartial()

                    case 18:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.preds.append(try codedInputStream.readBool())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 26:
                        u8S = try codedInputStream.readData()

                    case 34:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.s32S.append(try codedInputStream.readInt32())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 42:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.s64S.append(try codedInputStream.readInt64())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 50:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.u32S.append(try codedInputStream.readUInt32())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 58:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.u64S.append(try codedInputStream.readUInt64())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 66:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.f32S.append(try codedInputStream.readFloat())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 74:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.f64S.append(try codedInputStream.readDouble())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 82:
                        let subBuilder = Xla.Literal.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        tupleLiterals.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.Literal.Builder {
                let resultDecodedBuilder = Xla.Literal.Builder()
                if let jsonValueShape = jsonMap["shape"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.shape = try Xla.Shape.Builder.decodeToBuilder(jsonMap:jsonValueShape).build()

                }
                if let jsonValuePreds = jsonMap["preds"] as? Array<Bool> {
                    var jsonArrayPreds:Array<Bool> = []
                    for oneValuePreds in jsonValuePreds {
                        jsonArrayPreds.append(oneValuePreds)
                    }
                    resultDecodedBuilder.preds = jsonArrayPreds
                }
                if let jsonValueU8S = jsonMap["u8s"] as? String {
                    resultDecodedBuilder.u8S = Data(base64Encoded:jsonValueU8S, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                if let jsonValueS32S = jsonMap["s32s"] as? Array<Int> {
                    var jsonArrayS32S:Array<Int32> = []
                    for oneValueS32S in jsonValueS32S {
                        jsonArrayS32S.append(Int32(oneValueS32S))
                    }
                    resultDecodedBuilder.s32S = jsonArrayS32S
                }
                if let jsonValueS64S = jsonMap["s64s"] as? Array<String> {
                    var jsonArrayS64S:Array<Int64> = []
                    for oneValueS64S in jsonValueS64S {
                        jsonArrayS64S.append(Int64(oneValueS64S)!)
                    }
                    resultDecodedBuilder.s64S = jsonArrayS64S
                }
                if let jsonValueU32S = jsonMap["u32s"] as? Array<UInt> {
                    var jsonArrayU32S:Array<UInt32> = []
                    for oneValueU32S in jsonValueU32S {
                        jsonArrayU32S.append(UInt32(oneValueU32S))
                    }
                    resultDecodedBuilder.u32S = jsonArrayU32S
                }
                if let jsonValueU64S = jsonMap["u64s"] as? Array<String> {
                    var jsonArrayU64S:Array<UInt64> = []
                    for oneValueU64S in jsonValueU64S {
                        jsonArrayU64S.append(UInt64(oneValueU64S)!)
                    }
                    resultDecodedBuilder.u64S = jsonArrayU64S
                }
                if let jsonValueF32S = jsonMap["f32s"] as? Array<Float> {
                    var jsonArrayF32S:Array<Float> = []
                    for oneValueF32S in jsonValueF32S {
                        jsonArrayF32S.append(Float(oneValueF32S))
                    }
                    resultDecodedBuilder.f32S = jsonArrayF32S
                }
                if let jsonValueF64S = jsonMap["f64s"] as? Array<Double> {
                    var jsonArrayF64S:Array<Double> = []
                    for oneValueF64S in jsonValueF64S {
                        jsonArrayF64S.append(Double(oneValueF64S))
                    }
                    resultDecodedBuilder.f64S = jsonArrayF64S
                }
                if let jsonValueTupleLiterals = jsonMap["tupleLiterals"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayTupleLiterals:Array<Xla.Literal> = []
                    for oneValueTupleLiterals in jsonValueTupleLiterals {
                        let messageFromStringTupleLiterals = try Xla.Literal.Builder.decodeToBuilder(jsonMap:oneValueTupleLiterals).build()

                        jsonArrayTupleLiterals.append(messageFromStringTupleLiterals)
                    }
                    resultDecodedBuilder.tupleLiterals = jsonArrayTupleLiterals
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.Literal.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.Literal.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class WindowDimension : GeneratedMessage {

        public static func == (lhs: Xla.WindowDimension, rhs: Xla.WindowDimension) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasSize == rhs.hasSize) && (!lhs.hasSize || lhs.size == rhs.size)
            fieldCheck = fieldCheck && (lhs.hasStride == rhs.hasStride) && (!lhs.hasStride || lhs.stride == rhs.stride)
            fieldCheck = fieldCheck && (lhs.hasPaddingLow == rhs.hasPaddingLow) && (!lhs.hasPaddingLow || lhs.paddingLow == rhs.paddingLow)
            fieldCheck = fieldCheck && (lhs.hasPaddingHigh == rhs.hasPaddingHigh) && (!lhs.hasPaddingHigh || lhs.paddingHigh == rhs.paddingHigh)
            fieldCheck = fieldCheck && (lhs.hasWindowDilation == rhs.hasWindowDilation) && (!lhs.hasWindowDilation || lhs.windowDilation == rhs.windowDilation)
            fieldCheck = fieldCheck && (lhs.hasBaseDilation == rhs.hasBaseDilation) && (!lhs.hasBaseDilation || lhs.baseDilation == rhs.baseDilation)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// The size of the window in this dimension. For a rectangle, this would be
        /// the width or height.
        public fileprivate(set) var size:Int64 = Int64(0)
        public fileprivate(set) var hasSize:Bool = false

        /// The stride at which the window moves across the base area in this
        /// dimension. In other words, this is the spacing between different
        /// positions of the window in this dimension.
        public fileprivate(set) var stride:Int64 = Int64(0)
        public fileprivate(set) var hasStride:Bool = false

        /// If positive, means the amount of padding with zeroes to add to the base
        /// area at the low end of this dimension; if negative, its negative means the
        /// number of elements removed from the low end of this dimension. For example,
        /// in the horizontal dimension of a rectangle, this would be the number of
        /// zeroes to pad on the left, given that indices increase when going right.
        public fileprivate(set) var paddingLow:Int64 = Int64(0)
        public fileprivate(set) var hasPaddingLow:Bool = false

        /// As padding_low, but on the high end of this dimension. For
        /// example, in the horizontal dimension of a rectangle, this would
        /// be the number of zeroes to pad on the right, given that indices
        /// increase when going right.
        public fileprivate(set) var paddingHigh:Int64 = Int64(0)
        public fileprivate(set) var hasPaddingHigh:Bool = false

        /// Dilation factor of the sliding window in this dimension. A dilation factor
        /// of 1 means no dilation. window_dilation - 1 no-op entries ("holes") are
        /// implicitly placed between each kernel element. See documentation for
        /// convolution.
        public fileprivate(set) var windowDilation:Int64 = Int64(0)
        public fileprivate(set) var hasWindowDilation:Bool = false

        /// Dilation factor of the base area in this dimension. A dilation factor of 1
        /// means no dilation. base_dilation - 1 no-op entries ("holes") are implicitly
        /// placed between each base area element. See documentation for convolution.
        public fileprivate(set) var baseDilation:Int64 = Int64(0)
        public fileprivate(set) var hasBaseDilation:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasSize {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:size)
            }
            if hasStride {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:stride)
            }
            if hasPaddingLow {
                try codedOutputStream.writeInt64(fieldNumber: 3, value:paddingLow)
            }
            if hasPaddingHigh {
                try codedOutputStream.writeInt64(fieldNumber: 4, value:paddingHigh)
            }
            if hasWindowDilation {
                try codedOutputStream.writeInt64(fieldNumber: 5, value:windowDilation)
            }
            if hasBaseDilation {
                try codedOutputStream.writeInt64(fieldNumber: 6, value:baseDilation)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasSize {
                serialize_size += size.computeInt64Size(fieldNumber: 1)
            }
            if hasStride {
                serialize_size += stride.computeInt64Size(fieldNumber: 2)
            }
            if hasPaddingLow {
                serialize_size += paddingLow.computeInt64Size(fieldNumber: 3)
            }
            if hasPaddingHigh {
                serialize_size += paddingHigh.computeInt64Size(fieldNumber: 4)
            }
            if hasWindowDilation {
                serialize_size += windowDilation.computeInt64Size(fieldNumber: 5)
            }
            if hasBaseDilation {
                serialize_size += baseDilation.computeInt64Size(fieldNumber: 6)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.WindowDimension.Builder {
            return Xla.WindowDimension.classBuilder() as! Xla.WindowDimension.Builder
        }
        public func getBuilder() -> Xla.WindowDimension.Builder {
            return classBuilder() as! Xla.WindowDimension.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.WindowDimension.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.WindowDimension.Builder()
        }
        public func toBuilder() throws -> Xla.WindowDimension.Builder {
            return try Xla.WindowDimension.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.WindowDimension) throws -> Xla.WindowDimension.Builder {
            return try Xla.WindowDimension.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasSize {
                jsonMap["size"] = "\(size)"
            }
            if hasStride {
                jsonMap["stride"] = "\(stride)"
            }
            if hasPaddingLow {
                jsonMap["paddingLow"] = "\(paddingLow)"
            }
            if hasPaddingHigh {
                jsonMap["paddingHigh"] = "\(paddingHigh)"
            }
            if hasWindowDilation {
                jsonMap["windowDilation"] = "\(windowDilation)"
            }
            if hasBaseDilation {
                jsonMap["baseDilation"] = "\(baseDilation)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.WindowDimension {
            return try Xla.WindowDimension.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.WindowDimension {
            return try Xla.WindowDimension.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasSize {
                output += "\(indent) size: \(size) \n"
            }
            if hasStride {
                output += "\(indent) stride: \(stride) \n"
            }
            if hasPaddingLow {
                output += "\(indent) paddingLow: \(paddingLow) \n"
            }
            if hasPaddingHigh {
                output += "\(indent) paddingHigh: \(paddingHigh) \n"
            }
            if hasWindowDilation {
                output += "\(indent) windowDilation: \(windowDilation) \n"
            }
            if hasBaseDilation {
                output += "\(indent) baseDilation: \(baseDilation) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasSize {
                    hashCode = (hashCode &* 31) &+ size.hashValue
                }
                if hasStride {
                    hashCode = (hashCode &* 31) &+ stride.hashValue
                }
                if hasPaddingLow {
                    hashCode = (hashCode &* 31) &+ paddingLow.hashValue
                }
                if hasPaddingHigh {
                    hashCode = (hashCode &* 31) &+ paddingHigh.hashValue
                }
                if hasWindowDilation {
                    hashCode = (hashCode &* 31) &+ windowDilation.hashValue
                }
                if hasBaseDilation {
                    hashCode = (hashCode &* 31) &+ baseDilation.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.WindowDimension"
        }
        override public func className() -> String {
            return "Xla.WindowDimension"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.WindowDimension = Xla.WindowDimension()
            public func getMessage() -> Xla.WindowDimension {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The size of the window in this dimension. For a rectangle, this would be
            /// the width or height.
            public var size:Int64 {
                get {
                    return builderResult.size
                }
                set (value) {
                    builderResult.hasSize = true
                    builderResult.size = value
                }
            }
            public var hasSize:Bool {
                get {
                    return builderResult.hasSize
                }
            }
            @discardableResult
            public func setSize(_ value:Int64) -> Xla.WindowDimension.Builder {
                self.size = value
                return self
            }
            @discardableResult
            public func clearSize() -> Xla.WindowDimension.Builder{
                builderResult.hasSize = false
                builderResult.size = Int64(0)
                return self
            }
            /// The stride at which the window moves across the base area in this
            /// dimension. In other words, this is the spacing between different
            /// positions of the window in this dimension.
            public var stride:Int64 {
                get {
                    return builderResult.stride
                }
                set (value) {
                    builderResult.hasStride = true
                    builderResult.stride = value
                }
            }
            public var hasStride:Bool {
                get {
                    return builderResult.hasStride
                }
            }
            @discardableResult
            public func setStride(_ value:Int64) -> Xla.WindowDimension.Builder {
                self.stride = value
                return self
            }
            @discardableResult
            public func clearStride() -> Xla.WindowDimension.Builder{
                builderResult.hasStride = false
                builderResult.stride = Int64(0)
                return self
            }
            /// If positive, means the amount of padding with zeroes to add to the base
            /// area at the low end of this dimension; if negative, its negative means the
            /// number of elements removed from the low end of this dimension. For example,
            /// in the horizontal dimension of a rectangle, this would be the number of
            /// zeroes to pad on the left, given that indices increase when going right.
            public var paddingLow:Int64 {
                get {
                    return builderResult.paddingLow
                }
                set (value) {
                    builderResult.hasPaddingLow = true
                    builderResult.paddingLow = value
                }
            }
            public var hasPaddingLow:Bool {
                get {
                    return builderResult.hasPaddingLow
                }
            }
            @discardableResult
            public func setPaddingLow(_ value:Int64) -> Xla.WindowDimension.Builder {
                self.paddingLow = value
                return self
            }
            @discardableResult
            public func clearPaddingLow() -> Xla.WindowDimension.Builder{
                builderResult.hasPaddingLow = false
                builderResult.paddingLow = Int64(0)
                return self
            }
            /// As padding_low, but on the high end of this dimension. For
            /// example, in the horizontal dimension of a rectangle, this would
            /// be the number of zeroes to pad on the right, given that indices
            /// increase when going right.
            public var paddingHigh:Int64 {
                get {
                    return builderResult.paddingHigh
                }
                set (value) {
                    builderResult.hasPaddingHigh = true
                    builderResult.paddingHigh = value
                }
            }
            public var hasPaddingHigh:Bool {
                get {
                    return builderResult.hasPaddingHigh
                }
            }
            @discardableResult
            public func setPaddingHigh(_ value:Int64) -> Xla.WindowDimension.Builder {
                self.paddingHigh = value
                return self
            }
            @discardableResult
            public func clearPaddingHigh() -> Xla.WindowDimension.Builder{
                builderResult.hasPaddingHigh = false
                builderResult.paddingHigh = Int64(0)
                return self
            }
            /// Dilation factor of the sliding window in this dimension. A dilation factor
            /// of 1 means no dilation. window_dilation - 1 no-op entries ("holes") are
            /// implicitly placed between each kernel element. See documentation for
            /// convolution.
            public var windowDilation:Int64 {
                get {
                    return builderResult.windowDilation
                }
                set (value) {
                    builderResult.hasWindowDilation = true
                    builderResult.windowDilation = value
                }
            }
            public var hasWindowDilation:Bool {
                get {
                    return builderResult.hasWindowDilation
                }
            }
            @discardableResult
            public func setWindowDilation(_ value:Int64) -> Xla.WindowDimension.Builder {
                self.windowDilation = value
                return self
            }
            @discardableResult
            public func clearWindowDilation() -> Xla.WindowDimension.Builder{
                builderResult.hasWindowDilation = false
                builderResult.windowDilation = Int64(0)
                return self
            }
            /// Dilation factor of the base area in this dimension. A dilation factor of 1
            /// means no dilation. base_dilation - 1 no-op entries ("holes") are implicitly
            /// placed between each base area element. See documentation for convolution.
            public var baseDilation:Int64 {
                get {
                    return builderResult.baseDilation
                }
                set (value) {
                    builderResult.hasBaseDilation = true
                    builderResult.baseDilation = value
                }
            }
            public var hasBaseDilation:Bool {
                get {
                    return builderResult.hasBaseDilation
                }
            }
            @discardableResult
            public func setBaseDilation(_ value:Int64) -> Xla.WindowDimension.Builder {
                self.baseDilation = value
                return self
            }
            @discardableResult
            public func clearBaseDilation() -> Xla.WindowDimension.Builder{
                builderResult.hasBaseDilation = false
                builderResult.baseDilation = Int64(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.WindowDimension.Builder {
                builderResult = Xla.WindowDimension()
                return self
            }
            override public func clone() throws -> Xla.WindowDimension.Builder {
                return try Xla.WindowDimension.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.WindowDimension {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.WindowDimension {
                let returnMe:Xla.WindowDimension = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.WindowDimension) throws -> Xla.WindowDimension.Builder {
                if other == Xla.WindowDimension() {
                    return self
                }
                if other.hasSize {
                    size = other.size
                }
                if other.hasStride {
                    stride = other.stride
                }
                if other.hasPaddingLow {
                    paddingLow = other.paddingLow
                }
                if other.hasPaddingHigh {
                    paddingHigh = other.paddingHigh
                }
                if other.hasWindowDilation {
                    windowDilation = other.windowDilation
                }
                if other.hasBaseDilation {
                    baseDilation = other.baseDilation
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.WindowDimension.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.WindowDimension.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        size = try codedInputStream.readInt64()

                    case 16:
                        stride = try codedInputStream.readInt64()

                    case 24:
                        paddingLow = try codedInputStream.readInt64()

                    case 32:
                        paddingHigh = try codedInputStream.readInt64()

                    case 40:
                        windowDilation = try codedInputStream.readInt64()

                    case 48:
                        baseDilation = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.WindowDimension.Builder {
                let resultDecodedBuilder = Xla.WindowDimension.Builder()
                if let jsonValueSize = jsonMap["size"] as? String {
                    resultDecodedBuilder.size = Int64(jsonValueSize)!
                } else if let jsonValueSize = jsonMap["size"] as? Int {
                    resultDecodedBuilder.size = Int64(jsonValueSize)
                }
                if let jsonValueStride = jsonMap["stride"] as? String {
                    resultDecodedBuilder.stride = Int64(jsonValueStride)!
                } else if let jsonValueStride = jsonMap["stride"] as? Int {
                    resultDecodedBuilder.stride = Int64(jsonValueStride)
                }
                if let jsonValuePaddingLow = jsonMap["paddingLow"] as? String {
                    resultDecodedBuilder.paddingLow = Int64(jsonValuePaddingLow)!
                } else if let jsonValuePaddingLow = jsonMap["paddingLow"] as? Int {
                    resultDecodedBuilder.paddingLow = Int64(jsonValuePaddingLow)
                }
                if let jsonValuePaddingHigh = jsonMap["paddingHigh"] as? String {
                    resultDecodedBuilder.paddingHigh = Int64(jsonValuePaddingHigh)!
                } else if let jsonValuePaddingHigh = jsonMap["paddingHigh"] as? Int {
                    resultDecodedBuilder.paddingHigh = Int64(jsonValuePaddingHigh)
                }
                if let jsonValueWindowDilation = jsonMap["windowDilation"] as? String {
                    resultDecodedBuilder.windowDilation = Int64(jsonValueWindowDilation)!
                } else if let jsonValueWindowDilation = jsonMap["windowDilation"] as? Int {
                    resultDecodedBuilder.windowDilation = Int64(jsonValueWindowDilation)
                }
                if let jsonValueBaseDilation = jsonMap["baseDilation"] as? String {
                    resultDecodedBuilder.baseDilation = Int64(jsonValueBaseDilation)!
                } else if let jsonValueBaseDilation = jsonMap["baseDilation"] as? Int {
                    resultDecodedBuilder.baseDilation = Int64(jsonValueBaseDilation)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.WindowDimension.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.WindowDimension.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Describes the windowing in an operation such as convolution.
    /// The window is moved across a base area and for each position of the
    /// window a computation is performed. The field below describes the
    /// window and the movement of the window across a base area.
    final public class Window : GeneratedMessage {

        public static func == (lhs: Xla.Window, rhs: Xla.Window) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.dimensions == rhs.dimensions)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var dimensions:Array<Xla.WindowDimension>  = Array<Xla.WindowDimension>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementDimensions in dimensions {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementDimensions)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementDimensions in dimensions {
                serialize_size += oneElementDimensions.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.Window.Builder {
            return Xla.Window.classBuilder() as! Xla.Window.Builder
        }
        public func getBuilder() -> Xla.Window.Builder {
            return classBuilder() as! Xla.Window.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.Window.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.Window.Builder()
        }
        public func toBuilder() throws -> Xla.Window.Builder {
            return try Xla.Window.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.Window) throws -> Xla.Window.Builder {
            return try Xla.Window.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !dimensions.isEmpty {
                var jsonArrayDimensions:Array<Dictionary<String,Any>> = []
                for oneValueDimensions in dimensions {
                    let ecodedMessageDimensions = try oneValueDimensions.encode()
                    jsonArrayDimensions.append(ecodedMessageDimensions)
                }
                jsonMap["dimensions"] = jsonArrayDimensions
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.Window {
            return try Xla.Window.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.Window {
            return try Xla.Window.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var dimensionsElementIndex:Int = 0
            for oneElementDimensions in dimensions {
                output += "\(indent) dimensions[\(dimensionsElementIndex)] {\n"
                output += try oneElementDimensions.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                dimensionsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementDimensions in dimensions {
                    hashCode = (hashCode &* 31) &+ oneElementDimensions.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.Window"
        }
        override public func className() -> String {
            return "Xla.Window"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.Window = Xla.Window()
            public func getMessage() -> Xla.Window {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var dimensions:Array<Xla.WindowDimension> {
                get {
                    return builderResult.dimensions
                }
                set (value) {
                    builderResult.dimensions = value
                }
            }
            @discardableResult
            public func setDimensions(_ value:Array<Xla.WindowDimension>) -> Xla.Window.Builder {
                self.dimensions = value
                return self
            }
            @discardableResult
            public func clearDimensions() -> Xla.Window.Builder {
                builderResult.dimensions.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.Window.Builder {
                builderResult = Xla.Window()
                return self
            }
            override public func clone() throws -> Xla.Window.Builder {
                return try Xla.Window.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.Window {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.Window {
                let returnMe:Xla.Window = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.Window) throws -> Xla.Window.Builder {
                if other == Xla.Window() {
                    return self
                }
                if !other.dimensions.isEmpty  {
                     builderResult.dimensions += other.dimensions
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.Window.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.Window.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Xla.WindowDimension.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        dimensions.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.Window.Builder {
                let resultDecodedBuilder = Xla.Window.Builder()
                if let jsonValueDimensions = jsonMap["dimensions"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayDimensions:Array<Xla.WindowDimension> = []
                    for oneValueDimensions in jsonValueDimensions {
                        let messageFromStringDimensions = try Xla.WindowDimension.Builder.decodeToBuilder(jsonMap:oneValueDimensions).build()

                        jsonArrayDimensions.append(messageFromStringDimensions)
                    }
                    resultDecodedBuilder.dimensions = jsonArrayDimensions
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.Window.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.Window.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ConstantRequest : GeneratedMessage {

        public static func == (lhs: Xla.ConstantRequest, rhs: Xla.ConstantRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasLiteral == rhs.hasLiteral) && (!lhs.hasLiteral || lhs.literal == rhs.literal)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var literal:Xla.Literal!
        public fileprivate(set) var hasLiteral:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasLiteral {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:literal)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasLiteral {
                if let varSizeliteral = literal?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeliteral
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.ConstantRequest.Builder {
            return Xla.ConstantRequest.classBuilder() as! Xla.ConstantRequest.Builder
        }
        public func getBuilder() -> Xla.ConstantRequest.Builder {
            return classBuilder() as! Xla.ConstantRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ConstantRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ConstantRequest.Builder()
        }
        public func toBuilder() throws -> Xla.ConstantRequest.Builder {
            return try Xla.ConstantRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.ConstantRequest) throws -> Xla.ConstantRequest.Builder {
            return try Xla.ConstantRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasLiteral {
                jsonMap["literal"] = try literal.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.ConstantRequest {
            return try Xla.ConstantRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.ConstantRequest {
            return try Xla.ConstantRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasLiteral {
                output += "\(indent) literal {\n"
                if let outDescLiteral = literal {
                    output += try outDescLiteral.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasLiteral {
                    if let hashValueliteral = literal?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueliteral
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.ConstantRequest"
        }
        override public func className() -> String {
            return "Xla.ConstantRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.ConstantRequest = Xla.ConstantRequest()
            public func getMessage() -> Xla.ConstantRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var literal:Xla.Literal! {
                get {
                    if literalBuilder_ != nil {
                        builderResult.literal = literalBuilder_.getMessage()
                    }
                    return builderResult.literal
                }
                set (value) {
                    builderResult.hasLiteral = true
                    builderResult.literal = value
                }
            }
            public var hasLiteral:Bool {
                get {
                    return builderResult.hasLiteral
                }
            }
            fileprivate var literalBuilder_:Xla.Literal.Builder! {
                didSet {
                    builderResult.hasLiteral = true
                }
            }
            public func getLiteralBuilder() -> Xla.Literal.Builder {
                if literalBuilder_ == nil {
                    literalBuilder_ = Xla.Literal.Builder()
                    builderResult.literal = literalBuilder_.getMessage()
                    if literal != nil {
                        try! literalBuilder_.mergeFrom(other: literal)
                    }
                }
                return literalBuilder_
            }
            @discardableResult
            public func setLiteral(_ value:Xla.Literal!) -> Xla.ConstantRequest.Builder {
                self.literal = value
                return self
            }
            @discardableResult
            public func mergeLiteral(value:Xla.Literal) throws -> Xla.ConstantRequest.Builder {
                if builderResult.hasLiteral {
                    builderResult.literal = try Xla.Literal.builderWithPrototype(prototype:builderResult.literal).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.literal = value
                }
                builderResult.hasLiteral = true
                return self
            }
            @discardableResult
            public func clearLiteral() -> Xla.ConstantRequest.Builder {
                literalBuilder_ = nil
                builderResult.hasLiteral = false
                builderResult.literal = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.ConstantRequest.Builder {
                builderResult = Xla.ConstantRequest()
                return self
            }
            override public func clone() throws -> Xla.ConstantRequest.Builder {
                return try Xla.ConstantRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.ConstantRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.ConstantRequest {
                let returnMe:Xla.ConstantRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.ConstantRequest) throws -> Xla.ConstantRequest.Builder {
                if other == Xla.ConstantRequest() {
                    return self
                }
                if (other.hasLiteral) {
                    try mergeLiteral(value: other.literal)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.ConstantRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ConstantRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 18:
                        let subBuilder:Xla.Literal.Builder = Xla.Literal.Builder()
                        if hasLiteral {
                            try subBuilder.mergeFrom(other: literal)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        literal = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.ConstantRequest.Builder {
                let resultDecodedBuilder = Xla.ConstantRequest.Builder()
                if let jsonValueLiteral = jsonMap["literal"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.literal = try Xla.Literal.Builder.decodeToBuilder(jsonMap:jsonValueLiteral).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.ConstantRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.ConstantRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class GetTupleElementRequest : GeneratedMessage {

        public static func == (lhs: Xla.GetTupleElementRequest, rhs: Xla.GetTupleElementRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasOperand == rhs.hasOperand) && (!lhs.hasOperand || lhs.operand == rhs.operand)
            fieldCheck = fieldCheck && (lhs.hasIndex == rhs.hasIndex) && (!lhs.hasIndex || lhs.index == rhs.index)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var operand:Xla.ComputationDataHandle!
        public fileprivate(set) var hasOperand:Bool = false
        public fileprivate(set) var index:Int64 = Int64(0)
        public fileprivate(set) var hasIndex:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasOperand {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:operand)
            }
            if hasIndex {
                try codedOutputStream.writeInt64(fieldNumber: 3, value:index)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasOperand {
                if let varSizeoperand = operand?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeoperand
                }
            }
            if hasIndex {
                serialize_size += index.computeInt64Size(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.GetTupleElementRequest.Builder {
            return Xla.GetTupleElementRequest.classBuilder() as! Xla.GetTupleElementRequest.Builder
        }
        public func getBuilder() -> Xla.GetTupleElementRequest.Builder {
            return classBuilder() as! Xla.GetTupleElementRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.GetTupleElementRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.GetTupleElementRequest.Builder()
        }
        public func toBuilder() throws -> Xla.GetTupleElementRequest.Builder {
            return try Xla.GetTupleElementRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.GetTupleElementRequest) throws -> Xla.GetTupleElementRequest.Builder {
            return try Xla.GetTupleElementRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasOperand {
                jsonMap["operand"] = try operand.encode()
            }
            if hasIndex {
                jsonMap["index"] = "\(index)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.GetTupleElementRequest {
            return try Xla.GetTupleElementRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.GetTupleElementRequest {
            return try Xla.GetTupleElementRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasOperand {
                output += "\(indent) operand {\n"
                if let outDescOperand = operand {
                    output += try outDescOperand.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasIndex {
                output += "\(indent) index: \(index) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasOperand {
                    if let hashValueoperand = operand?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoperand
                    }
                }
                if hasIndex {
                    hashCode = (hashCode &* 31) &+ index.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.GetTupleElementRequest"
        }
        override public func className() -> String {
            return "Xla.GetTupleElementRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.GetTupleElementRequest = Xla.GetTupleElementRequest()
            public func getMessage() -> Xla.GetTupleElementRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var operand:Xla.ComputationDataHandle! {
                get {
                    if operandBuilder_ != nil {
                        builderResult.operand = operandBuilder_.getMessage()
                    }
                    return builderResult.operand
                }
                set (value) {
                    builderResult.hasOperand = true
                    builderResult.operand = value
                }
            }
            public var hasOperand:Bool {
                get {
                    return builderResult.hasOperand
                }
            }
            fileprivate var operandBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasOperand = true
                }
            }
            public func getOperandBuilder() -> Xla.ComputationDataHandle.Builder {
                if operandBuilder_ == nil {
                    operandBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.operand = operandBuilder_.getMessage()
                    if operand != nil {
                        try! operandBuilder_.mergeFrom(other: operand)
                    }
                }
                return operandBuilder_
            }
            @discardableResult
            public func setOperand(_ value:Xla.ComputationDataHandle!) -> Xla.GetTupleElementRequest.Builder {
                self.operand = value
                return self
            }
            @discardableResult
            public func mergeOperand(value:Xla.ComputationDataHandle) throws -> Xla.GetTupleElementRequest.Builder {
                if builderResult.hasOperand {
                    builderResult.operand = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.operand).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.operand = value
                }
                builderResult.hasOperand = true
                return self
            }
            @discardableResult
            public func clearOperand() -> Xla.GetTupleElementRequest.Builder {
                operandBuilder_ = nil
                builderResult.hasOperand = false
                builderResult.operand = nil
                return self
            }
            public var index:Int64 {
                get {
                    return builderResult.index
                }
                set (value) {
                    builderResult.hasIndex = true
                    builderResult.index = value
                }
            }
            public var hasIndex:Bool {
                get {
                    return builderResult.hasIndex
                }
            }
            @discardableResult
            public func setIndex(_ value:Int64) -> Xla.GetTupleElementRequest.Builder {
                self.index = value
                return self
            }
            @discardableResult
            public func clearIndex() -> Xla.GetTupleElementRequest.Builder{
                builderResult.hasIndex = false
                builderResult.index = Int64(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.GetTupleElementRequest.Builder {
                builderResult = Xla.GetTupleElementRequest()
                return self
            }
            override public func clone() throws -> Xla.GetTupleElementRequest.Builder {
                return try Xla.GetTupleElementRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.GetTupleElementRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.GetTupleElementRequest {
                let returnMe:Xla.GetTupleElementRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.GetTupleElementRequest) throws -> Xla.GetTupleElementRequest.Builder {
                if other == Xla.GetTupleElementRequest() {
                    return self
                }
                if (other.hasOperand) {
                    try mergeOperand(value: other.operand)
                }
                if other.hasIndex {
                    index = other.index
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.GetTupleElementRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.GetTupleElementRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 18:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasOperand {
                            try subBuilder.mergeFrom(other: operand)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        operand = subBuilder.buildPartial()

                    case 24:
                        index = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.GetTupleElementRequest.Builder {
                let resultDecodedBuilder = Xla.GetTupleElementRequest.Builder()
                if let jsonValueOperand = jsonMap["operand"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.operand = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueOperand).build()

                }
                if let jsonValueIndex = jsonMap["index"] as? String {
                    resultDecodedBuilder.index = Int64(jsonValueIndex)!
                } else if let jsonValueIndex = jsonMap["index"] as? Int {
                    resultDecodedBuilder.index = Int64(jsonValueIndex)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.GetTupleElementRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.GetTupleElementRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class SliceRequest : GeneratedMessage {

        public static func == (lhs: Xla.SliceRequest, rhs: Xla.SliceRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasOperand == rhs.hasOperand) && (!lhs.hasOperand || lhs.operand == rhs.operand)
            fieldCheck = fieldCheck && (lhs.startIndices == rhs.startIndices)
            fieldCheck = fieldCheck && (lhs.limitIndices == rhs.limitIndices)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var operand:Xla.ComputationDataHandle!
        public fileprivate(set) var hasOperand:Bool = false
        public fileprivate(set) var startIndices:Array<Int64> = Array<Int64>()
        private var startIndicesMemoizedSerializedSize:Int32 = -1
        public fileprivate(set) var limitIndices:Array<Int64> = Array<Int64>()
        private var limitIndicesMemoizedSerializedSize:Int32 = -1
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasOperand {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:operand)
            }
            if !startIndices.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 26)
                try codedOutputStream.writeRawVarint32(value: startIndicesMemoizedSerializedSize)
                for oneValuestartIndices in startIndices {
                    try codedOutputStream.writeInt64NoTag(value: oneValuestartIndices)
                }
            }
            if !limitIndices.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 34)
                try codedOutputStream.writeRawVarint32(value: limitIndicesMemoizedSerializedSize)
                for oneValuelimitIndices in limitIndices {
                    try codedOutputStream.writeInt64NoTag(value: oneValuelimitIndices)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasOperand {
                if let varSizeoperand = operand?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeoperand
                }
            }
            var dataSizeStartIndices:Int32 = 0
            for oneValuestartIndices in startIndices {
                dataSizeStartIndices += oneValuestartIndices.computeInt64SizeNoTag()
            }
            serialize_size += dataSizeStartIndices
            if !startIndices.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeStartIndices.computeInt32SizeNoTag()
            }
            startIndicesMemoizedSerializedSize = dataSizeStartIndices
            var dataSizeLimitIndices:Int32 = 0
            for oneValuelimitIndices in limitIndices {
                dataSizeLimitIndices += oneValuelimitIndices.computeInt64SizeNoTag()
            }
            serialize_size += dataSizeLimitIndices
            if !limitIndices.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeLimitIndices.computeInt32SizeNoTag()
            }
            limitIndicesMemoizedSerializedSize = dataSizeLimitIndices
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.SliceRequest.Builder {
            return Xla.SliceRequest.classBuilder() as! Xla.SliceRequest.Builder
        }
        public func getBuilder() -> Xla.SliceRequest.Builder {
            return classBuilder() as! Xla.SliceRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.SliceRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.SliceRequest.Builder()
        }
        public func toBuilder() throws -> Xla.SliceRequest.Builder {
            return try Xla.SliceRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.SliceRequest) throws -> Xla.SliceRequest.Builder {
            return try Xla.SliceRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasOperand {
                jsonMap["operand"] = try operand.encode()
            }
            if !startIndices.isEmpty {
                var jsonArrayStartIndices:Array<String> = []
                for oneValueStartIndices in startIndices {
                    jsonArrayStartIndices.append("\(oneValueStartIndices)")
                }
                jsonMap["startIndices"] = jsonArrayStartIndices
            }
            if !limitIndices.isEmpty {
                var jsonArrayLimitIndices:Array<String> = []
                for oneValueLimitIndices in limitIndices {
                    jsonArrayLimitIndices.append("\(oneValueLimitIndices)")
                }
                jsonMap["limitIndices"] = jsonArrayLimitIndices
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.SliceRequest {
            return try Xla.SliceRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.SliceRequest {
            return try Xla.SliceRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasOperand {
                output += "\(indent) operand {\n"
                if let outDescOperand = operand {
                    output += try outDescOperand.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            var startIndicesElementIndex:Int = 0
            for oneValueStartIndices in startIndices  {
                output += "\(indent) startIndices[\(startIndicesElementIndex)]: \(oneValueStartIndices)\n"
                startIndicesElementIndex += 1
            }
            var limitIndicesElementIndex:Int = 0
            for oneValueLimitIndices in limitIndices  {
                output += "\(indent) limitIndices[\(limitIndicesElementIndex)]: \(oneValueLimitIndices)\n"
                limitIndicesElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasOperand {
                    if let hashValueoperand = operand?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoperand
                    }
                }
                for oneValueStartIndices in startIndices {
                    hashCode = (hashCode &* 31) &+ oneValueStartIndices.hashValue
                }
                for oneValueLimitIndices in limitIndices {
                    hashCode = (hashCode &* 31) &+ oneValueLimitIndices.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.SliceRequest"
        }
        override public func className() -> String {
            return "Xla.SliceRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.SliceRequest = Xla.SliceRequest()
            public func getMessage() -> Xla.SliceRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var operand:Xla.ComputationDataHandle! {
                get {
                    if operandBuilder_ != nil {
                        builderResult.operand = operandBuilder_.getMessage()
                    }
                    return builderResult.operand
                }
                set (value) {
                    builderResult.hasOperand = true
                    builderResult.operand = value
                }
            }
            public var hasOperand:Bool {
                get {
                    return builderResult.hasOperand
                }
            }
            fileprivate var operandBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasOperand = true
                }
            }
            public func getOperandBuilder() -> Xla.ComputationDataHandle.Builder {
                if operandBuilder_ == nil {
                    operandBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.operand = operandBuilder_.getMessage()
                    if operand != nil {
                        try! operandBuilder_.mergeFrom(other: operand)
                    }
                }
                return operandBuilder_
            }
            @discardableResult
            public func setOperand(_ value:Xla.ComputationDataHandle!) -> Xla.SliceRequest.Builder {
                self.operand = value
                return self
            }
            @discardableResult
            public func mergeOperand(value:Xla.ComputationDataHandle) throws -> Xla.SliceRequest.Builder {
                if builderResult.hasOperand {
                    builderResult.operand = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.operand).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.operand = value
                }
                builderResult.hasOperand = true
                return self
            }
            @discardableResult
            public func clearOperand() -> Xla.SliceRequest.Builder {
                operandBuilder_ = nil
                builderResult.hasOperand = false
                builderResult.operand = nil
                return self
            }
            public var startIndices:Array<Int64> {
                get {
                    return builderResult.startIndices
                }
                set (array) {
                    builderResult.startIndices = array
                }
            }
            @discardableResult
            public func setStartIndices(_ value:Array<Int64>) -> Xla.SliceRequest.Builder {
                self.startIndices = value
                return self
            }
            @discardableResult
            public func clearStartIndices() -> Xla.SliceRequest.Builder {
                builderResult.startIndices.removeAll(keepingCapacity: false)
                return self
            }
            public var limitIndices:Array<Int64> {
                get {
                    return builderResult.limitIndices
                }
                set (array) {
                    builderResult.limitIndices = array
                }
            }
            @discardableResult
            public func setLimitIndices(_ value:Array<Int64>) -> Xla.SliceRequest.Builder {
                self.limitIndices = value
                return self
            }
            @discardableResult
            public func clearLimitIndices() -> Xla.SliceRequest.Builder {
                builderResult.limitIndices.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.SliceRequest.Builder {
                builderResult = Xla.SliceRequest()
                return self
            }
            override public func clone() throws -> Xla.SliceRequest.Builder {
                return try Xla.SliceRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.SliceRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.SliceRequest {
                let returnMe:Xla.SliceRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.SliceRequest) throws -> Xla.SliceRequest.Builder {
                if other == Xla.SliceRequest() {
                    return self
                }
                if (other.hasOperand) {
                    try mergeOperand(value: other.operand)
                }
                if !other.startIndices.isEmpty {
                    builderResult.startIndices += other.startIndices
                }
                if !other.limitIndices.isEmpty {
                    builderResult.limitIndices += other.limitIndices
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.SliceRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SliceRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 18:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasOperand {
                            try subBuilder.mergeFrom(other: operand)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        operand = subBuilder.buildPartial()

                    case 26:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.startIndices.append(try codedInputStream.readInt64())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 34:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.limitIndices.append(try codedInputStream.readInt64())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.SliceRequest.Builder {
                let resultDecodedBuilder = Xla.SliceRequest.Builder()
                if let jsonValueOperand = jsonMap["operand"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.operand = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueOperand).build()

                }
                if let jsonValueStartIndices = jsonMap["startIndices"] as? Array<String> {
                    var jsonArrayStartIndices:Array<Int64> = []
                    for oneValueStartIndices in jsonValueStartIndices {
                        jsonArrayStartIndices.append(Int64(oneValueStartIndices)!)
                    }
                    resultDecodedBuilder.startIndices = jsonArrayStartIndices
                }
                if let jsonValueLimitIndices = jsonMap["limitIndices"] as? Array<String> {
                    var jsonArrayLimitIndices:Array<Int64> = []
                    for oneValueLimitIndices in jsonValueLimitIndices {
                        jsonArrayLimitIndices.append(Int64(oneValueLimitIndices)!)
                    }
                    resultDecodedBuilder.limitIndices = jsonArrayLimitIndices
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.SliceRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.SliceRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class DynamicSliceRequest : GeneratedMessage {

        public static func == (lhs: Xla.DynamicSliceRequest, rhs: Xla.DynamicSliceRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasOperand == rhs.hasOperand) && (!lhs.hasOperand || lhs.operand == rhs.operand)
            fieldCheck = fieldCheck && (lhs.hasStartIndices == rhs.hasStartIndices) && (!lhs.hasStartIndices || lhs.startIndices == rhs.startIndices)
            fieldCheck = fieldCheck && (lhs.sliceSizes == rhs.sliceSizes)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var operand:Xla.ComputationDataHandle!
        public fileprivate(set) var hasOperand:Bool = false
        public fileprivate(set) var startIndices:Xla.ComputationDataHandle!
        public fileprivate(set) var hasStartIndices:Bool = false
        /// Slice sizes for each dimension (note that indices calculations are computed
        /// modulo dimension sizes to avoid out-of-bound array accesses).
        public fileprivate(set) var sliceSizes:Array<Int64> = Array<Int64>()
        private var sliceSizesMemoizedSerializedSize:Int32 = -1
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasOperand {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:operand)
            }
            if hasStartIndices {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:startIndices)
            }
            if !sliceSizes.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 34)
                try codedOutputStream.writeRawVarint32(value: sliceSizesMemoizedSerializedSize)
                for oneValuesliceSizes in sliceSizes {
                    try codedOutputStream.writeInt64NoTag(value: oneValuesliceSizes)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasOperand {
                if let varSizeoperand = operand?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeoperand
                }
            }
            if hasStartIndices {
                if let varSizestartIndices = startIndices?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizestartIndices
                }
            }
            var dataSizeSliceSizes:Int32 = 0
            for oneValuesliceSizes in sliceSizes {
                dataSizeSliceSizes += oneValuesliceSizes.computeInt64SizeNoTag()
            }
            serialize_size += dataSizeSliceSizes
            if !sliceSizes.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeSliceSizes.computeInt32SizeNoTag()
            }
            sliceSizesMemoizedSerializedSize = dataSizeSliceSizes
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.DynamicSliceRequest.Builder {
            return Xla.DynamicSliceRequest.classBuilder() as! Xla.DynamicSliceRequest.Builder
        }
        public func getBuilder() -> Xla.DynamicSliceRequest.Builder {
            return classBuilder() as! Xla.DynamicSliceRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.DynamicSliceRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.DynamicSliceRequest.Builder()
        }
        public func toBuilder() throws -> Xla.DynamicSliceRequest.Builder {
            return try Xla.DynamicSliceRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.DynamicSliceRequest) throws -> Xla.DynamicSliceRequest.Builder {
            return try Xla.DynamicSliceRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasOperand {
                jsonMap["operand"] = try operand.encode()
            }
            if hasStartIndices {
                jsonMap["startIndices"] = try startIndices.encode()
            }
            if !sliceSizes.isEmpty {
                var jsonArraySliceSizes:Array<String> = []
                for oneValueSliceSizes in sliceSizes {
                    jsonArraySliceSizes.append("\(oneValueSliceSizes)")
                }
                jsonMap["sliceSizes"] = jsonArraySliceSizes
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.DynamicSliceRequest {
            return try Xla.DynamicSliceRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.DynamicSliceRequest {
            return try Xla.DynamicSliceRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasOperand {
                output += "\(indent) operand {\n"
                if let outDescOperand = operand {
                    output += try outDescOperand.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasStartIndices {
                output += "\(indent) startIndices {\n"
                if let outDescStartIndices = startIndices {
                    output += try outDescStartIndices.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            var sliceSizesElementIndex:Int = 0
            for oneValueSliceSizes in sliceSizes  {
                output += "\(indent) sliceSizes[\(sliceSizesElementIndex)]: \(oneValueSliceSizes)\n"
                sliceSizesElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasOperand {
                    if let hashValueoperand = operand?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoperand
                    }
                }
                if hasStartIndices {
                    if let hashValuestartIndices = startIndices?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuestartIndices
                    }
                }
                for oneValueSliceSizes in sliceSizes {
                    hashCode = (hashCode &* 31) &+ oneValueSliceSizes.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.DynamicSliceRequest"
        }
        override public func className() -> String {
            return "Xla.DynamicSliceRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.DynamicSliceRequest = Xla.DynamicSliceRequest()
            public func getMessage() -> Xla.DynamicSliceRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Operand from which to slice at dynamic 'start_indices'.
            public var operand:Xla.ComputationDataHandle! {
                get {
                    if operandBuilder_ != nil {
                        builderResult.operand = operandBuilder_.getMessage()
                    }
                    return builderResult.operand
                }
                set (value) {
                    builderResult.hasOperand = true
                    builderResult.operand = value
                }
            }
            public var hasOperand:Bool {
                get {
                    return builderResult.hasOperand
                }
            }
            fileprivate var operandBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasOperand = true
                }
            }
            public func getOperandBuilder() -> Xla.ComputationDataHandle.Builder {
                if operandBuilder_ == nil {
                    operandBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.operand = operandBuilder_.getMessage()
                    if operand != nil {
                        try! operandBuilder_.mergeFrom(other: operand)
                    }
                }
                return operandBuilder_
            }
            @discardableResult
            public func setOperand(_ value:Xla.ComputationDataHandle!) -> Xla.DynamicSliceRequest.Builder {
                self.operand = value
                return self
            }
            @discardableResult
            public func mergeOperand(value:Xla.ComputationDataHandle) throws -> Xla.DynamicSliceRequest.Builder {
                if builderResult.hasOperand {
                    builderResult.operand = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.operand).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.operand = value
                }
                builderResult.hasOperand = true
                return self
            }
            @discardableResult
            public func clearOperand() -> Xla.DynamicSliceRequest.Builder {
                operandBuilder_ = nil
                builderResult.hasOperand = false
                builderResult.operand = nil
                return self
            }
            /// Dynamically computed 'start_indices' for slice operation.
            public var startIndices:Xla.ComputationDataHandle! {
                get {
                    if startIndicesBuilder_ != nil {
                        builderResult.startIndices = startIndicesBuilder_.getMessage()
                    }
                    return builderResult.startIndices
                }
                set (value) {
                    builderResult.hasStartIndices = true
                    builderResult.startIndices = value
                }
            }
            public var hasStartIndices:Bool {
                get {
                    return builderResult.hasStartIndices
                }
            }
            fileprivate var startIndicesBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasStartIndices = true
                }
            }
            public func getStartIndicesBuilder() -> Xla.ComputationDataHandle.Builder {
                if startIndicesBuilder_ == nil {
                    startIndicesBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.startIndices = startIndicesBuilder_.getMessage()
                    if startIndices != nil {
                        try! startIndicesBuilder_.mergeFrom(other: startIndices)
                    }
                }
                return startIndicesBuilder_
            }
            @discardableResult
            public func setStartIndices(_ value:Xla.ComputationDataHandle!) -> Xla.DynamicSliceRequest.Builder {
                self.startIndices = value
                return self
            }
            @discardableResult
            public func mergeStartIndices(value:Xla.ComputationDataHandle) throws -> Xla.DynamicSliceRequest.Builder {
                if builderResult.hasStartIndices {
                    builderResult.startIndices = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.startIndices).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.startIndices = value
                }
                builderResult.hasStartIndices = true
                return self
            }
            @discardableResult
            public func clearStartIndices() -> Xla.DynamicSliceRequest.Builder {
                startIndicesBuilder_ = nil
                builderResult.hasStartIndices = false
                builderResult.startIndices = nil
                return self
            }
            /// Slice sizes for each dimension (note that indices calculations are computed
            /// modulo dimension sizes to avoid out-of-bound array accesses).
            public var sliceSizes:Array<Int64> {
                get {
                    return builderResult.sliceSizes
                }
                set (array) {
                    builderResult.sliceSizes = array
                }
            }
            @discardableResult
            public func setSliceSizes(_ value:Array<Int64>) -> Xla.DynamicSliceRequest.Builder {
                self.sliceSizes = value
                return self
            }
            @discardableResult
            public func clearSliceSizes() -> Xla.DynamicSliceRequest.Builder {
                builderResult.sliceSizes.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.DynamicSliceRequest.Builder {
                builderResult = Xla.DynamicSliceRequest()
                return self
            }
            override public func clone() throws -> Xla.DynamicSliceRequest.Builder {
                return try Xla.DynamicSliceRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.DynamicSliceRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.DynamicSliceRequest {
                let returnMe:Xla.DynamicSliceRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.DynamicSliceRequest) throws -> Xla.DynamicSliceRequest.Builder {
                if other == Xla.DynamicSliceRequest() {
                    return self
                }
                if (other.hasOperand) {
                    try mergeOperand(value: other.operand)
                }
                if (other.hasStartIndices) {
                    try mergeStartIndices(value: other.startIndices)
                }
                if !other.sliceSizes.isEmpty {
                    builderResult.sliceSizes += other.sliceSizes
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.DynamicSliceRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.DynamicSliceRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 18:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasOperand {
                            try subBuilder.mergeFrom(other: operand)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        operand = subBuilder.buildPartial()

                    case 26:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasStartIndices {
                            try subBuilder.mergeFrom(other: startIndices)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        startIndices = subBuilder.buildPartial()

                    case 34:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.sliceSizes.append(try codedInputStream.readInt64())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.DynamicSliceRequest.Builder {
                let resultDecodedBuilder = Xla.DynamicSliceRequest.Builder()
                if let jsonValueOperand = jsonMap["operand"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.operand = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueOperand).build()

                }
                if let jsonValueStartIndices = jsonMap["startIndices"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.startIndices = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueStartIndices).build()

                }
                if let jsonValueSliceSizes = jsonMap["sliceSizes"] as? Array<String> {
                    var jsonArraySliceSizes:Array<Int64> = []
                    for oneValueSliceSizes in jsonValueSliceSizes {
                        jsonArraySliceSizes.append(Int64(oneValueSliceSizes)!)
                    }
                    resultDecodedBuilder.sliceSizes = jsonArraySliceSizes
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.DynamicSliceRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.DynamicSliceRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class DynamicUpdateSliceRequest : GeneratedMessage {

        public static func == (lhs: Xla.DynamicUpdateSliceRequest, rhs: Xla.DynamicUpdateSliceRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasOperand == rhs.hasOperand) && (!lhs.hasOperand || lhs.operand == rhs.operand)
            fieldCheck = fieldCheck && (lhs.hasUpdate == rhs.hasUpdate) && (!lhs.hasUpdate || lhs.update == rhs.update)
            fieldCheck = fieldCheck && (lhs.hasStartIndices == rhs.hasStartIndices) && (!lhs.hasStartIndices || lhs.startIndices == rhs.startIndices)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var operand:Xla.ComputationDataHandle!
        public fileprivate(set) var hasOperand:Bool = false
        public fileprivate(set) var update:Xla.ComputationDataHandle!
        public fileprivate(set) var hasUpdate:Bool = false
        public fileprivate(set) var startIndices:Xla.ComputationDataHandle!
        public fileprivate(set) var hasStartIndices:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasOperand {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:operand)
            }
            if hasUpdate {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:update)
            }
            if hasStartIndices {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:startIndices)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasOperand {
                if let varSizeoperand = operand?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeoperand
                }
            }
            if hasUpdate {
                if let varSizeupdate = update?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizeupdate
                }
            }
            if hasStartIndices {
                if let varSizestartIndices = startIndices?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizestartIndices
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.DynamicUpdateSliceRequest.Builder {
            return Xla.DynamicUpdateSliceRequest.classBuilder() as! Xla.DynamicUpdateSliceRequest.Builder
        }
        public func getBuilder() -> Xla.DynamicUpdateSliceRequest.Builder {
            return classBuilder() as! Xla.DynamicUpdateSliceRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.DynamicUpdateSliceRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.DynamicUpdateSliceRequest.Builder()
        }
        public func toBuilder() throws -> Xla.DynamicUpdateSliceRequest.Builder {
            return try Xla.DynamicUpdateSliceRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.DynamicUpdateSliceRequest) throws -> Xla.DynamicUpdateSliceRequest.Builder {
            return try Xla.DynamicUpdateSliceRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasOperand {
                jsonMap["operand"] = try operand.encode()
            }
            if hasUpdate {
                jsonMap["update"] = try update.encode()
            }
            if hasStartIndices {
                jsonMap["startIndices"] = try startIndices.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.DynamicUpdateSliceRequest {
            return try Xla.DynamicUpdateSliceRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.DynamicUpdateSliceRequest {
            return try Xla.DynamicUpdateSliceRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasOperand {
                output += "\(indent) operand {\n"
                if let outDescOperand = operand {
                    output += try outDescOperand.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasUpdate {
                output += "\(indent) update {\n"
                if let outDescUpdate = update {
                    output += try outDescUpdate.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasStartIndices {
                output += "\(indent) startIndices {\n"
                if let outDescStartIndices = startIndices {
                    output += try outDescStartIndices.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasOperand {
                    if let hashValueoperand = operand?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoperand
                    }
                }
                if hasUpdate {
                    if let hashValueupdate = update?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueupdate
                    }
                }
                if hasStartIndices {
                    if let hashValuestartIndices = startIndices?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuestartIndices
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.DynamicUpdateSliceRequest"
        }
        override public func className() -> String {
            return "Xla.DynamicUpdateSliceRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.DynamicUpdateSliceRequest = Xla.DynamicUpdateSliceRequest()
            public func getMessage() -> Xla.DynamicUpdateSliceRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Operand on which slice 'update' is to be applied.
            public var operand:Xla.ComputationDataHandle! {
                get {
                    if operandBuilder_ != nil {
                        builderResult.operand = operandBuilder_.getMessage()
                    }
                    return builderResult.operand
                }
                set (value) {
                    builderResult.hasOperand = true
                    builderResult.operand = value
                }
            }
            public var hasOperand:Bool {
                get {
                    return builderResult.hasOperand
                }
            }
            fileprivate var operandBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasOperand = true
                }
            }
            public func getOperandBuilder() -> Xla.ComputationDataHandle.Builder {
                if operandBuilder_ == nil {
                    operandBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.operand = operandBuilder_.getMessage()
                    if operand != nil {
                        try! operandBuilder_.mergeFrom(other: operand)
                    }
                }
                return operandBuilder_
            }
            @discardableResult
            public func setOperand(_ value:Xla.ComputationDataHandle!) -> Xla.DynamicUpdateSliceRequest.Builder {
                self.operand = value
                return self
            }
            @discardableResult
            public func mergeOperand(value:Xla.ComputationDataHandle) throws -> Xla.DynamicUpdateSliceRequest.Builder {
                if builderResult.hasOperand {
                    builderResult.operand = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.operand).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.operand = value
                }
                builderResult.hasOperand = true
                return self
            }
            @discardableResult
            public func clearOperand() -> Xla.DynamicUpdateSliceRequest.Builder {
                operandBuilder_ = nil
                builderResult.hasOperand = false
                builderResult.operand = nil
                return self
            }
            /// The slice update to apply to 'operand'.
            public var update:Xla.ComputationDataHandle! {
                get {
                    if updateBuilder_ != nil {
                        builderResult.update = updateBuilder_.getMessage()
                    }
                    return builderResult.update
                }
                set (value) {
                    builderResult.hasUpdate = true
                    builderResult.update = value
                }
            }
            public var hasUpdate:Bool {
                get {
                    return builderResult.hasUpdate
                }
            }
            fileprivate var updateBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasUpdate = true
                }
            }
            public func getUpdateBuilder() -> Xla.ComputationDataHandle.Builder {
                if updateBuilder_ == nil {
                    updateBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.update = updateBuilder_.getMessage()
                    if update != nil {
                        try! updateBuilder_.mergeFrom(other: update)
                    }
                }
                return updateBuilder_
            }
            @discardableResult
            public func setUpdate(_ value:Xla.ComputationDataHandle!) -> Xla.DynamicUpdateSliceRequest.Builder {
                self.update = value
                return self
            }
            @discardableResult
            public func mergeUpdate(value:Xla.ComputationDataHandle) throws -> Xla.DynamicUpdateSliceRequest.Builder {
                if builderResult.hasUpdate {
                    builderResult.update = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.update).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.update = value
                }
                builderResult.hasUpdate = true
                return self
            }
            @discardableResult
            public func clearUpdate() -> Xla.DynamicUpdateSliceRequest.Builder {
                updateBuilder_ = nil
                builderResult.hasUpdate = false
                builderResult.update = nil
                return self
            }
            /// Dynamically computed start indices for the update slice operation.
            public var startIndices:Xla.ComputationDataHandle! {
                get {
                    if startIndicesBuilder_ != nil {
                        builderResult.startIndices = startIndicesBuilder_.getMessage()
                    }
                    return builderResult.startIndices
                }
                set (value) {
                    builderResult.hasStartIndices = true
                    builderResult.startIndices = value
                }
            }
            public var hasStartIndices:Bool {
                get {
                    return builderResult.hasStartIndices
                }
            }
            fileprivate var startIndicesBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasStartIndices = true
                }
            }
            public func getStartIndicesBuilder() -> Xla.ComputationDataHandle.Builder {
                if startIndicesBuilder_ == nil {
                    startIndicesBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.startIndices = startIndicesBuilder_.getMessage()
                    if startIndices != nil {
                        try! startIndicesBuilder_.mergeFrom(other: startIndices)
                    }
                }
                return startIndicesBuilder_
            }
            @discardableResult
            public func setStartIndices(_ value:Xla.ComputationDataHandle!) -> Xla.DynamicUpdateSliceRequest.Builder {
                self.startIndices = value
                return self
            }
            @discardableResult
            public func mergeStartIndices(value:Xla.ComputationDataHandle) throws -> Xla.DynamicUpdateSliceRequest.Builder {
                if builderResult.hasStartIndices {
                    builderResult.startIndices = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.startIndices).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.startIndices = value
                }
                builderResult.hasStartIndices = true
                return self
            }
            @discardableResult
            public func clearStartIndices() -> Xla.DynamicUpdateSliceRequest.Builder {
                startIndicesBuilder_ = nil
                builderResult.hasStartIndices = false
                builderResult.startIndices = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.DynamicUpdateSliceRequest.Builder {
                builderResult = Xla.DynamicUpdateSliceRequest()
                return self
            }
            override public func clone() throws -> Xla.DynamicUpdateSliceRequest.Builder {
                return try Xla.DynamicUpdateSliceRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.DynamicUpdateSliceRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.DynamicUpdateSliceRequest {
                let returnMe:Xla.DynamicUpdateSliceRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.DynamicUpdateSliceRequest) throws -> Xla.DynamicUpdateSliceRequest.Builder {
                if other == Xla.DynamicUpdateSliceRequest() {
                    return self
                }
                if (other.hasOperand) {
                    try mergeOperand(value: other.operand)
                }
                if (other.hasUpdate) {
                    try mergeUpdate(value: other.update)
                }
                if (other.hasStartIndices) {
                    try mergeStartIndices(value: other.startIndices)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.DynamicUpdateSliceRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.DynamicUpdateSliceRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 18:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasOperand {
                            try subBuilder.mergeFrom(other: operand)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        operand = subBuilder.buildPartial()

                    case 26:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasUpdate {
                            try subBuilder.mergeFrom(other: update)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        update = subBuilder.buildPartial()

                    case 34:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasStartIndices {
                            try subBuilder.mergeFrom(other: startIndices)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        startIndices = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.DynamicUpdateSliceRequest.Builder {
                let resultDecodedBuilder = Xla.DynamicUpdateSliceRequest.Builder()
                if let jsonValueOperand = jsonMap["operand"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.operand = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueOperand).build()

                }
                if let jsonValueUpdate = jsonMap["update"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.update = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueUpdate).build()

                }
                if let jsonValueStartIndices = jsonMap["startIndices"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.startIndices = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueStartIndices).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.DynamicUpdateSliceRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.DynamicUpdateSliceRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ConvolutionDimensionNumbers : GeneratedMessage {

        public static func == (lhs: Xla.ConvolutionDimensionNumbers, rhs: Xla.ConvolutionDimensionNumbers) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasBatchDimension == rhs.hasBatchDimension) && (!lhs.hasBatchDimension || lhs.batchDimension == rhs.batchDimension)
            fieldCheck = fieldCheck && (lhs.hasFeatureDimension == rhs.hasFeatureDimension) && (!lhs.hasFeatureDimension || lhs.featureDimension == rhs.featureDimension)
            fieldCheck = fieldCheck && (lhs.hasKernelInputFeatureDimension == rhs.hasKernelInputFeatureDimension) && (!lhs.hasKernelInputFeatureDimension || lhs.kernelInputFeatureDimension == rhs.kernelInputFeatureDimension)
            fieldCheck = fieldCheck && (lhs.hasKernelOutputFeatureDimension == rhs.hasKernelOutputFeatureDimension) && (!lhs.hasKernelOutputFeatureDimension || lhs.kernelOutputFeatureDimension == rhs.kernelOutputFeatureDimension)
            fieldCheck = fieldCheck && (lhs.spatialDimensions == rhs.spatialDimensions)
            fieldCheck = fieldCheck && (lhs.kernelSpatialDimensions == rhs.kernelSpatialDimensions)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// The number of the dimension that represents batch in the input
        /// (lhs) and output.
        public fileprivate(set) var batchDimension:Int64 = Int64(0)
        public fileprivate(set) var hasBatchDimension:Bool = false

        /// The number of the dimension that represents features in the input
        /// (lhs) and output.
        public fileprivate(set) var featureDimension:Int64 = Int64(0)
        public fileprivate(set) var hasFeatureDimension:Bool = false

        /// The dimension numbers for the spatial dimensions that the window
        /// moves through in the input (lhs) and output.
        public fileprivate(set) var spatialDimensions:Array<Int64> = Array<Int64>()
        private var spatialDimensionsMemoizedSerializedSize:Int32 = -1
        /// The number of the dimension that represents input features in the
        /// convolutional kernel (rhs).
        public fileprivate(set) var kernelInputFeatureDimension:Int64 = Int64(0)
        public fileprivate(set) var hasKernelInputFeatureDimension:Bool = false

        /// The number of the dimension that represents output features in
        /// the convolutional kernel (rhs).
        public fileprivate(set) var kernelOutputFeatureDimension:Int64 = Int64(0)
        public fileprivate(set) var hasKernelOutputFeatureDimension:Bool = false

        /// The dimension numbers for the spatial dimensions that the window
        /// moves through in the kernel (rhs). window.strides(0) is the
        /// stride in the kernel_spatial_dimensions(0) dimension.
        public fileprivate(set) var kernelSpatialDimensions:Array<Int64> = Array<Int64>()
        private var kernelSpatialDimensionsMemoizedSerializedSize:Int32 = -1
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasBatchDimension {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:batchDimension)
            }
            if hasFeatureDimension {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:featureDimension)
            }
            if hasKernelInputFeatureDimension {
                try codedOutputStream.writeInt64(fieldNumber: 3, value:kernelInputFeatureDimension)
            }
            if hasKernelOutputFeatureDimension {
                try codedOutputStream.writeInt64(fieldNumber: 4, value:kernelOutputFeatureDimension)
            }
            if !spatialDimensions.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 42)
                try codedOutputStream.writeRawVarint32(value: spatialDimensionsMemoizedSerializedSize)
                for oneValuespatialDimensions in spatialDimensions {
                    try codedOutputStream.writeInt64NoTag(value: oneValuespatialDimensions)
                }
            }
            if !kernelSpatialDimensions.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 50)
                try codedOutputStream.writeRawVarint32(value: kernelSpatialDimensionsMemoizedSerializedSize)
                for oneValuekernelSpatialDimensions in kernelSpatialDimensions {
                    try codedOutputStream.writeInt64NoTag(value: oneValuekernelSpatialDimensions)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasBatchDimension {
                serialize_size += batchDimension.computeInt64Size(fieldNumber: 1)
            }
            if hasFeatureDimension {
                serialize_size += featureDimension.computeInt64Size(fieldNumber: 2)
            }
            if hasKernelInputFeatureDimension {
                serialize_size += kernelInputFeatureDimension.computeInt64Size(fieldNumber: 3)
            }
            if hasKernelOutputFeatureDimension {
                serialize_size += kernelOutputFeatureDimension.computeInt64Size(fieldNumber: 4)
            }
            var dataSizeSpatialDimensions:Int32 = 0
            for oneValuespatialDimensions in spatialDimensions {
                dataSizeSpatialDimensions += oneValuespatialDimensions.computeInt64SizeNoTag()
            }
            serialize_size += dataSizeSpatialDimensions
            if !spatialDimensions.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeSpatialDimensions.computeInt32SizeNoTag()
            }
            spatialDimensionsMemoizedSerializedSize = dataSizeSpatialDimensions
            var dataSizeKernelSpatialDimensions:Int32 = 0
            for oneValuekernelSpatialDimensions in kernelSpatialDimensions {
                dataSizeKernelSpatialDimensions += oneValuekernelSpatialDimensions.computeInt64SizeNoTag()
            }
            serialize_size += dataSizeKernelSpatialDimensions
            if !kernelSpatialDimensions.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeKernelSpatialDimensions.computeInt32SizeNoTag()
            }
            kernelSpatialDimensionsMemoizedSerializedSize = dataSizeKernelSpatialDimensions
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.ConvolutionDimensionNumbers.Builder {
            return Xla.ConvolutionDimensionNumbers.classBuilder() as! Xla.ConvolutionDimensionNumbers.Builder
        }
        public func getBuilder() -> Xla.ConvolutionDimensionNumbers.Builder {
            return classBuilder() as! Xla.ConvolutionDimensionNumbers.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ConvolutionDimensionNumbers.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ConvolutionDimensionNumbers.Builder()
        }
        public func toBuilder() throws -> Xla.ConvolutionDimensionNumbers.Builder {
            return try Xla.ConvolutionDimensionNumbers.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.ConvolutionDimensionNumbers) throws -> Xla.ConvolutionDimensionNumbers.Builder {
            return try Xla.ConvolutionDimensionNumbers.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasBatchDimension {
                jsonMap["batchDimension"] = "\(batchDimension)"
            }
            if hasFeatureDimension {
                jsonMap["featureDimension"] = "\(featureDimension)"
            }
            if !spatialDimensions.isEmpty {
                var jsonArraySpatialDimensions:Array<String> = []
                for oneValueSpatialDimensions in spatialDimensions {
                    jsonArraySpatialDimensions.append("\(oneValueSpatialDimensions)")
                }
                jsonMap["spatialDimensions"] = jsonArraySpatialDimensions
            }
            if hasKernelInputFeatureDimension {
                jsonMap["kernelInputFeatureDimension"] = "\(kernelInputFeatureDimension)"
            }
            if hasKernelOutputFeatureDimension {
                jsonMap["kernelOutputFeatureDimension"] = "\(kernelOutputFeatureDimension)"
            }
            if !kernelSpatialDimensions.isEmpty {
                var jsonArrayKernelSpatialDimensions:Array<String> = []
                for oneValueKernelSpatialDimensions in kernelSpatialDimensions {
                    jsonArrayKernelSpatialDimensions.append("\(oneValueKernelSpatialDimensions)")
                }
                jsonMap["kernelSpatialDimensions"] = jsonArrayKernelSpatialDimensions
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.ConvolutionDimensionNumbers {
            return try Xla.ConvolutionDimensionNumbers.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.ConvolutionDimensionNumbers {
            return try Xla.ConvolutionDimensionNumbers.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasBatchDimension {
                output += "\(indent) batchDimension: \(batchDimension) \n"
            }
            if hasFeatureDimension {
                output += "\(indent) featureDimension: \(featureDimension) \n"
            }
            if hasKernelInputFeatureDimension {
                output += "\(indent) kernelInputFeatureDimension: \(kernelInputFeatureDimension) \n"
            }
            if hasKernelOutputFeatureDimension {
                output += "\(indent) kernelOutputFeatureDimension: \(kernelOutputFeatureDimension) \n"
            }
            var spatialDimensionsElementIndex:Int = 0
            for oneValueSpatialDimensions in spatialDimensions  {
                output += "\(indent) spatialDimensions[\(spatialDimensionsElementIndex)]: \(oneValueSpatialDimensions)\n"
                spatialDimensionsElementIndex += 1
            }
            var kernelSpatialDimensionsElementIndex:Int = 0
            for oneValueKernelSpatialDimensions in kernelSpatialDimensions  {
                output += "\(indent) kernelSpatialDimensions[\(kernelSpatialDimensionsElementIndex)]: \(oneValueKernelSpatialDimensions)\n"
                kernelSpatialDimensionsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasBatchDimension {
                    hashCode = (hashCode &* 31) &+ batchDimension.hashValue
                }
                if hasFeatureDimension {
                    hashCode = (hashCode &* 31) &+ featureDimension.hashValue
                }
                if hasKernelInputFeatureDimension {
                    hashCode = (hashCode &* 31) &+ kernelInputFeatureDimension.hashValue
                }
                if hasKernelOutputFeatureDimension {
                    hashCode = (hashCode &* 31) &+ kernelOutputFeatureDimension.hashValue
                }
                for oneValueSpatialDimensions in spatialDimensions {
                    hashCode = (hashCode &* 31) &+ oneValueSpatialDimensions.hashValue
                }
                for oneValueKernelSpatialDimensions in kernelSpatialDimensions {
                    hashCode = (hashCode &* 31) &+ oneValueKernelSpatialDimensions.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.ConvolutionDimensionNumbers"
        }
        override public func className() -> String {
            return "Xla.ConvolutionDimensionNumbers"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.ConvolutionDimensionNumbers = Xla.ConvolutionDimensionNumbers()
            public func getMessage() -> Xla.ConvolutionDimensionNumbers {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The number of the dimension that represents batch in the input
            /// (lhs) and output.
            public var batchDimension:Int64 {
                get {
                    return builderResult.batchDimension
                }
                set (value) {
                    builderResult.hasBatchDimension = true
                    builderResult.batchDimension = value
                }
            }
            public var hasBatchDimension:Bool {
                get {
                    return builderResult.hasBatchDimension
                }
            }
            @discardableResult
            public func setBatchDimension(_ value:Int64) -> Xla.ConvolutionDimensionNumbers.Builder {
                self.batchDimension = value
                return self
            }
            @discardableResult
            public func clearBatchDimension() -> Xla.ConvolutionDimensionNumbers.Builder{
                builderResult.hasBatchDimension = false
                builderResult.batchDimension = Int64(0)
                return self
            }
            /// The number of the dimension that represents features in the input
            /// (lhs) and output.
            public var featureDimension:Int64 {
                get {
                    return builderResult.featureDimension
                }
                set (value) {
                    builderResult.hasFeatureDimension = true
                    builderResult.featureDimension = value
                }
            }
            public var hasFeatureDimension:Bool {
                get {
                    return builderResult.hasFeatureDimension
                }
            }
            @discardableResult
            public func setFeatureDimension(_ value:Int64) -> Xla.ConvolutionDimensionNumbers.Builder {
                self.featureDimension = value
                return self
            }
            @discardableResult
            public func clearFeatureDimension() -> Xla.ConvolutionDimensionNumbers.Builder{
                builderResult.hasFeatureDimension = false
                builderResult.featureDimension = Int64(0)
                return self
            }
            /// The dimension numbers for the spatial dimensions that the window
            /// moves through in the input (lhs) and output.
            public var spatialDimensions:Array<Int64> {
                get {
                    return builderResult.spatialDimensions
                }
                set (array) {
                    builderResult.spatialDimensions = array
                }
            }
            @discardableResult
            public func setSpatialDimensions(_ value:Array<Int64>) -> Xla.ConvolutionDimensionNumbers.Builder {
                self.spatialDimensions = value
                return self
            }
            @discardableResult
            public func clearSpatialDimensions() -> Xla.ConvolutionDimensionNumbers.Builder {
                builderResult.spatialDimensions.removeAll(keepingCapacity: false)
                return self
            }
            /// The number of the dimension that represents input features in the
            /// convolutional kernel (rhs).
            public var kernelInputFeatureDimension:Int64 {
                get {
                    return builderResult.kernelInputFeatureDimension
                }
                set (value) {
                    builderResult.hasKernelInputFeatureDimension = true
                    builderResult.kernelInputFeatureDimension = value
                }
            }
            public var hasKernelInputFeatureDimension:Bool {
                get {
                    return builderResult.hasKernelInputFeatureDimension
                }
            }
            @discardableResult
            public func setKernelInputFeatureDimension(_ value:Int64) -> Xla.ConvolutionDimensionNumbers.Builder {
                self.kernelInputFeatureDimension = value
                return self
            }
            @discardableResult
            public func clearKernelInputFeatureDimension() -> Xla.ConvolutionDimensionNumbers.Builder{
                builderResult.hasKernelInputFeatureDimension = false
                builderResult.kernelInputFeatureDimension = Int64(0)
                return self
            }
            /// The number of the dimension that represents output features in
            /// the convolutional kernel (rhs).
            public var kernelOutputFeatureDimension:Int64 {
                get {
                    return builderResult.kernelOutputFeatureDimension
                }
                set (value) {
                    builderResult.hasKernelOutputFeatureDimension = true
                    builderResult.kernelOutputFeatureDimension = value
                }
            }
            public var hasKernelOutputFeatureDimension:Bool {
                get {
                    return builderResult.hasKernelOutputFeatureDimension
                }
            }
            @discardableResult
            public func setKernelOutputFeatureDimension(_ value:Int64) -> Xla.ConvolutionDimensionNumbers.Builder {
                self.kernelOutputFeatureDimension = value
                return self
            }
            @discardableResult
            public func clearKernelOutputFeatureDimension() -> Xla.ConvolutionDimensionNumbers.Builder{
                builderResult.hasKernelOutputFeatureDimension = false
                builderResult.kernelOutputFeatureDimension = Int64(0)
                return self
            }
            /// The dimension numbers for the spatial dimensions that the window
            /// moves through in the kernel (rhs). window.strides(0) is the
            /// stride in the kernel_spatial_dimensions(0) dimension.
            public var kernelSpatialDimensions:Array<Int64> {
                get {
                    return builderResult.kernelSpatialDimensions
                }
                set (array) {
                    builderResult.kernelSpatialDimensions = array
                }
            }
            @discardableResult
            public func setKernelSpatialDimensions(_ value:Array<Int64>) -> Xla.ConvolutionDimensionNumbers.Builder {
                self.kernelSpatialDimensions = value
                return self
            }
            @discardableResult
            public func clearKernelSpatialDimensions() -> Xla.ConvolutionDimensionNumbers.Builder {
                builderResult.kernelSpatialDimensions.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.ConvolutionDimensionNumbers.Builder {
                builderResult = Xla.ConvolutionDimensionNumbers()
                return self
            }
            override public func clone() throws -> Xla.ConvolutionDimensionNumbers.Builder {
                return try Xla.ConvolutionDimensionNumbers.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.ConvolutionDimensionNumbers {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.ConvolutionDimensionNumbers {
                let returnMe:Xla.ConvolutionDimensionNumbers = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.ConvolutionDimensionNumbers) throws -> Xla.ConvolutionDimensionNumbers.Builder {
                if other == Xla.ConvolutionDimensionNumbers() {
                    return self
                }
                if other.hasBatchDimension {
                    batchDimension = other.batchDimension
                }
                if other.hasFeatureDimension {
                    featureDimension = other.featureDimension
                }
                if !other.spatialDimensions.isEmpty {
                    builderResult.spatialDimensions += other.spatialDimensions
                }
                if other.hasKernelInputFeatureDimension {
                    kernelInputFeatureDimension = other.kernelInputFeatureDimension
                }
                if other.hasKernelOutputFeatureDimension {
                    kernelOutputFeatureDimension = other.kernelOutputFeatureDimension
                }
                if !other.kernelSpatialDimensions.isEmpty {
                    builderResult.kernelSpatialDimensions += other.kernelSpatialDimensions
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.ConvolutionDimensionNumbers.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ConvolutionDimensionNumbers.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        batchDimension = try codedInputStream.readInt64()

                    case 16:
                        featureDimension = try codedInputStream.readInt64()

                    case 24:
                        kernelInputFeatureDimension = try codedInputStream.readInt64()

                    case 32:
                        kernelOutputFeatureDimension = try codedInputStream.readInt64()

                    case 42:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.spatialDimensions.append(try codedInputStream.readInt64())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 50:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.kernelSpatialDimensions.append(try codedInputStream.readInt64())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.ConvolutionDimensionNumbers.Builder {
                let resultDecodedBuilder = Xla.ConvolutionDimensionNumbers.Builder()
                if let jsonValueBatchDimension = jsonMap["batchDimension"] as? String {
                    resultDecodedBuilder.batchDimension = Int64(jsonValueBatchDimension)!
                } else if let jsonValueBatchDimension = jsonMap["batchDimension"] as? Int {
                    resultDecodedBuilder.batchDimension = Int64(jsonValueBatchDimension)
                }
                if let jsonValueFeatureDimension = jsonMap["featureDimension"] as? String {
                    resultDecodedBuilder.featureDimension = Int64(jsonValueFeatureDimension)!
                } else if let jsonValueFeatureDimension = jsonMap["featureDimension"] as? Int {
                    resultDecodedBuilder.featureDimension = Int64(jsonValueFeatureDimension)
                }
                if let jsonValueSpatialDimensions = jsonMap["spatialDimensions"] as? Array<String> {
                    var jsonArraySpatialDimensions:Array<Int64> = []
                    for oneValueSpatialDimensions in jsonValueSpatialDimensions {
                        jsonArraySpatialDimensions.append(Int64(oneValueSpatialDimensions)!)
                    }
                    resultDecodedBuilder.spatialDimensions = jsonArraySpatialDimensions
                }
                if let jsonValueKernelInputFeatureDimension = jsonMap["kernelInputFeatureDimension"] as? String {
                    resultDecodedBuilder.kernelInputFeatureDimension = Int64(jsonValueKernelInputFeatureDimension)!
                } else if let jsonValueKernelInputFeatureDimension = jsonMap["kernelInputFeatureDimension"] as? Int {
                    resultDecodedBuilder.kernelInputFeatureDimension = Int64(jsonValueKernelInputFeatureDimension)
                }
                if let jsonValueKernelOutputFeatureDimension = jsonMap["kernelOutputFeatureDimension"] as? String {
                    resultDecodedBuilder.kernelOutputFeatureDimension = Int64(jsonValueKernelOutputFeatureDimension)!
                } else if let jsonValueKernelOutputFeatureDimension = jsonMap["kernelOutputFeatureDimension"] as? Int {
                    resultDecodedBuilder.kernelOutputFeatureDimension = Int64(jsonValueKernelOutputFeatureDimension)
                }
                if let jsonValueKernelSpatialDimensions = jsonMap["kernelSpatialDimensions"] as? Array<String> {
                    var jsonArrayKernelSpatialDimensions:Array<Int64> = []
                    for oneValueKernelSpatialDimensions in jsonValueKernelSpatialDimensions {
                        jsonArrayKernelSpatialDimensions.append(Int64(oneValueKernelSpatialDimensions)!)
                    }
                    resultDecodedBuilder.kernelSpatialDimensions = jsonArrayKernelSpatialDimensions
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.ConvolutionDimensionNumbers.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.ConvolutionDimensionNumbers.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ConvolveRequest : GeneratedMessage {

        public static func == (lhs: Xla.ConvolveRequest, rhs: Xla.ConvolveRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasLhs == rhs.hasLhs) && (!lhs.hasLhs || lhs.lhs == rhs.lhs)
            fieldCheck = fieldCheck && (lhs.hasRhs == rhs.hasRhs) && (!lhs.hasRhs || lhs.rhs == rhs.rhs)
            fieldCheck = fieldCheck && (lhs.hasWindow == rhs.hasWindow) && (!lhs.hasWindow || lhs.window == rhs.window)
            fieldCheck = fieldCheck && (lhs.hasDimensionNumbers == rhs.hasDimensionNumbers) && (!lhs.hasDimensionNumbers || lhs.dimensionNumbers == rhs.dimensionNumbers)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var lhs:Xla.ComputationDataHandle!
        public fileprivate(set) var hasLhs:Bool = false
        public fileprivate(set) var rhs:Xla.ComputationDataHandle!
        public fileprivate(set) var hasRhs:Bool = false
        public fileprivate(set) var window:Xla.Window!
        public fileprivate(set) var hasWindow:Bool = false
        public fileprivate(set) var dimensionNumbers:Xla.ConvolutionDimensionNumbers!
        public fileprivate(set) var hasDimensionNumbers:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasLhs {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:lhs)
            }
            if hasRhs {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:rhs)
            }
            if hasWindow {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:window)
            }
            if hasDimensionNumbers {
                try codedOutputStream.writeMessage(fieldNumber: 5, value:dimensionNumbers)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasLhs {
                if let varSizelhs = lhs?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizelhs
                }
            }
            if hasRhs {
                if let varSizerhs = rhs?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizerhs
                }
            }
            if hasWindow {
                if let varSizewindow = window?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizewindow
                }
            }
            if hasDimensionNumbers {
                if let varSizedimensionNumbers = dimensionNumbers?.computeMessageSize(fieldNumber: 5) {
                    serialize_size += varSizedimensionNumbers
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.ConvolveRequest.Builder {
            return Xla.ConvolveRequest.classBuilder() as! Xla.ConvolveRequest.Builder
        }
        public func getBuilder() -> Xla.ConvolveRequest.Builder {
            return classBuilder() as! Xla.ConvolveRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ConvolveRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ConvolveRequest.Builder()
        }
        public func toBuilder() throws -> Xla.ConvolveRequest.Builder {
            return try Xla.ConvolveRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.ConvolveRequest) throws -> Xla.ConvolveRequest.Builder {
            return try Xla.ConvolveRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasLhs {
                jsonMap["lhs"] = try lhs.encode()
            }
            if hasRhs {
                jsonMap["rhs"] = try rhs.encode()
            }
            if hasWindow {
                jsonMap["window"] = try window.encode()
            }
            if hasDimensionNumbers {
                jsonMap["dimensionNumbers"] = try dimensionNumbers.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.ConvolveRequest {
            return try Xla.ConvolveRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.ConvolveRequest {
            return try Xla.ConvolveRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasLhs {
                output += "\(indent) lhs {\n"
                if let outDescLhs = lhs {
                    output += try outDescLhs.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasRhs {
                output += "\(indent) rhs {\n"
                if let outDescRhs = rhs {
                    output += try outDescRhs.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasWindow {
                output += "\(indent) window {\n"
                if let outDescWindow = window {
                    output += try outDescWindow.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasDimensionNumbers {
                output += "\(indent) dimensionNumbers {\n"
                if let outDescDimensionNumbers = dimensionNumbers {
                    output += try outDescDimensionNumbers.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasLhs {
                    if let hashValuelhs = lhs?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuelhs
                    }
                }
                if hasRhs {
                    if let hashValuerhs = rhs?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuerhs
                    }
                }
                if hasWindow {
                    if let hashValuewindow = window?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuewindow
                    }
                }
                if hasDimensionNumbers {
                    if let hashValuedimensionNumbers = dimensionNumbers?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuedimensionNumbers
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.ConvolveRequest"
        }
        override public func className() -> String {
            return "Xla.ConvolveRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.ConvolveRequest = Xla.ConvolveRequest()
            public func getMessage() -> Xla.ConvolveRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var lhs:Xla.ComputationDataHandle! {
                get {
                    if lhsBuilder_ != nil {
                        builderResult.lhs = lhsBuilder_.getMessage()
                    }
                    return builderResult.lhs
                }
                set (value) {
                    builderResult.hasLhs = true
                    builderResult.lhs = value
                }
            }
            public var hasLhs:Bool {
                get {
                    return builderResult.hasLhs
                }
            }
            fileprivate var lhsBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasLhs = true
                }
            }
            public func getLhsBuilder() -> Xla.ComputationDataHandle.Builder {
                if lhsBuilder_ == nil {
                    lhsBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.lhs = lhsBuilder_.getMessage()
                    if lhs != nil {
                        try! lhsBuilder_.mergeFrom(other: lhs)
                    }
                }
                return lhsBuilder_
            }
            @discardableResult
            public func setLhs(_ value:Xla.ComputationDataHandle!) -> Xla.ConvolveRequest.Builder {
                self.lhs = value
                return self
            }
            @discardableResult
            public func mergeLhs(value:Xla.ComputationDataHandle) throws -> Xla.ConvolveRequest.Builder {
                if builderResult.hasLhs {
                    builderResult.lhs = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.lhs).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.lhs = value
                }
                builderResult.hasLhs = true
                return self
            }
            @discardableResult
            public func clearLhs() -> Xla.ConvolveRequest.Builder {
                lhsBuilder_ = nil
                builderResult.hasLhs = false
                builderResult.lhs = nil
                return self
            }
            /// This is the filter/kernel.
            public var rhs:Xla.ComputationDataHandle! {
                get {
                    if rhsBuilder_ != nil {
                        builderResult.rhs = rhsBuilder_.getMessage()
                    }
                    return builderResult.rhs
                }
                set (value) {
                    builderResult.hasRhs = true
                    builderResult.rhs = value
                }
            }
            public var hasRhs:Bool {
                get {
                    return builderResult.hasRhs
                }
            }
            fileprivate var rhsBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasRhs = true
                }
            }
            public func getRhsBuilder() -> Xla.ComputationDataHandle.Builder {
                if rhsBuilder_ == nil {
                    rhsBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.rhs = rhsBuilder_.getMessage()
                    if rhs != nil {
                        try! rhsBuilder_.mergeFrom(other: rhs)
                    }
                }
                return rhsBuilder_
            }
            @discardableResult
            public func setRhs(_ value:Xla.ComputationDataHandle!) -> Xla.ConvolveRequest.Builder {
                self.rhs = value
                return self
            }
            @discardableResult
            public func mergeRhs(value:Xla.ComputationDataHandle) throws -> Xla.ConvolveRequest.Builder {
                if builderResult.hasRhs {
                    builderResult.rhs = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.rhs).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.rhs = value
                }
                builderResult.hasRhs = true
                return self
            }
            @discardableResult
            public func clearRhs() -> Xla.ConvolveRequest.Builder {
                rhsBuilder_ = nil
                builderResult.hasRhs = false
                builderResult.rhs = nil
                return self
            }
            /// Describes the filter/kenel.
            public var window:Xla.Window! {
                get {
                    if windowBuilder_ != nil {
                        builderResult.window = windowBuilder_.getMessage()
                    }
                    return builderResult.window
                }
                set (value) {
                    builderResult.hasWindow = true
                    builderResult.window = value
                }
            }
            public var hasWindow:Bool {
                get {
                    return builderResult.hasWindow
                }
            }
            fileprivate var windowBuilder_:Xla.Window.Builder! {
                didSet {
                    builderResult.hasWindow = true
                }
            }
            public func getWindowBuilder() -> Xla.Window.Builder {
                if windowBuilder_ == nil {
                    windowBuilder_ = Xla.Window.Builder()
                    builderResult.window = windowBuilder_.getMessage()
                    if window != nil {
                        try! windowBuilder_.mergeFrom(other: window)
                    }
                }
                return windowBuilder_
            }
            @discardableResult
            public func setWindow(_ value:Xla.Window!) -> Xla.ConvolveRequest.Builder {
                self.window = value
                return self
            }
            @discardableResult
            public func mergeWindow(value:Xla.Window) throws -> Xla.ConvolveRequest.Builder {
                if builderResult.hasWindow {
                    builderResult.window = try Xla.Window.builderWithPrototype(prototype:builderResult.window).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.window = value
                }
                builderResult.hasWindow = true
                return self
            }
            @discardableResult
            public func clearWindow() -> Xla.ConvolveRequest.Builder {
                windowBuilder_ = nil
                builderResult.hasWindow = false
                builderResult.window = nil
                return self
            }
            public var dimensionNumbers:Xla.ConvolutionDimensionNumbers! {
                get {
                    if dimensionNumbersBuilder_ != nil {
                        builderResult.dimensionNumbers = dimensionNumbersBuilder_.getMessage()
                    }
                    return builderResult.dimensionNumbers
                }
                set (value) {
                    builderResult.hasDimensionNumbers = true
                    builderResult.dimensionNumbers = value
                }
            }
            public var hasDimensionNumbers:Bool {
                get {
                    return builderResult.hasDimensionNumbers
                }
            }
            fileprivate var dimensionNumbersBuilder_:Xla.ConvolutionDimensionNumbers.Builder! {
                didSet {
                    builderResult.hasDimensionNumbers = true
                }
            }
            public func getDimensionNumbersBuilder() -> Xla.ConvolutionDimensionNumbers.Builder {
                if dimensionNumbersBuilder_ == nil {
                    dimensionNumbersBuilder_ = Xla.ConvolutionDimensionNumbers.Builder()
                    builderResult.dimensionNumbers = dimensionNumbersBuilder_.getMessage()
                    if dimensionNumbers != nil {
                        try! dimensionNumbersBuilder_.mergeFrom(other: dimensionNumbers)
                    }
                }
                return dimensionNumbersBuilder_
            }
            @discardableResult
            public func setDimensionNumbers(_ value:Xla.ConvolutionDimensionNumbers!) -> Xla.ConvolveRequest.Builder {
                self.dimensionNumbers = value
                return self
            }
            @discardableResult
            public func mergeDimensionNumbers(value:Xla.ConvolutionDimensionNumbers) throws -> Xla.ConvolveRequest.Builder {
                if builderResult.hasDimensionNumbers {
                    builderResult.dimensionNumbers = try Xla.ConvolutionDimensionNumbers.builderWithPrototype(prototype:builderResult.dimensionNumbers).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.dimensionNumbers = value
                }
                builderResult.hasDimensionNumbers = true
                return self
            }
            @discardableResult
            public func clearDimensionNumbers() -> Xla.ConvolveRequest.Builder {
                dimensionNumbersBuilder_ = nil
                builderResult.hasDimensionNumbers = false
                builderResult.dimensionNumbers = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.ConvolveRequest.Builder {
                builderResult = Xla.ConvolveRequest()
                return self
            }
            override public func clone() throws -> Xla.ConvolveRequest.Builder {
                return try Xla.ConvolveRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.ConvolveRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.ConvolveRequest {
                let returnMe:Xla.ConvolveRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.ConvolveRequest) throws -> Xla.ConvolveRequest.Builder {
                if other == Xla.ConvolveRequest() {
                    return self
                }
                if (other.hasLhs) {
                    try mergeLhs(value: other.lhs)
                }
                if (other.hasRhs) {
                    try mergeRhs(value: other.rhs)
                }
                if (other.hasWindow) {
                    try mergeWindow(value: other.window)
                }
                if (other.hasDimensionNumbers) {
                    try mergeDimensionNumbers(value: other.dimensionNumbers)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.ConvolveRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ConvolveRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 18:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasLhs {
                            try subBuilder.mergeFrom(other: lhs)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        lhs = subBuilder.buildPartial()

                    case 26:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasRhs {
                            try subBuilder.mergeFrom(other: rhs)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        rhs = subBuilder.buildPartial()

                    case 34:
                        let subBuilder:Xla.Window.Builder = Xla.Window.Builder()
                        if hasWindow {
                            try subBuilder.mergeFrom(other: window)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        window = subBuilder.buildPartial()

                    case 42:
                        let subBuilder:Xla.ConvolutionDimensionNumbers.Builder = Xla.ConvolutionDimensionNumbers.Builder()
                        if hasDimensionNumbers {
                            try subBuilder.mergeFrom(other: dimensionNumbers)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        dimensionNumbers = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.ConvolveRequest.Builder {
                let resultDecodedBuilder = Xla.ConvolveRequest.Builder()
                if let jsonValueLhs = jsonMap["lhs"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.lhs = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueLhs).build()

                }
                if let jsonValueRhs = jsonMap["rhs"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.rhs = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueRhs).build()

                }
                if let jsonValueWindow = jsonMap["window"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.window = try Xla.Window.Builder.decodeToBuilder(jsonMap:jsonValueWindow).build()

                }
                if let jsonValueDimensionNumbers = jsonMap["dimensionNumbers"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.dimensionNumbers = try Xla.ConvolutionDimensionNumbers.Builder.decodeToBuilder(jsonMap:jsonValueDimensionNumbers).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.ConvolveRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.ConvolveRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class InfeedRequest : GeneratedMessage {

        public static func == (lhs: Xla.InfeedRequest, rhs: Xla.InfeedRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasShape == rhs.hasShape) && (!lhs.hasShape || lhs.shape == rhs.shape)
            fieldCheck = fieldCheck && (lhs.hasConfig == rhs.hasConfig) && (!lhs.hasConfig || lhs.config == rhs.config)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var shape:Xla.Shape!
        public fileprivate(set) var hasShape:Bool = false
        /// Additional infeed configuration for the backend.
        public fileprivate(set) var config:Data = Data()
        public fileprivate(set) var hasConfig:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasShape {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:shape)
            }
            if hasConfig {
                try codedOutputStream.writeData(fieldNumber: 3, value:config)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasShape {
                if let varSizeshape = shape?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeshape
                }
            }
            if hasConfig {
                serialize_size += config.computeDataSize(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.InfeedRequest.Builder {
            return Xla.InfeedRequest.classBuilder() as! Xla.InfeedRequest.Builder
        }
        public func getBuilder() -> Xla.InfeedRequest.Builder {
            return classBuilder() as! Xla.InfeedRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.InfeedRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.InfeedRequest.Builder()
        }
        public func toBuilder() throws -> Xla.InfeedRequest.Builder {
            return try Xla.InfeedRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.InfeedRequest) throws -> Xla.InfeedRequest.Builder {
            return try Xla.InfeedRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasShape {
                jsonMap["shape"] = try shape.encode()
            }
            if hasConfig {
                jsonMap["config"] = config.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.InfeedRequest {
            return try Xla.InfeedRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.InfeedRequest {
            return try Xla.InfeedRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasShape {
                output += "\(indent) shape {\n"
                if let outDescShape = shape {
                    output += try outDescShape.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasConfig {
                output += "\(indent) config: \(config) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasShape {
                    if let hashValueshape = shape?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueshape
                    }
                }
                if hasConfig {
                    hashCode = (hashCode &* 31) &+ config.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.InfeedRequest"
        }
        override public func className() -> String {
            return "Xla.InfeedRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.InfeedRequest = Xla.InfeedRequest()
            public func getMessage() -> Xla.InfeedRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The shape of the data returned by reading the device's infeed buffer.
            public var shape:Xla.Shape! {
                get {
                    if shapeBuilder_ != nil {
                        builderResult.shape = shapeBuilder_.getMessage()
                    }
                    return builderResult.shape
                }
                set (value) {
                    builderResult.hasShape = true
                    builderResult.shape = value
                }
            }
            public var hasShape:Bool {
                get {
                    return builderResult.hasShape
                }
            }
            fileprivate var shapeBuilder_:Xla.Shape.Builder! {
                didSet {
                    builderResult.hasShape = true
                }
            }
            public func getShapeBuilder() -> Xla.Shape.Builder {
                if shapeBuilder_ == nil {
                    shapeBuilder_ = Xla.Shape.Builder()
                    builderResult.shape = shapeBuilder_.getMessage()
                    if shape != nil {
                        try! shapeBuilder_.mergeFrom(other: shape)
                    }
                }
                return shapeBuilder_
            }
            @discardableResult
            public func setShape(_ value:Xla.Shape!) -> Xla.InfeedRequest.Builder {
                self.shape = value
                return self
            }
            @discardableResult
            public func mergeShape(value:Xla.Shape) throws -> Xla.InfeedRequest.Builder {
                if builderResult.hasShape {
                    builderResult.shape = try Xla.Shape.builderWithPrototype(prototype:builderResult.shape).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.shape = value
                }
                builderResult.hasShape = true
                return self
            }
            @discardableResult
            public func clearShape() -> Xla.InfeedRequest.Builder {
                shapeBuilder_ = nil
                builderResult.hasShape = false
                builderResult.shape = nil
                return self
            }
            /// Additional infeed configuration for the backend.
            public var config:Data {
                get {
                    return builderResult.config
                }
                set (value) {
                    builderResult.hasConfig = true
                    builderResult.config = value
                }
            }
            public var hasConfig:Bool {
                get {
                    return builderResult.hasConfig
                }
            }
            @discardableResult
            public func setConfig(_ value:Data) -> Xla.InfeedRequest.Builder {
                self.config = value
                return self
            }
            @discardableResult
            public func clearConfig() -> Xla.InfeedRequest.Builder{
                builderResult.hasConfig = false
                builderResult.config = Data()
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.InfeedRequest.Builder {
                builderResult = Xla.InfeedRequest()
                return self
            }
            override public func clone() throws -> Xla.InfeedRequest.Builder {
                return try Xla.InfeedRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.InfeedRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.InfeedRequest {
                let returnMe:Xla.InfeedRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.InfeedRequest) throws -> Xla.InfeedRequest.Builder {
                if other == Xla.InfeedRequest() {
                    return self
                }
                if (other.hasShape) {
                    try mergeShape(value: other.shape)
                }
                if other.hasConfig {
                    config = other.config
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.InfeedRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.InfeedRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 18:
                        let subBuilder:Xla.Shape.Builder = Xla.Shape.Builder()
                        if hasShape {
                            try subBuilder.mergeFrom(other: shape)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        shape = subBuilder.buildPartial()

                    case 26:
                        config = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.InfeedRequest.Builder {
                let resultDecodedBuilder = Xla.InfeedRequest.Builder()
                if let jsonValueShape = jsonMap["shape"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.shape = try Xla.Shape.Builder.decodeToBuilder(jsonMap:jsonValueShape).build()

                }
                if let jsonValueConfig = jsonMap["config"] as? String {
                    resultDecodedBuilder.config = Data(base64Encoded:jsonValueConfig, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.InfeedRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.InfeedRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class OutfeedRequest : GeneratedMessage {

        public static func == (lhs: Xla.OutfeedRequest, rhs: Xla.OutfeedRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasShape == rhs.hasShape) && (!lhs.hasShape || lhs.shape == rhs.shape)
            fieldCheck = fieldCheck && (lhs.hasOperand == rhs.hasOperand) && (!lhs.hasOperand || lhs.operand == rhs.operand)
            fieldCheck = fieldCheck && (lhs.hasOutfeedConfig == rhs.hasOutfeedConfig) && (!lhs.hasOutfeedConfig || lhs.outfeedConfig == rhs.outfeedConfig)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var shape:Xla.Shape!
        public fileprivate(set) var hasShape:Bool = false
        public fileprivate(set) var operand:Xla.ComputationDataHandle!
        public fileprivate(set) var hasOperand:Bool = false
        /// Backend-specific information for how to perform the outfeed.
        public fileprivate(set) var outfeedConfig:Data = Data()
        public fileprivate(set) var hasOutfeedConfig:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasShape {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:shape)
            }
            if hasOperand {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:operand)
            }
            if hasOutfeedConfig {
                try codedOutputStream.writeData(fieldNumber: 3, value:outfeedConfig)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasShape {
                if let varSizeshape = shape?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeshape
                }
            }
            if hasOperand {
                if let varSizeoperand = operand?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeoperand
                }
            }
            if hasOutfeedConfig {
                serialize_size += outfeedConfig.computeDataSize(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.OutfeedRequest.Builder {
            return Xla.OutfeedRequest.classBuilder() as! Xla.OutfeedRequest.Builder
        }
        public func getBuilder() -> Xla.OutfeedRequest.Builder {
            return classBuilder() as! Xla.OutfeedRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.OutfeedRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.OutfeedRequest.Builder()
        }
        public func toBuilder() throws -> Xla.OutfeedRequest.Builder {
            return try Xla.OutfeedRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.OutfeedRequest) throws -> Xla.OutfeedRequest.Builder {
            return try Xla.OutfeedRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasShape {
                jsonMap["shape"] = try shape.encode()
            }
            if hasOperand {
                jsonMap["operand"] = try operand.encode()
            }
            if hasOutfeedConfig {
                jsonMap["outfeedConfig"] = outfeedConfig.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.OutfeedRequest {
            return try Xla.OutfeedRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.OutfeedRequest {
            return try Xla.OutfeedRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasShape {
                output += "\(indent) shape {\n"
                if let outDescShape = shape {
                    output += try outDescShape.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasOperand {
                output += "\(indent) operand {\n"
                if let outDescOperand = operand {
                    output += try outDescOperand.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasOutfeedConfig {
                output += "\(indent) outfeedConfig: \(outfeedConfig) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasShape {
                    if let hashValueshape = shape?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueshape
                    }
                }
                if hasOperand {
                    if let hashValueoperand = operand?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoperand
                    }
                }
                if hasOutfeedConfig {
                    hashCode = (hashCode &* 31) &+ outfeedConfig.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.OutfeedRequest"
        }
        override public func className() -> String {
            return "Xla.OutfeedRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.OutfeedRequest = Xla.OutfeedRequest()
            public func getMessage() -> Xla.OutfeedRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The shape of the data returned by reading the device's outfeed buffer.
            public var shape:Xla.Shape! {
                get {
                    if shapeBuilder_ != nil {
                        builderResult.shape = shapeBuilder_.getMessage()
                    }
                    return builderResult.shape
                }
                set (value) {
                    builderResult.hasShape = true
                    builderResult.shape = value
                }
            }
            public var hasShape:Bool {
                get {
                    return builderResult.hasShape
                }
            }
            fileprivate var shapeBuilder_:Xla.Shape.Builder! {
                didSet {
                    builderResult.hasShape = true
                }
            }
            public func getShapeBuilder() -> Xla.Shape.Builder {
                if shapeBuilder_ == nil {
                    shapeBuilder_ = Xla.Shape.Builder()
                    builderResult.shape = shapeBuilder_.getMessage()
                    if shape != nil {
                        try! shapeBuilder_.mergeFrom(other: shape)
                    }
                }
                return shapeBuilder_
            }
            @discardableResult
            public func setShape(_ value:Xla.Shape!) -> Xla.OutfeedRequest.Builder {
                self.shape = value
                return self
            }
            @discardableResult
            public func mergeShape(value:Xla.Shape) throws -> Xla.OutfeedRequest.Builder {
                if builderResult.hasShape {
                    builderResult.shape = try Xla.Shape.builderWithPrototype(prototype:builderResult.shape).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.shape = value
                }
                builderResult.hasShape = true
                return self
            }
            @discardableResult
            public func clearShape() -> Xla.OutfeedRequest.Builder {
                shapeBuilder_ = nil
                builderResult.hasShape = false
                builderResult.shape = nil
                return self
            }
            /// Operand to the Outfeed. Supports tuple.
            public var operand:Xla.ComputationDataHandle! {
                get {
                    if operandBuilder_ != nil {
                        builderResult.operand = operandBuilder_.getMessage()
                    }
                    return builderResult.operand
                }
                set (value) {
                    builderResult.hasOperand = true
                    builderResult.operand = value
                }
            }
            public var hasOperand:Bool {
                get {
                    return builderResult.hasOperand
                }
            }
            fileprivate var operandBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasOperand = true
                }
            }
            public func getOperandBuilder() -> Xla.ComputationDataHandle.Builder {
                if operandBuilder_ == nil {
                    operandBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.operand = operandBuilder_.getMessage()
                    if operand != nil {
                        try! operandBuilder_.mergeFrom(other: operand)
                    }
                }
                return operandBuilder_
            }
            @discardableResult
            public func setOperand(_ value:Xla.ComputationDataHandle!) -> Xla.OutfeedRequest.Builder {
                self.operand = value
                return self
            }
            @discardableResult
            public func mergeOperand(value:Xla.ComputationDataHandle) throws -> Xla.OutfeedRequest.Builder {
                if builderResult.hasOperand {
                    builderResult.operand = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.operand).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.operand = value
                }
                builderResult.hasOperand = true
                return self
            }
            @discardableResult
            public func clearOperand() -> Xla.OutfeedRequest.Builder {
                operandBuilder_ = nil
                builderResult.hasOperand = false
                builderResult.operand = nil
                return self
            }
            /// Backend-specific information for how to perform the outfeed.
            public var outfeedConfig:Data {
                get {
                    return builderResult.outfeedConfig
                }
                set (value) {
                    builderResult.hasOutfeedConfig = true
                    builderResult.outfeedConfig = value
                }
            }
            public var hasOutfeedConfig:Bool {
                get {
                    return builderResult.hasOutfeedConfig
                }
            }
            @discardableResult
            public func setOutfeedConfig(_ value:Data) -> Xla.OutfeedRequest.Builder {
                self.outfeedConfig = value
                return self
            }
            @discardableResult
            public func clearOutfeedConfig() -> Xla.OutfeedRequest.Builder{
                builderResult.hasOutfeedConfig = false
                builderResult.outfeedConfig = Data()
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.OutfeedRequest.Builder {
                builderResult = Xla.OutfeedRequest()
                return self
            }
            override public func clone() throws -> Xla.OutfeedRequest.Builder {
                return try Xla.OutfeedRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.OutfeedRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.OutfeedRequest {
                let returnMe:Xla.OutfeedRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.OutfeedRequest) throws -> Xla.OutfeedRequest.Builder {
                if other == Xla.OutfeedRequest() {
                    return self
                }
                if (other.hasShape) {
                    try mergeShape(value: other.shape)
                }
                if (other.hasOperand) {
                    try mergeOperand(value: other.operand)
                }
                if other.hasOutfeedConfig {
                    outfeedConfig = other.outfeedConfig
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.OutfeedRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.OutfeedRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.Shape.Builder = Xla.Shape.Builder()
                        if hasShape {
                            try subBuilder.mergeFrom(other: shape)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        shape = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasOperand {
                            try subBuilder.mergeFrom(other: operand)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        operand = subBuilder.buildPartial()

                    case 26:
                        outfeedConfig = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.OutfeedRequest.Builder {
                let resultDecodedBuilder = Xla.OutfeedRequest.Builder()
                if let jsonValueShape = jsonMap["shape"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.shape = try Xla.Shape.Builder.decodeToBuilder(jsonMap:jsonValueShape).build()

                }
                if let jsonValueOperand = jsonMap["operand"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.operand = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueOperand).build()

                }
                if let jsonValueOutfeedConfig = jsonMap["outfeedConfig"] as? String {
                    resultDecodedBuilder.outfeedConfig = Data(base64Encoded:jsonValueOutfeedConfig, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.OutfeedRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.OutfeedRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class CallRequest : GeneratedMessage {

        public static func == (lhs: Xla.CallRequest, rhs: Xla.CallRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasToApply == rhs.hasToApply) && (!lhs.hasToApply || lhs.toApply == rhs.toApply)
            fieldCheck = fieldCheck && (lhs.operands == rhs.operands)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var toApply:Xla.ComputationHandle!
        public fileprivate(set) var hasToApply:Bool = false
        public fileprivate(set) var operands:Array<Xla.ComputationDataHandle>  = Array<Xla.ComputationDataHandle>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasToApply {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:toApply)
            }
            for oneElementOperands in operands {
                  try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementOperands)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasToApply {
                if let varSizetoApply = toApply?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizetoApply
                }
            }
            for oneElementOperands in operands {
                serialize_size += oneElementOperands.computeMessageSize(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.CallRequest.Builder {
            return Xla.CallRequest.classBuilder() as! Xla.CallRequest.Builder
        }
        public func getBuilder() -> Xla.CallRequest.Builder {
            return classBuilder() as! Xla.CallRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.CallRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.CallRequest.Builder()
        }
        public func toBuilder() throws -> Xla.CallRequest.Builder {
            return try Xla.CallRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.CallRequest) throws -> Xla.CallRequest.Builder {
            return try Xla.CallRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasToApply {
                jsonMap["toApply"] = try toApply.encode()
            }
            if !operands.isEmpty {
                var jsonArrayOperands:Array<Dictionary<String,Any>> = []
                for oneValueOperands in operands {
                    let ecodedMessageOperands = try oneValueOperands.encode()
                    jsonArrayOperands.append(ecodedMessageOperands)
                }
                jsonMap["operands"] = jsonArrayOperands
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.CallRequest {
            return try Xla.CallRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.CallRequest {
            return try Xla.CallRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasToApply {
                output += "\(indent) toApply {\n"
                if let outDescToApply = toApply {
                    output += try outDescToApply.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            var operandsElementIndex:Int = 0
            for oneElementOperands in operands {
                output += "\(indent) operands[\(operandsElementIndex)] {\n"
                output += try oneElementOperands.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                operandsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasToApply {
                    if let hashValuetoApply = toApply?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuetoApply
                    }
                }
                for oneElementOperands in operands {
                    hashCode = (hashCode &* 31) &+ oneElementOperands.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.CallRequest"
        }
        override public func className() -> String {
            return "Xla.CallRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.CallRequest = Xla.CallRequest()
            public func getMessage() -> Xla.CallRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var toApply:Xla.ComputationHandle! {
                get {
                    if toApplyBuilder_ != nil {
                        builderResult.toApply = toApplyBuilder_.getMessage()
                    }
                    return builderResult.toApply
                }
                set (value) {
                    builderResult.hasToApply = true
                    builderResult.toApply = value
                }
            }
            public var hasToApply:Bool {
                get {
                    return builderResult.hasToApply
                }
            }
            fileprivate var toApplyBuilder_:Xla.ComputationHandle.Builder! {
                didSet {
                    builderResult.hasToApply = true
                }
            }
            public func getToApplyBuilder() -> Xla.ComputationHandle.Builder {
                if toApplyBuilder_ == nil {
                    toApplyBuilder_ = Xla.ComputationHandle.Builder()
                    builderResult.toApply = toApplyBuilder_.getMessage()
                    if toApply != nil {
                        try! toApplyBuilder_.mergeFrom(other: toApply)
                    }
                }
                return toApplyBuilder_
            }
            @discardableResult
            public func setToApply(_ value:Xla.ComputationHandle!) -> Xla.CallRequest.Builder {
                self.toApply = value
                return self
            }
            @discardableResult
            public func mergeToApply(value:Xla.ComputationHandle) throws -> Xla.CallRequest.Builder {
                if builderResult.hasToApply {
                    builderResult.toApply = try Xla.ComputationHandle.builderWithPrototype(prototype:builderResult.toApply).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.toApply = value
                }
                builderResult.hasToApply = true
                return self
            }
            @discardableResult
            public func clearToApply() -> Xla.CallRequest.Builder {
                toApplyBuilder_ = nil
                builderResult.hasToApply = false
                builderResult.toApply = nil
                return self
            }
            public var operands:Array<Xla.ComputationDataHandle> {
                get {
                    return builderResult.operands
                }
                set (value) {
                    builderResult.operands = value
                }
            }
            @discardableResult
            public func setOperands(_ value:Array<Xla.ComputationDataHandle>) -> Xla.CallRequest.Builder {
                self.operands = value
                return self
            }
            @discardableResult
            public func clearOperands() -> Xla.CallRequest.Builder {
                builderResult.operands.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.CallRequest.Builder {
                builderResult = Xla.CallRequest()
                return self
            }
            override public func clone() throws -> Xla.CallRequest.Builder {
                return try Xla.CallRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.CallRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.CallRequest {
                let returnMe:Xla.CallRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.CallRequest) throws -> Xla.CallRequest.Builder {
                if other == Xla.CallRequest() {
                    return self
                }
                if (other.hasToApply) {
                    try mergeToApply(value: other.toApply)
                }
                if !other.operands.isEmpty  {
                     builderResult.operands += other.operands
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.CallRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.CallRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 18:
                        let subBuilder:Xla.ComputationHandle.Builder = Xla.ComputationHandle.Builder()
                        if hasToApply {
                            try subBuilder.mergeFrom(other: toApply)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        toApply = subBuilder.buildPartial()

                    case 26:
                        let subBuilder = Xla.ComputationDataHandle.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        operands.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.CallRequest.Builder {
                let resultDecodedBuilder = Xla.CallRequest.Builder()
                if let jsonValueToApply = jsonMap["toApply"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.toApply = try Xla.ComputationHandle.Builder.decodeToBuilder(jsonMap:jsonValueToApply).build()

                }
                if let jsonValueOperands = jsonMap["operands"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayOperands:Array<Xla.ComputationDataHandle> = []
                    for oneValueOperands in jsonValueOperands {
                        let messageFromStringOperands = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:oneValueOperands).build()

                        jsonArrayOperands.append(messageFromStringOperands)
                    }
                    resultDecodedBuilder.operands = jsonArrayOperands
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.CallRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.CallRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class CustomCallRequest : GeneratedMessage {

        public static func == (lhs: Xla.CustomCallRequest, rhs: Xla.CustomCallRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasCallTargetName == rhs.hasCallTargetName) && (!lhs.hasCallTargetName || lhs.callTargetName == rhs.callTargetName)
            fieldCheck = fieldCheck && (lhs.operands == rhs.operands)
            fieldCheck = fieldCheck && (lhs.hasShape == rhs.hasShape) && (!lhs.hasShape || lhs.shape == rhs.shape)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var callTargetName:String = ""
        public fileprivate(set) var hasCallTargetName:Bool = false

        public fileprivate(set) var operands:Array<Xla.ComputationDataHandle>  = Array<Xla.ComputationDataHandle>()
        public fileprivate(set) var shape:Xla.Shape!
        public fileprivate(set) var hasShape:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasCallTargetName {
                try codedOutputStream.writeString(fieldNumber: 2, value:callTargetName)
            }
            for oneElementOperands in operands {
                  try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementOperands)
            }
            if hasShape {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:shape)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasCallTargetName {
                serialize_size += callTargetName.computeStringSize(fieldNumber: 2)
            }
            for oneElementOperands in operands {
                serialize_size += oneElementOperands.computeMessageSize(fieldNumber: 3)
            }
            if hasShape {
                if let varSizeshape = shape?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizeshape
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.CustomCallRequest.Builder {
            return Xla.CustomCallRequest.classBuilder() as! Xla.CustomCallRequest.Builder
        }
        public func getBuilder() -> Xla.CustomCallRequest.Builder {
            return classBuilder() as! Xla.CustomCallRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.CustomCallRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.CustomCallRequest.Builder()
        }
        public func toBuilder() throws -> Xla.CustomCallRequest.Builder {
            return try Xla.CustomCallRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.CustomCallRequest) throws -> Xla.CustomCallRequest.Builder {
            return try Xla.CustomCallRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasCallTargetName {
                jsonMap["callTargetName"] = callTargetName
            }
            if !operands.isEmpty {
                var jsonArrayOperands:Array<Dictionary<String,Any>> = []
                for oneValueOperands in operands {
                    let ecodedMessageOperands = try oneValueOperands.encode()
                    jsonArrayOperands.append(ecodedMessageOperands)
                }
                jsonMap["operands"] = jsonArrayOperands
            }
            if hasShape {
                jsonMap["shape"] = try shape.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.CustomCallRequest {
            return try Xla.CustomCallRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.CustomCallRequest {
            return try Xla.CustomCallRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasCallTargetName {
                output += "\(indent) callTargetName: \(callTargetName) \n"
            }
            var operandsElementIndex:Int = 0
            for oneElementOperands in operands {
                output += "\(indent) operands[\(operandsElementIndex)] {\n"
                output += try oneElementOperands.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                operandsElementIndex += 1
            }
            if hasShape {
                output += "\(indent) shape {\n"
                if let outDescShape = shape {
                    output += try outDescShape.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasCallTargetName {
                    hashCode = (hashCode &* 31) &+ callTargetName.hashValue
                }
                for oneElementOperands in operands {
                    hashCode = (hashCode &* 31) &+ oneElementOperands.hashValue
                }
                if hasShape {
                    if let hashValueshape = shape?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueshape
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.CustomCallRequest"
        }
        override public func className() -> String {
            return "Xla.CustomCallRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.CustomCallRequest = Xla.CustomCallRequest()
            public func getMessage() -> Xla.CustomCallRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var callTargetName:String {
                get {
                    return builderResult.callTargetName
                }
                set (value) {
                    builderResult.hasCallTargetName = true
                    builderResult.callTargetName = value
                }
            }
            public var hasCallTargetName:Bool {
                get {
                    return builderResult.hasCallTargetName
                }
            }
            @discardableResult
            public func setCallTargetName(_ value:String) -> Xla.CustomCallRequest.Builder {
                self.callTargetName = value
                return self
            }
            @discardableResult
            public func clearCallTargetName() -> Xla.CustomCallRequest.Builder{
                builderResult.hasCallTargetName = false
                builderResult.callTargetName = ""
                return self
            }
            public var operands:Array<Xla.ComputationDataHandle> {
                get {
                    return builderResult.operands
                }
                set (value) {
                    builderResult.operands = value
                }
            }
            @discardableResult
            public func setOperands(_ value:Array<Xla.ComputationDataHandle>) -> Xla.CustomCallRequest.Builder {
                self.operands = value
                return self
            }
            @discardableResult
            public func clearOperands() -> Xla.CustomCallRequest.Builder {
                builderResult.operands.removeAll(keepingCapacity: false)
                return self
            }
            public var shape:Xla.Shape! {
                get {
                    if shapeBuilder_ != nil {
                        builderResult.shape = shapeBuilder_.getMessage()
                    }
                    return builderResult.shape
                }
                set (value) {
                    builderResult.hasShape = true
                    builderResult.shape = value
                }
            }
            public var hasShape:Bool {
                get {
                    return builderResult.hasShape
                }
            }
            fileprivate var shapeBuilder_:Xla.Shape.Builder! {
                didSet {
                    builderResult.hasShape = true
                }
            }
            public func getShapeBuilder() -> Xla.Shape.Builder {
                if shapeBuilder_ == nil {
                    shapeBuilder_ = Xla.Shape.Builder()
                    builderResult.shape = shapeBuilder_.getMessage()
                    if shape != nil {
                        try! shapeBuilder_.mergeFrom(other: shape)
                    }
                }
                return shapeBuilder_
            }
            @discardableResult
            public func setShape(_ value:Xla.Shape!) -> Xla.CustomCallRequest.Builder {
                self.shape = value
                return self
            }
            @discardableResult
            public func mergeShape(value:Xla.Shape) throws -> Xla.CustomCallRequest.Builder {
                if builderResult.hasShape {
                    builderResult.shape = try Xla.Shape.builderWithPrototype(prototype:builderResult.shape).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.shape = value
                }
                builderResult.hasShape = true
                return self
            }
            @discardableResult
            public func clearShape() -> Xla.CustomCallRequest.Builder {
                shapeBuilder_ = nil
                builderResult.hasShape = false
                builderResult.shape = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.CustomCallRequest.Builder {
                builderResult = Xla.CustomCallRequest()
                return self
            }
            override public func clone() throws -> Xla.CustomCallRequest.Builder {
                return try Xla.CustomCallRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.CustomCallRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.CustomCallRequest {
                let returnMe:Xla.CustomCallRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.CustomCallRequest) throws -> Xla.CustomCallRequest.Builder {
                if other == Xla.CustomCallRequest() {
                    return self
                }
                if other.hasCallTargetName {
                    callTargetName = other.callTargetName
                }
                if !other.operands.isEmpty  {
                     builderResult.operands += other.operands
                }
                if (other.hasShape) {
                    try mergeShape(value: other.shape)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.CustomCallRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.CustomCallRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 18:
                        callTargetName = try codedInputStream.readString()

                    case 26:
                        let subBuilder = Xla.ComputationDataHandle.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        operands.append(subBuilder.buildPartial())

                    case 34:
                        let subBuilder:Xla.Shape.Builder = Xla.Shape.Builder()
                        if hasShape {
                            try subBuilder.mergeFrom(other: shape)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        shape = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.CustomCallRequest.Builder {
                let resultDecodedBuilder = Xla.CustomCallRequest.Builder()
                if let jsonValueCallTargetName = jsonMap["callTargetName"] as? String {
                    resultDecodedBuilder.callTargetName = jsonValueCallTargetName
                }
                if let jsonValueOperands = jsonMap["operands"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayOperands:Array<Xla.ComputationDataHandle> = []
                    for oneValueOperands in jsonValueOperands {
                        let messageFromStringOperands = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:oneValueOperands).build()

                        jsonArrayOperands.append(messageFromStringOperands)
                    }
                    resultDecodedBuilder.operands = jsonArrayOperands
                }
                if let jsonValueShape = jsonMap["shape"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.shape = try Xla.Shape.Builder.decodeToBuilder(jsonMap:jsonValueShape).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.CustomCallRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.CustomCallRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class MapRequest : GeneratedMessage {

        public static func == (lhs: Xla.MapRequest, rhs: Xla.MapRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.operands == rhs.operands)
            fieldCheck = fieldCheck && (lhs.hasToApply == rhs.hasToApply) && (!lhs.hasToApply || lhs.toApply == rhs.toApply)
            fieldCheck = fieldCheck && (lhs.staticOperands == rhs.staticOperands)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var operands:Array<Xla.ComputationDataHandle>  = Array<Xla.ComputationDataHandle>()
        public fileprivate(set) var toApply:Xla.ComputationHandle!
        public fileprivate(set) var hasToApply:Bool = false
        public fileprivate(set) var staticOperands:Array<Xla.ComputationDataHandle>  = Array<Xla.ComputationDataHandle>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementOperands in operands {
                  try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementOperands)
            }
            if hasToApply {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:toApply)
            }
            for oneElementStaticOperands in staticOperands {
                  try codedOutputStream.writeMessage(fieldNumber: 4, value:oneElementStaticOperands)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementOperands in operands {
                serialize_size += oneElementOperands.computeMessageSize(fieldNumber: 2)
            }
            if hasToApply {
                if let varSizetoApply = toApply?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizetoApply
                }
            }
            for oneElementStaticOperands in staticOperands {
                serialize_size += oneElementStaticOperands.computeMessageSize(fieldNumber: 4)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.MapRequest.Builder {
            return Xla.MapRequest.classBuilder() as! Xla.MapRequest.Builder
        }
        public func getBuilder() -> Xla.MapRequest.Builder {
            return classBuilder() as! Xla.MapRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.MapRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.MapRequest.Builder()
        }
        public func toBuilder() throws -> Xla.MapRequest.Builder {
            return try Xla.MapRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.MapRequest) throws -> Xla.MapRequest.Builder {
            return try Xla.MapRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !operands.isEmpty {
                var jsonArrayOperands:Array<Dictionary<String,Any>> = []
                for oneValueOperands in operands {
                    let ecodedMessageOperands = try oneValueOperands.encode()
                    jsonArrayOperands.append(ecodedMessageOperands)
                }
                jsonMap["operands"] = jsonArrayOperands
            }
            if hasToApply {
                jsonMap["toApply"] = try toApply.encode()
            }
            if !staticOperands.isEmpty {
                var jsonArrayStaticOperands:Array<Dictionary<String,Any>> = []
                for oneValueStaticOperands in staticOperands {
                    let ecodedMessageStaticOperands = try oneValueStaticOperands.encode()
                    jsonArrayStaticOperands.append(ecodedMessageStaticOperands)
                }
                jsonMap["staticOperands"] = jsonArrayStaticOperands
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.MapRequest {
            return try Xla.MapRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.MapRequest {
            return try Xla.MapRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var operandsElementIndex:Int = 0
            for oneElementOperands in operands {
                output += "\(indent) operands[\(operandsElementIndex)] {\n"
                output += try oneElementOperands.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                operandsElementIndex += 1
            }
            if hasToApply {
                output += "\(indent) toApply {\n"
                if let outDescToApply = toApply {
                    output += try outDescToApply.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            var staticOperandsElementIndex:Int = 0
            for oneElementStaticOperands in staticOperands {
                output += "\(indent) staticOperands[\(staticOperandsElementIndex)] {\n"
                output += try oneElementStaticOperands.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                staticOperandsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementOperands in operands {
                    hashCode = (hashCode &* 31) &+ oneElementOperands.hashValue
                }
                if hasToApply {
                    if let hashValuetoApply = toApply?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuetoApply
                    }
                }
                for oneElementStaticOperands in staticOperands {
                    hashCode = (hashCode &* 31) &+ oneElementStaticOperands.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.MapRequest"
        }
        override public func className() -> String {
            return "Xla.MapRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.MapRequest = Xla.MapRequest()
            public func getMessage() -> Xla.MapRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var operands:Array<Xla.ComputationDataHandle> {
                get {
                    return builderResult.operands
                }
                set (value) {
                    builderResult.operands = value
                }
            }
            @discardableResult
            public func setOperands(_ value:Array<Xla.ComputationDataHandle>) -> Xla.MapRequest.Builder {
                self.operands = value
                return self
            }
            @discardableResult
            public func clearOperands() -> Xla.MapRequest.Builder {
                builderResult.operands.removeAll(keepingCapacity: false)
                return self
            }
            public var toApply:Xla.ComputationHandle! {
                get {
                    if toApplyBuilder_ != nil {
                        builderResult.toApply = toApplyBuilder_.getMessage()
                    }
                    return builderResult.toApply
                }
                set (value) {
                    builderResult.hasToApply = true
                    builderResult.toApply = value
                }
            }
            public var hasToApply:Bool {
                get {
                    return builderResult.hasToApply
                }
            }
            fileprivate var toApplyBuilder_:Xla.ComputationHandle.Builder! {
                didSet {
                    builderResult.hasToApply = true
                }
            }
            public func getToApplyBuilder() -> Xla.ComputationHandle.Builder {
                if toApplyBuilder_ == nil {
                    toApplyBuilder_ = Xla.ComputationHandle.Builder()
                    builderResult.toApply = toApplyBuilder_.getMessage()
                    if toApply != nil {
                        try! toApplyBuilder_.mergeFrom(other: toApply)
                    }
                }
                return toApplyBuilder_
            }
            @discardableResult
            public func setToApply(_ value:Xla.ComputationHandle!) -> Xla.MapRequest.Builder {
                self.toApply = value
                return self
            }
            @discardableResult
            public func mergeToApply(value:Xla.ComputationHandle) throws -> Xla.MapRequest.Builder {
                if builderResult.hasToApply {
                    builderResult.toApply = try Xla.ComputationHandle.builderWithPrototype(prototype:builderResult.toApply).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.toApply = value
                }
                builderResult.hasToApply = true
                return self
            }
            @discardableResult
            public func clearToApply() -> Xla.MapRequest.Builder {
                toApplyBuilder_ = nil
                builderResult.hasToApply = false
                builderResult.toApply = nil
                return self
            }
            public var staticOperands:Array<Xla.ComputationDataHandle> {
                get {
                    return builderResult.staticOperands
                }
                set (value) {
                    builderResult.staticOperands = value
                }
            }
            @discardableResult
            public func setStaticOperands(_ value:Array<Xla.ComputationDataHandle>) -> Xla.MapRequest.Builder {
                self.staticOperands = value
                return self
            }
            @discardableResult
            public func clearStaticOperands() -> Xla.MapRequest.Builder {
                builderResult.staticOperands.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.MapRequest.Builder {
                builderResult = Xla.MapRequest()
                return self
            }
            override public func clone() throws -> Xla.MapRequest.Builder {
                return try Xla.MapRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.MapRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.MapRequest {
                let returnMe:Xla.MapRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.MapRequest) throws -> Xla.MapRequest.Builder {
                if other == Xla.MapRequest() {
                    return self
                }
                if !other.operands.isEmpty  {
                     builderResult.operands += other.operands
                }
                if (other.hasToApply) {
                    try mergeToApply(value: other.toApply)
                }
                if !other.staticOperands.isEmpty  {
                     builderResult.staticOperands += other.staticOperands
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.MapRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.MapRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 18:
                        let subBuilder = Xla.ComputationDataHandle.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        operands.append(subBuilder.buildPartial())

                    case 26:
                        let subBuilder:Xla.ComputationHandle.Builder = Xla.ComputationHandle.Builder()
                        if hasToApply {
                            try subBuilder.mergeFrom(other: toApply)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        toApply = subBuilder.buildPartial()

                    case 34:
                        let subBuilder = Xla.ComputationDataHandle.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        staticOperands.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.MapRequest.Builder {
                let resultDecodedBuilder = Xla.MapRequest.Builder()
                if let jsonValueOperands = jsonMap["operands"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayOperands:Array<Xla.ComputationDataHandle> = []
                    for oneValueOperands in jsonValueOperands {
                        let messageFromStringOperands = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:oneValueOperands).build()

                        jsonArrayOperands.append(messageFromStringOperands)
                    }
                    resultDecodedBuilder.operands = jsonArrayOperands
                }
                if let jsonValueToApply = jsonMap["toApply"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.toApply = try Xla.ComputationHandle.Builder.decodeToBuilder(jsonMap:jsonValueToApply).build()

                }
                if let jsonValueStaticOperands = jsonMap["staticOperands"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayStaticOperands:Array<Xla.ComputationDataHandle> = []
                    for oneValueStaticOperands in jsonValueStaticOperands {
                        let messageFromStringStaticOperands = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:oneValueStaticOperands).build()

                        jsonArrayStaticOperands.append(messageFromStringStaticOperands)
                    }
                    resultDecodedBuilder.staticOperands = jsonArrayStaticOperands
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.MapRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.MapRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ReduceRequest : GeneratedMessage {

        public static func == (lhs: Xla.ReduceRequest, rhs: Xla.ReduceRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasOperand == rhs.hasOperand) && (!lhs.hasOperand || lhs.operand == rhs.operand)
            fieldCheck = fieldCheck && (lhs.hasInitValue == rhs.hasInitValue) && (!lhs.hasInitValue || lhs.initValue == rhs.initValue)
            fieldCheck = fieldCheck && (lhs.dimensions == rhs.dimensions)
            fieldCheck = fieldCheck && (lhs.hasToApply == rhs.hasToApply) && (!lhs.hasToApply || lhs.toApply == rhs.toApply)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var operand:Xla.ComputationDataHandle!
        public fileprivate(set) var hasOperand:Bool = false
        public fileprivate(set) var initValue:Xla.ComputationDataHandle!
        public fileprivate(set) var hasInitValue:Bool = false
        /// The dimensions to reduce over.
        public fileprivate(set) var dimensions:Array<Int64> = Array<Int64>()
        private var dimensionsMemoizedSerializedSize:Int32 = -1
        public fileprivate(set) var toApply:Xla.ComputationHandle!
        public fileprivate(set) var hasToApply:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasOperand {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:operand)
            }
            if hasInitValue {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:initValue)
            }
            if !dimensions.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 34)
                try codedOutputStream.writeRawVarint32(value: dimensionsMemoizedSerializedSize)
                for oneValuedimensions in dimensions {
                    try codedOutputStream.writeInt64NoTag(value: oneValuedimensions)
                }
            }
            if hasToApply {
                try codedOutputStream.writeMessage(fieldNumber: 5, value:toApply)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasOperand {
                if let varSizeoperand = operand?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeoperand
                }
            }
            if hasInitValue {
                if let varSizeinitValue = initValue?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizeinitValue
                }
            }
            var dataSizeDimensions:Int32 = 0
            for oneValuedimensions in dimensions {
                dataSizeDimensions += oneValuedimensions.computeInt64SizeNoTag()
            }
            serialize_size += dataSizeDimensions
            if !dimensions.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeDimensions.computeInt32SizeNoTag()
            }
            dimensionsMemoizedSerializedSize = dataSizeDimensions
            if hasToApply {
                if let varSizetoApply = toApply?.computeMessageSize(fieldNumber: 5) {
                    serialize_size += varSizetoApply
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.ReduceRequest.Builder {
            return Xla.ReduceRequest.classBuilder() as! Xla.ReduceRequest.Builder
        }
        public func getBuilder() -> Xla.ReduceRequest.Builder {
            return classBuilder() as! Xla.ReduceRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ReduceRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ReduceRequest.Builder()
        }
        public func toBuilder() throws -> Xla.ReduceRequest.Builder {
            return try Xla.ReduceRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.ReduceRequest) throws -> Xla.ReduceRequest.Builder {
            return try Xla.ReduceRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasOperand {
                jsonMap["operand"] = try operand.encode()
            }
            if hasInitValue {
                jsonMap["initValue"] = try initValue.encode()
            }
            if !dimensions.isEmpty {
                var jsonArrayDimensions:Array<String> = []
                for oneValueDimensions in dimensions {
                    jsonArrayDimensions.append("\(oneValueDimensions)")
                }
                jsonMap["dimensions"] = jsonArrayDimensions
            }
            if hasToApply {
                jsonMap["toApply"] = try toApply.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.ReduceRequest {
            return try Xla.ReduceRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.ReduceRequest {
            return try Xla.ReduceRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasOperand {
                output += "\(indent) operand {\n"
                if let outDescOperand = operand {
                    output += try outDescOperand.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasInitValue {
                output += "\(indent) initValue {\n"
                if let outDescInitValue = initValue {
                    output += try outDescInitValue.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            var dimensionsElementIndex:Int = 0
            for oneValueDimensions in dimensions  {
                output += "\(indent) dimensions[\(dimensionsElementIndex)]: \(oneValueDimensions)\n"
                dimensionsElementIndex += 1
            }
            if hasToApply {
                output += "\(indent) toApply {\n"
                if let outDescToApply = toApply {
                    output += try outDescToApply.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasOperand {
                    if let hashValueoperand = operand?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoperand
                    }
                }
                if hasInitValue {
                    if let hashValueinitValue = initValue?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueinitValue
                    }
                }
                for oneValueDimensions in dimensions {
                    hashCode = (hashCode &* 31) &+ oneValueDimensions.hashValue
                }
                if hasToApply {
                    if let hashValuetoApply = toApply?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuetoApply
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.ReduceRequest"
        }
        override public func className() -> String {
            return "Xla.ReduceRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.ReduceRequest = Xla.ReduceRequest()
            public func getMessage() -> Xla.ReduceRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Operand to the reduction.
            public var operand:Xla.ComputationDataHandle! {
                get {
                    if operandBuilder_ != nil {
                        builderResult.operand = operandBuilder_.getMessage()
                    }
                    return builderResult.operand
                }
                set (value) {
                    builderResult.hasOperand = true
                    builderResult.operand = value
                }
            }
            public var hasOperand:Bool {
                get {
                    return builderResult.hasOperand
                }
            }
            fileprivate var operandBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasOperand = true
                }
            }
            public func getOperandBuilder() -> Xla.ComputationDataHandle.Builder {
                if operandBuilder_ == nil {
                    operandBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.operand = operandBuilder_.getMessage()
                    if operand != nil {
                        try! operandBuilder_.mergeFrom(other: operand)
                    }
                }
                return operandBuilder_
            }
            @discardableResult
            public func setOperand(_ value:Xla.ComputationDataHandle!) -> Xla.ReduceRequest.Builder {
                self.operand = value
                return self
            }
            @discardableResult
            public func mergeOperand(value:Xla.ComputationDataHandle) throws -> Xla.ReduceRequest.Builder {
                if builderResult.hasOperand {
                    builderResult.operand = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.operand).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.operand = value
                }
                builderResult.hasOperand = true
                return self
            }
            @discardableResult
            public func clearOperand() -> Xla.ReduceRequest.Builder {
                operandBuilder_ = nil
                builderResult.hasOperand = false
                builderResult.operand = nil
                return self
            }
            /// Initial value for the reduction. This must be consistent with the result
            /// shape of to_apply.
            public var initValue:Xla.ComputationDataHandle! {
                get {
                    if initValueBuilder_ != nil {
                        builderResult.initValue = initValueBuilder_.getMessage()
                    }
                    return builderResult.initValue
                }
                set (value) {
                    builderResult.hasInitValue = true
                    builderResult.initValue = value
                }
            }
            public var hasInitValue:Bool {
                get {
                    return builderResult.hasInitValue
                }
            }
            fileprivate var initValueBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasInitValue = true
                }
            }
            public func getInitValueBuilder() -> Xla.ComputationDataHandle.Builder {
                if initValueBuilder_ == nil {
                    initValueBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.initValue = initValueBuilder_.getMessage()
                    if initValue != nil {
                        try! initValueBuilder_.mergeFrom(other: initValue)
                    }
                }
                return initValueBuilder_
            }
            @discardableResult
            public func setInitValue(_ value:Xla.ComputationDataHandle!) -> Xla.ReduceRequest.Builder {
                self.initValue = value
                return self
            }
            @discardableResult
            public func mergeInitValue(value:Xla.ComputationDataHandle) throws -> Xla.ReduceRequest.Builder {
                if builderResult.hasInitValue {
                    builderResult.initValue = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.initValue).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.initValue = value
                }
                builderResult.hasInitValue = true
                return self
            }
            @discardableResult
            public func clearInitValue() -> Xla.ReduceRequest.Builder {
                initValueBuilder_ = nil
                builderResult.hasInitValue = false
                builderResult.initValue = nil
                return self
            }
            /// The dimensions to reduce over.
            public var dimensions:Array<Int64> {
                get {
                    return builderResult.dimensions
                }
                set (array) {
                    builderResult.dimensions = array
                }
            }
            @discardableResult
            public func setDimensions(_ value:Array<Int64>) -> Xla.ReduceRequest.Builder {
                self.dimensions = value
                return self
            }
            @discardableResult
            public func clearDimensions() -> Xla.ReduceRequest.Builder {
                builderResult.dimensions.removeAll(keepingCapacity: false)
                return self
            }
            /// The computation to apply in the reduction.
            public var toApply:Xla.ComputationHandle! {
                get {
                    if toApplyBuilder_ != nil {
                        builderResult.toApply = toApplyBuilder_.getMessage()
                    }
                    return builderResult.toApply
                }
                set (value) {
                    builderResult.hasToApply = true
                    builderResult.toApply = value
                }
            }
            public var hasToApply:Bool {
                get {
                    return builderResult.hasToApply
                }
            }
            fileprivate var toApplyBuilder_:Xla.ComputationHandle.Builder! {
                didSet {
                    builderResult.hasToApply = true
                }
            }
            public func getToApplyBuilder() -> Xla.ComputationHandle.Builder {
                if toApplyBuilder_ == nil {
                    toApplyBuilder_ = Xla.ComputationHandle.Builder()
                    builderResult.toApply = toApplyBuilder_.getMessage()
                    if toApply != nil {
                        try! toApplyBuilder_.mergeFrom(other: toApply)
                    }
                }
                return toApplyBuilder_
            }
            @discardableResult
            public func setToApply(_ value:Xla.ComputationHandle!) -> Xla.ReduceRequest.Builder {
                self.toApply = value
                return self
            }
            @discardableResult
            public func mergeToApply(value:Xla.ComputationHandle) throws -> Xla.ReduceRequest.Builder {
                if builderResult.hasToApply {
                    builderResult.toApply = try Xla.ComputationHandle.builderWithPrototype(prototype:builderResult.toApply).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.toApply = value
                }
                builderResult.hasToApply = true
                return self
            }
            @discardableResult
            public func clearToApply() -> Xla.ReduceRequest.Builder {
                toApplyBuilder_ = nil
                builderResult.hasToApply = false
                builderResult.toApply = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.ReduceRequest.Builder {
                builderResult = Xla.ReduceRequest()
                return self
            }
            override public func clone() throws -> Xla.ReduceRequest.Builder {
                return try Xla.ReduceRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.ReduceRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.ReduceRequest {
                let returnMe:Xla.ReduceRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.ReduceRequest) throws -> Xla.ReduceRequest.Builder {
                if other == Xla.ReduceRequest() {
                    return self
                }
                if (other.hasOperand) {
                    try mergeOperand(value: other.operand)
                }
                if (other.hasInitValue) {
                    try mergeInitValue(value: other.initValue)
                }
                if !other.dimensions.isEmpty {
                    builderResult.dimensions += other.dimensions
                }
                if (other.hasToApply) {
                    try mergeToApply(value: other.toApply)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.ReduceRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ReduceRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 18:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasOperand {
                            try subBuilder.mergeFrom(other: operand)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        operand = subBuilder.buildPartial()

                    case 26:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasInitValue {
                            try subBuilder.mergeFrom(other: initValue)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        initValue = subBuilder.buildPartial()

                    case 34:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.dimensions.append(try codedInputStream.readInt64())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 42:
                        let subBuilder:Xla.ComputationHandle.Builder = Xla.ComputationHandle.Builder()
                        if hasToApply {
                            try subBuilder.mergeFrom(other: toApply)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        toApply = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.ReduceRequest.Builder {
                let resultDecodedBuilder = Xla.ReduceRequest.Builder()
                if let jsonValueOperand = jsonMap["operand"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.operand = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueOperand).build()

                }
                if let jsonValueInitValue = jsonMap["initValue"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.initValue = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueInitValue).build()

                }
                if let jsonValueDimensions = jsonMap["dimensions"] as? Array<String> {
                    var jsonArrayDimensions:Array<Int64> = []
                    for oneValueDimensions in jsonValueDimensions {
                        jsonArrayDimensions.append(Int64(oneValueDimensions)!)
                    }
                    resultDecodedBuilder.dimensions = jsonArrayDimensions
                }
                if let jsonValueToApply = jsonMap["toApply"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.toApply = try Xla.ComputationHandle.Builder.decodeToBuilder(jsonMap:jsonValueToApply).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.ReduceRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.ReduceRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ReduceWindowRequest : GeneratedMessage {

        public static func == (lhs: Xla.ReduceWindowRequest, rhs: Xla.ReduceWindowRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasOperand == rhs.hasOperand) && (!lhs.hasOperand || lhs.operand == rhs.operand)
            fieldCheck = fieldCheck && (lhs.hasInitValue == rhs.hasInitValue) && (!lhs.hasInitValue || lhs.initValue == rhs.initValue)
            fieldCheck = fieldCheck && (lhs.hasWindow == rhs.hasWindow) && (!lhs.hasWindow || lhs.window == rhs.window)
            fieldCheck = fieldCheck && (lhs.hasToApply == rhs.hasToApply) && (!lhs.hasToApply || lhs.toApply == rhs.toApply)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var operand:Xla.ComputationDataHandle!
        public fileprivate(set) var hasOperand:Bool = false
        public fileprivate(set) var initValue:Xla.ComputationDataHandle!
        public fileprivate(set) var hasInitValue:Bool = false
        public fileprivate(set) var window:Xla.Window!
        public fileprivate(set) var hasWindow:Bool = false
        public fileprivate(set) var toApply:Xla.ComputationHandle!
        public fileprivate(set) var hasToApply:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasOperand {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:operand)
            }
            if hasInitValue {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:initValue)
            }
            if hasWindow {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:window)
            }
            if hasToApply {
                try codedOutputStream.writeMessage(fieldNumber: 5, value:toApply)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasOperand {
                if let varSizeoperand = operand?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeoperand
                }
            }
            if hasInitValue {
                if let varSizeinitValue = initValue?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizeinitValue
                }
            }
            if hasWindow {
                if let varSizewindow = window?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizewindow
                }
            }
            if hasToApply {
                if let varSizetoApply = toApply?.computeMessageSize(fieldNumber: 5) {
                    serialize_size += varSizetoApply
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.ReduceWindowRequest.Builder {
            return Xla.ReduceWindowRequest.classBuilder() as! Xla.ReduceWindowRequest.Builder
        }
        public func getBuilder() -> Xla.ReduceWindowRequest.Builder {
            return classBuilder() as! Xla.ReduceWindowRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ReduceWindowRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ReduceWindowRequest.Builder()
        }
        public func toBuilder() throws -> Xla.ReduceWindowRequest.Builder {
            return try Xla.ReduceWindowRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.ReduceWindowRequest) throws -> Xla.ReduceWindowRequest.Builder {
            return try Xla.ReduceWindowRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasOperand {
                jsonMap["operand"] = try operand.encode()
            }
            if hasInitValue {
                jsonMap["initValue"] = try initValue.encode()
            }
            if hasWindow {
                jsonMap["window"] = try window.encode()
            }
            if hasToApply {
                jsonMap["toApply"] = try toApply.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.ReduceWindowRequest {
            return try Xla.ReduceWindowRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.ReduceWindowRequest {
            return try Xla.ReduceWindowRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasOperand {
                output += "\(indent) operand {\n"
                if let outDescOperand = operand {
                    output += try outDescOperand.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasInitValue {
                output += "\(indent) initValue {\n"
                if let outDescInitValue = initValue {
                    output += try outDescInitValue.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasWindow {
                output += "\(indent) window {\n"
                if let outDescWindow = window {
                    output += try outDescWindow.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasToApply {
                output += "\(indent) toApply {\n"
                if let outDescToApply = toApply {
                    output += try outDescToApply.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasOperand {
                    if let hashValueoperand = operand?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoperand
                    }
                }
                if hasInitValue {
                    if let hashValueinitValue = initValue?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueinitValue
                    }
                }
                if hasWindow {
                    if let hashValuewindow = window?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuewindow
                    }
                }
                if hasToApply {
                    if let hashValuetoApply = toApply?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuetoApply
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.ReduceWindowRequest"
        }
        override public func className() -> String {
            return "Xla.ReduceWindowRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.ReduceWindowRequest = Xla.ReduceWindowRequest()
            public func getMessage() -> Xla.ReduceWindowRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var operand:Xla.ComputationDataHandle! {
                get {
                    if operandBuilder_ != nil {
                        builderResult.operand = operandBuilder_.getMessage()
                    }
                    return builderResult.operand
                }
                set (value) {
                    builderResult.hasOperand = true
                    builderResult.operand = value
                }
            }
            public var hasOperand:Bool {
                get {
                    return builderResult.hasOperand
                }
            }
            fileprivate var operandBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasOperand = true
                }
            }
            public func getOperandBuilder() -> Xla.ComputationDataHandle.Builder {
                if operandBuilder_ == nil {
                    operandBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.operand = operandBuilder_.getMessage()
                    if operand != nil {
                        try! operandBuilder_.mergeFrom(other: operand)
                    }
                }
                return operandBuilder_
            }
            @discardableResult
            public func setOperand(_ value:Xla.ComputationDataHandle!) -> Xla.ReduceWindowRequest.Builder {
                self.operand = value
                return self
            }
            @discardableResult
            public func mergeOperand(value:Xla.ComputationDataHandle) throws -> Xla.ReduceWindowRequest.Builder {
                if builderResult.hasOperand {
                    builderResult.operand = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.operand).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.operand = value
                }
                builderResult.hasOperand = true
                return self
            }
            @discardableResult
            public func clearOperand() -> Xla.ReduceWindowRequest.Builder {
                operandBuilder_ = nil
                builderResult.hasOperand = false
                builderResult.operand = nil
                return self
            }
            public var initValue:Xla.ComputationDataHandle! {
                get {
                    if initValueBuilder_ != nil {
                        builderResult.initValue = initValueBuilder_.getMessage()
                    }
                    return builderResult.initValue
                }
                set (value) {
                    builderResult.hasInitValue = true
                    builderResult.initValue = value
                }
            }
            public var hasInitValue:Bool {
                get {
                    return builderResult.hasInitValue
                }
            }
            fileprivate var initValueBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasInitValue = true
                }
            }
            public func getInitValueBuilder() -> Xla.ComputationDataHandle.Builder {
                if initValueBuilder_ == nil {
                    initValueBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.initValue = initValueBuilder_.getMessage()
                    if initValue != nil {
                        try! initValueBuilder_.mergeFrom(other: initValue)
                    }
                }
                return initValueBuilder_
            }
            @discardableResult
            public func setInitValue(_ value:Xla.ComputationDataHandle!) -> Xla.ReduceWindowRequest.Builder {
                self.initValue = value
                return self
            }
            @discardableResult
            public func mergeInitValue(value:Xla.ComputationDataHandle) throws -> Xla.ReduceWindowRequest.Builder {
                if builderResult.hasInitValue {
                    builderResult.initValue = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.initValue).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.initValue = value
                }
                builderResult.hasInitValue = true
                return self
            }
            @discardableResult
            public func clearInitValue() -> Xla.ReduceWindowRequest.Builder {
                initValueBuilder_ = nil
                builderResult.hasInitValue = false
                builderResult.initValue = nil
                return self
            }
            public var window:Xla.Window! {
                get {
                    if windowBuilder_ != nil {
                        builderResult.window = windowBuilder_.getMessage()
                    }
                    return builderResult.window
                }
                set (value) {
                    builderResult.hasWindow = true
                    builderResult.window = value
                }
            }
            public var hasWindow:Bool {
                get {
                    return builderResult.hasWindow
                }
            }
            fileprivate var windowBuilder_:Xla.Window.Builder! {
                didSet {
                    builderResult.hasWindow = true
                }
            }
            public func getWindowBuilder() -> Xla.Window.Builder {
                if windowBuilder_ == nil {
                    windowBuilder_ = Xla.Window.Builder()
                    builderResult.window = windowBuilder_.getMessage()
                    if window != nil {
                        try! windowBuilder_.mergeFrom(other: window)
                    }
                }
                return windowBuilder_
            }
            @discardableResult
            public func setWindow(_ value:Xla.Window!) -> Xla.ReduceWindowRequest.Builder {
                self.window = value
                return self
            }
            @discardableResult
            public func mergeWindow(value:Xla.Window) throws -> Xla.ReduceWindowRequest.Builder {
                if builderResult.hasWindow {
                    builderResult.window = try Xla.Window.builderWithPrototype(prototype:builderResult.window).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.window = value
                }
                builderResult.hasWindow = true
                return self
            }
            @discardableResult
            public func clearWindow() -> Xla.ReduceWindowRequest.Builder {
                windowBuilder_ = nil
                builderResult.hasWindow = false
                builderResult.window = nil
                return self
            }
            public var toApply:Xla.ComputationHandle! {
                get {
                    if toApplyBuilder_ != nil {
                        builderResult.toApply = toApplyBuilder_.getMessage()
                    }
                    return builderResult.toApply
                }
                set (value) {
                    builderResult.hasToApply = true
                    builderResult.toApply = value
                }
            }
            public var hasToApply:Bool {
                get {
                    return builderResult.hasToApply
                }
            }
            fileprivate var toApplyBuilder_:Xla.ComputationHandle.Builder! {
                didSet {
                    builderResult.hasToApply = true
                }
            }
            public func getToApplyBuilder() -> Xla.ComputationHandle.Builder {
                if toApplyBuilder_ == nil {
                    toApplyBuilder_ = Xla.ComputationHandle.Builder()
                    builderResult.toApply = toApplyBuilder_.getMessage()
                    if toApply != nil {
                        try! toApplyBuilder_.mergeFrom(other: toApply)
                    }
                }
                return toApplyBuilder_
            }
            @discardableResult
            public func setToApply(_ value:Xla.ComputationHandle!) -> Xla.ReduceWindowRequest.Builder {
                self.toApply = value
                return self
            }
            @discardableResult
            public func mergeToApply(value:Xla.ComputationHandle) throws -> Xla.ReduceWindowRequest.Builder {
                if builderResult.hasToApply {
                    builderResult.toApply = try Xla.ComputationHandle.builderWithPrototype(prototype:builderResult.toApply).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.toApply = value
                }
                builderResult.hasToApply = true
                return self
            }
            @discardableResult
            public func clearToApply() -> Xla.ReduceWindowRequest.Builder {
                toApplyBuilder_ = nil
                builderResult.hasToApply = false
                builderResult.toApply = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.ReduceWindowRequest.Builder {
                builderResult = Xla.ReduceWindowRequest()
                return self
            }
            override public func clone() throws -> Xla.ReduceWindowRequest.Builder {
                return try Xla.ReduceWindowRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.ReduceWindowRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.ReduceWindowRequest {
                let returnMe:Xla.ReduceWindowRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.ReduceWindowRequest) throws -> Xla.ReduceWindowRequest.Builder {
                if other == Xla.ReduceWindowRequest() {
                    return self
                }
                if (other.hasOperand) {
                    try mergeOperand(value: other.operand)
                }
                if (other.hasInitValue) {
                    try mergeInitValue(value: other.initValue)
                }
                if (other.hasWindow) {
                    try mergeWindow(value: other.window)
                }
                if (other.hasToApply) {
                    try mergeToApply(value: other.toApply)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.ReduceWindowRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ReduceWindowRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 18:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasOperand {
                            try subBuilder.mergeFrom(other: operand)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        operand = subBuilder.buildPartial()

                    case 26:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasInitValue {
                            try subBuilder.mergeFrom(other: initValue)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        initValue = subBuilder.buildPartial()

                    case 34:
                        let subBuilder:Xla.Window.Builder = Xla.Window.Builder()
                        if hasWindow {
                            try subBuilder.mergeFrom(other: window)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        window = subBuilder.buildPartial()

                    case 42:
                        let subBuilder:Xla.ComputationHandle.Builder = Xla.ComputationHandle.Builder()
                        if hasToApply {
                            try subBuilder.mergeFrom(other: toApply)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        toApply = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.ReduceWindowRequest.Builder {
                let resultDecodedBuilder = Xla.ReduceWindowRequest.Builder()
                if let jsonValueOperand = jsonMap["operand"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.operand = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueOperand).build()

                }
                if let jsonValueInitValue = jsonMap["initValue"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.initValue = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueInitValue).build()

                }
                if let jsonValueWindow = jsonMap["window"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.window = try Xla.Window.Builder.decodeToBuilder(jsonMap:jsonValueWindow).build()

                }
                if let jsonValueToApply = jsonMap["toApply"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.toApply = try Xla.ComputationHandle.Builder.decodeToBuilder(jsonMap:jsonValueToApply).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.ReduceWindowRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.ReduceWindowRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class CrossReplicaSumRequest : GeneratedMessage {

        public static func == (lhs: Xla.CrossReplicaSumRequest, rhs: Xla.CrossReplicaSumRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasOperand == rhs.hasOperand) && (!lhs.hasOperand || lhs.operand == rhs.operand)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var operand:Xla.ComputationDataHandle!
        public fileprivate(set) var hasOperand:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasOperand {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:operand)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasOperand {
                if let varSizeoperand = operand?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeoperand
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.CrossReplicaSumRequest.Builder {
            return Xla.CrossReplicaSumRequest.classBuilder() as! Xla.CrossReplicaSumRequest.Builder
        }
        public func getBuilder() -> Xla.CrossReplicaSumRequest.Builder {
            return classBuilder() as! Xla.CrossReplicaSumRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.CrossReplicaSumRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.CrossReplicaSumRequest.Builder()
        }
        public func toBuilder() throws -> Xla.CrossReplicaSumRequest.Builder {
            return try Xla.CrossReplicaSumRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.CrossReplicaSumRequest) throws -> Xla.CrossReplicaSumRequest.Builder {
            return try Xla.CrossReplicaSumRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasOperand {
                jsonMap["operand"] = try operand.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.CrossReplicaSumRequest {
            return try Xla.CrossReplicaSumRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.CrossReplicaSumRequest {
            return try Xla.CrossReplicaSumRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasOperand {
                output += "\(indent) operand {\n"
                if let outDescOperand = operand {
                    output += try outDescOperand.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasOperand {
                    if let hashValueoperand = operand?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoperand
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.CrossReplicaSumRequest"
        }
        override public func className() -> String {
            return "Xla.CrossReplicaSumRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.CrossReplicaSumRequest = Xla.CrossReplicaSumRequest()
            public func getMessage() -> Xla.CrossReplicaSumRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var operand:Xla.ComputationDataHandle! {
                get {
                    if operandBuilder_ != nil {
                        builderResult.operand = operandBuilder_.getMessage()
                    }
                    return builderResult.operand
                }
                set (value) {
                    builderResult.hasOperand = true
                    builderResult.operand = value
                }
            }
            public var hasOperand:Bool {
                get {
                    return builderResult.hasOperand
                }
            }
            fileprivate var operandBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasOperand = true
                }
            }
            public func getOperandBuilder() -> Xla.ComputationDataHandle.Builder {
                if operandBuilder_ == nil {
                    operandBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.operand = operandBuilder_.getMessage()
                    if operand != nil {
                        try! operandBuilder_.mergeFrom(other: operand)
                    }
                }
                return operandBuilder_
            }
            @discardableResult
            public func setOperand(_ value:Xla.ComputationDataHandle!) -> Xla.CrossReplicaSumRequest.Builder {
                self.operand = value
                return self
            }
            @discardableResult
            public func mergeOperand(value:Xla.ComputationDataHandle) throws -> Xla.CrossReplicaSumRequest.Builder {
                if builderResult.hasOperand {
                    builderResult.operand = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.operand).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.operand = value
                }
                builderResult.hasOperand = true
                return self
            }
            @discardableResult
            public func clearOperand() -> Xla.CrossReplicaSumRequest.Builder {
                operandBuilder_ = nil
                builderResult.hasOperand = false
                builderResult.operand = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.CrossReplicaSumRequest.Builder {
                builderResult = Xla.CrossReplicaSumRequest()
                return self
            }
            override public func clone() throws -> Xla.CrossReplicaSumRequest.Builder {
                return try Xla.CrossReplicaSumRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.CrossReplicaSumRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.CrossReplicaSumRequest {
                let returnMe:Xla.CrossReplicaSumRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.CrossReplicaSumRequest) throws -> Xla.CrossReplicaSumRequest.Builder {
                if other == Xla.CrossReplicaSumRequest() {
                    return self
                }
                if (other.hasOperand) {
                    try mergeOperand(value: other.operand)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.CrossReplicaSumRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.CrossReplicaSumRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 18:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasOperand {
                            try subBuilder.mergeFrom(other: operand)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        operand = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.CrossReplicaSumRequest.Builder {
                let resultDecodedBuilder = Xla.CrossReplicaSumRequest.Builder()
                if let jsonValueOperand = jsonMap["operand"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.operand = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueOperand).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.CrossReplicaSumRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.CrossReplicaSumRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class SelectAndScatterRequest : GeneratedMessage {

        public static func == (lhs: Xla.SelectAndScatterRequest, rhs: Xla.SelectAndScatterRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasOperand == rhs.hasOperand) && (!lhs.hasOperand || lhs.operand == rhs.operand)
            fieldCheck = fieldCheck && (lhs.hasSource == rhs.hasSource) && (!lhs.hasSource || lhs.source == rhs.source)
            fieldCheck = fieldCheck && (lhs.hasInitValue == rhs.hasInitValue) && (!lhs.hasInitValue || lhs.initValue == rhs.initValue)
            fieldCheck = fieldCheck && (lhs.hasWindow == rhs.hasWindow) && (!lhs.hasWindow || lhs.window == rhs.window)
            fieldCheck = fieldCheck && (lhs.hasSelect == rhs.hasSelect) && (!lhs.hasSelect || lhs.select == rhs.select)
            fieldCheck = fieldCheck && (lhs.hasScatter == rhs.hasScatter) && (!lhs.hasScatter || lhs.scatter == rhs.scatter)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var operand:Xla.ComputationDataHandle!
        public fileprivate(set) var hasOperand:Bool = false
        public fileprivate(set) var source:Xla.ComputationDataHandle!
        public fileprivate(set) var hasSource:Bool = false
        public fileprivate(set) var initValue:Xla.ComputationDataHandle!
        public fileprivate(set) var hasInitValue:Bool = false
        public fileprivate(set) var window:Xla.Window!
        public fileprivate(set) var hasWindow:Bool = false
        public fileprivate(set) var select:Xla.ComputationHandle!
        public fileprivate(set) var hasSelect:Bool = false
        public fileprivate(set) var scatter:Xla.ComputationHandle!
        public fileprivate(set) var hasScatter:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasOperand {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:operand)
            }
            if hasSource {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:source)
            }
            if hasInitValue {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:initValue)
            }
            if hasWindow {
                try codedOutputStream.writeMessage(fieldNumber: 5, value:window)
            }
            if hasSelect {
                try codedOutputStream.writeMessage(fieldNumber: 6, value:select)
            }
            if hasScatter {
                try codedOutputStream.writeMessage(fieldNumber: 7, value:scatter)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasOperand {
                if let varSizeoperand = operand?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeoperand
                }
            }
            if hasSource {
                if let varSizesource = source?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizesource
                }
            }
            if hasInitValue {
                if let varSizeinitValue = initValue?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizeinitValue
                }
            }
            if hasWindow {
                if let varSizewindow = window?.computeMessageSize(fieldNumber: 5) {
                    serialize_size += varSizewindow
                }
            }
            if hasSelect {
                if let varSizeselect = select?.computeMessageSize(fieldNumber: 6) {
                    serialize_size += varSizeselect
                }
            }
            if hasScatter {
                if let varSizescatter = scatter?.computeMessageSize(fieldNumber: 7) {
                    serialize_size += varSizescatter
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.SelectAndScatterRequest.Builder {
            return Xla.SelectAndScatterRequest.classBuilder() as! Xla.SelectAndScatterRequest.Builder
        }
        public func getBuilder() -> Xla.SelectAndScatterRequest.Builder {
            return classBuilder() as! Xla.SelectAndScatterRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.SelectAndScatterRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.SelectAndScatterRequest.Builder()
        }
        public func toBuilder() throws -> Xla.SelectAndScatterRequest.Builder {
            return try Xla.SelectAndScatterRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.SelectAndScatterRequest) throws -> Xla.SelectAndScatterRequest.Builder {
            return try Xla.SelectAndScatterRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasOperand {
                jsonMap["operand"] = try operand.encode()
            }
            if hasSource {
                jsonMap["source"] = try source.encode()
            }
            if hasInitValue {
                jsonMap["initValue"] = try initValue.encode()
            }
            if hasWindow {
                jsonMap["window"] = try window.encode()
            }
            if hasSelect {
                jsonMap["select"] = try select.encode()
            }
            if hasScatter {
                jsonMap["scatter"] = try scatter.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.SelectAndScatterRequest {
            return try Xla.SelectAndScatterRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.SelectAndScatterRequest {
            return try Xla.SelectAndScatterRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasOperand {
                output += "\(indent) operand {\n"
                if let outDescOperand = operand {
                    output += try outDescOperand.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasSource {
                output += "\(indent) source {\n"
                if let outDescSource = source {
                    output += try outDescSource.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasInitValue {
                output += "\(indent) initValue {\n"
                if let outDescInitValue = initValue {
                    output += try outDescInitValue.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasWindow {
                output += "\(indent) window {\n"
                if let outDescWindow = window {
                    output += try outDescWindow.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasSelect {
                output += "\(indent) select {\n"
                if let outDescSelect = select {
                    output += try outDescSelect.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasScatter {
                output += "\(indent) scatter {\n"
                if let outDescScatter = scatter {
                    output += try outDescScatter.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasOperand {
                    if let hashValueoperand = operand?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoperand
                    }
                }
                if hasSource {
                    if let hashValuesource = source?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuesource
                    }
                }
                if hasInitValue {
                    if let hashValueinitValue = initValue?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueinitValue
                    }
                }
                if hasWindow {
                    if let hashValuewindow = window?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuewindow
                    }
                }
                if hasSelect {
                    if let hashValueselect = select?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueselect
                    }
                }
                if hasScatter {
                    if let hashValuescatter = scatter?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuescatter
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.SelectAndScatterRequest"
        }
        override public func className() -> String {
            return "Xla.SelectAndScatterRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.SelectAndScatterRequest = Xla.SelectAndScatterRequest()
            public func getMessage() -> Xla.SelectAndScatterRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Operand array on which the windows slide.
            public var operand:Xla.ComputationDataHandle! {
                get {
                    if operandBuilder_ != nil {
                        builderResult.operand = operandBuilder_.getMessage()
                    }
                    return builderResult.operand
                }
                set (value) {
                    builderResult.hasOperand = true
                    builderResult.operand = value
                }
            }
            public var hasOperand:Bool {
                get {
                    return builderResult.hasOperand
                }
            }
            fileprivate var operandBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasOperand = true
                }
            }
            public func getOperandBuilder() -> Xla.ComputationDataHandle.Builder {
                if operandBuilder_ == nil {
                    operandBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.operand = operandBuilder_.getMessage()
                    if operand != nil {
                        try! operandBuilder_.mergeFrom(other: operand)
                    }
                }
                return operandBuilder_
            }
            @discardableResult
            public func setOperand(_ value:Xla.ComputationDataHandle!) -> Xla.SelectAndScatterRequest.Builder {
                self.operand = value
                return self
            }
            @discardableResult
            public func mergeOperand(value:Xla.ComputationDataHandle) throws -> Xla.SelectAndScatterRequest.Builder {
                if builderResult.hasOperand {
                    builderResult.operand = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.operand).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.operand = value
                }
                builderResult.hasOperand = true
                return self
            }
            @discardableResult
            public func clearOperand() -> Xla.SelectAndScatterRequest.Builder {
                operandBuilder_ = nil
                builderResult.hasOperand = false
                builderResult.operand = nil
                return self
            }
            /// Source array for the data to scatter.
            public var source:Xla.ComputationDataHandle! {
                get {
                    if sourceBuilder_ != nil {
                        builderResult.source = sourceBuilder_.getMessage()
                    }
                    return builderResult.source
                }
                set (value) {
                    builderResult.hasSource = true
                    builderResult.source = value
                }
            }
            public var hasSource:Bool {
                get {
                    return builderResult.hasSource
                }
            }
            fileprivate var sourceBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasSource = true
                }
            }
            public func getSourceBuilder() -> Xla.ComputationDataHandle.Builder {
                if sourceBuilder_ == nil {
                    sourceBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.source = sourceBuilder_.getMessage()
                    if source != nil {
                        try! sourceBuilder_.mergeFrom(other: source)
                    }
                }
                return sourceBuilder_
            }
            @discardableResult
            public func setSource(_ value:Xla.ComputationDataHandle!) -> Xla.SelectAndScatterRequest.Builder {
                self.source = value
                return self
            }
            @discardableResult
            public func mergeSource(value:Xla.ComputationDataHandle) throws -> Xla.SelectAndScatterRequest.Builder {
                if builderResult.hasSource {
                    builderResult.source = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.source).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.source = value
                }
                builderResult.hasSource = true
                return self
            }
            @discardableResult
            public func clearSource() -> Xla.SelectAndScatterRequest.Builder {
                sourceBuilder_ = nil
                builderResult.hasSource = false
                builderResult.source = nil
                return self
            }
            /// Initial scalar value for each element in the output.
            public var initValue:Xla.ComputationDataHandle! {
                get {
                    if initValueBuilder_ != nil {
                        builderResult.initValue = initValueBuilder_.getMessage()
                    }
                    return builderResult.initValue
                }
                set (value) {
                    builderResult.hasInitValue = true
                    builderResult.initValue = value
                }
            }
            public var hasInitValue:Bool {
                get {
                    return builderResult.hasInitValue
                }
            }
            fileprivate var initValueBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasInitValue = true
                }
            }
            public func getInitValueBuilder() -> Xla.ComputationDataHandle.Builder {
                if initValueBuilder_ == nil {
                    initValueBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.initValue = initValueBuilder_.getMessage()
                    if initValue != nil {
                        try! initValueBuilder_.mergeFrom(other: initValue)
                    }
                }
                return initValueBuilder_
            }
            @discardableResult
            public func setInitValue(_ value:Xla.ComputationDataHandle!) -> Xla.SelectAndScatterRequest.Builder {
                self.initValue = value
                return self
            }
            @discardableResult
            public func mergeInitValue(value:Xla.ComputationDataHandle) throws -> Xla.SelectAndScatterRequest.Builder {
                if builderResult.hasInitValue {
                    builderResult.initValue = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.initValue).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.initValue = value
                }
                builderResult.hasInitValue = true
                return self
            }
            @discardableResult
            public func clearInitValue() -> Xla.SelectAndScatterRequest.Builder {
                initValueBuilder_ = nil
                builderResult.hasInitValue = false
                builderResult.initValue = nil
                return self
            }
            /// Window configuration.
            public var window:Xla.Window! {
                get {
                    if windowBuilder_ != nil {
                        builderResult.window = windowBuilder_.getMessage()
                    }
                    return builderResult.window
                }
                set (value) {
                    builderResult.hasWindow = true
                    builderResult.window = value
                }
            }
            public var hasWindow:Bool {
                get {
                    return builderResult.hasWindow
                }
            }
            fileprivate var windowBuilder_:Xla.Window.Builder! {
                didSet {
                    builderResult.hasWindow = true
                }
            }
            public func getWindowBuilder() -> Xla.Window.Builder {
                if windowBuilder_ == nil {
                    windowBuilder_ = Xla.Window.Builder()
                    builderResult.window = windowBuilder_.getMessage()
                    if window != nil {
                        try! windowBuilder_.mergeFrom(other: window)
                    }
                }
                return windowBuilder_
            }
            @discardableResult
            public func setWindow(_ value:Xla.Window!) -> Xla.SelectAndScatterRequest.Builder {
                self.window = value
                return self
            }
            @discardableResult
            public func mergeWindow(value:Xla.Window) throws -> Xla.SelectAndScatterRequest.Builder {
                if builderResult.hasWindow {
                    builderResult.window = try Xla.Window.builderWithPrototype(prototype:builderResult.window).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.window = value
                }
                builderResult.hasWindow = true
                return self
            }
            @discardableResult
            public func clearWindow() -> Xla.SelectAndScatterRequest.Builder {
                windowBuilder_ = nil
                builderResult.hasWindow = false
                builderResult.window = nil
                return self
            }
            /// Binary function used to select an element from each window.
            public var select:Xla.ComputationHandle! {
                get {
                    if selectBuilder_ != nil {
                        builderResult.select = selectBuilder_.getMessage()
                    }
                    return builderResult.select
                }
                set (value) {
                    builderResult.hasSelect = true
                    builderResult.select = value
                }
            }
            public var hasSelect:Bool {
                get {
                    return builderResult.hasSelect
                }
            }
            fileprivate var selectBuilder_:Xla.ComputationHandle.Builder! {
                didSet {
                    builderResult.hasSelect = true
                }
            }
            public func getSelectBuilder() -> Xla.ComputationHandle.Builder {
                if selectBuilder_ == nil {
                    selectBuilder_ = Xla.ComputationHandle.Builder()
                    builderResult.select = selectBuilder_.getMessage()
                    if select != nil {
                        try! selectBuilder_.mergeFrom(other: select)
                    }
                }
                return selectBuilder_
            }
            @discardableResult
            public func setSelect(_ value:Xla.ComputationHandle!) -> Xla.SelectAndScatterRequest.Builder {
                self.select = value
                return self
            }
            @discardableResult
            public func mergeSelect(value:Xla.ComputationHandle) throws -> Xla.SelectAndScatterRequest.Builder {
                if builderResult.hasSelect {
                    builderResult.select = try Xla.ComputationHandle.builderWithPrototype(prototype:builderResult.select).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.select = value
                }
                builderResult.hasSelect = true
                return self
            }
            @discardableResult
            public func clearSelect() -> Xla.SelectAndScatterRequest.Builder {
                selectBuilder_ = nil
                builderResult.hasSelect = false
                builderResult.select = nil
                return self
            }
            /// Binary function used to combine each scattered value from source with the
            /// current output value at the selected location.
            public var scatter:Xla.ComputationHandle! {
                get {
                    if scatterBuilder_ != nil {
                        builderResult.scatter = scatterBuilder_.getMessage()
                    }
                    return builderResult.scatter
                }
                set (value) {
                    builderResult.hasScatter = true
                    builderResult.scatter = value
                }
            }
            public var hasScatter:Bool {
                get {
                    return builderResult.hasScatter
                }
            }
            fileprivate var scatterBuilder_:Xla.ComputationHandle.Builder! {
                didSet {
                    builderResult.hasScatter = true
                }
            }
            public func getScatterBuilder() -> Xla.ComputationHandle.Builder {
                if scatterBuilder_ == nil {
                    scatterBuilder_ = Xla.ComputationHandle.Builder()
                    builderResult.scatter = scatterBuilder_.getMessage()
                    if scatter != nil {
                        try! scatterBuilder_.mergeFrom(other: scatter)
                    }
                }
                return scatterBuilder_
            }
            @discardableResult
            public func setScatter(_ value:Xla.ComputationHandle!) -> Xla.SelectAndScatterRequest.Builder {
                self.scatter = value
                return self
            }
            @discardableResult
            public func mergeScatter(value:Xla.ComputationHandle) throws -> Xla.SelectAndScatterRequest.Builder {
                if builderResult.hasScatter {
                    builderResult.scatter = try Xla.ComputationHandle.builderWithPrototype(prototype:builderResult.scatter).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.scatter = value
                }
                builderResult.hasScatter = true
                return self
            }
            @discardableResult
            public func clearScatter() -> Xla.SelectAndScatterRequest.Builder {
                scatterBuilder_ = nil
                builderResult.hasScatter = false
                builderResult.scatter = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.SelectAndScatterRequest.Builder {
                builderResult = Xla.SelectAndScatterRequest()
                return self
            }
            override public func clone() throws -> Xla.SelectAndScatterRequest.Builder {
                return try Xla.SelectAndScatterRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.SelectAndScatterRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.SelectAndScatterRequest {
                let returnMe:Xla.SelectAndScatterRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.SelectAndScatterRequest) throws -> Xla.SelectAndScatterRequest.Builder {
                if other == Xla.SelectAndScatterRequest() {
                    return self
                }
                if (other.hasOperand) {
                    try mergeOperand(value: other.operand)
                }
                if (other.hasSource) {
                    try mergeSource(value: other.source)
                }
                if (other.hasInitValue) {
                    try mergeInitValue(value: other.initValue)
                }
                if (other.hasWindow) {
                    try mergeWindow(value: other.window)
                }
                if (other.hasSelect) {
                    try mergeSelect(value: other.select)
                }
                if (other.hasScatter) {
                    try mergeScatter(value: other.scatter)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.SelectAndScatterRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SelectAndScatterRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 18:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasOperand {
                            try subBuilder.mergeFrom(other: operand)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        operand = subBuilder.buildPartial()

                    case 26:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasSource {
                            try subBuilder.mergeFrom(other: source)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        source = subBuilder.buildPartial()

                    case 34:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasInitValue {
                            try subBuilder.mergeFrom(other: initValue)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        initValue = subBuilder.buildPartial()

                    case 42:
                        let subBuilder:Xla.Window.Builder = Xla.Window.Builder()
                        if hasWindow {
                            try subBuilder.mergeFrom(other: window)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        window = subBuilder.buildPartial()

                    case 50:
                        let subBuilder:Xla.ComputationHandle.Builder = Xla.ComputationHandle.Builder()
                        if hasSelect {
                            try subBuilder.mergeFrom(other: select)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        select = subBuilder.buildPartial()

                    case 58:
                        let subBuilder:Xla.ComputationHandle.Builder = Xla.ComputationHandle.Builder()
                        if hasScatter {
                            try subBuilder.mergeFrom(other: scatter)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        scatter = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.SelectAndScatterRequest.Builder {
                let resultDecodedBuilder = Xla.SelectAndScatterRequest.Builder()
                if let jsonValueOperand = jsonMap["operand"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.operand = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueOperand).build()

                }
                if let jsonValueSource = jsonMap["source"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.source = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueSource).build()

                }
                if let jsonValueInitValue = jsonMap["initValue"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.initValue = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueInitValue).build()

                }
                if let jsonValueWindow = jsonMap["window"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.window = try Xla.Window.Builder.decodeToBuilder(jsonMap:jsonValueWindow).build()

                }
                if let jsonValueSelect = jsonMap["select"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.select = try Xla.ComputationHandle.Builder.decodeToBuilder(jsonMap:jsonValueSelect).build()

                }
                if let jsonValueScatter = jsonMap["scatter"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.scatter = try Xla.ComputationHandle.Builder.decodeToBuilder(jsonMap:jsonValueScatter).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.SelectAndScatterRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.SelectAndScatterRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ReverseRequest : GeneratedMessage {

        public static func == (lhs: Xla.ReverseRequest, rhs: Xla.ReverseRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasOperand == rhs.hasOperand) && (!lhs.hasOperand || lhs.operand == rhs.operand)
            fieldCheck = fieldCheck && (lhs.dimensions == rhs.dimensions)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var operand:Xla.ComputationDataHandle!
        public fileprivate(set) var hasOperand:Bool = false
        public fileprivate(set) var dimensions:Array<Int64> = Array<Int64>()
        private var dimensionsMemoizedSerializedSize:Int32 = -1
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasOperand {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:operand)
            }
            if !dimensions.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 26)
                try codedOutputStream.writeRawVarint32(value: dimensionsMemoizedSerializedSize)
                for oneValuedimensions in dimensions {
                    try codedOutputStream.writeInt64NoTag(value: oneValuedimensions)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasOperand {
                if let varSizeoperand = operand?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeoperand
                }
            }
            var dataSizeDimensions:Int32 = 0
            for oneValuedimensions in dimensions {
                dataSizeDimensions += oneValuedimensions.computeInt64SizeNoTag()
            }
            serialize_size += dataSizeDimensions
            if !dimensions.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeDimensions.computeInt32SizeNoTag()
            }
            dimensionsMemoizedSerializedSize = dataSizeDimensions
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.ReverseRequest.Builder {
            return Xla.ReverseRequest.classBuilder() as! Xla.ReverseRequest.Builder
        }
        public func getBuilder() -> Xla.ReverseRequest.Builder {
            return classBuilder() as! Xla.ReverseRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ReverseRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ReverseRequest.Builder()
        }
        public func toBuilder() throws -> Xla.ReverseRequest.Builder {
            return try Xla.ReverseRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.ReverseRequest) throws -> Xla.ReverseRequest.Builder {
            return try Xla.ReverseRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasOperand {
                jsonMap["operand"] = try operand.encode()
            }
            if !dimensions.isEmpty {
                var jsonArrayDimensions:Array<String> = []
                for oneValueDimensions in dimensions {
                    jsonArrayDimensions.append("\(oneValueDimensions)")
                }
                jsonMap["dimensions"] = jsonArrayDimensions
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.ReverseRequest {
            return try Xla.ReverseRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.ReverseRequest {
            return try Xla.ReverseRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasOperand {
                output += "\(indent) operand {\n"
                if let outDescOperand = operand {
                    output += try outDescOperand.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            var dimensionsElementIndex:Int = 0
            for oneValueDimensions in dimensions  {
                output += "\(indent) dimensions[\(dimensionsElementIndex)]: \(oneValueDimensions)\n"
                dimensionsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasOperand {
                    if let hashValueoperand = operand?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoperand
                    }
                }
                for oneValueDimensions in dimensions {
                    hashCode = (hashCode &* 31) &+ oneValueDimensions.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.ReverseRequest"
        }
        override public func className() -> String {
            return "Xla.ReverseRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.ReverseRequest = Xla.ReverseRequest()
            public func getMessage() -> Xla.ReverseRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var operand:Xla.ComputationDataHandle! {
                get {
                    if operandBuilder_ != nil {
                        builderResult.operand = operandBuilder_.getMessage()
                    }
                    return builderResult.operand
                }
                set (value) {
                    builderResult.hasOperand = true
                    builderResult.operand = value
                }
            }
            public var hasOperand:Bool {
                get {
                    return builderResult.hasOperand
                }
            }
            fileprivate var operandBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasOperand = true
                }
            }
            public func getOperandBuilder() -> Xla.ComputationDataHandle.Builder {
                if operandBuilder_ == nil {
                    operandBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.operand = operandBuilder_.getMessage()
                    if operand != nil {
                        try! operandBuilder_.mergeFrom(other: operand)
                    }
                }
                return operandBuilder_
            }
            @discardableResult
            public func setOperand(_ value:Xla.ComputationDataHandle!) -> Xla.ReverseRequest.Builder {
                self.operand = value
                return self
            }
            @discardableResult
            public func mergeOperand(value:Xla.ComputationDataHandle) throws -> Xla.ReverseRequest.Builder {
                if builderResult.hasOperand {
                    builderResult.operand = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.operand).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.operand = value
                }
                builderResult.hasOperand = true
                return self
            }
            @discardableResult
            public func clearOperand() -> Xla.ReverseRequest.Builder {
                operandBuilder_ = nil
                builderResult.hasOperand = false
                builderResult.operand = nil
                return self
            }
            public var dimensions:Array<Int64> {
                get {
                    return builderResult.dimensions
                }
                set (array) {
                    builderResult.dimensions = array
                }
            }
            @discardableResult
            public func setDimensions(_ value:Array<Int64>) -> Xla.ReverseRequest.Builder {
                self.dimensions = value
                return self
            }
            @discardableResult
            public func clearDimensions() -> Xla.ReverseRequest.Builder {
                builderResult.dimensions.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.ReverseRequest.Builder {
                builderResult = Xla.ReverseRequest()
                return self
            }
            override public func clone() throws -> Xla.ReverseRequest.Builder {
                return try Xla.ReverseRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.ReverseRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.ReverseRequest {
                let returnMe:Xla.ReverseRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.ReverseRequest) throws -> Xla.ReverseRequest.Builder {
                if other == Xla.ReverseRequest() {
                    return self
                }
                if (other.hasOperand) {
                    try mergeOperand(value: other.operand)
                }
                if !other.dimensions.isEmpty {
                    builderResult.dimensions += other.dimensions
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.ReverseRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ReverseRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 18:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasOperand {
                            try subBuilder.mergeFrom(other: operand)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        operand = subBuilder.buildPartial()

                    case 26:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.dimensions.append(try codedInputStream.readInt64())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.ReverseRequest.Builder {
                let resultDecodedBuilder = Xla.ReverseRequest.Builder()
                if let jsonValueOperand = jsonMap["operand"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.operand = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueOperand).build()

                }
                if let jsonValueDimensions = jsonMap["dimensions"] as? Array<String> {
                    var jsonArrayDimensions:Array<Int64> = []
                    for oneValueDimensions in jsonValueDimensions {
                        jsonArrayDimensions.append(Int64(oneValueDimensions)!)
                    }
                    resultDecodedBuilder.dimensions = jsonArrayDimensions
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.ReverseRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.ReverseRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class BroadcastRequest : GeneratedMessage {

        public static func == (lhs: Xla.BroadcastRequest, rhs: Xla.BroadcastRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasOperand == rhs.hasOperand) && (!lhs.hasOperand || lhs.operand == rhs.operand)
            fieldCheck = fieldCheck && (lhs.broadcastSizes == rhs.broadcastSizes)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var operand:Xla.ComputationDataHandle!
        public fileprivate(set) var hasOperand:Bool = false
        public fileprivate(set) var broadcastSizes:Array<Int64> = Array<Int64>()
        private var broadcastSizesMemoizedSerializedSize:Int32 = -1
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasOperand {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:operand)
            }
            if !broadcastSizes.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 26)
                try codedOutputStream.writeRawVarint32(value: broadcastSizesMemoizedSerializedSize)
                for oneValuebroadcastSizes in broadcastSizes {
                    try codedOutputStream.writeInt64NoTag(value: oneValuebroadcastSizes)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasOperand {
                if let varSizeoperand = operand?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeoperand
                }
            }
            var dataSizeBroadcastSizes:Int32 = 0
            for oneValuebroadcastSizes in broadcastSizes {
                dataSizeBroadcastSizes += oneValuebroadcastSizes.computeInt64SizeNoTag()
            }
            serialize_size += dataSizeBroadcastSizes
            if !broadcastSizes.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeBroadcastSizes.computeInt32SizeNoTag()
            }
            broadcastSizesMemoizedSerializedSize = dataSizeBroadcastSizes
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.BroadcastRequest.Builder {
            return Xla.BroadcastRequest.classBuilder() as! Xla.BroadcastRequest.Builder
        }
        public func getBuilder() -> Xla.BroadcastRequest.Builder {
            return classBuilder() as! Xla.BroadcastRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.BroadcastRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.BroadcastRequest.Builder()
        }
        public func toBuilder() throws -> Xla.BroadcastRequest.Builder {
            return try Xla.BroadcastRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.BroadcastRequest) throws -> Xla.BroadcastRequest.Builder {
            return try Xla.BroadcastRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasOperand {
                jsonMap["operand"] = try operand.encode()
            }
            if !broadcastSizes.isEmpty {
                var jsonArrayBroadcastSizes:Array<String> = []
                for oneValueBroadcastSizes in broadcastSizes {
                    jsonArrayBroadcastSizes.append("\(oneValueBroadcastSizes)")
                }
                jsonMap["broadcastSizes"] = jsonArrayBroadcastSizes
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.BroadcastRequest {
            return try Xla.BroadcastRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.BroadcastRequest {
            return try Xla.BroadcastRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasOperand {
                output += "\(indent) operand {\n"
                if let outDescOperand = operand {
                    output += try outDescOperand.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            var broadcastSizesElementIndex:Int = 0
            for oneValueBroadcastSizes in broadcastSizes  {
                output += "\(indent) broadcastSizes[\(broadcastSizesElementIndex)]: \(oneValueBroadcastSizes)\n"
                broadcastSizesElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasOperand {
                    if let hashValueoperand = operand?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoperand
                    }
                }
                for oneValueBroadcastSizes in broadcastSizes {
                    hashCode = (hashCode &* 31) &+ oneValueBroadcastSizes.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.BroadcastRequest"
        }
        override public func className() -> String {
            return "Xla.BroadcastRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.BroadcastRequest = Xla.BroadcastRequest()
            public func getMessage() -> Xla.BroadcastRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var operand:Xla.ComputationDataHandle! {
                get {
                    if operandBuilder_ != nil {
                        builderResult.operand = operandBuilder_.getMessage()
                    }
                    return builderResult.operand
                }
                set (value) {
                    builderResult.hasOperand = true
                    builderResult.operand = value
                }
            }
            public var hasOperand:Bool {
                get {
                    return builderResult.hasOperand
                }
            }
            fileprivate var operandBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasOperand = true
                }
            }
            public func getOperandBuilder() -> Xla.ComputationDataHandle.Builder {
                if operandBuilder_ == nil {
                    operandBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.operand = operandBuilder_.getMessage()
                    if operand != nil {
                        try! operandBuilder_.mergeFrom(other: operand)
                    }
                }
                return operandBuilder_
            }
            @discardableResult
            public func setOperand(_ value:Xla.ComputationDataHandle!) -> Xla.BroadcastRequest.Builder {
                self.operand = value
                return self
            }
            @discardableResult
            public func mergeOperand(value:Xla.ComputationDataHandle) throws -> Xla.BroadcastRequest.Builder {
                if builderResult.hasOperand {
                    builderResult.operand = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.operand).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.operand = value
                }
                builderResult.hasOperand = true
                return self
            }
            @discardableResult
            public func clearOperand() -> Xla.BroadcastRequest.Builder {
                operandBuilder_ = nil
                builderResult.hasOperand = false
                builderResult.operand = nil
                return self
            }
            public var broadcastSizes:Array<Int64> {
                get {
                    return builderResult.broadcastSizes
                }
                set (array) {
                    builderResult.broadcastSizes = array
                }
            }
            @discardableResult
            public func setBroadcastSizes(_ value:Array<Int64>) -> Xla.BroadcastRequest.Builder {
                self.broadcastSizes = value
                return self
            }
            @discardableResult
            public func clearBroadcastSizes() -> Xla.BroadcastRequest.Builder {
                builderResult.broadcastSizes.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.BroadcastRequest.Builder {
                builderResult = Xla.BroadcastRequest()
                return self
            }
            override public func clone() throws -> Xla.BroadcastRequest.Builder {
                return try Xla.BroadcastRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.BroadcastRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.BroadcastRequest {
                let returnMe:Xla.BroadcastRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.BroadcastRequest) throws -> Xla.BroadcastRequest.Builder {
                if other == Xla.BroadcastRequest() {
                    return self
                }
                if (other.hasOperand) {
                    try mergeOperand(value: other.operand)
                }
                if !other.broadcastSizes.isEmpty {
                    builderResult.broadcastSizes += other.broadcastSizes
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.BroadcastRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.BroadcastRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 18:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasOperand {
                            try subBuilder.mergeFrom(other: operand)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        operand = subBuilder.buildPartial()

                    case 26:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.broadcastSizes.append(try codedInputStream.readInt64())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.BroadcastRequest.Builder {
                let resultDecodedBuilder = Xla.BroadcastRequest.Builder()
                if let jsonValueOperand = jsonMap["operand"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.operand = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueOperand).build()

                }
                if let jsonValueBroadcastSizes = jsonMap["broadcastSizes"] as? Array<String> {
                    var jsonArrayBroadcastSizes:Array<Int64> = []
                    for oneValueBroadcastSizes in jsonValueBroadcastSizes {
                        jsonArrayBroadcastSizes.append(Int64(oneValueBroadcastSizes)!)
                    }
                    resultDecodedBuilder.broadcastSizes = jsonArrayBroadcastSizes
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.BroadcastRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.BroadcastRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class PadRequest : GeneratedMessage {

        public static func == (lhs: Xla.PadRequest, rhs: Xla.PadRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasOperand == rhs.hasOperand) && (!lhs.hasOperand || lhs.operand == rhs.operand)
            fieldCheck = fieldCheck && (lhs.hasPaddingValue == rhs.hasPaddingValue) && (!lhs.hasPaddingValue || lhs.paddingValue == rhs.paddingValue)
            fieldCheck = fieldCheck && (lhs.hasPaddingConfig == rhs.hasPaddingConfig) && (!lhs.hasPaddingConfig || lhs.paddingConfig == rhs.paddingConfig)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var operand:Xla.ComputationDataHandle!
        public fileprivate(set) var hasOperand:Bool = false
        public fileprivate(set) var paddingValue:Xla.ComputationDataHandle!
        public fileprivate(set) var hasPaddingValue:Bool = false
        public fileprivate(set) var paddingConfig:Xla.PaddingConfig!
        public fileprivate(set) var hasPaddingConfig:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasOperand {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:operand)
            }
            if hasPaddingValue {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:paddingValue)
            }
            if hasPaddingConfig {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:paddingConfig)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasOperand {
                if let varSizeoperand = operand?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeoperand
                }
            }
            if hasPaddingValue {
                if let varSizepaddingValue = paddingValue?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizepaddingValue
                }
            }
            if hasPaddingConfig {
                if let varSizepaddingConfig = paddingConfig?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizepaddingConfig
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.PadRequest.Builder {
            return Xla.PadRequest.classBuilder() as! Xla.PadRequest.Builder
        }
        public func getBuilder() -> Xla.PadRequest.Builder {
            return classBuilder() as! Xla.PadRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.PadRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.PadRequest.Builder()
        }
        public func toBuilder() throws -> Xla.PadRequest.Builder {
            return try Xla.PadRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.PadRequest) throws -> Xla.PadRequest.Builder {
            return try Xla.PadRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasOperand {
                jsonMap["operand"] = try operand.encode()
            }
            if hasPaddingValue {
                jsonMap["paddingValue"] = try paddingValue.encode()
            }
            if hasPaddingConfig {
                jsonMap["paddingConfig"] = try paddingConfig.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.PadRequest {
            return try Xla.PadRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.PadRequest {
            return try Xla.PadRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasOperand {
                output += "\(indent) operand {\n"
                if let outDescOperand = operand {
                    output += try outDescOperand.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasPaddingValue {
                output += "\(indent) paddingValue {\n"
                if let outDescPaddingValue = paddingValue {
                    output += try outDescPaddingValue.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasPaddingConfig {
                output += "\(indent) paddingConfig {\n"
                if let outDescPaddingConfig = paddingConfig {
                    output += try outDescPaddingConfig.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasOperand {
                    if let hashValueoperand = operand?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoperand
                    }
                }
                if hasPaddingValue {
                    if let hashValuepaddingValue = paddingValue?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuepaddingValue
                    }
                }
                if hasPaddingConfig {
                    if let hashValuepaddingConfig = paddingConfig?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuepaddingConfig
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.PadRequest"
        }
        override public func className() -> String {
            return "Xla.PadRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.PadRequest = Xla.PadRequest()
            public func getMessage() -> Xla.PadRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var operand:Xla.ComputationDataHandle! {
                get {
                    if operandBuilder_ != nil {
                        builderResult.operand = operandBuilder_.getMessage()
                    }
                    return builderResult.operand
                }
                set (value) {
                    builderResult.hasOperand = true
                    builderResult.operand = value
                }
            }
            public var hasOperand:Bool {
                get {
                    return builderResult.hasOperand
                }
            }
            fileprivate var operandBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasOperand = true
                }
            }
            public func getOperandBuilder() -> Xla.ComputationDataHandle.Builder {
                if operandBuilder_ == nil {
                    operandBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.operand = operandBuilder_.getMessage()
                    if operand != nil {
                        try! operandBuilder_.mergeFrom(other: operand)
                    }
                }
                return operandBuilder_
            }
            @discardableResult
            public func setOperand(_ value:Xla.ComputationDataHandle!) -> Xla.PadRequest.Builder {
                self.operand = value
                return self
            }
            @discardableResult
            public func mergeOperand(value:Xla.ComputationDataHandle) throws -> Xla.PadRequest.Builder {
                if builderResult.hasOperand {
                    builderResult.operand = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.operand).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.operand = value
                }
                builderResult.hasOperand = true
                return self
            }
            @discardableResult
            public func clearOperand() -> Xla.PadRequest.Builder {
                operandBuilder_ = nil
                builderResult.hasOperand = false
                builderResult.operand = nil
                return self
            }
            public var paddingValue:Xla.ComputationDataHandle! {
                get {
                    if paddingValueBuilder_ != nil {
                        builderResult.paddingValue = paddingValueBuilder_.getMessage()
                    }
                    return builderResult.paddingValue
                }
                set (value) {
                    builderResult.hasPaddingValue = true
                    builderResult.paddingValue = value
                }
            }
            public var hasPaddingValue:Bool {
                get {
                    return builderResult.hasPaddingValue
                }
            }
            fileprivate var paddingValueBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasPaddingValue = true
                }
            }
            public func getPaddingValueBuilder() -> Xla.ComputationDataHandle.Builder {
                if paddingValueBuilder_ == nil {
                    paddingValueBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.paddingValue = paddingValueBuilder_.getMessage()
                    if paddingValue != nil {
                        try! paddingValueBuilder_.mergeFrom(other: paddingValue)
                    }
                }
                return paddingValueBuilder_
            }
            @discardableResult
            public func setPaddingValue(_ value:Xla.ComputationDataHandle!) -> Xla.PadRequest.Builder {
                self.paddingValue = value
                return self
            }
            @discardableResult
            public func mergePaddingValue(value:Xla.ComputationDataHandle) throws -> Xla.PadRequest.Builder {
                if builderResult.hasPaddingValue {
                    builderResult.paddingValue = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.paddingValue).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.paddingValue = value
                }
                builderResult.hasPaddingValue = true
                return self
            }
            @discardableResult
            public func clearPaddingValue() -> Xla.PadRequest.Builder {
                paddingValueBuilder_ = nil
                builderResult.hasPaddingValue = false
                builderResult.paddingValue = nil
                return self
            }
            public var paddingConfig:Xla.PaddingConfig! {
                get {
                    if paddingConfigBuilder_ != nil {
                        builderResult.paddingConfig = paddingConfigBuilder_.getMessage()
                    }
                    return builderResult.paddingConfig
                }
                set (value) {
                    builderResult.hasPaddingConfig = true
                    builderResult.paddingConfig = value
                }
            }
            public var hasPaddingConfig:Bool {
                get {
                    return builderResult.hasPaddingConfig
                }
            }
            fileprivate var paddingConfigBuilder_:Xla.PaddingConfig.Builder! {
                didSet {
                    builderResult.hasPaddingConfig = true
                }
            }
            public func getPaddingConfigBuilder() -> Xla.PaddingConfig.Builder {
                if paddingConfigBuilder_ == nil {
                    paddingConfigBuilder_ = Xla.PaddingConfig.Builder()
                    builderResult.paddingConfig = paddingConfigBuilder_.getMessage()
                    if paddingConfig != nil {
                        try! paddingConfigBuilder_.mergeFrom(other: paddingConfig)
                    }
                }
                return paddingConfigBuilder_
            }
            @discardableResult
            public func setPaddingConfig(_ value:Xla.PaddingConfig!) -> Xla.PadRequest.Builder {
                self.paddingConfig = value
                return self
            }
            @discardableResult
            public func mergePaddingConfig(value:Xla.PaddingConfig) throws -> Xla.PadRequest.Builder {
                if builderResult.hasPaddingConfig {
                    builderResult.paddingConfig = try Xla.PaddingConfig.builderWithPrototype(prototype:builderResult.paddingConfig).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.paddingConfig = value
                }
                builderResult.hasPaddingConfig = true
                return self
            }
            @discardableResult
            public func clearPaddingConfig() -> Xla.PadRequest.Builder {
                paddingConfigBuilder_ = nil
                builderResult.hasPaddingConfig = false
                builderResult.paddingConfig = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.PadRequest.Builder {
                builderResult = Xla.PadRequest()
                return self
            }
            override public func clone() throws -> Xla.PadRequest.Builder {
                return try Xla.PadRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.PadRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.PadRequest {
                let returnMe:Xla.PadRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.PadRequest) throws -> Xla.PadRequest.Builder {
                if other == Xla.PadRequest() {
                    return self
                }
                if (other.hasOperand) {
                    try mergeOperand(value: other.operand)
                }
                if (other.hasPaddingValue) {
                    try mergePaddingValue(value: other.paddingValue)
                }
                if (other.hasPaddingConfig) {
                    try mergePaddingConfig(value: other.paddingConfig)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.PadRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.PadRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 18:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasOperand {
                            try subBuilder.mergeFrom(other: operand)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        operand = subBuilder.buildPartial()

                    case 26:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasPaddingValue {
                            try subBuilder.mergeFrom(other: paddingValue)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        paddingValue = subBuilder.buildPartial()

                    case 34:
                        let subBuilder:Xla.PaddingConfig.Builder = Xla.PaddingConfig.Builder()
                        if hasPaddingConfig {
                            try subBuilder.mergeFrom(other: paddingConfig)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        paddingConfig = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.PadRequest.Builder {
                let resultDecodedBuilder = Xla.PadRequest.Builder()
                if let jsonValueOperand = jsonMap["operand"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.operand = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueOperand).build()

                }
                if let jsonValuePaddingValue = jsonMap["paddingValue"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.paddingValue = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValuePaddingValue).build()

                }
                if let jsonValuePaddingConfig = jsonMap["paddingConfig"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.paddingConfig = try Xla.PaddingConfig.Builder.decodeToBuilder(jsonMap:jsonValuePaddingConfig).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.PadRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.PadRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ReshapeRequest : GeneratedMessage {

        public static func == (lhs: Xla.ReshapeRequest, rhs: Xla.ReshapeRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasOperand == rhs.hasOperand) && (!lhs.hasOperand || lhs.operand == rhs.operand)
            fieldCheck = fieldCheck && (lhs.dimensions == rhs.dimensions)
            fieldCheck = fieldCheck && (lhs.newSizes == rhs.newSizes)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var operand:Xla.ComputationDataHandle!
        public fileprivate(set) var hasOperand:Bool = false
        /// The dimension order for collapse (from fastest-changing to slowest).
        public fileprivate(set) var dimensions:Array<Int64> = Array<Int64>()
        private var dimensionsMemoizedSerializedSize:Int32 = -1
        /// The new dimension sizes (from dimension 0 to n-1).
        public fileprivate(set) var newSizes:Array<Int64> = Array<Int64>()
        private var newSizesMemoizedSerializedSize:Int32 = -1
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasOperand {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:operand)
            }
            if !dimensions.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 26)
                try codedOutputStream.writeRawVarint32(value: dimensionsMemoizedSerializedSize)
                for oneValuedimensions in dimensions {
                    try codedOutputStream.writeInt64NoTag(value: oneValuedimensions)
                }
            }
            if !newSizes.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 34)
                try codedOutputStream.writeRawVarint32(value: newSizesMemoizedSerializedSize)
                for oneValuenewSizes in newSizes {
                    try codedOutputStream.writeInt64NoTag(value: oneValuenewSizes)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasOperand {
                if let varSizeoperand = operand?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeoperand
                }
            }
            var dataSizeDimensions:Int32 = 0
            for oneValuedimensions in dimensions {
                dataSizeDimensions += oneValuedimensions.computeInt64SizeNoTag()
            }
            serialize_size += dataSizeDimensions
            if !dimensions.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeDimensions.computeInt32SizeNoTag()
            }
            dimensionsMemoizedSerializedSize = dataSizeDimensions
            var dataSizeNewSizes:Int32 = 0
            for oneValuenewSizes in newSizes {
                dataSizeNewSizes += oneValuenewSizes.computeInt64SizeNoTag()
            }
            serialize_size += dataSizeNewSizes
            if !newSizes.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeNewSizes.computeInt32SizeNoTag()
            }
            newSizesMemoizedSerializedSize = dataSizeNewSizes
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.ReshapeRequest.Builder {
            return Xla.ReshapeRequest.classBuilder() as! Xla.ReshapeRequest.Builder
        }
        public func getBuilder() -> Xla.ReshapeRequest.Builder {
            return classBuilder() as! Xla.ReshapeRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ReshapeRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ReshapeRequest.Builder()
        }
        public func toBuilder() throws -> Xla.ReshapeRequest.Builder {
            return try Xla.ReshapeRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.ReshapeRequest) throws -> Xla.ReshapeRequest.Builder {
            return try Xla.ReshapeRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasOperand {
                jsonMap["operand"] = try operand.encode()
            }
            if !dimensions.isEmpty {
                var jsonArrayDimensions:Array<String> = []
                for oneValueDimensions in dimensions {
                    jsonArrayDimensions.append("\(oneValueDimensions)")
                }
                jsonMap["dimensions"] = jsonArrayDimensions
            }
            if !newSizes.isEmpty {
                var jsonArrayNewSizes:Array<String> = []
                for oneValueNewSizes in newSizes {
                    jsonArrayNewSizes.append("\(oneValueNewSizes)")
                }
                jsonMap["newSizes"] = jsonArrayNewSizes
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.ReshapeRequest {
            return try Xla.ReshapeRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.ReshapeRequest {
            return try Xla.ReshapeRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasOperand {
                output += "\(indent) operand {\n"
                if let outDescOperand = operand {
                    output += try outDescOperand.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            var dimensionsElementIndex:Int = 0
            for oneValueDimensions in dimensions  {
                output += "\(indent) dimensions[\(dimensionsElementIndex)]: \(oneValueDimensions)\n"
                dimensionsElementIndex += 1
            }
            var newSizesElementIndex:Int = 0
            for oneValueNewSizes in newSizes  {
                output += "\(indent) newSizes[\(newSizesElementIndex)]: \(oneValueNewSizes)\n"
                newSizesElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasOperand {
                    if let hashValueoperand = operand?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoperand
                    }
                }
                for oneValueDimensions in dimensions {
                    hashCode = (hashCode &* 31) &+ oneValueDimensions.hashValue
                }
                for oneValueNewSizes in newSizes {
                    hashCode = (hashCode &* 31) &+ oneValueNewSizes.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.ReshapeRequest"
        }
        override public func className() -> String {
            return "Xla.ReshapeRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.ReshapeRequest = Xla.ReshapeRequest()
            public func getMessage() -> Xla.ReshapeRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var operand:Xla.ComputationDataHandle! {
                get {
                    if operandBuilder_ != nil {
                        builderResult.operand = operandBuilder_.getMessage()
                    }
                    return builderResult.operand
                }
                set (value) {
                    builderResult.hasOperand = true
                    builderResult.operand = value
                }
            }
            public var hasOperand:Bool {
                get {
                    return builderResult.hasOperand
                }
            }
            fileprivate var operandBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasOperand = true
                }
            }
            public func getOperandBuilder() -> Xla.ComputationDataHandle.Builder {
                if operandBuilder_ == nil {
                    operandBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.operand = operandBuilder_.getMessage()
                    if operand != nil {
                        try! operandBuilder_.mergeFrom(other: operand)
                    }
                }
                return operandBuilder_
            }
            @discardableResult
            public func setOperand(_ value:Xla.ComputationDataHandle!) -> Xla.ReshapeRequest.Builder {
                self.operand = value
                return self
            }
            @discardableResult
            public func mergeOperand(value:Xla.ComputationDataHandle) throws -> Xla.ReshapeRequest.Builder {
                if builderResult.hasOperand {
                    builderResult.operand = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.operand).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.operand = value
                }
                builderResult.hasOperand = true
                return self
            }
            @discardableResult
            public func clearOperand() -> Xla.ReshapeRequest.Builder {
                operandBuilder_ = nil
                builderResult.hasOperand = false
                builderResult.operand = nil
                return self
            }
            /// The dimension order for collapse (from fastest-changing to slowest).
            public var dimensions:Array<Int64> {
                get {
                    return builderResult.dimensions
                }
                set (array) {
                    builderResult.dimensions = array
                }
            }
            @discardableResult
            public func setDimensions(_ value:Array<Int64>) -> Xla.ReshapeRequest.Builder {
                self.dimensions = value
                return self
            }
            @discardableResult
            public func clearDimensions() -> Xla.ReshapeRequest.Builder {
                builderResult.dimensions.removeAll(keepingCapacity: false)
                return self
            }
            /// The new dimension sizes (from dimension 0 to n-1).
            public var newSizes:Array<Int64> {
                get {
                    return builderResult.newSizes
                }
                set (array) {
                    builderResult.newSizes = array
                }
            }
            @discardableResult
            public func setNewSizes(_ value:Array<Int64>) -> Xla.ReshapeRequest.Builder {
                self.newSizes = value
                return self
            }
            @discardableResult
            public func clearNewSizes() -> Xla.ReshapeRequest.Builder {
                builderResult.newSizes.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.ReshapeRequest.Builder {
                builderResult = Xla.ReshapeRequest()
                return self
            }
            override public func clone() throws -> Xla.ReshapeRequest.Builder {
                return try Xla.ReshapeRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.ReshapeRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.ReshapeRequest {
                let returnMe:Xla.ReshapeRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.ReshapeRequest) throws -> Xla.ReshapeRequest.Builder {
                if other == Xla.ReshapeRequest() {
                    return self
                }
                if (other.hasOperand) {
                    try mergeOperand(value: other.operand)
                }
                if !other.dimensions.isEmpty {
                    builderResult.dimensions += other.dimensions
                }
                if !other.newSizes.isEmpty {
                    builderResult.newSizes += other.newSizes
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.ReshapeRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ReshapeRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 18:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasOperand {
                            try subBuilder.mergeFrom(other: operand)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        operand = subBuilder.buildPartial()

                    case 26:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.dimensions.append(try codedInputStream.readInt64())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 34:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.newSizes.append(try codedInputStream.readInt64())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.ReshapeRequest.Builder {
                let resultDecodedBuilder = Xla.ReshapeRequest.Builder()
                if let jsonValueOperand = jsonMap["operand"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.operand = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueOperand).build()

                }
                if let jsonValueDimensions = jsonMap["dimensions"] as? Array<String> {
                    var jsonArrayDimensions:Array<Int64> = []
                    for oneValueDimensions in jsonValueDimensions {
                        jsonArrayDimensions.append(Int64(oneValueDimensions)!)
                    }
                    resultDecodedBuilder.dimensions = jsonArrayDimensions
                }
                if let jsonValueNewSizes = jsonMap["newSizes"] as? Array<String> {
                    var jsonArrayNewSizes:Array<Int64> = []
                    for oneValueNewSizes in jsonValueNewSizes {
                        jsonArrayNewSizes.append(Int64(oneValueNewSizes)!)
                    }
                    resultDecodedBuilder.newSizes = jsonArrayNewSizes
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.ReshapeRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.ReshapeRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class TransposeRequest : GeneratedMessage {

        public static func == (lhs: Xla.TransposeRequest, rhs: Xla.TransposeRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasOperand == rhs.hasOperand) && (!lhs.hasOperand || lhs.operand == rhs.operand)
            fieldCheck = fieldCheck && (lhs.dimensions == rhs.dimensions)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var operand:Xla.ComputationDataHandle!
        public fileprivate(set) var hasOperand:Bool = false
        /// The permutation of the operand's dimensions (in the range 0 to n-1).
        public fileprivate(set) var dimensions:Array<Int64> = Array<Int64>()
        private var dimensionsMemoizedSerializedSize:Int32 = -1
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasOperand {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:operand)
            }
            if !dimensions.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 26)
                try codedOutputStream.writeRawVarint32(value: dimensionsMemoizedSerializedSize)
                for oneValuedimensions in dimensions {
                    try codedOutputStream.writeInt64NoTag(value: oneValuedimensions)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasOperand {
                if let varSizeoperand = operand?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeoperand
                }
            }
            var dataSizeDimensions:Int32 = 0
            for oneValuedimensions in dimensions {
                dataSizeDimensions += oneValuedimensions.computeInt64SizeNoTag()
            }
            serialize_size += dataSizeDimensions
            if !dimensions.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeDimensions.computeInt32SizeNoTag()
            }
            dimensionsMemoizedSerializedSize = dataSizeDimensions
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.TransposeRequest.Builder {
            return Xla.TransposeRequest.classBuilder() as! Xla.TransposeRequest.Builder
        }
        public func getBuilder() -> Xla.TransposeRequest.Builder {
            return classBuilder() as! Xla.TransposeRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.TransposeRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.TransposeRequest.Builder()
        }
        public func toBuilder() throws -> Xla.TransposeRequest.Builder {
            return try Xla.TransposeRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.TransposeRequest) throws -> Xla.TransposeRequest.Builder {
            return try Xla.TransposeRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasOperand {
                jsonMap["operand"] = try operand.encode()
            }
            if !dimensions.isEmpty {
                var jsonArrayDimensions:Array<String> = []
                for oneValueDimensions in dimensions {
                    jsonArrayDimensions.append("\(oneValueDimensions)")
                }
                jsonMap["dimensions"] = jsonArrayDimensions
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.TransposeRequest {
            return try Xla.TransposeRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.TransposeRequest {
            return try Xla.TransposeRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasOperand {
                output += "\(indent) operand {\n"
                if let outDescOperand = operand {
                    output += try outDescOperand.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            var dimensionsElementIndex:Int = 0
            for oneValueDimensions in dimensions  {
                output += "\(indent) dimensions[\(dimensionsElementIndex)]: \(oneValueDimensions)\n"
                dimensionsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasOperand {
                    if let hashValueoperand = operand?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoperand
                    }
                }
                for oneValueDimensions in dimensions {
                    hashCode = (hashCode &* 31) &+ oneValueDimensions.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.TransposeRequest"
        }
        override public func className() -> String {
            return "Xla.TransposeRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.TransposeRequest = Xla.TransposeRequest()
            public func getMessage() -> Xla.TransposeRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var operand:Xla.ComputationDataHandle! {
                get {
                    if operandBuilder_ != nil {
                        builderResult.operand = operandBuilder_.getMessage()
                    }
                    return builderResult.operand
                }
                set (value) {
                    builderResult.hasOperand = true
                    builderResult.operand = value
                }
            }
            public var hasOperand:Bool {
                get {
                    return builderResult.hasOperand
                }
            }
            fileprivate var operandBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasOperand = true
                }
            }
            public func getOperandBuilder() -> Xla.ComputationDataHandle.Builder {
                if operandBuilder_ == nil {
                    operandBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.operand = operandBuilder_.getMessage()
                    if operand != nil {
                        try! operandBuilder_.mergeFrom(other: operand)
                    }
                }
                return operandBuilder_
            }
            @discardableResult
            public func setOperand(_ value:Xla.ComputationDataHandle!) -> Xla.TransposeRequest.Builder {
                self.operand = value
                return self
            }
            @discardableResult
            public func mergeOperand(value:Xla.ComputationDataHandle) throws -> Xla.TransposeRequest.Builder {
                if builderResult.hasOperand {
                    builderResult.operand = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.operand).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.operand = value
                }
                builderResult.hasOperand = true
                return self
            }
            @discardableResult
            public func clearOperand() -> Xla.TransposeRequest.Builder {
                operandBuilder_ = nil
                builderResult.hasOperand = false
                builderResult.operand = nil
                return self
            }
            /// The permutation of the operand's dimensions (in the range 0 to n-1).
            public var dimensions:Array<Int64> {
                get {
                    return builderResult.dimensions
                }
                set (array) {
                    builderResult.dimensions = array
                }
            }
            @discardableResult
            public func setDimensions(_ value:Array<Int64>) -> Xla.TransposeRequest.Builder {
                self.dimensions = value
                return self
            }
            @discardableResult
            public func clearDimensions() -> Xla.TransposeRequest.Builder {
                builderResult.dimensions.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.TransposeRequest.Builder {
                builderResult = Xla.TransposeRequest()
                return self
            }
            override public func clone() throws -> Xla.TransposeRequest.Builder {
                return try Xla.TransposeRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.TransposeRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.TransposeRequest {
                let returnMe:Xla.TransposeRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.TransposeRequest) throws -> Xla.TransposeRequest.Builder {
                if other == Xla.TransposeRequest() {
                    return self
                }
                if (other.hasOperand) {
                    try mergeOperand(value: other.operand)
                }
                if !other.dimensions.isEmpty {
                    builderResult.dimensions += other.dimensions
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.TransposeRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransposeRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 18:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasOperand {
                            try subBuilder.mergeFrom(other: operand)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        operand = subBuilder.buildPartial()

                    case 26:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.dimensions.append(try codedInputStream.readInt64())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.TransposeRequest.Builder {
                let resultDecodedBuilder = Xla.TransposeRequest.Builder()
                if let jsonValueOperand = jsonMap["operand"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.operand = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueOperand).build()

                }
                if let jsonValueDimensions = jsonMap["dimensions"] as? Array<String> {
                    var jsonArrayDimensions:Array<Int64> = []
                    for oneValueDimensions in jsonValueDimensions {
                        jsonArrayDimensions.append(Int64(oneValueDimensions)!)
                    }
                    resultDecodedBuilder.dimensions = jsonArrayDimensions
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.TransposeRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.TransposeRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ParameterRequest : GeneratedMessage {

        public static func == (lhs: Xla.ParameterRequest, rhs: Xla.ParameterRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasShape == rhs.hasShape) && (!lhs.hasShape || lhs.shape == rhs.shape)
            fieldCheck = fieldCheck && (lhs.hasParameter == rhs.hasParameter) && (!lhs.hasParameter || lhs.parameter == rhs.parameter)
            fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var shape:Xla.Shape!
        public fileprivate(set) var hasShape:Bool = false
        public fileprivate(set) var parameter:Int64 = Int64(0)
        public fileprivate(set) var hasParameter:Bool = false

        public fileprivate(set) var name:String = ""
        public fileprivate(set) var hasName:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasShape {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:shape)
            }
            if hasParameter {
                try codedOutputStream.writeInt64(fieldNumber: 3, value:parameter)
            }
            if hasName {
                try codedOutputStream.writeString(fieldNumber: 4, value:name)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasShape {
                if let varSizeshape = shape?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeshape
                }
            }
            if hasParameter {
                serialize_size += parameter.computeInt64Size(fieldNumber: 3)
            }
            if hasName {
                serialize_size += name.computeStringSize(fieldNumber: 4)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.ParameterRequest.Builder {
            return Xla.ParameterRequest.classBuilder() as! Xla.ParameterRequest.Builder
        }
        public func getBuilder() -> Xla.ParameterRequest.Builder {
            return classBuilder() as! Xla.ParameterRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ParameterRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ParameterRequest.Builder()
        }
        public func toBuilder() throws -> Xla.ParameterRequest.Builder {
            return try Xla.ParameterRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.ParameterRequest) throws -> Xla.ParameterRequest.Builder {
            return try Xla.ParameterRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasShape {
                jsonMap["shape"] = try shape.encode()
            }
            if hasParameter {
                jsonMap["parameter"] = "\(parameter)"
            }
            if hasName {
                jsonMap["name"] = name
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.ParameterRequest {
            return try Xla.ParameterRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.ParameterRequest {
            return try Xla.ParameterRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasShape {
                output += "\(indent) shape {\n"
                if let outDescShape = shape {
                    output += try outDescShape.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasParameter {
                output += "\(indent) parameter: \(parameter) \n"
            }
            if hasName {
                output += "\(indent) name: \(name) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasShape {
                    if let hashValueshape = shape?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueshape
                    }
                }
                if hasParameter {
                    hashCode = (hashCode &* 31) &+ parameter.hashValue
                }
                if hasName {
                    hashCode = (hashCode &* 31) &+ name.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.ParameterRequest"
        }
        override public func className() -> String {
            return "Xla.ParameterRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.ParameterRequest = Xla.ParameterRequest()
            public func getMessage() -> Xla.ParameterRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var shape:Xla.Shape! {
                get {
                    if shapeBuilder_ != nil {
                        builderResult.shape = shapeBuilder_.getMessage()
                    }
                    return builderResult.shape
                }
                set (value) {
                    builderResult.hasShape = true
                    builderResult.shape = value
                }
            }
            public var hasShape:Bool {
                get {
                    return builderResult.hasShape
                }
            }
            fileprivate var shapeBuilder_:Xla.Shape.Builder! {
                didSet {
                    builderResult.hasShape = true
                }
            }
            public func getShapeBuilder() -> Xla.Shape.Builder {
                if shapeBuilder_ == nil {
                    shapeBuilder_ = Xla.Shape.Builder()
                    builderResult.shape = shapeBuilder_.getMessage()
                    if shape != nil {
                        try! shapeBuilder_.mergeFrom(other: shape)
                    }
                }
                return shapeBuilder_
            }
            @discardableResult
            public func setShape(_ value:Xla.Shape!) -> Xla.ParameterRequest.Builder {
                self.shape = value
                return self
            }
            @discardableResult
            public func mergeShape(value:Xla.Shape) throws -> Xla.ParameterRequest.Builder {
                if builderResult.hasShape {
                    builderResult.shape = try Xla.Shape.builderWithPrototype(prototype:builderResult.shape).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.shape = value
                }
                builderResult.hasShape = true
                return self
            }
            @discardableResult
            public func clearShape() -> Xla.ParameterRequest.Builder {
                shapeBuilder_ = nil
                builderResult.hasShape = false
                builderResult.shape = nil
                return self
            }
            public var parameter:Int64 {
                get {
                    return builderResult.parameter
                }
                set (value) {
                    builderResult.hasParameter = true
                    builderResult.parameter = value
                }
            }
            public var hasParameter:Bool {
                get {
                    return builderResult.hasParameter
                }
            }
            @discardableResult
            public func setParameter(_ value:Int64) -> Xla.ParameterRequest.Builder {
                self.parameter = value
                return self
            }
            @discardableResult
            public func clearParameter() -> Xla.ParameterRequest.Builder{
                builderResult.hasParameter = false
                builderResult.parameter = Int64(0)
                return self
            }
            public var name:String {
                get {
                    return builderResult.name
                }
                set (value) {
                    builderResult.hasName = true
                    builderResult.name = value
                }
            }
            public var hasName:Bool {
                get {
                    return builderResult.hasName
                }
            }
            @discardableResult
            public func setName(_ value:String) -> Xla.ParameterRequest.Builder {
                self.name = value
                return self
            }
            @discardableResult
            public func clearName() -> Xla.ParameterRequest.Builder{
                builderResult.hasName = false
                builderResult.name = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.ParameterRequest.Builder {
                builderResult = Xla.ParameterRequest()
                return self
            }
            override public func clone() throws -> Xla.ParameterRequest.Builder {
                return try Xla.ParameterRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.ParameterRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.ParameterRequest {
                let returnMe:Xla.ParameterRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.ParameterRequest) throws -> Xla.ParameterRequest.Builder {
                if other == Xla.ParameterRequest() {
                    return self
                }
                if (other.hasShape) {
                    try mergeShape(value: other.shape)
                }
                if other.hasParameter {
                    parameter = other.parameter
                }
                if other.hasName {
                    name = other.name
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.ParameterRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ParameterRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 18:
                        let subBuilder:Xla.Shape.Builder = Xla.Shape.Builder()
                        if hasShape {
                            try subBuilder.mergeFrom(other: shape)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        shape = subBuilder.buildPartial()

                    case 24:
                        parameter = try codedInputStream.readInt64()

                    case 34:
                        name = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.ParameterRequest.Builder {
                let resultDecodedBuilder = Xla.ParameterRequest.Builder()
                if let jsonValueShape = jsonMap["shape"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.shape = try Xla.Shape.Builder.decodeToBuilder(jsonMap:jsonValueShape).build()

                }
                if let jsonValueParameter = jsonMap["parameter"] as? String {
                    resultDecodedBuilder.parameter = Int64(jsonValueParameter)!
                } else if let jsonValueParameter = jsonMap["parameter"] as? Int {
                    resultDecodedBuilder.parameter = Int64(jsonValueParameter)
                }
                if let jsonValueName = jsonMap["name"] as? String {
                    resultDecodedBuilder.name = jsonValueName
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.ParameterRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.ParameterRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class GetLocalShapeRequest : GeneratedMessage {

        public static func == (lhs: Xla.GetLocalShapeRequest, rhs: Xla.GetLocalShapeRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasComputation == rhs.hasComputation) && (!lhs.hasComputation || lhs.computation == rhs.computation)
            fieldCheck = fieldCheck && (lhs.hasOperand == rhs.hasOperand) && (!lhs.hasOperand || lhs.operand == rhs.operand)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var computation:Xla.ComputationHandle!
        public fileprivate(set) var hasComputation:Bool = false
        public fileprivate(set) var operand:Xla.ComputationDataHandle!
        public fileprivate(set) var hasOperand:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasComputation {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:computation)
            }
            if hasOperand {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:operand)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasComputation {
                if let varSizecomputation = computation?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizecomputation
                }
            }
            if hasOperand {
                if let varSizeoperand = operand?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeoperand
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.GetLocalShapeRequest.Builder {
            return Xla.GetLocalShapeRequest.classBuilder() as! Xla.GetLocalShapeRequest.Builder
        }
        public func getBuilder() -> Xla.GetLocalShapeRequest.Builder {
            return classBuilder() as! Xla.GetLocalShapeRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.GetLocalShapeRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.GetLocalShapeRequest.Builder()
        }
        public func toBuilder() throws -> Xla.GetLocalShapeRequest.Builder {
            return try Xla.GetLocalShapeRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.GetLocalShapeRequest) throws -> Xla.GetLocalShapeRequest.Builder {
            return try Xla.GetLocalShapeRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasComputation {
                jsonMap["computation"] = try computation.encode()
            }
            if hasOperand {
                jsonMap["operand"] = try operand.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.GetLocalShapeRequest {
            return try Xla.GetLocalShapeRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.GetLocalShapeRequest {
            return try Xla.GetLocalShapeRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasComputation {
                output += "\(indent) computation {\n"
                if let outDescComputation = computation {
                    output += try outDescComputation.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasOperand {
                output += "\(indent) operand {\n"
                if let outDescOperand = operand {
                    output += try outDescOperand.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasComputation {
                    if let hashValuecomputation = computation?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecomputation
                    }
                }
                if hasOperand {
                    if let hashValueoperand = operand?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoperand
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.GetLocalShapeRequest"
        }
        override public func className() -> String {
            return "Xla.GetLocalShapeRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.GetLocalShapeRequest = Xla.GetLocalShapeRequest()
            public func getMessage() -> Xla.GetLocalShapeRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var computation:Xla.ComputationHandle! {
                get {
                    if computationBuilder_ != nil {
                        builderResult.computation = computationBuilder_.getMessage()
                    }
                    return builderResult.computation
                }
                set (value) {
                    builderResult.hasComputation = true
                    builderResult.computation = value
                }
            }
            public var hasComputation:Bool {
                get {
                    return builderResult.hasComputation
                }
            }
            fileprivate var computationBuilder_:Xla.ComputationHandle.Builder! {
                didSet {
                    builderResult.hasComputation = true
                }
            }
            public func getComputationBuilder() -> Xla.ComputationHandle.Builder {
                if computationBuilder_ == nil {
                    computationBuilder_ = Xla.ComputationHandle.Builder()
                    builderResult.computation = computationBuilder_.getMessage()
                    if computation != nil {
                        try! computationBuilder_.mergeFrom(other: computation)
                    }
                }
                return computationBuilder_
            }
            @discardableResult
            public func setComputation(_ value:Xla.ComputationHandle!) -> Xla.GetLocalShapeRequest.Builder {
                self.computation = value
                return self
            }
            @discardableResult
            public func mergeComputation(value:Xla.ComputationHandle) throws -> Xla.GetLocalShapeRequest.Builder {
                if builderResult.hasComputation {
                    builderResult.computation = try Xla.ComputationHandle.builderWithPrototype(prototype:builderResult.computation).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.computation = value
                }
                builderResult.hasComputation = true
                return self
            }
            @discardableResult
            public func clearComputation() -> Xla.GetLocalShapeRequest.Builder {
                computationBuilder_ = nil
                builderResult.hasComputation = false
                builderResult.computation = nil
                return self
            }
            public var operand:Xla.ComputationDataHandle! {
                get {
                    if operandBuilder_ != nil {
                        builderResult.operand = operandBuilder_.getMessage()
                    }
                    return builderResult.operand
                }
                set (value) {
                    builderResult.hasOperand = true
                    builderResult.operand = value
                }
            }
            public var hasOperand:Bool {
                get {
                    return builderResult.hasOperand
                }
            }
            fileprivate var operandBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasOperand = true
                }
            }
            public func getOperandBuilder() -> Xla.ComputationDataHandle.Builder {
                if operandBuilder_ == nil {
                    operandBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.operand = operandBuilder_.getMessage()
                    if operand != nil {
                        try! operandBuilder_.mergeFrom(other: operand)
                    }
                }
                return operandBuilder_
            }
            @discardableResult
            public func setOperand(_ value:Xla.ComputationDataHandle!) -> Xla.GetLocalShapeRequest.Builder {
                self.operand = value
                return self
            }
            @discardableResult
            public func mergeOperand(value:Xla.ComputationDataHandle) throws -> Xla.GetLocalShapeRequest.Builder {
                if builderResult.hasOperand {
                    builderResult.operand = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.operand).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.operand = value
                }
                builderResult.hasOperand = true
                return self
            }
            @discardableResult
            public func clearOperand() -> Xla.GetLocalShapeRequest.Builder {
                operandBuilder_ = nil
                builderResult.hasOperand = false
                builderResult.operand = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.GetLocalShapeRequest.Builder {
                builderResult = Xla.GetLocalShapeRequest()
                return self
            }
            override public func clone() throws -> Xla.GetLocalShapeRequest.Builder {
                return try Xla.GetLocalShapeRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.GetLocalShapeRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.GetLocalShapeRequest {
                let returnMe:Xla.GetLocalShapeRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.GetLocalShapeRequest) throws -> Xla.GetLocalShapeRequest.Builder {
                if other == Xla.GetLocalShapeRequest() {
                    return self
                }
                if (other.hasComputation) {
                    try mergeComputation(value: other.computation)
                }
                if (other.hasOperand) {
                    try mergeOperand(value: other.operand)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.GetLocalShapeRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.GetLocalShapeRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.ComputationHandle.Builder = Xla.ComputationHandle.Builder()
                        if hasComputation {
                            try subBuilder.mergeFrom(other: computation)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        computation = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasOperand {
                            try subBuilder.mergeFrom(other: operand)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        operand = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.GetLocalShapeRequest.Builder {
                let resultDecodedBuilder = Xla.GetLocalShapeRequest.Builder()
                if let jsonValueComputation = jsonMap["computation"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.computation = try Xla.ComputationHandle.Builder.decodeToBuilder(jsonMap:jsonValueComputation).build()

                }
                if let jsonValueOperand = jsonMap["operand"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.operand = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueOperand).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.GetLocalShapeRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.GetLocalShapeRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class GetLocalShapeResponse : GeneratedMessage {

        public static func == (lhs: Xla.GetLocalShapeResponse, rhs: Xla.GetLocalShapeResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasShape == rhs.hasShape) && (!lhs.hasShape || lhs.shape == rhs.shape)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var shape:Xla.Shape!
        public fileprivate(set) var hasShape:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasShape {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:shape)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasShape {
                if let varSizeshape = shape?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeshape
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.GetLocalShapeResponse.Builder {
            return Xla.GetLocalShapeResponse.classBuilder() as! Xla.GetLocalShapeResponse.Builder
        }
        public func getBuilder() -> Xla.GetLocalShapeResponse.Builder {
            return classBuilder() as! Xla.GetLocalShapeResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.GetLocalShapeResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.GetLocalShapeResponse.Builder()
        }
        public func toBuilder() throws -> Xla.GetLocalShapeResponse.Builder {
            return try Xla.GetLocalShapeResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.GetLocalShapeResponse) throws -> Xla.GetLocalShapeResponse.Builder {
            return try Xla.GetLocalShapeResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasShape {
                jsonMap["shape"] = try shape.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.GetLocalShapeResponse {
            return try Xla.GetLocalShapeResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.GetLocalShapeResponse {
            return try Xla.GetLocalShapeResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasShape {
                output += "\(indent) shape {\n"
                if let outDescShape = shape {
                    output += try outDescShape.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasShape {
                    if let hashValueshape = shape?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueshape
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.GetLocalShapeResponse"
        }
        override public func className() -> String {
            return "Xla.GetLocalShapeResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.GetLocalShapeResponse = Xla.GetLocalShapeResponse()
            public func getMessage() -> Xla.GetLocalShapeResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var shape:Xla.Shape! {
                get {
                    if shapeBuilder_ != nil {
                        builderResult.shape = shapeBuilder_.getMessage()
                    }
                    return builderResult.shape
                }
                set (value) {
                    builderResult.hasShape = true
                    builderResult.shape = value
                }
            }
            public var hasShape:Bool {
                get {
                    return builderResult.hasShape
                }
            }
            fileprivate var shapeBuilder_:Xla.Shape.Builder! {
                didSet {
                    builderResult.hasShape = true
                }
            }
            public func getShapeBuilder() -> Xla.Shape.Builder {
                if shapeBuilder_ == nil {
                    shapeBuilder_ = Xla.Shape.Builder()
                    builderResult.shape = shapeBuilder_.getMessage()
                    if shape != nil {
                        try! shapeBuilder_.mergeFrom(other: shape)
                    }
                }
                return shapeBuilder_
            }
            @discardableResult
            public func setShape(_ value:Xla.Shape!) -> Xla.GetLocalShapeResponse.Builder {
                self.shape = value
                return self
            }
            @discardableResult
            public func mergeShape(value:Xla.Shape) throws -> Xla.GetLocalShapeResponse.Builder {
                if builderResult.hasShape {
                    builderResult.shape = try Xla.Shape.builderWithPrototype(prototype:builderResult.shape).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.shape = value
                }
                builderResult.hasShape = true
                return self
            }
            @discardableResult
            public func clearShape() -> Xla.GetLocalShapeResponse.Builder {
                shapeBuilder_ = nil
                builderResult.hasShape = false
                builderResult.shape = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.GetLocalShapeResponse.Builder {
                builderResult = Xla.GetLocalShapeResponse()
                return self
            }
            override public func clone() throws -> Xla.GetLocalShapeResponse.Builder {
                return try Xla.GetLocalShapeResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.GetLocalShapeResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.GetLocalShapeResponse {
                let returnMe:Xla.GetLocalShapeResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.GetLocalShapeResponse) throws -> Xla.GetLocalShapeResponse.Builder {
                if other == Xla.GetLocalShapeResponse() {
                    return self
                }
                if (other.hasShape) {
                    try mergeShape(value: other.shape)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.GetLocalShapeResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.GetLocalShapeResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.Shape.Builder = Xla.Shape.Builder()
                        if hasShape {
                            try subBuilder.mergeFrom(other: shape)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        shape = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.GetLocalShapeResponse.Builder {
                let resultDecodedBuilder = Xla.GetLocalShapeResponse.Builder()
                if let jsonValueShape = jsonMap["shape"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.shape = try Xla.Shape.Builder.decodeToBuilder(jsonMap:jsonValueShape).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.GetLocalShapeResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.GetLocalShapeResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class TraceRequest : GeneratedMessage {

        public static func == (lhs: Xla.TraceRequest, rhs: Xla.TraceRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasTag == rhs.hasTag) && (!lhs.hasTag || lhs.tag == rhs.tag)
            fieldCheck = fieldCheck && (lhs.hasOperand == rhs.hasOperand) && (!lhs.hasOperand || lhs.operand == rhs.operand)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var tag:String = ""
        public fileprivate(set) var hasTag:Bool = false

        public fileprivate(set) var operand:Xla.ComputationDataHandle!
        public fileprivate(set) var hasOperand:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasTag {
                try codedOutputStream.writeString(fieldNumber: 2, value:tag)
            }
            if hasOperand {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:operand)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasTag {
                serialize_size += tag.computeStringSize(fieldNumber: 2)
            }
            if hasOperand {
                if let varSizeoperand = operand?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizeoperand
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.TraceRequest.Builder {
            return Xla.TraceRequest.classBuilder() as! Xla.TraceRequest.Builder
        }
        public func getBuilder() -> Xla.TraceRequest.Builder {
            return classBuilder() as! Xla.TraceRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.TraceRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.TraceRequest.Builder()
        }
        public func toBuilder() throws -> Xla.TraceRequest.Builder {
            return try Xla.TraceRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.TraceRequest) throws -> Xla.TraceRequest.Builder {
            return try Xla.TraceRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasTag {
                jsonMap["tag"] = tag
            }
            if hasOperand {
                jsonMap["operand"] = try operand.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.TraceRequest {
            return try Xla.TraceRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.TraceRequest {
            return try Xla.TraceRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasTag {
                output += "\(indent) tag: \(tag) \n"
            }
            if hasOperand {
                output += "\(indent) operand {\n"
                if let outDescOperand = operand {
                    output += try outDescOperand.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasTag {
                    hashCode = (hashCode &* 31) &+ tag.hashValue
                }
                if hasOperand {
                    if let hashValueoperand = operand?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoperand
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.TraceRequest"
        }
        override public func className() -> String {
            return "Xla.TraceRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.TraceRequest = Xla.TraceRequest()
            public func getMessage() -> Xla.TraceRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var tag:String {
                get {
                    return builderResult.tag
                }
                set (value) {
                    builderResult.hasTag = true
                    builderResult.tag = value
                }
            }
            public var hasTag:Bool {
                get {
                    return builderResult.hasTag
                }
            }
            @discardableResult
            public func setTag(_ value:String) -> Xla.TraceRequest.Builder {
                self.tag = value
                return self
            }
            @discardableResult
            public func clearTag() -> Xla.TraceRequest.Builder{
                builderResult.hasTag = false
                builderResult.tag = ""
                return self
            }
            public var operand:Xla.ComputationDataHandle! {
                get {
                    if operandBuilder_ != nil {
                        builderResult.operand = operandBuilder_.getMessage()
                    }
                    return builderResult.operand
                }
                set (value) {
                    builderResult.hasOperand = true
                    builderResult.operand = value
                }
            }
            public var hasOperand:Bool {
                get {
                    return builderResult.hasOperand
                }
            }
            fileprivate var operandBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasOperand = true
                }
            }
            public func getOperandBuilder() -> Xla.ComputationDataHandle.Builder {
                if operandBuilder_ == nil {
                    operandBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.operand = operandBuilder_.getMessage()
                    if operand != nil {
                        try! operandBuilder_.mergeFrom(other: operand)
                    }
                }
                return operandBuilder_
            }
            @discardableResult
            public func setOperand(_ value:Xla.ComputationDataHandle!) -> Xla.TraceRequest.Builder {
                self.operand = value
                return self
            }
            @discardableResult
            public func mergeOperand(value:Xla.ComputationDataHandle) throws -> Xla.TraceRequest.Builder {
                if builderResult.hasOperand {
                    builderResult.operand = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.operand).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.operand = value
                }
                builderResult.hasOperand = true
                return self
            }
            @discardableResult
            public func clearOperand() -> Xla.TraceRequest.Builder {
                operandBuilder_ = nil
                builderResult.hasOperand = false
                builderResult.operand = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.TraceRequest.Builder {
                builderResult = Xla.TraceRequest()
                return self
            }
            override public func clone() throws -> Xla.TraceRequest.Builder {
                return try Xla.TraceRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.TraceRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.TraceRequest {
                let returnMe:Xla.TraceRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.TraceRequest) throws -> Xla.TraceRequest.Builder {
                if other == Xla.TraceRequest() {
                    return self
                }
                if other.hasTag {
                    tag = other.tag
                }
                if (other.hasOperand) {
                    try mergeOperand(value: other.operand)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.TraceRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TraceRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 18:
                        tag = try codedInputStream.readString()

                    case 26:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasOperand {
                            try subBuilder.mergeFrom(other: operand)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        operand = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.TraceRequest.Builder {
                let resultDecodedBuilder = Xla.TraceRequest.Builder()
                if let jsonValueTag = jsonMap["tag"] as? String {
                    resultDecodedBuilder.tag = jsonValueTag
                }
                if let jsonValueOperand = jsonMap["operand"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.operand = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueOperand).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.TraceRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.TraceRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ConvertRequest : GeneratedMessage {

        public static func == (lhs: Xla.ConvertRequest, rhs: Xla.ConvertRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasOperand == rhs.hasOperand) && (!lhs.hasOperand || lhs.operand == rhs.operand)
            fieldCheck = fieldCheck && (lhs.hasNewElementType == rhs.hasNewElementType) && (!lhs.hasNewElementType || lhs.newElementType == rhs.newElementType)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var operand:Xla.ComputationDataHandle!
        public fileprivate(set) var hasOperand:Bool = false
        public fileprivate(set) var newElementType:Xla.PrimitiveType = Xla.PrimitiveType.primitiveTypeInvalid
        public fileprivate(set) var hasNewElementType:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasOperand {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:operand)
            }
            if hasNewElementType {
                try codedOutputStream.writeEnum(fieldNumber: 3, value:newElementType.rawValue)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasOperand {
                if let varSizeoperand = operand?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeoperand
                }
            }
            if (hasNewElementType) {
                serialize_size += newElementType.rawValue.computeEnumSize(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.ConvertRequest.Builder {
            return Xla.ConvertRequest.classBuilder() as! Xla.ConvertRequest.Builder
        }
        public func getBuilder() -> Xla.ConvertRequest.Builder {
            return classBuilder() as! Xla.ConvertRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ConvertRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ConvertRequest.Builder()
        }
        public func toBuilder() throws -> Xla.ConvertRequest.Builder {
            return try Xla.ConvertRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.ConvertRequest) throws -> Xla.ConvertRequest.Builder {
            return try Xla.ConvertRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasOperand {
                jsonMap["operand"] = try operand.encode()
            }
            if hasNewElementType {
                jsonMap["newElementType"] = newElementType.toString()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.ConvertRequest {
            return try Xla.ConvertRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.ConvertRequest {
            return try Xla.ConvertRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasOperand {
                output += "\(indent) operand {\n"
                if let outDescOperand = operand {
                    output += try outDescOperand.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if (hasNewElementType) {
                output += "\(indent) newElementType: \(newElementType.description)\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasOperand {
                    if let hashValueoperand = operand?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoperand
                    }
                }
                if hasNewElementType {
                     hashCode = (hashCode &* 31) &+ newElementType.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.ConvertRequest"
        }
        override public func className() -> String {
            return "Xla.ConvertRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.ConvertRequest = Xla.ConvertRequest()
            public func getMessage() -> Xla.ConvertRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var operand:Xla.ComputationDataHandle! {
                get {
                    if operandBuilder_ != nil {
                        builderResult.operand = operandBuilder_.getMessage()
                    }
                    return builderResult.operand
                }
                set (value) {
                    builderResult.hasOperand = true
                    builderResult.operand = value
                }
            }
            public var hasOperand:Bool {
                get {
                    return builderResult.hasOperand
                }
            }
            fileprivate var operandBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasOperand = true
                }
            }
            public func getOperandBuilder() -> Xla.ComputationDataHandle.Builder {
                if operandBuilder_ == nil {
                    operandBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.operand = operandBuilder_.getMessage()
                    if operand != nil {
                        try! operandBuilder_.mergeFrom(other: operand)
                    }
                }
                return operandBuilder_
            }
            @discardableResult
            public func setOperand(_ value:Xla.ComputationDataHandle!) -> Xla.ConvertRequest.Builder {
                self.operand = value
                return self
            }
            @discardableResult
            public func mergeOperand(value:Xla.ComputationDataHandle) throws -> Xla.ConvertRequest.Builder {
                if builderResult.hasOperand {
                    builderResult.operand = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.operand).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.operand = value
                }
                builderResult.hasOperand = true
                return self
            }
            @discardableResult
            public func clearOperand() -> Xla.ConvertRequest.Builder {
                operandBuilder_ = nil
                builderResult.hasOperand = false
                builderResult.operand = nil
                return self
            }
                public var newElementType:Xla.PrimitiveType {
                    get {
                        return builderResult.newElementType
                    }
                    set (value) {
                        builderResult.hasNewElementType = true
                        builderResult.newElementType = value
                    }
                }
                public var hasNewElementType:Bool{
                    get {
                        return builderResult.hasNewElementType
                    }
                }
            @discardableResult
                public func setNewElementType(_ value:Xla.PrimitiveType) -> Xla.ConvertRequest.Builder {
                  self.newElementType = value
                  return self
                }
            @discardableResult
                public func clearNewElementType() -> Xla.ConvertRequest.Builder {
                   builderResult.hasNewElementType = false
                   builderResult.newElementType = .primitiveTypeInvalid
                   return self
                }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.ConvertRequest.Builder {
                builderResult = Xla.ConvertRequest()
                return self
            }
            override public func clone() throws -> Xla.ConvertRequest.Builder {
                return try Xla.ConvertRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.ConvertRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.ConvertRequest {
                let returnMe:Xla.ConvertRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.ConvertRequest) throws -> Xla.ConvertRequest.Builder {
                if other == Xla.ConvertRequest() {
                    return self
                }
                if (other.hasOperand) {
                    try mergeOperand(value: other.operand)
                }
                if other.hasNewElementType {
                    newElementType = other.newElementType
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.ConvertRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ConvertRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 18:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasOperand {
                            try subBuilder.mergeFrom(other: operand)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        operand = subBuilder.buildPartial()

                    case 24:
                        let valueIntnewElementType = try codedInputStream.readEnum()
                        if let enumsnewElementType = Xla.PrimitiveType(rawValue:valueIntnewElementType){
                            newElementType = enumsnewElementType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 3, value:Int64(valueIntnewElementType))
                        }

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.ConvertRequest.Builder {
                let resultDecodedBuilder = Xla.ConvertRequest.Builder()
                if let jsonValueOperand = jsonMap["operand"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.operand = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueOperand).build()

                }
                if let jsonValueNewElementType = jsonMap["newElementType"] as? String {
                    resultDecodedBuilder.newElementType = try Xla.PrimitiveType.fromString(str: jsonValueNewElementType)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.ConvertRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.ConvertRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ConcatenateRequest : GeneratedMessage {

        public static func == (lhs: Xla.ConcatenateRequest, rhs: Xla.ConcatenateRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.operands == rhs.operands)
            fieldCheck = fieldCheck && (lhs.hasDimension == rhs.hasDimension) && (!lhs.hasDimension || lhs.dimension == rhs.dimension)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var operands:Array<Xla.ComputationDataHandle>  = Array<Xla.ComputationDataHandle>()
        /// The dimension in which we concatenate; e.g. if you had dimension arrays of
        /// [4, 1] and [5, 1], you'd concatenate in dimension 0 to produce a [9, 1].
        /// Attempting to concatenate those in dimension 1 would produce an error, as
        /// 4 != 5 (and there is no ragged array support).
        public fileprivate(set) var dimension:Int64 = Int64(0)
        public fileprivate(set) var hasDimension:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementOperands in operands {
                  try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementOperands)
            }
            if hasDimension {
                try codedOutputStream.writeInt64(fieldNumber: 3, value:dimension)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementOperands in operands {
                serialize_size += oneElementOperands.computeMessageSize(fieldNumber: 2)
            }
            if hasDimension {
                serialize_size += dimension.computeInt64Size(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.ConcatenateRequest.Builder {
            return Xla.ConcatenateRequest.classBuilder() as! Xla.ConcatenateRequest.Builder
        }
        public func getBuilder() -> Xla.ConcatenateRequest.Builder {
            return classBuilder() as! Xla.ConcatenateRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ConcatenateRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ConcatenateRequest.Builder()
        }
        public func toBuilder() throws -> Xla.ConcatenateRequest.Builder {
            return try Xla.ConcatenateRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.ConcatenateRequest) throws -> Xla.ConcatenateRequest.Builder {
            return try Xla.ConcatenateRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !operands.isEmpty {
                var jsonArrayOperands:Array<Dictionary<String,Any>> = []
                for oneValueOperands in operands {
                    let ecodedMessageOperands = try oneValueOperands.encode()
                    jsonArrayOperands.append(ecodedMessageOperands)
                }
                jsonMap["operands"] = jsonArrayOperands
            }
            if hasDimension {
                jsonMap["dimension"] = "\(dimension)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.ConcatenateRequest {
            return try Xla.ConcatenateRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.ConcatenateRequest {
            return try Xla.ConcatenateRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var operandsElementIndex:Int = 0
            for oneElementOperands in operands {
                output += "\(indent) operands[\(operandsElementIndex)] {\n"
                output += try oneElementOperands.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                operandsElementIndex += 1
            }
            if hasDimension {
                output += "\(indent) dimension: \(dimension) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementOperands in operands {
                    hashCode = (hashCode &* 31) &+ oneElementOperands.hashValue
                }
                if hasDimension {
                    hashCode = (hashCode &* 31) &+ dimension.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.ConcatenateRequest"
        }
        override public func className() -> String {
            return "Xla.ConcatenateRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.ConcatenateRequest = Xla.ConcatenateRequest()
            public func getMessage() -> Xla.ConcatenateRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var operands:Array<Xla.ComputationDataHandle> {
                get {
                    return builderResult.operands
                }
                set (value) {
                    builderResult.operands = value
                }
            }
            @discardableResult
            public func setOperands(_ value:Array<Xla.ComputationDataHandle>) -> Xla.ConcatenateRequest.Builder {
                self.operands = value
                return self
            }
            @discardableResult
            public func clearOperands() -> Xla.ConcatenateRequest.Builder {
                builderResult.operands.removeAll(keepingCapacity: false)
                return self
            }
            /// The dimension in which we concatenate; e.g. if you had dimension arrays of
            /// [4, 1] and [5, 1], you'd concatenate in dimension 0 to produce a [9, 1].
            /// Attempting to concatenate those in dimension 1 would produce an error, as
            /// 4 != 5 (and there is no ragged array support).
            public var dimension:Int64 {
                get {
                    return builderResult.dimension
                }
                set (value) {
                    builderResult.hasDimension = true
                    builderResult.dimension = value
                }
            }
            public var hasDimension:Bool {
                get {
                    return builderResult.hasDimension
                }
            }
            @discardableResult
            public func setDimension(_ value:Int64) -> Xla.ConcatenateRequest.Builder {
                self.dimension = value
                return self
            }
            @discardableResult
            public func clearDimension() -> Xla.ConcatenateRequest.Builder{
                builderResult.hasDimension = false
                builderResult.dimension = Int64(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.ConcatenateRequest.Builder {
                builderResult = Xla.ConcatenateRequest()
                return self
            }
            override public func clone() throws -> Xla.ConcatenateRequest.Builder {
                return try Xla.ConcatenateRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.ConcatenateRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.ConcatenateRequest {
                let returnMe:Xla.ConcatenateRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.ConcatenateRequest) throws -> Xla.ConcatenateRequest.Builder {
                if other == Xla.ConcatenateRequest() {
                    return self
                }
                if !other.operands.isEmpty  {
                     builderResult.operands += other.operands
                }
                if other.hasDimension {
                    dimension = other.dimension
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.ConcatenateRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ConcatenateRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 18:
                        let subBuilder = Xla.ComputationDataHandle.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        operands.append(subBuilder.buildPartial())

                    case 24:
                        dimension = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.ConcatenateRequest.Builder {
                let resultDecodedBuilder = Xla.ConcatenateRequest.Builder()
                if let jsonValueOperands = jsonMap["operands"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayOperands:Array<Xla.ComputationDataHandle> = []
                    for oneValueOperands in jsonValueOperands {
                        let messageFromStringOperands = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:oneValueOperands).build()

                        jsonArrayOperands.append(messageFromStringOperands)
                    }
                    resultDecodedBuilder.operands = jsonArrayOperands
                }
                if let jsonValueDimension = jsonMap["dimension"] as? String {
                    resultDecodedBuilder.dimension = Int64(jsonValueDimension)!
                } else if let jsonValueDimension = jsonMap["dimension"] as? Int {
                    resultDecodedBuilder.dimension = Int64(jsonValueDimension)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.ConcatenateRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.ConcatenateRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class WhileRequest : GeneratedMessage {

        public static func == (lhs: Xla.WhileRequest, rhs: Xla.WhileRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasCondition == rhs.hasCondition) && (!lhs.hasCondition || lhs.condition == rhs.condition)
            fieldCheck = fieldCheck && (lhs.hasBody == rhs.hasBody) && (!lhs.hasBody || lhs.body == rhs.body)
            fieldCheck = fieldCheck && (lhs.hasInit == rhs.hasInit) && (!lhs.hasInit || lhs.`init` == rhs.`init`)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var condition:Xla.ComputationHandle!
        public fileprivate(set) var hasCondition:Bool = false
        public fileprivate(set) var body:Xla.ComputationHandle!
        public fileprivate(set) var hasBody:Bool = false
        public fileprivate(set) var `init`:Xla.ComputationDataHandle!
        public fileprivate(set) var hasInit:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasCondition {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:condition)
            }
            if hasBody {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:body)
            }
            if hasInit {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:`init`)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasCondition {
                if let varSizecondition = condition?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizecondition
                }
            }
            if hasBody {
                if let varSizebody = body?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizebody
                }
            }
            if hasInit {
                if let varSizeinit = `init`?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizeinit
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.WhileRequest.Builder {
            return Xla.WhileRequest.classBuilder() as! Xla.WhileRequest.Builder
        }
        public func getBuilder() -> Xla.WhileRequest.Builder {
            return classBuilder() as! Xla.WhileRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.WhileRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.WhileRequest.Builder()
        }
        public func toBuilder() throws -> Xla.WhileRequest.Builder {
            return try Xla.WhileRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.WhileRequest) throws -> Xla.WhileRequest.Builder {
            return try Xla.WhileRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasCondition {
                jsonMap["condition"] = try condition.encode()
            }
            if hasBody {
                jsonMap["body"] = try body.encode()
            }
            if hasInit {
                jsonMap["init"] = try `init`.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.WhileRequest {
            return try Xla.WhileRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.WhileRequest {
            return try Xla.WhileRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasCondition {
                output += "\(indent) condition {\n"
                if let outDescCondition = condition {
                    output += try outDescCondition.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasBody {
                output += "\(indent) body {\n"
                if let outDescBody = body {
                    output += try outDescBody.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasInit {
                output += "\(indent) init {\n"
                if let outDescInit = `init` {
                    output += try outDescInit.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasCondition {
                    if let hashValuecondition = condition?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecondition
                    }
                }
                if hasBody {
                    if let hashValuebody = body?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuebody
                    }
                }
                if hasInit {
                    if let hashValueinit = `init`?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueinit
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.WhileRequest"
        }
        override public func className() -> String {
            return "Xla.WhileRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.WhileRequest = Xla.WhileRequest()
            public func getMessage() -> Xla.WhileRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var condition:Xla.ComputationHandle! {
                get {
                    if conditionBuilder_ != nil {
                        builderResult.condition = conditionBuilder_.getMessage()
                    }
                    return builderResult.condition
                }
                set (value) {
                    builderResult.hasCondition = true
                    builderResult.condition = value
                }
            }
            public var hasCondition:Bool {
                get {
                    return builderResult.hasCondition
                }
            }
            fileprivate var conditionBuilder_:Xla.ComputationHandle.Builder! {
                didSet {
                    builderResult.hasCondition = true
                }
            }
            public func getConditionBuilder() -> Xla.ComputationHandle.Builder {
                if conditionBuilder_ == nil {
                    conditionBuilder_ = Xla.ComputationHandle.Builder()
                    builderResult.condition = conditionBuilder_.getMessage()
                    if condition != nil {
                        try! conditionBuilder_.mergeFrom(other: condition)
                    }
                }
                return conditionBuilder_
            }
            @discardableResult
            public func setCondition(_ value:Xla.ComputationHandle!) -> Xla.WhileRequest.Builder {
                self.condition = value
                return self
            }
            @discardableResult
            public func mergeCondition(value:Xla.ComputationHandle) throws -> Xla.WhileRequest.Builder {
                if builderResult.hasCondition {
                    builderResult.condition = try Xla.ComputationHandle.builderWithPrototype(prototype:builderResult.condition).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.condition = value
                }
                builderResult.hasCondition = true
                return self
            }
            @discardableResult
            public func clearCondition() -> Xla.WhileRequest.Builder {
                conditionBuilder_ = nil
                builderResult.hasCondition = false
                builderResult.condition = nil
                return self
            }
            public var body:Xla.ComputationHandle! {
                get {
                    if bodyBuilder_ != nil {
                        builderResult.body = bodyBuilder_.getMessage()
                    }
                    return builderResult.body
                }
                set (value) {
                    builderResult.hasBody = true
                    builderResult.body = value
                }
            }
            public var hasBody:Bool {
                get {
                    return builderResult.hasBody
                }
            }
            fileprivate var bodyBuilder_:Xla.ComputationHandle.Builder! {
                didSet {
                    builderResult.hasBody = true
                }
            }
            public func getBodyBuilder() -> Xla.ComputationHandle.Builder {
                if bodyBuilder_ == nil {
                    bodyBuilder_ = Xla.ComputationHandle.Builder()
                    builderResult.body = bodyBuilder_.getMessage()
                    if body != nil {
                        try! bodyBuilder_.mergeFrom(other: body)
                    }
                }
                return bodyBuilder_
            }
            @discardableResult
            public func setBody(_ value:Xla.ComputationHandle!) -> Xla.WhileRequest.Builder {
                self.body = value
                return self
            }
            @discardableResult
            public func mergeBody(value:Xla.ComputationHandle) throws -> Xla.WhileRequest.Builder {
                if builderResult.hasBody {
                    builderResult.body = try Xla.ComputationHandle.builderWithPrototype(prototype:builderResult.body).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.body = value
                }
                builderResult.hasBody = true
                return self
            }
            @discardableResult
            public func clearBody() -> Xla.WhileRequest.Builder {
                bodyBuilder_ = nil
                builderResult.hasBody = false
                builderResult.body = nil
                return self
            }
            public var `init`:Xla.ComputationDataHandle! {
                get {
                    if initBuilder_ != nil {
                        builderResult.`init` = initBuilder_.getMessage()
                    }
                    return builderResult.`init`
                }
                set (value) {
                    builderResult.hasInit = true
                    builderResult.`init` = value
                }
            }
            public var hasInit:Bool {
                get {
                    return builderResult.hasInit
                }
            }
            fileprivate var initBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasInit = true
                }
            }
            public func getInitBuilder() -> Xla.ComputationDataHandle.Builder {
                if initBuilder_ == nil {
                    initBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.`init` = initBuilder_.getMessage()
                    if `init` != nil {
                        try! initBuilder_.mergeFrom(other: `init`)
                    }
                }
                return initBuilder_
            }
            @discardableResult
            public func setInit(_ value:Xla.ComputationDataHandle!) -> Xla.WhileRequest.Builder {
                self.`init` = value
                return self
            }
            @discardableResult
            public func mergeInit(value:Xla.ComputationDataHandle) throws -> Xla.WhileRequest.Builder {
                if builderResult.hasInit {
                    builderResult.`init` = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.`init`).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.`init` = value
                }
                builderResult.hasInit = true
                return self
            }
            @discardableResult
            public func clearInit() -> Xla.WhileRequest.Builder {
                initBuilder_ = nil
                builderResult.hasInit = false
                builderResult.`init` = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.WhileRequest.Builder {
                builderResult = Xla.WhileRequest()
                return self
            }
            override public func clone() throws -> Xla.WhileRequest.Builder {
                return try Xla.WhileRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.WhileRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.WhileRequest {
                let returnMe:Xla.WhileRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.WhileRequest) throws -> Xla.WhileRequest.Builder {
                if other == Xla.WhileRequest() {
                    return self
                }
                if (other.hasCondition) {
                    try mergeCondition(value: other.condition)
                }
                if (other.hasBody) {
                    try mergeBody(value: other.body)
                }
                if (other.hasInit) {
                    try mergeInit(value: other.`init`)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.WhileRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.WhileRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 18:
                        let subBuilder:Xla.ComputationHandle.Builder = Xla.ComputationHandle.Builder()
                        if hasCondition {
                            try subBuilder.mergeFrom(other: condition)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        condition = subBuilder.buildPartial()

                    case 26:
                        let subBuilder:Xla.ComputationHandle.Builder = Xla.ComputationHandle.Builder()
                        if hasBody {
                            try subBuilder.mergeFrom(other: body)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        body = subBuilder.buildPartial()

                    case 34:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasInit {
                            try subBuilder.mergeFrom(other: `init`)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        `init` = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.WhileRequest.Builder {
                let resultDecodedBuilder = Xla.WhileRequest.Builder()
                if let jsonValueCondition = jsonMap["condition"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.condition = try Xla.ComputationHandle.Builder.decodeToBuilder(jsonMap:jsonValueCondition).build()

                }
                if let jsonValueBody = jsonMap["body"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.body = try Xla.ComputationHandle.Builder.decodeToBuilder(jsonMap:jsonValueBody).build()

                }
                if let jsonValueInit = jsonMap["init"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.`init` = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueInit).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.WhileRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.WhileRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class UnaryOpRequest : GeneratedMessage {

        public static func == (lhs: Xla.UnaryOpRequest, rhs: Xla.UnaryOpRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUnop == rhs.hasUnop) && (!lhs.hasUnop || lhs.unop == rhs.unop)
            fieldCheck = fieldCheck && (lhs.hasOperand == rhs.hasOperand) && (!lhs.hasOperand || lhs.operand == rhs.operand)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var unop:Xla.UnaryOperation = Xla.UnaryOperation.unopInvalid
        public fileprivate(set) var hasUnop:Bool = false
        public fileprivate(set) var operand:Xla.ComputationDataHandle!
        public fileprivate(set) var hasOperand:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUnop {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:unop.rawValue)
            }
            if hasOperand {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:operand)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if (hasUnop) {
                serialize_size += unop.rawValue.computeEnumSize(fieldNumber: 2)
            }
            if hasOperand {
                if let varSizeoperand = operand?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizeoperand
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.UnaryOpRequest.Builder {
            return Xla.UnaryOpRequest.classBuilder() as! Xla.UnaryOpRequest.Builder
        }
        public func getBuilder() -> Xla.UnaryOpRequest.Builder {
            return classBuilder() as! Xla.UnaryOpRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.UnaryOpRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.UnaryOpRequest.Builder()
        }
        public func toBuilder() throws -> Xla.UnaryOpRequest.Builder {
            return try Xla.UnaryOpRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.UnaryOpRequest) throws -> Xla.UnaryOpRequest.Builder {
            return try Xla.UnaryOpRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUnop {
                jsonMap["unop"] = unop.toString()
            }
            if hasOperand {
                jsonMap["operand"] = try operand.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.UnaryOpRequest {
            return try Xla.UnaryOpRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.UnaryOpRequest {
            return try Xla.UnaryOpRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if (hasUnop) {
                output += "\(indent) unop: \(unop.description)\n"
            }
            if hasOperand {
                output += "\(indent) operand {\n"
                if let outDescOperand = operand {
                    output += try outDescOperand.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUnop {
                     hashCode = (hashCode &* 31) &+ unop.hashValue
                }
                if hasOperand {
                    if let hashValueoperand = operand?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoperand
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.UnaryOpRequest"
        }
        override public func className() -> String {
            return "Xla.UnaryOpRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.UnaryOpRequest = Xla.UnaryOpRequest()
            public func getMessage() -> Xla.UnaryOpRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
                public var unop:Xla.UnaryOperation {
                    get {
                        return builderResult.unop
                    }
                    set (value) {
                        builderResult.hasUnop = true
                        builderResult.unop = value
                    }
                }
                public var hasUnop:Bool{
                    get {
                        return builderResult.hasUnop
                    }
                }
            @discardableResult
                public func setUnop(_ value:Xla.UnaryOperation) -> Xla.UnaryOpRequest.Builder {
                  self.unop = value
                  return self
                }
            @discardableResult
                public func clearUnop() -> Xla.UnaryOpRequest.Builder {
                   builderResult.hasUnop = false
                   builderResult.unop = .unopInvalid
                   return self
                }
            public var operand:Xla.ComputationDataHandle! {
                get {
                    if operandBuilder_ != nil {
                        builderResult.operand = operandBuilder_.getMessage()
                    }
                    return builderResult.operand
                }
                set (value) {
                    builderResult.hasOperand = true
                    builderResult.operand = value
                }
            }
            public var hasOperand:Bool {
                get {
                    return builderResult.hasOperand
                }
            }
            fileprivate var operandBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasOperand = true
                }
            }
            public func getOperandBuilder() -> Xla.ComputationDataHandle.Builder {
                if operandBuilder_ == nil {
                    operandBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.operand = operandBuilder_.getMessage()
                    if operand != nil {
                        try! operandBuilder_.mergeFrom(other: operand)
                    }
                }
                return operandBuilder_
            }
            @discardableResult
            public func setOperand(_ value:Xla.ComputationDataHandle!) -> Xla.UnaryOpRequest.Builder {
                self.operand = value
                return self
            }
            @discardableResult
            public func mergeOperand(value:Xla.ComputationDataHandle) throws -> Xla.UnaryOpRequest.Builder {
                if builderResult.hasOperand {
                    builderResult.operand = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.operand).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.operand = value
                }
                builderResult.hasOperand = true
                return self
            }
            @discardableResult
            public func clearOperand() -> Xla.UnaryOpRequest.Builder {
                operandBuilder_ = nil
                builderResult.hasOperand = false
                builderResult.operand = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.UnaryOpRequest.Builder {
                builderResult = Xla.UnaryOpRequest()
                return self
            }
            override public func clone() throws -> Xla.UnaryOpRequest.Builder {
                return try Xla.UnaryOpRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.UnaryOpRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.UnaryOpRequest {
                let returnMe:Xla.UnaryOpRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.UnaryOpRequest) throws -> Xla.UnaryOpRequest.Builder {
                if other == Xla.UnaryOpRequest() {
                    return self
                }
                if other.hasUnop {
                    unop = other.unop
                }
                if (other.hasOperand) {
                    try mergeOperand(value: other.operand)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.UnaryOpRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.UnaryOpRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 16:
                        let valueIntunop = try codedInputStream.readEnum()
                        if let enumsunop = Xla.UnaryOperation(rawValue:valueIntunop){
                            unop = enumsunop
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntunop))
                        }

                    case 26:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasOperand {
                            try subBuilder.mergeFrom(other: operand)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        operand = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.UnaryOpRequest.Builder {
                let resultDecodedBuilder = Xla.UnaryOpRequest.Builder()
                if let jsonValueUnop = jsonMap["unop"] as? String {
                    resultDecodedBuilder.unop = try Xla.UnaryOperation.fromString(str: jsonValueUnop)
                }
                if let jsonValueOperand = jsonMap["operand"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.operand = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueOperand).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.UnaryOpRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.UnaryOpRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class BinaryOpRequest : GeneratedMessage {

        public static func == (lhs: Xla.BinaryOpRequest, rhs: Xla.BinaryOpRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasBinop == rhs.hasBinop) && (!lhs.hasBinop || lhs.binop == rhs.binop)
            fieldCheck = fieldCheck && (lhs.hasLhs == rhs.hasLhs) && (!lhs.hasLhs || lhs.lhs == rhs.lhs)
            fieldCheck = fieldCheck && (lhs.hasRhs == rhs.hasRhs) && (!lhs.hasRhs || lhs.rhs == rhs.rhs)
            fieldCheck = fieldCheck && (lhs.broadcastDimensions == rhs.broadcastDimensions)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var binop:Xla.BinaryOperation = Xla.BinaryOperation.binopInvalid
        public fileprivate(set) var hasBinop:Bool = false
        public fileprivate(set) var lhs:Xla.ComputationDataHandle!
        public fileprivate(set) var hasLhs:Bool = false
        public fileprivate(set) var rhs:Xla.ComputationDataHandle!
        public fileprivate(set) var hasRhs:Bool = false
        public fileprivate(set) var broadcastDimensions:Array<Int64> = Array<Int64>()
        private var broadcastDimensionsMemoizedSerializedSize:Int32 = -1
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasBinop {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:binop.rawValue)
            }
            if hasLhs {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:lhs)
            }
            if hasRhs {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:rhs)
            }
            if !broadcastDimensions.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 42)
                try codedOutputStream.writeRawVarint32(value: broadcastDimensionsMemoizedSerializedSize)
                for oneValuebroadcastDimensions in broadcastDimensions {
                    try codedOutputStream.writeInt64NoTag(value: oneValuebroadcastDimensions)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if (hasBinop) {
                serialize_size += binop.rawValue.computeEnumSize(fieldNumber: 2)
            }
            if hasLhs {
                if let varSizelhs = lhs?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizelhs
                }
            }
            if hasRhs {
                if let varSizerhs = rhs?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizerhs
                }
            }
            var dataSizeBroadcastDimensions:Int32 = 0
            for oneValuebroadcastDimensions in broadcastDimensions {
                dataSizeBroadcastDimensions += oneValuebroadcastDimensions.computeInt64SizeNoTag()
            }
            serialize_size += dataSizeBroadcastDimensions
            if !broadcastDimensions.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeBroadcastDimensions.computeInt32SizeNoTag()
            }
            broadcastDimensionsMemoizedSerializedSize = dataSizeBroadcastDimensions
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.BinaryOpRequest.Builder {
            return Xla.BinaryOpRequest.classBuilder() as! Xla.BinaryOpRequest.Builder
        }
        public func getBuilder() -> Xla.BinaryOpRequest.Builder {
            return classBuilder() as! Xla.BinaryOpRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.BinaryOpRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.BinaryOpRequest.Builder()
        }
        public func toBuilder() throws -> Xla.BinaryOpRequest.Builder {
            return try Xla.BinaryOpRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.BinaryOpRequest) throws -> Xla.BinaryOpRequest.Builder {
            return try Xla.BinaryOpRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasBinop {
                jsonMap["binop"] = binop.toString()
            }
            if hasLhs {
                jsonMap["lhs"] = try lhs.encode()
            }
            if hasRhs {
                jsonMap["rhs"] = try rhs.encode()
            }
            if !broadcastDimensions.isEmpty {
                var jsonArrayBroadcastDimensions:Array<String> = []
                for oneValueBroadcastDimensions in broadcastDimensions {
                    jsonArrayBroadcastDimensions.append("\(oneValueBroadcastDimensions)")
                }
                jsonMap["broadcastDimensions"] = jsonArrayBroadcastDimensions
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.BinaryOpRequest {
            return try Xla.BinaryOpRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.BinaryOpRequest {
            return try Xla.BinaryOpRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if (hasBinop) {
                output += "\(indent) binop: \(binop.description)\n"
            }
            if hasLhs {
                output += "\(indent) lhs {\n"
                if let outDescLhs = lhs {
                    output += try outDescLhs.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasRhs {
                output += "\(indent) rhs {\n"
                if let outDescRhs = rhs {
                    output += try outDescRhs.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            var broadcastDimensionsElementIndex:Int = 0
            for oneValueBroadcastDimensions in broadcastDimensions  {
                output += "\(indent) broadcastDimensions[\(broadcastDimensionsElementIndex)]: \(oneValueBroadcastDimensions)\n"
                broadcastDimensionsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasBinop {
                     hashCode = (hashCode &* 31) &+ binop.hashValue
                }
                if hasLhs {
                    if let hashValuelhs = lhs?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuelhs
                    }
                }
                if hasRhs {
                    if let hashValuerhs = rhs?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuerhs
                    }
                }
                for oneValueBroadcastDimensions in broadcastDimensions {
                    hashCode = (hashCode &* 31) &+ oneValueBroadcastDimensions.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.BinaryOpRequest"
        }
        override public func className() -> String {
            return "Xla.BinaryOpRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.BinaryOpRequest = Xla.BinaryOpRequest()
            public func getMessage() -> Xla.BinaryOpRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
                public var binop:Xla.BinaryOperation {
                    get {
                        return builderResult.binop
                    }
                    set (value) {
                        builderResult.hasBinop = true
                        builderResult.binop = value
                    }
                }
                public var hasBinop:Bool{
                    get {
                        return builderResult.hasBinop
                    }
                }
            @discardableResult
                public func setBinop(_ value:Xla.BinaryOperation) -> Xla.BinaryOpRequest.Builder {
                  self.binop = value
                  return self
                }
            @discardableResult
                public func clearBinop() -> Xla.BinaryOpRequest.Builder {
                   builderResult.hasBinop = false
                   builderResult.binop = .binopInvalid
                   return self
                }
            public var lhs:Xla.ComputationDataHandle! {
                get {
                    if lhsBuilder_ != nil {
                        builderResult.lhs = lhsBuilder_.getMessage()
                    }
                    return builderResult.lhs
                }
                set (value) {
                    builderResult.hasLhs = true
                    builderResult.lhs = value
                }
            }
            public var hasLhs:Bool {
                get {
                    return builderResult.hasLhs
                }
            }
            fileprivate var lhsBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasLhs = true
                }
            }
            public func getLhsBuilder() -> Xla.ComputationDataHandle.Builder {
                if lhsBuilder_ == nil {
                    lhsBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.lhs = lhsBuilder_.getMessage()
                    if lhs != nil {
                        try! lhsBuilder_.mergeFrom(other: lhs)
                    }
                }
                return lhsBuilder_
            }
            @discardableResult
            public func setLhs(_ value:Xla.ComputationDataHandle!) -> Xla.BinaryOpRequest.Builder {
                self.lhs = value
                return self
            }
            @discardableResult
            public func mergeLhs(value:Xla.ComputationDataHandle) throws -> Xla.BinaryOpRequest.Builder {
                if builderResult.hasLhs {
                    builderResult.lhs = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.lhs).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.lhs = value
                }
                builderResult.hasLhs = true
                return self
            }
            @discardableResult
            public func clearLhs() -> Xla.BinaryOpRequest.Builder {
                lhsBuilder_ = nil
                builderResult.hasLhs = false
                builderResult.lhs = nil
                return self
            }
            public var rhs:Xla.ComputationDataHandle! {
                get {
                    if rhsBuilder_ != nil {
                        builderResult.rhs = rhsBuilder_.getMessage()
                    }
                    return builderResult.rhs
                }
                set (value) {
                    builderResult.hasRhs = true
                    builderResult.rhs = value
                }
            }
            public var hasRhs:Bool {
                get {
                    return builderResult.hasRhs
                }
            }
            fileprivate var rhsBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasRhs = true
                }
            }
            public func getRhsBuilder() -> Xla.ComputationDataHandle.Builder {
                if rhsBuilder_ == nil {
                    rhsBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.rhs = rhsBuilder_.getMessage()
                    if rhs != nil {
                        try! rhsBuilder_.mergeFrom(other: rhs)
                    }
                }
                return rhsBuilder_
            }
            @discardableResult
            public func setRhs(_ value:Xla.ComputationDataHandle!) -> Xla.BinaryOpRequest.Builder {
                self.rhs = value
                return self
            }
            @discardableResult
            public func mergeRhs(value:Xla.ComputationDataHandle) throws -> Xla.BinaryOpRequest.Builder {
                if builderResult.hasRhs {
                    builderResult.rhs = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.rhs).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.rhs = value
                }
                builderResult.hasRhs = true
                return self
            }
            @discardableResult
            public func clearRhs() -> Xla.BinaryOpRequest.Builder {
                rhsBuilder_ = nil
                builderResult.hasRhs = false
                builderResult.rhs = nil
                return self
            }
            public var broadcastDimensions:Array<Int64> {
                get {
                    return builderResult.broadcastDimensions
                }
                set (array) {
                    builderResult.broadcastDimensions = array
                }
            }
            @discardableResult
            public func setBroadcastDimensions(_ value:Array<Int64>) -> Xla.BinaryOpRequest.Builder {
                self.broadcastDimensions = value
                return self
            }
            @discardableResult
            public func clearBroadcastDimensions() -> Xla.BinaryOpRequest.Builder {
                builderResult.broadcastDimensions.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.BinaryOpRequest.Builder {
                builderResult = Xla.BinaryOpRequest()
                return self
            }
            override public func clone() throws -> Xla.BinaryOpRequest.Builder {
                return try Xla.BinaryOpRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.BinaryOpRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.BinaryOpRequest {
                let returnMe:Xla.BinaryOpRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.BinaryOpRequest) throws -> Xla.BinaryOpRequest.Builder {
                if other == Xla.BinaryOpRequest() {
                    return self
                }
                if other.hasBinop {
                    binop = other.binop
                }
                if (other.hasLhs) {
                    try mergeLhs(value: other.lhs)
                }
                if (other.hasRhs) {
                    try mergeRhs(value: other.rhs)
                }
                if !other.broadcastDimensions.isEmpty {
                    builderResult.broadcastDimensions += other.broadcastDimensions
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.BinaryOpRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.BinaryOpRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 16:
                        let valueIntbinop = try codedInputStream.readEnum()
                        if let enumsbinop = Xla.BinaryOperation(rawValue:valueIntbinop){
                            binop = enumsbinop
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntbinop))
                        }

                    case 26:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasLhs {
                            try subBuilder.mergeFrom(other: lhs)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        lhs = subBuilder.buildPartial()

                    case 34:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasRhs {
                            try subBuilder.mergeFrom(other: rhs)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        rhs = subBuilder.buildPartial()

                    case 42:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.broadcastDimensions.append(try codedInputStream.readInt64())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.BinaryOpRequest.Builder {
                let resultDecodedBuilder = Xla.BinaryOpRequest.Builder()
                if let jsonValueBinop = jsonMap["binop"] as? String {
                    resultDecodedBuilder.binop = try Xla.BinaryOperation.fromString(str: jsonValueBinop)
                }
                if let jsonValueLhs = jsonMap["lhs"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.lhs = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueLhs).build()

                }
                if let jsonValueRhs = jsonMap["rhs"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.rhs = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueRhs).build()

                }
                if let jsonValueBroadcastDimensions = jsonMap["broadcastDimensions"] as? Array<String> {
                    var jsonArrayBroadcastDimensions:Array<Int64> = []
                    for oneValueBroadcastDimensions in jsonValueBroadcastDimensions {
                        jsonArrayBroadcastDimensions.append(Int64(oneValueBroadcastDimensions)!)
                    }
                    resultDecodedBuilder.broadcastDimensions = jsonArrayBroadcastDimensions
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.BinaryOpRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.BinaryOpRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class RngRequest : GeneratedMessage {

        public static func == (lhs: Xla.RngRequest, rhs: Xla.RngRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasDistribution == rhs.hasDistribution) && (!lhs.hasDistribution || lhs.distribution == rhs.distribution)
            fieldCheck = fieldCheck && (lhs.parameter == rhs.parameter)
            fieldCheck = fieldCheck && (lhs.hasShape == rhs.hasShape) && (!lhs.hasShape || lhs.shape == rhs.shape)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var distribution:Xla.RandomDistribution = Xla.RandomDistribution.rngInvalid
        public fileprivate(set) var hasDistribution:Bool = false
        public fileprivate(set) var parameter:Array<Xla.ComputationDataHandle>  = Array<Xla.ComputationDataHandle>()
        public fileprivate(set) var shape:Xla.Shape!
        public fileprivate(set) var hasShape:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasDistribution {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:distribution.rawValue)
            }
            for oneElementParameter in parameter {
                  try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementParameter)
            }
            if hasShape {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:shape)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if (hasDistribution) {
                serialize_size += distribution.rawValue.computeEnumSize(fieldNumber: 2)
            }
            for oneElementParameter in parameter {
                serialize_size += oneElementParameter.computeMessageSize(fieldNumber: 3)
            }
            if hasShape {
                if let varSizeshape = shape?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizeshape
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.RngRequest.Builder {
            return Xla.RngRequest.classBuilder() as! Xla.RngRequest.Builder
        }
        public func getBuilder() -> Xla.RngRequest.Builder {
            return classBuilder() as! Xla.RngRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.RngRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.RngRequest.Builder()
        }
        public func toBuilder() throws -> Xla.RngRequest.Builder {
            return try Xla.RngRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.RngRequest) throws -> Xla.RngRequest.Builder {
            return try Xla.RngRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasDistribution {
                jsonMap["distribution"] = distribution.toString()
            }
            if !parameter.isEmpty {
                var jsonArrayParameter:Array<Dictionary<String,Any>> = []
                for oneValueParameter in parameter {
                    let ecodedMessageParameter = try oneValueParameter.encode()
                    jsonArrayParameter.append(ecodedMessageParameter)
                }
                jsonMap["parameter"] = jsonArrayParameter
            }
            if hasShape {
                jsonMap["shape"] = try shape.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.RngRequest {
            return try Xla.RngRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.RngRequest {
            return try Xla.RngRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if (hasDistribution) {
                output += "\(indent) distribution: \(distribution.description)\n"
            }
            var parameterElementIndex:Int = 0
            for oneElementParameter in parameter {
                output += "\(indent) parameter[\(parameterElementIndex)] {\n"
                output += try oneElementParameter.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                parameterElementIndex += 1
            }
            if hasShape {
                output += "\(indent) shape {\n"
                if let outDescShape = shape {
                    output += try outDescShape.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasDistribution {
                     hashCode = (hashCode &* 31) &+ distribution.hashValue
                }
                for oneElementParameter in parameter {
                    hashCode = (hashCode &* 31) &+ oneElementParameter.hashValue
                }
                if hasShape {
                    if let hashValueshape = shape?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueshape
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.RngRequest"
        }
        override public func className() -> String {
            return "Xla.RngRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.RngRequest = Xla.RngRequest()
            public func getMessage() -> Xla.RngRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
                public var distribution:Xla.RandomDistribution {
                    get {
                        return builderResult.distribution
                    }
                    set (value) {
                        builderResult.hasDistribution = true
                        builderResult.distribution = value
                    }
                }
                public var hasDistribution:Bool{
                    get {
                        return builderResult.hasDistribution
                    }
                }
            @discardableResult
                public func setDistribution(_ value:Xla.RandomDistribution) -> Xla.RngRequest.Builder {
                  self.distribution = value
                  return self
                }
            @discardableResult
                public func clearDistribution() -> Xla.RngRequest.Builder {
                   builderResult.hasDistribution = false
                   builderResult.distribution = .rngInvalid
                   return self
                }
            public var parameter:Array<Xla.ComputationDataHandle> {
                get {
                    return builderResult.parameter
                }
                set (value) {
                    builderResult.parameter = value
                }
            }
            @discardableResult
            public func setParameter(_ value:Array<Xla.ComputationDataHandle>) -> Xla.RngRequest.Builder {
                self.parameter = value
                return self
            }
            @discardableResult
            public func clearParameter() -> Xla.RngRequest.Builder {
                builderResult.parameter.removeAll(keepingCapacity: false)
                return self
            }
            public var shape:Xla.Shape! {
                get {
                    if shapeBuilder_ != nil {
                        builderResult.shape = shapeBuilder_.getMessage()
                    }
                    return builderResult.shape
                }
                set (value) {
                    builderResult.hasShape = true
                    builderResult.shape = value
                }
            }
            public var hasShape:Bool {
                get {
                    return builderResult.hasShape
                }
            }
            fileprivate var shapeBuilder_:Xla.Shape.Builder! {
                didSet {
                    builderResult.hasShape = true
                }
            }
            public func getShapeBuilder() -> Xla.Shape.Builder {
                if shapeBuilder_ == nil {
                    shapeBuilder_ = Xla.Shape.Builder()
                    builderResult.shape = shapeBuilder_.getMessage()
                    if shape != nil {
                        try! shapeBuilder_.mergeFrom(other: shape)
                    }
                }
                return shapeBuilder_
            }
            @discardableResult
            public func setShape(_ value:Xla.Shape!) -> Xla.RngRequest.Builder {
                self.shape = value
                return self
            }
            @discardableResult
            public func mergeShape(value:Xla.Shape) throws -> Xla.RngRequest.Builder {
                if builderResult.hasShape {
                    builderResult.shape = try Xla.Shape.builderWithPrototype(prototype:builderResult.shape).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.shape = value
                }
                builderResult.hasShape = true
                return self
            }
            @discardableResult
            public func clearShape() -> Xla.RngRequest.Builder {
                shapeBuilder_ = nil
                builderResult.hasShape = false
                builderResult.shape = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.RngRequest.Builder {
                builderResult = Xla.RngRequest()
                return self
            }
            override public func clone() throws -> Xla.RngRequest.Builder {
                return try Xla.RngRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.RngRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.RngRequest {
                let returnMe:Xla.RngRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.RngRequest) throws -> Xla.RngRequest.Builder {
                if other == Xla.RngRequest() {
                    return self
                }
                if other.hasDistribution {
                    distribution = other.distribution
                }
                if !other.parameter.isEmpty  {
                     builderResult.parameter += other.parameter
                }
                if (other.hasShape) {
                    try mergeShape(value: other.shape)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.RngRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.RngRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 16:
                        let valueIntdistribution = try codedInputStream.readEnum()
                        if let enumsdistribution = Xla.RandomDistribution(rawValue:valueIntdistribution){
                            distribution = enumsdistribution
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntdistribution))
                        }

                    case 26:
                        let subBuilder = Xla.ComputationDataHandle.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        parameter.append(subBuilder.buildPartial())

                    case 34:
                        let subBuilder:Xla.Shape.Builder = Xla.Shape.Builder()
                        if hasShape {
                            try subBuilder.mergeFrom(other: shape)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        shape = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.RngRequest.Builder {
                let resultDecodedBuilder = Xla.RngRequest.Builder()
                if let jsonValueDistribution = jsonMap["distribution"] as? String {
                    resultDecodedBuilder.distribution = try Xla.RandomDistribution.fromString(str: jsonValueDistribution)
                }
                if let jsonValueParameter = jsonMap["parameter"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayParameter:Array<Xla.ComputationDataHandle> = []
                    for oneValueParameter in jsonValueParameter {
                        let messageFromStringParameter = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:oneValueParameter).build()

                        jsonArrayParameter.append(messageFromStringParameter)
                    }
                    resultDecodedBuilder.parameter = jsonArrayParameter
                }
                if let jsonValueShape = jsonMap["shape"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.shape = try Xla.Shape.Builder.decodeToBuilder(jsonMap:jsonValueShape).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.RngRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.RngRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class TernaryOpRequest : GeneratedMessage {

        public static func == (lhs: Xla.TernaryOpRequest, rhs: Xla.TernaryOpRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasTriop == rhs.hasTriop) && (!lhs.hasTriop || lhs.triop == rhs.triop)
            fieldCheck = fieldCheck && (lhs.hasLhs == rhs.hasLhs) && (!lhs.hasLhs || lhs.lhs == rhs.lhs)
            fieldCheck = fieldCheck && (lhs.hasRhs == rhs.hasRhs) && (!lhs.hasRhs || lhs.rhs == rhs.rhs)
            fieldCheck = fieldCheck && (lhs.hasEhs == rhs.hasEhs) && (!lhs.hasEhs || lhs.ehs == rhs.ehs)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var triop:Xla.TernaryOperation = Xla.TernaryOperation.triopInvalid
        public fileprivate(set) var hasTriop:Bool = false
        public fileprivate(set) var lhs:Xla.ComputationDataHandle!
        public fileprivate(set) var hasLhs:Bool = false
        public fileprivate(set) var rhs:Xla.ComputationDataHandle!
        public fileprivate(set) var hasRhs:Bool = false
        public fileprivate(set) var ehs:Xla.ComputationDataHandle!
        public fileprivate(set) var hasEhs:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasTriop {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:triop.rawValue)
            }
            if hasLhs {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:lhs)
            }
            if hasRhs {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:rhs)
            }
            if hasEhs {
                try codedOutputStream.writeMessage(fieldNumber: 5, value:ehs)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if (hasTriop) {
                serialize_size += triop.rawValue.computeEnumSize(fieldNumber: 2)
            }
            if hasLhs {
                if let varSizelhs = lhs?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizelhs
                }
            }
            if hasRhs {
                if let varSizerhs = rhs?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizerhs
                }
            }
            if hasEhs {
                if let varSizeehs = ehs?.computeMessageSize(fieldNumber: 5) {
                    serialize_size += varSizeehs
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.TernaryOpRequest.Builder {
            return Xla.TernaryOpRequest.classBuilder() as! Xla.TernaryOpRequest.Builder
        }
        public func getBuilder() -> Xla.TernaryOpRequest.Builder {
            return classBuilder() as! Xla.TernaryOpRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.TernaryOpRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.TernaryOpRequest.Builder()
        }
        public func toBuilder() throws -> Xla.TernaryOpRequest.Builder {
            return try Xla.TernaryOpRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.TernaryOpRequest) throws -> Xla.TernaryOpRequest.Builder {
            return try Xla.TernaryOpRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasTriop {
                jsonMap["triop"] = triop.toString()
            }
            if hasLhs {
                jsonMap["lhs"] = try lhs.encode()
            }
            if hasRhs {
                jsonMap["rhs"] = try rhs.encode()
            }
            if hasEhs {
                jsonMap["ehs"] = try ehs.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.TernaryOpRequest {
            return try Xla.TernaryOpRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.TernaryOpRequest {
            return try Xla.TernaryOpRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if (hasTriop) {
                output += "\(indent) triop: \(triop.description)\n"
            }
            if hasLhs {
                output += "\(indent) lhs {\n"
                if let outDescLhs = lhs {
                    output += try outDescLhs.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasRhs {
                output += "\(indent) rhs {\n"
                if let outDescRhs = rhs {
                    output += try outDescRhs.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasEhs {
                output += "\(indent) ehs {\n"
                if let outDescEhs = ehs {
                    output += try outDescEhs.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasTriop {
                     hashCode = (hashCode &* 31) &+ triop.hashValue
                }
                if hasLhs {
                    if let hashValuelhs = lhs?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuelhs
                    }
                }
                if hasRhs {
                    if let hashValuerhs = rhs?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuerhs
                    }
                }
                if hasEhs {
                    if let hashValueehs = ehs?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueehs
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.TernaryOpRequest"
        }
        override public func className() -> String {
            return "Xla.TernaryOpRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.TernaryOpRequest = Xla.TernaryOpRequest()
            public func getMessage() -> Xla.TernaryOpRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
                public var triop:Xla.TernaryOperation {
                    get {
                        return builderResult.triop
                    }
                    set (value) {
                        builderResult.hasTriop = true
                        builderResult.triop = value
                    }
                }
                public var hasTriop:Bool{
                    get {
                        return builderResult.hasTriop
                    }
                }
            @discardableResult
                public func setTriop(_ value:Xla.TernaryOperation) -> Xla.TernaryOpRequest.Builder {
                  self.triop = value
                  return self
                }
            @discardableResult
                public func clearTriop() -> Xla.TernaryOpRequest.Builder {
                   builderResult.hasTriop = false
                   builderResult.triop = .triopInvalid
                   return self
                }
            public var lhs:Xla.ComputationDataHandle! {
                get {
                    if lhsBuilder_ != nil {
                        builderResult.lhs = lhsBuilder_.getMessage()
                    }
                    return builderResult.lhs
                }
                set (value) {
                    builderResult.hasLhs = true
                    builderResult.lhs = value
                }
            }
            public var hasLhs:Bool {
                get {
                    return builderResult.hasLhs
                }
            }
            fileprivate var lhsBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasLhs = true
                }
            }
            public func getLhsBuilder() -> Xla.ComputationDataHandle.Builder {
                if lhsBuilder_ == nil {
                    lhsBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.lhs = lhsBuilder_.getMessage()
                    if lhs != nil {
                        try! lhsBuilder_.mergeFrom(other: lhs)
                    }
                }
                return lhsBuilder_
            }
            @discardableResult
            public func setLhs(_ value:Xla.ComputationDataHandle!) -> Xla.TernaryOpRequest.Builder {
                self.lhs = value
                return self
            }
            @discardableResult
            public func mergeLhs(value:Xla.ComputationDataHandle) throws -> Xla.TernaryOpRequest.Builder {
                if builderResult.hasLhs {
                    builderResult.lhs = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.lhs).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.lhs = value
                }
                builderResult.hasLhs = true
                return self
            }
            @discardableResult
            public func clearLhs() -> Xla.TernaryOpRequest.Builder {
                lhsBuilder_ = nil
                builderResult.hasLhs = false
                builderResult.lhs = nil
                return self
            }
            public var rhs:Xla.ComputationDataHandle! {
                get {
                    if rhsBuilder_ != nil {
                        builderResult.rhs = rhsBuilder_.getMessage()
                    }
                    return builderResult.rhs
                }
                set (value) {
                    builderResult.hasRhs = true
                    builderResult.rhs = value
                }
            }
            public var hasRhs:Bool {
                get {
                    return builderResult.hasRhs
                }
            }
            fileprivate var rhsBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasRhs = true
                }
            }
            public func getRhsBuilder() -> Xla.ComputationDataHandle.Builder {
                if rhsBuilder_ == nil {
                    rhsBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.rhs = rhsBuilder_.getMessage()
                    if rhs != nil {
                        try! rhsBuilder_.mergeFrom(other: rhs)
                    }
                }
                return rhsBuilder_
            }
            @discardableResult
            public func setRhs(_ value:Xla.ComputationDataHandle!) -> Xla.TernaryOpRequest.Builder {
                self.rhs = value
                return self
            }
            @discardableResult
            public func mergeRhs(value:Xla.ComputationDataHandle) throws -> Xla.TernaryOpRequest.Builder {
                if builderResult.hasRhs {
                    builderResult.rhs = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.rhs).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.rhs = value
                }
                builderResult.hasRhs = true
                return self
            }
            @discardableResult
            public func clearRhs() -> Xla.TernaryOpRequest.Builder {
                rhsBuilder_ = nil
                builderResult.hasRhs = false
                builderResult.rhs = nil
                return self
            }
            public var ehs:Xla.ComputationDataHandle! {
                get {
                    if ehsBuilder_ != nil {
                        builderResult.ehs = ehsBuilder_.getMessage()
                    }
                    return builderResult.ehs
                }
                set (value) {
                    builderResult.hasEhs = true
                    builderResult.ehs = value
                }
            }
            public var hasEhs:Bool {
                get {
                    return builderResult.hasEhs
                }
            }
            fileprivate var ehsBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasEhs = true
                }
            }
            public func getEhsBuilder() -> Xla.ComputationDataHandle.Builder {
                if ehsBuilder_ == nil {
                    ehsBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.ehs = ehsBuilder_.getMessage()
                    if ehs != nil {
                        try! ehsBuilder_.mergeFrom(other: ehs)
                    }
                }
                return ehsBuilder_
            }
            @discardableResult
            public func setEhs(_ value:Xla.ComputationDataHandle!) -> Xla.TernaryOpRequest.Builder {
                self.ehs = value
                return self
            }
            @discardableResult
            public func mergeEhs(value:Xla.ComputationDataHandle) throws -> Xla.TernaryOpRequest.Builder {
                if builderResult.hasEhs {
                    builderResult.ehs = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.ehs).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.ehs = value
                }
                builderResult.hasEhs = true
                return self
            }
            @discardableResult
            public func clearEhs() -> Xla.TernaryOpRequest.Builder {
                ehsBuilder_ = nil
                builderResult.hasEhs = false
                builderResult.ehs = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.TernaryOpRequest.Builder {
                builderResult = Xla.TernaryOpRequest()
                return self
            }
            override public func clone() throws -> Xla.TernaryOpRequest.Builder {
                return try Xla.TernaryOpRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.TernaryOpRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.TernaryOpRequest {
                let returnMe:Xla.TernaryOpRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.TernaryOpRequest) throws -> Xla.TernaryOpRequest.Builder {
                if other == Xla.TernaryOpRequest() {
                    return self
                }
                if other.hasTriop {
                    triop = other.triop
                }
                if (other.hasLhs) {
                    try mergeLhs(value: other.lhs)
                }
                if (other.hasRhs) {
                    try mergeRhs(value: other.rhs)
                }
                if (other.hasEhs) {
                    try mergeEhs(value: other.ehs)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.TernaryOpRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TernaryOpRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 16:
                        let valueInttriop = try codedInputStream.readEnum()
                        if let enumstriop = Xla.TernaryOperation(rawValue:valueInttriop){
                            triop = enumstriop
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueInttriop))
                        }

                    case 26:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasLhs {
                            try subBuilder.mergeFrom(other: lhs)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        lhs = subBuilder.buildPartial()

                    case 34:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasRhs {
                            try subBuilder.mergeFrom(other: rhs)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        rhs = subBuilder.buildPartial()

                    case 42:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasEhs {
                            try subBuilder.mergeFrom(other: ehs)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        ehs = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.TernaryOpRequest.Builder {
                let resultDecodedBuilder = Xla.TernaryOpRequest.Builder()
                if let jsonValueTriop = jsonMap["triop"] as? String {
                    resultDecodedBuilder.triop = try Xla.TernaryOperation.fromString(str: jsonValueTriop)
                }
                if let jsonValueLhs = jsonMap["lhs"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.lhs = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueLhs).build()

                }
                if let jsonValueRhs = jsonMap["rhs"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.rhs = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueRhs).build()

                }
                if let jsonValueEhs = jsonMap["ehs"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.ehs = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueEhs).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.TernaryOpRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.TernaryOpRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class VariadicOpRequest : GeneratedMessage {

        public static func == (lhs: Xla.VariadicOpRequest, rhs: Xla.VariadicOpRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasVarop == rhs.hasVarop) && (!lhs.hasVarop || lhs.varop == rhs.varop)
            fieldCheck = fieldCheck && (lhs.operands == rhs.operands)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var varop:Xla.VariadicOperation = Xla.VariadicOperation.varopInvalid
        public fileprivate(set) var hasVarop:Bool = false
        public fileprivate(set) var operands:Array<Xla.ComputationDataHandle>  = Array<Xla.ComputationDataHandle>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasVarop {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:varop.rawValue)
            }
            for oneElementOperands in operands {
                  try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementOperands)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if (hasVarop) {
                serialize_size += varop.rawValue.computeEnumSize(fieldNumber: 2)
            }
            for oneElementOperands in operands {
                serialize_size += oneElementOperands.computeMessageSize(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.VariadicOpRequest.Builder {
            return Xla.VariadicOpRequest.classBuilder() as! Xla.VariadicOpRequest.Builder
        }
        public func getBuilder() -> Xla.VariadicOpRequest.Builder {
            return classBuilder() as! Xla.VariadicOpRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.VariadicOpRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.VariadicOpRequest.Builder()
        }
        public func toBuilder() throws -> Xla.VariadicOpRequest.Builder {
            return try Xla.VariadicOpRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.VariadicOpRequest) throws -> Xla.VariadicOpRequest.Builder {
            return try Xla.VariadicOpRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasVarop {
                jsonMap["varop"] = varop.toString()
            }
            if !operands.isEmpty {
                var jsonArrayOperands:Array<Dictionary<String,Any>> = []
                for oneValueOperands in operands {
                    let ecodedMessageOperands = try oneValueOperands.encode()
                    jsonArrayOperands.append(ecodedMessageOperands)
                }
                jsonMap["operands"] = jsonArrayOperands
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.VariadicOpRequest {
            return try Xla.VariadicOpRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.VariadicOpRequest {
            return try Xla.VariadicOpRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if (hasVarop) {
                output += "\(indent) varop: \(varop.description)\n"
            }
            var operandsElementIndex:Int = 0
            for oneElementOperands in operands {
                output += "\(indent) operands[\(operandsElementIndex)] {\n"
                output += try oneElementOperands.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                operandsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasVarop {
                     hashCode = (hashCode &* 31) &+ varop.hashValue
                }
                for oneElementOperands in operands {
                    hashCode = (hashCode &* 31) &+ oneElementOperands.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.VariadicOpRequest"
        }
        override public func className() -> String {
            return "Xla.VariadicOpRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.VariadicOpRequest = Xla.VariadicOpRequest()
            public func getMessage() -> Xla.VariadicOpRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
                public var varop:Xla.VariadicOperation {
                    get {
                        return builderResult.varop
                    }
                    set (value) {
                        builderResult.hasVarop = true
                        builderResult.varop = value
                    }
                }
                public var hasVarop:Bool{
                    get {
                        return builderResult.hasVarop
                    }
                }
            @discardableResult
                public func setVarop(_ value:Xla.VariadicOperation) -> Xla.VariadicOpRequest.Builder {
                  self.varop = value
                  return self
                }
            @discardableResult
                public func clearVarop() -> Xla.VariadicOpRequest.Builder {
                   builderResult.hasVarop = false
                   builderResult.varop = .varopInvalid
                   return self
                }
            public var operands:Array<Xla.ComputationDataHandle> {
                get {
                    return builderResult.operands
                }
                set (value) {
                    builderResult.operands = value
                }
            }
            @discardableResult
            public func setOperands(_ value:Array<Xla.ComputationDataHandle>) -> Xla.VariadicOpRequest.Builder {
                self.operands = value
                return self
            }
            @discardableResult
            public func clearOperands() -> Xla.VariadicOpRequest.Builder {
                builderResult.operands.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.VariadicOpRequest.Builder {
                builderResult = Xla.VariadicOpRequest()
                return self
            }
            override public func clone() throws -> Xla.VariadicOpRequest.Builder {
                return try Xla.VariadicOpRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.VariadicOpRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.VariadicOpRequest {
                let returnMe:Xla.VariadicOpRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.VariadicOpRequest) throws -> Xla.VariadicOpRequest.Builder {
                if other == Xla.VariadicOpRequest() {
                    return self
                }
                if other.hasVarop {
                    varop = other.varop
                }
                if !other.operands.isEmpty  {
                     builderResult.operands += other.operands
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.VariadicOpRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.VariadicOpRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 16:
                        let valueIntvarop = try codedInputStream.readEnum()
                        if let enumsvarop = Xla.VariadicOperation(rawValue:valueIntvarop){
                            varop = enumsvarop
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntvarop))
                        }

                    case 26:
                        let subBuilder = Xla.ComputationDataHandle.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        operands.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.VariadicOpRequest.Builder {
                let resultDecodedBuilder = Xla.VariadicOpRequest.Builder()
                if let jsonValueVarop = jsonMap["varop"] as? String {
                    resultDecodedBuilder.varop = try Xla.VariadicOperation.fromString(str: jsonValueVarop)
                }
                if let jsonValueOperands = jsonMap["operands"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayOperands:Array<Xla.ComputationDataHandle> = []
                    for oneValueOperands in jsonValueOperands {
                        let messageFromStringOperands = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:oneValueOperands).build()

                        jsonArrayOperands.append(messageFromStringOperands)
                    }
                    resultDecodedBuilder.operands = jsonArrayOperands
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.VariadicOpRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.VariadicOpRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class SendRequest : GeneratedMessage {

        public static func == (lhs: Xla.SendRequest, rhs: Xla.SendRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasOperand == rhs.hasOperand) && (!lhs.hasOperand || lhs.operand == rhs.operand)
            fieldCheck = fieldCheck && (lhs.hasChannelHandle == rhs.hasChannelHandle) && (!lhs.hasChannelHandle || lhs.channelHandle == rhs.channelHandle)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var operand:Xla.ComputationDataHandle!
        public fileprivate(set) var hasOperand:Bool = false
        public fileprivate(set) var channelHandle:Xla.ChannelHandle!
        public fileprivate(set) var hasChannelHandle:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasOperand {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:operand)
            }
            if hasChannelHandle {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:channelHandle)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasOperand {
                if let varSizeoperand = operand?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeoperand
                }
            }
            if hasChannelHandle {
                if let varSizechannelHandle = channelHandle?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizechannelHandle
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.SendRequest.Builder {
            return Xla.SendRequest.classBuilder() as! Xla.SendRequest.Builder
        }
        public func getBuilder() -> Xla.SendRequest.Builder {
            return classBuilder() as! Xla.SendRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.SendRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.SendRequest.Builder()
        }
        public func toBuilder() throws -> Xla.SendRequest.Builder {
            return try Xla.SendRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.SendRequest) throws -> Xla.SendRequest.Builder {
            return try Xla.SendRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasOperand {
                jsonMap["operand"] = try operand.encode()
            }
            if hasChannelHandle {
                jsonMap["channelHandle"] = try channelHandle.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.SendRequest {
            return try Xla.SendRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.SendRequest {
            return try Xla.SendRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasOperand {
                output += "\(indent) operand {\n"
                if let outDescOperand = operand {
                    output += try outDescOperand.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasChannelHandle {
                output += "\(indent) channelHandle {\n"
                if let outDescChannelHandle = channelHandle {
                    output += try outDescChannelHandle.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasOperand {
                    if let hashValueoperand = operand?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoperand
                    }
                }
                if hasChannelHandle {
                    if let hashValuechannelHandle = channelHandle?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuechannelHandle
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.SendRequest"
        }
        override public func className() -> String {
            return "Xla.SendRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.SendRequest = Xla.SendRequest()
            public func getMessage() -> Xla.SendRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var operand:Xla.ComputationDataHandle! {
                get {
                    if operandBuilder_ != nil {
                        builderResult.operand = operandBuilder_.getMessage()
                    }
                    return builderResult.operand
                }
                set (value) {
                    builderResult.hasOperand = true
                    builderResult.operand = value
                }
            }
            public var hasOperand:Bool {
                get {
                    return builderResult.hasOperand
                }
            }
            fileprivate var operandBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasOperand = true
                }
            }
            public func getOperandBuilder() -> Xla.ComputationDataHandle.Builder {
                if operandBuilder_ == nil {
                    operandBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.operand = operandBuilder_.getMessage()
                    if operand != nil {
                        try! operandBuilder_.mergeFrom(other: operand)
                    }
                }
                return operandBuilder_
            }
            @discardableResult
            public func setOperand(_ value:Xla.ComputationDataHandle!) -> Xla.SendRequest.Builder {
                self.operand = value
                return self
            }
            @discardableResult
            public func mergeOperand(value:Xla.ComputationDataHandle) throws -> Xla.SendRequest.Builder {
                if builderResult.hasOperand {
                    builderResult.operand = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.operand).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.operand = value
                }
                builderResult.hasOperand = true
                return self
            }
            @discardableResult
            public func clearOperand() -> Xla.SendRequest.Builder {
                operandBuilder_ = nil
                builderResult.hasOperand = false
                builderResult.operand = nil
                return self
            }
            public var channelHandle:Xla.ChannelHandle! {
                get {
                    if channelHandleBuilder_ != nil {
                        builderResult.channelHandle = channelHandleBuilder_.getMessage()
                    }
                    return builderResult.channelHandle
                }
                set (value) {
                    builderResult.hasChannelHandle = true
                    builderResult.channelHandle = value
                }
            }
            public var hasChannelHandle:Bool {
                get {
                    return builderResult.hasChannelHandle
                }
            }
            fileprivate var channelHandleBuilder_:Xla.ChannelHandle.Builder! {
                didSet {
                    builderResult.hasChannelHandle = true
                }
            }
            public func getChannelHandleBuilder() -> Xla.ChannelHandle.Builder {
                if channelHandleBuilder_ == nil {
                    channelHandleBuilder_ = Xla.ChannelHandle.Builder()
                    builderResult.channelHandle = channelHandleBuilder_.getMessage()
                    if channelHandle != nil {
                        try! channelHandleBuilder_.mergeFrom(other: channelHandle)
                    }
                }
                return channelHandleBuilder_
            }
            @discardableResult
            public func setChannelHandle(_ value:Xla.ChannelHandle!) -> Xla.SendRequest.Builder {
                self.channelHandle = value
                return self
            }
            @discardableResult
            public func mergeChannelHandle(value:Xla.ChannelHandle) throws -> Xla.SendRequest.Builder {
                if builderResult.hasChannelHandle {
                    builderResult.channelHandle = try Xla.ChannelHandle.builderWithPrototype(prototype:builderResult.channelHandle).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.channelHandle = value
                }
                builderResult.hasChannelHandle = true
                return self
            }
            @discardableResult
            public func clearChannelHandle() -> Xla.SendRequest.Builder {
                channelHandleBuilder_ = nil
                builderResult.hasChannelHandle = false
                builderResult.channelHandle = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.SendRequest.Builder {
                builderResult = Xla.SendRequest()
                return self
            }
            override public func clone() throws -> Xla.SendRequest.Builder {
                return try Xla.SendRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.SendRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.SendRequest {
                let returnMe:Xla.SendRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.SendRequest) throws -> Xla.SendRequest.Builder {
                if other == Xla.SendRequest() {
                    return self
                }
                if (other.hasOperand) {
                    try mergeOperand(value: other.operand)
                }
                if (other.hasChannelHandle) {
                    try mergeChannelHandle(value: other.channelHandle)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.SendRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SendRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasOperand {
                            try subBuilder.mergeFrom(other: operand)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        operand = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Xla.ChannelHandle.Builder = Xla.ChannelHandle.Builder()
                        if hasChannelHandle {
                            try subBuilder.mergeFrom(other: channelHandle)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        channelHandle = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.SendRequest.Builder {
                let resultDecodedBuilder = Xla.SendRequest.Builder()
                if let jsonValueOperand = jsonMap["operand"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.operand = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueOperand).build()

                }
                if let jsonValueChannelHandle = jsonMap["channelHandle"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.channelHandle = try Xla.ChannelHandle.Builder.decodeToBuilder(jsonMap:jsonValueChannelHandle).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.SendRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.SendRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class RecvRequest : GeneratedMessage {

        public static func == (lhs: Xla.RecvRequest, rhs: Xla.RecvRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasShape == rhs.hasShape) && (!lhs.hasShape || lhs.shape == rhs.shape)
            fieldCheck = fieldCheck && (lhs.hasChannelHandle == rhs.hasChannelHandle) && (!lhs.hasChannelHandle || lhs.channelHandle == rhs.channelHandle)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var shape:Xla.Shape!
        public fileprivate(set) var hasShape:Bool = false
        public fileprivate(set) var channelHandle:Xla.ChannelHandle!
        public fileprivate(set) var hasChannelHandle:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasShape {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:shape)
            }
            if hasChannelHandle {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:channelHandle)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasShape {
                if let varSizeshape = shape?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeshape
                }
            }
            if hasChannelHandle {
                if let varSizechannelHandle = channelHandle?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizechannelHandle
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.RecvRequest.Builder {
            return Xla.RecvRequest.classBuilder() as! Xla.RecvRequest.Builder
        }
        public func getBuilder() -> Xla.RecvRequest.Builder {
            return classBuilder() as! Xla.RecvRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.RecvRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.RecvRequest.Builder()
        }
        public func toBuilder() throws -> Xla.RecvRequest.Builder {
            return try Xla.RecvRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.RecvRequest) throws -> Xla.RecvRequest.Builder {
            return try Xla.RecvRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasShape {
                jsonMap["shape"] = try shape.encode()
            }
            if hasChannelHandle {
                jsonMap["channelHandle"] = try channelHandle.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.RecvRequest {
            return try Xla.RecvRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.RecvRequest {
            return try Xla.RecvRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasShape {
                output += "\(indent) shape {\n"
                if let outDescShape = shape {
                    output += try outDescShape.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasChannelHandle {
                output += "\(indent) channelHandle {\n"
                if let outDescChannelHandle = channelHandle {
                    output += try outDescChannelHandle.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasShape {
                    if let hashValueshape = shape?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueshape
                    }
                }
                if hasChannelHandle {
                    if let hashValuechannelHandle = channelHandle?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuechannelHandle
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.RecvRequest"
        }
        override public func className() -> String {
            return "Xla.RecvRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.RecvRequest = Xla.RecvRequest()
            public func getMessage() -> Xla.RecvRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var shape:Xla.Shape! {
                get {
                    if shapeBuilder_ != nil {
                        builderResult.shape = shapeBuilder_.getMessage()
                    }
                    return builderResult.shape
                }
                set (value) {
                    builderResult.hasShape = true
                    builderResult.shape = value
                }
            }
            public var hasShape:Bool {
                get {
                    return builderResult.hasShape
                }
            }
            fileprivate var shapeBuilder_:Xla.Shape.Builder! {
                didSet {
                    builderResult.hasShape = true
                }
            }
            public func getShapeBuilder() -> Xla.Shape.Builder {
                if shapeBuilder_ == nil {
                    shapeBuilder_ = Xla.Shape.Builder()
                    builderResult.shape = shapeBuilder_.getMessage()
                    if shape != nil {
                        try! shapeBuilder_.mergeFrom(other: shape)
                    }
                }
                return shapeBuilder_
            }
            @discardableResult
            public func setShape(_ value:Xla.Shape!) -> Xla.RecvRequest.Builder {
                self.shape = value
                return self
            }
            @discardableResult
            public func mergeShape(value:Xla.Shape) throws -> Xla.RecvRequest.Builder {
                if builderResult.hasShape {
                    builderResult.shape = try Xla.Shape.builderWithPrototype(prototype:builderResult.shape).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.shape = value
                }
                builderResult.hasShape = true
                return self
            }
            @discardableResult
            public func clearShape() -> Xla.RecvRequest.Builder {
                shapeBuilder_ = nil
                builderResult.hasShape = false
                builderResult.shape = nil
                return self
            }
            public var channelHandle:Xla.ChannelHandle! {
                get {
                    if channelHandleBuilder_ != nil {
                        builderResult.channelHandle = channelHandleBuilder_.getMessage()
                    }
                    return builderResult.channelHandle
                }
                set (value) {
                    builderResult.hasChannelHandle = true
                    builderResult.channelHandle = value
                }
            }
            public var hasChannelHandle:Bool {
                get {
                    return builderResult.hasChannelHandle
                }
            }
            fileprivate var channelHandleBuilder_:Xla.ChannelHandle.Builder! {
                didSet {
                    builderResult.hasChannelHandle = true
                }
            }
            public func getChannelHandleBuilder() -> Xla.ChannelHandle.Builder {
                if channelHandleBuilder_ == nil {
                    channelHandleBuilder_ = Xla.ChannelHandle.Builder()
                    builderResult.channelHandle = channelHandleBuilder_.getMessage()
                    if channelHandle != nil {
                        try! channelHandleBuilder_.mergeFrom(other: channelHandle)
                    }
                }
                return channelHandleBuilder_
            }
            @discardableResult
            public func setChannelHandle(_ value:Xla.ChannelHandle!) -> Xla.RecvRequest.Builder {
                self.channelHandle = value
                return self
            }
            @discardableResult
            public func mergeChannelHandle(value:Xla.ChannelHandle) throws -> Xla.RecvRequest.Builder {
                if builderResult.hasChannelHandle {
                    builderResult.channelHandle = try Xla.ChannelHandle.builderWithPrototype(prototype:builderResult.channelHandle).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.channelHandle = value
                }
                builderResult.hasChannelHandle = true
                return self
            }
            @discardableResult
            public func clearChannelHandle() -> Xla.RecvRequest.Builder {
                channelHandleBuilder_ = nil
                builderResult.hasChannelHandle = false
                builderResult.channelHandle = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.RecvRequest.Builder {
                builderResult = Xla.RecvRequest()
                return self
            }
            override public func clone() throws -> Xla.RecvRequest.Builder {
                return try Xla.RecvRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.RecvRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.RecvRequest {
                let returnMe:Xla.RecvRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.RecvRequest) throws -> Xla.RecvRequest.Builder {
                if other == Xla.RecvRequest() {
                    return self
                }
                if (other.hasShape) {
                    try mergeShape(value: other.shape)
                }
                if (other.hasChannelHandle) {
                    try mergeChannelHandle(value: other.channelHandle)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.RecvRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.RecvRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.Shape.Builder = Xla.Shape.Builder()
                        if hasShape {
                            try subBuilder.mergeFrom(other: shape)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        shape = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Xla.ChannelHandle.Builder = Xla.ChannelHandle.Builder()
                        if hasChannelHandle {
                            try subBuilder.mergeFrom(other: channelHandle)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        channelHandle = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.RecvRequest.Builder {
                let resultDecodedBuilder = Xla.RecvRequest.Builder()
                if let jsonValueShape = jsonMap["shape"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.shape = try Xla.Shape.Builder.decodeToBuilder(jsonMap:jsonValueShape).build()

                }
                if let jsonValueChannelHandle = jsonMap["channelHandle"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.channelHandle = try Xla.ChannelHandle.Builder.decodeToBuilder(jsonMap:jsonValueChannelHandle).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.RecvRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.RecvRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class OpRequest : GeneratedMessage {

        public static func == (lhs: Xla.OpRequest, rhs: Xla.OpRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasComputation == rhs.hasComputation) && (!lhs.hasComputation || lhs.computation == rhs.computation)
            fieldCheck = fieldCheck && (lhs.hasBinaryOpRequest == rhs.hasBinaryOpRequest) && (!lhs.hasBinaryOpRequest || lhs.binaryOpRequest == rhs.binaryOpRequest)
            fieldCheck = fieldCheck && (lhs.hasBroadcastRequest == rhs.hasBroadcastRequest) && (!lhs.hasBroadcastRequest || lhs.broadcastRequest == rhs.broadcastRequest)
            fieldCheck = fieldCheck && (lhs.hasCallRequest == rhs.hasCallRequest) && (!lhs.hasCallRequest || lhs.callRequest == rhs.callRequest)
            fieldCheck = fieldCheck && (lhs.hasConcatenateRequest == rhs.hasConcatenateRequest) && (!lhs.hasConcatenateRequest || lhs.concatenateRequest == rhs.concatenateRequest)
            fieldCheck = fieldCheck && (lhs.hasConstantRequest == rhs.hasConstantRequest) && (!lhs.hasConstantRequest || lhs.constantRequest == rhs.constantRequest)
            fieldCheck = fieldCheck && (lhs.hasConvertRequest == rhs.hasConvertRequest) && (!lhs.hasConvertRequest || lhs.convertRequest == rhs.convertRequest)
            fieldCheck = fieldCheck && (lhs.hasConvolveRequest == rhs.hasConvolveRequest) && (!lhs.hasConvolveRequest || lhs.convolveRequest == rhs.convolveRequest)
            fieldCheck = fieldCheck && (lhs.hasCrossReplicaSumRequest == rhs.hasCrossReplicaSumRequest) && (!lhs.hasCrossReplicaSumRequest || lhs.crossReplicaSumRequest == rhs.crossReplicaSumRequest)
            fieldCheck = fieldCheck && (lhs.hasCustomCallRequest == rhs.hasCustomCallRequest) && (!lhs.hasCustomCallRequest || lhs.customCallRequest == rhs.customCallRequest)
            fieldCheck = fieldCheck && (lhs.hasDynamicSliceRequest == rhs.hasDynamicSliceRequest) && (!lhs.hasDynamicSliceRequest || lhs.dynamicSliceRequest == rhs.dynamicSliceRequest)
            fieldCheck = fieldCheck && (lhs.hasDynamicUpdateSliceRequest == rhs.hasDynamicUpdateSliceRequest) && (!lhs.hasDynamicUpdateSliceRequest || lhs.dynamicUpdateSliceRequest == rhs.dynamicUpdateSliceRequest)
            fieldCheck = fieldCheck && (lhs.hasGetTupleElementRequest == rhs.hasGetTupleElementRequest) && (!lhs.hasGetTupleElementRequest || lhs.getTupleElementRequest == rhs.getTupleElementRequest)
            fieldCheck = fieldCheck && (lhs.hasInfeedRequest == rhs.hasInfeedRequest) && (!lhs.hasInfeedRequest || lhs.infeedRequest == rhs.infeedRequest)
            fieldCheck = fieldCheck && (lhs.hasMapRequest == rhs.hasMapRequest) && (!lhs.hasMapRequest || lhs.mapRequest == rhs.mapRequest)
            fieldCheck = fieldCheck && (lhs.hasPadRequest == rhs.hasPadRequest) && (!lhs.hasPadRequest || lhs.padRequest == rhs.padRequest)
            fieldCheck = fieldCheck && (lhs.hasParameterRequest == rhs.hasParameterRequest) && (!lhs.hasParameterRequest || lhs.parameterRequest == rhs.parameterRequest)
            fieldCheck = fieldCheck && (lhs.hasReduceRequest == rhs.hasReduceRequest) && (!lhs.hasReduceRequest || lhs.reduceRequest == rhs.reduceRequest)
            fieldCheck = fieldCheck && (lhs.hasReduceWindowRequest == rhs.hasReduceWindowRequest) && (!lhs.hasReduceWindowRequest || lhs.reduceWindowRequest == rhs.reduceWindowRequest)
            fieldCheck = fieldCheck && (lhs.hasReshapeRequest == rhs.hasReshapeRequest) && (!lhs.hasReshapeRequest || lhs.reshapeRequest == rhs.reshapeRequest)
            fieldCheck = fieldCheck && (lhs.hasReverseRequest == rhs.hasReverseRequest) && (!lhs.hasReverseRequest || lhs.reverseRequest == rhs.reverseRequest)
            fieldCheck = fieldCheck && (lhs.hasRngRequest == rhs.hasRngRequest) && (!lhs.hasRngRequest || lhs.rngRequest == rhs.rngRequest)
            fieldCheck = fieldCheck && (lhs.hasSelectAndScatterRequest == rhs.hasSelectAndScatterRequest) && (!lhs.hasSelectAndScatterRequest || lhs.selectAndScatterRequest == rhs.selectAndScatterRequest)
            fieldCheck = fieldCheck && (lhs.hasSliceRequest == rhs.hasSliceRequest) && (!lhs.hasSliceRequest || lhs.sliceRequest == rhs.sliceRequest)
            fieldCheck = fieldCheck && (lhs.hasTernaryOpRequest == rhs.hasTernaryOpRequest) && (!lhs.hasTernaryOpRequest || lhs.ternaryOpRequest == rhs.ternaryOpRequest)
            fieldCheck = fieldCheck && (lhs.hasTraceRequest == rhs.hasTraceRequest) && (!lhs.hasTraceRequest || lhs.traceRequest == rhs.traceRequest)
            fieldCheck = fieldCheck && (lhs.hasUnaryOpRequest == rhs.hasUnaryOpRequest) && (!lhs.hasUnaryOpRequest || lhs.unaryOpRequest == rhs.unaryOpRequest)
            fieldCheck = fieldCheck && (lhs.hasVariadicOpRequest == rhs.hasVariadicOpRequest) && (!lhs.hasVariadicOpRequest || lhs.variadicOpRequest == rhs.variadicOpRequest)
            fieldCheck = fieldCheck && (lhs.hasWhileRequest == rhs.hasWhileRequest) && (!lhs.hasWhileRequest || lhs.whileRequest == rhs.whileRequest)
            fieldCheck = fieldCheck && (lhs.hasSendRequest == rhs.hasSendRequest) && (!lhs.hasSendRequest || lhs.sendRequest == rhs.sendRequest)
            fieldCheck = fieldCheck && (lhs.hasRecvRequest == rhs.hasRecvRequest) && (!lhs.hasRecvRequest || lhs.recvRequest == rhs.recvRequest)
            fieldCheck = fieldCheck && (lhs.hasOutfeedRequest == rhs.hasOutfeedRequest) && (!lhs.hasOutfeedRequest || lhs.outfeedRequest == rhs.outfeedRequest)
            fieldCheck = fieldCheck && (lhs.hasMetadata == rhs.hasMetadata) && (!lhs.hasMetadata || lhs.metadata == rhs.metadata)
            fieldCheck = fieldCheck && (lhs.hasTransposeRequest == rhs.hasTransposeRequest) && (!lhs.hasTransposeRequest || lhs.transposeRequest == rhs.transposeRequest)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //OneOf declaration start

        public enum Op {
            case OneOfOpNotSet

            public func checkOneOfIsSet() -> Bool {
                switch self {
                case .OneOfOpNotSet: return false
                default: return true
                }
            }
            case BinaryOpRequest(Xla.BinaryOpRequest)

            public static func getBinaryOpRequest(_ value:Op) -> Xla.BinaryOpRequest? {
                switch value {
                case .BinaryOpRequest(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case BroadcastRequest(Xla.BroadcastRequest)

            public static func getBroadcastRequest(_ value:Op) -> Xla.BroadcastRequest? {
                switch value {
                case .BroadcastRequest(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case CallRequest(Xla.CallRequest)

            public static func getCallRequest(_ value:Op) -> Xla.CallRequest? {
                switch value {
                case .CallRequest(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case ConcatenateRequest(Xla.ConcatenateRequest)

            public static func getConcatenateRequest(_ value:Op) -> Xla.ConcatenateRequest? {
                switch value {
                case .ConcatenateRequest(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case ConstantRequest(Xla.ConstantRequest)

            public static func getConstantRequest(_ value:Op) -> Xla.ConstantRequest? {
                switch value {
                case .ConstantRequest(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case ConvertRequest(Xla.ConvertRequest)

            public static func getConvertRequest(_ value:Op) -> Xla.ConvertRequest? {
                switch value {
                case .ConvertRequest(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case ConvolveRequest(Xla.ConvolveRequest)

            public static func getConvolveRequest(_ value:Op) -> Xla.ConvolveRequest? {
                switch value {
                case .ConvolveRequest(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case CrossReplicaSumRequest(Xla.CrossReplicaSumRequest)

            public static func getCrossReplicaSumRequest(_ value:Op) -> Xla.CrossReplicaSumRequest? {
                switch value {
                case .CrossReplicaSumRequest(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case CustomCallRequest(Xla.CustomCallRequest)

            public static func getCustomCallRequest(_ value:Op) -> Xla.CustomCallRequest? {
                switch value {
                case .CustomCallRequest(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case DynamicSliceRequest(Xla.DynamicSliceRequest)

            public static func getDynamicSliceRequest(_ value:Op) -> Xla.DynamicSliceRequest? {
                switch value {
                case .DynamicSliceRequest(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case DynamicUpdateSliceRequest(Xla.DynamicUpdateSliceRequest)

            public static func getDynamicUpdateSliceRequest(_ value:Op) -> Xla.DynamicUpdateSliceRequest? {
                switch value {
                case .DynamicUpdateSliceRequest(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case GetTupleElementRequest(Xla.GetTupleElementRequest)

            public static func getGetTupleElementRequest(_ value:Op) -> Xla.GetTupleElementRequest? {
                switch value {
                case .GetTupleElementRequest(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case InfeedRequest(Xla.InfeedRequest)

            public static func getInfeedRequest(_ value:Op) -> Xla.InfeedRequest? {
                switch value {
                case .InfeedRequest(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case MapRequest(Xla.MapRequest)

            public static func getMapRequest(_ value:Op) -> Xla.MapRequest? {
                switch value {
                case .MapRequest(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case PadRequest(Xla.PadRequest)

            public static func getPadRequest(_ value:Op) -> Xla.PadRequest? {
                switch value {
                case .PadRequest(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case ParameterRequest(Xla.ParameterRequest)

            public static func getParameterRequest(_ value:Op) -> Xla.ParameterRequest? {
                switch value {
                case .ParameterRequest(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case ReduceRequest(Xla.ReduceRequest)

            public static func getReduceRequest(_ value:Op) -> Xla.ReduceRequest? {
                switch value {
                case .ReduceRequest(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case ReduceWindowRequest(Xla.ReduceWindowRequest)

            public static func getReduceWindowRequest(_ value:Op) -> Xla.ReduceWindowRequest? {
                switch value {
                case .ReduceWindowRequest(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case ReshapeRequest(Xla.ReshapeRequest)

            public static func getReshapeRequest(_ value:Op) -> Xla.ReshapeRequest? {
                switch value {
                case .ReshapeRequest(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case ReverseRequest(Xla.ReverseRequest)

            public static func getReverseRequest(_ value:Op) -> Xla.ReverseRequest? {
                switch value {
                case .ReverseRequest(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case RngRequest(Xla.RngRequest)

            public static func getRngRequest(_ value:Op) -> Xla.RngRequest? {
                switch value {
                case .RngRequest(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case SelectAndScatterRequest(Xla.SelectAndScatterRequest)

            public static func getSelectAndScatterRequest(_ value:Op) -> Xla.SelectAndScatterRequest? {
                switch value {
                case .SelectAndScatterRequest(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case SliceRequest(Xla.SliceRequest)

            public static func getSliceRequest(_ value:Op) -> Xla.SliceRequest? {
                switch value {
                case .SliceRequest(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case TernaryOpRequest(Xla.TernaryOpRequest)

            public static func getTernaryOpRequest(_ value:Op) -> Xla.TernaryOpRequest? {
                switch value {
                case .TernaryOpRequest(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case TraceRequest(Xla.TraceRequest)

            public static func getTraceRequest(_ value:Op) -> Xla.TraceRequest? {
                switch value {
                case .TraceRequest(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case TransposeRequest(Xla.TransposeRequest)

            public static func getTransposeRequest(_ value:Op) -> Xla.TransposeRequest? {
                switch value {
                case .TransposeRequest(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case UnaryOpRequest(Xla.UnaryOpRequest)

            public static func getUnaryOpRequest(_ value:Op) -> Xla.UnaryOpRequest? {
                switch value {
                case .UnaryOpRequest(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case VariadicOpRequest(Xla.VariadicOpRequest)

            public static func getVariadicOpRequest(_ value:Op) -> Xla.VariadicOpRequest? {
                switch value {
                case .VariadicOpRequest(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case WhileRequest(Xla.WhileRequest)

            public static func getWhileRequest(_ value:Op) -> Xla.WhileRequest? {
                switch value {
                case .WhileRequest(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case SendRequest(Xla.SendRequest)

            public static func getSendRequest(_ value:Op) -> Xla.SendRequest? {
                switch value {
                case .SendRequest(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case RecvRequest(Xla.RecvRequest)

            public static func getRecvRequest(_ value:Op) -> Xla.RecvRequest? {
                switch value {
                case .RecvRequest(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case OutfeedRequest(Xla.OutfeedRequest)

            public static func getOutfeedRequest(_ value:Op) -> Xla.OutfeedRequest? {
                switch value {
                case .OutfeedRequest(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
        }
        //OneOf declaration end

        fileprivate var storageOp:OpRequest.Op =  OpRequest.Op.OneOfOpNotSet
        public func getOneOfOp() ->  OpRequest.Op {
            let copyObjectOp = storageOp
            return copyObjectOp
        }
        public fileprivate(set) var computation:Xla.ComputationHandle!
        public fileprivate(set) var hasComputation:Bool = false
        public fileprivate(set) var metadata:Xla.OpMetadata!
        public fileprivate(set) var hasMetadata:Bool = false
        public fileprivate(set) var binaryOpRequest:Xla.BinaryOpRequest!{
            get {
                return OpRequest.Op.getBinaryOpRequest(storageOp)
            }
            set (newvalue) {
                storageOp = OpRequest.Op.BinaryOpRequest(newvalue)
            }
        }
        public fileprivate(set) var hasBinaryOpRequest:Bool {
            get {
                guard let _ = OpRequest.Op.getBinaryOpRequest(storageOp) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var broadcastRequest:Xla.BroadcastRequest!{
            get {
                return OpRequest.Op.getBroadcastRequest(storageOp)
            }
            set (newvalue) {
                storageOp = OpRequest.Op.BroadcastRequest(newvalue)
            }
        }
        public fileprivate(set) var hasBroadcastRequest:Bool {
            get {
                guard let _ = OpRequest.Op.getBroadcastRequest(storageOp) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var callRequest:Xla.CallRequest!{
            get {
                return OpRequest.Op.getCallRequest(storageOp)
            }
            set (newvalue) {
                storageOp = OpRequest.Op.CallRequest(newvalue)
            }
        }
        public fileprivate(set) var hasCallRequest:Bool {
            get {
                guard let _ = OpRequest.Op.getCallRequest(storageOp) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var concatenateRequest:Xla.ConcatenateRequest!{
            get {
                return OpRequest.Op.getConcatenateRequest(storageOp)
            }
            set (newvalue) {
                storageOp = OpRequest.Op.ConcatenateRequest(newvalue)
            }
        }
        public fileprivate(set) var hasConcatenateRequest:Bool {
            get {
                guard let _ = OpRequest.Op.getConcatenateRequest(storageOp) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var constantRequest:Xla.ConstantRequest!{
            get {
                return OpRequest.Op.getConstantRequest(storageOp)
            }
            set (newvalue) {
                storageOp = OpRequest.Op.ConstantRequest(newvalue)
            }
        }
        public fileprivate(set) var hasConstantRequest:Bool {
            get {
                guard let _ = OpRequest.Op.getConstantRequest(storageOp) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var convertRequest:Xla.ConvertRequest!{
            get {
                return OpRequest.Op.getConvertRequest(storageOp)
            }
            set (newvalue) {
                storageOp = OpRequest.Op.ConvertRequest(newvalue)
            }
        }
        public fileprivate(set) var hasConvertRequest:Bool {
            get {
                guard let _ = OpRequest.Op.getConvertRequest(storageOp) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var convolveRequest:Xla.ConvolveRequest!{
            get {
                return OpRequest.Op.getConvolveRequest(storageOp)
            }
            set (newvalue) {
                storageOp = OpRequest.Op.ConvolveRequest(newvalue)
            }
        }
        public fileprivate(set) var hasConvolveRequest:Bool {
            get {
                guard let _ = OpRequest.Op.getConvolveRequest(storageOp) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var crossReplicaSumRequest:Xla.CrossReplicaSumRequest!{
            get {
                return OpRequest.Op.getCrossReplicaSumRequest(storageOp)
            }
            set (newvalue) {
                storageOp = OpRequest.Op.CrossReplicaSumRequest(newvalue)
            }
        }
        public fileprivate(set) var hasCrossReplicaSumRequest:Bool {
            get {
                guard let _ = OpRequest.Op.getCrossReplicaSumRequest(storageOp) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var customCallRequest:Xla.CustomCallRequest!{
            get {
                return OpRequest.Op.getCustomCallRequest(storageOp)
            }
            set (newvalue) {
                storageOp = OpRequest.Op.CustomCallRequest(newvalue)
            }
        }
        public fileprivate(set) var hasCustomCallRequest:Bool {
            get {
                guard let _ = OpRequest.Op.getCustomCallRequest(storageOp) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var dynamicSliceRequest:Xla.DynamicSliceRequest!{
            get {
                return OpRequest.Op.getDynamicSliceRequest(storageOp)
            }
            set (newvalue) {
                storageOp = OpRequest.Op.DynamicSliceRequest(newvalue)
            }
        }
        public fileprivate(set) var hasDynamicSliceRequest:Bool {
            get {
                guard let _ = OpRequest.Op.getDynamicSliceRequest(storageOp) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var dynamicUpdateSliceRequest:Xla.DynamicUpdateSliceRequest!{
            get {
                return OpRequest.Op.getDynamicUpdateSliceRequest(storageOp)
            }
            set (newvalue) {
                storageOp = OpRequest.Op.DynamicUpdateSliceRequest(newvalue)
            }
        }
        public fileprivate(set) var hasDynamicUpdateSliceRequest:Bool {
            get {
                guard let _ = OpRequest.Op.getDynamicUpdateSliceRequest(storageOp) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var getTupleElementRequest:Xla.GetTupleElementRequest!{
            get {
                return OpRequest.Op.getGetTupleElementRequest(storageOp)
            }
            set (newvalue) {
                storageOp = OpRequest.Op.GetTupleElementRequest(newvalue)
            }
        }
        public fileprivate(set) var hasGetTupleElementRequest:Bool {
            get {
                guard let _ = OpRequest.Op.getGetTupleElementRequest(storageOp) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var infeedRequest:Xla.InfeedRequest!{
            get {
                return OpRequest.Op.getInfeedRequest(storageOp)
            }
            set (newvalue) {
                storageOp = OpRequest.Op.InfeedRequest(newvalue)
            }
        }
        public fileprivate(set) var hasInfeedRequest:Bool {
            get {
                guard let _ = OpRequest.Op.getInfeedRequest(storageOp) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var mapRequest:Xla.MapRequest!{
            get {
                return OpRequest.Op.getMapRequest(storageOp)
            }
            set (newvalue) {
                storageOp = OpRequest.Op.MapRequest(newvalue)
            }
        }
        public fileprivate(set) var hasMapRequest:Bool {
            get {
                guard let _ = OpRequest.Op.getMapRequest(storageOp) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var padRequest:Xla.PadRequest!{
            get {
                return OpRequest.Op.getPadRequest(storageOp)
            }
            set (newvalue) {
                storageOp = OpRequest.Op.PadRequest(newvalue)
            }
        }
        public fileprivate(set) var hasPadRequest:Bool {
            get {
                guard let _ = OpRequest.Op.getPadRequest(storageOp) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var parameterRequest:Xla.ParameterRequest!{
            get {
                return OpRequest.Op.getParameterRequest(storageOp)
            }
            set (newvalue) {
                storageOp = OpRequest.Op.ParameterRequest(newvalue)
            }
        }
        public fileprivate(set) var hasParameterRequest:Bool {
            get {
                guard let _ = OpRequest.Op.getParameterRequest(storageOp) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var reduceRequest:Xla.ReduceRequest!{
            get {
                return OpRequest.Op.getReduceRequest(storageOp)
            }
            set (newvalue) {
                storageOp = OpRequest.Op.ReduceRequest(newvalue)
            }
        }
        public fileprivate(set) var hasReduceRequest:Bool {
            get {
                guard let _ = OpRequest.Op.getReduceRequest(storageOp) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var reduceWindowRequest:Xla.ReduceWindowRequest!{
            get {
                return OpRequest.Op.getReduceWindowRequest(storageOp)
            }
            set (newvalue) {
                storageOp = OpRequest.Op.ReduceWindowRequest(newvalue)
            }
        }
        public fileprivate(set) var hasReduceWindowRequest:Bool {
            get {
                guard let _ = OpRequest.Op.getReduceWindowRequest(storageOp) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var reshapeRequest:Xla.ReshapeRequest!{
            get {
                return OpRequest.Op.getReshapeRequest(storageOp)
            }
            set (newvalue) {
                storageOp = OpRequest.Op.ReshapeRequest(newvalue)
            }
        }
        public fileprivate(set) var hasReshapeRequest:Bool {
            get {
                guard let _ = OpRequest.Op.getReshapeRequest(storageOp) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var reverseRequest:Xla.ReverseRequest!{
            get {
                return OpRequest.Op.getReverseRequest(storageOp)
            }
            set (newvalue) {
                storageOp = OpRequest.Op.ReverseRequest(newvalue)
            }
        }
        public fileprivate(set) var hasReverseRequest:Bool {
            get {
                guard let _ = OpRequest.Op.getReverseRequest(storageOp) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var rngRequest:Xla.RngRequest!{
            get {
                return OpRequest.Op.getRngRequest(storageOp)
            }
            set (newvalue) {
                storageOp = OpRequest.Op.RngRequest(newvalue)
            }
        }
        public fileprivate(set) var hasRngRequest:Bool {
            get {
                guard let _ = OpRequest.Op.getRngRequest(storageOp) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var selectAndScatterRequest:Xla.SelectAndScatterRequest!{
            get {
                return OpRequest.Op.getSelectAndScatterRequest(storageOp)
            }
            set (newvalue) {
                storageOp = OpRequest.Op.SelectAndScatterRequest(newvalue)
            }
        }
        public fileprivate(set) var hasSelectAndScatterRequest:Bool {
            get {
                guard let _ = OpRequest.Op.getSelectAndScatterRequest(storageOp) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var sliceRequest:Xla.SliceRequest!{
            get {
                return OpRequest.Op.getSliceRequest(storageOp)
            }
            set (newvalue) {
                storageOp = OpRequest.Op.SliceRequest(newvalue)
            }
        }
        public fileprivate(set) var hasSliceRequest:Bool {
            get {
                guard let _ = OpRequest.Op.getSliceRequest(storageOp) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var ternaryOpRequest:Xla.TernaryOpRequest!{
            get {
                return OpRequest.Op.getTernaryOpRequest(storageOp)
            }
            set (newvalue) {
                storageOp = OpRequest.Op.TernaryOpRequest(newvalue)
            }
        }
        public fileprivate(set) var hasTernaryOpRequest:Bool {
            get {
                guard let _ = OpRequest.Op.getTernaryOpRequest(storageOp) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var traceRequest:Xla.TraceRequest!{
            get {
                return OpRequest.Op.getTraceRequest(storageOp)
            }
            set (newvalue) {
                storageOp = OpRequest.Op.TraceRequest(newvalue)
            }
        }
        public fileprivate(set) var hasTraceRequest:Bool {
            get {
                guard let _ = OpRequest.Op.getTraceRequest(storageOp) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var transposeRequest:Xla.TransposeRequest!{
            get {
                return OpRequest.Op.getTransposeRequest(storageOp)
            }
            set (newvalue) {
                storageOp = OpRequest.Op.TransposeRequest(newvalue)
            }
        }
        public fileprivate(set) var hasTransposeRequest:Bool {
            get {
                guard let _ = OpRequest.Op.getTransposeRequest(storageOp) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var unaryOpRequest:Xla.UnaryOpRequest!{
            get {
                return OpRequest.Op.getUnaryOpRequest(storageOp)
            }
            set (newvalue) {
                storageOp = OpRequest.Op.UnaryOpRequest(newvalue)
            }
        }
        public fileprivate(set) var hasUnaryOpRequest:Bool {
            get {
                guard let _ = OpRequest.Op.getUnaryOpRequest(storageOp) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var variadicOpRequest:Xla.VariadicOpRequest!{
            get {
                return OpRequest.Op.getVariadicOpRequest(storageOp)
            }
            set (newvalue) {
                storageOp = OpRequest.Op.VariadicOpRequest(newvalue)
            }
        }
        public fileprivate(set) var hasVariadicOpRequest:Bool {
            get {
                guard let _ = OpRequest.Op.getVariadicOpRequest(storageOp) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var whileRequest:Xla.WhileRequest!{
            get {
                return OpRequest.Op.getWhileRequest(storageOp)
            }
            set (newvalue) {
                storageOp = OpRequest.Op.WhileRequest(newvalue)
            }
        }
        public fileprivate(set) var hasWhileRequest:Bool {
            get {
                guard let _ = OpRequest.Op.getWhileRequest(storageOp) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var sendRequest:Xla.SendRequest!{
            get {
                return OpRequest.Op.getSendRequest(storageOp)
            }
            set (newvalue) {
                storageOp = OpRequest.Op.SendRequest(newvalue)
            }
        }
        public fileprivate(set) var hasSendRequest:Bool {
            get {
                guard let _ = OpRequest.Op.getSendRequest(storageOp) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var recvRequest:Xla.RecvRequest!{
            get {
                return OpRequest.Op.getRecvRequest(storageOp)
            }
            set (newvalue) {
                storageOp = OpRequest.Op.RecvRequest(newvalue)
            }
        }
        public fileprivate(set) var hasRecvRequest:Bool {
            get {
                guard let _ = OpRequest.Op.getRecvRequest(storageOp) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var outfeedRequest:Xla.OutfeedRequest!{
            get {
                return OpRequest.Op.getOutfeedRequest(storageOp)
            }
            set (newvalue) {
                storageOp = OpRequest.Op.OutfeedRequest(newvalue)
            }
        }
        public fileprivate(set) var hasOutfeedRequest:Bool {
            get {
                guard let _ = OpRequest.Op.getOutfeedRequest(storageOp) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasComputation {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:computation)
            }
            if hasBinaryOpRequest {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:binaryOpRequest)
            }
            if hasBroadcastRequest {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:broadcastRequest)
            }
            if hasCallRequest {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:callRequest)
            }
            if hasConcatenateRequest {
                try codedOutputStream.writeMessage(fieldNumber: 5, value:concatenateRequest)
            }
            if hasConstantRequest {
                try codedOutputStream.writeMessage(fieldNumber: 6, value:constantRequest)
            }
            if hasConvertRequest {
                try codedOutputStream.writeMessage(fieldNumber: 7, value:convertRequest)
            }
            if hasConvolveRequest {
                try codedOutputStream.writeMessage(fieldNumber: 8, value:convolveRequest)
            }
            if hasCrossReplicaSumRequest {
                try codedOutputStream.writeMessage(fieldNumber: 9, value:crossReplicaSumRequest)
            }
            if hasCustomCallRequest {
                try codedOutputStream.writeMessage(fieldNumber: 10, value:customCallRequest)
            }
            if hasDynamicSliceRequest {
                try codedOutputStream.writeMessage(fieldNumber: 11, value:dynamicSliceRequest)
            }
            if hasDynamicUpdateSliceRequest {
                try codedOutputStream.writeMessage(fieldNumber: 12, value:dynamicUpdateSliceRequest)
            }
            if hasGetTupleElementRequest {
                try codedOutputStream.writeMessage(fieldNumber: 13, value:getTupleElementRequest)
            }
            if hasInfeedRequest {
                try codedOutputStream.writeMessage(fieldNumber: 14, value:infeedRequest)
            }
            if hasMapRequest {
                try codedOutputStream.writeMessage(fieldNumber: 15, value:mapRequest)
            }
            if hasPadRequest {
                try codedOutputStream.writeMessage(fieldNumber: 16, value:padRequest)
            }
            if hasParameterRequest {
                try codedOutputStream.writeMessage(fieldNumber: 17, value:parameterRequest)
            }
            if hasReduceRequest {
                try codedOutputStream.writeMessage(fieldNumber: 18, value:reduceRequest)
            }
            if hasReduceWindowRequest {
                try codedOutputStream.writeMessage(fieldNumber: 19, value:reduceWindowRequest)
            }
            if hasReshapeRequest {
                try codedOutputStream.writeMessage(fieldNumber: 20, value:reshapeRequest)
            }
            if hasReverseRequest {
                try codedOutputStream.writeMessage(fieldNumber: 21, value:reverseRequest)
            }
            if hasRngRequest {
                try codedOutputStream.writeMessage(fieldNumber: 22, value:rngRequest)
            }
            if hasSelectAndScatterRequest {
                try codedOutputStream.writeMessage(fieldNumber: 23, value:selectAndScatterRequest)
            }
            if hasSliceRequest {
                try codedOutputStream.writeMessage(fieldNumber: 24, value:sliceRequest)
            }
            if hasTernaryOpRequest {
                try codedOutputStream.writeMessage(fieldNumber: 25, value:ternaryOpRequest)
            }
            if hasTraceRequest {
                try codedOutputStream.writeMessage(fieldNumber: 26, value:traceRequest)
            }
            if hasUnaryOpRequest {
                try codedOutputStream.writeMessage(fieldNumber: 27, value:unaryOpRequest)
            }
            if hasVariadicOpRequest {
                try codedOutputStream.writeMessage(fieldNumber: 28, value:variadicOpRequest)
            }
            if hasWhileRequest {
                try codedOutputStream.writeMessage(fieldNumber: 29, value:whileRequest)
            }
            if hasSendRequest {
                try codedOutputStream.writeMessage(fieldNumber: 30, value:sendRequest)
            }
            if hasRecvRequest {
                try codedOutputStream.writeMessage(fieldNumber: 31, value:recvRequest)
            }
            if hasOutfeedRequest {
                try codedOutputStream.writeMessage(fieldNumber: 32, value:outfeedRequest)
            }
            if hasMetadata {
                try codedOutputStream.writeMessage(fieldNumber: 33, value:metadata)
            }
            if hasTransposeRequest {
                try codedOutputStream.writeMessage(fieldNumber: 34, value:transposeRequest)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasComputation {
                if let varSizecomputation = computation?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizecomputation
                }
            }
            if hasBinaryOpRequest {
                if let varSizebinaryOpRequest = binaryOpRequest?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizebinaryOpRequest
                }
            }
            if hasBroadcastRequest {
                if let varSizebroadcastRequest = broadcastRequest?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizebroadcastRequest
                }
            }
            if hasCallRequest {
                if let varSizecallRequest = callRequest?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizecallRequest
                }
            }
            if hasConcatenateRequest {
                if let varSizeconcatenateRequest = concatenateRequest?.computeMessageSize(fieldNumber: 5) {
                    serialize_size += varSizeconcatenateRequest
                }
            }
            if hasConstantRequest {
                if let varSizeconstantRequest = constantRequest?.computeMessageSize(fieldNumber: 6) {
                    serialize_size += varSizeconstantRequest
                }
            }
            if hasConvertRequest {
                if let varSizeconvertRequest = convertRequest?.computeMessageSize(fieldNumber: 7) {
                    serialize_size += varSizeconvertRequest
                }
            }
            if hasConvolveRequest {
                if let varSizeconvolveRequest = convolveRequest?.computeMessageSize(fieldNumber: 8) {
                    serialize_size += varSizeconvolveRequest
                }
            }
            if hasCrossReplicaSumRequest {
                if let varSizecrossReplicaSumRequest = crossReplicaSumRequest?.computeMessageSize(fieldNumber: 9) {
                    serialize_size += varSizecrossReplicaSumRequest
                }
            }
            if hasCustomCallRequest {
                if let varSizecustomCallRequest = customCallRequest?.computeMessageSize(fieldNumber: 10) {
                    serialize_size += varSizecustomCallRequest
                }
            }
            if hasDynamicSliceRequest {
                if let varSizedynamicSliceRequest = dynamicSliceRequest?.computeMessageSize(fieldNumber: 11) {
                    serialize_size += varSizedynamicSliceRequest
                }
            }
            if hasDynamicUpdateSliceRequest {
                if let varSizedynamicUpdateSliceRequest = dynamicUpdateSliceRequest?.computeMessageSize(fieldNumber: 12) {
                    serialize_size += varSizedynamicUpdateSliceRequest
                }
            }
            if hasGetTupleElementRequest {
                if let varSizegetTupleElementRequest = getTupleElementRequest?.computeMessageSize(fieldNumber: 13) {
                    serialize_size += varSizegetTupleElementRequest
                }
            }
            if hasInfeedRequest {
                if let varSizeinfeedRequest = infeedRequest?.computeMessageSize(fieldNumber: 14) {
                    serialize_size += varSizeinfeedRequest
                }
            }
            if hasMapRequest {
                if let varSizemapRequest = mapRequest?.computeMessageSize(fieldNumber: 15) {
                    serialize_size += varSizemapRequest
                }
            }
            if hasPadRequest {
                if let varSizepadRequest = padRequest?.computeMessageSize(fieldNumber: 16) {
                    serialize_size += varSizepadRequest
                }
            }
            if hasParameterRequest {
                if let varSizeparameterRequest = parameterRequest?.computeMessageSize(fieldNumber: 17) {
                    serialize_size += varSizeparameterRequest
                }
            }
            if hasReduceRequest {
                if let varSizereduceRequest = reduceRequest?.computeMessageSize(fieldNumber: 18) {
                    serialize_size += varSizereduceRequest
                }
            }
            if hasReduceWindowRequest {
                if let varSizereduceWindowRequest = reduceWindowRequest?.computeMessageSize(fieldNumber: 19) {
                    serialize_size += varSizereduceWindowRequest
                }
            }
            if hasReshapeRequest {
                if let varSizereshapeRequest = reshapeRequest?.computeMessageSize(fieldNumber: 20) {
                    serialize_size += varSizereshapeRequest
                }
            }
            if hasReverseRequest {
                if let varSizereverseRequest = reverseRequest?.computeMessageSize(fieldNumber: 21) {
                    serialize_size += varSizereverseRequest
                }
            }
            if hasRngRequest {
                if let varSizerngRequest = rngRequest?.computeMessageSize(fieldNumber: 22) {
                    serialize_size += varSizerngRequest
                }
            }
            if hasSelectAndScatterRequest {
                if let varSizeselectAndScatterRequest = selectAndScatterRequest?.computeMessageSize(fieldNumber: 23) {
                    serialize_size += varSizeselectAndScatterRequest
                }
            }
            if hasSliceRequest {
                if let varSizesliceRequest = sliceRequest?.computeMessageSize(fieldNumber: 24) {
                    serialize_size += varSizesliceRequest
                }
            }
            if hasTernaryOpRequest {
                if let varSizeternaryOpRequest = ternaryOpRequest?.computeMessageSize(fieldNumber: 25) {
                    serialize_size += varSizeternaryOpRequest
                }
            }
            if hasTraceRequest {
                if let varSizetraceRequest = traceRequest?.computeMessageSize(fieldNumber: 26) {
                    serialize_size += varSizetraceRequest
                }
            }
            if hasUnaryOpRequest {
                if let varSizeunaryOpRequest = unaryOpRequest?.computeMessageSize(fieldNumber: 27) {
                    serialize_size += varSizeunaryOpRequest
                }
            }
            if hasVariadicOpRequest {
                if let varSizevariadicOpRequest = variadicOpRequest?.computeMessageSize(fieldNumber: 28) {
                    serialize_size += varSizevariadicOpRequest
                }
            }
            if hasWhileRequest {
                if let varSizewhileRequest = whileRequest?.computeMessageSize(fieldNumber: 29) {
                    serialize_size += varSizewhileRequest
                }
            }
            if hasSendRequest {
                if let varSizesendRequest = sendRequest?.computeMessageSize(fieldNumber: 30) {
                    serialize_size += varSizesendRequest
                }
            }
            if hasRecvRequest {
                if let varSizerecvRequest = recvRequest?.computeMessageSize(fieldNumber: 31) {
                    serialize_size += varSizerecvRequest
                }
            }
            if hasOutfeedRequest {
                if let varSizeoutfeedRequest = outfeedRequest?.computeMessageSize(fieldNumber: 32) {
                    serialize_size += varSizeoutfeedRequest
                }
            }
            if hasMetadata {
                if let varSizemetadata = metadata?.computeMessageSize(fieldNumber: 33) {
                    serialize_size += varSizemetadata
                }
            }
            if hasTransposeRequest {
                if let varSizetransposeRequest = transposeRequest?.computeMessageSize(fieldNumber: 34) {
                    serialize_size += varSizetransposeRequest
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.OpRequest.Builder {
            return Xla.OpRequest.classBuilder() as! Xla.OpRequest.Builder
        }
        public func getBuilder() -> Xla.OpRequest.Builder {
            return classBuilder() as! Xla.OpRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.OpRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.OpRequest.Builder()
        }
        public func toBuilder() throws -> Xla.OpRequest.Builder {
            return try Xla.OpRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.OpRequest) throws -> Xla.OpRequest.Builder {
            return try Xla.OpRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasComputation {
                jsonMap["computation"] = try computation.encode()
            }
            if hasMetadata {
                jsonMap["metadata"] = try metadata.encode()
            }
            if hasBinaryOpRequest {
                jsonMap["binaryOpRequest"] = try binaryOpRequest.encode()
            }
            if hasBroadcastRequest {
                jsonMap["broadcastRequest"] = try broadcastRequest.encode()
            }
            if hasCallRequest {
                jsonMap["callRequest"] = try callRequest.encode()
            }
            if hasConcatenateRequest {
                jsonMap["concatenateRequest"] = try concatenateRequest.encode()
            }
            if hasConstantRequest {
                jsonMap["constantRequest"] = try constantRequest.encode()
            }
            if hasConvertRequest {
                jsonMap["convertRequest"] = try convertRequest.encode()
            }
            if hasConvolveRequest {
                jsonMap["convolveRequest"] = try convolveRequest.encode()
            }
            if hasCrossReplicaSumRequest {
                jsonMap["crossReplicaSumRequest"] = try crossReplicaSumRequest.encode()
            }
            if hasCustomCallRequest {
                jsonMap["customCallRequest"] = try customCallRequest.encode()
            }
            if hasDynamicSliceRequest {
                jsonMap["dynamicSliceRequest"] = try dynamicSliceRequest.encode()
            }
            if hasDynamicUpdateSliceRequest {
                jsonMap["dynamicUpdateSliceRequest"] = try dynamicUpdateSliceRequest.encode()
            }
            if hasGetTupleElementRequest {
                jsonMap["getTupleElementRequest"] = try getTupleElementRequest.encode()
            }
            if hasInfeedRequest {
                jsonMap["infeedRequest"] = try infeedRequest.encode()
            }
            if hasMapRequest {
                jsonMap["mapRequest"] = try mapRequest.encode()
            }
            if hasPadRequest {
                jsonMap["padRequest"] = try padRequest.encode()
            }
            if hasParameterRequest {
                jsonMap["parameterRequest"] = try parameterRequest.encode()
            }
            if hasReduceRequest {
                jsonMap["reduceRequest"] = try reduceRequest.encode()
            }
            if hasReduceWindowRequest {
                jsonMap["reduceWindowRequest"] = try reduceWindowRequest.encode()
            }
            if hasReshapeRequest {
                jsonMap["reshapeRequest"] = try reshapeRequest.encode()
            }
            if hasReverseRequest {
                jsonMap["reverseRequest"] = try reverseRequest.encode()
            }
            if hasRngRequest {
                jsonMap["rngRequest"] = try rngRequest.encode()
            }
            if hasSelectAndScatterRequest {
                jsonMap["selectAndScatterRequest"] = try selectAndScatterRequest.encode()
            }
            if hasSliceRequest {
                jsonMap["sliceRequest"] = try sliceRequest.encode()
            }
            if hasTernaryOpRequest {
                jsonMap["ternaryOpRequest"] = try ternaryOpRequest.encode()
            }
            if hasTraceRequest {
                jsonMap["traceRequest"] = try traceRequest.encode()
            }
            if hasTransposeRequest {
                jsonMap["transposeRequest"] = try transposeRequest.encode()
            }
            if hasUnaryOpRequest {
                jsonMap["unaryOpRequest"] = try unaryOpRequest.encode()
            }
            if hasVariadicOpRequest {
                jsonMap["variadicOpRequest"] = try variadicOpRequest.encode()
            }
            if hasWhileRequest {
                jsonMap["whileRequest"] = try whileRequest.encode()
            }
            if hasSendRequest {
                jsonMap["sendRequest"] = try sendRequest.encode()
            }
            if hasRecvRequest {
                jsonMap["recvRequest"] = try recvRequest.encode()
            }
            if hasOutfeedRequest {
                jsonMap["outfeedRequest"] = try outfeedRequest.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.OpRequest {
            return try Xla.OpRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.OpRequest {
            return try Xla.OpRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasComputation {
                output += "\(indent) computation {\n"
                if let outDescComputation = computation {
                    output += try outDescComputation.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasBinaryOpRequest {
                output += "\(indent) binaryOpRequest {\n"
                if let outDescBinaryOpRequest = binaryOpRequest {
                    output += try outDescBinaryOpRequest.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasBroadcastRequest {
                output += "\(indent) broadcastRequest {\n"
                if let outDescBroadcastRequest = broadcastRequest {
                    output += try outDescBroadcastRequest.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasCallRequest {
                output += "\(indent) callRequest {\n"
                if let outDescCallRequest = callRequest {
                    output += try outDescCallRequest.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasConcatenateRequest {
                output += "\(indent) concatenateRequest {\n"
                if let outDescConcatenateRequest = concatenateRequest {
                    output += try outDescConcatenateRequest.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasConstantRequest {
                output += "\(indent) constantRequest {\n"
                if let outDescConstantRequest = constantRequest {
                    output += try outDescConstantRequest.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasConvertRequest {
                output += "\(indent) convertRequest {\n"
                if let outDescConvertRequest = convertRequest {
                    output += try outDescConvertRequest.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasConvolveRequest {
                output += "\(indent) convolveRequest {\n"
                if let outDescConvolveRequest = convolveRequest {
                    output += try outDescConvolveRequest.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasCrossReplicaSumRequest {
                output += "\(indent) crossReplicaSumRequest {\n"
                if let outDescCrossReplicaSumRequest = crossReplicaSumRequest {
                    output += try outDescCrossReplicaSumRequest.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasCustomCallRequest {
                output += "\(indent) customCallRequest {\n"
                if let outDescCustomCallRequest = customCallRequest {
                    output += try outDescCustomCallRequest.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasDynamicSliceRequest {
                output += "\(indent) dynamicSliceRequest {\n"
                if let outDescDynamicSliceRequest = dynamicSliceRequest {
                    output += try outDescDynamicSliceRequest.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasDynamicUpdateSliceRequest {
                output += "\(indent) dynamicUpdateSliceRequest {\n"
                if let outDescDynamicUpdateSliceRequest = dynamicUpdateSliceRequest {
                    output += try outDescDynamicUpdateSliceRequest.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasGetTupleElementRequest {
                output += "\(indent) getTupleElementRequest {\n"
                if let outDescGetTupleElementRequest = getTupleElementRequest {
                    output += try outDescGetTupleElementRequest.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasInfeedRequest {
                output += "\(indent) infeedRequest {\n"
                if let outDescInfeedRequest = infeedRequest {
                    output += try outDescInfeedRequest.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasMapRequest {
                output += "\(indent) mapRequest {\n"
                if let outDescMapRequest = mapRequest {
                    output += try outDescMapRequest.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasPadRequest {
                output += "\(indent) padRequest {\n"
                if let outDescPadRequest = padRequest {
                    output += try outDescPadRequest.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasParameterRequest {
                output += "\(indent) parameterRequest {\n"
                if let outDescParameterRequest = parameterRequest {
                    output += try outDescParameterRequest.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasReduceRequest {
                output += "\(indent) reduceRequest {\n"
                if let outDescReduceRequest = reduceRequest {
                    output += try outDescReduceRequest.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasReduceWindowRequest {
                output += "\(indent) reduceWindowRequest {\n"
                if let outDescReduceWindowRequest = reduceWindowRequest {
                    output += try outDescReduceWindowRequest.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasReshapeRequest {
                output += "\(indent) reshapeRequest {\n"
                if let outDescReshapeRequest = reshapeRequest {
                    output += try outDescReshapeRequest.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasReverseRequest {
                output += "\(indent) reverseRequest {\n"
                if let outDescReverseRequest = reverseRequest {
                    output += try outDescReverseRequest.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasRngRequest {
                output += "\(indent) rngRequest {\n"
                if let outDescRngRequest = rngRequest {
                    output += try outDescRngRequest.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasSelectAndScatterRequest {
                output += "\(indent) selectAndScatterRequest {\n"
                if let outDescSelectAndScatterRequest = selectAndScatterRequest {
                    output += try outDescSelectAndScatterRequest.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasSliceRequest {
                output += "\(indent) sliceRequest {\n"
                if let outDescSliceRequest = sliceRequest {
                    output += try outDescSliceRequest.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasTernaryOpRequest {
                output += "\(indent) ternaryOpRequest {\n"
                if let outDescTernaryOpRequest = ternaryOpRequest {
                    output += try outDescTernaryOpRequest.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasTraceRequest {
                output += "\(indent) traceRequest {\n"
                if let outDescTraceRequest = traceRequest {
                    output += try outDescTraceRequest.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasUnaryOpRequest {
                output += "\(indent) unaryOpRequest {\n"
                if let outDescUnaryOpRequest = unaryOpRequest {
                    output += try outDescUnaryOpRequest.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasVariadicOpRequest {
                output += "\(indent) variadicOpRequest {\n"
                if let outDescVariadicOpRequest = variadicOpRequest {
                    output += try outDescVariadicOpRequest.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasWhileRequest {
                output += "\(indent) whileRequest {\n"
                if let outDescWhileRequest = whileRequest {
                    output += try outDescWhileRequest.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasSendRequest {
                output += "\(indent) sendRequest {\n"
                if let outDescSendRequest = sendRequest {
                    output += try outDescSendRequest.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasRecvRequest {
                output += "\(indent) recvRequest {\n"
                if let outDescRecvRequest = recvRequest {
                    output += try outDescRecvRequest.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasOutfeedRequest {
                output += "\(indent) outfeedRequest {\n"
                if let outDescOutfeedRequest = outfeedRequest {
                    output += try outDescOutfeedRequest.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasMetadata {
                output += "\(indent) metadata {\n"
                if let outDescMetadata = metadata {
                    output += try outDescMetadata.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasTransposeRequest {
                output += "\(indent) transposeRequest {\n"
                if let outDescTransposeRequest = transposeRequest {
                    output += try outDescTransposeRequest.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasComputation {
                    if let hashValuecomputation = computation?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecomputation
                    }
                }
                if hasBinaryOpRequest {
                    if let hashValuebinaryOpRequest = binaryOpRequest?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuebinaryOpRequest
                    }
                }
                if hasBroadcastRequest {
                    if let hashValuebroadcastRequest = broadcastRequest?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuebroadcastRequest
                    }
                }
                if hasCallRequest {
                    if let hashValuecallRequest = callRequest?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecallRequest
                    }
                }
                if hasConcatenateRequest {
                    if let hashValueconcatenateRequest = concatenateRequest?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueconcatenateRequest
                    }
                }
                if hasConstantRequest {
                    if let hashValueconstantRequest = constantRequest?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueconstantRequest
                    }
                }
                if hasConvertRequest {
                    if let hashValueconvertRequest = convertRequest?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueconvertRequest
                    }
                }
                if hasConvolveRequest {
                    if let hashValueconvolveRequest = convolveRequest?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueconvolveRequest
                    }
                }
                if hasCrossReplicaSumRequest {
                    if let hashValuecrossReplicaSumRequest = crossReplicaSumRequest?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecrossReplicaSumRequest
                    }
                }
                if hasCustomCallRequest {
                    if let hashValuecustomCallRequest = customCallRequest?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecustomCallRequest
                    }
                }
                if hasDynamicSliceRequest {
                    if let hashValuedynamicSliceRequest = dynamicSliceRequest?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuedynamicSliceRequest
                    }
                }
                if hasDynamicUpdateSliceRequest {
                    if let hashValuedynamicUpdateSliceRequest = dynamicUpdateSliceRequest?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuedynamicUpdateSliceRequest
                    }
                }
                if hasGetTupleElementRequest {
                    if let hashValuegetTupleElementRequest = getTupleElementRequest?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuegetTupleElementRequest
                    }
                }
                if hasInfeedRequest {
                    if let hashValueinfeedRequest = infeedRequest?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueinfeedRequest
                    }
                }
                if hasMapRequest {
                    if let hashValuemapRequest = mapRequest?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuemapRequest
                    }
                }
                if hasPadRequest {
                    if let hashValuepadRequest = padRequest?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuepadRequest
                    }
                }
                if hasParameterRequest {
                    if let hashValueparameterRequest = parameterRequest?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueparameterRequest
                    }
                }
                if hasReduceRequest {
                    if let hashValuereduceRequest = reduceRequest?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuereduceRequest
                    }
                }
                if hasReduceWindowRequest {
                    if let hashValuereduceWindowRequest = reduceWindowRequest?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuereduceWindowRequest
                    }
                }
                if hasReshapeRequest {
                    if let hashValuereshapeRequest = reshapeRequest?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuereshapeRequest
                    }
                }
                if hasReverseRequest {
                    if let hashValuereverseRequest = reverseRequest?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuereverseRequest
                    }
                }
                if hasRngRequest {
                    if let hashValuerngRequest = rngRequest?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuerngRequest
                    }
                }
                if hasSelectAndScatterRequest {
                    if let hashValueselectAndScatterRequest = selectAndScatterRequest?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueselectAndScatterRequest
                    }
                }
                if hasSliceRequest {
                    if let hashValuesliceRequest = sliceRequest?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuesliceRequest
                    }
                }
                if hasTernaryOpRequest {
                    if let hashValueternaryOpRequest = ternaryOpRequest?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueternaryOpRequest
                    }
                }
                if hasTraceRequest {
                    if let hashValuetraceRequest = traceRequest?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuetraceRequest
                    }
                }
                if hasUnaryOpRequest {
                    if let hashValueunaryOpRequest = unaryOpRequest?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueunaryOpRequest
                    }
                }
                if hasVariadicOpRequest {
                    if let hashValuevariadicOpRequest = variadicOpRequest?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuevariadicOpRequest
                    }
                }
                if hasWhileRequest {
                    if let hashValuewhileRequest = whileRequest?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuewhileRequest
                    }
                }
                if hasSendRequest {
                    if let hashValuesendRequest = sendRequest?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuesendRequest
                    }
                }
                if hasRecvRequest {
                    if let hashValuerecvRequest = recvRequest?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuerecvRequest
                    }
                }
                if hasOutfeedRequest {
                    if let hashValueoutfeedRequest = outfeedRequest?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoutfeedRequest
                    }
                }
                if hasMetadata {
                    if let hashValuemetadata = metadata?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuemetadata
                    }
                }
                if hasTransposeRequest {
                    if let hashValuetransposeRequest = transposeRequest?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuetransposeRequest
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.OpRequest"
        }
        override public func className() -> String {
            return "Xla.OpRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.OpRequest = Xla.OpRequest()
            public func getMessage() -> Xla.OpRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var computation:Xla.ComputationHandle! {
                get {
                    if computationBuilder_ != nil {
                        builderResult.computation = computationBuilder_.getMessage()
                    }
                    return builderResult.computation
                }
                set (value) {
                    builderResult.hasComputation = true
                    builderResult.computation = value
                }
            }
            public var hasComputation:Bool {
                get {
                    return builderResult.hasComputation
                }
            }
            fileprivate var computationBuilder_:Xla.ComputationHandle.Builder! {
                didSet {
                    builderResult.hasComputation = true
                }
            }
            public func getComputationBuilder() -> Xla.ComputationHandle.Builder {
                if computationBuilder_ == nil {
                    computationBuilder_ = Xla.ComputationHandle.Builder()
                    builderResult.computation = computationBuilder_.getMessage()
                    if computation != nil {
                        try! computationBuilder_.mergeFrom(other: computation)
                    }
                }
                return computationBuilder_
            }
            @discardableResult
            public func setComputation(_ value:Xla.ComputationHandle!) -> Xla.OpRequest.Builder {
                self.computation = value
                return self
            }
            @discardableResult
            public func mergeComputation(value:Xla.ComputationHandle) throws -> Xla.OpRequest.Builder {
                if builderResult.hasComputation {
                    builderResult.computation = try Xla.ComputationHandle.builderWithPrototype(prototype:builderResult.computation).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.computation = value
                }
                builderResult.hasComputation = true
                return self
            }
            @discardableResult
            public func clearComputation() -> Xla.OpRequest.Builder {
                computationBuilder_ = nil
                builderResult.hasComputation = false
                builderResult.computation = nil
                return self
            }
            public var metadata:Xla.OpMetadata! {
                get {
                    if metadataBuilder_ != nil {
                        builderResult.metadata = metadataBuilder_.getMessage()
                    }
                    return builderResult.metadata
                }
                set (value) {
                    builderResult.hasMetadata = true
                    builderResult.metadata = value
                }
            }
            public var hasMetadata:Bool {
                get {
                    return builderResult.hasMetadata
                }
            }
            fileprivate var metadataBuilder_:Xla.OpMetadata.Builder! {
                didSet {
                    builderResult.hasMetadata = true
                }
            }
            public func getMetadataBuilder() -> Xla.OpMetadata.Builder {
                if metadataBuilder_ == nil {
                    metadataBuilder_ = Xla.OpMetadata.Builder()
                    builderResult.metadata = metadataBuilder_.getMessage()
                    if metadata != nil {
                        try! metadataBuilder_.mergeFrom(other: metadata)
                    }
                }
                return metadataBuilder_
            }
            @discardableResult
            public func setMetadata(_ value:Xla.OpMetadata!) -> Xla.OpRequest.Builder {
                self.metadata = value
                return self
            }
            @discardableResult
            public func mergeMetadata(value:Xla.OpMetadata) throws -> Xla.OpRequest.Builder {
                if builderResult.hasMetadata {
                    builderResult.metadata = try Xla.OpMetadata.builderWithPrototype(prototype:builderResult.metadata).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.metadata = value
                }
                builderResult.hasMetadata = true
                return self
            }
            @discardableResult
            public func clearMetadata() -> Xla.OpRequest.Builder {
                metadataBuilder_ = nil
                builderResult.hasMetadata = false
                builderResult.metadata = nil
                return self
            }
            public var binaryOpRequest:Xla.BinaryOpRequest! {
                get {
                    if binaryOpRequestBuilder_ != nil {
                        builderResult.binaryOpRequest = binaryOpRequestBuilder_.getMessage()
                    }
                    return builderResult.binaryOpRequest
                }
                set (value) {
                    builderResult.hasBinaryOpRequest = true
                    builderResult.binaryOpRequest = value
                }
            }
            public var hasBinaryOpRequest:Bool {
                get {
                    return builderResult.hasBinaryOpRequest
                }
            }
            fileprivate var binaryOpRequestBuilder_:Xla.BinaryOpRequest.Builder! {
                didSet {
                    builderResult.hasBinaryOpRequest = true
                }
            }
            public func getBinaryOpRequestBuilder() -> Xla.BinaryOpRequest.Builder {
                if binaryOpRequestBuilder_ == nil {
                    binaryOpRequestBuilder_ = Xla.BinaryOpRequest.Builder()
                    builderResult.binaryOpRequest = binaryOpRequestBuilder_.getMessage()
                    if binaryOpRequest != nil {
                        try! binaryOpRequestBuilder_.mergeFrom(other: binaryOpRequest)
                    }
                }
                return binaryOpRequestBuilder_
            }
            @discardableResult
            public func setBinaryOpRequest(_ value:Xla.BinaryOpRequest!) -> Xla.OpRequest.Builder {
                self.binaryOpRequest = value
                return self
            }
            @discardableResult
            public func mergeBinaryOpRequest(value:Xla.BinaryOpRequest) throws -> Xla.OpRequest.Builder {
                if builderResult.hasBinaryOpRequest {
                    builderResult.binaryOpRequest = try Xla.BinaryOpRequest.builderWithPrototype(prototype:builderResult.binaryOpRequest).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.binaryOpRequest = value
                }
                builderResult.hasBinaryOpRequest = true
                return self
            }
            @discardableResult
            public func clearBinaryOpRequest() -> Xla.OpRequest.Builder {
                binaryOpRequestBuilder_ = nil
                builderResult.hasBinaryOpRequest = false
                builderResult.binaryOpRequest = nil
                return self
            }
            public var broadcastRequest:Xla.BroadcastRequest! {
                get {
                    if broadcastRequestBuilder_ != nil {
                        builderResult.broadcastRequest = broadcastRequestBuilder_.getMessage()
                    }
                    return builderResult.broadcastRequest
                }
                set (value) {
                    builderResult.hasBroadcastRequest = true
                    builderResult.broadcastRequest = value
                }
            }
            public var hasBroadcastRequest:Bool {
                get {
                    return builderResult.hasBroadcastRequest
                }
            }
            fileprivate var broadcastRequestBuilder_:Xla.BroadcastRequest.Builder! {
                didSet {
                    builderResult.hasBroadcastRequest = true
                }
            }
            public func getBroadcastRequestBuilder() -> Xla.BroadcastRequest.Builder {
                if broadcastRequestBuilder_ == nil {
                    broadcastRequestBuilder_ = Xla.BroadcastRequest.Builder()
                    builderResult.broadcastRequest = broadcastRequestBuilder_.getMessage()
                    if broadcastRequest != nil {
                        try! broadcastRequestBuilder_.mergeFrom(other: broadcastRequest)
                    }
                }
                return broadcastRequestBuilder_
            }
            @discardableResult
            public func setBroadcastRequest(_ value:Xla.BroadcastRequest!) -> Xla.OpRequest.Builder {
                self.broadcastRequest = value
                return self
            }
            @discardableResult
            public func mergeBroadcastRequest(value:Xla.BroadcastRequest) throws -> Xla.OpRequest.Builder {
                if builderResult.hasBroadcastRequest {
                    builderResult.broadcastRequest = try Xla.BroadcastRequest.builderWithPrototype(prototype:builderResult.broadcastRequest).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.broadcastRequest = value
                }
                builderResult.hasBroadcastRequest = true
                return self
            }
            @discardableResult
            public func clearBroadcastRequest() -> Xla.OpRequest.Builder {
                broadcastRequestBuilder_ = nil
                builderResult.hasBroadcastRequest = false
                builderResult.broadcastRequest = nil
                return self
            }
            public var callRequest:Xla.CallRequest! {
                get {
                    if callRequestBuilder_ != nil {
                        builderResult.callRequest = callRequestBuilder_.getMessage()
                    }
                    return builderResult.callRequest
                }
                set (value) {
                    builderResult.hasCallRequest = true
                    builderResult.callRequest = value
                }
            }
            public var hasCallRequest:Bool {
                get {
                    return builderResult.hasCallRequest
                }
            }
            fileprivate var callRequestBuilder_:Xla.CallRequest.Builder! {
                didSet {
                    builderResult.hasCallRequest = true
                }
            }
            public func getCallRequestBuilder() -> Xla.CallRequest.Builder {
                if callRequestBuilder_ == nil {
                    callRequestBuilder_ = Xla.CallRequest.Builder()
                    builderResult.callRequest = callRequestBuilder_.getMessage()
                    if callRequest != nil {
                        try! callRequestBuilder_.mergeFrom(other: callRequest)
                    }
                }
                return callRequestBuilder_
            }
            @discardableResult
            public func setCallRequest(_ value:Xla.CallRequest!) -> Xla.OpRequest.Builder {
                self.callRequest = value
                return self
            }
            @discardableResult
            public func mergeCallRequest(value:Xla.CallRequest) throws -> Xla.OpRequest.Builder {
                if builderResult.hasCallRequest {
                    builderResult.callRequest = try Xla.CallRequest.builderWithPrototype(prototype:builderResult.callRequest).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.callRequest = value
                }
                builderResult.hasCallRequest = true
                return self
            }
            @discardableResult
            public func clearCallRequest() -> Xla.OpRequest.Builder {
                callRequestBuilder_ = nil
                builderResult.hasCallRequest = false
                builderResult.callRequest = nil
                return self
            }
            public var concatenateRequest:Xla.ConcatenateRequest! {
                get {
                    if concatenateRequestBuilder_ != nil {
                        builderResult.concatenateRequest = concatenateRequestBuilder_.getMessage()
                    }
                    return builderResult.concatenateRequest
                }
                set (value) {
                    builderResult.hasConcatenateRequest = true
                    builderResult.concatenateRequest = value
                }
            }
            public var hasConcatenateRequest:Bool {
                get {
                    return builderResult.hasConcatenateRequest
                }
            }
            fileprivate var concatenateRequestBuilder_:Xla.ConcatenateRequest.Builder! {
                didSet {
                    builderResult.hasConcatenateRequest = true
                }
            }
            public func getConcatenateRequestBuilder() -> Xla.ConcatenateRequest.Builder {
                if concatenateRequestBuilder_ == nil {
                    concatenateRequestBuilder_ = Xla.ConcatenateRequest.Builder()
                    builderResult.concatenateRequest = concatenateRequestBuilder_.getMessage()
                    if concatenateRequest != nil {
                        try! concatenateRequestBuilder_.mergeFrom(other: concatenateRequest)
                    }
                }
                return concatenateRequestBuilder_
            }
            @discardableResult
            public func setConcatenateRequest(_ value:Xla.ConcatenateRequest!) -> Xla.OpRequest.Builder {
                self.concatenateRequest = value
                return self
            }
            @discardableResult
            public func mergeConcatenateRequest(value:Xla.ConcatenateRequest) throws -> Xla.OpRequest.Builder {
                if builderResult.hasConcatenateRequest {
                    builderResult.concatenateRequest = try Xla.ConcatenateRequest.builderWithPrototype(prototype:builderResult.concatenateRequest).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.concatenateRequest = value
                }
                builderResult.hasConcatenateRequest = true
                return self
            }
            @discardableResult
            public func clearConcatenateRequest() -> Xla.OpRequest.Builder {
                concatenateRequestBuilder_ = nil
                builderResult.hasConcatenateRequest = false
                builderResult.concatenateRequest = nil
                return self
            }
            public var constantRequest:Xla.ConstantRequest! {
                get {
                    if constantRequestBuilder_ != nil {
                        builderResult.constantRequest = constantRequestBuilder_.getMessage()
                    }
                    return builderResult.constantRequest
                }
                set (value) {
                    builderResult.hasConstantRequest = true
                    builderResult.constantRequest = value
                }
            }
            public var hasConstantRequest:Bool {
                get {
                    return builderResult.hasConstantRequest
                }
            }
            fileprivate var constantRequestBuilder_:Xla.ConstantRequest.Builder! {
                didSet {
                    builderResult.hasConstantRequest = true
                }
            }
            public func getConstantRequestBuilder() -> Xla.ConstantRequest.Builder {
                if constantRequestBuilder_ == nil {
                    constantRequestBuilder_ = Xla.ConstantRequest.Builder()
                    builderResult.constantRequest = constantRequestBuilder_.getMessage()
                    if constantRequest != nil {
                        try! constantRequestBuilder_.mergeFrom(other: constantRequest)
                    }
                }
                return constantRequestBuilder_
            }
            @discardableResult
            public func setConstantRequest(_ value:Xla.ConstantRequest!) -> Xla.OpRequest.Builder {
                self.constantRequest = value
                return self
            }
            @discardableResult
            public func mergeConstantRequest(value:Xla.ConstantRequest) throws -> Xla.OpRequest.Builder {
                if builderResult.hasConstantRequest {
                    builderResult.constantRequest = try Xla.ConstantRequest.builderWithPrototype(prototype:builderResult.constantRequest).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.constantRequest = value
                }
                builderResult.hasConstantRequest = true
                return self
            }
            @discardableResult
            public func clearConstantRequest() -> Xla.OpRequest.Builder {
                constantRequestBuilder_ = nil
                builderResult.hasConstantRequest = false
                builderResult.constantRequest = nil
                return self
            }
            public var convertRequest:Xla.ConvertRequest! {
                get {
                    if convertRequestBuilder_ != nil {
                        builderResult.convertRequest = convertRequestBuilder_.getMessage()
                    }
                    return builderResult.convertRequest
                }
                set (value) {
                    builderResult.hasConvertRequest = true
                    builderResult.convertRequest = value
                }
            }
            public var hasConvertRequest:Bool {
                get {
                    return builderResult.hasConvertRequest
                }
            }
            fileprivate var convertRequestBuilder_:Xla.ConvertRequest.Builder! {
                didSet {
                    builderResult.hasConvertRequest = true
                }
            }
            public func getConvertRequestBuilder() -> Xla.ConvertRequest.Builder {
                if convertRequestBuilder_ == nil {
                    convertRequestBuilder_ = Xla.ConvertRequest.Builder()
                    builderResult.convertRequest = convertRequestBuilder_.getMessage()
                    if convertRequest != nil {
                        try! convertRequestBuilder_.mergeFrom(other: convertRequest)
                    }
                }
                return convertRequestBuilder_
            }
            @discardableResult
            public func setConvertRequest(_ value:Xla.ConvertRequest!) -> Xla.OpRequest.Builder {
                self.convertRequest = value
                return self
            }
            @discardableResult
            public func mergeConvertRequest(value:Xla.ConvertRequest) throws -> Xla.OpRequest.Builder {
                if builderResult.hasConvertRequest {
                    builderResult.convertRequest = try Xla.ConvertRequest.builderWithPrototype(prototype:builderResult.convertRequest).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.convertRequest = value
                }
                builderResult.hasConvertRequest = true
                return self
            }
            @discardableResult
            public func clearConvertRequest() -> Xla.OpRequest.Builder {
                convertRequestBuilder_ = nil
                builderResult.hasConvertRequest = false
                builderResult.convertRequest = nil
                return self
            }
            public var convolveRequest:Xla.ConvolveRequest! {
                get {
                    if convolveRequestBuilder_ != nil {
                        builderResult.convolveRequest = convolveRequestBuilder_.getMessage()
                    }
                    return builderResult.convolveRequest
                }
                set (value) {
                    builderResult.hasConvolveRequest = true
                    builderResult.convolveRequest = value
                }
            }
            public var hasConvolveRequest:Bool {
                get {
                    return builderResult.hasConvolveRequest
                }
            }
            fileprivate var convolveRequestBuilder_:Xla.ConvolveRequest.Builder! {
                didSet {
                    builderResult.hasConvolveRequest = true
                }
            }
            public func getConvolveRequestBuilder() -> Xla.ConvolveRequest.Builder {
                if convolveRequestBuilder_ == nil {
                    convolveRequestBuilder_ = Xla.ConvolveRequest.Builder()
                    builderResult.convolveRequest = convolveRequestBuilder_.getMessage()
                    if convolveRequest != nil {
                        try! convolveRequestBuilder_.mergeFrom(other: convolveRequest)
                    }
                }
                return convolveRequestBuilder_
            }
            @discardableResult
            public func setConvolveRequest(_ value:Xla.ConvolveRequest!) -> Xla.OpRequest.Builder {
                self.convolveRequest = value
                return self
            }
            @discardableResult
            public func mergeConvolveRequest(value:Xla.ConvolveRequest) throws -> Xla.OpRequest.Builder {
                if builderResult.hasConvolveRequest {
                    builderResult.convolveRequest = try Xla.ConvolveRequest.builderWithPrototype(prototype:builderResult.convolveRequest).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.convolveRequest = value
                }
                builderResult.hasConvolveRequest = true
                return self
            }
            @discardableResult
            public func clearConvolveRequest() -> Xla.OpRequest.Builder {
                convolveRequestBuilder_ = nil
                builderResult.hasConvolveRequest = false
                builderResult.convolveRequest = nil
                return self
            }
            public var crossReplicaSumRequest:Xla.CrossReplicaSumRequest! {
                get {
                    if crossReplicaSumRequestBuilder_ != nil {
                        builderResult.crossReplicaSumRequest = crossReplicaSumRequestBuilder_.getMessage()
                    }
                    return builderResult.crossReplicaSumRequest
                }
                set (value) {
                    builderResult.hasCrossReplicaSumRequest = true
                    builderResult.crossReplicaSumRequest = value
                }
            }
            public var hasCrossReplicaSumRequest:Bool {
                get {
                    return builderResult.hasCrossReplicaSumRequest
                }
            }
            fileprivate var crossReplicaSumRequestBuilder_:Xla.CrossReplicaSumRequest.Builder! {
                didSet {
                    builderResult.hasCrossReplicaSumRequest = true
                }
            }
            public func getCrossReplicaSumRequestBuilder() -> Xla.CrossReplicaSumRequest.Builder {
                if crossReplicaSumRequestBuilder_ == nil {
                    crossReplicaSumRequestBuilder_ = Xla.CrossReplicaSumRequest.Builder()
                    builderResult.crossReplicaSumRequest = crossReplicaSumRequestBuilder_.getMessage()
                    if crossReplicaSumRequest != nil {
                        try! crossReplicaSumRequestBuilder_.mergeFrom(other: crossReplicaSumRequest)
                    }
                }
                return crossReplicaSumRequestBuilder_
            }
            @discardableResult
            public func setCrossReplicaSumRequest(_ value:Xla.CrossReplicaSumRequest!) -> Xla.OpRequest.Builder {
                self.crossReplicaSumRequest = value
                return self
            }
            @discardableResult
            public func mergeCrossReplicaSumRequest(value:Xla.CrossReplicaSumRequest) throws -> Xla.OpRequest.Builder {
                if builderResult.hasCrossReplicaSumRequest {
                    builderResult.crossReplicaSumRequest = try Xla.CrossReplicaSumRequest.builderWithPrototype(prototype:builderResult.crossReplicaSumRequest).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.crossReplicaSumRequest = value
                }
                builderResult.hasCrossReplicaSumRequest = true
                return self
            }
            @discardableResult
            public func clearCrossReplicaSumRequest() -> Xla.OpRequest.Builder {
                crossReplicaSumRequestBuilder_ = nil
                builderResult.hasCrossReplicaSumRequest = false
                builderResult.crossReplicaSumRequest = nil
                return self
            }
            public var customCallRequest:Xla.CustomCallRequest! {
                get {
                    if customCallRequestBuilder_ != nil {
                        builderResult.customCallRequest = customCallRequestBuilder_.getMessage()
                    }
                    return builderResult.customCallRequest
                }
                set (value) {
                    builderResult.hasCustomCallRequest = true
                    builderResult.customCallRequest = value
                }
            }
            public var hasCustomCallRequest:Bool {
                get {
                    return builderResult.hasCustomCallRequest
                }
            }
            fileprivate var customCallRequestBuilder_:Xla.CustomCallRequest.Builder! {
                didSet {
                    builderResult.hasCustomCallRequest = true
                }
            }
            public func getCustomCallRequestBuilder() -> Xla.CustomCallRequest.Builder {
                if customCallRequestBuilder_ == nil {
                    customCallRequestBuilder_ = Xla.CustomCallRequest.Builder()
                    builderResult.customCallRequest = customCallRequestBuilder_.getMessage()
                    if customCallRequest != nil {
                        try! customCallRequestBuilder_.mergeFrom(other: customCallRequest)
                    }
                }
                return customCallRequestBuilder_
            }
            @discardableResult
            public func setCustomCallRequest(_ value:Xla.CustomCallRequest!) -> Xla.OpRequest.Builder {
                self.customCallRequest = value
                return self
            }
            @discardableResult
            public func mergeCustomCallRequest(value:Xla.CustomCallRequest) throws -> Xla.OpRequest.Builder {
                if builderResult.hasCustomCallRequest {
                    builderResult.customCallRequest = try Xla.CustomCallRequest.builderWithPrototype(prototype:builderResult.customCallRequest).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.customCallRequest = value
                }
                builderResult.hasCustomCallRequest = true
                return self
            }
            @discardableResult
            public func clearCustomCallRequest() -> Xla.OpRequest.Builder {
                customCallRequestBuilder_ = nil
                builderResult.hasCustomCallRequest = false
                builderResult.customCallRequest = nil
                return self
            }
            public var dynamicSliceRequest:Xla.DynamicSliceRequest! {
                get {
                    if dynamicSliceRequestBuilder_ != nil {
                        builderResult.dynamicSliceRequest = dynamicSliceRequestBuilder_.getMessage()
                    }
                    return builderResult.dynamicSliceRequest
                }
                set (value) {
                    builderResult.hasDynamicSliceRequest = true
                    builderResult.dynamicSliceRequest = value
                }
            }
            public var hasDynamicSliceRequest:Bool {
                get {
                    return builderResult.hasDynamicSliceRequest
                }
            }
            fileprivate var dynamicSliceRequestBuilder_:Xla.DynamicSliceRequest.Builder! {
                didSet {
                    builderResult.hasDynamicSliceRequest = true
                }
            }
            public func getDynamicSliceRequestBuilder() -> Xla.DynamicSliceRequest.Builder {
                if dynamicSliceRequestBuilder_ == nil {
                    dynamicSliceRequestBuilder_ = Xla.DynamicSliceRequest.Builder()
                    builderResult.dynamicSliceRequest = dynamicSliceRequestBuilder_.getMessage()
                    if dynamicSliceRequest != nil {
                        try! dynamicSliceRequestBuilder_.mergeFrom(other: dynamicSliceRequest)
                    }
                }
                return dynamicSliceRequestBuilder_
            }
            @discardableResult
            public func setDynamicSliceRequest(_ value:Xla.DynamicSliceRequest!) -> Xla.OpRequest.Builder {
                self.dynamicSliceRequest = value
                return self
            }
            @discardableResult
            public func mergeDynamicSliceRequest(value:Xla.DynamicSliceRequest) throws -> Xla.OpRequest.Builder {
                if builderResult.hasDynamicSliceRequest {
                    builderResult.dynamicSliceRequest = try Xla.DynamicSliceRequest.builderWithPrototype(prototype:builderResult.dynamicSliceRequest).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.dynamicSliceRequest = value
                }
                builderResult.hasDynamicSliceRequest = true
                return self
            }
            @discardableResult
            public func clearDynamicSliceRequest() -> Xla.OpRequest.Builder {
                dynamicSliceRequestBuilder_ = nil
                builderResult.hasDynamicSliceRequest = false
                builderResult.dynamicSliceRequest = nil
                return self
            }
            public var dynamicUpdateSliceRequest:Xla.DynamicUpdateSliceRequest! {
                get {
                    if dynamicUpdateSliceRequestBuilder_ != nil {
                        builderResult.dynamicUpdateSliceRequest = dynamicUpdateSliceRequestBuilder_.getMessage()
                    }
                    return builderResult.dynamicUpdateSliceRequest
                }
                set (value) {
                    builderResult.hasDynamicUpdateSliceRequest = true
                    builderResult.dynamicUpdateSliceRequest = value
                }
            }
            public var hasDynamicUpdateSliceRequest:Bool {
                get {
                    return builderResult.hasDynamicUpdateSliceRequest
                }
            }
            fileprivate var dynamicUpdateSliceRequestBuilder_:Xla.DynamicUpdateSliceRequest.Builder! {
                didSet {
                    builderResult.hasDynamicUpdateSliceRequest = true
                }
            }
            public func getDynamicUpdateSliceRequestBuilder() -> Xla.DynamicUpdateSliceRequest.Builder {
                if dynamicUpdateSliceRequestBuilder_ == nil {
                    dynamicUpdateSliceRequestBuilder_ = Xla.DynamicUpdateSliceRequest.Builder()
                    builderResult.dynamicUpdateSliceRequest = dynamicUpdateSliceRequestBuilder_.getMessage()
                    if dynamicUpdateSliceRequest != nil {
                        try! dynamicUpdateSliceRequestBuilder_.mergeFrom(other: dynamicUpdateSliceRequest)
                    }
                }
                return dynamicUpdateSliceRequestBuilder_
            }
            @discardableResult
            public func setDynamicUpdateSliceRequest(_ value:Xla.DynamicUpdateSliceRequest!) -> Xla.OpRequest.Builder {
                self.dynamicUpdateSliceRequest = value
                return self
            }
            @discardableResult
            public func mergeDynamicUpdateSliceRequest(value:Xla.DynamicUpdateSliceRequest) throws -> Xla.OpRequest.Builder {
                if builderResult.hasDynamicUpdateSliceRequest {
                    builderResult.dynamicUpdateSliceRequest = try Xla.DynamicUpdateSliceRequest.builderWithPrototype(prototype:builderResult.dynamicUpdateSliceRequest).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.dynamicUpdateSliceRequest = value
                }
                builderResult.hasDynamicUpdateSliceRequest = true
                return self
            }
            @discardableResult
            public func clearDynamicUpdateSliceRequest() -> Xla.OpRequest.Builder {
                dynamicUpdateSliceRequestBuilder_ = nil
                builderResult.hasDynamicUpdateSliceRequest = false
                builderResult.dynamicUpdateSliceRequest = nil
                return self
            }
            public var getTupleElementRequest:Xla.GetTupleElementRequest! {
                get {
                    if getTupleElementRequestBuilder_ != nil {
                        builderResult.getTupleElementRequest = getTupleElementRequestBuilder_.getMessage()
                    }
                    return builderResult.getTupleElementRequest
                }
                set (value) {
                    builderResult.hasGetTupleElementRequest = true
                    builderResult.getTupleElementRequest = value
                }
            }
            public var hasGetTupleElementRequest:Bool {
                get {
                    return builderResult.hasGetTupleElementRequest
                }
            }
            fileprivate var getTupleElementRequestBuilder_:Xla.GetTupleElementRequest.Builder! {
                didSet {
                    builderResult.hasGetTupleElementRequest = true
                }
            }
            public func getGetTupleElementRequestBuilder() -> Xla.GetTupleElementRequest.Builder {
                if getTupleElementRequestBuilder_ == nil {
                    getTupleElementRequestBuilder_ = Xla.GetTupleElementRequest.Builder()
                    builderResult.getTupleElementRequest = getTupleElementRequestBuilder_.getMessage()
                    if getTupleElementRequest != nil {
                        try! getTupleElementRequestBuilder_.mergeFrom(other: getTupleElementRequest)
                    }
                }
                return getTupleElementRequestBuilder_
            }
            @discardableResult
            public func setGetTupleElementRequest(_ value:Xla.GetTupleElementRequest!) -> Xla.OpRequest.Builder {
                self.getTupleElementRequest = value
                return self
            }
            @discardableResult
            public func mergeGetTupleElementRequest(value:Xla.GetTupleElementRequest) throws -> Xla.OpRequest.Builder {
                if builderResult.hasGetTupleElementRequest {
                    builderResult.getTupleElementRequest = try Xla.GetTupleElementRequest.builderWithPrototype(prototype:builderResult.getTupleElementRequest).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.getTupleElementRequest = value
                }
                builderResult.hasGetTupleElementRequest = true
                return self
            }
            @discardableResult
            public func clearGetTupleElementRequest() -> Xla.OpRequest.Builder {
                getTupleElementRequestBuilder_ = nil
                builderResult.hasGetTupleElementRequest = false
                builderResult.getTupleElementRequest = nil
                return self
            }
            public var infeedRequest:Xla.InfeedRequest! {
                get {
                    if infeedRequestBuilder_ != nil {
                        builderResult.infeedRequest = infeedRequestBuilder_.getMessage()
                    }
                    return builderResult.infeedRequest
                }
                set (value) {
                    builderResult.hasInfeedRequest = true
                    builderResult.infeedRequest = value
                }
            }
            public var hasInfeedRequest:Bool {
                get {
                    return builderResult.hasInfeedRequest
                }
            }
            fileprivate var infeedRequestBuilder_:Xla.InfeedRequest.Builder! {
                didSet {
                    builderResult.hasInfeedRequest = true
                }
            }
            public func getInfeedRequestBuilder() -> Xla.InfeedRequest.Builder {
                if infeedRequestBuilder_ == nil {
                    infeedRequestBuilder_ = Xla.InfeedRequest.Builder()
                    builderResult.infeedRequest = infeedRequestBuilder_.getMessage()
                    if infeedRequest != nil {
                        try! infeedRequestBuilder_.mergeFrom(other: infeedRequest)
                    }
                }
                return infeedRequestBuilder_
            }
            @discardableResult
            public func setInfeedRequest(_ value:Xla.InfeedRequest!) -> Xla.OpRequest.Builder {
                self.infeedRequest = value
                return self
            }
            @discardableResult
            public func mergeInfeedRequest(value:Xla.InfeedRequest) throws -> Xla.OpRequest.Builder {
                if builderResult.hasInfeedRequest {
                    builderResult.infeedRequest = try Xla.InfeedRequest.builderWithPrototype(prototype:builderResult.infeedRequest).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.infeedRequest = value
                }
                builderResult.hasInfeedRequest = true
                return self
            }
            @discardableResult
            public func clearInfeedRequest() -> Xla.OpRequest.Builder {
                infeedRequestBuilder_ = nil
                builderResult.hasInfeedRequest = false
                builderResult.infeedRequest = nil
                return self
            }
            public var mapRequest:Xla.MapRequest! {
                get {
                    if mapRequestBuilder_ != nil {
                        builderResult.mapRequest = mapRequestBuilder_.getMessage()
                    }
                    return builderResult.mapRequest
                }
                set (value) {
                    builderResult.hasMapRequest = true
                    builderResult.mapRequest = value
                }
            }
            public var hasMapRequest:Bool {
                get {
                    return builderResult.hasMapRequest
                }
            }
            fileprivate var mapRequestBuilder_:Xla.MapRequest.Builder! {
                didSet {
                    builderResult.hasMapRequest = true
                }
            }
            public func getMapRequestBuilder() -> Xla.MapRequest.Builder {
                if mapRequestBuilder_ == nil {
                    mapRequestBuilder_ = Xla.MapRequest.Builder()
                    builderResult.mapRequest = mapRequestBuilder_.getMessage()
                    if mapRequest != nil {
                        try! mapRequestBuilder_.mergeFrom(other: mapRequest)
                    }
                }
                return mapRequestBuilder_
            }
            @discardableResult
            public func setMapRequest(_ value:Xla.MapRequest!) -> Xla.OpRequest.Builder {
                self.mapRequest = value
                return self
            }
            @discardableResult
            public func mergeMapRequest(value:Xla.MapRequest) throws -> Xla.OpRequest.Builder {
                if builderResult.hasMapRequest {
                    builderResult.mapRequest = try Xla.MapRequest.builderWithPrototype(prototype:builderResult.mapRequest).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.mapRequest = value
                }
                builderResult.hasMapRequest = true
                return self
            }
            @discardableResult
            public func clearMapRequest() -> Xla.OpRequest.Builder {
                mapRequestBuilder_ = nil
                builderResult.hasMapRequest = false
                builderResult.mapRequest = nil
                return self
            }
            public var padRequest:Xla.PadRequest! {
                get {
                    if padRequestBuilder_ != nil {
                        builderResult.padRequest = padRequestBuilder_.getMessage()
                    }
                    return builderResult.padRequest
                }
                set (value) {
                    builderResult.hasPadRequest = true
                    builderResult.padRequest = value
                }
            }
            public var hasPadRequest:Bool {
                get {
                    return builderResult.hasPadRequest
                }
            }
            fileprivate var padRequestBuilder_:Xla.PadRequest.Builder! {
                didSet {
                    builderResult.hasPadRequest = true
                }
            }
            public func getPadRequestBuilder() -> Xla.PadRequest.Builder {
                if padRequestBuilder_ == nil {
                    padRequestBuilder_ = Xla.PadRequest.Builder()
                    builderResult.padRequest = padRequestBuilder_.getMessage()
                    if padRequest != nil {
                        try! padRequestBuilder_.mergeFrom(other: padRequest)
                    }
                }
                return padRequestBuilder_
            }
            @discardableResult
            public func setPadRequest(_ value:Xla.PadRequest!) -> Xla.OpRequest.Builder {
                self.padRequest = value
                return self
            }
            @discardableResult
            public func mergePadRequest(value:Xla.PadRequest) throws -> Xla.OpRequest.Builder {
                if builderResult.hasPadRequest {
                    builderResult.padRequest = try Xla.PadRequest.builderWithPrototype(prototype:builderResult.padRequest).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.padRequest = value
                }
                builderResult.hasPadRequest = true
                return self
            }
            @discardableResult
            public func clearPadRequest() -> Xla.OpRequest.Builder {
                padRequestBuilder_ = nil
                builderResult.hasPadRequest = false
                builderResult.padRequest = nil
                return self
            }
            public var parameterRequest:Xla.ParameterRequest! {
                get {
                    if parameterRequestBuilder_ != nil {
                        builderResult.parameterRequest = parameterRequestBuilder_.getMessage()
                    }
                    return builderResult.parameterRequest
                }
                set (value) {
                    builderResult.hasParameterRequest = true
                    builderResult.parameterRequest = value
                }
            }
            public var hasParameterRequest:Bool {
                get {
                    return builderResult.hasParameterRequest
                }
            }
            fileprivate var parameterRequestBuilder_:Xla.ParameterRequest.Builder! {
                didSet {
                    builderResult.hasParameterRequest = true
                }
            }
            public func getParameterRequestBuilder() -> Xla.ParameterRequest.Builder {
                if parameterRequestBuilder_ == nil {
                    parameterRequestBuilder_ = Xla.ParameterRequest.Builder()
                    builderResult.parameterRequest = parameterRequestBuilder_.getMessage()
                    if parameterRequest != nil {
                        try! parameterRequestBuilder_.mergeFrom(other: parameterRequest)
                    }
                }
                return parameterRequestBuilder_
            }
            @discardableResult
            public func setParameterRequest(_ value:Xla.ParameterRequest!) -> Xla.OpRequest.Builder {
                self.parameterRequest = value
                return self
            }
            @discardableResult
            public func mergeParameterRequest(value:Xla.ParameterRequest) throws -> Xla.OpRequest.Builder {
                if builderResult.hasParameterRequest {
                    builderResult.parameterRequest = try Xla.ParameterRequest.builderWithPrototype(prototype:builderResult.parameterRequest).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.parameterRequest = value
                }
                builderResult.hasParameterRequest = true
                return self
            }
            @discardableResult
            public func clearParameterRequest() -> Xla.OpRequest.Builder {
                parameterRequestBuilder_ = nil
                builderResult.hasParameterRequest = false
                builderResult.parameterRequest = nil
                return self
            }
            public var reduceRequest:Xla.ReduceRequest! {
                get {
                    if reduceRequestBuilder_ != nil {
                        builderResult.reduceRequest = reduceRequestBuilder_.getMessage()
                    }
                    return builderResult.reduceRequest
                }
                set (value) {
                    builderResult.hasReduceRequest = true
                    builderResult.reduceRequest = value
                }
            }
            public var hasReduceRequest:Bool {
                get {
                    return builderResult.hasReduceRequest
                }
            }
            fileprivate var reduceRequestBuilder_:Xla.ReduceRequest.Builder! {
                didSet {
                    builderResult.hasReduceRequest = true
                }
            }
            public func getReduceRequestBuilder() -> Xla.ReduceRequest.Builder {
                if reduceRequestBuilder_ == nil {
                    reduceRequestBuilder_ = Xla.ReduceRequest.Builder()
                    builderResult.reduceRequest = reduceRequestBuilder_.getMessage()
                    if reduceRequest != nil {
                        try! reduceRequestBuilder_.mergeFrom(other: reduceRequest)
                    }
                }
                return reduceRequestBuilder_
            }
            @discardableResult
            public func setReduceRequest(_ value:Xla.ReduceRequest!) -> Xla.OpRequest.Builder {
                self.reduceRequest = value
                return self
            }
            @discardableResult
            public func mergeReduceRequest(value:Xla.ReduceRequest) throws -> Xla.OpRequest.Builder {
                if builderResult.hasReduceRequest {
                    builderResult.reduceRequest = try Xla.ReduceRequest.builderWithPrototype(prototype:builderResult.reduceRequest).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.reduceRequest = value
                }
                builderResult.hasReduceRequest = true
                return self
            }
            @discardableResult
            public func clearReduceRequest() -> Xla.OpRequest.Builder {
                reduceRequestBuilder_ = nil
                builderResult.hasReduceRequest = false
                builderResult.reduceRequest = nil
                return self
            }
            public var reduceWindowRequest:Xla.ReduceWindowRequest! {
                get {
                    if reduceWindowRequestBuilder_ != nil {
                        builderResult.reduceWindowRequest = reduceWindowRequestBuilder_.getMessage()
                    }
                    return builderResult.reduceWindowRequest
                }
                set (value) {
                    builderResult.hasReduceWindowRequest = true
                    builderResult.reduceWindowRequest = value
                }
            }
            public var hasReduceWindowRequest:Bool {
                get {
                    return builderResult.hasReduceWindowRequest
                }
            }
            fileprivate var reduceWindowRequestBuilder_:Xla.ReduceWindowRequest.Builder! {
                didSet {
                    builderResult.hasReduceWindowRequest = true
                }
            }
            public func getReduceWindowRequestBuilder() -> Xla.ReduceWindowRequest.Builder {
                if reduceWindowRequestBuilder_ == nil {
                    reduceWindowRequestBuilder_ = Xla.ReduceWindowRequest.Builder()
                    builderResult.reduceWindowRequest = reduceWindowRequestBuilder_.getMessage()
                    if reduceWindowRequest != nil {
                        try! reduceWindowRequestBuilder_.mergeFrom(other: reduceWindowRequest)
                    }
                }
                return reduceWindowRequestBuilder_
            }
            @discardableResult
            public func setReduceWindowRequest(_ value:Xla.ReduceWindowRequest!) -> Xla.OpRequest.Builder {
                self.reduceWindowRequest = value
                return self
            }
            @discardableResult
            public func mergeReduceWindowRequest(value:Xla.ReduceWindowRequest) throws -> Xla.OpRequest.Builder {
                if builderResult.hasReduceWindowRequest {
                    builderResult.reduceWindowRequest = try Xla.ReduceWindowRequest.builderWithPrototype(prototype:builderResult.reduceWindowRequest).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.reduceWindowRequest = value
                }
                builderResult.hasReduceWindowRequest = true
                return self
            }
            @discardableResult
            public func clearReduceWindowRequest() -> Xla.OpRequest.Builder {
                reduceWindowRequestBuilder_ = nil
                builderResult.hasReduceWindowRequest = false
                builderResult.reduceWindowRequest = nil
                return self
            }
            public var reshapeRequest:Xla.ReshapeRequest! {
                get {
                    if reshapeRequestBuilder_ != nil {
                        builderResult.reshapeRequest = reshapeRequestBuilder_.getMessage()
                    }
                    return builderResult.reshapeRequest
                }
                set (value) {
                    builderResult.hasReshapeRequest = true
                    builderResult.reshapeRequest = value
                }
            }
            public var hasReshapeRequest:Bool {
                get {
                    return builderResult.hasReshapeRequest
                }
            }
            fileprivate var reshapeRequestBuilder_:Xla.ReshapeRequest.Builder! {
                didSet {
                    builderResult.hasReshapeRequest = true
                }
            }
            public func getReshapeRequestBuilder() -> Xla.ReshapeRequest.Builder {
                if reshapeRequestBuilder_ == nil {
                    reshapeRequestBuilder_ = Xla.ReshapeRequest.Builder()
                    builderResult.reshapeRequest = reshapeRequestBuilder_.getMessage()
                    if reshapeRequest != nil {
                        try! reshapeRequestBuilder_.mergeFrom(other: reshapeRequest)
                    }
                }
                return reshapeRequestBuilder_
            }
            @discardableResult
            public func setReshapeRequest(_ value:Xla.ReshapeRequest!) -> Xla.OpRequest.Builder {
                self.reshapeRequest = value
                return self
            }
            @discardableResult
            public func mergeReshapeRequest(value:Xla.ReshapeRequest) throws -> Xla.OpRequest.Builder {
                if builderResult.hasReshapeRequest {
                    builderResult.reshapeRequest = try Xla.ReshapeRequest.builderWithPrototype(prototype:builderResult.reshapeRequest).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.reshapeRequest = value
                }
                builderResult.hasReshapeRequest = true
                return self
            }
            @discardableResult
            public func clearReshapeRequest() -> Xla.OpRequest.Builder {
                reshapeRequestBuilder_ = nil
                builderResult.hasReshapeRequest = false
                builderResult.reshapeRequest = nil
                return self
            }
            public var reverseRequest:Xla.ReverseRequest! {
                get {
                    if reverseRequestBuilder_ != nil {
                        builderResult.reverseRequest = reverseRequestBuilder_.getMessage()
                    }
                    return builderResult.reverseRequest
                }
                set (value) {
                    builderResult.hasReverseRequest = true
                    builderResult.reverseRequest = value
                }
            }
            public var hasReverseRequest:Bool {
                get {
                    return builderResult.hasReverseRequest
                }
            }
            fileprivate var reverseRequestBuilder_:Xla.ReverseRequest.Builder! {
                didSet {
                    builderResult.hasReverseRequest = true
                }
            }
            public func getReverseRequestBuilder() -> Xla.ReverseRequest.Builder {
                if reverseRequestBuilder_ == nil {
                    reverseRequestBuilder_ = Xla.ReverseRequest.Builder()
                    builderResult.reverseRequest = reverseRequestBuilder_.getMessage()
                    if reverseRequest != nil {
                        try! reverseRequestBuilder_.mergeFrom(other: reverseRequest)
                    }
                }
                return reverseRequestBuilder_
            }
            @discardableResult
            public func setReverseRequest(_ value:Xla.ReverseRequest!) -> Xla.OpRequest.Builder {
                self.reverseRequest = value
                return self
            }
            @discardableResult
            public func mergeReverseRequest(value:Xla.ReverseRequest) throws -> Xla.OpRequest.Builder {
                if builderResult.hasReverseRequest {
                    builderResult.reverseRequest = try Xla.ReverseRequest.builderWithPrototype(prototype:builderResult.reverseRequest).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.reverseRequest = value
                }
                builderResult.hasReverseRequest = true
                return self
            }
            @discardableResult
            public func clearReverseRequest() -> Xla.OpRequest.Builder {
                reverseRequestBuilder_ = nil
                builderResult.hasReverseRequest = false
                builderResult.reverseRequest = nil
                return self
            }
            public var rngRequest:Xla.RngRequest! {
                get {
                    if rngRequestBuilder_ != nil {
                        builderResult.rngRequest = rngRequestBuilder_.getMessage()
                    }
                    return builderResult.rngRequest
                }
                set (value) {
                    builderResult.hasRngRequest = true
                    builderResult.rngRequest = value
                }
            }
            public var hasRngRequest:Bool {
                get {
                    return builderResult.hasRngRequest
                }
            }
            fileprivate var rngRequestBuilder_:Xla.RngRequest.Builder! {
                didSet {
                    builderResult.hasRngRequest = true
                }
            }
            public func getRngRequestBuilder() -> Xla.RngRequest.Builder {
                if rngRequestBuilder_ == nil {
                    rngRequestBuilder_ = Xla.RngRequest.Builder()
                    builderResult.rngRequest = rngRequestBuilder_.getMessage()
                    if rngRequest != nil {
                        try! rngRequestBuilder_.mergeFrom(other: rngRequest)
                    }
                }
                return rngRequestBuilder_
            }
            @discardableResult
            public func setRngRequest(_ value:Xla.RngRequest!) -> Xla.OpRequest.Builder {
                self.rngRequest = value
                return self
            }
            @discardableResult
            public func mergeRngRequest(value:Xla.RngRequest) throws -> Xla.OpRequest.Builder {
                if builderResult.hasRngRequest {
                    builderResult.rngRequest = try Xla.RngRequest.builderWithPrototype(prototype:builderResult.rngRequest).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.rngRequest = value
                }
                builderResult.hasRngRequest = true
                return self
            }
            @discardableResult
            public func clearRngRequest() -> Xla.OpRequest.Builder {
                rngRequestBuilder_ = nil
                builderResult.hasRngRequest = false
                builderResult.rngRequest = nil
                return self
            }
            public var selectAndScatterRequest:Xla.SelectAndScatterRequest! {
                get {
                    if selectAndScatterRequestBuilder_ != nil {
                        builderResult.selectAndScatterRequest = selectAndScatterRequestBuilder_.getMessage()
                    }
                    return builderResult.selectAndScatterRequest
                }
                set (value) {
                    builderResult.hasSelectAndScatterRequest = true
                    builderResult.selectAndScatterRequest = value
                }
            }
            public var hasSelectAndScatterRequest:Bool {
                get {
                    return builderResult.hasSelectAndScatterRequest
                }
            }
            fileprivate var selectAndScatterRequestBuilder_:Xla.SelectAndScatterRequest.Builder! {
                didSet {
                    builderResult.hasSelectAndScatterRequest = true
                }
            }
            public func getSelectAndScatterRequestBuilder() -> Xla.SelectAndScatterRequest.Builder {
                if selectAndScatterRequestBuilder_ == nil {
                    selectAndScatterRequestBuilder_ = Xla.SelectAndScatterRequest.Builder()
                    builderResult.selectAndScatterRequest = selectAndScatterRequestBuilder_.getMessage()
                    if selectAndScatterRequest != nil {
                        try! selectAndScatterRequestBuilder_.mergeFrom(other: selectAndScatterRequest)
                    }
                }
                return selectAndScatterRequestBuilder_
            }
            @discardableResult
            public func setSelectAndScatterRequest(_ value:Xla.SelectAndScatterRequest!) -> Xla.OpRequest.Builder {
                self.selectAndScatterRequest = value
                return self
            }
            @discardableResult
            public func mergeSelectAndScatterRequest(value:Xla.SelectAndScatterRequest) throws -> Xla.OpRequest.Builder {
                if builderResult.hasSelectAndScatterRequest {
                    builderResult.selectAndScatterRequest = try Xla.SelectAndScatterRequest.builderWithPrototype(prototype:builderResult.selectAndScatterRequest).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.selectAndScatterRequest = value
                }
                builderResult.hasSelectAndScatterRequest = true
                return self
            }
            @discardableResult
            public func clearSelectAndScatterRequest() -> Xla.OpRequest.Builder {
                selectAndScatterRequestBuilder_ = nil
                builderResult.hasSelectAndScatterRequest = false
                builderResult.selectAndScatterRequest = nil
                return self
            }
            public var sliceRequest:Xla.SliceRequest! {
                get {
                    if sliceRequestBuilder_ != nil {
                        builderResult.sliceRequest = sliceRequestBuilder_.getMessage()
                    }
                    return builderResult.sliceRequest
                }
                set (value) {
                    builderResult.hasSliceRequest = true
                    builderResult.sliceRequest = value
                }
            }
            public var hasSliceRequest:Bool {
                get {
                    return builderResult.hasSliceRequest
                }
            }
            fileprivate var sliceRequestBuilder_:Xla.SliceRequest.Builder! {
                didSet {
                    builderResult.hasSliceRequest = true
                }
            }
            public func getSliceRequestBuilder() -> Xla.SliceRequest.Builder {
                if sliceRequestBuilder_ == nil {
                    sliceRequestBuilder_ = Xla.SliceRequest.Builder()
                    builderResult.sliceRequest = sliceRequestBuilder_.getMessage()
                    if sliceRequest != nil {
                        try! sliceRequestBuilder_.mergeFrom(other: sliceRequest)
                    }
                }
                return sliceRequestBuilder_
            }
            @discardableResult
            public func setSliceRequest(_ value:Xla.SliceRequest!) -> Xla.OpRequest.Builder {
                self.sliceRequest = value
                return self
            }
            @discardableResult
            public func mergeSliceRequest(value:Xla.SliceRequest) throws -> Xla.OpRequest.Builder {
                if builderResult.hasSliceRequest {
                    builderResult.sliceRequest = try Xla.SliceRequest.builderWithPrototype(prototype:builderResult.sliceRequest).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.sliceRequest = value
                }
                builderResult.hasSliceRequest = true
                return self
            }
            @discardableResult
            public func clearSliceRequest() -> Xla.OpRequest.Builder {
                sliceRequestBuilder_ = nil
                builderResult.hasSliceRequest = false
                builderResult.sliceRequest = nil
                return self
            }
            public var ternaryOpRequest:Xla.TernaryOpRequest! {
                get {
                    if ternaryOpRequestBuilder_ != nil {
                        builderResult.ternaryOpRequest = ternaryOpRequestBuilder_.getMessage()
                    }
                    return builderResult.ternaryOpRequest
                }
                set (value) {
                    builderResult.hasTernaryOpRequest = true
                    builderResult.ternaryOpRequest = value
                }
            }
            public var hasTernaryOpRequest:Bool {
                get {
                    return builderResult.hasTernaryOpRequest
                }
            }
            fileprivate var ternaryOpRequestBuilder_:Xla.TernaryOpRequest.Builder! {
                didSet {
                    builderResult.hasTernaryOpRequest = true
                }
            }
            public func getTernaryOpRequestBuilder() -> Xla.TernaryOpRequest.Builder {
                if ternaryOpRequestBuilder_ == nil {
                    ternaryOpRequestBuilder_ = Xla.TernaryOpRequest.Builder()
                    builderResult.ternaryOpRequest = ternaryOpRequestBuilder_.getMessage()
                    if ternaryOpRequest != nil {
                        try! ternaryOpRequestBuilder_.mergeFrom(other: ternaryOpRequest)
                    }
                }
                return ternaryOpRequestBuilder_
            }
            @discardableResult
            public func setTernaryOpRequest(_ value:Xla.TernaryOpRequest!) -> Xla.OpRequest.Builder {
                self.ternaryOpRequest = value
                return self
            }
            @discardableResult
            public func mergeTernaryOpRequest(value:Xla.TernaryOpRequest) throws -> Xla.OpRequest.Builder {
                if builderResult.hasTernaryOpRequest {
                    builderResult.ternaryOpRequest = try Xla.TernaryOpRequest.builderWithPrototype(prototype:builderResult.ternaryOpRequest).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.ternaryOpRequest = value
                }
                builderResult.hasTernaryOpRequest = true
                return self
            }
            @discardableResult
            public func clearTernaryOpRequest() -> Xla.OpRequest.Builder {
                ternaryOpRequestBuilder_ = nil
                builderResult.hasTernaryOpRequest = false
                builderResult.ternaryOpRequest = nil
                return self
            }
            public var traceRequest:Xla.TraceRequest! {
                get {
                    if traceRequestBuilder_ != nil {
                        builderResult.traceRequest = traceRequestBuilder_.getMessage()
                    }
                    return builderResult.traceRequest
                }
                set (value) {
                    builderResult.hasTraceRequest = true
                    builderResult.traceRequest = value
                }
            }
            public var hasTraceRequest:Bool {
                get {
                    return builderResult.hasTraceRequest
                }
            }
            fileprivate var traceRequestBuilder_:Xla.TraceRequest.Builder! {
                didSet {
                    builderResult.hasTraceRequest = true
                }
            }
            public func getTraceRequestBuilder() -> Xla.TraceRequest.Builder {
                if traceRequestBuilder_ == nil {
                    traceRequestBuilder_ = Xla.TraceRequest.Builder()
                    builderResult.traceRequest = traceRequestBuilder_.getMessage()
                    if traceRequest != nil {
                        try! traceRequestBuilder_.mergeFrom(other: traceRequest)
                    }
                }
                return traceRequestBuilder_
            }
            @discardableResult
            public func setTraceRequest(_ value:Xla.TraceRequest!) -> Xla.OpRequest.Builder {
                self.traceRequest = value
                return self
            }
            @discardableResult
            public func mergeTraceRequest(value:Xla.TraceRequest) throws -> Xla.OpRequest.Builder {
                if builderResult.hasTraceRequest {
                    builderResult.traceRequest = try Xla.TraceRequest.builderWithPrototype(prototype:builderResult.traceRequest).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.traceRequest = value
                }
                builderResult.hasTraceRequest = true
                return self
            }
            @discardableResult
            public func clearTraceRequest() -> Xla.OpRequest.Builder {
                traceRequestBuilder_ = nil
                builderResult.hasTraceRequest = false
                builderResult.traceRequest = nil
                return self
            }
            public var transposeRequest:Xla.TransposeRequest! {
                get {
                    if transposeRequestBuilder_ != nil {
                        builderResult.transposeRequest = transposeRequestBuilder_.getMessage()
                    }
                    return builderResult.transposeRequest
                }
                set (value) {
                    builderResult.hasTransposeRequest = true
                    builderResult.transposeRequest = value
                }
            }
            public var hasTransposeRequest:Bool {
                get {
                    return builderResult.hasTransposeRequest
                }
            }
            fileprivate var transposeRequestBuilder_:Xla.TransposeRequest.Builder! {
                didSet {
                    builderResult.hasTransposeRequest = true
                }
            }
            public func getTransposeRequestBuilder() -> Xla.TransposeRequest.Builder {
                if transposeRequestBuilder_ == nil {
                    transposeRequestBuilder_ = Xla.TransposeRequest.Builder()
                    builderResult.transposeRequest = transposeRequestBuilder_.getMessage()
                    if transposeRequest != nil {
                        try! transposeRequestBuilder_.mergeFrom(other: transposeRequest)
                    }
                }
                return transposeRequestBuilder_
            }
            @discardableResult
            public func setTransposeRequest(_ value:Xla.TransposeRequest!) -> Xla.OpRequest.Builder {
                self.transposeRequest = value
                return self
            }
            @discardableResult
            public func mergeTransposeRequest(value:Xla.TransposeRequest) throws -> Xla.OpRequest.Builder {
                if builderResult.hasTransposeRequest {
                    builderResult.transposeRequest = try Xla.TransposeRequest.builderWithPrototype(prototype:builderResult.transposeRequest).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.transposeRequest = value
                }
                builderResult.hasTransposeRequest = true
                return self
            }
            @discardableResult
            public func clearTransposeRequest() -> Xla.OpRequest.Builder {
                transposeRequestBuilder_ = nil
                builderResult.hasTransposeRequest = false
                builderResult.transposeRequest = nil
                return self
            }
            public var unaryOpRequest:Xla.UnaryOpRequest! {
                get {
                    if unaryOpRequestBuilder_ != nil {
                        builderResult.unaryOpRequest = unaryOpRequestBuilder_.getMessage()
                    }
                    return builderResult.unaryOpRequest
                }
                set (value) {
                    builderResult.hasUnaryOpRequest = true
                    builderResult.unaryOpRequest = value
                }
            }
            public var hasUnaryOpRequest:Bool {
                get {
                    return builderResult.hasUnaryOpRequest
                }
            }
            fileprivate var unaryOpRequestBuilder_:Xla.UnaryOpRequest.Builder! {
                didSet {
                    builderResult.hasUnaryOpRequest = true
                }
            }
            public func getUnaryOpRequestBuilder() -> Xla.UnaryOpRequest.Builder {
                if unaryOpRequestBuilder_ == nil {
                    unaryOpRequestBuilder_ = Xla.UnaryOpRequest.Builder()
                    builderResult.unaryOpRequest = unaryOpRequestBuilder_.getMessage()
                    if unaryOpRequest != nil {
                        try! unaryOpRequestBuilder_.mergeFrom(other: unaryOpRequest)
                    }
                }
                return unaryOpRequestBuilder_
            }
            @discardableResult
            public func setUnaryOpRequest(_ value:Xla.UnaryOpRequest!) -> Xla.OpRequest.Builder {
                self.unaryOpRequest = value
                return self
            }
            @discardableResult
            public func mergeUnaryOpRequest(value:Xla.UnaryOpRequest) throws -> Xla.OpRequest.Builder {
                if builderResult.hasUnaryOpRequest {
                    builderResult.unaryOpRequest = try Xla.UnaryOpRequest.builderWithPrototype(prototype:builderResult.unaryOpRequest).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.unaryOpRequest = value
                }
                builderResult.hasUnaryOpRequest = true
                return self
            }
            @discardableResult
            public func clearUnaryOpRequest() -> Xla.OpRequest.Builder {
                unaryOpRequestBuilder_ = nil
                builderResult.hasUnaryOpRequest = false
                builderResult.unaryOpRequest = nil
                return self
            }
            public var variadicOpRequest:Xla.VariadicOpRequest! {
                get {
                    if variadicOpRequestBuilder_ != nil {
                        builderResult.variadicOpRequest = variadicOpRequestBuilder_.getMessage()
                    }
                    return builderResult.variadicOpRequest
                }
                set (value) {
                    builderResult.hasVariadicOpRequest = true
                    builderResult.variadicOpRequest = value
                }
            }
            public var hasVariadicOpRequest:Bool {
                get {
                    return builderResult.hasVariadicOpRequest
                }
            }
            fileprivate var variadicOpRequestBuilder_:Xla.VariadicOpRequest.Builder! {
                didSet {
                    builderResult.hasVariadicOpRequest = true
                }
            }
            public func getVariadicOpRequestBuilder() -> Xla.VariadicOpRequest.Builder {
                if variadicOpRequestBuilder_ == nil {
                    variadicOpRequestBuilder_ = Xla.VariadicOpRequest.Builder()
                    builderResult.variadicOpRequest = variadicOpRequestBuilder_.getMessage()
                    if variadicOpRequest != nil {
                        try! variadicOpRequestBuilder_.mergeFrom(other: variadicOpRequest)
                    }
                }
                return variadicOpRequestBuilder_
            }
            @discardableResult
            public func setVariadicOpRequest(_ value:Xla.VariadicOpRequest!) -> Xla.OpRequest.Builder {
                self.variadicOpRequest = value
                return self
            }
            @discardableResult
            public func mergeVariadicOpRequest(value:Xla.VariadicOpRequest) throws -> Xla.OpRequest.Builder {
                if builderResult.hasVariadicOpRequest {
                    builderResult.variadicOpRequest = try Xla.VariadicOpRequest.builderWithPrototype(prototype:builderResult.variadicOpRequest).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.variadicOpRequest = value
                }
                builderResult.hasVariadicOpRequest = true
                return self
            }
            @discardableResult
            public func clearVariadicOpRequest() -> Xla.OpRequest.Builder {
                variadicOpRequestBuilder_ = nil
                builderResult.hasVariadicOpRequest = false
                builderResult.variadicOpRequest = nil
                return self
            }
            public var whileRequest:Xla.WhileRequest! {
                get {
                    if whileRequestBuilder_ != nil {
                        builderResult.whileRequest = whileRequestBuilder_.getMessage()
                    }
                    return builderResult.whileRequest
                }
                set (value) {
                    builderResult.hasWhileRequest = true
                    builderResult.whileRequest = value
                }
            }
            public var hasWhileRequest:Bool {
                get {
                    return builderResult.hasWhileRequest
                }
            }
            fileprivate var whileRequestBuilder_:Xla.WhileRequest.Builder! {
                didSet {
                    builderResult.hasWhileRequest = true
                }
            }
            public func getWhileRequestBuilder() -> Xla.WhileRequest.Builder {
                if whileRequestBuilder_ == nil {
                    whileRequestBuilder_ = Xla.WhileRequest.Builder()
                    builderResult.whileRequest = whileRequestBuilder_.getMessage()
                    if whileRequest != nil {
                        try! whileRequestBuilder_.mergeFrom(other: whileRequest)
                    }
                }
                return whileRequestBuilder_
            }
            @discardableResult
            public func setWhileRequest(_ value:Xla.WhileRequest!) -> Xla.OpRequest.Builder {
                self.whileRequest = value
                return self
            }
            @discardableResult
            public func mergeWhileRequest(value:Xla.WhileRequest) throws -> Xla.OpRequest.Builder {
                if builderResult.hasWhileRequest {
                    builderResult.whileRequest = try Xla.WhileRequest.builderWithPrototype(prototype:builderResult.whileRequest).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.whileRequest = value
                }
                builderResult.hasWhileRequest = true
                return self
            }
            @discardableResult
            public func clearWhileRequest() -> Xla.OpRequest.Builder {
                whileRequestBuilder_ = nil
                builderResult.hasWhileRequest = false
                builderResult.whileRequest = nil
                return self
            }
            public var sendRequest:Xla.SendRequest! {
                get {
                    if sendRequestBuilder_ != nil {
                        builderResult.sendRequest = sendRequestBuilder_.getMessage()
                    }
                    return builderResult.sendRequest
                }
                set (value) {
                    builderResult.hasSendRequest = true
                    builderResult.sendRequest = value
                }
            }
            public var hasSendRequest:Bool {
                get {
                    return builderResult.hasSendRequest
                }
            }
            fileprivate var sendRequestBuilder_:Xla.SendRequest.Builder! {
                didSet {
                    builderResult.hasSendRequest = true
                }
            }
            public func getSendRequestBuilder() -> Xla.SendRequest.Builder {
                if sendRequestBuilder_ == nil {
                    sendRequestBuilder_ = Xla.SendRequest.Builder()
                    builderResult.sendRequest = sendRequestBuilder_.getMessage()
                    if sendRequest != nil {
                        try! sendRequestBuilder_.mergeFrom(other: sendRequest)
                    }
                }
                return sendRequestBuilder_
            }
            @discardableResult
            public func setSendRequest(_ value:Xla.SendRequest!) -> Xla.OpRequest.Builder {
                self.sendRequest = value
                return self
            }
            @discardableResult
            public func mergeSendRequest(value:Xla.SendRequest) throws -> Xla.OpRequest.Builder {
                if builderResult.hasSendRequest {
                    builderResult.sendRequest = try Xla.SendRequest.builderWithPrototype(prototype:builderResult.sendRequest).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.sendRequest = value
                }
                builderResult.hasSendRequest = true
                return self
            }
            @discardableResult
            public func clearSendRequest() -> Xla.OpRequest.Builder {
                sendRequestBuilder_ = nil
                builderResult.hasSendRequest = false
                builderResult.sendRequest = nil
                return self
            }
            public var recvRequest:Xla.RecvRequest! {
                get {
                    if recvRequestBuilder_ != nil {
                        builderResult.recvRequest = recvRequestBuilder_.getMessage()
                    }
                    return builderResult.recvRequest
                }
                set (value) {
                    builderResult.hasRecvRequest = true
                    builderResult.recvRequest = value
                }
            }
            public var hasRecvRequest:Bool {
                get {
                    return builderResult.hasRecvRequest
                }
            }
            fileprivate var recvRequestBuilder_:Xla.RecvRequest.Builder! {
                didSet {
                    builderResult.hasRecvRequest = true
                }
            }
            public func getRecvRequestBuilder() -> Xla.RecvRequest.Builder {
                if recvRequestBuilder_ == nil {
                    recvRequestBuilder_ = Xla.RecvRequest.Builder()
                    builderResult.recvRequest = recvRequestBuilder_.getMessage()
                    if recvRequest != nil {
                        try! recvRequestBuilder_.mergeFrom(other: recvRequest)
                    }
                }
                return recvRequestBuilder_
            }
            @discardableResult
            public func setRecvRequest(_ value:Xla.RecvRequest!) -> Xla.OpRequest.Builder {
                self.recvRequest = value
                return self
            }
            @discardableResult
            public func mergeRecvRequest(value:Xla.RecvRequest) throws -> Xla.OpRequest.Builder {
                if builderResult.hasRecvRequest {
                    builderResult.recvRequest = try Xla.RecvRequest.builderWithPrototype(prototype:builderResult.recvRequest).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.recvRequest = value
                }
                builderResult.hasRecvRequest = true
                return self
            }
            @discardableResult
            public func clearRecvRequest() -> Xla.OpRequest.Builder {
                recvRequestBuilder_ = nil
                builderResult.hasRecvRequest = false
                builderResult.recvRequest = nil
                return self
            }
            /// Next: 35
            public var outfeedRequest:Xla.OutfeedRequest! {
                get {
                    if outfeedRequestBuilder_ != nil {
                        builderResult.outfeedRequest = outfeedRequestBuilder_.getMessage()
                    }
                    return builderResult.outfeedRequest
                }
                set (value) {
                    builderResult.hasOutfeedRequest = true
                    builderResult.outfeedRequest = value
                }
            }
            public var hasOutfeedRequest:Bool {
                get {
                    return builderResult.hasOutfeedRequest
                }
            }
            fileprivate var outfeedRequestBuilder_:Xla.OutfeedRequest.Builder! {
                didSet {
                    builderResult.hasOutfeedRequest = true
                }
            }
            public func getOutfeedRequestBuilder() -> Xla.OutfeedRequest.Builder {
                if outfeedRequestBuilder_ == nil {
                    outfeedRequestBuilder_ = Xla.OutfeedRequest.Builder()
                    builderResult.outfeedRequest = outfeedRequestBuilder_.getMessage()
                    if outfeedRequest != nil {
                        try! outfeedRequestBuilder_.mergeFrom(other: outfeedRequest)
                    }
                }
                return outfeedRequestBuilder_
            }
            @discardableResult
            public func setOutfeedRequest(_ value:Xla.OutfeedRequest!) -> Xla.OpRequest.Builder {
                self.outfeedRequest = value
                return self
            }
            @discardableResult
            public func mergeOutfeedRequest(value:Xla.OutfeedRequest) throws -> Xla.OpRequest.Builder {
                if builderResult.hasOutfeedRequest {
                    builderResult.outfeedRequest = try Xla.OutfeedRequest.builderWithPrototype(prototype:builderResult.outfeedRequest).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.outfeedRequest = value
                }
                builderResult.hasOutfeedRequest = true
                return self
            }
            @discardableResult
            public func clearOutfeedRequest() -> Xla.OpRequest.Builder {
                outfeedRequestBuilder_ = nil
                builderResult.hasOutfeedRequest = false
                builderResult.outfeedRequest = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.OpRequest.Builder {
                builderResult = Xla.OpRequest()
                return self
            }
            override public func clone() throws -> Xla.OpRequest.Builder {
                return try Xla.OpRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.OpRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.OpRequest {
                let returnMe:Xla.OpRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.OpRequest) throws -> Xla.OpRequest.Builder {
                if other == Xla.OpRequest() {
                    return self
                }
                if (other.hasComputation) {
                    try mergeComputation(value: other.computation)
                }
                if (other.hasMetadata) {
                    try mergeMetadata(value: other.metadata)
                }
                if (other.hasBinaryOpRequest) {
                    try mergeBinaryOpRequest(value: other.binaryOpRequest)
                }
                if (other.hasBroadcastRequest) {
                    try mergeBroadcastRequest(value: other.broadcastRequest)
                }
                if (other.hasCallRequest) {
                    try mergeCallRequest(value: other.callRequest)
                }
                if (other.hasConcatenateRequest) {
                    try mergeConcatenateRequest(value: other.concatenateRequest)
                }
                if (other.hasConstantRequest) {
                    try mergeConstantRequest(value: other.constantRequest)
                }
                if (other.hasConvertRequest) {
                    try mergeConvertRequest(value: other.convertRequest)
                }
                if (other.hasConvolveRequest) {
                    try mergeConvolveRequest(value: other.convolveRequest)
                }
                if (other.hasCrossReplicaSumRequest) {
                    try mergeCrossReplicaSumRequest(value: other.crossReplicaSumRequest)
                }
                if (other.hasCustomCallRequest) {
                    try mergeCustomCallRequest(value: other.customCallRequest)
                }
                if (other.hasDynamicSliceRequest) {
                    try mergeDynamicSliceRequest(value: other.dynamicSliceRequest)
                }
                if (other.hasDynamicUpdateSliceRequest) {
                    try mergeDynamicUpdateSliceRequest(value: other.dynamicUpdateSliceRequest)
                }
                if (other.hasGetTupleElementRequest) {
                    try mergeGetTupleElementRequest(value: other.getTupleElementRequest)
                }
                if (other.hasInfeedRequest) {
                    try mergeInfeedRequest(value: other.infeedRequest)
                }
                if (other.hasMapRequest) {
                    try mergeMapRequest(value: other.mapRequest)
                }
                if (other.hasPadRequest) {
                    try mergePadRequest(value: other.padRequest)
                }
                if (other.hasParameterRequest) {
                    try mergeParameterRequest(value: other.parameterRequest)
                }
                if (other.hasReduceRequest) {
                    try mergeReduceRequest(value: other.reduceRequest)
                }
                if (other.hasReduceWindowRequest) {
                    try mergeReduceWindowRequest(value: other.reduceWindowRequest)
                }
                if (other.hasReshapeRequest) {
                    try mergeReshapeRequest(value: other.reshapeRequest)
                }
                if (other.hasReverseRequest) {
                    try mergeReverseRequest(value: other.reverseRequest)
                }
                if (other.hasRngRequest) {
                    try mergeRngRequest(value: other.rngRequest)
                }
                if (other.hasSelectAndScatterRequest) {
                    try mergeSelectAndScatterRequest(value: other.selectAndScatterRequest)
                }
                if (other.hasSliceRequest) {
                    try mergeSliceRequest(value: other.sliceRequest)
                }
                if (other.hasTernaryOpRequest) {
                    try mergeTernaryOpRequest(value: other.ternaryOpRequest)
                }
                if (other.hasTraceRequest) {
                    try mergeTraceRequest(value: other.traceRequest)
                }
                if (other.hasTransposeRequest) {
                    try mergeTransposeRequest(value: other.transposeRequest)
                }
                if (other.hasUnaryOpRequest) {
                    try mergeUnaryOpRequest(value: other.unaryOpRequest)
                }
                if (other.hasVariadicOpRequest) {
                    try mergeVariadicOpRequest(value: other.variadicOpRequest)
                }
                if (other.hasWhileRequest) {
                    try mergeWhileRequest(value: other.whileRequest)
                }
                if (other.hasSendRequest) {
                    try mergeSendRequest(value: other.sendRequest)
                }
                if (other.hasRecvRequest) {
                    try mergeRecvRequest(value: other.recvRequest)
                }
                if (other.hasOutfeedRequest) {
                    try mergeOutfeedRequest(value: other.outfeedRequest)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.OpRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.OpRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.ComputationHandle.Builder = Xla.ComputationHandle.Builder()
                        if hasComputation {
                            try subBuilder.mergeFrom(other: computation)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        computation = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Xla.BinaryOpRequest.Builder = Xla.BinaryOpRequest.Builder()
                        if hasBinaryOpRequest {
                            try subBuilder.mergeFrom(other: binaryOpRequest)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        binaryOpRequest = subBuilder.buildPartial()

                    case 26:
                        let subBuilder:Xla.BroadcastRequest.Builder = Xla.BroadcastRequest.Builder()
                        if hasBroadcastRequest {
                            try subBuilder.mergeFrom(other: broadcastRequest)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        broadcastRequest = subBuilder.buildPartial()

                    case 34:
                        let subBuilder:Xla.CallRequest.Builder = Xla.CallRequest.Builder()
                        if hasCallRequest {
                            try subBuilder.mergeFrom(other: callRequest)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        callRequest = subBuilder.buildPartial()

                    case 42:
                        let subBuilder:Xla.ConcatenateRequest.Builder = Xla.ConcatenateRequest.Builder()
                        if hasConcatenateRequest {
                            try subBuilder.mergeFrom(other: concatenateRequest)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        concatenateRequest = subBuilder.buildPartial()

                    case 50:
                        let subBuilder:Xla.ConstantRequest.Builder = Xla.ConstantRequest.Builder()
                        if hasConstantRequest {
                            try subBuilder.mergeFrom(other: constantRequest)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        constantRequest = subBuilder.buildPartial()

                    case 58:
                        let subBuilder:Xla.ConvertRequest.Builder = Xla.ConvertRequest.Builder()
                        if hasConvertRequest {
                            try subBuilder.mergeFrom(other: convertRequest)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        convertRequest = subBuilder.buildPartial()

                    case 66:
                        let subBuilder:Xla.ConvolveRequest.Builder = Xla.ConvolveRequest.Builder()
                        if hasConvolveRequest {
                            try subBuilder.mergeFrom(other: convolveRequest)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        convolveRequest = subBuilder.buildPartial()

                    case 74:
                        let subBuilder:Xla.CrossReplicaSumRequest.Builder = Xla.CrossReplicaSumRequest.Builder()
                        if hasCrossReplicaSumRequest {
                            try subBuilder.mergeFrom(other: crossReplicaSumRequest)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        crossReplicaSumRequest = subBuilder.buildPartial()

                    case 82:
                        let subBuilder:Xla.CustomCallRequest.Builder = Xla.CustomCallRequest.Builder()
                        if hasCustomCallRequest {
                            try subBuilder.mergeFrom(other: customCallRequest)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        customCallRequest = subBuilder.buildPartial()

                    case 90:
                        let subBuilder:Xla.DynamicSliceRequest.Builder = Xla.DynamicSliceRequest.Builder()
                        if hasDynamicSliceRequest {
                            try subBuilder.mergeFrom(other: dynamicSliceRequest)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        dynamicSliceRequest = subBuilder.buildPartial()

                    case 98:
                        let subBuilder:Xla.DynamicUpdateSliceRequest.Builder = Xla.DynamicUpdateSliceRequest.Builder()
                        if hasDynamicUpdateSliceRequest {
                            try subBuilder.mergeFrom(other: dynamicUpdateSliceRequest)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        dynamicUpdateSliceRequest = subBuilder.buildPartial()

                    case 106:
                        let subBuilder:Xla.GetTupleElementRequest.Builder = Xla.GetTupleElementRequest.Builder()
                        if hasGetTupleElementRequest {
                            try subBuilder.mergeFrom(other: getTupleElementRequest)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        getTupleElementRequest = subBuilder.buildPartial()

                    case 114:
                        let subBuilder:Xla.InfeedRequest.Builder = Xla.InfeedRequest.Builder()
                        if hasInfeedRequest {
                            try subBuilder.mergeFrom(other: infeedRequest)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        infeedRequest = subBuilder.buildPartial()

                    case 122:
                        let subBuilder:Xla.MapRequest.Builder = Xla.MapRequest.Builder()
                        if hasMapRequest {
                            try subBuilder.mergeFrom(other: mapRequest)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        mapRequest = subBuilder.buildPartial()

                    case 130:
                        let subBuilder:Xla.PadRequest.Builder = Xla.PadRequest.Builder()
                        if hasPadRequest {
                            try subBuilder.mergeFrom(other: padRequest)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        padRequest = subBuilder.buildPartial()

                    case 138:
                        let subBuilder:Xla.ParameterRequest.Builder = Xla.ParameterRequest.Builder()
                        if hasParameterRequest {
                            try subBuilder.mergeFrom(other: parameterRequest)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        parameterRequest = subBuilder.buildPartial()

                    case 146:
                        let subBuilder:Xla.ReduceRequest.Builder = Xla.ReduceRequest.Builder()
                        if hasReduceRequest {
                            try subBuilder.mergeFrom(other: reduceRequest)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        reduceRequest = subBuilder.buildPartial()

                    case 154:
                        let subBuilder:Xla.ReduceWindowRequest.Builder = Xla.ReduceWindowRequest.Builder()
                        if hasReduceWindowRequest {
                            try subBuilder.mergeFrom(other: reduceWindowRequest)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        reduceWindowRequest = subBuilder.buildPartial()

                    case 162:
                        let subBuilder:Xla.ReshapeRequest.Builder = Xla.ReshapeRequest.Builder()
                        if hasReshapeRequest {
                            try subBuilder.mergeFrom(other: reshapeRequest)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        reshapeRequest = subBuilder.buildPartial()

                    case 170:
                        let subBuilder:Xla.ReverseRequest.Builder = Xla.ReverseRequest.Builder()
                        if hasReverseRequest {
                            try subBuilder.mergeFrom(other: reverseRequest)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        reverseRequest = subBuilder.buildPartial()

                    case 178:
                        let subBuilder:Xla.RngRequest.Builder = Xla.RngRequest.Builder()
                        if hasRngRequest {
                            try subBuilder.mergeFrom(other: rngRequest)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        rngRequest = subBuilder.buildPartial()

                    case 186:
                        let subBuilder:Xla.SelectAndScatterRequest.Builder = Xla.SelectAndScatterRequest.Builder()
                        if hasSelectAndScatterRequest {
                            try subBuilder.mergeFrom(other: selectAndScatterRequest)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        selectAndScatterRequest = subBuilder.buildPartial()

                    case 194:
                        let subBuilder:Xla.SliceRequest.Builder = Xla.SliceRequest.Builder()
                        if hasSliceRequest {
                            try subBuilder.mergeFrom(other: sliceRequest)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        sliceRequest = subBuilder.buildPartial()

                    case 202:
                        let subBuilder:Xla.TernaryOpRequest.Builder = Xla.TernaryOpRequest.Builder()
                        if hasTernaryOpRequest {
                            try subBuilder.mergeFrom(other: ternaryOpRequest)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        ternaryOpRequest = subBuilder.buildPartial()

                    case 210:
                        let subBuilder:Xla.TraceRequest.Builder = Xla.TraceRequest.Builder()
                        if hasTraceRequest {
                            try subBuilder.mergeFrom(other: traceRequest)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        traceRequest = subBuilder.buildPartial()

                    case 218:
                        let subBuilder:Xla.UnaryOpRequest.Builder = Xla.UnaryOpRequest.Builder()
                        if hasUnaryOpRequest {
                            try subBuilder.mergeFrom(other: unaryOpRequest)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        unaryOpRequest = subBuilder.buildPartial()

                    case 226:
                        let subBuilder:Xla.VariadicOpRequest.Builder = Xla.VariadicOpRequest.Builder()
                        if hasVariadicOpRequest {
                            try subBuilder.mergeFrom(other: variadicOpRequest)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        variadicOpRequest = subBuilder.buildPartial()

                    case 234:
                        let subBuilder:Xla.WhileRequest.Builder = Xla.WhileRequest.Builder()
                        if hasWhileRequest {
                            try subBuilder.mergeFrom(other: whileRequest)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        whileRequest = subBuilder.buildPartial()

                    case 242:
                        let subBuilder:Xla.SendRequest.Builder = Xla.SendRequest.Builder()
                        if hasSendRequest {
                            try subBuilder.mergeFrom(other: sendRequest)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        sendRequest = subBuilder.buildPartial()

                    case 250:
                        let subBuilder:Xla.RecvRequest.Builder = Xla.RecvRequest.Builder()
                        if hasRecvRequest {
                            try subBuilder.mergeFrom(other: recvRequest)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        recvRequest = subBuilder.buildPartial()

                    case 258:
                        let subBuilder:Xla.OutfeedRequest.Builder = Xla.OutfeedRequest.Builder()
                        if hasOutfeedRequest {
                            try subBuilder.mergeFrom(other: outfeedRequest)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        outfeedRequest = subBuilder.buildPartial()

                    case 266:
                        let subBuilder:Xla.OpMetadata.Builder = Xla.OpMetadata.Builder()
                        if hasMetadata {
                            try subBuilder.mergeFrom(other: metadata)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        metadata = subBuilder.buildPartial()

                    case 274:
                        let subBuilder:Xla.TransposeRequest.Builder = Xla.TransposeRequest.Builder()
                        if hasTransposeRequest {
                            try subBuilder.mergeFrom(other: transposeRequest)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        transposeRequest = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.OpRequest.Builder {
                let resultDecodedBuilder = Xla.OpRequest.Builder()
                if let jsonValueComputation = jsonMap["computation"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.computation = try Xla.ComputationHandle.Builder.decodeToBuilder(jsonMap:jsonValueComputation).build()

                }
                if let jsonValueMetadata = jsonMap["metadata"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.metadata = try Xla.OpMetadata.Builder.decodeToBuilder(jsonMap:jsonValueMetadata).build()

                }
                if let jsonValueBinaryOpRequest = jsonMap["binaryOpRequest"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.binaryOpRequest = try Xla.BinaryOpRequest.Builder.decodeToBuilder(jsonMap:jsonValueBinaryOpRequest).build()

                }
                if let jsonValueBroadcastRequest = jsonMap["broadcastRequest"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.broadcastRequest = try Xla.BroadcastRequest.Builder.decodeToBuilder(jsonMap:jsonValueBroadcastRequest).build()

                }
                if let jsonValueCallRequest = jsonMap["callRequest"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.callRequest = try Xla.CallRequest.Builder.decodeToBuilder(jsonMap:jsonValueCallRequest).build()

                }
                if let jsonValueConcatenateRequest = jsonMap["concatenateRequest"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.concatenateRequest = try Xla.ConcatenateRequest.Builder.decodeToBuilder(jsonMap:jsonValueConcatenateRequest).build()

                }
                if let jsonValueConstantRequest = jsonMap["constantRequest"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.constantRequest = try Xla.ConstantRequest.Builder.decodeToBuilder(jsonMap:jsonValueConstantRequest).build()

                }
                if let jsonValueConvertRequest = jsonMap["convertRequest"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.convertRequest = try Xla.ConvertRequest.Builder.decodeToBuilder(jsonMap:jsonValueConvertRequest).build()

                }
                if let jsonValueConvolveRequest = jsonMap["convolveRequest"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.convolveRequest = try Xla.ConvolveRequest.Builder.decodeToBuilder(jsonMap:jsonValueConvolveRequest).build()

                }
                if let jsonValueCrossReplicaSumRequest = jsonMap["crossReplicaSumRequest"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.crossReplicaSumRequest = try Xla.CrossReplicaSumRequest.Builder.decodeToBuilder(jsonMap:jsonValueCrossReplicaSumRequest).build()

                }
                if let jsonValueCustomCallRequest = jsonMap["customCallRequest"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.customCallRequest = try Xla.CustomCallRequest.Builder.decodeToBuilder(jsonMap:jsonValueCustomCallRequest).build()

                }
                if let jsonValueDynamicSliceRequest = jsonMap["dynamicSliceRequest"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.dynamicSliceRequest = try Xla.DynamicSliceRequest.Builder.decodeToBuilder(jsonMap:jsonValueDynamicSliceRequest).build()

                }
                if let jsonValueDynamicUpdateSliceRequest = jsonMap["dynamicUpdateSliceRequest"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.dynamicUpdateSliceRequest = try Xla.DynamicUpdateSliceRequest.Builder.decodeToBuilder(jsonMap:jsonValueDynamicUpdateSliceRequest).build()

                }
                if let jsonValueGetTupleElementRequest = jsonMap["getTupleElementRequest"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.getTupleElementRequest = try Xla.GetTupleElementRequest.Builder.decodeToBuilder(jsonMap:jsonValueGetTupleElementRequest).build()

                }
                if let jsonValueInfeedRequest = jsonMap["infeedRequest"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.infeedRequest = try Xla.InfeedRequest.Builder.decodeToBuilder(jsonMap:jsonValueInfeedRequest).build()

                }
                if let jsonValueMapRequest = jsonMap["mapRequest"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.mapRequest = try Xla.MapRequest.Builder.decodeToBuilder(jsonMap:jsonValueMapRequest).build()

                }
                if let jsonValuePadRequest = jsonMap["padRequest"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.padRequest = try Xla.PadRequest.Builder.decodeToBuilder(jsonMap:jsonValuePadRequest).build()

                }
                if let jsonValueParameterRequest = jsonMap["parameterRequest"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.parameterRequest = try Xla.ParameterRequest.Builder.decodeToBuilder(jsonMap:jsonValueParameterRequest).build()

                }
                if let jsonValueReduceRequest = jsonMap["reduceRequest"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.reduceRequest = try Xla.ReduceRequest.Builder.decodeToBuilder(jsonMap:jsonValueReduceRequest).build()

                }
                if let jsonValueReduceWindowRequest = jsonMap["reduceWindowRequest"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.reduceWindowRequest = try Xla.ReduceWindowRequest.Builder.decodeToBuilder(jsonMap:jsonValueReduceWindowRequest).build()

                }
                if let jsonValueReshapeRequest = jsonMap["reshapeRequest"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.reshapeRequest = try Xla.ReshapeRequest.Builder.decodeToBuilder(jsonMap:jsonValueReshapeRequest).build()

                }
                if let jsonValueReverseRequest = jsonMap["reverseRequest"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.reverseRequest = try Xla.ReverseRequest.Builder.decodeToBuilder(jsonMap:jsonValueReverseRequest).build()

                }
                if let jsonValueRngRequest = jsonMap["rngRequest"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.rngRequest = try Xla.RngRequest.Builder.decodeToBuilder(jsonMap:jsonValueRngRequest).build()

                }
                if let jsonValueSelectAndScatterRequest = jsonMap["selectAndScatterRequest"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.selectAndScatterRequest = try Xla.SelectAndScatterRequest.Builder.decodeToBuilder(jsonMap:jsonValueSelectAndScatterRequest).build()

                }
                if let jsonValueSliceRequest = jsonMap["sliceRequest"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.sliceRequest = try Xla.SliceRequest.Builder.decodeToBuilder(jsonMap:jsonValueSliceRequest).build()

                }
                if let jsonValueTernaryOpRequest = jsonMap["ternaryOpRequest"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.ternaryOpRequest = try Xla.TernaryOpRequest.Builder.decodeToBuilder(jsonMap:jsonValueTernaryOpRequest).build()

                }
                if let jsonValueTraceRequest = jsonMap["traceRequest"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.traceRequest = try Xla.TraceRequest.Builder.decodeToBuilder(jsonMap:jsonValueTraceRequest).build()

                }
                if let jsonValueTransposeRequest = jsonMap["transposeRequest"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.transposeRequest = try Xla.TransposeRequest.Builder.decodeToBuilder(jsonMap:jsonValueTransposeRequest).build()

                }
                if let jsonValueUnaryOpRequest = jsonMap["unaryOpRequest"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.unaryOpRequest = try Xla.UnaryOpRequest.Builder.decodeToBuilder(jsonMap:jsonValueUnaryOpRequest).build()

                }
                if let jsonValueVariadicOpRequest = jsonMap["variadicOpRequest"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.variadicOpRequest = try Xla.VariadicOpRequest.Builder.decodeToBuilder(jsonMap:jsonValueVariadicOpRequest).build()

                }
                if let jsonValueWhileRequest = jsonMap["whileRequest"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.whileRequest = try Xla.WhileRequest.Builder.decodeToBuilder(jsonMap:jsonValueWhileRequest).build()

                }
                if let jsonValueSendRequest = jsonMap["sendRequest"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.sendRequest = try Xla.SendRequest.Builder.decodeToBuilder(jsonMap:jsonValueSendRequest).build()

                }
                if let jsonValueRecvRequest = jsonMap["recvRequest"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.recvRequest = try Xla.RecvRequest.Builder.decodeToBuilder(jsonMap:jsonValueRecvRequest).build()

                }
                if let jsonValueOutfeedRequest = jsonMap["outfeedRequest"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.outfeedRequest = try Xla.OutfeedRequest.Builder.decodeToBuilder(jsonMap:jsonValueOutfeedRequest).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.OpRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.OpRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class OpResponse : GeneratedMessage {

        public static func == (lhs: Xla.OpResponse, rhs: Xla.OpResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasOutput == rhs.hasOutput) && (!lhs.hasOutput || lhs.output == rhs.output)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var output:Xla.ComputationDataHandle!
        public fileprivate(set) var hasOutput:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasOutput {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:output)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasOutput {
                if let varSizeoutput = output?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeoutput
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.OpResponse.Builder {
            return Xla.OpResponse.classBuilder() as! Xla.OpResponse.Builder
        }
        public func getBuilder() -> Xla.OpResponse.Builder {
            return classBuilder() as! Xla.OpResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.OpResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.OpResponse.Builder()
        }
        public func toBuilder() throws -> Xla.OpResponse.Builder {
            return try Xla.OpResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.OpResponse) throws -> Xla.OpResponse.Builder {
            return try Xla.OpResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasOutput {
                jsonMap["output"] = try output.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.OpResponse {
            return try Xla.OpResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.OpResponse {
            return try Xla.OpResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasOutput {
                output += "\(indent) output {\n"
                if let outDescOutput = output {
                    output += try outDescOutput.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasOutput {
                    if let hashValueoutput = output?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoutput
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.OpResponse"
        }
        override public func className() -> String {
            return "Xla.OpResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.OpResponse = Xla.OpResponse()
            public func getMessage() -> Xla.OpResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var output:Xla.ComputationDataHandle! {
                get {
                    if outputBuilder_ != nil {
                        builderResult.output = outputBuilder_.getMessage()
                    }
                    return builderResult.output
                }
                set (value) {
                    builderResult.hasOutput = true
                    builderResult.output = value
                }
            }
            public var hasOutput:Bool {
                get {
                    return builderResult.hasOutput
                }
            }
            fileprivate var outputBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasOutput = true
                }
            }
            public func getOutputBuilder() -> Xla.ComputationDataHandle.Builder {
                if outputBuilder_ == nil {
                    outputBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.output = outputBuilder_.getMessage()
                    if output != nil {
                        try! outputBuilder_.mergeFrom(other: output)
                    }
                }
                return outputBuilder_
            }
            @discardableResult
            public func setOutput(_ value:Xla.ComputationDataHandle!) -> Xla.OpResponse.Builder {
                self.output = value
                return self
            }
            @discardableResult
            public func mergeOutput(value:Xla.ComputationDataHandle) throws -> Xla.OpResponse.Builder {
                if builderResult.hasOutput {
                    builderResult.output = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.output).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.output = value
                }
                builderResult.hasOutput = true
                return self
            }
            @discardableResult
            public func clearOutput() -> Xla.OpResponse.Builder {
                outputBuilder_ = nil
                builderResult.hasOutput = false
                builderResult.output = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.OpResponse.Builder {
                builderResult = Xla.OpResponse()
                return self
            }
            override public func clone() throws -> Xla.OpResponse.Builder {
                return try Xla.OpResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.OpResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.OpResponse {
                let returnMe:Xla.OpResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.OpResponse) throws -> Xla.OpResponse.Builder {
                if other == Xla.OpResponse() {
                    return self
                }
                if (other.hasOutput) {
                    try mergeOutput(value: other.output)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.OpResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.OpResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasOutput {
                            try subBuilder.mergeFrom(other: output)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        output = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.OpResponse.Builder {
                let resultDecodedBuilder = Xla.OpResponse.Builder()
                if let jsonValueOutput = jsonMap["output"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.output = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueOutput).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.OpResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.OpResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Xla.PaddingConfig: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.PaddingConfig> {
        var mergedArray = Array<Xla.PaddingConfig>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.PaddingConfig? {
        return try Xla.PaddingConfig.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.PaddingConfig {
        return try Xla.PaddingConfig.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.PaddingConfig {
        return try Xla.PaddingConfig.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.PaddingConfig {
        return try Xla.PaddingConfig.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.PaddingConfig {
        return try Xla.PaddingConfig.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.PaddingConfig {
        return try Xla.PaddingConfig.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.PaddingConfig {
        return try Xla.PaddingConfig.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "dimensions": return self.dimensions
        default: return nil
        }
    }
}
extension Xla.PaddingConfig.PaddingConfigDimension: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.PaddingConfig.PaddingConfigDimension> {
        var mergedArray = Array<Xla.PaddingConfig.PaddingConfigDimension>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.PaddingConfig.PaddingConfigDimension? {
        return try Xla.PaddingConfig.PaddingConfigDimension.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.PaddingConfig.PaddingConfigDimension {
        return try Xla.PaddingConfig.PaddingConfigDimension.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.PaddingConfig.PaddingConfigDimension {
        return try Xla.PaddingConfig.PaddingConfigDimension.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.PaddingConfig.PaddingConfigDimension {
        return try Xla.PaddingConfig.PaddingConfigDimension.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.PaddingConfig.PaddingConfigDimension {
        return try Xla.PaddingConfig.PaddingConfigDimension.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.PaddingConfig.PaddingConfigDimension {
        return try Xla.PaddingConfig.PaddingConfigDimension.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.PaddingConfig.PaddingConfigDimension {
        return try Xla.PaddingConfig.PaddingConfigDimension.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "edgePaddingLow": return self.edgePaddingLow
        case "edgePaddingHigh": return self.edgePaddingHigh
        case "interiorPadding": return self.interiorPadding
        default: return nil
        }
    }
}
extension Xla.PaddingConfig.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "dimensions": return self.dimensions
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "dimensions":
                guard let newSubscriptValue = newSubscriptValue as? Array<Xla.PaddingConfig.PaddingConfigDimension> else {
                    return
                }
                self.dimensions = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.PaddingConfig.PaddingConfigDimension.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "edgePaddingLow": return self.edgePaddingLow
            case "edgePaddingHigh": return self.edgePaddingHigh
            case "interiorPadding": return self.interiorPadding
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "edgePaddingLow":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.edgePaddingLow = newSubscriptValue
            case "edgePaddingHigh":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.edgePaddingHigh = newSubscriptValue
            case "interiorPadding":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.interiorPadding = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.Layout: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.Layout> {
        var mergedArray = Array<Xla.Layout>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.Layout? {
        return try Xla.Layout.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.Layout {
        return try Xla.Layout.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.Layout {
        return try Xla.Layout.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.Layout {
        return try Xla.Layout.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.Layout {
        return try Xla.Layout.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.Layout {
        return try Xla.Layout.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.Layout {
        return try Xla.Layout.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "minorToMajor": return self.minorToMajor
        case "paddedDimensions": return self.paddedDimensions
        case "paddingValue": return self.paddingValue
        default: return nil
        }
    }
}
extension Xla.Layout.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "minorToMajor": return self.minorToMajor
            case "paddedDimensions": return self.paddedDimensions
            case "paddingValue": return self.paddingValue
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "minorToMajor":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.minorToMajor = newSubscriptValue
            case "paddedDimensions":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.paddedDimensions = newSubscriptValue
            case "paddingValue":
                guard let newSubscriptValue = newSubscriptValue as? Xla.PaddingValue else {
                    return
                }
                self.paddingValue = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.Shape: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.Shape> {
        var mergedArray = Array<Xla.Shape>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.Shape? {
        return try Xla.Shape.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.Shape {
        return try Xla.Shape.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.Shape {
        return try Xla.Shape.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.Shape {
        return try Xla.Shape.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.Shape {
        return try Xla.Shape.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.Shape {
        return try Xla.Shape.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.Shape {
        return try Xla.Shape.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "elementType": return self.elementType
        case "dimensions": return self.dimensions
        case "tupleShapes": return self.tupleShapes
        case "layout": return self.layout
        default: return nil
        }
    }
}
extension Xla.Shape.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "elementType": return self.elementType
            case "dimensions": return self.dimensions
            case "tupleShapes": return self.tupleShapes
            case "layout": return self.layout
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "elementType":
                guard let newSubscriptValue = newSubscriptValue as? Xla.PrimitiveType else {
                    return
                }
                self.elementType = newSubscriptValue
            case "dimensions":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.dimensions = newSubscriptValue
            case "tupleShapes":
                guard let newSubscriptValue = newSubscriptValue as? Array<Xla.Shape> else {
                    return
                }
                self.tupleShapes = newSubscriptValue
            case "layout":
                guard let newSubscriptValue = newSubscriptValue as? Xla.Layout else {
                    return
                }
                self.layout = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.ProgramShape: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.ProgramShape> {
        var mergedArray = Array<Xla.ProgramShape>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.ProgramShape? {
        return try Xla.ProgramShape.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.ProgramShape {
        return try Xla.ProgramShape.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.ProgramShape {
        return try Xla.ProgramShape.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.ProgramShape {
        return try Xla.ProgramShape.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ProgramShape {
        return try Xla.ProgramShape.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.ProgramShape {
        return try Xla.ProgramShape.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ProgramShape {
        return try Xla.ProgramShape.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "parameters": return self.parameters
        case "result": return self.result
        case "parameterNames": return self.parameterNames
        default: return nil
        }
    }
}
extension Xla.ProgramShape.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "parameters": return self.parameters
            case "result": return self.result
            case "parameterNames": return self.parameterNames
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "parameters":
                guard let newSubscriptValue = newSubscriptValue as? Array<Xla.Shape> else {
                    return
                }
                self.parameters = newSubscriptValue
            case "result":
                guard let newSubscriptValue = newSubscriptValue as? Xla.Shape else {
                    return
                }
                self.result = newSubscriptValue
            case "parameterNames":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.parameterNames = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.ComputationStats: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.ComputationStats> {
        var mergedArray = Array<Xla.ComputationStats>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.ComputationStats? {
        return try Xla.ComputationStats.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.ComputationStats {
        return try Xla.ComputationStats.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputationStats {
        return try Xla.ComputationStats.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.ComputationStats {
        return try Xla.ComputationStats.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputationStats {
        return try Xla.ComputationStats.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.ComputationStats {
        return try Xla.ComputationStats.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputationStats {
        return try Xla.ComputationStats.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "flopCount": return self.flopCount
        case "transcendentalCount": return self.transcendentalCount
        default: return nil
        }
    }
}
extension Xla.ComputationStats.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "flopCount": return self.flopCount
            case "transcendentalCount": return self.transcendentalCount
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "flopCount":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.flopCount = newSubscriptValue
            case "transcendentalCount":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.transcendentalCount = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.OpMetadata: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.OpMetadata> {
        var mergedArray = Array<Xla.OpMetadata>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.OpMetadata? {
        return try Xla.OpMetadata.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.OpMetadata {
        return try Xla.OpMetadata.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.OpMetadata {
        return try Xla.OpMetadata.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.OpMetadata {
        return try Xla.OpMetadata.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.OpMetadata {
        return try Xla.OpMetadata.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.OpMetadata {
        return try Xla.OpMetadata.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.OpMetadata {
        return try Xla.OpMetadata.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "opType": return self.opType
        case "opName": return self.opName
        case "sourceFile": return self.sourceFile
        case "sourceLine": return self.sourceLine
        default: return nil
        }
    }
}
extension Xla.OpMetadata.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "opType": return self.opType
            case "opName": return self.opName
            case "sourceFile": return self.sourceFile
            case "sourceLine": return self.sourceLine
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "opType":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.opType = newSubscriptValue
            case "opName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.opName = newSubscriptValue
            case "sourceFile":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.sourceFile = newSubscriptValue
            case "sourceLine":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.sourceLine = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.ExecutionProfile: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.ExecutionProfile> {
        var mergedArray = Array<Xla.ExecutionProfile>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.ExecutionProfile? {
        return try Xla.ExecutionProfile.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.ExecutionProfile {
        return try Xla.ExecutionProfile.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecutionProfile {
        return try Xla.ExecutionProfile.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.ExecutionProfile {
        return try Xla.ExecutionProfile.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecutionProfile {
        return try Xla.ExecutionProfile.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.ExecutionProfile {
        return try Xla.ExecutionProfile.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecutionProfile {
        return try Xla.ExecutionProfile.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "compilationCacheHit": return self.compilationCacheHit
        case "compileTimeMs": return self.compileTimeMs
        case "computeCycleCount": return self.computeCycleCount
        case "computeTimeNs": return self.computeTimeNs
        case "computeAndTransferTimeNs": return self.computeAndTransferTimeNs
        default: return nil
        }
    }
}
extension Xla.ExecutionProfile.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "compilationCacheHit": return self.compilationCacheHit
            case "compileTimeMs": return self.compileTimeMs
            case "computeCycleCount": return self.computeCycleCount
            case "computeTimeNs": return self.computeTimeNs
            case "computeAndTransferTimeNs": return self.computeAndTransferTimeNs
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "compilationCacheHit":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.compilationCacheHit = newSubscriptValue
            case "compileTimeMs":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.compileTimeMs = newSubscriptValue
            case "computeCycleCount":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.computeCycleCount = newSubscriptValue
            case "computeTimeNs":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.computeTimeNs = newSubscriptValue
            case "computeAndTransferTimeNs":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.computeAndTransferTimeNs = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.ComputationHandle: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.ComputationHandle> {
        var mergedArray = Array<Xla.ComputationHandle>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.ComputationHandle? {
        return try Xla.ComputationHandle.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.ComputationHandle {
        return try Xla.ComputationHandle.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputationHandle {
        return try Xla.ComputationHandle.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.ComputationHandle {
        return try Xla.ComputationHandle.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputationHandle {
        return try Xla.ComputationHandle.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.ComputationHandle {
        return try Xla.ComputationHandle.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputationHandle {
        return try Xla.ComputationHandle.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "handle": return self.handle
        default: return nil
        }
    }
}
extension Xla.ComputationHandle.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "handle": return self.handle
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "handle":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.handle = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.ExecutionHandle: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.ExecutionHandle> {
        var mergedArray = Array<Xla.ExecutionHandle>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.ExecutionHandle? {
        return try Xla.ExecutionHandle.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.ExecutionHandle {
        return try Xla.ExecutionHandle.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecutionHandle {
        return try Xla.ExecutionHandle.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.ExecutionHandle {
        return try Xla.ExecutionHandle.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecutionHandle {
        return try Xla.ExecutionHandle.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.ExecutionHandle {
        return try Xla.ExecutionHandle.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecutionHandle {
        return try Xla.ExecutionHandle.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "handle": return self.handle
        default: return nil
        }
    }
}
extension Xla.ExecutionHandle.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "handle": return self.handle
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "handle":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.handle = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.GlobalDataHandle: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.GlobalDataHandle> {
        var mergedArray = Array<Xla.GlobalDataHandle>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.GlobalDataHandle? {
        return try Xla.GlobalDataHandle.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.GlobalDataHandle {
        return try Xla.GlobalDataHandle.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.GlobalDataHandle {
        return try Xla.GlobalDataHandle.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.GlobalDataHandle {
        return try Xla.GlobalDataHandle.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.GlobalDataHandle {
        return try Xla.GlobalDataHandle.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.GlobalDataHandle {
        return try Xla.GlobalDataHandle.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.GlobalDataHandle {
        return try Xla.GlobalDataHandle.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "handle": return self.handle
        default: return nil
        }
    }
}
extension Xla.GlobalDataHandle.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "handle": return self.handle
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "handle":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.handle = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.ComputationDataHandle: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.ComputationDataHandle> {
        var mergedArray = Array<Xla.ComputationDataHandle>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.ComputationDataHandle? {
        return try Xla.ComputationDataHandle.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.ComputationDataHandle {
        return try Xla.ComputationDataHandle.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputationDataHandle {
        return try Xla.ComputationDataHandle.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.ComputationDataHandle {
        return try Xla.ComputationDataHandle.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputationDataHandle {
        return try Xla.ComputationDataHandle.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.ComputationDataHandle {
        return try Xla.ComputationDataHandle.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputationDataHandle {
        return try Xla.ComputationDataHandle.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "handle": return self.handle
        default: return nil
        }
    }
}
extension Xla.ComputationDataHandle.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "handle": return self.handle
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "handle":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.handle = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.DeviceHandle: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.DeviceHandle> {
        var mergedArray = Array<Xla.DeviceHandle>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.DeviceHandle? {
        return try Xla.DeviceHandle.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.DeviceHandle {
        return try Xla.DeviceHandle.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.DeviceHandle {
        return try Xla.DeviceHandle.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.DeviceHandle {
        return try Xla.DeviceHandle.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.DeviceHandle {
        return try Xla.DeviceHandle.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.DeviceHandle {
        return try Xla.DeviceHandle.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.DeviceHandle {
        return try Xla.DeviceHandle.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "handle": return self.handle
        default: return nil
        }
    }
}
extension Xla.DeviceHandle.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "handle": return self.handle
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "handle":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.handle = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.ChannelHandle: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.ChannelHandle> {
        var mergedArray = Array<Xla.ChannelHandle>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.ChannelHandle? {
        return try Xla.ChannelHandle.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.ChannelHandle {
        return try Xla.ChannelHandle.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.ChannelHandle {
        return try Xla.ChannelHandle.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.ChannelHandle {
        return try Xla.ChannelHandle.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ChannelHandle {
        return try Xla.ChannelHandle.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.ChannelHandle {
        return try Xla.ChannelHandle.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ChannelHandle {
        return try Xla.ChannelHandle.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "handle": return self.handle
        default: return nil
        }
    }
}
extension Xla.ChannelHandle.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "handle": return self.handle
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "handle":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.handle = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.Literal: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.Literal> {
        var mergedArray = Array<Xla.Literal>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.Literal? {
        return try Xla.Literal.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.Literal {
        return try Xla.Literal.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.Literal {
        return try Xla.Literal.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.Literal {
        return try Xla.Literal.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.Literal {
        return try Xla.Literal.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.Literal {
        return try Xla.Literal.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.Literal {
        return try Xla.Literal.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "shape": return self.shape
        case "preds": return self.preds
        case "u8S": return self.u8S
        case "s32S": return self.s32S
        case "s64S": return self.s64S
        case "u32S": return self.u32S
        case "u64S": return self.u64S
        case "f32S": return self.f32S
        case "f64S": return self.f64S
        case "tupleLiterals": return self.tupleLiterals
        default: return nil
        }
    }
}
extension Xla.Literal.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "shape": return self.shape
            case "preds": return self.preds
            case "u8S": return self.u8S
            case "s32S": return self.s32S
            case "s64S": return self.s64S
            case "u32S": return self.u32S
            case "u64S": return self.u64S
            case "f32S": return self.f32S
            case "f64S": return self.f64S
            case "tupleLiterals": return self.tupleLiterals
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "shape":
                guard let newSubscriptValue = newSubscriptValue as? Xla.Shape else {
                    return
                }
                self.shape = newSubscriptValue
            case "preds":
                guard let newSubscriptValue = newSubscriptValue as? Array<Bool> else {
                    return
                }
                self.preds = newSubscriptValue
            case "u8S":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.u8S = newSubscriptValue
            case "s32S":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int32> else {
                    return
                }
                self.s32S = newSubscriptValue
            case "s64S":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.s64S = newSubscriptValue
            case "u32S":
                guard let newSubscriptValue = newSubscriptValue as? Array<UInt32> else {
                    return
                }
                self.u32S = newSubscriptValue
            case "u64S":
                guard let newSubscriptValue = newSubscriptValue as? Array<UInt64> else {
                    return
                }
                self.u64S = newSubscriptValue
            case "f32S":
                guard let newSubscriptValue = newSubscriptValue as? Array<Float> else {
                    return
                }
                self.f32S = newSubscriptValue
            case "f64S":
                guard let newSubscriptValue = newSubscriptValue as? Array<Double> else {
                    return
                }
                self.f64S = newSubscriptValue
            case "tupleLiterals":
                guard let newSubscriptValue = newSubscriptValue as? Array<Xla.Literal> else {
                    return
                }
                self.tupleLiterals = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.WindowDimension: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.WindowDimension> {
        var mergedArray = Array<Xla.WindowDimension>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.WindowDimension? {
        return try Xla.WindowDimension.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.WindowDimension {
        return try Xla.WindowDimension.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.WindowDimension {
        return try Xla.WindowDimension.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.WindowDimension {
        return try Xla.WindowDimension.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.WindowDimension {
        return try Xla.WindowDimension.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.WindowDimension {
        return try Xla.WindowDimension.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.WindowDimension {
        return try Xla.WindowDimension.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "size": return self.size
        case "stride": return self.stride
        case "paddingLow": return self.paddingLow
        case "paddingHigh": return self.paddingHigh
        case "windowDilation": return self.windowDilation
        case "baseDilation": return self.baseDilation
        default: return nil
        }
    }
}
extension Xla.WindowDimension.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "size": return self.size
            case "stride": return self.stride
            case "paddingLow": return self.paddingLow
            case "paddingHigh": return self.paddingHigh
            case "windowDilation": return self.windowDilation
            case "baseDilation": return self.baseDilation
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "size":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.size = newSubscriptValue
            case "stride":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.stride = newSubscriptValue
            case "paddingLow":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.paddingLow = newSubscriptValue
            case "paddingHigh":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.paddingHigh = newSubscriptValue
            case "windowDilation":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.windowDilation = newSubscriptValue
            case "baseDilation":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.baseDilation = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.Window: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.Window> {
        var mergedArray = Array<Xla.Window>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.Window? {
        return try Xla.Window.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.Window {
        return try Xla.Window.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.Window {
        return try Xla.Window.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.Window {
        return try Xla.Window.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.Window {
        return try Xla.Window.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.Window {
        return try Xla.Window.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.Window {
        return try Xla.Window.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "dimensions": return self.dimensions
        default: return nil
        }
    }
}
extension Xla.Window.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "dimensions": return self.dimensions
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "dimensions":
                guard let newSubscriptValue = newSubscriptValue as? Array<Xla.WindowDimension> else {
                    return
                }
                self.dimensions = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.ConstantRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.ConstantRequest> {
        var mergedArray = Array<Xla.ConstantRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.ConstantRequest? {
        return try Xla.ConstantRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.ConstantRequest {
        return try Xla.ConstantRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.ConstantRequest {
        return try Xla.ConstantRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.ConstantRequest {
        return try Xla.ConstantRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ConstantRequest {
        return try Xla.ConstantRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.ConstantRequest {
        return try Xla.ConstantRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ConstantRequest {
        return try Xla.ConstantRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "literal": return self.literal
        default: return nil
        }
    }
}
extension Xla.ConstantRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "literal": return self.literal
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "literal":
                guard let newSubscriptValue = newSubscriptValue as? Xla.Literal else {
                    return
                }
                self.literal = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.GetTupleElementRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.GetTupleElementRequest> {
        var mergedArray = Array<Xla.GetTupleElementRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.GetTupleElementRequest? {
        return try Xla.GetTupleElementRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.GetTupleElementRequest {
        return try Xla.GetTupleElementRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.GetTupleElementRequest {
        return try Xla.GetTupleElementRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.GetTupleElementRequest {
        return try Xla.GetTupleElementRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.GetTupleElementRequest {
        return try Xla.GetTupleElementRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.GetTupleElementRequest {
        return try Xla.GetTupleElementRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.GetTupleElementRequest {
        return try Xla.GetTupleElementRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "operand": return self.operand
        case "index": return self.index
        default: return nil
        }
    }
}
extension Xla.GetTupleElementRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "operand": return self.operand
            case "index": return self.index
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "operand":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.operand = newSubscriptValue
            case "index":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.index = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.SliceRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.SliceRequest> {
        var mergedArray = Array<Xla.SliceRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.SliceRequest? {
        return try Xla.SliceRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.SliceRequest {
        return try Xla.SliceRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.SliceRequest {
        return try Xla.SliceRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.SliceRequest {
        return try Xla.SliceRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SliceRequest {
        return try Xla.SliceRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.SliceRequest {
        return try Xla.SliceRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SliceRequest {
        return try Xla.SliceRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "operand": return self.operand
        case "startIndices": return self.startIndices
        case "limitIndices": return self.limitIndices
        default: return nil
        }
    }
}
extension Xla.SliceRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "operand": return self.operand
            case "startIndices": return self.startIndices
            case "limitIndices": return self.limitIndices
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "operand":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.operand = newSubscriptValue
            case "startIndices":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.startIndices = newSubscriptValue
            case "limitIndices":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.limitIndices = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.DynamicSliceRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.DynamicSliceRequest> {
        var mergedArray = Array<Xla.DynamicSliceRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.DynamicSliceRequest? {
        return try Xla.DynamicSliceRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.DynamicSliceRequest {
        return try Xla.DynamicSliceRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.DynamicSliceRequest {
        return try Xla.DynamicSliceRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.DynamicSliceRequest {
        return try Xla.DynamicSliceRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.DynamicSliceRequest {
        return try Xla.DynamicSliceRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.DynamicSliceRequest {
        return try Xla.DynamicSliceRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.DynamicSliceRequest {
        return try Xla.DynamicSliceRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "operand": return self.operand
        case "startIndices": return self.startIndices
        case "sliceSizes": return self.sliceSizes
        default: return nil
        }
    }
}
extension Xla.DynamicSliceRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "operand": return self.operand
            case "startIndices": return self.startIndices
            case "sliceSizes": return self.sliceSizes
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "operand":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.operand = newSubscriptValue
            case "startIndices":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.startIndices = newSubscriptValue
            case "sliceSizes":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.sliceSizes = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.DynamicUpdateSliceRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.DynamicUpdateSliceRequest> {
        var mergedArray = Array<Xla.DynamicUpdateSliceRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.DynamicUpdateSliceRequest? {
        return try Xla.DynamicUpdateSliceRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.DynamicUpdateSliceRequest {
        return try Xla.DynamicUpdateSliceRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.DynamicUpdateSliceRequest {
        return try Xla.DynamicUpdateSliceRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.DynamicUpdateSliceRequest {
        return try Xla.DynamicUpdateSliceRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.DynamicUpdateSliceRequest {
        return try Xla.DynamicUpdateSliceRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.DynamicUpdateSliceRequest {
        return try Xla.DynamicUpdateSliceRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.DynamicUpdateSliceRequest {
        return try Xla.DynamicUpdateSliceRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "operand": return self.operand
        case "update": return self.update
        case "startIndices": return self.startIndices
        default: return nil
        }
    }
}
extension Xla.DynamicUpdateSliceRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "operand": return self.operand
            case "update": return self.update
            case "startIndices": return self.startIndices
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "operand":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.operand = newSubscriptValue
            case "update":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.update = newSubscriptValue
            case "startIndices":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.startIndices = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.ConvolutionDimensionNumbers: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.ConvolutionDimensionNumbers> {
        var mergedArray = Array<Xla.ConvolutionDimensionNumbers>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.ConvolutionDimensionNumbers? {
        return try Xla.ConvolutionDimensionNumbers.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.ConvolutionDimensionNumbers {
        return try Xla.ConvolutionDimensionNumbers.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.ConvolutionDimensionNumbers {
        return try Xla.ConvolutionDimensionNumbers.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.ConvolutionDimensionNumbers {
        return try Xla.ConvolutionDimensionNumbers.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ConvolutionDimensionNumbers {
        return try Xla.ConvolutionDimensionNumbers.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.ConvolutionDimensionNumbers {
        return try Xla.ConvolutionDimensionNumbers.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ConvolutionDimensionNumbers {
        return try Xla.ConvolutionDimensionNumbers.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "batchDimension": return self.batchDimension
        case "featureDimension": return self.featureDimension
        case "spatialDimensions": return self.spatialDimensions
        case "kernelInputFeatureDimension": return self.kernelInputFeatureDimension
        case "kernelOutputFeatureDimension": return self.kernelOutputFeatureDimension
        case "kernelSpatialDimensions": return self.kernelSpatialDimensions
        default: return nil
        }
    }
}
extension Xla.ConvolutionDimensionNumbers.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "batchDimension": return self.batchDimension
            case "featureDimension": return self.featureDimension
            case "spatialDimensions": return self.spatialDimensions
            case "kernelInputFeatureDimension": return self.kernelInputFeatureDimension
            case "kernelOutputFeatureDimension": return self.kernelOutputFeatureDimension
            case "kernelSpatialDimensions": return self.kernelSpatialDimensions
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "batchDimension":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.batchDimension = newSubscriptValue
            case "featureDimension":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.featureDimension = newSubscriptValue
            case "spatialDimensions":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.spatialDimensions = newSubscriptValue
            case "kernelInputFeatureDimension":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.kernelInputFeatureDimension = newSubscriptValue
            case "kernelOutputFeatureDimension":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.kernelOutputFeatureDimension = newSubscriptValue
            case "kernelSpatialDimensions":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.kernelSpatialDimensions = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.ConvolveRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.ConvolveRequest> {
        var mergedArray = Array<Xla.ConvolveRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.ConvolveRequest? {
        return try Xla.ConvolveRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.ConvolveRequest {
        return try Xla.ConvolveRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.ConvolveRequest {
        return try Xla.ConvolveRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.ConvolveRequest {
        return try Xla.ConvolveRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ConvolveRequest {
        return try Xla.ConvolveRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.ConvolveRequest {
        return try Xla.ConvolveRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ConvolveRequest {
        return try Xla.ConvolveRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "lhs": return self.lhs
        case "rhs": return self.rhs
        case "window": return self.window
        case "dimensionNumbers": return self.dimensionNumbers
        default: return nil
        }
    }
}
extension Xla.ConvolveRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "lhs": return self.lhs
            case "rhs": return self.rhs
            case "window": return self.window
            case "dimensionNumbers": return self.dimensionNumbers
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "lhs":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.lhs = newSubscriptValue
            case "rhs":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.rhs = newSubscriptValue
            case "window":
                guard let newSubscriptValue = newSubscriptValue as? Xla.Window else {
                    return
                }
                self.window = newSubscriptValue
            case "dimensionNumbers":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ConvolutionDimensionNumbers else {
                    return
                }
                self.dimensionNumbers = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.InfeedRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.InfeedRequest> {
        var mergedArray = Array<Xla.InfeedRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.InfeedRequest? {
        return try Xla.InfeedRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.InfeedRequest {
        return try Xla.InfeedRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.InfeedRequest {
        return try Xla.InfeedRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.InfeedRequest {
        return try Xla.InfeedRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.InfeedRequest {
        return try Xla.InfeedRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.InfeedRequest {
        return try Xla.InfeedRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.InfeedRequest {
        return try Xla.InfeedRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "shape": return self.shape
        case "config": return self.config
        default: return nil
        }
    }
}
extension Xla.InfeedRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "shape": return self.shape
            case "config": return self.config
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "shape":
                guard let newSubscriptValue = newSubscriptValue as? Xla.Shape else {
                    return
                }
                self.shape = newSubscriptValue
            case "config":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.config = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.OutfeedRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.OutfeedRequest> {
        var mergedArray = Array<Xla.OutfeedRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.OutfeedRequest? {
        return try Xla.OutfeedRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.OutfeedRequest {
        return try Xla.OutfeedRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.OutfeedRequest {
        return try Xla.OutfeedRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.OutfeedRequest {
        return try Xla.OutfeedRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.OutfeedRequest {
        return try Xla.OutfeedRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.OutfeedRequest {
        return try Xla.OutfeedRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.OutfeedRequest {
        return try Xla.OutfeedRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "shape": return self.shape
        case "operand": return self.operand
        case "outfeedConfig": return self.outfeedConfig
        default: return nil
        }
    }
}
extension Xla.OutfeedRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "shape": return self.shape
            case "operand": return self.operand
            case "outfeedConfig": return self.outfeedConfig
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "shape":
                guard let newSubscriptValue = newSubscriptValue as? Xla.Shape else {
                    return
                }
                self.shape = newSubscriptValue
            case "operand":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.operand = newSubscriptValue
            case "outfeedConfig":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.outfeedConfig = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.CallRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.CallRequest> {
        var mergedArray = Array<Xla.CallRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.CallRequest? {
        return try Xla.CallRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.CallRequest {
        return try Xla.CallRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.CallRequest {
        return try Xla.CallRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.CallRequest {
        return try Xla.CallRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.CallRequest {
        return try Xla.CallRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.CallRequest {
        return try Xla.CallRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.CallRequest {
        return try Xla.CallRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "toApply": return self.toApply
        case "operands": return self.operands
        default: return nil
        }
    }
}
extension Xla.CallRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "toApply": return self.toApply
            case "operands": return self.operands
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "toApply":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationHandle else {
                    return
                }
                self.toApply = newSubscriptValue
            case "operands":
                guard let newSubscriptValue = newSubscriptValue as? Array<Xla.ComputationDataHandle> else {
                    return
                }
                self.operands = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.CustomCallRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.CustomCallRequest> {
        var mergedArray = Array<Xla.CustomCallRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.CustomCallRequest? {
        return try Xla.CustomCallRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.CustomCallRequest {
        return try Xla.CustomCallRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.CustomCallRequest {
        return try Xla.CustomCallRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.CustomCallRequest {
        return try Xla.CustomCallRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.CustomCallRequest {
        return try Xla.CustomCallRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.CustomCallRequest {
        return try Xla.CustomCallRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.CustomCallRequest {
        return try Xla.CustomCallRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "callTargetName": return self.callTargetName
        case "operands": return self.operands
        case "shape": return self.shape
        default: return nil
        }
    }
}
extension Xla.CustomCallRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "callTargetName": return self.callTargetName
            case "operands": return self.operands
            case "shape": return self.shape
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "callTargetName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.callTargetName = newSubscriptValue
            case "operands":
                guard let newSubscriptValue = newSubscriptValue as? Array<Xla.ComputationDataHandle> else {
                    return
                }
                self.operands = newSubscriptValue
            case "shape":
                guard let newSubscriptValue = newSubscriptValue as? Xla.Shape else {
                    return
                }
                self.shape = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.MapRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.MapRequest> {
        var mergedArray = Array<Xla.MapRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.MapRequest? {
        return try Xla.MapRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.MapRequest {
        return try Xla.MapRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.MapRequest {
        return try Xla.MapRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.MapRequest {
        return try Xla.MapRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.MapRequest {
        return try Xla.MapRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.MapRequest {
        return try Xla.MapRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.MapRequest {
        return try Xla.MapRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "operands": return self.operands
        case "toApply": return self.toApply
        case "staticOperands": return self.staticOperands
        default: return nil
        }
    }
}
extension Xla.MapRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "operands": return self.operands
            case "toApply": return self.toApply
            case "staticOperands": return self.staticOperands
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "operands":
                guard let newSubscriptValue = newSubscriptValue as? Array<Xla.ComputationDataHandle> else {
                    return
                }
                self.operands = newSubscriptValue
            case "toApply":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationHandle else {
                    return
                }
                self.toApply = newSubscriptValue
            case "staticOperands":
                guard let newSubscriptValue = newSubscriptValue as? Array<Xla.ComputationDataHandle> else {
                    return
                }
                self.staticOperands = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.ReduceRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.ReduceRequest> {
        var mergedArray = Array<Xla.ReduceRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.ReduceRequest? {
        return try Xla.ReduceRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.ReduceRequest {
        return try Xla.ReduceRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.ReduceRequest {
        return try Xla.ReduceRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.ReduceRequest {
        return try Xla.ReduceRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ReduceRequest {
        return try Xla.ReduceRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.ReduceRequest {
        return try Xla.ReduceRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ReduceRequest {
        return try Xla.ReduceRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "operand": return self.operand
        case "initValue": return self.initValue
        case "dimensions": return self.dimensions
        case "toApply": return self.toApply
        default: return nil
        }
    }
}
extension Xla.ReduceRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "operand": return self.operand
            case "initValue": return self.initValue
            case "dimensions": return self.dimensions
            case "toApply": return self.toApply
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "operand":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.operand = newSubscriptValue
            case "initValue":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.initValue = newSubscriptValue
            case "dimensions":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.dimensions = newSubscriptValue
            case "toApply":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationHandle else {
                    return
                }
                self.toApply = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.ReduceWindowRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.ReduceWindowRequest> {
        var mergedArray = Array<Xla.ReduceWindowRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.ReduceWindowRequest? {
        return try Xla.ReduceWindowRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.ReduceWindowRequest {
        return try Xla.ReduceWindowRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.ReduceWindowRequest {
        return try Xla.ReduceWindowRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.ReduceWindowRequest {
        return try Xla.ReduceWindowRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ReduceWindowRequest {
        return try Xla.ReduceWindowRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.ReduceWindowRequest {
        return try Xla.ReduceWindowRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ReduceWindowRequest {
        return try Xla.ReduceWindowRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "operand": return self.operand
        case "initValue": return self.initValue
        case "window": return self.window
        case "toApply": return self.toApply
        default: return nil
        }
    }
}
extension Xla.ReduceWindowRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "operand": return self.operand
            case "initValue": return self.initValue
            case "window": return self.window
            case "toApply": return self.toApply
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "operand":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.operand = newSubscriptValue
            case "initValue":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.initValue = newSubscriptValue
            case "window":
                guard let newSubscriptValue = newSubscriptValue as? Xla.Window else {
                    return
                }
                self.window = newSubscriptValue
            case "toApply":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationHandle else {
                    return
                }
                self.toApply = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.CrossReplicaSumRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.CrossReplicaSumRequest> {
        var mergedArray = Array<Xla.CrossReplicaSumRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.CrossReplicaSumRequest? {
        return try Xla.CrossReplicaSumRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.CrossReplicaSumRequest {
        return try Xla.CrossReplicaSumRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.CrossReplicaSumRequest {
        return try Xla.CrossReplicaSumRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.CrossReplicaSumRequest {
        return try Xla.CrossReplicaSumRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.CrossReplicaSumRequest {
        return try Xla.CrossReplicaSumRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.CrossReplicaSumRequest {
        return try Xla.CrossReplicaSumRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.CrossReplicaSumRequest {
        return try Xla.CrossReplicaSumRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "operand": return self.operand
        default: return nil
        }
    }
}
extension Xla.CrossReplicaSumRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "operand": return self.operand
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "operand":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.operand = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.SelectAndScatterRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.SelectAndScatterRequest> {
        var mergedArray = Array<Xla.SelectAndScatterRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.SelectAndScatterRequest? {
        return try Xla.SelectAndScatterRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.SelectAndScatterRequest {
        return try Xla.SelectAndScatterRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.SelectAndScatterRequest {
        return try Xla.SelectAndScatterRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.SelectAndScatterRequest {
        return try Xla.SelectAndScatterRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SelectAndScatterRequest {
        return try Xla.SelectAndScatterRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.SelectAndScatterRequest {
        return try Xla.SelectAndScatterRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SelectAndScatterRequest {
        return try Xla.SelectAndScatterRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "operand": return self.operand
        case "source": return self.source
        case "initValue": return self.initValue
        case "window": return self.window
        case "select": return self.select
        case "scatter": return self.scatter
        default: return nil
        }
    }
}
extension Xla.SelectAndScatterRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "operand": return self.operand
            case "source": return self.source
            case "initValue": return self.initValue
            case "window": return self.window
            case "select": return self.select
            case "scatter": return self.scatter
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "operand":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.operand = newSubscriptValue
            case "source":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.source = newSubscriptValue
            case "initValue":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.initValue = newSubscriptValue
            case "window":
                guard let newSubscriptValue = newSubscriptValue as? Xla.Window else {
                    return
                }
                self.window = newSubscriptValue
            case "select":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationHandle else {
                    return
                }
                self.select = newSubscriptValue
            case "scatter":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationHandle else {
                    return
                }
                self.scatter = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.ReverseRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.ReverseRequest> {
        var mergedArray = Array<Xla.ReverseRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.ReverseRequest? {
        return try Xla.ReverseRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.ReverseRequest {
        return try Xla.ReverseRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.ReverseRequest {
        return try Xla.ReverseRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.ReverseRequest {
        return try Xla.ReverseRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ReverseRequest {
        return try Xla.ReverseRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.ReverseRequest {
        return try Xla.ReverseRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ReverseRequest {
        return try Xla.ReverseRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "operand": return self.operand
        case "dimensions": return self.dimensions
        default: return nil
        }
    }
}
extension Xla.ReverseRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "operand": return self.operand
            case "dimensions": return self.dimensions
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "operand":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.operand = newSubscriptValue
            case "dimensions":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.dimensions = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.BroadcastRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.BroadcastRequest> {
        var mergedArray = Array<Xla.BroadcastRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.BroadcastRequest? {
        return try Xla.BroadcastRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.BroadcastRequest {
        return try Xla.BroadcastRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.BroadcastRequest {
        return try Xla.BroadcastRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.BroadcastRequest {
        return try Xla.BroadcastRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.BroadcastRequest {
        return try Xla.BroadcastRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.BroadcastRequest {
        return try Xla.BroadcastRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.BroadcastRequest {
        return try Xla.BroadcastRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "operand": return self.operand
        case "broadcastSizes": return self.broadcastSizes
        default: return nil
        }
    }
}
extension Xla.BroadcastRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "operand": return self.operand
            case "broadcastSizes": return self.broadcastSizes
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "operand":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.operand = newSubscriptValue
            case "broadcastSizes":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.broadcastSizes = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.PadRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.PadRequest> {
        var mergedArray = Array<Xla.PadRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.PadRequest? {
        return try Xla.PadRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.PadRequest {
        return try Xla.PadRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.PadRequest {
        return try Xla.PadRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.PadRequest {
        return try Xla.PadRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.PadRequest {
        return try Xla.PadRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.PadRequest {
        return try Xla.PadRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.PadRequest {
        return try Xla.PadRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "operand": return self.operand
        case "paddingValue": return self.paddingValue
        case "paddingConfig": return self.paddingConfig
        default: return nil
        }
    }
}
extension Xla.PadRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "operand": return self.operand
            case "paddingValue": return self.paddingValue
            case "paddingConfig": return self.paddingConfig
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "operand":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.operand = newSubscriptValue
            case "paddingValue":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.paddingValue = newSubscriptValue
            case "paddingConfig":
                guard let newSubscriptValue = newSubscriptValue as? Xla.PaddingConfig else {
                    return
                }
                self.paddingConfig = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.ReshapeRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.ReshapeRequest> {
        var mergedArray = Array<Xla.ReshapeRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.ReshapeRequest? {
        return try Xla.ReshapeRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.ReshapeRequest {
        return try Xla.ReshapeRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.ReshapeRequest {
        return try Xla.ReshapeRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.ReshapeRequest {
        return try Xla.ReshapeRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ReshapeRequest {
        return try Xla.ReshapeRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.ReshapeRequest {
        return try Xla.ReshapeRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ReshapeRequest {
        return try Xla.ReshapeRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "operand": return self.operand
        case "dimensions": return self.dimensions
        case "newSizes": return self.newSizes
        default: return nil
        }
    }
}
extension Xla.ReshapeRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "operand": return self.operand
            case "dimensions": return self.dimensions
            case "newSizes": return self.newSizes
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "operand":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.operand = newSubscriptValue
            case "dimensions":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.dimensions = newSubscriptValue
            case "newSizes":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.newSizes = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.TransposeRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.TransposeRequest> {
        var mergedArray = Array<Xla.TransposeRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.TransposeRequest? {
        return try Xla.TransposeRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.TransposeRequest {
        return try Xla.TransposeRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.TransposeRequest {
        return try Xla.TransposeRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.TransposeRequest {
        return try Xla.TransposeRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransposeRequest {
        return try Xla.TransposeRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.TransposeRequest {
        return try Xla.TransposeRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransposeRequest {
        return try Xla.TransposeRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "operand": return self.operand
        case "dimensions": return self.dimensions
        default: return nil
        }
    }
}
extension Xla.TransposeRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "operand": return self.operand
            case "dimensions": return self.dimensions
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "operand":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.operand = newSubscriptValue
            case "dimensions":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.dimensions = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.ParameterRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.ParameterRequest> {
        var mergedArray = Array<Xla.ParameterRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.ParameterRequest? {
        return try Xla.ParameterRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.ParameterRequest {
        return try Xla.ParameterRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.ParameterRequest {
        return try Xla.ParameterRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.ParameterRequest {
        return try Xla.ParameterRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ParameterRequest {
        return try Xla.ParameterRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.ParameterRequest {
        return try Xla.ParameterRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ParameterRequest {
        return try Xla.ParameterRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "shape": return self.shape
        case "parameter": return self.parameter
        case "name": return self.name
        default: return nil
        }
    }
}
extension Xla.ParameterRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "shape": return self.shape
            case "parameter": return self.parameter
            case "name": return self.name
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "shape":
                guard let newSubscriptValue = newSubscriptValue as? Xla.Shape else {
                    return
                }
                self.shape = newSubscriptValue
            case "parameter":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.parameter = newSubscriptValue
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.GetLocalShapeRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.GetLocalShapeRequest> {
        var mergedArray = Array<Xla.GetLocalShapeRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.GetLocalShapeRequest? {
        return try Xla.GetLocalShapeRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.GetLocalShapeRequest {
        return try Xla.GetLocalShapeRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.GetLocalShapeRequest {
        return try Xla.GetLocalShapeRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.GetLocalShapeRequest {
        return try Xla.GetLocalShapeRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.GetLocalShapeRequest {
        return try Xla.GetLocalShapeRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.GetLocalShapeRequest {
        return try Xla.GetLocalShapeRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.GetLocalShapeRequest {
        return try Xla.GetLocalShapeRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "computation": return self.computation
        case "operand": return self.operand
        default: return nil
        }
    }
}
extension Xla.GetLocalShapeRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "computation": return self.computation
            case "operand": return self.operand
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "computation":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationHandle else {
                    return
                }
                self.computation = newSubscriptValue
            case "operand":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.operand = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.GetLocalShapeResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.GetLocalShapeResponse> {
        var mergedArray = Array<Xla.GetLocalShapeResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.GetLocalShapeResponse? {
        return try Xla.GetLocalShapeResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.GetLocalShapeResponse {
        return try Xla.GetLocalShapeResponse.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.GetLocalShapeResponse {
        return try Xla.GetLocalShapeResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.GetLocalShapeResponse {
        return try Xla.GetLocalShapeResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.GetLocalShapeResponse {
        return try Xla.GetLocalShapeResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.GetLocalShapeResponse {
        return try Xla.GetLocalShapeResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.GetLocalShapeResponse {
        return try Xla.GetLocalShapeResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "shape": return self.shape
        default: return nil
        }
    }
}
extension Xla.GetLocalShapeResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "shape": return self.shape
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "shape":
                guard let newSubscriptValue = newSubscriptValue as? Xla.Shape else {
                    return
                }
                self.shape = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.TraceRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.TraceRequest> {
        var mergedArray = Array<Xla.TraceRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.TraceRequest? {
        return try Xla.TraceRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.TraceRequest {
        return try Xla.TraceRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.TraceRequest {
        return try Xla.TraceRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.TraceRequest {
        return try Xla.TraceRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TraceRequest {
        return try Xla.TraceRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.TraceRequest {
        return try Xla.TraceRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TraceRequest {
        return try Xla.TraceRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "tag": return self.tag
        case "operand": return self.operand
        default: return nil
        }
    }
}
extension Xla.TraceRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "tag": return self.tag
            case "operand": return self.operand
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "tag":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.tag = newSubscriptValue
            case "operand":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.operand = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.ConvertRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.ConvertRequest> {
        var mergedArray = Array<Xla.ConvertRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.ConvertRequest? {
        return try Xla.ConvertRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.ConvertRequest {
        return try Xla.ConvertRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.ConvertRequest {
        return try Xla.ConvertRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.ConvertRequest {
        return try Xla.ConvertRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ConvertRequest {
        return try Xla.ConvertRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.ConvertRequest {
        return try Xla.ConvertRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ConvertRequest {
        return try Xla.ConvertRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "operand": return self.operand
        case "newElementType": return self.newElementType
        default: return nil
        }
    }
}
extension Xla.ConvertRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "operand": return self.operand
            case "newElementType": return self.newElementType
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "operand":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.operand = newSubscriptValue
            case "newElementType":
                guard let newSubscriptValue = newSubscriptValue as? Xla.PrimitiveType else {
                    return
                }
                self.newElementType = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.ConcatenateRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.ConcatenateRequest> {
        var mergedArray = Array<Xla.ConcatenateRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.ConcatenateRequest? {
        return try Xla.ConcatenateRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.ConcatenateRequest {
        return try Xla.ConcatenateRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.ConcatenateRequest {
        return try Xla.ConcatenateRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.ConcatenateRequest {
        return try Xla.ConcatenateRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ConcatenateRequest {
        return try Xla.ConcatenateRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.ConcatenateRequest {
        return try Xla.ConcatenateRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ConcatenateRequest {
        return try Xla.ConcatenateRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "operands": return self.operands
        case "dimension": return self.dimension
        default: return nil
        }
    }
}
extension Xla.ConcatenateRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "operands": return self.operands
            case "dimension": return self.dimension
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "operands":
                guard let newSubscriptValue = newSubscriptValue as? Array<Xla.ComputationDataHandle> else {
                    return
                }
                self.operands = newSubscriptValue
            case "dimension":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.dimension = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.WhileRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.WhileRequest> {
        var mergedArray = Array<Xla.WhileRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.WhileRequest? {
        return try Xla.WhileRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.WhileRequest {
        return try Xla.WhileRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.WhileRequest {
        return try Xla.WhileRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.WhileRequest {
        return try Xla.WhileRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.WhileRequest {
        return try Xla.WhileRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.WhileRequest {
        return try Xla.WhileRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.WhileRequest {
        return try Xla.WhileRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "condition": return self.condition
        case "body": return self.body
        case "`init`": return self.`init`
        default: return nil
        }
    }
}
extension Xla.WhileRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "condition": return self.condition
            case "body": return self.body
            case "`init`": return self.`init`
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "condition":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationHandle else {
                    return
                }
                self.condition = newSubscriptValue
            case "body":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationHandle else {
                    return
                }
                self.body = newSubscriptValue
            case "`init`":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.`init` = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.UnaryOpRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.UnaryOpRequest> {
        var mergedArray = Array<Xla.UnaryOpRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.UnaryOpRequest? {
        return try Xla.UnaryOpRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.UnaryOpRequest {
        return try Xla.UnaryOpRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.UnaryOpRequest {
        return try Xla.UnaryOpRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.UnaryOpRequest {
        return try Xla.UnaryOpRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.UnaryOpRequest {
        return try Xla.UnaryOpRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.UnaryOpRequest {
        return try Xla.UnaryOpRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.UnaryOpRequest {
        return try Xla.UnaryOpRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "unop": return self.unop
        case "operand": return self.operand
        default: return nil
        }
    }
}
extension Xla.UnaryOpRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "unop": return self.unop
            case "operand": return self.operand
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "unop":
                guard let newSubscriptValue = newSubscriptValue as? Xla.UnaryOperation else {
                    return
                }
                self.unop = newSubscriptValue
            case "operand":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.operand = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.BinaryOpRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.BinaryOpRequest> {
        var mergedArray = Array<Xla.BinaryOpRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.BinaryOpRequest? {
        return try Xla.BinaryOpRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.BinaryOpRequest {
        return try Xla.BinaryOpRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.BinaryOpRequest {
        return try Xla.BinaryOpRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.BinaryOpRequest {
        return try Xla.BinaryOpRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.BinaryOpRequest {
        return try Xla.BinaryOpRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.BinaryOpRequest {
        return try Xla.BinaryOpRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.BinaryOpRequest {
        return try Xla.BinaryOpRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "binop": return self.binop
        case "lhs": return self.lhs
        case "rhs": return self.rhs
        case "broadcastDimensions": return self.broadcastDimensions
        default: return nil
        }
    }
}
extension Xla.BinaryOpRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "binop": return self.binop
            case "lhs": return self.lhs
            case "rhs": return self.rhs
            case "broadcastDimensions": return self.broadcastDimensions
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "binop":
                guard let newSubscriptValue = newSubscriptValue as? Xla.BinaryOperation else {
                    return
                }
                self.binop = newSubscriptValue
            case "lhs":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.lhs = newSubscriptValue
            case "rhs":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.rhs = newSubscriptValue
            case "broadcastDimensions":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.broadcastDimensions = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.RngRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.RngRequest> {
        var mergedArray = Array<Xla.RngRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.RngRequest? {
        return try Xla.RngRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.RngRequest {
        return try Xla.RngRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.RngRequest {
        return try Xla.RngRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.RngRequest {
        return try Xla.RngRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.RngRequest {
        return try Xla.RngRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.RngRequest {
        return try Xla.RngRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.RngRequest {
        return try Xla.RngRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "distribution": return self.distribution
        case "parameter": return self.parameter
        case "shape": return self.shape
        default: return nil
        }
    }
}
extension Xla.RngRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "distribution": return self.distribution
            case "parameter": return self.parameter
            case "shape": return self.shape
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "distribution":
                guard let newSubscriptValue = newSubscriptValue as? Xla.RandomDistribution else {
                    return
                }
                self.distribution = newSubscriptValue
            case "parameter":
                guard let newSubscriptValue = newSubscriptValue as? Array<Xla.ComputationDataHandle> else {
                    return
                }
                self.parameter = newSubscriptValue
            case "shape":
                guard let newSubscriptValue = newSubscriptValue as? Xla.Shape else {
                    return
                }
                self.shape = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.TernaryOpRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.TernaryOpRequest> {
        var mergedArray = Array<Xla.TernaryOpRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.TernaryOpRequest? {
        return try Xla.TernaryOpRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.TernaryOpRequest {
        return try Xla.TernaryOpRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.TernaryOpRequest {
        return try Xla.TernaryOpRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.TernaryOpRequest {
        return try Xla.TernaryOpRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TernaryOpRequest {
        return try Xla.TernaryOpRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.TernaryOpRequest {
        return try Xla.TernaryOpRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TernaryOpRequest {
        return try Xla.TernaryOpRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "triop": return self.triop
        case "lhs": return self.lhs
        case "rhs": return self.rhs
        case "ehs": return self.ehs
        default: return nil
        }
    }
}
extension Xla.TernaryOpRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "triop": return self.triop
            case "lhs": return self.lhs
            case "rhs": return self.rhs
            case "ehs": return self.ehs
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "triop":
                guard let newSubscriptValue = newSubscriptValue as? Xla.TernaryOperation else {
                    return
                }
                self.triop = newSubscriptValue
            case "lhs":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.lhs = newSubscriptValue
            case "rhs":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.rhs = newSubscriptValue
            case "ehs":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.ehs = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.VariadicOpRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.VariadicOpRequest> {
        var mergedArray = Array<Xla.VariadicOpRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.VariadicOpRequest? {
        return try Xla.VariadicOpRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.VariadicOpRequest {
        return try Xla.VariadicOpRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.VariadicOpRequest {
        return try Xla.VariadicOpRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.VariadicOpRequest {
        return try Xla.VariadicOpRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.VariadicOpRequest {
        return try Xla.VariadicOpRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.VariadicOpRequest {
        return try Xla.VariadicOpRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.VariadicOpRequest {
        return try Xla.VariadicOpRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "varop": return self.varop
        case "operands": return self.operands
        default: return nil
        }
    }
}
extension Xla.VariadicOpRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "varop": return self.varop
            case "operands": return self.operands
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "varop":
                guard let newSubscriptValue = newSubscriptValue as? Xla.VariadicOperation else {
                    return
                }
                self.varop = newSubscriptValue
            case "operands":
                guard let newSubscriptValue = newSubscriptValue as? Array<Xla.ComputationDataHandle> else {
                    return
                }
                self.operands = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.SendRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.SendRequest> {
        var mergedArray = Array<Xla.SendRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.SendRequest? {
        return try Xla.SendRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.SendRequest {
        return try Xla.SendRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.SendRequest {
        return try Xla.SendRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.SendRequest {
        return try Xla.SendRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SendRequest {
        return try Xla.SendRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.SendRequest {
        return try Xla.SendRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SendRequest {
        return try Xla.SendRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "operand": return self.operand
        case "channelHandle": return self.channelHandle
        default: return nil
        }
    }
}
extension Xla.SendRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "operand": return self.operand
            case "channelHandle": return self.channelHandle
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "operand":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.operand = newSubscriptValue
            case "channelHandle":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ChannelHandle else {
                    return
                }
                self.channelHandle = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.RecvRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.RecvRequest> {
        var mergedArray = Array<Xla.RecvRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.RecvRequest? {
        return try Xla.RecvRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.RecvRequest {
        return try Xla.RecvRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.RecvRequest {
        return try Xla.RecvRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.RecvRequest {
        return try Xla.RecvRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.RecvRequest {
        return try Xla.RecvRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.RecvRequest {
        return try Xla.RecvRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.RecvRequest {
        return try Xla.RecvRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "shape": return self.shape
        case "channelHandle": return self.channelHandle
        default: return nil
        }
    }
}
extension Xla.RecvRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "shape": return self.shape
            case "channelHandle": return self.channelHandle
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "shape":
                guard let newSubscriptValue = newSubscriptValue as? Xla.Shape else {
                    return
                }
                self.shape = newSubscriptValue
            case "channelHandle":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ChannelHandle else {
                    return
                }
                self.channelHandle = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.OpRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.OpRequest> {
        var mergedArray = Array<Xla.OpRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.OpRequest? {
        return try Xla.OpRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.OpRequest {
        return try Xla.OpRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.OpRequest {
        return try Xla.OpRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.OpRequest {
        return try Xla.OpRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.OpRequest {
        return try Xla.OpRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.OpRequest {
        return try Xla.OpRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.OpRequest {
        return try Xla.OpRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "computation": return self.computation
        case "metadata": return self.metadata
        case "binaryOpRequest": return self.binaryOpRequest
        case "broadcastRequest": return self.broadcastRequest
        case "callRequest": return self.callRequest
        case "concatenateRequest": return self.concatenateRequest
        case "constantRequest": return self.constantRequest
        case "convertRequest": return self.convertRequest
        case "convolveRequest": return self.convolveRequest
        case "crossReplicaSumRequest": return self.crossReplicaSumRequest
        case "customCallRequest": return self.customCallRequest
        case "dynamicSliceRequest": return self.dynamicSliceRequest
        case "dynamicUpdateSliceRequest": return self.dynamicUpdateSliceRequest
        case "getTupleElementRequest": return self.getTupleElementRequest
        case "infeedRequest": return self.infeedRequest
        case "mapRequest": return self.mapRequest
        case "padRequest": return self.padRequest
        case "parameterRequest": return self.parameterRequest
        case "reduceRequest": return self.reduceRequest
        case "reduceWindowRequest": return self.reduceWindowRequest
        case "reshapeRequest": return self.reshapeRequest
        case "reverseRequest": return self.reverseRequest
        case "rngRequest": return self.rngRequest
        case "selectAndScatterRequest": return self.selectAndScatterRequest
        case "sliceRequest": return self.sliceRequest
        case "ternaryOpRequest": return self.ternaryOpRequest
        case "traceRequest": return self.traceRequest
        case "transposeRequest": return self.transposeRequest
        case "unaryOpRequest": return self.unaryOpRequest
        case "variadicOpRequest": return self.variadicOpRequest
        case "whileRequest": return self.whileRequest
        case "sendRequest": return self.sendRequest
        case "recvRequest": return self.recvRequest
        case "outfeedRequest": return self.outfeedRequest
        default: return nil
        }
    }
}
extension Xla.OpRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "computation": return self.computation
            case "metadata": return self.metadata
            case "binaryOpRequest": return self.binaryOpRequest
            case "broadcastRequest": return self.broadcastRequest
            case "callRequest": return self.callRequest
            case "concatenateRequest": return self.concatenateRequest
            case "constantRequest": return self.constantRequest
            case "convertRequest": return self.convertRequest
            case "convolveRequest": return self.convolveRequest
            case "crossReplicaSumRequest": return self.crossReplicaSumRequest
            case "customCallRequest": return self.customCallRequest
            case "dynamicSliceRequest": return self.dynamicSliceRequest
            case "dynamicUpdateSliceRequest": return self.dynamicUpdateSliceRequest
            case "getTupleElementRequest": return self.getTupleElementRequest
            case "infeedRequest": return self.infeedRequest
            case "mapRequest": return self.mapRequest
            case "padRequest": return self.padRequest
            case "parameterRequest": return self.parameterRequest
            case "reduceRequest": return self.reduceRequest
            case "reduceWindowRequest": return self.reduceWindowRequest
            case "reshapeRequest": return self.reshapeRequest
            case "reverseRequest": return self.reverseRequest
            case "rngRequest": return self.rngRequest
            case "selectAndScatterRequest": return self.selectAndScatterRequest
            case "sliceRequest": return self.sliceRequest
            case "ternaryOpRequest": return self.ternaryOpRequest
            case "traceRequest": return self.traceRequest
            case "transposeRequest": return self.transposeRequest
            case "unaryOpRequest": return self.unaryOpRequest
            case "variadicOpRequest": return self.variadicOpRequest
            case "whileRequest": return self.whileRequest
            case "sendRequest": return self.sendRequest
            case "recvRequest": return self.recvRequest
            case "outfeedRequest": return self.outfeedRequest
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "computation":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationHandle else {
                    return
                }
                self.computation = newSubscriptValue
            case "metadata":
                guard let newSubscriptValue = newSubscriptValue as? Xla.OpMetadata else {
                    return
                }
                self.metadata = newSubscriptValue
            case "binaryOpRequest":
                guard let newSubscriptValue = newSubscriptValue as? Xla.BinaryOpRequest else {
                    return
                }
                self.binaryOpRequest = newSubscriptValue
            case "broadcastRequest":
                guard let newSubscriptValue = newSubscriptValue as? Xla.BroadcastRequest else {
                    return
                }
                self.broadcastRequest = newSubscriptValue
            case "callRequest":
                guard let newSubscriptValue = newSubscriptValue as? Xla.CallRequest else {
                    return
                }
                self.callRequest = newSubscriptValue
            case "concatenateRequest":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ConcatenateRequest else {
                    return
                }
                self.concatenateRequest = newSubscriptValue
            case "constantRequest":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ConstantRequest else {
                    return
                }
                self.constantRequest = newSubscriptValue
            case "convertRequest":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ConvertRequest else {
                    return
                }
                self.convertRequest = newSubscriptValue
            case "convolveRequest":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ConvolveRequest else {
                    return
                }
                self.convolveRequest = newSubscriptValue
            case "crossReplicaSumRequest":
                guard let newSubscriptValue = newSubscriptValue as? Xla.CrossReplicaSumRequest else {
                    return
                }
                self.crossReplicaSumRequest = newSubscriptValue
            case "customCallRequest":
                guard let newSubscriptValue = newSubscriptValue as? Xla.CustomCallRequest else {
                    return
                }
                self.customCallRequest = newSubscriptValue
            case "dynamicSliceRequest":
                guard let newSubscriptValue = newSubscriptValue as? Xla.DynamicSliceRequest else {
                    return
                }
                self.dynamicSliceRequest = newSubscriptValue
            case "dynamicUpdateSliceRequest":
                guard let newSubscriptValue = newSubscriptValue as? Xla.DynamicUpdateSliceRequest else {
                    return
                }
                self.dynamicUpdateSliceRequest = newSubscriptValue
            case "getTupleElementRequest":
                guard let newSubscriptValue = newSubscriptValue as? Xla.GetTupleElementRequest else {
                    return
                }
                self.getTupleElementRequest = newSubscriptValue
            case "infeedRequest":
                guard let newSubscriptValue = newSubscriptValue as? Xla.InfeedRequest else {
                    return
                }
                self.infeedRequest = newSubscriptValue
            case "mapRequest":
                guard let newSubscriptValue = newSubscriptValue as? Xla.MapRequest else {
                    return
                }
                self.mapRequest = newSubscriptValue
            case "padRequest":
                guard let newSubscriptValue = newSubscriptValue as? Xla.PadRequest else {
                    return
                }
                self.padRequest = newSubscriptValue
            case "parameterRequest":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ParameterRequest else {
                    return
                }
                self.parameterRequest = newSubscriptValue
            case "reduceRequest":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ReduceRequest else {
                    return
                }
                self.reduceRequest = newSubscriptValue
            case "reduceWindowRequest":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ReduceWindowRequest else {
                    return
                }
                self.reduceWindowRequest = newSubscriptValue
            case "reshapeRequest":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ReshapeRequest else {
                    return
                }
                self.reshapeRequest = newSubscriptValue
            case "reverseRequest":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ReverseRequest else {
                    return
                }
                self.reverseRequest = newSubscriptValue
            case "rngRequest":
                guard let newSubscriptValue = newSubscriptValue as? Xla.RngRequest else {
                    return
                }
                self.rngRequest = newSubscriptValue
            case "selectAndScatterRequest":
                guard let newSubscriptValue = newSubscriptValue as? Xla.SelectAndScatterRequest else {
                    return
                }
                self.selectAndScatterRequest = newSubscriptValue
            case "sliceRequest":
                guard let newSubscriptValue = newSubscriptValue as? Xla.SliceRequest else {
                    return
                }
                self.sliceRequest = newSubscriptValue
            case "ternaryOpRequest":
                guard let newSubscriptValue = newSubscriptValue as? Xla.TernaryOpRequest else {
                    return
                }
                self.ternaryOpRequest = newSubscriptValue
            case "traceRequest":
                guard let newSubscriptValue = newSubscriptValue as? Xla.TraceRequest else {
                    return
                }
                self.traceRequest = newSubscriptValue
            case "transposeRequest":
                guard let newSubscriptValue = newSubscriptValue as? Xla.TransposeRequest else {
                    return
                }
                self.transposeRequest = newSubscriptValue
            case "unaryOpRequest":
                guard let newSubscriptValue = newSubscriptValue as? Xla.UnaryOpRequest else {
                    return
                }
                self.unaryOpRequest = newSubscriptValue
            case "variadicOpRequest":
                guard let newSubscriptValue = newSubscriptValue as? Xla.VariadicOpRequest else {
                    return
                }
                self.variadicOpRequest = newSubscriptValue
            case "whileRequest":
                guard let newSubscriptValue = newSubscriptValue as? Xla.WhileRequest else {
                    return
                }
                self.whileRequest = newSubscriptValue
            case "sendRequest":
                guard let newSubscriptValue = newSubscriptValue as? Xla.SendRequest else {
                    return
                }
                self.sendRequest = newSubscriptValue
            case "recvRequest":
                guard let newSubscriptValue = newSubscriptValue as? Xla.RecvRequest else {
                    return
                }
                self.recvRequest = newSubscriptValue
            case "outfeedRequest":
                guard let newSubscriptValue = newSubscriptValue as? Xla.OutfeedRequest else {
                    return
                }
                self.outfeedRequest = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.OpResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.OpResponse> {
        var mergedArray = Array<Xla.OpResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.OpResponse? {
        return try Xla.OpResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.OpResponse {
        return try Xla.OpResponse.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.OpResponse {
        return try Xla.OpResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.OpResponse {
        return try Xla.OpResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.OpResponse {
        return try Xla.OpResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.OpResponse {
        return try Xla.OpResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.OpResponse {
        return try Xla.OpResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "output": return self.output
        default: return nil
        }
    }
}
extension Xla.OpResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "output": return self.output
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "output":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.output = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "projector_config.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { }

public extension Tensorflow {
    public struct ProjectorConfigRoot {
        public static let `default` = ProjectorConfigRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    final public class SpriteMetadata : GeneratedMessage {

        public static func == (lhs: Tensorflow.SpriteMetadata, rhs: Tensorflow.SpriteMetadata) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasImagePath == rhs.hasImagePath) && (!lhs.hasImagePath || lhs.imagePath == rhs.imagePath)
            fieldCheck = fieldCheck && (lhs.singleImageDim == rhs.singleImageDim)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var imagePath:String = ""
        public fileprivate(set) var hasImagePath:Bool = false

        /// [width, height] of a single image in the sprite.
        public fileprivate(set) var singleImageDim:Array<UInt32> = Array<UInt32>()
        private var singleImageDimMemoizedSerializedSize:Int32 = -1
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasImagePath {
                try codedOutputStream.writeString(fieldNumber: 1, value:imagePath)
            }
            if !singleImageDim.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 18)
                try codedOutputStream.writeRawVarint32(value: singleImageDimMemoizedSerializedSize)
                for oneValuesingleImageDim in singleImageDim {
                    try codedOutputStream.writeUInt32NoTag(value: oneValuesingleImageDim)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasImagePath {
                serialize_size += imagePath.computeStringSize(fieldNumber: 1)
            }
            var dataSizeSingleImageDim:Int32 = 0
            for oneValuesingleImageDim in singleImageDim {
                dataSizeSingleImageDim += oneValuesingleImageDim.computeUInt32SizeNoTag()
            }
            serialize_size += dataSizeSingleImageDim
            if !singleImageDim.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeSingleImageDim.computeInt32SizeNoTag()
            }
            singleImageDimMemoizedSerializedSize = dataSizeSingleImageDim
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.SpriteMetadata.Builder {
            return Tensorflow.SpriteMetadata.classBuilder() as! Tensorflow.SpriteMetadata.Builder
        }
        public func getBuilder() -> Tensorflow.SpriteMetadata.Builder {
            return classBuilder() as! Tensorflow.SpriteMetadata.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.SpriteMetadata.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.SpriteMetadata.Builder()
        }
        public func toBuilder() throws -> Tensorflow.SpriteMetadata.Builder {
            return try Tensorflow.SpriteMetadata.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.SpriteMetadata) throws -> Tensorflow.SpriteMetadata.Builder {
            return try Tensorflow.SpriteMetadata.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasImagePath {
                jsonMap["imagePath"] = imagePath
            }
            if !singleImageDim.isEmpty {
                var jsonArraySingleImageDim:Array<UInt> = []
                for oneValueSingleImageDim in singleImageDim {
                    jsonArraySingleImageDim.append(UInt(oneValueSingleImageDim))
                }
                jsonMap["singleImageDim"] = jsonArraySingleImageDim
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.SpriteMetadata {
            return try Tensorflow.SpriteMetadata.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.SpriteMetadata {
            return try Tensorflow.SpriteMetadata.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasImagePath {
                output += "\(indent) imagePath: \(imagePath) \n"
            }
            var singleImageDimElementIndex:Int = 0
            for oneValueSingleImageDim in singleImageDim  {
                output += "\(indent) singleImageDim[\(singleImageDimElementIndex)]: \(oneValueSingleImageDim)\n"
                singleImageDimElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasImagePath {
                    hashCode = (hashCode &* 31) &+ imagePath.hashValue
                }
                for oneValueSingleImageDim in singleImageDim {
                    hashCode = (hashCode &* 31) &+ oneValueSingleImageDim.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.SpriteMetadata"
        }
        override public func className() -> String {
            return "Tensorflow.SpriteMetadata"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.SpriteMetadata = Tensorflow.SpriteMetadata()
            public func getMessage() -> Tensorflow.SpriteMetadata {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var imagePath:String {
                get {
                    return builderResult.imagePath
                }
                set (value) {
                    builderResult.hasImagePath = true
                    builderResult.imagePath = value
                }
            }
            public var hasImagePath:Bool {
                get {
                    return builderResult.hasImagePath
                }
            }
            @discardableResult
            public func setImagePath(_ value:String) -> Tensorflow.SpriteMetadata.Builder {
                self.imagePath = value
                return self
            }
            @discardableResult
            public func clearImagePath() -> Tensorflow.SpriteMetadata.Builder{
                builderResult.hasImagePath = false
                builderResult.imagePath = ""
                return self
            }
            /// [width, height] of a single image in the sprite.
            public var singleImageDim:Array<UInt32> {
                get {
                    return builderResult.singleImageDim
                }
                set (array) {
                    builderResult.singleImageDim = array
                }
            }
            @discardableResult
            public func setSingleImageDim(_ value:Array<UInt32>) -> Tensorflow.SpriteMetadata.Builder {
                self.singleImageDim = value
                return self
            }
            @discardableResult
            public func clearSingleImageDim() -> Tensorflow.SpriteMetadata.Builder {
                builderResult.singleImageDim.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.SpriteMetadata.Builder {
                builderResult = Tensorflow.SpriteMetadata()
                return self
            }
            override public func clone() throws -> Tensorflow.SpriteMetadata.Builder {
                return try Tensorflow.SpriteMetadata.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.SpriteMetadata {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.SpriteMetadata {
                let returnMe:Tensorflow.SpriteMetadata = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.SpriteMetadata) throws -> Tensorflow.SpriteMetadata.Builder {
                if other == Tensorflow.SpriteMetadata() {
                    return self
                }
                if other.hasImagePath {
                    imagePath = other.imagePath
                }
                if !other.singleImageDim.isEmpty {
                    builderResult.singleImageDim += other.singleImageDim
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.SpriteMetadata.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.SpriteMetadata.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        imagePath = try codedInputStream.readString()

                    case 18:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.singleImageDim.append(try codedInputStream.readUInt32())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.SpriteMetadata.Builder {
                let resultDecodedBuilder = Tensorflow.SpriteMetadata.Builder()
                if let jsonValueImagePath = jsonMap["imagePath"] as? String {
                    resultDecodedBuilder.imagePath = jsonValueImagePath
                }
                if let jsonValueSingleImageDim = jsonMap["singleImageDim"] as? Array<UInt> {
                    var jsonArraySingleImageDim:Array<UInt32> = []
                    for oneValueSingleImageDim in jsonValueSingleImageDim {
                        jsonArraySingleImageDim.append(UInt32(oneValueSingleImageDim))
                    }
                    resultDecodedBuilder.singleImageDim = jsonArraySingleImageDim
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.SpriteMetadata.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.SpriteMetadata.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class EmbeddingInfo : GeneratedMessage {

        public static func == (lhs: Tensorflow.EmbeddingInfo, rhs: Tensorflow.EmbeddingInfo) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasTensorName == rhs.hasTensorName) && (!lhs.hasTensorName || lhs.tensorName == rhs.tensorName)
            fieldCheck = fieldCheck && (lhs.hasMetadataPath == rhs.hasMetadataPath) && (!lhs.hasMetadataPath || lhs.metadataPath == rhs.metadataPath)
            fieldCheck = fieldCheck && (lhs.hasBookmarksPath == rhs.hasBookmarksPath) && (!lhs.hasBookmarksPath || lhs.bookmarksPath == rhs.bookmarksPath)
            fieldCheck = fieldCheck && (lhs.tensorShape == rhs.tensorShape)
            fieldCheck = fieldCheck && (lhs.hasSprite == rhs.hasSprite) && (!lhs.hasSprite || lhs.sprite == rhs.sprite)
            fieldCheck = fieldCheck && (lhs.hasTensorPath == rhs.hasTensorPath) && (!lhs.hasTensorPath || lhs.tensorPath == rhs.tensorPath)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var tensorName:String = ""
        public fileprivate(set) var hasTensorName:Bool = false

        public fileprivate(set) var metadataPath:String = ""
        public fileprivate(set) var hasMetadataPath:Bool = false

        public fileprivate(set) var bookmarksPath:String = ""
        public fileprivate(set) var hasBookmarksPath:Bool = false

        /// Shape of the 2D tensor [N x D]. If missing, it will be inferred from the
        /// model checkpoint.
        public fileprivate(set) var tensorShape:Array<UInt32> = Array<UInt32>()
        private var tensorShapeMemoizedSerializedSize:Int32 = -1
        public fileprivate(set) var sprite:Tensorflow.SpriteMetadata!
        public fileprivate(set) var hasSprite:Bool = false
        /// Path to the TSV file holding the tensor values. If missing, the tensor
        /// is assumed to be stored in the model checkpoint.
        public fileprivate(set) var tensorPath:String = ""
        public fileprivate(set) var hasTensorPath:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasTensorName {
                try codedOutputStream.writeString(fieldNumber: 1, value:tensorName)
            }
            if hasMetadataPath {
                try codedOutputStream.writeString(fieldNumber: 2, value:metadataPath)
            }
            if hasBookmarksPath {
                try codedOutputStream.writeString(fieldNumber: 3, value:bookmarksPath)
            }
            if !tensorShape.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 34)
                try codedOutputStream.writeRawVarint32(value: tensorShapeMemoizedSerializedSize)
                for oneValuetensorShape in tensorShape {
                    try codedOutputStream.writeUInt32NoTag(value: oneValuetensorShape)
                }
            }
            if hasSprite {
                try codedOutputStream.writeMessage(fieldNumber: 5, value:sprite)
            }
            if hasTensorPath {
                try codedOutputStream.writeString(fieldNumber: 6, value:tensorPath)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasTensorName {
                serialize_size += tensorName.computeStringSize(fieldNumber: 1)
            }
            if hasMetadataPath {
                serialize_size += metadataPath.computeStringSize(fieldNumber: 2)
            }
            if hasBookmarksPath {
                serialize_size += bookmarksPath.computeStringSize(fieldNumber: 3)
            }
            var dataSizeTensorShape:Int32 = 0
            for oneValuetensorShape in tensorShape {
                dataSizeTensorShape += oneValuetensorShape.computeUInt32SizeNoTag()
            }
            serialize_size += dataSizeTensorShape
            if !tensorShape.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeTensorShape.computeInt32SizeNoTag()
            }
            tensorShapeMemoizedSerializedSize = dataSizeTensorShape
            if hasSprite {
                if let varSizesprite = sprite?.computeMessageSize(fieldNumber: 5) {
                    serialize_size += varSizesprite
                }
            }
            if hasTensorPath {
                serialize_size += tensorPath.computeStringSize(fieldNumber: 6)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.EmbeddingInfo.Builder {
            return Tensorflow.EmbeddingInfo.classBuilder() as! Tensorflow.EmbeddingInfo.Builder
        }
        public func getBuilder() -> Tensorflow.EmbeddingInfo.Builder {
            return classBuilder() as! Tensorflow.EmbeddingInfo.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.EmbeddingInfo.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.EmbeddingInfo.Builder()
        }
        public func toBuilder() throws -> Tensorflow.EmbeddingInfo.Builder {
            return try Tensorflow.EmbeddingInfo.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.EmbeddingInfo) throws -> Tensorflow.EmbeddingInfo.Builder {
            return try Tensorflow.EmbeddingInfo.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasTensorName {
                jsonMap["tensorName"] = tensorName
            }
            if hasMetadataPath {
                jsonMap["metadataPath"] = metadataPath
            }
            if hasBookmarksPath {
                jsonMap["bookmarksPath"] = bookmarksPath
            }
            if !tensorShape.isEmpty {
                var jsonArrayTensorShape:Array<UInt> = []
                for oneValueTensorShape in tensorShape {
                    jsonArrayTensorShape.append(UInt(oneValueTensorShape))
                }
                jsonMap["tensorShape"] = jsonArrayTensorShape
            }
            if hasSprite {
                jsonMap["sprite"] = try sprite.encode()
            }
            if hasTensorPath {
                jsonMap["tensorPath"] = tensorPath
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.EmbeddingInfo {
            return try Tensorflow.EmbeddingInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.EmbeddingInfo {
            return try Tensorflow.EmbeddingInfo.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasTensorName {
                output += "\(indent) tensorName: \(tensorName) \n"
            }
            if hasMetadataPath {
                output += "\(indent) metadataPath: \(metadataPath) \n"
            }
            if hasBookmarksPath {
                output += "\(indent) bookmarksPath: \(bookmarksPath) \n"
            }
            var tensorShapeElementIndex:Int = 0
            for oneValueTensorShape in tensorShape  {
                output += "\(indent) tensorShape[\(tensorShapeElementIndex)]: \(oneValueTensorShape)\n"
                tensorShapeElementIndex += 1
            }
            if hasSprite {
                output += "\(indent) sprite {\n"
                if let outDescSprite = sprite {
                    output += try outDescSprite.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasTensorPath {
                output += "\(indent) tensorPath: \(tensorPath) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasTensorName {
                    hashCode = (hashCode &* 31) &+ tensorName.hashValue
                }
                if hasMetadataPath {
                    hashCode = (hashCode &* 31) &+ metadataPath.hashValue
                }
                if hasBookmarksPath {
                    hashCode = (hashCode &* 31) &+ bookmarksPath.hashValue
                }
                for oneValueTensorShape in tensorShape {
                    hashCode = (hashCode &* 31) &+ oneValueTensorShape.hashValue
                }
                if hasSprite {
                    if let hashValuesprite = sprite?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuesprite
                    }
                }
                if hasTensorPath {
                    hashCode = (hashCode &* 31) &+ tensorPath.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.EmbeddingInfo"
        }
        override public func className() -> String {
            return "Tensorflow.EmbeddingInfo"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.EmbeddingInfo = Tensorflow.EmbeddingInfo()
            public func getMessage() -> Tensorflow.EmbeddingInfo {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var tensorName:String {
                get {
                    return builderResult.tensorName
                }
                set (value) {
                    builderResult.hasTensorName = true
                    builderResult.tensorName = value
                }
            }
            public var hasTensorName:Bool {
                get {
                    return builderResult.hasTensorName
                }
            }
            @discardableResult
            public func setTensorName(_ value:String) -> Tensorflow.EmbeddingInfo.Builder {
                self.tensorName = value
                return self
            }
            @discardableResult
            public func clearTensorName() -> Tensorflow.EmbeddingInfo.Builder{
                builderResult.hasTensorName = false
                builderResult.tensorName = ""
                return self
            }
            public var metadataPath:String {
                get {
                    return builderResult.metadataPath
                }
                set (value) {
                    builderResult.hasMetadataPath = true
                    builderResult.metadataPath = value
                }
            }
            public var hasMetadataPath:Bool {
                get {
                    return builderResult.hasMetadataPath
                }
            }
            @discardableResult
            public func setMetadataPath(_ value:String) -> Tensorflow.EmbeddingInfo.Builder {
                self.metadataPath = value
                return self
            }
            @discardableResult
            public func clearMetadataPath() -> Tensorflow.EmbeddingInfo.Builder{
                builderResult.hasMetadataPath = false
                builderResult.metadataPath = ""
                return self
            }
            public var bookmarksPath:String {
                get {
                    return builderResult.bookmarksPath
                }
                set (value) {
                    builderResult.hasBookmarksPath = true
                    builderResult.bookmarksPath = value
                }
            }
            public var hasBookmarksPath:Bool {
                get {
                    return builderResult.hasBookmarksPath
                }
            }
            @discardableResult
            public func setBookmarksPath(_ value:String) -> Tensorflow.EmbeddingInfo.Builder {
                self.bookmarksPath = value
                return self
            }
            @discardableResult
            public func clearBookmarksPath() -> Tensorflow.EmbeddingInfo.Builder{
                builderResult.hasBookmarksPath = false
                builderResult.bookmarksPath = ""
                return self
            }
            /// Shape of the 2D tensor [N x D]. If missing, it will be inferred from the
            /// model checkpoint.
            public var tensorShape:Array<UInt32> {
                get {
                    return builderResult.tensorShape
                }
                set (array) {
                    builderResult.tensorShape = array
                }
            }
            @discardableResult
            public func setTensorShape(_ value:Array<UInt32>) -> Tensorflow.EmbeddingInfo.Builder {
                self.tensorShape = value
                return self
            }
            @discardableResult
            public func clearTensorShape() -> Tensorflow.EmbeddingInfo.Builder {
                builderResult.tensorShape.removeAll(keepingCapacity: false)
                return self
            }
            public var sprite:Tensorflow.SpriteMetadata! {
                get {
                    if spriteBuilder_ != nil {
                        builderResult.sprite = spriteBuilder_.getMessage()
                    }
                    return builderResult.sprite
                }
                set (value) {
                    builderResult.hasSprite = true
                    builderResult.sprite = value
                }
            }
            public var hasSprite:Bool {
                get {
                    return builderResult.hasSprite
                }
            }
            fileprivate var spriteBuilder_:Tensorflow.SpriteMetadata.Builder! {
                didSet {
                    builderResult.hasSprite = true
                }
            }
            public func getSpriteBuilder() -> Tensorflow.SpriteMetadata.Builder {
                if spriteBuilder_ == nil {
                    spriteBuilder_ = Tensorflow.SpriteMetadata.Builder()
                    builderResult.sprite = spriteBuilder_.getMessage()
                    if sprite != nil {
                        try! spriteBuilder_.mergeFrom(other: sprite)
                    }
                }
                return spriteBuilder_
            }
            @discardableResult
            public func setSprite(_ value:Tensorflow.SpriteMetadata!) -> Tensorflow.EmbeddingInfo.Builder {
                self.sprite = value
                return self
            }
            @discardableResult
            public func mergeSprite(value:Tensorflow.SpriteMetadata) throws -> Tensorflow.EmbeddingInfo.Builder {
                if builderResult.hasSprite {
                    builderResult.sprite = try Tensorflow.SpriteMetadata.builderWithPrototype(prototype:builderResult.sprite).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.sprite = value
                }
                builderResult.hasSprite = true
                return self
            }
            @discardableResult
            public func clearSprite() -> Tensorflow.EmbeddingInfo.Builder {
                spriteBuilder_ = nil
                builderResult.hasSprite = false
                builderResult.sprite = nil
                return self
            }
            /// Path to the TSV file holding the tensor values. If missing, the tensor
            /// is assumed to be stored in the model checkpoint.
            public var tensorPath:String {
                get {
                    return builderResult.tensorPath
                }
                set (value) {
                    builderResult.hasTensorPath = true
                    builderResult.tensorPath = value
                }
            }
            public var hasTensorPath:Bool {
                get {
                    return builderResult.hasTensorPath
                }
            }
            @discardableResult
            public func setTensorPath(_ value:String) -> Tensorflow.EmbeddingInfo.Builder {
                self.tensorPath = value
                return self
            }
            @discardableResult
            public func clearTensorPath() -> Tensorflow.EmbeddingInfo.Builder{
                builderResult.hasTensorPath = false
                builderResult.tensorPath = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.EmbeddingInfo.Builder {
                builderResult = Tensorflow.EmbeddingInfo()
                return self
            }
            override public func clone() throws -> Tensorflow.EmbeddingInfo.Builder {
                return try Tensorflow.EmbeddingInfo.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.EmbeddingInfo {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.EmbeddingInfo {
                let returnMe:Tensorflow.EmbeddingInfo = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.EmbeddingInfo) throws -> Tensorflow.EmbeddingInfo.Builder {
                if other == Tensorflow.EmbeddingInfo() {
                    return self
                }
                if other.hasTensorName {
                    tensorName = other.tensorName
                }
                if other.hasMetadataPath {
                    metadataPath = other.metadataPath
                }
                if other.hasBookmarksPath {
                    bookmarksPath = other.bookmarksPath
                }
                if !other.tensorShape.isEmpty {
                    builderResult.tensorShape += other.tensorShape
                }
                if (other.hasSprite) {
                    try mergeSprite(value: other.sprite)
                }
                if other.hasTensorPath {
                    tensorPath = other.tensorPath
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.EmbeddingInfo.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.EmbeddingInfo.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        tensorName = try codedInputStream.readString()

                    case 18:
                        metadataPath = try codedInputStream.readString()

                    case 26:
                        bookmarksPath = try codedInputStream.readString()

                    case 34:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.tensorShape.append(try codedInputStream.readUInt32())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 42:
                        let subBuilder:Tensorflow.SpriteMetadata.Builder = Tensorflow.SpriteMetadata.Builder()
                        if hasSprite {
                            try subBuilder.mergeFrom(other: sprite)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        sprite = subBuilder.buildPartial()

                    case 50:
                        tensorPath = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.EmbeddingInfo.Builder {
                let resultDecodedBuilder = Tensorflow.EmbeddingInfo.Builder()
                if let jsonValueTensorName = jsonMap["tensorName"] as? String {
                    resultDecodedBuilder.tensorName = jsonValueTensorName
                }
                if let jsonValueMetadataPath = jsonMap["metadataPath"] as? String {
                    resultDecodedBuilder.metadataPath = jsonValueMetadataPath
                }
                if let jsonValueBookmarksPath = jsonMap["bookmarksPath"] as? String {
                    resultDecodedBuilder.bookmarksPath = jsonValueBookmarksPath
                }
                if let jsonValueTensorShape = jsonMap["tensorShape"] as? Array<UInt> {
                    var jsonArrayTensorShape:Array<UInt32> = []
                    for oneValueTensorShape in jsonValueTensorShape {
                        jsonArrayTensorShape.append(UInt32(oneValueTensorShape))
                    }
                    resultDecodedBuilder.tensorShape = jsonArrayTensorShape
                }
                if let jsonValueSprite = jsonMap["sprite"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.sprite = try Tensorflow.SpriteMetadata.Builder.decodeToBuilder(jsonMap:jsonValueSprite).build()

                }
                if let jsonValueTensorPath = jsonMap["tensorPath"] as? String {
                    resultDecodedBuilder.tensorPath = jsonValueTensorPath
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.EmbeddingInfo.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.EmbeddingInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ProjectorConfig : GeneratedMessage {

        public static func == (lhs: Tensorflow.ProjectorConfig, rhs: Tensorflow.ProjectorConfig) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasModelCheckpointPath == rhs.hasModelCheckpointPath) && (!lhs.hasModelCheckpointPath || lhs.modelCheckpointPath == rhs.modelCheckpointPath)
            fieldCheck = fieldCheck && (lhs.embeddings == rhs.embeddings)
            fieldCheck = fieldCheck && (lhs.hasModelCheckpointDir == rhs.hasModelCheckpointDir) && (!lhs.hasModelCheckpointDir || lhs.modelCheckpointDir == rhs.modelCheckpointDir)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Path to the checkpoint file. Use either this or model_checkpoint_dir.
        public fileprivate(set) var modelCheckpointPath:String = ""
        public fileprivate(set) var hasModelCheckpointPath:Bool = false

        public fileprivate(set) var embeddings:Array<Tensorflow.EmbeddingInfo>  = Array<Tensorflow.EmbeddingInfo>()
        /// Path to the checkpoint directory. The directory will be scanned for the
        /// latest checkpoint file.
        public fileprivate(set) var modelCheckpointDir:String = ""
        public fileprivate(set) var hasModelCheckpointDir:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasModelCheckpointPath {
                try codedOutputStream.writeString(fieldNumber: 1, value:modelCheckpointPath)
            }
            for oneElementEmbeddings in embeddings {
                  try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementEmbeddings)
            }
            if hasModelCheckpointDir {
                try codedOutputStream.writeString(fieldNumber: 3, value:modelCheckpointDir)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasModelCheckpointPath {
                serialize_size += modelCheckpointPath.computeStringSize(fieldNumber: 1)
            }
            for oneElementEmbeddings in embeddings {
                serialize_size += oneElementEmbeddings.computeMessageSize(fieldNumber: 2)
            }
            if hasModelCheckpointDir {
                serialize_size += modelCheckpointDir.computeStringSize(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.ProjectorConfig.Builder {
            return Tensorflow.ProjectorConfig.classBuilder() as! Tensorflow.ProjectorConfig.Builder
        }
        public func getBuilder() -> Tensorflow.ProjectorConfig.Builder {
            return classBuilder() as! Tensorflow.ProjectorConfig.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.ProjectorConfig.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.ProjectorConfig.Builder()
        }
        public func toBuilder() throws -> Tensorflow.ProjectorConfig.Builder {
            return try Tensorflow.ProjectorConfig.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.ProjectorConfig) throws -> Tensorflow.ProjectorConfig.Builder {
            return try Tensorflow.ProjectorConfig.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasModelCheckpointPath {
                jsonMap["modelCheckpointPath"] = modelCheckpointPath
            }
            if !embeddings.isEmpty {
                var jsonArrayEmbeddings:Array<Dictionary<String,Any>> = []
                for oneValueEmbeddings in embeddings {
                    let ecodedMessageEmbeddings = try oneValueEmbeddings.encode()
                    jsonArrayEmbeddings.append(ecodedMessageEmbeddings)
                }
                jsonMap["embeddings"] = jsonArrayEmbeddings
            }
            if hasModelCheckpointDir {
                jsonMap["modelCheckpointDir"] = modelCheckpointDir
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.ProjectorConfig {
            return try Tensorflow.ProjectorConfig.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.ProjectorConfig {
            return try Tensorflow.ProjectorConfig.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasModelCheckpointPath {
                output += "\(indent) modelCheckpointPath: \(modelCheckpointPath) \n"
            }
            var embeddingsElementIndex:Int = 0
            for oneElementEmbeddings in embeddings {
                output += "\(indent) embeddings[\(embeddingsElementIndex)] {\n"
                output += try oneElementEmbeddings.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                embeddingsElementIndex += 1
            }
            if hasModelCheckpointDir {
                output += "\(indent) modelCheckpointDir: \(modelCheckpointDir) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasModelCheckpointPath {
                    hashCode = (hashCode &* 31) &+ modelCheckpointPath.hashValue
                }
                for oneElementEmbeddings in embeddings {
                    hashCode = (hashCode &* 31) &+ oneElementEmbeddings.hashValue
                }
                if hasModelCheckpointDir {
                    hashCode = (hashCode &* 31) &+ modelCheckpointDir.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.ProjectorConfig"
        }
        override public func className() -> String {
            return "Tensorflow.ProjectorConfig"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.ProjectorConfig = Tensorflow.ProjectorConfig()
            public func getMessage() -> Tensorflow.ProjectorConfig {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Path to the checkpoint file. Use either this or model_checkpoint_dir.
            public var modelCheckpointPath:String {
                get {
                    return builderResult.modelCheckpointPath
                }
                set (value) {
                    builderResult.hasModelCheckpointPath = true
                    builderResult.modelCheckpointPath = value
                }
            }
            public var hasModelCheckpointPath:Bool {
                get {
                    return builderResult.hasModelCheckpointPath
                }
            }
            @discardableResult
            public func setModelCheckpointPath(_ value:String) -> Tensorflow.ProjectorConfig.Builder {
                self.modelCheckpointPath = value
                return self
            }
            @discardableResult
            public func clearModelCheckpointPath() -> Tensorflow.ProjectorConfig.Builder{
                builderResult.hasModelCheckpointPath = false
                builderResult.modelCheckpointPath = ""
                return self
            }
            public var embeddings:Array<Tensorflow.EmbeddingInfo> {
                get {
                    return builderResult.embeddings
                }
                set (value) {
                    builderResult.embeddings = value
                }
            }
            @discardableResult
            public func setEmbeddings(_ value:Array<Tensorflow.EmbeddingInfo>) -> Tensorflow.ProjectorConfig.Builder {
                self.embeddings = value
                return self
            }
            @discardableResult
            public func clearEmbeddings() -> Tensorflow.ProjectorConfig.Builder {
                builderResult.embeddings.removeAll(keepingCapacity: false)
                return self
            }
            /// Path to the checkpoint directory. The directory will be scanned for the
            /// latest checkpoint file.
            public var modelCheckpointDir:String {
                get {
                    return builderResult.modelCheckpointDir
                }
                set (value) {
                    builderResult.hasModelCheckpointDir = true
                    builderResult.modelCheckpointDir = value
                }
            }
            public var hasModelCheckpointDir:Bool {
                get {
                    return builderResult.hasModelCheckpointDir
                }
            }
            @discardableResult
            public func setModelCheckpointDir(_ value:String) -> Tensorflow.ProjectorConfig.Builder {
                self.modelCheckpointDir = value
                return self
            }
            @discardableResult
            public func clearModelCheckpointDir() -> Tensorflow.ProjectorConfig.Builder{
                builderResult.hasModelCheckpointDir = false
                builderResult.modelCheckpointDir = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.ProjectorConfig.Builder {
                builderResult = Tensorflow.ProjectorConfig()
                return self
            }
            override public func clone() throws -> Tensorflow.ProjectorConfig.Builder {
                return try Tensorflow.ProjectorConfig.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.ProjectorConfig {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.ProjectorConfig {
                let returnMe:Tensorflow.ProjectorConfig = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.ProjectorConfig) throws -> Tensorflow.ProjectorConfig.Builder {
                if other == Tensorflow.ProjectorConfig() {
                    return self
                }
                if other.hasModelCheckpointPath {
                    modelCheckpointPath = other.modelCheckpointPath
                }
                if !other.embeddings.isEmpty  {
                     builderResult.embeddings += other.embeddings
                }
                if other.hasModelCheckpointDir {
                    modelCheckpointDir = other.modelCheckpointDir
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.ProjectorConfig.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ProjectorConfig.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        modelCheckpointPath = try codedInputStream.readString()

                    case 18:
                        let subBuilder = Tensorflow.EmbeddingInfo.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        embeddings.append(subBuilder.buildPartial())

                    case 26:
                        modelCheckpointDir = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.ProjectorConfig.Builder {
                let resultDecodedBuilder = Tensorflow.ProjectorConfig.Builder()
                if let jsonValueModelCheckpointPath = jsonMap["modelCheckpointPath"] as? String {
                    resultDecodedBuilder.modelCheckpointPath = jsonValueModelCheckpointPath
                }
                if let jsonValueEmbeddings = jsonMap["embeddings"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayEmbeddings:Array<Tensorflow.EmbeddingInfo> = []
                    for oneValueEmbeddings in jsonValueEmbeddings {
                        let messageFromStringEmbeddings = try Tensorflow.EmbeddingInfo.Builder.decodeToBuilder(jsonMap:oneValueEmbeddings).build()

                        jsonArrayEmbeddings.append(messageFromStringEmbeddings)
                    }
                    resultDecodedBuilder.embeddings = jsonArrayEmbeddings
                }
                if let jsonValueModelCheckpointDir = jsonMap["modelCheckpointDir"] as? String {
                    resultDecodedBuilder.modelCheckpointDir = jsonValueModelCheckpointDir
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.ProjectorConfig.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.ProjectorConfig.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.SpriteMetadata: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.SpriteMetadata> {
        var mergedArray = Array<Tensorflow.SpriteMetadata>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.SpriteMetadata? {
        return try Tensorflow.SpriteMetadata.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.SpriteMetadata {
        return try Tensorflow.SpriteMetadata.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.ProjectorConfigRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.SpriteMetadata {
        return try Tensorflow.SpriteMetadata.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.SpriteMetadata {
        return try Tensorflow.SpriteMetadata.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.SpriteMetadata {
        return try Tensorflow.SpriteMetadata.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.SpriteMetadata {
        return try Tensorflow.SpriteMetadata.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.SpriteMetadata {
        return try Tensorflow.SpriteMetadata.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "imagePath": return self.imagePath
        case "singleImageDim": return self.singleImageDim
        default: return nil
        }
    }
}
extension Tensorflow.SpriteMetadata.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "imagePath": return self.imagePath
            case "singleImageDim": return self.singleImageDim
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "imagePath":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.imagePath = newSubscriptValue
            case "singleImageDim":
                guard let newSubscriptValue = newSubscriptValue as? Array<UInt32> else {
                    return
                }
                self.singleImageDim = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.EmbeddingInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.EmbeddingInfo> {
        var mergedArray = Array<Tensorflow.EmbeddingInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.EmbeddingInfo? {
        return try Tensorflow.EmbeddingInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.EmbeddingInfo {
        return try Tensorflow.EmbeddingInfo.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.ProjectorConfigRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.EmbeddingInfo {
        return try Tensorflow.EmbeddingInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.EmbeddingInfo {
        return try Tensorflow.EmbeddingInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.EmbeddingInfo {
        return try Tensorflow.EmbeddingInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.EmbeddingInfo {
        return try Tensorflow.EmbeddingInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.EmbeddingInfo {
        return try Tensorflow.EmbeddingInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "tensorName": return self.tensorName
        case "metadataPath": return self.metadataPath
        case "bookmarksPath": return self.bookmarksPath
        case "tensorShape": return self.tensorShape
        case "sprite": return self.sprite
        case "tensorPath": return self.tensorPath
        default: return nil
        }
    }
}
extension Tensorflow.EmbeddingInfo.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "tensorName": return self.tensorName
            case "metadataPath": return self.metadataPath
            case "bookmarksPath": return self.bookmarksPath
            case "tensorShape": return self.tensorShape
            case "sprite": return self.sprite
            case "tensorPath": return self.tensorPath
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "tensorName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.tensorName = newSubscriptValue
            case "metadataPath":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.metadataPath = newSubscriptValue
            case "bookmarksPath":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.bookmarksPath = newSubscriptValue
            case "tensorShape":
                guard let newSubscriptValue = newSubscriptValue as? Array<UInt32> else {
                    return
                }
                self.tensorShape = newSubscriptValue
            case "sprite":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.SpriteMetadata else {
                    return
                }
                self.sprite = newSubscriptValue
            case "tensorPath":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.tensorPath = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.ProjectorConfig: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.ProjectorConfig> {
        var mergedArray = Array<Tensorflow.ProjectorConfig>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.ProjectorConfig? {
        return try Tensorflow.ProjectorConfig.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.ProjectorConfig {
        return try Tensorflow.ProjectorConfig.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.ProjectorConfigRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ProjectorConfig {
        return try Tensorflow.ProjectorConfig.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.ProjectorConfig {
        return try Tensorflow.ProjectorConfig.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ProjectorConfig {
        return try Tensorflow.ProjectorConfig.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.ProjectorConfig {
        return try Tensorflow.ProjectorConfig.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ProjectorConfig {
        return try Tensorflow.ProjectorConfig.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "modelCheckpointPath": return self.modelCheckpointPath
        case "embeddings": return self.embeddings
        case "modelCheckpointDir": return self.modelCheckpointDir
        default: return nil
        }
    }
}
extension Tensorflow.ProjectorConfig.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "modelCheckpointPath": return self.modelCheckpointPath
            case "embeddings": return self.embeddings
            case "modelCheckpointDir": return self.modelCheckpointDir
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "modelCheckpointPath":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.modelCheckpointPath = newSubscriptValue
            case "embeddings":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.EmbeddingInfo> else {
                    return
                }
                self.embeddings = newSubscriptValue
            case "modelCheckpointDir":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.modelCheckpointDir = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

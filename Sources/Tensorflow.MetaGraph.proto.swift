/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "meta_graph.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { }

public extension Tensorflow {
    public struct MetaGraphRoot {
        public static let `default` = MetaGraphRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Google.Protobuf.AnyRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.GraphRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.OpDefRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.TensorShapeRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.TypesRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.SaverRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    /// NOTE: This protocol buffer is evolving, and will go through revisions in the
    /// coming months.
    /// Protocol buffer containing the following which are necessary to restart
    /// training, run inference. It can be used to serialize/de-serialize memory
    /// objects necessary for running computation in a graph when crossing the
    /// process boundary. It can be used for long term storage of graphs,
    /// cross-language execution of graphs, etc.
    ///   MetaInfoDef
    ///   GraphDef
    ///   SaverDef
    ///   CollectionDef
    ///   TensorInfo
    ///   SignatureDef
    final public class MetaGraphDef : GeneratedMessage {

        public static func == (lhs: Tensorflow.MetaGraphDef, rhs: Tensorflow.MetaGraphDef) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasMetaInfoDef == rhs.hasMetaInfoDef) && (!lhs.hasMetaInfoDef || lhs.metaInfoDef == rhs.metaInfoDef)
            fieldCheck = fieldCheck && (lhs.hasGraphDef == rhs.hasGraphDef) && (!lhs.hasGraphDef || lhs.graphDef == rhs.graphDef)
            fieldCheck = fieldCheck && (lhs.hasSaverDef == rhs.hasSaverDef) && (!lhs.hasSaverDef || lhs.saverDef == rhs.saverDef)
            fieldCheck = fieldCheck && (lhs.hasCollectionDef == rhs.hasCollectionDef) && (!lhs.hasCollectionDef || lhs.collectionDef == rhs.collectionDef)
            fieldCheck = fieldCheck && (lhs.hasSignatureDef == rhs.hasSignatureDef) && (!lhs.hasSignatureDef || lhs.signatureDef == rhs.signatureDef)
            fieldCheck = fieldCheck && (lhs.assetFileDef == rhs.assetFileDef)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        /// Meta information regarding the graph to be exported.  To be used by users
        /// of this protocol buffer to encode information regarding their meta graph.
        final public class MetaInfoDef : GeneratedMessage {

            public static func == (lhs: Tensorflow.MetaGraphDef.MetaInfoDef, rhs: Tensorflow.MetaGraphDef.MetaInfoDef) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasMetaGraphVersion == rhs.hasMetaGraphVersion) && (!lhs.hasMetaGraphVersion || lhs.metaGraphVersion == rhs.metaGraphVersion)
                fieldCheck = fieldCheck && (lhs.hasStrippedOpList == rhs.hasStrippedOpList) && (!lhs.hasStrippedOpList || lhs.strippedOpList == rhs.strippedOpList)
                fieldCheck = fieldCheck && (lhs.hasAnyInfo == rhs.hasAnyInfo) && (!lhs.hasAnyInfo || lhs.anyInfo == rhs.anyInfo)
                fieldCheck = fieldCheck && (lhs.tags == rhs.tags)
                fieldCheck = fieldCheck && (lhs.hasTensorflowVersion == rhs.hasTensorflowVersion) && (!lhs.hasTensorflowVersion || lhs.tensorflowVersion == rhs.tensorflowVersion)
                fieldCheck = fieldCheck && (lhs.hasTensorflowGitVersion == rhs.hasTensorflowGitVersion) && (!lhs.hasTensorflowGitVersion || lhs.tensorflowGitVersion == rhs.tensorflowGitVersion)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            /// User specified Version string. Can be the name of the model and revision,
            /// steps this model has been trained to, etc.
            public fileprivate(set) var metaGraphVersion:String = ""
            public fileprivate(set) var hasMetaGraphVersion:Bool = false

            public fileprivate(set) var strippedOpList:Tensorflow.OpList!
            public fileprivate(set) var hasStrippedOpList:Bool = false
            public fileprivate(set) var anyInfo:Google.Protobuf.`Any`!
            public fileprivate(set) var hasAnyInfo:Bool = false
            /// User supplied tag(s) on the meta_graph and included graph_def.
            /// MetaGraphDefs should be tagged with their capabilities or use-cases.
            /// Examples: "train", "serve", "gpu", "tpu", etc.
            /// These tags enable loaders to access the MetaGraph(s) appropriate for a
            /// specific use-case or runtime environment.
            public fileprivate(set) var tags:Array<String> = Array<String>()
            /// The __version__ string of the tensorflow build used to write this graph.
            /// This will be populated by the framework, which will overwrite any user
            /// supplied value.
            public fileprivate(set) var tensorflowVersion:String = ""
            public fileprivate(set) var hasTensorflowVersion:Bool = false

            /// The __git_version__ string of the tensorflow build used to write this
            /// graph. This will be populated by the framework, which will overwrite any
            /// user supplied value.
            public fileprivate(set) var tensorflowGitVersion:String = ""
            public fileprivate(set) var hasTensorflowGitVersion:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasMetaGraphVersion {
                    try codedOutputStream.writeString(fieldNumber: 1, value:metaGraphVersion)
                }
                if hasStrippedOpList {
                    try codedOutputStream.writeMessage(fieldNumber: 2, value:strippedOpList)
                }
                if hasAnyInfo {
                    try codedOutputStream.writeMessage(fieldNumber: 3, value:anyInfo)
                }
                if !tags.isEmpty {
                    for oneValuetags in tags {
                        try codedOutputStream.writeString(fieldNumber: 4, value:oneValuetags)
                    }
                }
                if hasTensorflowVersion {
                    try codedOutputStream.writeString(fieldNumber: 5, value:tensorflowVersion)
                }
                if hasTensorflowGitVersion {
                    try codedOutputStream.writeString(fieldNumber: 6, value:tensorflowGitVersion)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasMetaGraphVersion {
                    serialize_size += metaGraphVersion.computeStringSize(fieldNumber: 1)
                }
                if hasStrippedOpList {
                    if let varSizestrippedOpList = strippedOpList?.computeMessageSize(fieldNumber: 2) {
                        serialize_size += varSizestrippedOpList
                    }
                }
                if hasAnyInfo {
                    if let varSizeanyInfo = anyInfo?.computeMessageSize(fieldNumber: 3) {
                        serialize_size += varSizeanyInfo
                    }
                }
                var dataSizeTags:Int32 = 0
                for oneValuetags in tags {
                    dataSizeTags += oneValuetags.computeStringSizeNoTag()
                }
                serialize_size += dataSizeTags
                serialize_size += 1 * Int32(tags.count)
                if hasTensorflowVersion {
                    serialize_size += tensorflowVersion.computeStringSize(fieldNumber: 5)
                }
                if hasTensorflowGitVersion {
                    serialize_size += tensorflowGitVersion.computeStringSize(fieldNumber: 6)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.MetaGraphDef.MetaInfoDef.Builder {
                return Tensorflow.MetaGraphDef.MetaInfoDef.classBuilder() as! Tensorflow.MetaGraphDef.MetaInfoDef.Builder
            }
            public func getBuilder() -> Tensorflow.MetaGraphDef.MetaInfoDef.Builder {
                return classBuilder() as! Tensorflow.MetaGraphDef.MetaInfoDef.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.MetaGraphDef.MetaInfoDef.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.MetaGraphDef.MetaInfoDef.Builder()
            }
            public func toBuilder() throws -> Tensorflow.MetaGraphDef.MetaInfoDef.Builder {
                return try Tensorflow.MetaGraphDef.MetaInfoDef.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.MetaGraphDef.MetaInfoDef) throws -> Tensorflow.MetaGraphDef.MetaInfoDef.Builder {
                return try Tensorflow.MetaGraphDef.MetaInfoDef.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasMetaGraphVersion {
                    jsonMap["metaGraphVersion"] = metaGraphVersion
                }
                if hasStrippedOpList {
                    jsonMap["strippedOpList"] = try strippedOpList.encode()
                }
                if hasAnyInfo {
                    jsonMap["anyInfo"] = try anyInfo.encode()
                }
                if !tags.isEmpty {
                    var jsonArrayTags:Array<String> = []
                    for oneValueTags in tags {
                        jsonArrayTags.append(oneValueTags)
                    }
                    jsonMap["tags"] = jsonArrayTags
                }
                if hasTensorflowVersion {
                    jsonMap["tensorflowVersion"] = tensorflowVersion
                }
                if hasTensorflowGitVersion {
                    jsonMap["tensorflowGitVersion"] = tensorflowGitVersion
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.MetaGraphDef.MetaInfoDef {
                return try Tensorflow.MetaGraphDef.MetaInfoDef.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.MetaGraphDef.MetaInfoDef {
                return try Tensorflow.MetaGraphDef.MetaInfoDef.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasMetaGraphVersion {
                    output += "\(indent) metaGraphVersion: \(metaGraphVersion) \n"
                }
                if hasStrippedOpList {
                    output += "\(indent) strippedOpList {\n"
                    if let outDescStrippedOpList = strippedOpList {
                        output += try outDescStrippedOpList.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                if hasAnyInfo {
                    output += "\(indent) anyInfo {\n"
                    if let outDescAnyInfo = anyInfo {
                        output += try outDescAnyInfo.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                var tagsElementIndex:Int = 0
                for oneValueTags in tags  {
                    output += "\(indent) tags[\(tagsElementIndex)]: \(oneValueTags)\n"
                    tagsElementIndex += 1
                }
                if hasTensorflowVersion {
                    output += "\(indent) tensorflowVersion: \(tensorflowVersion) \n"
                }
                if hasTensorflowGitVersion {
                    output += "\(indent) tensorflowGitVersion: \(tensorflowGitVersion) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasMetaGraphVersion {
                        hashCode = (hashCode &* 31) &+ metaGraphVersion.hashValue
                    }
                    if hasStrippedOpList {
                        if let hashValuestrippedOpList = strippedOpList?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuestrippedOpList
                        }
                    }
                    if hasAnyInfo {
                        if let hashValueanyInfo = anyInfo?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValueanyInfo
                        }
                    }
                    for oneValueTags in tags {
                        hashCode = (hashCode &* 31) &+ oneValueTags.hashValue
                    }
                    if hasTensorflowVersion {
                        hashCode = (hashCode &* 31) &+ tensorflowVersion.hashValue
                    }
                    if hasTensorflowGitVersion {
                        hashCode = (hashCode &* 31) &+ tensorflowGitVersion.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.MetaGraphDef.MetaInfoDef"
            }
            override public func className() -> String {
                return "Tensorflow.MetaGraphDef.MetaInfoDef"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.MetaGraphDef.MetaInfoDef = Tensorflow.MetaGraphDef.MetaInfoDef()
                public func getMessage() -> Tensorflow.MetaGraphDef.MetaInfoDef {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                /// User specified Version string. Can be the name of the model and revision,
                /// steps this model has been trained to, etc.
                public var metaGraphVersion:String {
                    get {
                        return builderResult.metaGraphVersion
                    }
                    set (value) {
                        builderResult.hasMetaGraphVersion = true
                        builderResult.metaGraphVersion = value
                    }
                }
                public var hasMetaGraphVersion:Bool {
                    get {
                        return builderResult.hasMetaGraphVersion
                    }
                }
                @discardableResult
                public func setMetaGraphVersion(_ value:String) -> Tensorflow.MetaGraphDef.MetaInfoDef.Builder {
                    self.metaGraphVersion = value
                    return self
                }
                @discardableResult
                public func clearMetaGraphVersion() -> Tensorflow.MetaGraphDef.MetaInfoDef.Builder{
                    builderResult.hasMetaGraphVersion = false
                    builderResult.metaGraphVersion = ""
                    return self
                }
                /// A copy of the OpDefs used by the producer of this graph_def.
                /// Descriptions and Ops not used in graph_def are stripped out.
                public var strippedOpList:Tensorflow.OpList! {
                    get {
                        if strippedOpListBuilder_ != nil {
                            builderResult.strippedOpList = strippedOpListBuilder_.getMessage()
                        }
                        return builderResult.strippedOpList
                    }
                    set (value) {
                        builderResult.hasStrippedOpList = true
                        builderResult.strippedOpList = value
                    }
                }
                public var hasStrippedOpList:Bool {
                    get {
                        return builderResult.hasStrippedOpList
                    }
                }
                fileprivate var strippedOpListBuilder_:Tensorflow.OpList.Builder! {
                    didSet {
                        builderResult.hasStrippedOpList = true
                    }
                }
                public func getStrippedOpListBuilder() -> Tensorflow.OpList.Builder {
                    if strippedOpListBuilder_ == nil {
                        strippedOpListBuilder_ = Tensorflow.OpList.Builder()
                        builderResult.strippedOpList = strippedOpListBuilder_.getMessage()
                        if strippedOpList != nil {
                            try! strippedOpListBuilder_.mergeFrom(other: strippedOpList)
                        }
                    }
                    return strippedOpListBuilder_
                }
                @discardableResult
                public func setStrippedOpList(_ value:Tensorflow.OpList!) -> Tensorflow.MetaGraphDef.MetaInfoDef.Builder {
                    self.strippedOpList = value
                    return self
                }
                @discardableResult
                public func mergeStrippedOpList(value:Tensorflow.OpList) throws -> Tensorflow.MetaGraphDef.MetaInfoDef.Builder {
                    if builderResult.hasStrippedOpList {
                        builderResult.strippedOpList = try Tensorflow.OpList.builderWithPrototype(prototype:builderResult.strippedOpList).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.strippedOpList = value
                    }
                    builderResult.hasStrippedOpList = true
                    return self
                }
                @discardableResult
                public func clearStrippedOpList() -> Tensorflow.MetaGraphDef.MetaInfoDef.Builder {
                    strippedOpListBuilder_ = nil
                    builderResult.hasStrippedOpList = false
                    builderResult.strippedOpList = nil
                    return self
                }
                /// A serialized protobuf. Can be the time this meta graph is created, or
                /// modified, or name of the model.
                public var anyInfo:Google.Protobuf.`Any`! {
                    get {
                        if anyInfoBuilder_ != nil {
                            builderResult.anyInfo = anyInfoBuilder_.getMessage()
                        }
                        return builderResult.anyInfo
                    }
                    set (value) {
                        builderResult.hasAnyInfo = true
                        builderResult.anyInfo = value
                    }
                }
                public var hasAnyInfo:Bool {
                    get {
                        return builderResult.hasAnyInfo
                    }
                }
                fileprivate var anyInfoBuilder_:Google.Protobuf.`Any`.Builder! {
                    didSet {
                        builderResult.hasAnyInfo = true
                    }
                }
                public func getAnyInfoBuilder() -> Google.Protobuf.`Any`.Builder {
                    if anyInfoBuilder_ == nil {
                        anyInfoBuilder_ = Google.Protobuf.`Any`.Builder()
                        builderResult.anyInfo = anyInfoBuilder_.getMessage()
                        if anyInfo != nil {
                            try! anyInfoBuilder_.mergeFrom(other: anyInfo)
                        }
                    }
                    return anyInfoBuilder_
                }
                @discardableResult
                public func setAnyInfo(_ value:Google.Protobuf.`Any`!) -> Tensorflow.MetaGraphDef.MetaInfoDef.Builder {
                    self.anyInfo = value
                    return self
                }
                @discardableResult
                public func mergeAnyInfo(value:Google.Protobuf.`Any`) throws -> Tensorflow.MetaGraphDef.MetaInfoDef.Builder {
                    if builderResult.hasAnyInfo {
                        builderResult.anyInfo = try Google.Protobuf.`Any`.builderWithPrototype(prototype:builderResult.anyInfo).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.anyInfo = value
                    }
                    builderResult.hasAnyInfo = true
                    return self
                }
                @discardableResult
                public func clearAnyInfo() -> Tensorflow.MetaGraphDef.MetaInfoDef.Builder {
                    anyInfoBuilder_ = nil
                    builderResult.hasAnyInfo = false
                    builderResult.anyInfo = nil
                    return self
                }
                /// User supplied tag(s) on the meta_graph and included graph_def.
                /// MetaGraphDefs should be tagged with their capabilities or use-cases.
                /// Examples: "train", "serve", "gpu", "tpu", etc.
                /// These tags enable loaders to access the MetaGraph(s) appropriate for a
                /// specific use-case or runtime environment.
                public var tags:Array<String> {
                    get {
                        return builderResult.tags
                    }
                    set (array) {
                        builderResult.tags = array
                    }
                }
                @discardableResult
                public func setTags(_ value:Array<String>) -> Tensorflow.MetaGraphDef.MetaInfoDef.Builder {
                    self.tags = value
                    return self
                }
                @discardableResult
                public func clearTags() -> Tensorflow.MetaGraphDef.MetaInfoDef.Builder {
                    builderResult.tags.removeAll(keepingCapacity: false)
                    return self
                }
                /// The __version__ string of the tensorflow build used to write this graph.
                /// This will be populated by the framework, which will overwrite any user
                /// supplied value.
                public var tensorflowVersion:String {
                    get {
                        return builderResult.tensorflowVersion
                    }
                    set (value) {
                        builderResult.hasTensorflowVersion = true
                        builderResult.tensorflowVersion = value
                    }
                }
                public var hasTensorflowVersion:Bool {
                    get {
                        return builderResult.hasTensorflowVersion
                    }
                }
                @discardableResult
                public func setTensorflowVersion(_ value:String) -> Tensorflow.MetaGraphDef.MetaInfoDef.Builder {
                    self.tensorflowVersion = value
                    return self
                }
                @discardableResult
                public func clearTensorflowVersion() -> Tensorflow.MetaGraphDef.MetaInfoDef.Builder{
                    builderResult.hasTensorflowVersion = false
                    builderResult.tensorflowVersion = ""
                    return self
                }
                /// The __git_version__ string of the tensorflow build used to write this
                /// graph. This will be populated by the framework, which will overwrite any
                /// user supplied value.
                public var tensorflowGitVersion:String {
                    get {
                        return builderResult.tensorflowGitVersion
                    }
                    set (value) {
                        builderResult.hasTensorflowGitVersion = true
                        builderResult.tensorflowGitVersion = value
                    }
                }
                public var hasTensorflowGitVersion:Bool {
                    get {
                        return builderResult.hasTensorflowGitVersion
                    }
                }
                @discardableResult
                public func setTensorflowGitVersion(_ value:String) -> Tensorflow.MetaGraphDef.MetaInfoDef.Builder {
                    self.tensorflowGitVersion = value
                    return self
                }
                @discardableResult
                public func clearTensorflowGitVersion() -> Tensorflow.MetaGraphDef.MetaInfoDef.Builder{
                    builderResult.hasTensorflowGitVersion = false
                    builderResult.tensorflowGitVersion = ""
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.MetaGraphDef.MetaInfoDef.Builder {
                    builderResult = Tensorflow.MetaGraphDef.MetaInfoDef()
                    return self
                }
                override public func clone() throws -> Tensorflow.MetaGraphDef.MetaInfoDef.Builder {
                    return try Tensorflow.MetaGraphDef.MetaInfoDef.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.MetaGraphDef.MetaInfoDef {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.MetaGraphDef.MetaInfoDef {
                    let returnMe:Tensorflow.MetaGraphDef.MetaInfoDef = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.MetaGraphDef.MetaInfoDef) throws -> Tensorflow.MetaGraphDef.MetaInfoDef.Builder {
                    if other == Tensorflow.MetaGraphDef.MetaInfoDef() {
                        return self
                    }
                    if other.hasMetaGraphVersion {
                        metaGraphVersion = other.metaGraphVersion
                    }
                    if (other.hasStrippedOpList) {
                        try mergeStrippedOpList(value: other.strippedOpList)
                    }
                    if (other.hasAnyInfo) {
                        try mergeAnyInfo(value: other.anyInfo)
                    }
                    if !other.tags.isEmpty {
                        builderResult.tags += other.tags
                    }
                    if other.hasTensorflowVersion {
                        tensorflowVersion = other.tensorflowVersion
                    }
                    if other.hasTensorflowGitVersion {
                        tensorflowGitVersion = other.tensorflowGitVersion
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.MetaGraphDef.MetaInfoDef.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MetaGraphDef.MetaInfoDef.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            metaGraphVersion = try codedInputStream.readString()

                        case 18:
                            let subBuilder:Tensorflow.OpList.Builder = Tensorflow.OpList.Builder()
                            if hasStrippedOpList {
                                try subBuilder.mergeFrom(other: strippedOpList)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            strippedOpList = subBuilder.buildPartial()

                        case 26:
                            let subBuilder:Google.Protobuf.`Any`.Builder = Google.Protobuf.`Any`.Builder()
                            if hasAnyInfo {
                                try subBuilder.mergeFrom(other: anyInfo)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            anyInfo = subBuilder.buildPartial()

                        case 34:
                            tags += [try codedInputStream.readString()]

                        case 42:
                            tensorflowVersion = try codedInputStream.readString()

                        case 50:
                            tensorflowGitVersion = try codedInputStream.readString()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.MetaGraphDef.MetaInfoDef.Builder {
                    let resultDecodedBuilder = Tensorflow.MetaGraphDef.MetaInfoDef.Builder()
                    if let jsonValueMetaGraphVersion = jsonMap["metaGraphVersion"] as? String {
                        resultDecodedBuilder.metaGraphVersion = jsonValueMetaGraphVersion
                    }
                    if let jsonValueStrippedOpList = jsonMap["strippedOpList"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.strippedOpList = try Tensorflow.OpList.Builder.decodeToBuilder(jsonMap:jsonValueStrippedOpList).build()

                    }
                    if let jsonValueAnyInfo = jsonMap["anyInfo"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.anyInfo = try Google.Protobuf.`Any`.Builder.decodeToBuilder(jsonMap:jsonValueAnyInfo).build()

                    }
                    if let jsonValueTags = jsonMap["tags"] as? Array<String> {
                        var jsonArrayTags:Array<String> = []
                        for oneValueTags in jsonValueTags {
                            jsonArrayTags.append(oneValueTags)
                        }
                        resultDecodedBuilder.tags = jsonArrayTags
                    }
                    if let jsonValueTensorflowVersion = jsonMap["tensorflowVersion"] as? String {
                        resultDecodedBuilder.tensorflowVersion = jsonValueTensorflowVersion
                    }
                    if let jsonValueTensorflowGitVersion = jsonMap["tensorflowGitVersion"] as? String {
                        resultDecodedBuilder.tensorflowGitVersion = jsonValueTensorflowGitVersion
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.MetaGraphDef.MetaInfoDef.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.MetaGraphDef.MetaInfoDef.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        final public class CollectionDefEntry : GeneratedMessage {

            public static func == (lhs: Tensorflow.MetaGraphDef.CollectionDefEntry, rhs: Tensorflow.MetaGraphDef.CollectionDefEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:String = ""
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:Tensorflow.CollectionDef!
            public fileprivate(set) var hasValue:Bool = false
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeString(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeMessage(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeStringSize(fieldNumber: 1)
                }
                if hasValue {
                    if let varSizevalue = value?.computeMessageSize(fieldNumber: 2) {
                        serialize_size += varSizevalue
                    }
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.MetaGraphDef.CollectionDefEntry.Builder {
                return Tensorflow.MetaGraphDef.CollectionDefEntry.classBuilder() as! Tensorflow.MetaGraphDef.CollectionDefEntry.Builder
            }
            public func getBuilder() -> Tensorflow.MetaGraphDef.CollectionDefEntry.Builder {
                return classBuilder() as! Tensorflow.MetaGraphDef.CollectionDefEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.MetaGraphDef.CollectionDefEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.MetaGraphDef.CollectionDefEntry.Builder()
            }
            public func toBuilder() throws -> Tensorflow.MetaGraphDef.CollectionDefEntry.Builder {
                return try Tensorflow.MetaGraphDef.CollectionDefEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.MetaGraphDef.CollectionDefEntry) throws -> Tensorflow.MetaGraphDef.CollectionDefEntry.Builder {
                return try Tensorflow.MetaGraphDef.CollectionDefEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = key
                }
                if hasValue {
                    jsonMap["value"] = try value.encode()
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.MetaGraphDef.CollectionDefEntry {
                return try Tensorflow.MetaGraphDef.CollectionDefEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.MetaGraphDef.CollectionDefEntry {
                return try Tensorflow.MetaGraphDef.CollectionDefEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value {\n"
                    if let outDescValue = value {
                        output += try outDescValue.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        if let hashValuevalue = value?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuevalue
                        }
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.MetaGraphDef.CollectionDefEntry"
            }
            override public func className() -> String {
                return "Tensorflow.MetaGraphDef.CollectionDefEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.MetaGraphDef.CollectionDefEntry = Tensorflow.MetaGraphDef.CollectionDefEntry()
                public func getMessage() -> Tensorflow.MetaGraphDef.CollectionDefEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:String {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:String) -> Tensorflow.MetaGraphDef.CollectionDefEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> Tensorflow.MetaGraphDef.CollectionDefEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = ""
                    return self
                }
                public var value:Tensorflow.CollectionDef! {
                    get {
                        if valueBuilder_ != nil {
                            builderResult.value = valueBuilder_.getMessage()
                        }
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                fileprivate var valueBuilder_:Tensorflow.CollectionDef.Builder! {
                    didSet {
                        builderResult.hasValue = true
                    }
                }
                public func getValueBuilder() -> Tensorflow.CollectionDef.Builder {
                    if valueBuilder_ == nil {
                        valueBuilder_ = Tensorflow.CollectionDef.Builder()
                        builderResult.value = valueBuilder_.getMessage()
                        if value != nil {
                            try! valueBuilder_.mergeFrom(other: value)
                        }
                    }
                    return valueBuilder_
                }
                @discardableResult
                public func setValue(_ value:Tensorflow.CollectionDef!) -> Tensorflow.MetaGraphDef.CollectionDefEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func mergeValue(value:Tensorflow.CollectionDef) throws -> Tensorflow.MetaGraphDef.CollectionDefEntry.Builder {
                    if builderResult.hasValue {
                        builderResult.value = try Tensorflow.CollectionDef.builderWithPrototype(prototype:builderResult.value).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.value = value
                    }
                    builderResult.hasValue = true
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.MetaGraphDef.CollectionDefEntry.Builder {
                    valueBuilder_ = nil
                    builderResult.hasValue = false
                    builderResult.value = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.MetaGraphDef.CollectionDefEntry.Builder {
                    builderResult = Tensorflow.MetaGraphDef.CollectionDefEntry()
                    return self
                }
                override public func clone() throws -> Tensorflow.MetaGraphDef.CollectionDefEntry.Builder {
                    return try Tensorflow.MetaGraphDef.CollectionDefEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.MetaGraphDef.CollectionDefEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.MetaGraphDef.CollectionDefEntry {
                    let returnMe:Tensorflow.MetaGraphDef.CollectionDefEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.MetaGraphDef.CollectionDefEntry) throws -> Tensorflow.MetaGraphDef.CollectionDefEntry.Builder {
                    if other == Tensorflow.MetaGraphDef.CollectionDefEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if (other.hasValue) {
                        try mergeValue(value: other.value)
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.MetaGraphDef.CollectionDefEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MetaGraphDef.CollectionDefEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            key = try codedInputStream.readString()

                        case 18:
                            let subBuilder:Tensorflow.CollectionDef.Builder = Tensorflow.CollectionDef.Builder()
                            if hasValue {
                                try subBuilder.mergeFrom(other: value)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            value = subBuilder.buildPartial()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.MetaGraphDef.CollectionDefEntry.Builder {
                    let resultDecodedBuilder = Tensorflow.MetaGraphDef.CollectionDefEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = jsonValueKey
                    }
                    if let jsonValueValue = jsonMap["value"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.value = try Tensorflow.CollectionDef.Builder.decodeToBuilder(jsonMap:jsonValueValue).build()

                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.MetaGraphDef.CollectionDefEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.MetaGraphDef.CollectionDefEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        final public class SignatureDefEntry : GeneratedMessage {

            public static func == (lhs: Tensorflow.MetaGraphDef.SignatureDefEntry, rhs: Tensorflow.MetaGraphDef.SignatureDefEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:String = ""
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:Tensorflow.SignatureDef!
            public fileprivate(set) var hasValue:Bool = false
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeString(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeMessage(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeStringSize(fieldNumber: 1)
                }
                if hasValue {
                    if let varSizevalue = value?.computeMessageSize(fieldNumber: 2) {
                        serialize_size += varSizevalue
                    }
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.MetaGraphDef.SignatureDefEntry.Builder {
                return Tensorflow.MetaGraphDef.SignatureDefEntry.classBuilder() as! Tensorflow.MetaGraphDef.SignatureDefEntry.Builder
            }
            public func getBuilder() -> Tensorflow.MetaGraphDef.SignatureDefEntry.Builder {
                return classBuilder() as! Tensorflow.MetaGraphDef.SignatureDefEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.MetaGraphDef.SignatureDefEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.MetaGraphDef.SignatureDefEntry.Builder()
            }
            public func toBuilder() throws -> Tensorflow.MetaGraphDef.SignatureDefEntry.Builder {
                return try Tensorflow.MetaGraphDef.SignatureDefEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.MetaGraphDef.SignatureDefEntry) throws -> Tensorflow.MetaGraphDef.SignatureDefEntry.Builder {
                return try Tensorflow.MetaGraphDef.SignatureDefEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = key
                }
                if hasValue {
                    jsonMap["value"] = try value.encode()
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.MetaGraphDef.SignatureDefEntry {
                return try Tensorflow.MetaGraphDef.SignatureDefEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.MetaGraphDef.SignatureDefEntry {
                return try Tensorflow.MetaGraphDef.SignatureDefEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value {\n"
                    if let outDescValue = value {
                        output += try outDescValue.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        if let hashValuevalue = value?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuevalue
                        }
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.MetaGraphDef.SignatureDefEntry"
            }
            override public func className() -> String {
                return "Tensorflow.MetaGraphDef.SignatureDefEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.MetaGraphDef.SignatureDefEntry = Tensorflow.MetaGraphDef.SignatureDefEntry()
                public func getMessage() -> Tensorflow.MetaGraphDef.SignatureDefEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:String {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:String) -> Tensorflow.MetaGraphDef.SignatureDefEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> Tensorflow.MetaGraphDef.SignatureDefEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = ""
                    return self
                }
                public var value:Tensorflow.SignatureDef! {
                    get {
                        if valueBuilder_ != nil {
                            builderResult.value = valueBuilder_.getMessage()
                        }
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                fileprivate var valueBuilder_:Tensorflow.SignatureDef.Builder! {
                    didSet {
                        builderResult.hasValue = true
                    }
                }
                public func getValueBuilder() -> Tensorflow.SignatureDef.Builder {
                    if valueBuilder_ == nil {
                        valueBuilder_ = Tensorflow.SignatureDef.Builder()
                        builderResult.value = valueBuilder_.getMessage()
                        if value != nil {
                            try! valueBuilder_.mergeFrom(other: value)
                        }
                    }
                    return valueBuilder_
                }
                @discardableResult
                public func setValue(_ value:Tensorflow.SignatureDef!) -> Tensorflow.MetaGraphDef.SignatureDefEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func mergeValue(value:Tensorflow.SignatureDef) throws -> Tensorflow.MetaGraphDef.SignatureDefEntry.Builder {
                    if builderResult.hasValue {
                        builderResult.value = try Tensorflow.SignatureDef.builderWithPrototype(prototype:builderResult.value).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.value = value
                    }
                    builderResult.hasValue = true
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.MetaGraphDef.SignatureDefEntry.Builder {
                    valueBuilder_ = nil
                    builderResult.hasValue = false
                    builderResult.value = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.MetaGraphDef.SignatureDefEntry.Builder {
                    builderResult = Tensorflow.MetaGraphDef.SignatureDefEntry()
                    return self
                }
                override public func clone() throws -> Tensorflow.MetaGraphDef.SignatureDefEntry.Builder {
                    return try Tensorflow.MetaGraphDef.SignatureDefEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.MetaGraphDef.SignatureDefEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.MetaGraphDef.SignatureDefEntry {
                    let returnMe:Tensorflow.MetaGraphDef.SignatureDefEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.MetaGraphDef.SignatureDefEntry) throws -> Tensorflow.MetaGraphDef.SignatureDefEntry.Builder {
                    if other == Tensorflow.MetaGraphDef.SignatureDefEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if (other.hasValue) {
                        try mergeValue(value: other.value)
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.MetaGraphDef.SignatureDefEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MetaGraphDef.SignatureDefEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            key = try codedInputStream.readString()

                        case 18:
                            let subBuilder:Tensorflow.SignatureDef.Builder = Tensorflow.SignatureDef.Builder()
                            if hasValue {
                                try subBuilder.mergeFrom(other: value)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            value = subBuilder.buildPartial()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.MetaGraphDef.SignatureDefEntry.Builder {
                    let resultDecodedBuilder = Tensorflow.MetaGraphDef.SignatureDefEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = jsonValueKey
                    }
                    if let jsonValueValue = jsonMap["value"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.value = try Tensorflow.SignatureDef.Builder.decodeToBuilder(jsonMap:jsonValueValue).build()

                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.MetaGraphDef.SignatureDefEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.MetaGraphDef.SignatureDefEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        public fileprivate(set) var metaInfoDef:Tensorflow.MetaGraphDef.MetaInfoDef!
        public fileprivate(set) var hasMetaInfoDef:Bool = false
        public fileprivate(set) var graphDef:Tensorflow.GraphDef!
        public fileprivate(set) var hasGraphDef:Bool = false
        public fileprivate(set) var saverDef:Tensorflow.SaverDef!
        public fileprivate(set) var hasSaverDef:Bool = false
        /// collection_def: Map from collection name to collections.
        /// See CollectionDef section for details.
        public fileprivate(set) var collectionDef:Dictionary<String,Tensorflow.CollectionDef> = Dictionary<String,Tensorflow.CollectionDef>()

        public fileprivate(set) var hasCollectionDef:Bool = false
        /// signature_def: Map from user supplied key for a signature to a single
        /// SignatureDef.
        public fileprivate(set) var signatureDef:Dictionary<String,Tensorflow.SignatureDef> = Dictionary<String,Tensorflow.SignatureDef>()

        public fileprivate(set) var hasSignatureDef:Bool = false
        public fileprivate(set) var assetFileDef:Array<Tensorflow.AssetFileDef>  = Array<Tensorflow.AssetFileDef>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasMetaInfoDef {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:metaInfoDef)
            }
            if hasGraphDef {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:graphDef)
            }
            if hasSaverDef {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:saverDef)
            }
            if hasCollectionDef {
                for (keyCollectionDef, valueCollectionDef) in collectionDef {
                    let valueOfCollectionDef = try! Tensorflow.MetaGraphDef.CollectionDefEntry.Builder().setKey(keyCollectionDef).setValue(valueCollectionDef).build()
                      try codedOutputStream.writeMessage(fieldNumber: 4, value:valueOfCollectionDef)
                  }
            }
            if hasSignatureDef {
                for (keySignatureDef, valueSignatureDef) in signatureDef {
                    let valueOfSignatureDef = try! Tensorflow.MetaGraphDef.SignatureDefEntry.Builder().setKey(keySignatureDef).setValue(valueSignatureDef).build()
                      try codedOutputStream.writeMessage(fieldNumber: 5, value:valueOfSignatureDef)
                  }
            }
            for oneElementAssetFileDef in assetFileDef {
                  try codedOutputStream.writeMessage(fieldNumber: 6, value:oneElementAssetFileDef)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasMetaInfoDef {
                if let varSizemetaInfoDef = metaInfoDef?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizemetaInfoDef
                }
            }
            if hasGraphDef {
                if let varSizegraphDef = graphDef?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizegraphDef
                }
            }
            if hasSaverDef {
                if let varSizesaverDef = saverDef?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizesaverDef
                }
            }
            if hasCollectionDef {
                  for (keyCollectionDef, valueCollectionDef) in collectionDef {
                      let valueOfCollectionDef = try! Tensorflow.MetaGraphDef.CollectionDefEntry.Builder().setKey(keyCollectionDef).setValue(valueCollectionDef).build()
                serialize_size += valueOfCollectionDef.computeMessageSize(fieldNumber: 4)
                }
            }
            if hasSignatureDef {
                  for (keySignatureDef, valueSignatureDef) in signatureDef {
                      let valueOfSignatureDef = try! Tensorflow.MetaGraphDef.SignatureDefEntry.Builder().setKey(keySignatureDef).setValue(valueSignatureDef).build()
                serialize_size += valueOfSignatureDef.computeMessageSize(fieldNumber: 5)
                }
            }
            for oneElementAssetFileDef in assetFileDef {
                serialize_size += oneElementAssetFileDef.computeMessageSize(fieldNumber: 6)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.MetaGraphDef.Builder {
            return Tensorflow.MetaGraphDef.classBuilder() as! Tensorflow.MetaGraphDef.Builder
        }
        public func getBuilder() -> Tensorflow.MetaGraphDef.Builder {
            return classBuilder() as! Tensorflow.MetaGraphDef.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.MetaGraphDef.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.MetaGraphDef.Builder()
        }
        public func toBuilder() throws -> Tensorflow.MetaGraphDef.Builder {
            return try Tensorflow.MetaGraphDef.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.MetaGraphDef) throws -> Tensorflow.MetaGraphDef.Builder {
            return try Tensorflow.MetaGraphDef.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasMetaInfoDef {
                jsonMap["metaInfoDef"] = try metaInfoDef.encode()
            }
            if hasGraphDef {
                jsonMap["graphDef"] = try graphDef.encode()
            }
            if hasSaverDef {
                jsonMap["saverDef"] = try saverDef.encode()
            }
            if hasCollectionDef {
                var mapCollectionDef = Dictionary<String, Dictionary<String,Any>>()
                for (keyCollectionDef, valueCollectionDef) in collectionDef {
                    mapCollectionDef["\(keyCollectionDef)"] = try valueCollectionDef.encode()
                }
                jsonMap["collectionDef"] = mapCollectionDef
            }
            if hasSignatureDef {
                var mapSignatureDef = Dictionary<String, Dictionary<String,Any>>()
                for (keySignatureDef, valueSignatureDef) in signatureDef {
                    mapSignatureDef["\(keySignatureDef)"] = try valueSignatureDef.encode()
                }
                jsonMap["signatureDef"] = mapSignatureDef
            }
            if !assetFileDef.isEmpty {
                var jsonArrayAssetFileDef:Array<Dictionary<String,Any>> = []
                for oneValueAssetFileDef in assetFileDef {
                    let ecodedMessageAssetFileDef = try oneValueAssetFileDef.encode()
                    jsonArrayAssetFileDef.append(ecodedMessageAssetFileDef)
                }
                jsonMap["assetFileDef"] = jsonArrayAssetFileDef
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.MetaGraphDef {
            return try Tensorflow.MetaGraphDef.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.MetaGraphDef {
            return try Tensorflow.MetaGraphDef.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasMetaInfoDef {
                output += "\(indent) metaInfoDef {\n"
                if let outDescMetaInfoDef = metaInfoDef {
                    output += try outDescMetaInfoDef.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasGraphDef {
                output += "\(indent) graphDef {\n"
                if let outDescGraphDef = graphDef {
                    output += try outDescGraphDef.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasSaverDef {
                output += "\(indent) saverDef {\n"
                if let outDescSaverDef = saverDef {
                    output += try outDescSaverDef.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasCollectionDef {
                output += "\(indent) collectionDef: \(collectionDef) \n"
            }
            if hasSignatureDef {
                output += "\(indent) signatureDef: \(signatureDef) \n"
            }
            var assetFileDefElementIndex:Int = 0
            for oneElementAssetFileDef in assetFileDef {
                output += "\(indent) assetFileDef[\(assetFileDefElementIndex)] {\n"
                output += try oneElementAssetFileDef.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                assetFileDefElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasMetaInfoDef {
                    if let hashValuemetaInfoDef = metaInfoDef?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuemetaInfoDef
                    }
                }
                if hasGraphDef {
                    if let hashValuegraphDef = graphDef?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuegraphDef
                    }
                }
                if hasSaverDef {
                    if let hashValuesaverDef = saverDef?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuesaverDef
                    }
                }
                if hasCollectionDef {
                    for (keyCollectionDef, valueCollectionDef) in collectionDef {
                        hashCode = (hashCode &* 31) &+ keyCollectionDef.hashValue
                        hashCode = (hashCode &* 31) &+ valueCollectionDef.hashValue
                    }
                }
                if hasSignatureDef {
                    for (keySignatureDef, valueSignatureDef) in signatureDef {
                        hashCode = (hashCode &* 31) &+ keySignatureDef.hashValue
                        hashCode = (hashCode &* 31) &+ valueSignatureDef.hashValue
                    }
                }
                for oneElementAssetFileDef in assetFileDef {
                    hashCode = (hashCode &* 31) &+ oneElementAssetFileDef.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.MetaGraphDef"
        }
        override public func className() -> String {
            return "Tensorflow.MetaGraphDef"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.MetaGraphDef = Tensorflow.MetaGraphDef()
            public func getMessage() -> Tensorflow.MetaGraphDef {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var metaInfoDef:Tensorflow.MetaGraphDef.MetaInfoDef! {
                get {
                    if metaInfoDefBuilder_ != nil {
                        builderResult.metaInfoDef = metaInfoDefBuilder_.getMessage()
                    }
                    return builderResult.metaInfoDef
                }
                set (value) {
                    builderResult.hasMetaInfoDef = true
                    builderResult.metaInfoDef = value
                }
            }
            public var hasMetaInfoDef:Bool {
                get {
                    return builderResult.hasMetaInfoDef
                }
            }
            fileprivate var metaInfoDefBuilder_:Tensorflow.MetaGraphDef.MetaInfoDef.Builder! {
                didSet {
                    builderResult.hasMetaInfoDef = true
                }
            }
            public func getMetaInfoDefBuilder() -> Tensorflow.MetaGraphDef.MetaInfoDef.Builder {
                if metaInfoDefBuilder_ == nil {
                    metaInfoDefBuilder_ = Tensorflow.MetaGraphDef.MetaInfoDef.Builder()
                    builderResult.metaInfoDef = metaInfoDefBuilder_.getMessage()
                    if metaInfoDef != nil {
                        try! metaInfoDefBuilder_.mergeFrom(other: metaInfoDef)
                    }
                }
                return metaInfoDefBuilder_
            }
            @discardableResult
            public func setMetaInfoDef(_ value:Tensorflow.MetaGraphDef.MetaInfoDef!) -> Tensorflow.MetaGraphDef.Builder {
                self.metaInfoDef = value
                return self
            }
            @discardableResult
            public func mergeMetaInfoDef(value:Tensorflow.MetaGraphDef.MetaInfoDef) throws -> Tensorflow.MetaGraphDef.Builder {
                if builderResult.hasMetaInfoDef {
                    builderResult.metaInfoDef = try Tensorflow.MetaGraphDef.MetaInfoDef.builderWithPrototype(prototype:builderResult.metaInfoDef).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.metaInfoDef = value
                }
                builderResult.hasMetaInfoDef = true
                return self
            }
            @discardableResult
            public func clearMetaInfoDef() -> Tensorflow.MetaGraphDef.Builder {
                metaInfoDefBuilder_ = nil
                builderResult.hasMetaInfoDef = false
                builderResult.metaInfoDef = nil
                return self
            }
            /// GraphDef.
            public var graphDef:Tensorflow.GraphDef! {
                get {
                    if graphDefBuilder_ != nil {
                        builderResult.graphDef = graphDefBuilder_.getMessage()
                    }
                    return builderResult.graphDef
                }
                set (value) {
                    builderResult.hasGraphDef = true
                    builderResult.graphDef = value
                }
            }
            public var hasGraphDef:Bool {
                get {
                    return builderResult.hasGraphDef
                }
            }
            fileprivate var graphDefBuilder_:Tensorflow.GraphDef.Builder! {
                didSet {
                    builderResult.hasGraphDef = true
                }
            }
            public func getGraphDefBuilder() -> Tensorflow.GraphDef.Builder {
                if graphDefBuilder_ == nil {
                    graphDefBuilder_ = Tensorflow.GraphDef.Builder()
                    builderResult.graphDef = graphDefBuilder_.getMessage()
                    if graphDef != nil {
                        try! graphDefBuilder_.mergeFrom(other: graphDef)
                    }
                }
                return graphDefBuilder_
            }
            @discardableResult
            public func setGraphDef(_ value:Tensorflow.GraphDef!) -> Tensorflow.MetaGraphDef.Builder {
                self.graphDef = value
                return self
            }
            @discardableResult
            public func mergeGraphDef(value:Tensorflow.GraphDef) throws -> Tensorflow.MetaGraphDef.Builder {
                if builderResult.hasGraphDef {
                    builderResult.graphDef = try Tensorflow.GraphDef.builderWithPrototype(prototype:builderResult.graphDef).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.graphDef = value
                }
                builderResult.hasGraphDef = true
                return self
            }
            @discardableResult
            public func clearGraphDef() -> Tensorflow.MetaGraphDef.Builder {
                graphDefBuilder_ = nil
                builderResult.hasGraphDef = false
                builderResult.graphDef = nil
                return self
            }
            /// SaverDef.
            public var saverDef:Tensorflow.SaverDef! {
                get {
                    if saverDefBuilder_ != nil {
                        builderResult.saverDef = saverDefBuilder_.getMessage()
                    }
                    return builderResult.saverDef
                }
                set (value) {
                    builderResult.hasSaverDef = true
                    builderResult.saverDef = value
                }
            }
            public var hasSaverDef:Bool {
                get {
                    return builderResult.hasSaverDef
                }
            }
            fileprivate var saverDefBuilder_:Tensorflow.SaverDef.Builder! {
                didSet {
                    builderResult.hasSaverDef = true
                }
            }
            public func getSaverDefBuilder() -> Tensorflow.SaverDef.Builder {
                if saverDefBuilder_ == nil {
                    saverDefBuilder_ = Tensorflow.SaverDef.Builder()
                    builderResult.saverDef = saverDefBuilder_.getMessage()
                    if saverDef != nil {
                        try! saverDefBuilder_.mergeFrom(other: saverDef)
                    }
                }
                return saverDefBuilder_
            }
            @discardableResult
            public func setSaverDef(_ value:Tensorflow.SaverDef!) -> Tensorflow.MetaGraphDef.Builder {
                self.saverDef = value
                return self
            }
            @discardableResult
            public func mergeSaverDef(value:Tensorflow.SaverDef) throws -> Tensorflow.MetaGraphDef.Builder {
                if builderResult.hasSaverDef {
                    builderResult.saverDef = try Tensorflow.SaverDef.builderWithPrototype(prototype:builderResult.saverDef).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.saverDef = value
                }
                builderResult.hasSaverDef = true
                return self
            }
            @discardableResult
            public func clearSaverDef() -> Tensorflow.MetaGraphDef.Builder {
                saverDefBuilder_ = nil
                builderResult.hasSaverDef = false
                builderResult.saverDef = nil
                return self
            }
            /// collection_def: Map from collection name to collections.
            /// See CollectionDef section for details.
            public var hasCollectionDef:Bool {
                get {
                    return builderResult.hasCollectionDef
                }
            }
            public var collectionDef:Dictionary<String,Tensorflow.CollectionDef> {
                get {
                    return builderResult.collectionDef
                }
                set (value) {
                    builderResult.hasCollectionDef = true
                    builderResult.collectionDef = value
                }
            }
            @discardableResult
            public func setCollectionDef(_ value:Dictionary<String,Tensorflow.CollectionDef>) -> Tensorflow.MetaGraphDef.Builder {
                self.collectionDef = value
                return self
            }
            @discardableResult
            public func clearCollectionDef() -> Tensorflow.MetaGraphDef.Builder{
                builderResult.hasCollectionDef = false
                builderResult.collectionDef = Dictionary<String,Tensorflow.CollectionDef>()
                return self
            }
            /// signature_def: Map from user supplied key for a signature to a single
            /// SignatureDef.
            public var hasSignatureDef:Bool {
                get {
                    return builderResult.hasSignatureDef
                }
            }
            public var signatureDef:Dictionary<String,Tensorflow.SignatureDef> {
                get {
                    return builderResult.signatureDef
                }
                set (value) {
                    builderResult.hasSignatureDef = true
                    builderResult.signatureDef = value
                }
            }
            @discardableResult
            public func setSignatureDef(_ value:Dictionary<String,Tensorflow.SignatureDef>) -> Tensorflow.MetaGraphDef.Builder {
                self.signatureDef = value
                return self
            }
            @discardableResult
            public func clearSignatureDef() -> Tensorflow.MetaGraphDef.Builder{
                builderResult.hasSignatureDef = false
                builderResult.signatureDef = Dictionary<String,Tensorflow.SignatureDef>()
                return self
            }
            /// Asset file def to be used with the defined graph.
            public var assetFileDef:Array<Tensorflow.AssetFileDef> {
                get {
                    return builderResult.assetFileDef
                }
                set (value) {
                    builderResult.assetFileDef = value
                }
            }
            @discardableResult
            public func setAssetFileDef(_ value:Array<Tensorflow.AssetFileDef>) -> Tensorflow.MetaGraphDef.Builder {
                self.assetFileDef = value
                return self
            }
            @discardableResult
            public func clearAssetFileDef() -> Tensorflow.MetaGraphDef.Builder {
                builderResult.assetFileDef.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.MetaGraphDef.Builder {
                builderResult = Tensorflow.MetaGraphDef()
                return self
            }
            override public func clone() throws -> Tensorflow.MetaGraphDef.Builder {
                return try Tensorflow.MetaGraphDef.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.MetaGraphDef {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.MetaGraphDef {
                let returnMe:Tensorflow.MetaGraphDef = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.MetaGraphDef) throws -> Tensorflow.MetaGraphDef.Builder {
                if other == Tensorflow.MetaGraphDef() {
                    return self
                }
                if (other.hasMetaInfoDef) {
                    try mergeMetaInfoDef(value: other.metaInfoDef)
                }
                if (other.hasGraphDef) {
                    try mergeGraphDef(value: other.graphDef)
                }
                if (other.hasSaverDef) {
                    try mergeSaverDef(value: other.saverDef)
                }
                if other.hasCollectionDef {
                    collectionDef = other.collectionDef
                }
                if other.hasSignatureDef {
                    signatureDef = other.signatureDef
                }
                if !other.assetFileDef.isEmpty  {
                     builderResult.assetFileDef += other.assetFileDef
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.MetaGraphDef.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MetaGraphDef.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Tensorflow.MetaGraphDef.MetaInfoDef.Builder = Tensorflow.MetaGraphDef.MetaInfoDef.Builder()
                        if hasMetaInfoDef {
                            try subBuilder.mergeFrom(other: metaInfoDef)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        metaInfoDef = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Tensorflow.GraphDef.Builder = Tensorflow.GraphDef.Builder()
                        if hasGraphDef {
                            try subBuilder.mergeFrom(other: graphDef)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        graphDef = subBuilder.buildPartial()

                    case 26:
                        let subBuilder:Tensorflow.SaverDef.Builder = Tensorflow.SaverDef.Builder()
                        if hasSaverDef {
                            try subBuilder.mergeFrom(other: saverDef)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        saverDef = subBuilder.buildPartial()

                    case 34:
                        let subBuilder = Tensorflow.MetaGraphDef.CollectionDefEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfCollectionDef = subBuilder.buildPartial()
                        collectionDef[buildOfCollectionDef.key] = buildOfCollectionDef.value

                    case 42:
                        let subBuilder = Tensorflow.MetaGraphDef.SignatureDefEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfSignatureDef = subBuilder.buildPartial()
                        signatureDef[buildOfSignatureDef.key] = buildOfSignatureDef.value

                    case 50:
                        let subBuilder = Tensorflow.AssetFileDef.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        assetFileDef.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.MetaGraphDef.Builder {
                let resultDecodedBuilder = Tensorflow.MetaGraphDef.Builder()
                if let jsonValueMetaInfoDef = jsonMap["metaInfoDef"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.metaInfoDef = try Tensorflow.MetaGraphDef.MetaInfoDef.Builder.decodeToBuilder(jsonMap:jsonValueMetaInfoDef).build()

                }
                if let jsonValueGraphDef = jsonMap["graphDef"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.graphDef = try Tensorflow.GraphDef.Builder.decodeToBuilder(jsonMap:jsonValueGraphDef).build()

                }
                if let jsonValueSaverDef = jsonMap["saverDef"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.saverDef = try Tensorflow.SaverDef.Builder.decodeToBuilder(jsonMap:jsonValueSaverDef).build()

                }
                if let jsonValueCollectionDef = jsonMap["collectionDef"] as? Dictionary<String, Dictionary<String,Any>> {
                    var mapCollectionDef = Dictionary<String, Tensorflow.CollectionDef>()
                    for (keyCollectionDef, valueCollectionDef) in jsonValueCollectionDef {
                        guard let keyFromCollectionDef = String(keyCollectionDef) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapCollectionDef[keyFromCollectionDef] = try Tensorflow.CollectionDef.Builder.decodeToBuilder(jsonMap:valueCollectionDef).build()

                    }
                    resultDecodedBuilder.collectionDef = mapCollectionDef
                }
                if let jsonValueSignatureDef = jsonMap["signatureDef"] as? Dictionary<String, Dictionary<String,Any>> {
                    var mapSignatureDef = Dictionary<String, Tensorflow.SignatureDef>()
                    for (keySignatureDef, valueSignatureDef) in jsonValueSignatureDef {
                        guard let keyFromSignatureDef = String(keySignatureDef) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapSignatureDef[keyFromSignatureDef] = try Tensorflow.SignatureDef.Builder.decodeToBuilder(jsonMap:valueSignatureDef).build()

                    }
                    resultDecodedBuilder.signatureDef = mapSignatureDef
                }
                if let jsonValueAssetFileDef = jsonMap["assetFileDef"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayAssetFileDef:Array<Tensorflow.AssetFileDef> = []
                    for oneValueAssetFileDef in jsonValueAssetFileDef {
                        let messageFromStringAssetFileDef = try Tensorflow.AssetFileDef.Builder.decodeToBuilder(jsonMap:oneValueAssetFileDef).build()

                        jsonArrayAssetFileDef.append(messageFromStringAssetFileDef)
                    }
                    resultDecodedBuilder.assetFileDef = jsonArrayAssetFileDef
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.MetaGraphDef.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.MetaGraphDef.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// CollectionDef should cover most collections.
    /// To add a user-defined collection, do one of the following:
    /// 1. For simple data types, such as string, int, float:
    ///      tf.add_to_collection("your_collection_name", your_simple_value)
    ///    strings will be stored as bytes_list.
    /// 2. For Protobuf types, there are three ways to add them:
    ///    1) tf.add_to_collection("your_collection_name",
    ///         your_proto.SerializeToString())
    ///       collection_def {
    ///         key: "user_defined_bytes_collection"
    ///         value {
    ///           bytes_list {
    ///             value: "queue_name: \"test_queue\"\n"
    ///           }
    ///         }
    ///       }
    ///  or
    ///    2) tf.add_to_collection("your_collection_name", str(your_proto))
    ///       collection_def {
    ///         key: "user_defined_string_collection"
    ///         value {
    ///          bytes_list {
    ///             value: "\n\ntest_queue"
    ///           }
    ///         }
    ///       }
    ///  or
    ///    3) any_buf = any_pb2.Any()
    ///       tf.add_to_collection("your_collection_name",
    ///         any_buf.Pack(your_proto))
    ///       collection_def {
    ///         key: "user_defined_any_collection"
    ///         value {
    ///           any_list {
    ///             value {
    ///               type_url: "type.googleapis.com/tensorflow.QueueRunnerDef"
    ///               value: "\n\ntest_queue"
    ///             }
    ///           }
    ///         }
    ///       }
    /// 3. For Python objects, implement to_proto() and from_proto(), and register
    ///    them in the following manner:
    ///    ops.register_proto_function("your_collection_name",
    ///                                proto_type,
    ///                                to_proto=YourPythonObject.to_proto,
    ///                                from_proto=YourPythonObject.from_proto)
    ///    These functions will be invoked to serialize and de-serialize the
    ///    collection. For example,
    ///    ops.register_proto_function(ops.GraphKeys.GLOBAL_VARIABLES,
    ///                                proto_type=variable_pb2.VariableDef,
    ///                                to_proto=Variable.to_proto,
    ///                                from_proto=Variable.from_proto)
    final public class CollectionDef : GeneratedMessage {

        public static func == (lhs: Tensorflow.CollectionDef, rhs: Tensorflow.CollectionDef) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasNodeList == rhs.hasNodeList) && (!lhs.hasNodeList || lhs.nodeList == rhs.nodeList)
            fieldCheck = fieldCheck && (lhs.hasBytesList == rhs.hasBytesList) && (!lhs.hasBytesList || lhs.bytesList == rhs.bytesList)
            fieldCheck = fieldCheck && (lhs.hasInt64List == rhs.hasInt64List) && (!lhs.hasInt64List || lhs.int64List == rhs.int64List)
            fieldCheck = fieldCheck && (lhs.hasFloatList == rhs.hasFloatList) && (!lhs.hasFloatList || lhs.floatList == rhs.floatList)
            fieldCheck = fieldCheck && (lhs.hasAnyList == rhs.hasAnyList) && (!lhs.hasAnyList || lhs.anyList == rhs.anyList)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        /// NodeList is used for collecting nodes in graph. For example
        /// collection_def {
        ///   key: "summaries"
        ///   value {
        ///     node_list {
        ///       value: "input_producer/ScalarSummary:0"
        ///       value: "shuffle_batch/ScalarSummary:0"
        ///       value: "ImageSummary:0"
        ///     }
        ///   }
        final public class NodeList : GeneratedMessage {

            public static func == (lhs: Tensorflow.CollectionDef.NodeList, rhs: Tensorflow.CollectionDef.NodeList) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var value:Array<String> = Array<String>()
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if !value.isEmpty {
                    for oneValuevalue in value {
                        try codedOutputStream.writeString(fieldNumber: 1, value:oneValuevalue)
                    }
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                var dataSizeValue:Int32 = 0
                for oneValuevalue in value {
                    dataSizeValue += oneValuevalue.computeStringSizeNoTag()
                }
                serialize_size += dataSizeValue
                serialize_size += 1 * Int32(value.count)
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.CollectionDef.NodeList.Builder {
                return Tensorflow.CollectionDef.NodeList.classBuilder() as! Tensorflow.CollectionDef.NodeList.Builder
            }
            public func getBuilder() -> Tensorflow.CollectionDef.NodeList.Builder {
                return classBuilder() as! Tensorflow.CollectionDef.NodeList.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.CollectionDef.NodeList.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.CollectionDef.NodeList.Builder()
            }
            public func toBuilder() throws -> Tensorflow.CollectionDef.NodeList.Builder {
                return try Tensorflow.CollectionDef.NodeList.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.CollectionDef.NodeList) throws -> Tensorflow.CollectionDef.NodeList.Builder {
                return try Tensorflow.CollectionDef.NodeList.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if !value.isEmpty {
                    var jsonArrayValue:Array<String> = []
                    for oneValueValue in value {
                        jsonArrayValue.append(oneValueValue)
                    }
                    jsonMap["value"] = jsonArrayValue
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CollectionDef.NodeList {
                return try Tensorflow.CollectionDef.NodeList.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.CollectionDef.NodeList {
                return try Tensorflow.CollectionDef.NodeList.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                var valueElementIndex:Int = 0
                for oneValueValue in value  {
                    output += "\(indent) value[\(valueElementIndex)]: \(oneValueValue)\n"
                    valueElementIndex += 1
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    for oneValueValue in value {
                        hashCode = (hashCode &* 31) &+ oneValueValue.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.CollectionDef.NodeList"
            }
            override public func className() -> String {
                return "Tensorflow.CollectionDef.NodeList"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.CollectionDef.NodeList = Tensorflow.CollectionDef.NodeList()
                public func getMessage() -> Tensorflow.CollectionDef.NodeList {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var value:Array<String> {
                    get {
                        return builderResult.value
                    }
                    set (array) {
                        builderResult.value = array
                    }
                }
                @discardableResult
                public func setValue(_ value:Array<String>) -> Tensorflow.CollectionDef.NodeList.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.CollectionDef.NodeList.Builder {
                    builderResult.value.removeAll(keepingCapacity: false)
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.CollectionDef.NodeList.Builder {
                    builderResult = Tensorflow.CollectionDef.NodeList()
                    return self
                }
                override public func clone() throws -> Tensorflow.CollectionDef.NodeList.Builder {
                    return try Tensorflow.CollectionDef.NodeList.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.CollectionDef.NodeList {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.CollectionDef.NodeList {
                    let returnMe:Tensorflow.CollectionDef.NodeList = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.CollectionDef.NodeList) throws -> Tensorflow.CollectionDef.NodeList.Builder {
                    if other == Tensorflow.CollectionDef.NodeList() {
                        return self
                    }
                    if !other.value.isEmpty {
                        builderResult.value += other.value
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CollectionDef.NodeList.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CollectionDef.NodeList.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            value += [try codedInputStream.readString()]

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CollectionDef.NodeList.Builder {
                    let resultDecodedBuilder = Tensorflow.CollectionDef.NodeList.Builder()
                    if let jsonValueValue = jsonMap["value"] as? Array<String> {
                        var jsonArrayValue:Array<String> = []
                        for oneValueValue in jsonValueValue {
                            jsonArrayValue.append(oneValueValue)
                        }
                        resultDecodedBuilder.value = jsonArrayValue
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.CollectionDef.NodeList.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.CollectionDef.NodeList.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        /// BytesList is used for collecting strings and serialized protobufs. For
        /// example:
        /// collection_def {
        ///   key: "trainable_variables"
        ///   value {
        ///     bytes_list {
        ///       value: "\n\017conv1/weights:0\022\024conv1/weights/Assign
        ///              \032\024conv1/weights/read:0"
        ///       value: "\n\016conv1/biases:0\022\023conv1/biases/Assign\032
        ///              \023conv1/biases/read:0"
        ///     }
        ///   }
        /// }
        final public class BytesList : GeneratedMessage {

            public static func == (lhs: Tensorflow.CollectionDef.BytesList, rhs: Tensorflow.CollectionDef.BytesList) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var value:Array<Data> = Array<Data>()
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if !value.isEmpty {
                    for oneValuevalue in value {
                        try codedOutputStream.writeData(fieldNumber: 1, value:oneValuevalue)
                    }
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                var dataSizeValue:Int32 = 0
                for oneValuevalue in value {
                    dataSizeValue += oneValuevalue.computeDataSizeNoTag()
                }
                serialize_size += dataSizeValue
                serialize_size += 1 * Int32(value.count)
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.CollectionDef.BytesList.Builder {
                return Tensorflow.CollectionDef.BytesList.classBuilder() as! Tensorflow.CollectionDef.BytesList.Builder
            }
            public func getBuilder() -> Tensorflow.CollectionDef.BytesList.Builder {
                return classBuilder() as! Tensorflow.CollectionDef.BytesList.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.CollectionDef.BytesList.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.CollectionDef.BytesList.Builder()
            }
            public func toBuilder() throws -> Tensorflow.CollectionDef.BytesList.Builder {
                return try Tensorflow.CollectionDef.BytesList.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.CollectionDef.BytesList) throws -> Tensorflow.CollectionDef.BytesList.Builder {
                return try Tensorflow.CollectionDef.BytesList.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if !value.isEmpty {
                    var jsonArrayValue:Array<String> = []
                    for oneValueValue in value {
                        jsonArrayValue.append(oneValueValue.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0)))
                    }
                    jsonMap["value"] = jsonArrayValue
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CollectionDef.BytesList {
                return try Tensorflow.CollectionDef.BytesList.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.CollectionDef.BytesList {
                return try Tensorflow.CollectionDef.BytesList.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                var valueElementIndex:Int = 0
                for oneValueValue in value  {
                    output += "\(indent) value[\(valueElementIndex)]: \(oneValueValue)\n"
                    valueElementIndex += 1
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    for oneValueValue in value {
                        hashCode = (hashCode &* 31) &+ oneValueValue.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.CollectionDef.BytesList"
            }
            override public func className() -> String {
                return "Tensorflow.CollectionDef.BytesList"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.CollectionDef.BytesList = Tensorflow.CollectionDef.BytesList()
                public func getMessage() -> Tensorflow.CollectionDef.BytesList {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var value:Array<Data> {
                    get {
                        return builderResult.value
                    }
                    set (array) {
                        builderResult.value = array
                    }
                }
                @discardableResult
                public func setValue(_ value:Array<Data>) -> Tensorflow.CollectionDef.BytesList.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.CollectionDef.BytesList.Builder {
                    builderResult.value.removeAll(keepingCapacity: false)
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.CollectionDef.BytesList.Builder {
                    builderResult = Tensorflow.CollectionDef.BytesList()
                    return self
                }
                override public func clone() throws -> Tensorflow.CollectionDef.BytesList.Builder {
                    return try Tensorflow.CollectionDef.BytesList.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.CollectionDef.BytesList {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.CollectionDef.BytesList {
                    let returnMe:Tensorflow.CollectionDef.BytesList = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.CollectionDef.BytesList) throws -> Tensorflow.CollectionDef.BytesList.Builder {
                    if other == Tensorflow.CollectionDef.BytesList() {
                        return self
                    }
                    if !other.value.isEmpty {
                        builderResult.value += other.value
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CollectionDef.BytesList.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CollectionDef.BytesList.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            value += [try codedInputStream.readData()]

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CollectionDef.BytesList.Builder {
                    let resultDecodedBuilder = Tensorflow.CollectionDef.BytesList.Builder()
                    if let jsonValueValue = jsonMap["value"] as? Array<String> {
                        var jsonArrayValue:Array<Data> = []
                        for oneValueValue in jsonValueValue {
                            jsonArrayValue.append(Data(base64Encoded:oneValueValue, options: Data.Base64DecodingOptions(rawValue:0))!)
                        }
                        resultDecodedBuilder.value = jsonArrayValue
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.CollectionDef.BytesList.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.CollectionDef.BytesList.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        /// Int64List is used for collecting int, int64 and long values.
        final public class Int64List : GeneratedMessage {

            public static func == (lhs: Tensorflow.CollectionDef.Int64List, rhs: Tensorflow.CollectionDef.Int64List) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var value:Array<Int64> = Array<Int64>()
            private var valueMemoizedSerializedSize:Int32 = -1
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if !value.isEmpty {
                    try codedOutputStream.writeRawVarint32(value: 10)
                    try codedOutputStream.writeRawVarint32(value: valueMemoizedSerializedSize)
                    for oneValuevalue in value {
                        try codedOutputStream.writeInt64NoTag(value: oneValuevalue)
                    }
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                var dataSizeValue:Int32 = 0
                for oneValuevalue in value {
                    dataSizeValue += oneValuevalue.computeInt64SizeNoTag()
                }
                serialize_size += dataSizeValue
                if !value.isEmpty {
                    serialize_size += 1
                    serialize_size += dataSizeValue.computeInt32SizeNoTag()
                }
                valueMemoizedSerializedSize = dataSizeValue
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.CollectionDef.Int64List.Builder {
                return Tensorflow.CollectionDef.Int64List.classBuilder() as! Tensorflow.CollectionDef.Int64List.Builder
            }
            public func getBuilder() -> Tensorflow.CollectionDef.Int64List.Builder {
                return classBuilder() as! Tensorflow.CollectionDef.Int64List.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.CollectionDef.Int64List.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.CollectionDef.Int64List.Builder()
            }
            public func toBuilder() throws -> Tensorflow.CollectionDef.Int64List.Builder {
                return try Tensorflow.CollectionDef.Int64List.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.CollectionDef.Int64List) throws -> Tensorflow.CollectionDef.Int64List.Builder {
                return try Tensorflow.CollectionDef.Int64List.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if !value.isEmpty {
                    var jsonArrayValue:Array<String> = []
                    for oneValueValue in value {
                        jsonArrayValue.append("\(oneValueValue)")
                    }
                    jsonMap["value"] = jsonArrayValue
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CollectionDef.Int64List {
                return try Tensorflow.CollectionDef.Int64List.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.CollectionDef.Int64List {
                return try Tensorflow.CollectionDef.Int64List.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                var valueElementIndex:Int = 0
                for oneValueValue in value  {
                    output += "\(indent) value[\(valueElementIndex)]: \(oneValueValue)\n"
                    valueElementIndex += 1
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    for oneValueValue in value {
                        hashCode = (hashCode &* 31) &+ oneValueValue.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.CollectionDef.Int64List"
            }
            override public func className() -> String {
                return "Tensorflow.CollectionDef.Int64List"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.CollectionDef.Int64List = Tensorflow.CollectionDef.Int64List()
                public func getMessage() -> Tensorflow.CollectionDef.Int64List {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var value:Array<Int64> {
                    get {
                        return builderResult.value
                    }
                    set (array) {
                        builderResult.value = array
                    }
                }
                @discardableResult
                public func setValue(_ value:Array<Int64>) -> Tensorflow.CollectionDef.Int64List.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.CollectionDef.Int64List.Builder {
                    builderResult.value.removeAll(keepingCapacity: false)
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.CollectionDef.Int64List.Builder {
                    builderResult = Tensorflow.CollectionDef.Int64List()
                    return self
                }
                override public func clone() throws -> Tensorflow.CollectionDef.Int64List.Builder {
                    return try Tensorflow.CollectionDef.Int64List.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.CollectionDef.Int64List {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.CollectionDef.Int64List {
                    let returnMe:Tensorflow.CollectionDef.Int64List = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.CollectionDef.Int64List) throws -> Tensorflow.CollectionDef.Int64List.Builder {
                    if other == Tensorflow.CollectionDef.Int64List() {
                        return self
                    }
                    if !other.value.isEmpty {
                        builderResult.value += other.value
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CollectionDef.Int64List.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CollectionDef.Int64List.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            let length = Int(try codedInputStream.readRawVarint32())
                            let limit = try codedInputStream.pushLimit(byteLimit: length)
                            while (codedInputStream.bytesUntilLimit() > 0) {
                                builderResult.value.append(try codedInputStream.readInt64())
                            }
                            codedInputStream.popLimit(oldLimit: limit)

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CollectionDef.Int64List.Builder {
                    let resultDecodedBuilder = Tensorflow.CollectionDef.Int64List.Builder()
                    if let jsonValueValue = jsonMap["value"] as? Array<String> {
                        var jsonArrayValue:Array<Int64> = []
                        for oneValueValue in jsonValueValue {
                            jsonArrayValue.append(Int64(oneValueValue)!)
                        }
                        resultDecodedBuilder.value = jsonArrayValue
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.CollectionDef.Int64List.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.CollectionDef.Int64List.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        /// FloatList is used for collecting float values.
        final public class FloatList : GeneratedMessage {

            public static func == (lhs: Tensorflow.CollectionDef.FloatList, rhs: Tensorflow.CollectionDef.FloatList) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var value:Array<Float> = Array<Float>()
            private var valueMemoizedSerializedSize:Int32 = -1
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if !value.isEmpty {
                    try codedOutputStream.writeRawVarint32(value: 10)
                    try codedOutputStream.writeRawVarint32(value: valueMemoizedSerializedSize)
                    for oneValuevalue in value {
                        try codedOutputStream.writeFloatNoTag(value: oneValuevalue)
                    }
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                var dataSizeValue:Int32 = 0
                dataSizeValue = 4 * Int32(value.count)
                serialize_size += dataSizeValue
                if !value.isEmpty {
                    serialize_size += 1
                    serialize_size += dataSizeValue.computeInt32SizeNoTag()
                }
                valueMemoizedSerializedSize = dataSizeValue
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.CollectionDef.FloatList.Builder {
                return Tensorflow.CollectionDef.FloatList.classBuilder() as! Tensorflow.CollectionDef.FloatList.Builder
            }
            public func getBuilder() -> Tensorflow.CollectionDef.FloatList.Builder {
                return classBuilder() as! Tensorflow.CollectionDef.FloatList.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.CollectionDef.FloatList.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.CollectionDef.FloatList.Builder()
            }
            public func toBuilder() throws -> Tensorflow.CollectionDef.FloatList.Builder {
                return try Tensorflow.CollectionDef.FloatList.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.CollectionDef.FloatList) throws -> Tensorflow.CollectionDef.FloatList.Builder {
                return try Tensorflow.CollectionDef.FloatList.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if !value.isEmpty {
                    var jsonArrayValue:Array<Float> = []
                    for oneValueValue in value {
                        jsonArrayValue.append(Float(oneValueValue))
                    }
                    jsonMap["value"] = jsonArrayValue
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CollectionDef.FloatList {
                return try Tensorflow.CollectionDef.FloatList.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.CollectionDef.FloatList {
                return try Tensorflow.CollectionDef.FloatList.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                var valueElementIndex:Int = 0
                for oneValueValue in value  {
                    output += "\(indent) value[\(valueElementIndex)]: \(oneValueValue)\n"
                    valueElementIndex += 1
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    for oneValueValue in value {
                        hashCode = (hashCode &* 31) &+ oneValueValue.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.CollectionDef.FloatList"
            }
            override public func className() -> String {
                return "Tensorflow.CollectionDef.FloatList"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.CollectionDef.FloatList = Tensorflow.CollectionDef.FloatList()
                public func getMessage() -> Tensorflow.CollectionDef.FloatList {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var value:Array<Float> {
                    get {
                        return builderResult.value
                    }
                    set (array) {
                        builderResult.value = array
                    }
                }
                @discardableResult
                public func setValue(_ value:Array<Float>) -> Tensorflow.CollectionDef.FloatList.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.CollectionDef.FloatList.Builder {
                    builderResult.value.removeAll(keepingCapacity: false)
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.CollectionDef.FloatList.Builder {
                    builderResult = Tensorflow.CollectionDef.FloatList()
                    return self
                }
                override public func clone() throws -> Tensorflow.CollectionDef.FloatList.Builder {
                    return try Tensorflow.CollectionDef.FloatList.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.CollectionDef.FloatList {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.CollectionDef.FloatList {
                    let returnMe:Tensorflow.CollectionDef.FloatList = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.CollectionDef.FloatList) throws -> Tensorflow.CollectionDef.FloatList.Builder {
                    if other == Tensorflow.CollectionDef.FloatList() {
                        return self
                    }
                    if !other.value.isEmpty {
                        builderResult.value += other.value
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CollectionDef.FloatList.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CollectionDef.FloatList.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            let length = Int(try codedInputStream.readRawVarint32())
                            let limit = try codedInputStream.pushLimit(byteLimit: length)
                            while (codedInputStream.bytesUntilLimit() > 0) {
                                builderResult.value.append(try codedInputStream.readFloat())
                            }
                            codedInputStream.popLimit(oldLimit: limit)

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CollectionDef.FloatList.Builder {
                    let resultDecodedBuilder = Tensorflow.CollectionDef.FloatList.Builder()
                    if let jsonValueValue = jsonMap["value"] as? Array<Float> {
                        var jsonArrayValue:Array<Float> = []
                        for oneValueValue in jsonValueValue {
                            jsonArrayValue.append(Float(oneValueValue))
                        }
                        resultDecodedBuilder.value = jsonArrayValue
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.CollectionDef.FloatList.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.CollectionDef.FloatList.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        /// AnyList is used for collecting Any protos.
        final public class AnyList : GeneratedMessage {

            public static func == (lhs: Tensorflow.CollectionDef.AnyList, rhs: Tensorflow.CollectionDef.AnyList) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var value:Array<Google.Protobuf.`Any`>  = Array<Google.Protobuf.`Any`>()
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                for oneElementValue in value {
                      try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementValue)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                for oneElementValue in value {
                    serialize_size += oneElementValue.computeMessageSize(fieldNumber: 1)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.CollectionDef.AnyList.Builder {
                return Tensorflow.CollectionDef.AnyList.classBuilder() as! Tensorflow.CollectionDef.AnyList.Builder
            }
            public func getBuilder() -> Tensorflow.CollectionDef.AnyList.Builder {
                return classBuilder() as! Tensorflow.CollectionDef.AnyList.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.CollectionDef.AnyList.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.CollectionDef.AnyList.Builder()
            }
            public func toBuilder() throws -> Tensorflow.CollectionDef.AnyList.Builder {
                return try Tensorflow.CollectionDef.AnyList.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.CollectionDef.AnyList) throws -> Tensorflow.CollectionDef.AnyList.Builder {
                return try Tensorflow.CollectionDef.AnyList.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if !value.isEmpty {
                    var jsonArrayValue:Array<Dictionary<String,Any>> = []
                    for oneValueValue in value {
                        let ecodedMessageValue = try oneValueValue.encode()
                        jsonArrayValue.append(ecodedMessageValue)
                    }
                    jsonMap["value"] = jsonArrayValue
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CollectionDef.AnyList {
                return try Tensorflow.CollectionDef.AnyList.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.CollectionDef.AnyList {
                return try Tensorflow.CollectionDef.AnyList.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                var valueElementIndex:Int = 0
                for oneElementValue in value {
                    output += "\(indent) value[\(valueElementIndex)] {\n"
                    output += try oneElementValue.getDescription(indent: "\(indent)  ")
                    output += "\(indent)}\n"
                    valueElementIndex += 1
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    for oneElementValue in value {
                        hashCode = (hashCode &* 31) &+ oneElementValue.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.CollectionDef.AnyList"
            }
            override public func className() -> String {
                return "Tensorflow.CollectionDef.AnyList"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.CollectionDef.AnyList = Tensorflow.CollectionDef.AnyList()
                public func getMessage() -> Tensorflow.CollectionDef.AnyList {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var value:Array<Google.Protobuf.`Any`> {
                    get {
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.value = value
                    }
                }
                @discardableResult
                public func setValue(_ value:Array<Google.Protobuf.`Any`>) -> Tensorflow.CollectionDef.AnyList.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.CollectionDef.AnyList.Builder {
                    builderResult.value.removeAll(keepingCapacity: false)
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.CollectionDef.AnyList.Builder {
                    builderResult = Tensorflow.CollectionDef.AnyList()
                    return self
                }
                override public func clone() throws -> Tensorflow.CollectionDef.AnyList.Builder {
                    return try Tensorflow.CollectionDef.AnyList.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.CollectionDef.AnyList {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.CollectionDef.AnyList {
                    let returnMe:Tensorflow.CollectionDef.AnyList = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.CollectionDef.AnyList) throws -> Tensorflow.CollectionDef.AnyList.Builder {
                    if other == Tensorflow.CollectionDef.AnyList() {
                        return self
                    }
                    if !other.value.isEmpty  {
                         builderResult.value += other.value
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CollectionDef.AnyList.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CollectionDef.AnyList.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            let subBuilder = Google.Protobuf.`Any`.Builder()
                            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                            value.append(subBuilder.buildPartial())

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CollectionDef.AnyList.Builder {
                    let resultDecodedBuilder = Tensorflow.CollectionDef.AnyList.Builder()
                    if let jsonValueValue = jsonMap["value"] as? Array<Dictionary<String,Any>> {
                        var jsonArrayValue:Array<Google.Protobuf.`Any`> = []
                        for oneValueValue in jsonValueValue {
                            let messageFromStringValue = try Google.Protobuf.`Any`.Builder.decodeToBuilder(jsonMap:oneValueValue).build()

                            jsonArrayValue.append(messageFromStringValue)
                        }
                        resultDecodedBuilder.value = jsonArrayValue
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.CollectionDef.AnyList.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.CollectionDef.AnyList.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //OneOf declaration start

        public enum Kind {
            case OneOfKindNotSet

            public func checkOneOfIsSet() -> Bool {
                switch self {
                case .OneOfKindNotSet: return false
                default: return true
                }
            }
            case NodeList(Tensorflow.CollectionDef.NodeList)

            public static func getNodeList(_ value:Kind) -> Tensorflow.CollectionDef.NodeList? {
                switch value {
                case .NodeList(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case BytesList(Tensorflow.CollectionDef.BytesList)

            public static func getBytesList(_ value:Kind) -> Tensorflow.CollectionDef.BytesList? {
                switch value {
                case .BytesList(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case Int64List(Tensorflow.CollectionDef.Int64List)

            public static func getInt64List(_ value:Kind) -> Tensorflow.CollectionDef.Int64List? {
                switch value {
                case .Int64List(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case FloatList(Tensorflow.CollectionDef.FloatList)

            public static func getFloatList(_ value:Kind) -> Tensorflow.CollectionDef.FloatList? {
                switch value {
                case .FloatList(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case AnyList(Tensorflow.CollectionDef.AnyList)

            public static func getAnyList(_ value:Kind) -> Tensorflow.CollectionDef.AnyList? {
                switch value {
                case .AnyList(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
        }
        //OneOf declaration end

        fileprivate var storageKind:CollectionDef.Kind =  CollectionDef.Kind.OneOfKindNotSet
        public func getOneOfKind() ->  CollectionDef.Kind {
            let copyObjectKind = storageKind
            return copyObjectKind
        }
        public fileprivate(set) var nodeList:Tensorflow.CollectionDef.NodeList!{
            get {
                return CollectionDef.Kind.getNodeList(storageKind)
            }
            set (newvalue) {
                storageKind = CollectionDef.Kind.NodeList(newvalue)
            }
        }
        public fileprivate(set) var hasNodeList:Bool {
            get {
                guard let _ = CollectionDef.Kind.getNodeList(storageKind) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var bytesList:Tensorflow.CollectionDef.BytesList!{
            get {
                return CollectionDef.Kind.getBytesList(storageKind)
            }
            set (newvalue) {
                storageKind = CollectionDef.Kind.BytesList(newvalue)
            }
        }
        public fileprivate(set) var hasBytesList:Bool {
            get {
                guard let _ = CollectionDef.Kind.getBytesList(storageKind) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var int64List:Tensorflow.CollectionDef.Int64List!{
            get {
                return CollectionDef.Kind.getInt64List(storageKind)
            }
            set (newvalue) {
                storageKind = CollectionDef.Kind.Int64List(newvalue)
            }
        }
        public fileprivate(set) var hasInt64List:Bool {
            get {
                guard let _ = CollectionDef.Kind.getInt64List(storageKind) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var floatList:Tensorflow.CollectionDef.FloatList!{
            get {
                return CollectionDef.Kind.getFloatList(storageKind)
            }
            set (newvalue) {
                storageKind = CollectionDef.Kind.FloatList(newvalue)
            }
        }
        public fileprivate(set) var hasFloatList:Bool {
            get {
                guard let _ = CollectionDef.Kind.getFloatList(storageKind) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var anyList:Tensorflow.CollectionDef.AnyList!{
            get {
                return CollectionDef.Kind.getAnyList(storageKind)
            }
            set (newvalue) {
                storageKind = CollectionDef.Kind.AnyList(newvalue)
            }
        }
        public fileprivate(set) var hasAnyList:Bool {
            get {
                guard let _ = CollectionDef.Kind.getAnyList(storageKind) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasNodeList {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:nodeList)
            }
            if hasBytesList {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:bytesList)
            }
            if hasInt64List {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:int64List)
            }
            if hasFloatList {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:floatList)
            }
            if hasAnyList {
                try codedOutputStream.writeMessage(fieldNumber: 5, value:anyList)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasNodeList {
                if let varSizenodeList = nodeList?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizenodeList
                }
            }
            if hasBytesList {
                if let varSizebytesList = bytesList?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizebytesList
                }
            }
            if hasInt64List {
                if let varSizeint64List = int64List?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizeint64List
                }
            }
            if hasFloatList {
                if let varSizefloatList = floatList?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizefloatList
                }
            }
            if hasAnyList {
                if let varSizeanyList = anyList?.computeMessageSize(fieldNumber: 5) {
                    serialize_size += varSizeanyList
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.CollectionDef.Builder {
            return Tensorflow.CollectionDef.classBuilder() as! Tensorflow.CollectionDef.Builder
        }
        public func getBuilder() -> Tensorflow.CollectionDef.Builder {
            return classBuilder() as! Tensorflow.CollectionDef.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.CollectionDef.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.CollectionDef.Builder()
        }
        public func toBuilder() throws -> Tensorflow.CollectionDef.Builder {
            return try Tensorflow.CollectionDef.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.CollectionDef) throws -> Tensorflow.CollectionDef.Builder {
            return try Tensorflow.CollectionDef.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasNodeList {
                jsonMap["nodeList"] = try nodeList.encode()
            }
            if hasBytesList {
                jsonMap["bytesList"] = try bytesList.encode()
            }
            if hasInt64List {
                jsonMap["int64List"] = try int64List.encode()
            }
            if hasFloatList {
                jsonMap["floatList"] = try floatList.encode()
            }
            if hasAnyList {
                jsonMap["anyList"] = try anyList.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CollectionDef {
            return try Tensorflow.CollectionDef.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.CollectionDef {
            return try Tensorflow.CollectionDef.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasNodeList {
                output += "\(indent) nodeList {\n"
                if let outDescNodeList = nodeList {
                    output += try outDescNodeList.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasBytesList {
                output += "\(indent) bytesList {\n"
                if let outDescBytesList = bytesList {
                    output += try outDescBytesList.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasInt64List {
                output += "\(indent) int64List {\n"
                if let outDescInt64List = int64List {
                    output += try outDescInt64List.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasFloatList {
                output += "\(indent) floatList {\n"
                if let outDescFloatList = floatList {
                    output += try outDescFloatList.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasAnyList {
                output += "\(indent) anyList {\n"
                if let outDescAnyList = anyList {
                    output += try outDescAnyList.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasNodeList {
                    if let hashValuenodeList = nodeList?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuenodeList
                    }
                }
                if hasBytesList {
                    if let hashValuebytesList = bytesList?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuebytesList
                    }
                }
                if hasInt64List {
                    if let hashValueint64List = int64List?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueint64List
                    }
                }
                if hasFloatList {
                    if let hashValuefloatList = floatList?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuefloatList
                    }
                }
                if hasAnyList {
                    if let hashValueanyList = anyList?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueanyList
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.CollectionDef"
        }
        override public func className() -> String {
            return "Tensorflow.CollectionDef"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.CollectionDef = Tensorflow.CollectionDef()
            public func getMessage() -> Tensorflow.CollectionDef {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var nodeList:Tensorflow.CollectionDef.NodeList! {
                get {
                    if nodeListBuilder_ != nil {
                        builderResult.nodeList = nodeListBuilder_.getMessage()
                    }
                    return builderResult.nodeList
                }
                set (value) {
                    builderResult.hasNodeList = true
                    builderResult.nodeList = value
                }
            }
            public var hasNodeList:Bool {
                get {
                    return builderResult.hasNodeList
                }
            }
            fileprivate var nodeListBuilder_:Tensorflow.CollectionDef.NodeList.Builder! {
                didSet {
                    builderResult.hasNodeList = true
                }
            }
            public func getNodeListBuilder() -> Tensorflow.CollectionDef.NodeList.Builder {
                if nodeListBuilder_ == nil {
                    nodeListBuilder_ = Tensorflow.CollectionDef.NodeList.Builder()
                    builderResult.nodeList = nodeListBuilder_.getMessage()
                    if nodeList != nil {
                        try! nodeListBuilder_.mergeFrom(other: nodeList)
                    }
                }
                return nodeListBuilder_
            }
            @discardableResult
            public func setNodeList(_ value:Tensorflow.CollectionDef.NodeList!) -> Tensorflow.CollectionDef.Builder {
                self.nodeList = value
                return self
            }
            @discardableResult
            public func mergeNodeList(value:Tensorflow.CollectionDef.NodeList) throws -> Tensorflow.CollectionDef.Builder {
                if builderResult.hasNodeList {
                    builderResult.nodeList = try Tensorflow.CollectionDef.NodeList.builderWithPrototype(prototype:builderResult.nodeList).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.nodeList = value
                }
                builderResult.hasNodeList = true
                return self
            }
            @discardableResult
            public func clearNodeList() -> Tensorflow.CollectionDef.Builder {
                nodeListBuilder_ = nil
                builderResult.hasNodeList = false
                builderResult.nodeList = nil
                return self
            }
            public var bytesList:Tensorflow.CollectionDef.BytesList! {
                get {
                    if bytesListBuilder_ != nil {
                        builderResult.bytesList = bytesListBuilder_.getMessage()
                    }
                    return builderResult.bytesList
                }
                set (value) {
                    builderResult.hasBytesList = true
                    builderResult.bytesList = value
                }
            }
            public var hasBytesList:Bool {
                get {
                    return builderResult.hasBytesList
                }
            }
            fileprivate var bytesListBuilder_:Tensorflow.CollectionDef.BytesList.Builder! {
                didSet {
                    builderResult.hasBytesList = true
                }
            }
            public func getBytesListBuilder() -> Tensorflow.CollectionDef.BytesList.Builder {
                if bytesListBuilder_ == nil {
                    bytesListBuilder_ = Tensorflow.CollectionDef.BytesList.Builder()
                    builderResult.bytesList = bytesListBuilder_.getMessage()
                    if bytesList != nil {
                        try! bytesListBuilder_.mergeFrom(other: bytesList)
                    }
                }
                return bytesListBuilder_
            }
            @discardableResult
            public func setBytesList(_ value:Tensorflow.CollectionDef.BytesList!) -> Tensorflow.CollectionDef.Builder {
                self.bytesList = value
                return self
            }
            @discardableResult
            public func mergeBytesList(value:Tensorflow.CollectionDef.BytesList) throws -> Tensorflow.CollectionDef.Builder {
                if builderResult.hasBytesList {
                    builderResult.bytesList = try Tensorflow.CollectionDef.BytesList.builderWithPrototype(prototype:builderResult.bytesList).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.bytesList = value
                }
                builderResult.hasBytesList = true
                return self
            }
            @discardableResult
            public func clearBytesList() -> Tensorflow.CollectionDef.Builder {
                bytesListBuilder_ = nil
                builderResult.hasBytesList = false
                builderResult.bytesList = nil
                return self
            }
            public var int64List:Tensorflow.CollectionDef.Int64List! {
                get {
                    if int64ListBuilder_ != nil {
                        builderResult.int64List = int64ListBuilder_.getMessage()
                    }
                    return builderResult.int64List
                }
                set (value) {
                    builderResult.hasInt64List = true
                    builderResult.int64List = value
                }
            }
            public var hasInt64List:Bool {
                get {
                    return builderResult.hasInt64List
                }
            }
            fileprivate var int64ListBuilder_:Tensorflow.CollectionDef.Int64List.Builder! {
                didSet {
                    builderResult.hasInt64List = true
                }
            }
            public func getInt64ListBuilder() -> Tensorflow.CollectionDef.Int64List.Builder {
                if int64ListBuilder_ == nil {
                    int64ListBuilder_ = Tensorflow.CollectionDef.Int64List.Builder()
                    builderResult.int64List = int64ListBuilder_.getMessage()
                    if int64List != nil {
                        try! int64ListBuilder_.mergeFrom(other: int64List)
                    }
                }
                return int64ListBuilder_
            }
            @discardableResult
            public func setInt64List(_ value:Tensorflow.CollectionDef.Int64List!) -> Tensorflow.CollectionDef.Builder {
                self.int64List = value
                return self
            }
            @discardableResult
            public func mergeInt64List(value:Tensorflow.CollectionDef.Int64List) throws -> Tensorflow.CollectionDef.Builder {
                if builderResult.hasInt64List {
                    builderResult.int64List = try Tensorflow.CollectionDef.Int64List.builderWithPrototype(prototype:builderResult.int64List).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.int64List = value
                }
                builderResult.hasInt64List = true
                return self
            }
            @discardableResult
            public func clearInt64List() -> Tensorflow.CollectionDef.Builder {
                int64ListBuilder_ = nil
                builderResult.hasInt64List = false
                builderResult.int64List = nil
                return self
            }
            public var floatList:Tensorflow.CollectionDef.FloatList! {
                get {
                    if floatListBuilder_ != nil {
                        builderResult.floatList = floatListBuilder_.getMessage()
                    }
                    return builderResult.floatList
                }
                set (value) {
                    builderResult.hasFloatList = true
                    builderResult.floatList = value
                }
            }
            public var hasFloatList:Bool {
                get {
                    return builderResult.hasFloatList
                }
            }
            fileprivate var floatListBuilder_:Tensorflow.CollectionDef.FloatList.Builder! {
                didSet {
                    builderResult.hasFloatList = true
                }
            }
            public func getFloatListBuilder() -> Tensorflow.CollectionDef.FloatList.Builder {
                if floatListBuilder_ == nil {
                    floatListBuilder_ = Tensorflow.CollectionDef.FloatList.Builder()
                    builderResult.floatList = floatListBuilder_.getMessage()
                    if floatList != nil {
                        try! floatListBuilder_.mergeFrom(other: floatList)
                    }
                }
                return floatListBuilder_
            }
            @discardableResult
            public func setFloatList(_ value:Tensorflow.CollectionDef.FloatList!) -> Tensorflow.CollectionDef.Builder {
                self.floatList = value
                return self
            }
            @discardableResult
            public func mergeFloatList(value:Tensorflow.CollectionDef.FloatList) throws -> Tensorflow.CollectionDef.Builder {
                if builderResult.hasFloatList {
                    builderResult.floatList = try Tensorflow.CollectionDef.FloatList.builderWithPrototype(prototype:builderResult.floatList).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.floatList = value
                }
                builderResult.hasFloatList = true
                return self
            }
            @discardableResult
            public func clearFloatList() -> Tensorflow.CollectionDef.Builder {
                floatListBuilder_ = nil
                builderResult.hasFloatList = false
                builderResult.floatList = nil
                return self
            }
            public var anyList:Tensorflow.CollectionDef.AnyList! {
                get {
                    if anyListBuilder_ != nil {
                        builderResult.anyList = anyListBuilder_.getMessage()
                    }
                    return builderResult.anyList
                }
                set (value) {
                    builderResult.hasAnyList = true
                    builderResult.anyList = value
                }
            }
            public var hasAnyList:Bool {
                get {
                    return builderResult.hasAnyList
                }
            }
            fileprivate var anyListBuilder_:Tensorflow.CollectionDef.AnyList.Builder! {
                didSet {
                    builderResult.hasAnyList = true
                }
            }
            public func getAnyListBuilder() -> Tensorflow.CollectionDef.AnyList.Builder {
                if anyListBuilder_ == nil {
                    anyListBuilder_ = Tensorflow.CollectionDef.AnyList.Builder()
                    builderResult.anyList = anyListBuilder_.getMessage()
                    if anyList != nil {
                        try! anyListBuilder_.mergeFrom(other: anyList)
                    }
                }
                return anyListBuilder_
            }
            @discardableResult
            public func setAnyList(_ value:Tensorflow.CollectionDef.AnyList!) -> Tensorflow.CollectionDef.Builder {
                self.anyList = value
                return self
            }
            @discardableResult
            public func mergeAnyList(value:Tensorflow.CollectionDef.AnyList) throws -> Tensorflow.CollectionDef.Builder {
                if builderResult.hasAnyList {
                    builderResult.anyList = try Tensorflow.CollectionDef.AnyList.builderWithPrototype(prototype:builderResult.anyList).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.anyList = value
                }
                builderResult.hasAnyList = true
                return self
            }
            @discardableResult
            public func clearAnyList() -> Tensorflow.CollectionDef.Builder {
                anyListBuilder_ = nil
                builderResult.hasAnyList = false
                builderResult.anyList = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.CollectionDef.Builder {
                builderResult = Tensorflow.CollectionDef()
                return self
            }
            override public func clone() throws -> Tensorflow.CollectionDef.Builder {
                return try Tensorflow.CollectionDef.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.CollectionDef {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.CollectionDef {
                let returnMe:Tensorflow.CollectionDef = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.CollectionDef) throws -> Tensorflow.CollectionDef.Builder {
                if other == Tensorflow.CollectionDef() {
                    return self
                }
                if (other.hasNodeList) {
                    try mergeNodeList(value: other.nodeList)
                }
                if (other.hasBytesList) {
                    try mergeBytesList(value: other.bytesList)
                }
                if (other.hasInt64List) {
                    try mergeInt64List(value: other.int64List)
                }
                if (other.hasFloatList) {
                    try mergeFloatList(value: other.floatList)
                }
                if (other.hasAnyList) {
                    try mergeAnyList(value: other.anyList)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CollectionDef.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CollectionDef.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Tensorflow.CollectionDef.NodeList.Builder = Tensorflow.CollectionDef.NodeList.Builder()
                        if hasNodeList {
                            try subBuilder.mergeFrom(other: nodeList)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        nodeList = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Tensorflow.CollectionDef.BytesList.Builder = Tensorflow.CollectionDef.BytesList.Builder()
                        if hasBytesList {
                            try subBuilder.mergeFrom(other: bytesList)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        bytesList = subBuilder.buildPartial()

                    case 26:
                        let subBuilder:Tensorflow.CollectionDef.Int64List.Builder = Tensorflow.CollectionDef.Int64List.Builder()
                        if hasInt64List {
                            try subBuilder.mergeFrom(other: int64List)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        int64List = subBuilder.buildPartial()

                    case 34:
                        let subBuilder:Tensorflow.CollectionDef.FloatList.Builder = Tensorflow.CollectionDef.FloatList.Builder()
                        if hasFloatList {
                            try subBuilder.mergeFrom(other: floatList)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        floatList = subBuilder.buildPartial()

                    case 42:
                        let subBuilder:Tensorflow.CollectionDef.AnyList.Builder = Tensorflow.CollectionDef.AnyList.Builder()
                        if hasAnyList {
                            try subBuilder.mergeFrom(other: anyList)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        anyList = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CollectionDef.Builder {
                let resultDecodedBuilder = Tensorflow.CollectionDef.Builder()
                if let jsonValueNodeList = jsonMap["nodeList"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.nodeList = try Tensorflow.CollectionDef.NodeList.Builder.decodeToBuilder(jsonMap:jsonValueNodeList).build()

                }
                if let jsonValueBytesList = jsonMap["bytesList"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.bytesList = try Tensorflow.CollectionDef.BytesList.Builder.decodeToBuilder(jsonMap:jsonValueBytesList).build()

                }
                if let jsonValueInt64List = jsonMap["int64List"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.int64List = try Tensorflow.CollectionDef.Int64List.Builder.decodeToBuilder(jsonMap:jsonValueInt64List).build()

                }
                if let jsonValueFloatList = jsonMap["floatList"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.floatList = try Tensorflow.CollectionDef.FloatList.Builder.decodeToBuilder(jsonMap:jsonValueFloatList).build()

                }
                if let jsonValueAnyList = jsonMap["anyList"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.anyList = try Tensorflow.CollectionDef.AnyList.Builder.decodeToBuilder(jsonMap:jsonValueAnyList).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.CollectionDef.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.CollectionDef.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Information about a Tensor necessary for feeding or retrieval.
    final public class TensorInfo : GeneratedMessage {

        public static func == (lhs: Tensorflow.TensorInfo, rhs: Tensorflow.TensorInfo) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
            fieldCheck = fieldCheck && (lhs.hasDtype == rhs.hasDtype) && (!lhs.hasDtype || lhs.dtype == rhs.dtype)
            fieldCheck = fieldCheck && (lhs.hasTensorShape == rhs.hasTensorShape) && (!lhs.hasTensorShape || lhs.tensorShape == rhs.tensorShape)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var name:String = ""
        public fileprivate(set) var hasName:Bool = false

        public fileprivate(set) var dtype:Tensorflow.DataType = Tensorflow.DataType.dtInvalid
        public fileprivate(set) var hasDtype:Bool = false
        public fileprivate(set) var tensorShape:Tensorflow.TensorShapeProto!
        public fileprivate(set) var hasTensorShape:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasName {
                try codedOutputStream.writeString(fieldNumber: 1, value:name)
            }
            if hasDtype {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:dtype.rawValue)
            }
            if hasTensorShape {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:tensorShape)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasName {
                serialize_size += name.computeStringSize(fieldNumber: 1)
            }
            if (hasDtype) {
                serialize_size += dtype.rawValue.computeEnumSize(fieldNumber: 2)
            }
            if hasTensorShape {
                if let varSizetensorShape = tensorShape?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizetensorShape
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.TensorInfo.Builder {
            return Tensorflow.TensorInfo.classBuilder() as! Tensorflow.TensorInfo.Builder
        }
        public func getBuilder() -> Tensorflow.TensorInfo.Builder {
            return classBuilder() as! Tensorflow.TensorInfo.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.TensorInfo.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.TensorInfo.Builder()
        }
        public func toBuilder() throws -> Tensorflow.TensorInfo.Builder {
            return try Tensorflow.TensorInfo.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.TensorInfo) throws -> Tensorflow.TensorInfo.Builder {
            return try Tensorflow.TensorInfo.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasName {
                jsonMap["name"] = name
            }
            if hasDtype {
                jsonMap["dtype"] = dtype.toString()
            }
            if hasTensorShape {
                jsonMap["tensorShape"] = try tensorShape.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.TensorInfo {
            return try Tensorflow.TensorInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.TensorInfo {
            return try Tensorflow.TensorInfo.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasName {
                output += "\(indent) name: \(name) \n"
            }
            if (hasDtype) {
                output += "\(indent) dtype: \(dtype.description)\n"
            }
            if hasTensorShape {
                output += "\(indent) tensorShape {\n"
                if let outDescTensorShape = tensorShape {
                    output += try outDescTensorShape.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasName {
                    hashCode = (hashCode &* 31) &+ name.hashValue
                }
                if hasDtype {
                     hashCode = (hashCode &* 31) &+ dtype.hashValue
                }
                if hasTensorShape {
                    if let hashValuetensorShape = tensorShape?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuetensorShape
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.TensorInfo"
        }
        override public func className() -> String {
            return "Tensorflow.TensorInfo"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.TensorInfo = Tensorflow.TensorInfo()
            public func getMessage() -> Tensorflow.TensorInfo {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var name:String {
                get {
                    return builderResult.name
                }
                set (value) {
                    builderResult.hasName = true
                    builderResult.name = value
                }
            }
            public var hasName:Bool {
                get {
                    return builderResult.hasName
                }
            }
            @discardableResult
            public func setName(_ value:String) -> Tensorflow.TensorInfo.Builder {
                self.name = value
                return self
            }
            @discardableResult
            public func clearName() -> Tensorflow.TensorInfo.Builder{
                builderResult.hasName = false
                builderResult.name = ""
                return self
            }
                public var dtype:Tensorflow.DataType {
                    get {
                        return builderResult.dtype
                    }
                    set (value) {
                        builderResult.hasDtype = true
                        builderResult.dtype = value
                    }
                }
                public var hasDtype:Bool{
                    get {
                        return builderResult.hasDtype
                    }
                }
            @discardableResult
                public func setDtype(_ value:Tensorflow.DataType) -> Tensorflow.TensorInfo.Builder {
                  self.dtype = value
                  return self
                }
            @discardableResult
                public func clearDtype() -> Tensorflow.TensorInfo.Builder {
                   builderResult.hasDtype = false
                   builderResult.dtype = .dtInvalid
                   return self
                }
            public var tensorShape:Tensorflow.TensorShapeProto! {
                get {
                    if tensorShapeBuilder_ != nil {
                        builderResult.tensorShape = tensorShapeBuilder_.getMessage()
                    }
                    return builderResult.tensorShape
                }
                set (value) {
                    builderResult.hasTensorShape = true
                    builderResult.tensorShape = value
                }
            }
            public var hasTensorShape:Bool {
                get {
                    return builderResult.hasTensorShape
                }
            }
            fileprivate var tensorShapeBuilder_:Tensorflow.TensorShapeProto.Builder! {
                didSet {
                    builderResult.hasTensorShape = true
                }
            }
            public func getTensorShapeBuilder() -> Tensorflow.TensorShapeProto.Builder {
                if tensorShapeBuilder_ == nil {
                    tensorShapeBuilder_ = Tensorflow.TensorShapeProto.Builder()
                    builderResult.tensorShape = tensorShapeBuilder_.getMessage()
                    if tensorShape != nil {
                        try! tensorShapeBuilder_.mergeFrom(other: tensorShape)
                    }
                }
                return tensorShapeBuilder_
            }
            @discardableResult
            public func setTensorShape(_ value:Tensorflow.TensorShapeProto!) -> Tensorflow.TensorInfo.Builder {
                self.tensorShape = value
                return self
            }
            @discardableResult
            public func mergeTensorShape(value:Tensorflow.TensorShapeProto) throws -> Tensorflow.TensorInfo.Builder {
                if builderResult.hasTensorShape {
                    builderResult.tensorShape = try Tensorflow.TensorShapeProto.builderWithPrototype(prototype:builderResult.tensorShape).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.tensorShape = value
                }
                builderResult.hasTensorShape = true
                return self
            }
            @discardableResult
            public func clearTensorShape() -> Tensorflow.TensorInfo.Builder {
                tensorShapeBuilder_ = nil
                builderResult.hasTensorShape = false
                builderResult.tensorShape = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.TensorInfo.Builder {
                builderResult = Tensorflow.TensorInfo()
                return self
            }
            override public func clone() throws -> Tensorflow.TensorInfo.Builder {
                return try Tensorflow.TensorInfo.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.TensorInfo {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.TensorInfo {
                let returnMe:Tensorflow.TensorInfo = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.TensorInfo) throws -> Tensorflow.TensorInfo.Builder {
                if other == Tensorflow.TensorInfo() {
                    return self
                }
                if other.hasName {
                    name = other.name
                }
                if other.hasDtype {
                    dtype = other.dtype
                }
                if (other.hasTensorShape) {
                    try mergeTensorShape(value: other.tensorShape)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.TensorInfo.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.TensorInfo.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        name = try codedInputStream.readString()

                    case 16:
                        let valueIntdtype = try codedInputStream.readEnum()
                        if let enumsdtype = Tensorflow.DataType(rawValue:valueIntdtype){
                            dtype = enumsdtype
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntdtype))
                        }

                    case 26:
                        let subBuilder:Tensorflow.TensorShapeProto.Builder = Tensorflow.TensorShapeProto.Builder()
                        if hasTensorShape {
                            try subBuilder.mergeFrom(other: tensorShape)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        tensorShape = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.TensorInfo.Builder {
                let resultDecodedBuilder = Tensorflow.TensorInfo.Builder()
                if let jsonValueName = jsonMap["name"] as? String {
                    resultDecodedBuilder.name = jsonValueName
                }
                if let jsonValueDtype = jsonMap["dtype"] as? String {
                    resultDecodedBuilder.dtype = try Tensorflow.DataType.fromString(str: jsonValueDtype)
                }
                if let jsonValueTensorShape = jsonMap["tensorShape"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.tensorShape = try Tensorflow.TensorShapeProto.Builder.decodeToBuilder(jsonMap:jsonValueTensorShape).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.TensorInfo.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.TensorInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// SignatureDef defines the signature of a computation supported by a TensorFlow
    /// graph.
    /// For example, a model with two loss computations, sharing a single input,
    /// might have the following signature_def map.
    /// Note that across the two SignatureDefs "loss_A" and "loss_B", the input key,
    /// output key, and method_name are identical, and will be used by system(s) that
    /// implement or rely upon this particular loss method. The output tensor names
    /// differ, demonstrating how different outputs can exist for the same method.
    /// signature_def {
    ///   key: "loss_A"
    ///   value {
    ///     inputs {
    ///       key: "input"
    ///       value {
    ///         name: "input:0"
    ///         dtype: DT_STRING
    ///         tensor_shape: ...
    ///       }
    ///     }
    ///     outputs {
    ///       key: "loss_output"
    ///       value {
    ///         name: "loss_output_A:0"
    ///         dtype: DT_FLOAT
    ///         tensor_shape: ...
    ///       }
    ///     }
    ///   }
    ///   ...
    ///   method_name: "some/package/compute_loss"
    /// }
    /// signature_def {
    ///   key: "loss_B"
    ///   value {
    ///     inputs {
    ///       key: "input"
    ///       value {
    ///         name: "input:0"
    ///         dtype: DT_STRING
    ///         tensor_shape: ...
    ///       }
    ///     }
    ///     outputs {
    ///       key: "loss_output"
    ///       value {
    ///         name: "loss_output_B:0"
    ///         dtype: DT_FLOAT
    ///         tensor_shape: ...
    ///       }
    ///     }
    ///   }
    ///   ...
    ///   method_name: "some/package/compute_loss"
    /// }
    final public class SignatureDef : GeneratedMessage {

        public static func == (lhs: Tensorflow.SignatureDef, rhs: Tensorflow.SignatureDef) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasInputs == rhs.hasInputs) && (!lhs.hasInputs || lhs.inputs == rhs.inputs)
            fieldCheck = fieldCheck && (lhs.hasOutputs == rhs.hasOutputs) && (!lhs.hasOutputs || lhs.outputs == rhs.outputs)
            fieldCheck = fieldCheck && (lhs.hasMethodName == rhs.hasMethodName) && (!lhs.hasMethodName || lhs.methodName == rhs.methodName)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        final public class InputsEntry : GeneratedMessage {

            public static func == (lhs: Tensorflow.SignatureDef.InputsEntry, rhs: Tensorflow.SignatureDef.InputsEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:String = ""
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:Tensorflow.TensorInfo!
            public fileprivate(set) var hasValue:Bool = false
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeString(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeMessage(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeStringSize(fieldNumber: 1)
                }
                if hasValue {
                    if let varSizevalue = value?.computeMessageSize(fieldNumber: 2) {
                        serialize_size += varSizevalue
                    }
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.SignatureDef.InputsEntry.Builder {
                return Tensorflow.SignatureDef.InputsEntry.classBuilder() as! Tensorflow.SignatureDef.InputsEntry.Builder
            }
            public func getBuilder() -> Tensorflow.SignatureDef.InputsEntry.Builder {
                return classBuilder() as! Tensorflow.SignatureDef.InputsEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.SignatureDef.InputsEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.SignatureDef.InputsEntry.Builder()
            }
            public func toBuilder() throws -> Tensorflow.SignatureDef.InputsEntry.Builder {
                return try Tensorflow.SignatureDef.InputsEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.SignatureDef.InputsEntry) throws -> Tensorflow.SignatureDef.InputsEntry.Builder {
                return try Tensorflow.SignatureDef.InputsEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = key
                }
                if hasValue {
                    jsonMap["value"] = try value.encode()
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.SignatureDef.InputsEntry {
                return try Tensorflow.SignatureDef.InputsEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.SignatureDef.InputsEntry {
                return try Tensorflow.SignatureDef.InputsEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value {\n"
                    if let outDescValue = value {
                        output += try outDescValue.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        if let hashValuevalue = value?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuevalue
                        }
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.SignatureDef.InputsEntry"
            }
            override public func className() -> String {
                return "Tensorflow.SignatureDef.InputsEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.SignatureDef.InputsEntry = Tensorflow.SignatureDef.InputsEntry()
                public func getMessage() -> Tensorflow.SignatureDef.InputsEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:String {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:String) -> Tensorflow.SignatureDef.InputsEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> Tensorflow.SignatureDef.InputsEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = ""
                    return self
                }
                public var value:Tensorflow.TensorInfo! {
                    get {
                        if valueBuilder_ != nil {
                            builderResult.value = valueBuilder_.getMessage()
                        }
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                fileprivate var valueBuilder_:Tensorflow.TensorInfo.Builder! {
                    didSet {
                        builderResult.hasValue = true
                    }
                }
                public func getValueBuilder() -> Tensorflow.TensorInfo.Builder {
                    if valueBuilder_ == nil {
                        valueBuilder_ = Tensorflow.TensorInfo.Builder()
                        builderResult.value = valueBuilder_.getMessage()
                        if value != nil {
                            try! valueBuilder_.mergeFrom(other: value)
                        }
                    }
                    return valueBuilder_
                }
                @discardableResult
                public func setValue(_ value:Tensorflow.TensorInfo!) -> Tensorflow.SignatureDef.InputsEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func mergeValue(value:Tensorflow.TensorInfo) throws -> Tensorflow.SignatureDef.InputsEntry.Builder {
                    if builderResult.hasValue {
                        builderResult.value = try Tensorflow.TensorInfo.builderWithPrototype(prototype:builderResult.value).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.value = value
                    }
                    builderResult.hasValue = true
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.SignatureDef.InputsEntry.Builder {
                    valueBuilder_ = nil
                    builderResult.hasValue = false
                    builderResult.value = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.SignatureDef.InputsEntry.Builder {
                    builderResult = Tensorflow.SignatureDef.InputsEntry()
                    return self
                }
                override public func clone() throws -> Tensorflow.SignatureDef.InputsEntry.Builder {
                    return try Tensorflow.SignatureDef.InputsEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.SignatureDef.InputsEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.SignatureDef.InputsEntry {
                    let returnMe:Tensorflow.SignatureDef.InputsEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.SignatureDef.InputsEntry) throws -> Tensorflow.SignatureDef.InputsEntry.Builder {
                    if other == Tensorflow.SignatureDef.InputsEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if (other.hasValue) {
                        try mergeValue(value: other.value)
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.SignatureDef.InputsEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.SignatureDef.InputsEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            key = try codedInputStream.readString()

                        case 18:
                            let subBuilder:Tensorflow.TensorInfo.Builder = Tensorflow.TensorInfo.Builder()
                            if hasValue {
                                try subBuilder.mergeFrom(other: value)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            value = subBuilder.buildPartial()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.SignatureDef.InputsEntry.Builder {
                    let resultDecodedBuilder = Tensorflow.SignatureDef.InputsEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = jsonValueKey
                    }
                    if let jsonValueValue = jsonMap["value"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.value = try Tensorflow.TensorInfo.Builder.decodeToBuilder(jsonMap:jsonValueValue).build()

                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.SignatureDef.InputsEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.SignatureDef.InputsEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        final public class OutputsEntry : GeneratedMessage {

            public static func == (lhs: Tensorflow.SignatureDef.OutputsEntry, rhs: Tensorflow.SignatureDef.OutputsEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:String = ""
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:Tensorflow.TensorInfo!
            public fileprivate(set) var hasValue:Bool = false
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeString(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeMessage(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeStringSize(fieldNumber: 1)
                }
                if hasValue {
                    if let varSizevalue = value?.computeMessageSize(fieldNumber: 2) {
                        serialize_size += varSizevalue
                    }
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.SignatureDef.OutputsEntry.Builder {
                return Tensorflow.SignatureDef.OutputsEntry.classBuilder() as! Tensorflow.SignatureDef.OutputsEntry.Builder
            }
            public func getBuilder() -> Tensorflow.SignatureDef.OutputsEntry.Builder {
                return classBuilder() as! Tensorflow.SignatureDef.OutputsEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.SignatureDef.OutputsEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.SignatureDef.OutputsEntry.Builder()
            }
            public func toBuilder() throws -> Tensorflow.SignatureDef.OutputsEntry.Builder {
                return try Tensorflow.SignatureDef.OutputsEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.SignatureDef.OutputsEntry) throws -> Tensorflow.SignatureDef.OutputsEntry.Builder {
                return try Tensorflow.SignatureDef.OutputsEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = key
                }
                if hasValue {
                    jsonMap["value"] = try value.encode()
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.SignatureDef.OutputsEntry {
                return try Tensorflow.SignatureDef.OutputsEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.SignatureDef.OutputsEntry {
                return try Tensorflow.SignatureDef.OutputsEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value {\n"
                    if let outDescValue = value {
                        output += try outDescValue.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        if let hashValuevalue = value?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuevalue
                        }
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.SignatureDef.OutputsEntry"
            }
            override public func className() -> String {
                return "Tensorflow.SignatureDef.OutputsEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.SignatureDef.OutputsEntry = Tensorflow.SignatureDef.OutputsEntry()
                public func getMessage() -> Tensorflow.SignatureDef.OutputsEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:String {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:String) -> Tensorflow.SignatureDef.OutputsEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> Tensorflow.SignatureDef.OutputsEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = ""
                    return self
                }
                public var value:Tensorflow.TensorInfo! {
                    get {
                        if valueBuilder_ != nil {
                            builderResult.value = valueBuilder_.getMessage()
                        }
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                fileprivate var valueBuilder_:Tensorflow.TensorInfo.Builder! {
                    didSet {
                        builderResult.hasValue = true
                    }
                }
                public func getValueBuilder() -> Tensorflow.TensorInfo.Builder {
                    if valueBuilder_ == nil {
                        valueBuilder_ = Tensorflow.TensorInfo.Builder()
                        builderResult.value = valueBuilder_.getMessage()
                        if value != nil {
                            try! valueBuilder_.mergeFrom(other: value)
                        }
                    }
                    return valueBuilder_
                }
                @discardableResult
                public func setValue(_ value:Tensorflow.TensorInfo!) -> Tensorflow.SignatureDef.OutputsEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func mergeValue(value:Tensorflow.TensorInfo) throws -> Tensorflow.SignatureDef.OutputsEntry.Builder {
                    if builderResult.hasValue {
                        builderResult.value = try Tensorflow.TensorInfo.builderWithPrototype(prototype:builderResult.value).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.value = value
                    }
                    builderResult.hasValue = true
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.SignatureDef.OutputsEntry.Builder {
                    valueBuilder_ = nil
                    builderResult.hasValue = false
                    builderResult.value = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.SignatureDef.OutputsEntry.Builder {
                    builderResult = Tensorflow.SignatureDef.OutputsEntry()
                    return self
                }
                override public func clone() throws -> Tensorflow.SignatureDef.OutputsEntry.Builder {
                    return try Tensorflow.SignatureDef.OutputsEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.SignatureDef.OutputsEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.SignatureDef.OutputsEntry {
                    let returnMe:Tensorflow.SignatureDef.OutputsEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.SignatureDef.OutputsEntry) throws -> Tensorflow.SignatureDef.OutputsEntry.Builder {
                    if other == Tensorflow.SignatureDef.OutputsEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if (other.hasValue) {
                        try mergeValue(value: other.value)
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.SignatureDef.OutputsEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.SignatureDef.OutputsEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            key = try codedInputStream.readString()

                        case 18:
                            let subBuilder:Tensorflow.TensorInfo.Builder = Tensorflow.TensorInfo.Builder()
                            if hasValue {
                                try subBuilder.mergeFrom(other: value)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            value = subBuilder.buildPartial()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.SignatureDef.OutputsEntry.Builder {
                    let resultDecodedBuilder = Tensorflow.SignatureDef.OutputsEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = jsonValueKey
                    }
                    if let jsonValueValue = jsonMap["value"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.value = try Tensorflow.TensorInfo.Builder.decodeToBuilder(jsonMap:jsonValueValue).build()

                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.SignatureDef.OutputsEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.SignatureDef.OutputsEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        /// Named input parameters.
        public fileprivate(set) var inputs:Dictionary<String,Tensorflow.TensorInfo> = Dictionary<String,Tensorflow.TensorInfo>()

        public fileprivate(set) var hasInputs:Bool = false
        /// Named output parameters.
        public fileprivate(set) var outputs:Dictionary<String,Tensorflow.TensorInfo> = Dictionary<String,Tensorflow.TensorInfo>()

        public fileprivate(set) var hasOutputs:Bool = false
        /// Extensible method_name information enabling third-party users to mark a
        /// SignatureDef as supporting a particular method. This enables producers and
        /// consumers of SignatureDefs, e.g. a model definition library and a serving
        /// library to have a clear hand-off regarding the semantics of a computation.
        /// Note that multiple SignatureDefs in a single MetaGraphDef may have the same
        /// method_name. This is commonly used to support multi-headed computation,
        /// where a single graph computation may return multiple results.
        public fileprivate(set) var methodName:String = ""
        public fileprivate(set) var hasMethodName:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasInputs {
                for (keyInputs, valueInputs) in inputs {
                    let valueOfInputs = try! Tensorflow.SignatureDef.InputsEntry.Builder().setKey(keyInputs).setValue(valueInputs).build()
                      try codedOutputStream.writeMessage(fieldNumber: 1, value:valueOfInputs)
                  }
            }
            if hasOutputs {
                for (keyOutputs, valueOutputs) in outputs {
                    let valueOfOutputs = try! Tensorflow.SignatureDef.OutputsEntry.Builder().setKey(keyOutputs).setValue(valueOutputs).build()
                      try codedOutputStream.writeMessage(fieldNumber: 2, value:valueOfOutputs)
                  }
            }
            if hasMethodName {
                try codedOutputStream.writeString(fieldNumber: 3, value:methodName)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasInputs {
                  for (keyInputs, valueInputs) in inputs {
                      let valueOfInputs = try! Tensorflow.SignatureDef.InputsEntry.Builder().setKey(keyInputs).setValue(valueInputs).build()
                serialize_size += valueOfInputs.computeMessageSize(fieldNumber: 1)
                }
            }
            if hasOutputs {
                  for (keyOutputs, valueOutputs) in outputs {
                      let valueOfOutputs = try! Tensorflow.SignatureDef.OutputsEntry.Builder().setKey(keyOutputs).setValue(valueOutputs).build()
                serialize_size += valueOfOutputs.computeMessageSize(fieldNumber: 2)
                }
            }
            if hasMethodName {
                serialize_size += methodName.computeStringSize(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.SignatureDef.Builder {
            return Tensorflow.SignatureDef.classBuilder() as! Tensorflow.SignatureDef.Builder
        }
        public func getBuilder() -> Tensorflow.SignatureDef.Builder {
            return classBuilder() as! Tensorflow.SignatureDef.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.SignatureDef.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.SignatureDef.Builder()
        }
        public func toBuilder() throws -> Tensorflow.SignatureDef.Builder {
            return try Tensorflow.SignatureDef.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.SignatureDef) throws -> Tensorflow.SignatureDef.Builder {
            return try Tensorflow.SignatureDef.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasInputs {
                var mapInputs = Dictionary<String, Dictionary<String,Any>>()
                for (keyInputs, valueInputs) in inputs {
                    mapInputs["\(keyInputs)"] = try valueInputs.encode()
                }
                jsonMap["inputs"] = mapInputs
            }
            if hasOutputs {
                var mapOutputs = Dictionary<String, Dictionary<String,Any>>()
                for (keyOutputs, valueOutputs) in outputs {
                    mapOutputs["\(keyOutputs)"] = try valueOutputs.encode()
                }
                jsonMap["outputs"] = mapOutputs
            }
            if hasMethodName {
                jsonMap["methodName"] = methodName
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.SignatureDef {
            return try Tensorflow.SignatureDef.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.SignatureDef {
            return try Tensorflow.SignatureDef.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasInputs {
                output += "\(indent) inputs: \(inputs) \n"
            }
            if hasOutputs {
                output += "\(indent) outputs: \(outputs) \n"
            }
            if hasMethodName {
                output += "\(indent) methodName: \(methodName) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasInputs {
                    for (keyInputs, valueInputs) in inputs {
                        hashCode = (hashCode &* 31) &+ keyInputs.hashValue
                        hashCode = (hashCode &* 31) &+ valueInputs.hashValue
                    }
                }
                if hasOutputs {
                    for (keyOutputs, valueOutputs) in outputs {
                        hashCode = (hashCode &* 31) &+ keyOutputs.hashValue
                        hashCode = (hashCode &* 31) &+ valueOutputs.hashValue
                    }
                }
                if hasMethodName {
                    hashCode = (hashCode &* 31) &+ methodName.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.SignatureDef"
        }
        override public func className() -> String {
            return "Tensorflow.SignatureDef"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.SignatureDef = Tensorflow.SignatureDef()
            public func getMessage() -> Tensorflow.SignatureDef {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Named input parameters.
            public var hasInputs:Bool {
                get {
                    return builderResult.hasInputs
                }
            }
            public var inputs:Dictionary<String,Tensorflow.TensorInfo> {
                get {
                    return builderResult.inputs
                }
                set (value) {
                    builderResult.hasInputs = true
                    builderResult.inputs = value
                }
            }
            @discardableResult
            public func setInputs(_ value:Dictionary<String,Tensorflow.TensorInfo>) -> Tensorflow.SignatureDef.Builder {
                self.inputs = value
                return self
            }
            @discardableResult
            public func clearInputs() -> Tensorflow.SignatureDef.Builder{
                builderResult.hasInputs = false
                builderResult.inputs = Dictionary<String,Tensorflow.TensorInfo>()
                return self
            }
            /// Named output parameters.
            public var hasOutputs:Bool {
                get {
                    return builderResult.hasOutputs
                }
            }
            public var outputs:Dictionary<String,Tensorflow.TensorInfo> {
                get {
                    return builderResult.outputs
                }
                set (value) {
                    builderResult.hasOutputs = true
                    builderResult.outputs = value
                }
            }
            @discardableResult
            public func setOutputs(_ value:Dictionary<String,Tensorflow.TensorInfo>) -> Tensorflow.SignatureDef.Builder {
                self.outputs = value
                return self
            }
            @discardableResult
            public func clearOutputs() -> Tensorflow.SignatureDef.Builder{
                builderResult.hasOutputs = false
                builderResult.outputs = Dictionary<String,Tensorflow.TensorInfo>()
                return self
            }
            /// Extensible method_name information enabling third-party users to mark a
            /// SignatureDef as supporting a particular method. This enables producers and
            /// consumers of SignatureDefs, e.g. a model definition library and a serving
            /// library to have a clear hand-off regarding the semantics of a computation.
            /// Note that multiple SignatureDefs in a single MetaGraphDef may have the same
            /// method_name. This is commonly used to support multi-headed computation,
            /// where a single graph computation may return multiple results.
            public var methodName:String {
                get {
                    return builderResult.methodName
                }
                set (value) {
                    builderResult.hasMethodName = true
                    builderResult.methodName = value
                }
            }
            public var hasMethodName:Bool {
                get {
                    return builderResult.hasMethodName
                }
            }
            @discardableResult
            public func setMethodName(_ value:String) -> Tensorflow.SignatureDef.Builder {
                self.methodName = value
                return self
            }
            @discardableResult
            public func clearMethodName() -> Tensorflow.SignatureDef.Builder{
                builderResult.hasMethodName = false
                builderResult.methodName = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.SignatureDef.Builder {
                builderResult = Tensorflow.SignatureDef()
                return self
            }
            override public func clone() throws -> Tensorflow.SignatureDef.Builder {
                return try Tensorflow.SignatureDef.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.SignatureDef {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.SignatureDef {
                let returnMe:Tensorflow.SignatureDef = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.SignatureDef) throws -> Tensorflow.SignatureDef.Builder {
                if other == Tensorflow.SignatureDef() {
                    return self
                }
                if other.hasInputs {
                    inputs = other.inputs
                }
                if other.hasOutputs {
                    outputs = other.outputs
                }
                if other.hasMethodName {
                    methodName = other.methodName
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.SignatureDef.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.SignatureDef.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Tensorflow.SignatureDef.InputsEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfInputs = subBuilder.buildPartial()
                        inputs[buildOfInputs.key] = buildOfInputs.value

                    case 18:
                        let subBuilder = Tensorflow.SignatureDef.OutputsEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfOutputs = subBuilder.buildPartial()
                        outputs[buildOfOutputs.key] = buildOfOutputs.value

                    case 26:
                        methodName = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.SignatureDef.Builder {
                let resultDecodedBuilder = Tensorflow.SignatureDef.Builder()
                if let jsonValueInputs = jsonMap["inputs"] as? Dictionary<String, Dictionary<String,Any>> {
                    var mapInputs = Dictionary<String, Tensorflow.TensorInfo>()
                    for (keyInputs, valueInputs) in jsonValueInputs {
                        guard let keyFromInputs = String(keyInputs) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapInputs[keyFromInputs] = try Tensorflow.TensorInfo.Builder.decodeToBuilder(jsonMap:valueInputs).build()

                    }
                    resultDecodedBuilder.inputs = mapInputs
                }
                if let jsonValueOutputs = jsonMap["outputs"] as? Dictionary<String, Dictionary<String,Any>> {
                    var mapOutputs = Dictionary<String, Tensorflow.TensorInfo>()
                    for (keyOutputs, valueOutputs) in jsonValueOutputs {
                        guard let keyFromOutputs = String(keyOutputs) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapOutputs[keyFromOutputs] = try Tensorflow.TensorInfo.Builder.decodeToBuilder(jsonMap:valueOutputs).build()

                    }
                    resultDecodedBuilder.outputs = mapOutputs
                }
                if let jsonValueMethodName = jsonMap["methodName"] as? String {
                    resultDecodedBuilder.methodName = jsonValueMethodName
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.SignatureDef.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.SignatureDef.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// An asset file def for a single file or a set of sharded files with the same
    /// name.
    final public class AssetFileDef : GeneratedMessage {

        public static func == (lhs: Tensorflow.AssetFileDef, rhs: Tensorflow.AssetFileDef) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasTensorInfo == rhs.hasTensorInfo) && (!lhs.hasTensorInfo || lhs.tensorInfo == rhs.tensorInfo)
            fieldCheck = fieldCheck && (lhs.hasFilename == rhs.hasFilename) && (!lhs.hasFilename || lhs.filename == rhs.filename)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var tensorInfo:Tensorflow.TensorInfo!
        public fileprivate(set) var hasTensorInfo:Bool = false
        /// The filename within an assets directory. Note: does not include the path
        /// prefix, i.e. directories. For an asset at /tmp/path/vocab.txt, the filename
        /// would be "vocab.txt".
        public fileprivate(set) var filename:String = ""
        public fileprivate(set) var hasFilename:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasTensorInfo {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:tensorInfo)
            }
            if hasFilename {
                try codedOutputStream.writeString(fieldNumber: 2, value:filename)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasTensorInfo {
                if let varSizetensorInfo = tensorInfo?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizetensorInfo
                }
            }
            if hasFilename {
                serialize_size += filename.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.AssetFileDef.Builder {
            return Tensorflow.AssetFileDef.classBuilder() as! Tensorflow.AssetFileDef.Builder
        }
        public func getBuilder() -> Tensorflow.AssetFileDef.Builder {
            return classBuilder() as! Tensorflow.AssetFileDef.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.AssetFileDef.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.AssetFileDef.Builder()
        }
        public func toBuilder() throws -> Tensorflow.AssetFileDef.Builder {
            return try Tensorflow.AssetFileDef.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.AssetFileDef) throws -> Tensorflow.AssetFileDef.Builder {
            return try Tensorflow.AssetFileDef.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasTensorInfo {
                jsonMap["tensorInfo"] = try tensorInfo.encode()
            }
            if hasFilename {
                jsonMap["filename"] = filename
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.AssetFileDef {
            return try Tensorflow.AssetFileDef.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.AssetFileDef {
            return try Tensorflow.AssetFileDef.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasTensorInfo {
                output += "\(indent) tensorInfo {\n"
                if let outDescTensorInfo = tensorInfo {
                    output += try outDescTensorInfo.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasFilename {
                output += "\(indent) filename: \(filename) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasTensorInfo {
                    if let hashValuetensorInfo = tensorInfo?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuetensorInfo
                    }
                }
                if hasFilename {
                    hashCode = (hashCode &* 31) &+ filename.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.AssetFileDef"
        }
        override public func className() -> String {
            return "Tensorflow.AssetFileDef"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.AssetFileDef = Tensorflow.AssetFileDef()
            public func getMessage() -> Tensorflow.AssetFileDef {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The tensor to bind the asset filename to.
            public var tensorInfo:Tensorflow.TensorInfo! {
                get {
                    if tensorInfoBuilder_ != nil {
                        builderResult.tensorInfo = tensorInfoBuilder_.getMessage()
                    }
                    return builderResult.tensorInfo
                }
                set (value) {
                    builderResult.hasTensorInfo = true
                    builderResult.tensorInfo = value
                }
            }
            public var hasTensorInfo:Bool {
                get {
                    return builderResult.hasTensorInfo
                }
            }
            fileprivate var tensorInfoBuilder_:Tensorflow.TensorInfo.Builder! {
                didSet {
                    builderResult.hasTensorInfo = true
                }
            }
            public func getTensorInfoBuilder() -> Tensorflow.TensorInfo.Builder {
                if tensorInfoBuilder_ == nil {
                    tensorInfoBuilder_ = Tensorflow.TensorInfo.Builder()
                    builderResult.tensorInfo = tensorInfoBuilder_.getMessage()
                    if tensorInfo != nil {
                        try! tensorInfoBuilder_.mergeFrom(other: tensorInfo)
                    }
                }
                return tensorInfoBuilder_
            }
            @discardableResult
            public func setTensorInfo(_ value:Tensorflow.TensorInfo!) -> Tensorflow.AssetFileDef.Builder {
                self.tensorInfo = value
                return self
            }
            @discardableResult
            public func mergeTensorInfo(value:Tensorflow.TensorInfo) throws -> Tensorflow.AssetFileDef.Builder {
                if builderResult.hasTensorInfo {
                    builderResult.tensorInfo = try Tensorflow.TensorInfo.builderWithPrototype(prototype:builderResult.tensorInfo).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.tensorInfo = value
                }
                builderResult.hasTensorInfo = true
                return self
            }
            @discardableResult
            public func clearTensorInfo() -> Tensorflow.AssetFileDef.Builder {
                tensorInfoBuilder_ = nil
                builderResult.hasTensorInfo = false
                builderResult.tensorInfo = nil
                return self
            }
            /// The filename within an assets directory. Note: does not include the path
            /// prefix, i.e. directories. For an asset at /tmp/path/vocab.txt, the filename
            /// would be "vocab.txt".
            public var filename:String {
                get {
                    return builderResult.filename
                }
                set (value) {
                    builderResult.hasFilename = true
                    builderResult.filename = value
                }
            }
            public var hasFilename:Bool {
                get {
                    return builderResult.hasFilename
                }
            }
            @discardableResult
            public func setFilename(_ value:String) -> Tensorflow.AssetFileDef.Builder {
                self.filename = value
                return self
            }
            @discardableResult
            public func clearFilename() -> Tensorflow.AssetFileDef.Builder{
                builderResult.hasFilename = false
                builderResult.filename = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.AssetFileDef.Builder {
                builderResult = Tensorflow.AssetFileDef()
                return self
            }
            override public func clone() throws -> Tensorflow.AssetFileDef.Builder {
                return try Tensorflow.AssetFileDef.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.AssetFileDef {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.AssetFileDef {
                let returnMe:Tensorflow.AssetFileDef = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.AssetFileDef) throws -> Tensorflow.AssetFileDef.Builder {
                if other == Tensorflow.AssetFileDef() {
                    return self
                }
                if (other.hasTensorInfo) {
                    try mergeTensorInfo(value: other.tensorInfo)
                }
                if other.hasFilename {
                    filename = other.filename
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.AssetFileDef.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.AssetFileDef.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Tensorflow.TensorInfo.Builder = Tensorflow.TensorInfo.Builder()
                        if hasTensorInfo {
                            try subBuilder.mergeFrom(other: tensorInfo)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        tensorInfo = subBuilder.buildPartial()

                    case 18:
                        filename = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.AssetFileDef.Builder {
                let resultDecodedBuilder = Tensorflow.AssetFileDef.Builder()
                if let jsonValueTensorInfo = jsonMap["tensorInfo"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.tensorInfo = try Tensorflow.TensorInfo.Builder.decodeToBuilder(jsonMap:jsonValueTensorInfo).build()

                }
                if let jsonValueFilename = jsonMap["filename"] as? String {
                    resultDecodedBuilder.filename = jsonValueFilename
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.AssetFileDef.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.AssetFileDef.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.MetaGraphDef: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.MetaGraphDef> {
        var mergedArray = Array<Tensorflow.MetaGraphDef>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.MetaGraphDef? {
        return try Tensorflow.MetaGraphDef.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.MetaGraphDef {
        return try Tensorflow.MetaGraphDef.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.MetaGraphRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MetaGraphDef {
        return try Tensorflow.MetaGraphDef.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.MetaGraphDef {
        return try Tensorflow.MetaGraphDef.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MetaGraphDef {
        return try Tensorflow.MetaGraphDef.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.MetaGraphDef {
        return try Tensorflow.MetaGraphDef.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MetaGraphDef {
        return try Tensorflow.MetaGraphDef.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "metaInfoDef": return self.metaInfoDef
        case "graphDef": return self.graphDef
        case "saverDef": return self.saverDef
        case "collectionDef": return self.collectionDef
        case "signatureDef": return self.signatureDef
        case "assetFileDef": return self.assetFileDef
        default: return nil
        }
    }
}
extension Tensorflow.MetaGraphDef.MetaInfoDef: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.MetaGraphDef.MetaInfoDef> {
        var mergedArray = Array<Tensorflow.MetaGraphDef.MetaInfoDef>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.MetaGraphDef.MetaInfoDef? {
        return try Tensorflow.MetaGraphDef.MetaInfoDef.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.MetaGraphDef.MetaInfoDef {
        return try Tensorflow.MetaGraphDef.MetaInfoDef.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.MetaGraphRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MetaGraphDef.MetaInfoDef {
        return try Tensorflow.MetaGraphDef.MetaInfoDef.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.MetaGraphDef.MetaInfoDef {
        return try Tensorflow.MetaGraphDef.MetaInfoDef.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MetaGraphDef.MetaInfoDef {
        return try Tensorflow.MetaGraphDef.MetaInfoDef.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.MetaGraphDef.MetaInfoDef {
        return try Tensorflow.MetaGraphDef.MetaInfoDef.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MetaGraphDef.MetaInfoDef {
        return try Tensorflow.MetaGraphDef.MetaInfoDef.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "metaGraphVersion": return self.metaGraphVersion
        case "strippedOpList": return self.strippedOpList
        case "anyInfo": return self.anyInfo
        case "tags": return self.tags
        case "tensorflowVersion": return self.tensorflowVersion
        case "tensorflowGitVersion": return self.tensorflowGitVersion
        default: return nil
        }
    }
}
extension Tensorflow.MetaGraphDef.CollectionDefEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.MetaGraphDef.CollectionDefEntry> {
        var mergedArray = Array<Tensorflow.MetaGraphDef.CollectionDefEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.MetaGraphDef.CollectionDefEntry? {
        return try Tensorflow.MetaGraphDef.CollectionDefEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.MetaGraphDef.CollectionDefEntry {
        return try Tensorflow.MetaGraphDef.CollectionDefEntry.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.MetaGraphRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MetaGraphDef.CollectionDefEntry {
        return try Tensorflow.MetaGraphDef.CollectionDefEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.MetaGraphDef.CollectionDefEntry {
        return try Tensorflow.MetaGraphDef.CollectionDefEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MetaGraphDef.CollectionDefEntry {
        return try Tensorflow.MetaGraphDef.CollectionDefEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.MetaGraphDef.CollectionDefEntry {
        return try Tensorflow.MetaGraphDef.CollectionDefEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MetaGraphDef.CollectionDefEntry {
        return try Tensorflow.MetaGraphDef.CollectionDefEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.MetaGraphDef.SignatureDefEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.MetaGraphDef.SignatureDefEntry> {
        var mergedArray = Array<Tensorflow.MetaGraphDef.SignatureDefEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.MetaGraphDef.SignatureDefEntry? {
        return try Tensorflow.MetaGraphDef.SignatureDefEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.MetaGraphDef.SignatureDefEntry {
        return try Tensorflow.MetaGraphDef.SignatureDefEntry.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.MetaGraphRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MetaGraphDef.SignatureDefEntry {
        return try Tensorflow.MetaGraphDef.SignatureDefEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.MetaGraphDef.SignatureDefEntry {
        return try Tensorflow.MetaGraphDef.SignatureDefEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MetaGraphDef.SignatureDefEntry {
        return try Tensorflow.MetaGraphDef.SignatureDefEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.MetaGraphDef.SignatureDefEntry {
        return try Tensorflow.MetaGraphDef.SignatureDefEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MetaGraphDef.SignatureDefEntry {
        return try Tensorflow.MetaGraphDef.SignatureDefEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.MetaGraphDef.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "metaInfoDef": return self.metaInfoDef
            case "graphDef": return self.graphDef
            case "saverDef": return self.saverDef
            case "collectionDef": return self.collectionDef
            case "signatureDef": return self.signatureDef
            case "assetFileDef": return self.assetFileDef
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "metaInfoDef":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.MetaGraphDef.MetaInfoDef else {
                    return
                }
                self.metaInfoDef = newSubscriptValue
            case "graphDef":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.GraphDef else {
                    return
                }
                self.graphDef = newSubscriptValue
            case "saverDef":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.SaverDef else {
                    return
                }
                self.saverDef = newSubscriptValue
            case "collectionDef":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,Tensorflow.CollectionDef> else {
                    return
                }
                self.collectionDef = newSubscriptValue
            case "signatureDef":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,Tensorflow.SignatureDef> else {
                    return
                }
                self.signatureDef = newSubscriptValue
            case "assetFileDef":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.AssetFileDef> else {
                    return
                }
                self.assetFileDef = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.MetaGraphDef.MetaInfoDef.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "metaGraphVersion": return self.metaGraphVersion
            case "strippedOpList": return self.strippedOpList
            case "anyInfo": return self.anyInfo
            case "tags": return self.tags
            case "tensorflowVersion": return self.tensorflowVersion
            case "tensorflowGitVersion": return self.tensorflowGitVersion
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "metaGraphVersion":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.metaGraphVersion = newSubscriptValue
            case "strippedOpList":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.OpList else {
                    return
                }
                self.strippedOpList = newSubscriptValue
            case "anyInfo":
                guard let newSubscriptValue = newSubscriptValue as? Google.Protobuf.`Any` else {
                    return
                }
                self.anyInfo = newSubscriptValue
            case "tags":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.tags = newSubscriptValue
            case "tensorflowVersion":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.tensorflowVersion = newSubscriptValue
            case "tensorflowGitVersion":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.tensorflowGitVersion = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.MetaGraphDef.CollectionDefEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.CollectionDef else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.MetaGraphDef.SignatureDefEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.SignatureDef else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.CollectionDef: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.CollectionDef> {
        var mergedArray = Array<Tensorflow.CollectionDef>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.CollectionDef? {
        return try Tensorflow.CollectionDef.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.CollectionDef {
        return try Tensorflow.CollectionDef.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.MetaGraphRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CollectionDef {
        return try Tensorflow.CollectionDef.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.CollectionDef {
        return try Tensorflow.CollectionDef.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CollectionDef {
        return try Tensorflow.CollectionDef.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CollectionDef {
        return try Tensorflow.CollectionDef.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CollectionDef {
        return try Tensorflow.CollectionDef.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "nodeList": return self.nodeList
        case "bytesList": return self.bytesList
        case "int64List": return self.int64List
        case "floatList": return self.floatList
        case "anyList": return self.anyList
        default: return nil
        }
    }
}
extension Tensorflow.CollectionDef.NodeList: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.CollectionDef.NodeList> {
        var mergedArray = Array<Tensorflow.CollectionDef.NodeList>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.CollectionDef.NodeList? {
        return try Tensorflow.CollectionDef.NodeList.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.CollectionDef.NodeList {
        return try Tensorflow.CollectionDef.NodeList.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.MetaGraphRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CollectionDef.NodeList {
        return try Tensorflow.CollectionDef.NodeList.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.CollectionDef.NodeList {
        return try Tensorflow.CollectionDef.NodeList.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CollectionDef.NodeList {
        return try Tensorflow.CollectionDef.NodeList.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CollectionDef.NodeList {
        return try Tensorflow.CollectionDef.NodeList.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CollectionDef.NodeList {
        return try Tensorflow.CollectionDef.NodeList.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.CollectionDef.BytesList: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.CollectionDef.BytesList> {
        var mergedArray = Array<Tensorflow.CollectionDef.BytesList>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.CollectionDef.BytesList? {
        return try Tensorflow.CollectionDef.BytesList.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.CollectionDef.BytesList {
        return try Tensorflow.CollectionDef.BytesList.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.MetaGraphRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CollectionDef.BytesList {
        return try Tensorflow.CollectionDef.BytesList.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.CollectionDef.BytesList {
        return try Tensorflow.CollectionDef.BytesList.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CollectionDef.BytesList {
        return try Tensorflow.CollectionDef.BytesList.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CollectionDef.BytesList {
        return try Tensorflow.CollectionDef.BytesList.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CollectionDef.BytesList {
        return try Tensorflow.CollectionDef.BytesList.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.CollectionDef.Int64List: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.CollectionDef.Int64List> {
        var mergedArray = Array<Tensorflow.CollectionDef.Int64List>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.CollectionDef.Int64List? {
        return try Tensorflow.CollectionDef.Int64List.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.CollectionDef.Int64List {
        return try Tensorflow.CollectionDef.Int64List.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.MetaGraphRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CollectionDef.Int64List {
        return try Tensorflow.CollectionDef.Int64List.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.CollectionDef.Int64List {
        return try Tensorflow.CollectionDef.Int64List.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CollectionDef.Int64List {
        return try Tensorflow.CollectionDef.Int64List.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CollectionDef.Int64List {
        return try Tensorflow.CollectionDef.Int64List.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CollectionDef.Int64List {
        return try Tensorflow.CollectionDef.Int64List.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.CollectionDef.FloatList: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.CollectionDef.FloatList> {
        var mergedArray = Array<Tensorflow.CollectionDef.FloatList>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.CollectionDef.FloatList? {
        return try Tensorflow.CollectionDef.FloatList.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.CollectionDef.FloatList {
        return try Tensorflow.CollectionDef.FloatList.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.MetaGraphRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CollectionDef.FloatList {
        return try Tensorflow.CollectionDef.FloatList.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.CollectionDef.FloatList {
        return try Tensorflow.CollectionDef.FloatList.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CollectionDef.FloatList {
        return try Tensorflow.CollectionDef.FloatList.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CollectionDef.FloatList {
        return try Tensorflow.CollectionDef.FloatList.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CollectionDef.FloatList {
        return try Tensorflow.CollectionDef.FloatList.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.CollectionDef.AnyList: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.CollectionDef.AnyList> {
        var mergedArray = Array<Tensorflow.CollectionDef.AnyList>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.CollectionDef.AnyList? {
        return try Tensorflow.CollectionDef.AnyList.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.CollectionDef.AnyList {
        return try Tensorflow.CollectionDef.AnyList.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.MetaGraphRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CollectionDef.AnyList {
        return try Tensorflow.CollectionDef.AnyList.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.CollectionDef.AnyList {
        return try Tensorflow.CollectionDef.AnyList.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CollectionDef.AnyList {
        return try Tensorflow.CollectionDef.AnyList.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CollectionDef.AnyList {
        return try Tensorflow.CollectionDef.AnyList.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CollectionDef.AnyList {
        return try Tensorflow.CollectionDef.AnyList.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.CollectionDef.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "nodeList": return self.nodeList
            case "bytesList": return self.bytesList
            case "int64List": return self.int64List
            case "floatList": return self.floatList
            case "anyList": return self.anyList
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "nodeList":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.CollectionDef.NodeList else {
                    return
                }
                self.nodeList = newSubscriptValue
            case "bytesList":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.CollectionDef.BytesList else {
                    return
                }
                self.bytesList = newSubscriptValue
            case "int64List":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.CollectionDef.Int64List else {
                    return
                }
                self.int64List = newSubscriptValue
            case "floatList":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.CollectionDef.FloatList else {
                    return
                }
                self.floatList = newSubscriptValue
            case "anyList":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.CollectionDef.AnyList else {
                    return
                }
                self.anyList = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.CollectionDef.NodeList.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.CollectionDef.BytesList.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Array<Data> else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.CollectionDef.Int64List.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.CollectionDef.FloatList.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Array<Float> else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.CollectionDef.AnyList.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Array<Google.Protobuf.`Any`> else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.TensorInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.TensorInfo> {
        var mergedArray = Array<Tensorflow.TensorInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.TensorInfo? {
        return try Tensorflow.TensorInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.TensorInfo {
        return try Tensorflow.TensorInfo.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.MetaGraphRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.TensorInfo {
        return try Tensorflow.TensorInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.TensorInfo {
        return try Tensorflow.TensorInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.TensorInfo {
        return try Tensorflow.TensorInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.TensorInfo {
        return try Tensorflow.TensorInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.TensorInfo {
        return try Tensorflow.TensorInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "name": return self.name
        case "dtype": return self.dtype
        case "tensorShape": return self.tensorShape
        default: return nil
        }
    }
}
extension Tensorflow.TensorInfo.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "name": return self.name
            case "dtype": return self.dtype
            case "tensorShape": return self.tensorShape
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "dtype":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.DataType else {
                    return
                }
                self.dtype = newSubscriptValue
            case "tensorShape":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.TensorShapeProto else {
                    return
                }
                self.tensorShape = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.SignatureDef: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.SignatureDef> {
        var mergedArray = Array<Tensorflow.SignatureDef>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.SignatureDef? {
        return try Tensorflow.SignatureDef.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.SignatureDef {
        return try Tensorflow.SignatureDef.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.MetaGraphRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.SignatureDef {
        return try Tensorflow.SignatureDef.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.SignatureDef {
        return try Tensorflow.SignatureDef.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.SignatureDef {
        return try Tensorflow.SignatureDef.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.SignatureDef {
        return try Tensorflow.SignatureDef.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.SignatureDef {
        return try Tensorflow.SignatureDef.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "inputs": return self.inputs
        case "outputs": return self.outputs
        case "methodName": return self.methodName
        default: return nil
        }
    }
}
extension Tensorflow.SignatureDef.InputsEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.SignatureDef.InputsEntry> {
        var mergedArray = Array<Tensorflow.SignatureDef.InputsEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.SignatureDef.InputsEntry? {
        return try Tensorflow.SignatureDef.InputsEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.SignatureDef.InputsEntry {
        return try Tensorflow.SignatureDef.InputsEntry.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.MetaGraphRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.SignatureDef.InputsEntry {
        return try Tensorflow.SignatureDef.InputsEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.SignatureDef.InputsEntry {
        return try Tensorflow.SignatureDef.InputsEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.SignatureDef.InputsEntry {
        return try Tensorflow.SignatureDef.InputsEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.SignatureDef.InputsEntry {
        return try Tensorflow.SignatureDef.InputsEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.SignatureDef.InputsEntry {
        return try Tensorflow.SignatureDef.InputsEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.SignatureDef.OutputsEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.SignatureDef.OutputsEntry> {
        var mergedArray = Array<Tensorflow.SignatureDef.OutputsEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.SignatureDef.OutputsEntry? {
        return try Tensorflow.SignatureDef.OutputsEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.SignatureDef.OutputsEntry {
        return try Tensorflow.SignatureDef.OutputsEntry.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.MetaGraphRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.SignatureDef.OutputsEntry {
        return try Tensorflow.SignatureDef.OutputsEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.SignatureDef.OutputsEntry {
        return try Tensorflow.SignatureDef.OutputsEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.SignatureDef.OutputsEntry {
        return try Tensorflow.SignatureDef.OutputsEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.SignatureDef.OutputsEntry {
        return try Tensorflow.SignatureDef.OutputsEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.SignatureDef.OutputsEntry {
        return try Tensorflow.SignatureDef.OutputsEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.SignatureDef.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "inputs": return self.inputs
            case "outputs": return self.outputs
            case "methodName": return self.methodName
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "inputs":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,Tensorflow.TensorInfo> else {
                    return
                }
                self.inputs = newSubscriptValue
            case "outputs":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,Tensorflow.TensorInfo> else {
                    return
                }
                self.outputs = newSubscriptValue
            case "methodName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.methodName = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.SignatureDef.InputsEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.TensorInfo else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.SignatureDef.OutputsEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.TensorInfo else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.AssetFileDef: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.AssetFileDef> {
        var mergedArray = Array<Tensorflow.AssetFileDef>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.AssetFileDef? {
        return try Tensorflow.AssetFileDef.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.AssetFileDef {
        return try Tensorflow.AssetFileDef.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.MetaGraphRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.AssetFileDef {
        return try Tensorflow.AssetFileDef.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.AssetFileDef {
        return try Tensorflow.AssetFileDef.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.AssetFileDef {
        return try Tensorflow.AssetFileDef.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.AssetFileDef {
        return try Tensorflow.AssetFileDef.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.AssetFileDef {
        return try Tensorflow.AssetFileDef.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "tensorInfo": return self.tensorInfo
        case "filename": return self.filename
        default: return nil
        }
    }
}
extension Tensorflow.AssetFileDef.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "tensorInfo": return self.tensorInfo
            case "filename": return self.filename
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "tensorInfo":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.TensorInfo else {
                    return
                }
                self.tensorInfo = newSubscriptValue
            case "filename":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.filename = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

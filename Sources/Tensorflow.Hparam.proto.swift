/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "hparam.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { }

public extension Tensorflow {
    public struct HparamRoot {
        public static let `default` = HparamRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    /// Protocol buffer holding hyper parameters.
    /// Examples of hyper parameters:
    ///   learning_rate = 0.1,
    ///   num_hidden_units = 100,
    ///   activations = ['relu', 'tanh']
    final public class HparamDef : GeneratedMessage {

        public static func == (lhs: Tensorflow.HparamDef, rhs: Tensorflow.HparamDef) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasHparam == rhs.hasHparam) && (!lhs.hasHparam || lhs.hparam == rhs.hparam)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        final public class BytesList : GeneratedMessage {

            public static func == (lhs: Tensorflow.HparamDef.BytesList, rhs: Tensorflow.HparamDef.BytesList) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var value:Array<Data> = Array<Data>()
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if !value.isEmpty {
                    for oneValuevalue in value {
                        try codedOutputStream.writeData(fieldNumber: 1, value:oneValuevalue)
                    }
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                var dataSizeValue:Int32 = 0
                for oneValuevalue in value {
                    dataSizeValue += oneValuevalue.computeDataSizeNoTag()
                }
                serialize_size += dataSizeValue
                serialize_size += 1 * Int32(value.count)
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.HparamDef.BytesList.Builder {
                return Tensorflow.HparamDef.BytesList.classBuilder() as! Tensorflow.HparamDef.BytesList.Builder
            }
            public func getBuilder() -> Tensorflow.HparamDef.BytesList.Builder {
                return classBuilder() as! Tensorflow.HparamDef.BytesList.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.HparamDef.BytesList.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.HparamDef.BytesList.Builder()
            }
            public func toBuilder() throws -> Tensorflow.HparamDef.BytesList.Builder {
                return try Tensorflow.HparamDef.BytesList.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.HparamDef.BytesList) throws -> Tensorflow.HparamDef.BytesList.Builder {
                return try Tensorflow.HparamDef.BytesList.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if !value.isEmpty {
                    var jsonArrayValue:Array<String> = []
                    for oneValueValue in value {
                        jsonArrayValue.append(oneValueValue.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0)))
                    }
                    jsonMap["value"] = jsonArrayValue
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.HparamDef.BytesList {
                return try Tensorflow.HparamDef.BytesList.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.HparamDef.BytesList {
                return try Tensorflow.HparamDef.BytesList.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                var valueElementIndex:Int = 0
                for oneValueValue in value  {
                    output += "\(indent) value[\(valueElementIndex)]: \(oneValueValue)\n"
                    valueElementIndex += 1
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    for oneValueValue in value {
                        hashCode = (hashCode &* 31) &+ oneValueValue.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.HparamDef.BytesList"
            }
            override public func className() -> String {
                return "Tensorflow.HparamDef.BytesList"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.HparamDef.BytesList = Tensorflow.HparamDef.BytesList()
                public func getMessage() -> Tensorflow.HparamDef.BytesList {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var value:Array<Data> {
                    get {
                        return builderResult.value
                    }
                    set (array) {
                        builderResult.value = array
                    }
                }
                @discardableResult
                public func setValue(_ value:Array<Data>) -> Tensorflow.HparamDef.BytesList.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.HparamDef.BytesList.Builder {
                    builderResult.value.removeAll(keepingCapacity: false)
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.HparamDef.BytesList.Builder {
                    builderResult = Tensorflow.HparamDef.BytesList()
                    return self
                }
                override public func clone() throws -> Tensorflow.HparamDef.BytesList.Builder {
                    return try Tensorflow.HparamDef.BytesList.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.HparamDef.BytesList {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.HparamDef.BytesList {
                    let returnMe:Tensorflow.HparamDef.BytesList = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.HparamDef.BytesList) throws -> Tensorflow.HparamDef.BytesList.Builder {
                    if other == Tensorflow.HparamDef.BytesList() {
                        return self
                    }
                    if !other.value.isEmpty {
                        builderResult.value += other.value
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.HparamDef.BytesList.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.HparamDef.BytesList.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            value += [try codedInputStream.readData()]

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.HparamDef.BytesList.Builder {
                    let resultDecodedBuilder = Tensorflow.HparamDef.BytesList.Builder()
                    if let jsonValueValue = jsonMap["value"] as? Array<String> {
                        var jsonArrayValue:Array<Data> = []
                        for oneValueValue in jsonValueValue {
                            jsonArrayValue.append(Data(base64Encoded:oneValueValue, options: Data.Base64DecodingOptions(rawValue:0))!)
                        }
                        resultDecodedBuilder.value = jsonArrayValue
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.HparamDef.BytesList.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.HparamDef.BytesList.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        final public class FloatList : GeneratedMessage {

            public static func == (lhs: Tensorflow.HparamDef.FloatList, rhs: Tensorflow.HparamDef.FloatList) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var value:Array<Float> = Array<Float>()
            private var valueMemoizedSerializedSize:Int32 = -1
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if !value.isEmpty {
                    try codedOutputStream.writeRawVarint32(value: 10)
                    try codedOutputStream.writeRawVarint32(value: valueMemoizedSerializedSize)
                    for oneValuevalue in value {
                        try codedOutputStream.writeFloatNoTag(value: oneValuevalue)
                    }
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                var dataSizeValue:Int32 = 0
                dataSizeValue = 4 * Int32(value.count)
                serialize_size += dataSizeValue
                if !value.isEmpty {
                    serialize_size += 1
                    serialize_size += dataSizeValue.computeInt32SizeNoTag()
                }
                valueMemoizedSerializedSize = dataSizeValue
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.HparamDef.FloatList.Builder {
                return Tensorflow.HparamDef.FloatList.classBuilder() as! Tensorflow.HparamDef.FloatList.Builder
            }
            public func getBuilder() -> Tensorflow.HparamDef.FloatList.Builder {
                return classBuilder() as! Tensorflow.HparamDef.FloatList.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.HparamDef.FloatList.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.HparamDef.FloatList.Builder()
            }
            public func toBuilder() throws -> Tensorflow.HparamDef.FloatList.Builder {
                return try Tensorflow.HparamDef.FloatList.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.HparamDef.FloatList) throws -> Tensorflow.HparamDef.FloatList.Builder {
                return try Tensorflow.HparamDef.FloatList.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if !value.isEmpty {
                    var jsonArrayValue:Array<Float> = []
                    for oneValueValue in value {
                        jsonArrayValue.append(Float(oneValueValue))
                    }
                    jsonMap["value"] = jsonArrayValue
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.HparamDef.FloatList {
                return try Tensorflow.HparamDef.FloatList.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.HparamDef.FloatList {
                return try Tensorflow.HparamDef.FloatList.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                var valueElementIndex:Int = 0
                for oneValueValue in value  {
                    output += "\(indent) value[\(valueElementIndex)]: \(oneValueValue)\n"
                    valueElementIndex += 1
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    for oneValueValue in value {
                        hashCode = (hashCode &* 31) &+ oneValueValue.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.HparamDef.FloatList"
            }
            override public func className() -> String {
                return "Tensorflow.HparamDef.FloatList"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.HparamDef.FloatList = Tensorflow.HparamDef.FloatList()
                public func getMessage() -> Tensorflow.HparamDef.FloatList {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var value:Array<Float> {
                    get {
                        return builderResult.value
                    }
                    set (array) {
                        builderResult.value = array
                    }
                }
                @discardableResult
                public func setValue(_ value:Array<Float>) -> Tensorflow.HparamDef.FloatList.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.HparamDef.FloatList.Builder {
                    builderResult.value.removeAll(keepingCapacity: false)
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.HparamDef.FloatList.Builder {
                    builderResult = Tensorflow.HparamDef.FloatList()
                    return self
                }
                override public func clone() throws -> Tensorflow.HparamDef.FloatList.Builder {
                    return try Tensorflow.HparamDef.FloatList.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.HparamDef.FloatList {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.HparamDef.FloatList {
                    let returnMe:Tensorflow.HparamDef.FloatList = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.HparamDef.FloatList) throws -> Tensorflow.HparamDef.FloatList.Builder {
                    if other == Tensorflow.HparamDef.FloatList() {
                        return self
                    }
                    if !other.value.isEmpty {
                        builderResult.value += other.value
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.HparamDef.FloatList.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.HparamDef.FloatList.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            let length = Int(try codedInputStream.readRawVarint32())
                            let limit = try codedInputStream.pushLimit(byteLimit: length)
                            while (codedInputStream.bytesUntilLimit() > 0) {
                                builderResult.value.append(try codedInputStream.readFloat())
                            }
                            codedInputStream.popLimit(oldLimit: limit)

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.HparamDef.FloatList.Builder {
                    let resultDecodedBuilder = Tensorflow.HparamDef.FloatList.Builder()
                    if let jsonValueValue = jsonMap["value"] as? Array<Float> {
                        var jsonArrayValue:Array<Float> = []
                        for oneValueValue in jsonValueValue {
                            jsonArrayValue.append(Float(oneValueValue))
                        }
                        resultDecodedBuilder.value = jsonArrayValue
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.HparamDef.FloatList.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.HparamDef.FloatList.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        final public class Int64List : GeneratedMessage {

            public static func == (lhs: Tensorflow.HparamDef.Int64List, rhs: Tensorflow.HparamDef.Int64List) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var value:Array<Int64> = Array<Int64>()
            private var valueMemoizedSerializedSize:Int32 = -1
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if !value.isEmpty {
                    try codedOutputStream.writeRawVarint32(value: 10)
                    try codedOutputStream.writeRawVarint32(value: valueMemoizedSerializedSize)
                    for oneValuevalue in value {
                        try codedOutputStream.writeInt64NoTag(value: oneValuevalue)
                    }
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                var dataSizeValue:Int32 = 0
                for oneValuevalue in value {
                    dataSizeValue += oneValuevalue.computeInt64SizeNoTag()
                }
                serialize_size += dataSizeValue
                if !value.isEmpty {
                    serialize_size += 1
                    serialize_size += dataSizeValue.computeInt32SizeNoTag()
                }
                valueMemoizedSerializedSize = dataSizeValue
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.HparamDef.Int64List.Builder {
                return Tensorflow.HparamDef.Int64List.classBuilder() as! Tensorflow.HparamDef.Int64List.Builder
            }
            public func getBuilder() -> Tensorflow.HparamDef.Int64List.Builder {
                return classBuilder() as! Tensorflow.HparamDef.Int64List.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.HparamDef.Int64List.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.HparamDef.Int64List.Builder()
            }
            public func toBuilder() throws -> Tensorflow.HparamDef.Int64List.Builder {
                return try Tensorflow.HparamDef.Int64List.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.HparamDef.Int64List) throws -> Tensorflow.HparamDef.Int64List.Builder {
                return try Tensorflow.HparamDef.Int64List.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if !value.isEmpty {
                    var jsonArrayValue:Array<String> = []
                    for oneValueValue in value {
                        jsonArrayValue.append("\(oneValueValue)")
                    }
                    jsonMap["value"] = jsonArrayValue
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.HparamDef.Int64List {
                return try Tensorflow.HparamDef.Int64List.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.HparamDef.Int64List {
                return try Tensorflow.HparamDef.Int64List.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                var valueElementIndex:Int = 0
                for oneValueValue in value  {
                    output += "\(indent) value[\(valueElementIndex)]: \(oneValueValue)\n"
                    valueElementIndex += 1
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    for oneValueValue in value {
                        hashCode = (hashCode &* 31) &+ oneValueValue.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.HparamDef.Int64List"
            }
            override public func className() -> String {
                return "Tensorflow.HparamDef.Int64List"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.HparamDef.Int64List = Tensorflow.HparamDef.Int64List()
                public func getMessage() -> Tensorflow.HparamDef.Int64List {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var value:Array<Int64> {
                    get {
                        return builderResult.value
                    }
                    set (array) {
                        builderResult.value = array
                    }
                }
                @discardableResult
                public func setValue(_ value:Array<Int64>) -> Tensorflow.HparamDef.Int64List.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.HparamDef.Int64List.Builder {
                    builderResult.value.removeAll(keepingCapacity: false)
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.HparamDef.Int64List.Builder {
                    builderResult = Tensorflow.HparamDef.Int64List()
                    return self
                }
                override public func clone() throws -> Tensorflow.HparamDef.Int64List.Builder {
                    return try Tensorflow.HparamDef.Int64List.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.HparamDef.Int64List {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.HparamDef.Int64List {
                    let returnMe:Tensorflow.HparamDef.Int64List = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.HparamDef.Int64List) throws -> Tensorflow.HparamDef.Int64List.Builder {
                    if other == Tensorflow.HparamDef.Int64List() {
                        return self
                    }
                    if !other.value.isEmpty {
                        builderResult.value += other.value
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.HparamDef.Int64List.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.HparamDef.Int64List.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            let length = Int(try codedInputStream.readRawVarint32())
                            let limit = try codedInputStream.pushLimit(byteLimit: length)
                            while (codedInputStream.bytesUntilLimit() > 0) {
                                builderResult.value.append(try codedInputStream.readInt64())
                            }
                            codedInputStream.popLimit(oldLimit: limit)

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.HparamDef.Int64List.Builder {
                    let resultDecodedBuilder = Tensorflow.HparamDef.Int64List.Builder()
                    if let jsonValueValue = jsonMap["value"] as? Array<String> {
                        var jsonArrayValue:Array<Int64> = []
                        for oneValueValue in jsonValueValue {
                            jsonArrayValue.append(Int64(oneValueValue)!)
                        }
                        resultDecodedBuilder.value = jsonArrayValue
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.HparamDef.Int64List.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.HparamDef.Int64List.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        final public class BoolList : GeneratedMessage {

            public static func == (lhs: Tensorflow.HparamDef.BoolList, rhs: Tensorflow.HparamDef.BoolList) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var value:Array<Bool> = Array<Bool>()
            private var valueMemoizedSerializedSize:Int32 = -1
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if !value.isEmpty {
                    try codedOutputStream.writeRawVarint32(value: 10)
                    try codedOutputStream.writeRawVarint32(value: valueMemoizedSerializedSize)
                    for oneValuevalue in value {
                        try codedOutputStream.writeBoolNoTag(value: oneValuevalue)
                    }
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                var dataSizeValue:Int32 = 0
                dataSizeValue = 1 * Int32(value.count)
                serialize_size += dataSizeValue
                if !value.isEmpty {
                    serialize_size += 1
                    serialize_size += dataSizeValue.computeInt32SizeNoTag()
                }
                valueMemoizedSerializedSize = dataSizeValue
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.HparamDef.BoolList.Builder {
                return Tensorflow.HparamDef.BoolList.classBuilder() as! Tensorflow.HparamDef.BoolList.Builder
            }
            public func getBuilder() -> Tensorflow.HparamDef.BoolList.Builder {
                return classBuilder() as! Tensorflow.HparamDef.BoolList.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.HparamDef.BoolList.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.HparamDef.BoolList.Builder()
            }
            public func toBuilder() throws -> Tensorflow.HparamDef.BoolList.Builder {
                return try Tensorflow.HparamDef.BoolList.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.HparamDef.BoolList) throws -> Tensorflow.HparamDef.BoolList.Builder {
                return try Tensorflow.HparamDef.BoolList.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if !value.isEmpty {
                    var jsonArrayValue:Array<Bool> = []
                    for oneValueValue in value {
                        jsonArrayValue.append(oneValueValue)
                    }
                    jsonMap["value"] = jsonArrayValue
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.HparamDef.BoolList {
                return try Tensorflow.HparamDef.BoolList.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.HparamDef.BoolList {
                return try Tensorflow.HparamDef.BoolList.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                var valueElementIndex:Int = 0
                for oneValueValue in value  {
                    output += "\(indent) value[\(valueElementIndex)]: \(oneValueValue)\n"
                    valueElementIndex += 1
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    for oneValueValue in value {
                        hashCode = (hashCode &* 31) &+ oneValueValue.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.HparamDef.BoolList"
            }
            override public func className() -> String {
                return "Tensorflow.HparamDef.BoolList"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.HparamDef.BoolList = Tensorflow.HparamDef.BoolList()
                public func getMessage() -> Tensorflow.HparamDef.BoolList {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var value:Array<Bool> {
                    get {
                        return builderResult.value
                    }
                    set (array) {
                        builderResult.value = array
                    }
                }
                @discardableResult
                public func setValue(_ value:Array<Bool>) -> Tensorflow.HparamDef.BoolList.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.HparamDef.BoolList.Builder {
                    builderResult.value.removeAll(keepingCapacity: false)
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.HparamDef.BoolList.Builder {
                    builderResult = Tensorflow.HparamDef.BoolList()
                    return self
                }
                override public func clone() throws -> Tensorflow.HparamDef.BoolList.Builder {
                    return try Tensorflow.HparamDef.BoolList.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.HparamDef.BoolList {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.HparamDef.BoolList {
                    let returnMe:Tensorflow.HparamDef.BoolList = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.HparamDef.BoolList) throws -> Tensorflow.HparamDef.BoolList.Builder {
                    if other == Tensorflow.HparamDef.BoolList() {
                        return self
                    }
                    if !other.value.isEmpty {
                        builderResult.value += other.value
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.HparamDef.BoolList.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.HparamDef.BoolList.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            let length = Int(try codedInputStream.readRawVarint32())
                            let limit = try codedInputStream.pushLimit(byteLimit: length)
                            while (codedInputStream.bytesUntilLimit() > 0) {
                                builderResult.value.append(try codedInputStream.readBool())
                            }
                            codedInputStream.popLimit(oldLimit: limit)

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.HparamDef.BoolList.Builder {
                    let resultDecodedBuilder = Tensorflow.HparamDef.BoolList.Builder()
                    if let jsonValueValue = jsonMap["value"] as? Array<Bool> {
                        var jsonArrayValue:Array<Bool> = []
                        for oneValueValue in jsonValueValue {
                            jsonArrayValue.append(oneValueValue)
                        }
                        resultDecodedBuilder.value = jsonArrayValue
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.HparamDef.BoolList.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.HparamDef.BoolList.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        final public class HparamType : GeneratedMessage {

            public static func == (lhs: Tensorflow.HparamDef.HparamType, rhs: Tensorflow.HparamDef.HparamType) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasInt64Value == rhs.hasInt64Value) && (!lhs.hasInt64Value || lhs.int64Value == rhs.int64Value)
                fieldCheck = fieldCheck && (lhs.hasFloatValue == rhs.hasFloatValue) && (!lhs.hasFloatValue || lhs.floatValue == rhs.floatValue)
                fieldCheck = fieldCheck && (lhs.hasBytesValue == rhs.hasBytesValue) && (!lhs.hasBytesValue || lhs.bytesValue == rhs.bytesValue)
                fieldCheck = fieldCheck && (lhs.hasInt64List == rhs.hasInt64List) && (!lhs.hasInt64List || lhs.int64List == rhs.int64List)
                fieldCheck = fieldCheck && (lhs.hasFloatList == rhs.hasFloatList) && (!lhs.hasFloatList || lhs.floatList == rhs.floatList)
                fieldCheck = fieldCheck && (lhs.hasBytesList == rhs.hasBytesList) && (!lhs.hasBytesList || lhs.bytesList == rhs.bytesList)
                fieldCheck = fieldCheck && (lhs.hasBoolValue == rhs.hasBoolValue) && (!lhs.hasBoolValue || lhs.boolValue == rhs.boolValue)
                fieldCheck = fieldCheck && (lhs.hasBoolList == rhs.hasBoolList) && (!lhs.hasBoolList || lhs.boolList == rhs.boolList)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }



            //OneOf declaration start

            public enum Kind {
                case OneOfKindNotSet

                public func checkOneOfIsSet() -> Bool {
                    switch self {
                    case .OneOfKindNotSet: return false
                    default: return true
                    }
                }
                case Int64Value(Int64)

                public static func getInt64Value(_ value:Kind) -> Int64? {
                    switch value {
                    case .Int64Value(let enumValue): return enumValue
                    default: return nil
                    }
                }
                case FloatValue(Float)

                public static func getFloatValue(_ value:Kind) -> Float? {
                    switch value {
                    case .FloatValue(let enumValue): return enumValue
                    default: return nil
                    }
                }
                case BytesValue(Data)

                public static func getBytesValue(_ value:Kind) -> Data? {
                    switch value {
                    case .BytesValue(let enumValue): return enumValue
                    default: return nil
                    }
                }
                case BoolValue(Bool)

                public static func getBoolValue(_ value:Kind) -> Bool? {
                    switch value {
                    case .BoolValue(let enumValue): return enumValue
                    default: return nil
                    }
                }
                case Int64List(Tensorflow.HparamDef.Int64List)

                public static func getInt64List(_ value:Kind) -> Tensorflow.HparamDef.Int64List? {
                    switch value {
                    case .Int64List(let enumValue):
                        return enumValue
                        default: return nil
                    }
                }
                case FloatList(Tensorflow.HparamDef.FloatList)

                public static func getFloatList(_ value:Kind) -> Tensorflow.HparamDef.FloatList? {
                    switch value {
                    case .FloatList(let enumValue):
                        return enumValue
                        default: return nil
                    }
                }
                case BytesList(Tensorflow.HparamDef.BytesList)

                public static func getBytesList(_ value:Kind) -> Tensorflow.HparamDef.BytesList? {
                    switch value {
                    case .BytesList(let enumValue):
                        return enumValue
                        default: return nil
                    }
                }
                case BoolList(Tensorflow.HparamDef.BoolList)

                public static func getBoolList(_ value:Kind) -> Tensorflow.HparamDef.BoolList? {
                    switch value {
                    case .BoolList(let enumValue):
                        return enumValue
                        default: return nil
                    }
                }
            }
            //OneOf declaration end

            fileprivate var storageKind:HparamDef.HparamType.Kind =  HparamDef.HparamType.Kind.OneOfKindNotSet
            public func getOneOfKind() ->  HparamDef.HparamType.Kind {
                let copyObjectKind = storageKind
                return copyObjectKind
            }
            public fileprivate(set) var int64Value:Int64!{
                get {
                    return HparamDef.HparamType.Kind.getInt64Value(storageKind)
                }
                set (newvalue) {
                    storageKind = HparamDef.HparamType.Kind.Int64Value(newvalue)
                }
            }
            public fileprivate(set) var hasInt64Value:Bool {
                get {
                    guard let _ = HparamDef.HparamType.Kind.getInt64Value(storageKind) else {
                        return false
                    }
                    return true
                }
                set(newValue) {
                }
            }
            public fileprivate(set) var floatValue:Float!{
                get {
                    return HparamDef.HparamType.Kind.getFloatValue(storageKind)
                }
                set (newvalue) {
                    storageKind = HparamDef.HparamType.Kind.FloatValue(newvalue)
                }
            }
            public fileprivate(set) var hasFloatValue:Bool {
                get {
                    guard let _ = HparamDef.HparamType.Kind.getFloatValue(storageKind) else {
                        return false
                    }
                    return true
                }
                set(newValue) {
                }
            }
            public fileprivate(set) var bytesValue:Data!{
                get {
                    return HparamDef.HparamType.Kind.getBytesValue(storageKind)
                }
                set (newvalue) {
                    storageKind = HparamDef.HparamType.Kind.BytesValue(newvalue)
                }
            }
            public fileprivate(set) var hasBytesValue:Bool {
                get {
                    guard let _ = HparamDef.HparamType.Kind.getBytesValue(storageKind) else {
                        return false
                    }
                    return true
                }
                set(newValue) {
                }
            }
            public fileprivate(set) var boolValue:Bool!{
                get {
                    return HparamDef.HparamType.Kind.getBoolValue(storageKind)
                }
                set (newvalue) {
                    storageKind = HparamDef.HparamType.Kind.BoolValue(newvalue)
                }
            }
            public fileprivate(set) var hasBoolValue:Bool {
                get {
                    guard let _ = HparamDef.HparamType.Kind.getBoolValue(storageKind) else {
                        return false
                    }
                    return true
                }
                set(newValue) {
                }
            }
            public fileprivate(set) var int64List:Tensorflow.HparamDef.Int64List!{
                get {
                    return HparamDef.HparamType.Kind.getInt64List(storageKind)
                }
                set (newvalue) {
                    storageKind = HparamDef.HparamType.Kind.Int64List(newvalue)
                }
            }
            public fileprivate(set) var hasInt64List:Bool {
                get {
                    guard let _ = HparamDef.HparamType.Kind.getInt64List(storageKind) else {
                        return false
                    }
                    return true
                }
                set(newValue) {
                }
            }
            public fileprivate(set) var floatList:Tensorflow.HparamDef.FloatList!{
                get {
                    return HparamDef.HparamType.Kind.getFloatList(storageKind)
                }
                set (newvalue) {
                    storageKind = HparamDef.HparamType.Kind.FloatList(newvalue)
                }
            }
            public fileprivate(set) var hasFloatList:Bool {
                get {
                    guard let _ = HparamDef.HparamType.Kind.getFloatList(storageKind) else {
                        return false
                    }
                    return true
                }
                set(newValue) {
                }
            }
            public fileprivate(set) var bytesList:Tensorflow.HparamDef.BytesList!{
                get {
                    return HparamDef.HparamType.Kind.getBytesList(storageKind)
                }
                set (newvalue) {
                    storageKind = HparamDef.HparamType.Kind.BytesList(newvalue)
                }
            }
            public fileprivate(set) var hasBytesList:Bool {
                get {
                    guard let _ = HparamDef.HparamType.Kind.getBytesList(storageKind) else {
                        return false
                    }
                    return true
                }
                set(newValue) {
                }
            }
            public fileprivate(set) var boolList:Tensorflow.HparamDef.BoolList!{
                get {
                    return HparamDef.HparamType.Kind.getBoolList(storageKind)
                }
                set (newvalue) {
                    storageKind = HparamDef.HparamType.Kind.BoolList(newvalue)
                }
            }
            public fileprivate(set) var hasBoolList:Bool {
                get {
                    guard let _ = HparamDef.HparamType.Kind.getBoolList(storageKind) else {
                        return false
                    }
                    return true
                }
                set(newValue) {
                }
            }
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasInt64Value {
                    try codedOutputStream.writeInt64(fieldNumber: 1, value:int64Value)
                }
                if hasFloatValue {
                    try codedOutputStream.writeFloat(fieldNumber: 2, value:floatValue)
                }
                if hasBytesValue {
                    try codedOutputStream.writeData(fieldNumber: 3, value:bytesValue)
                }
                if hasInt64List {
                    try codedOutputStream.writeMessage(fieldNumber: 4, value:int64List)
                }
                if hasFloatList {
                    try codedOutputStream.writeMessage(fieldNumber: 5, value:floatList)
                }
                if hasBytesList {
                    try codedOutputStream.writeMessage(fieldNumber: 6, value:bytesList)
                }
                if hasBoolValue {
                    try codedOutputStream.writeBool(fieldNumber: 7, value:boolValue)
                }
                if hasBoolList {
                    try codedOutputStream.writeMessage(fieldNumber: 8, value:boolList)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasInt64Value {
                    serialize_size += int64Value.computeInt64Size(fieldNumber: 1)
                }
                if hasFloatValue {
                    serialize_size += floatValue.computeFloatSize(fieldNumber: 2)
                }
                if hasBytesValue {
                    serialize_size += bytesValue.computeDataSize(fieldNumber: 3)
                }
                if hasInt64List {
                    if let varSizeint64List = int64List?.computeMessageSize(fieldNumber: 4) {
                        serialize_size += varSizeint64List
                    }
                }
                if hasFloatList {
                    if let varSizefloatList = floatList?.computeMessageSize(fieldNumber: 5) {
                        serialize_size += varSizefloatList
                    }
                }
                if hasBytesList {
                    if let varSizebytesList = bytesList?.computeMessageSize(fieldNumber: 6) {
                        serialize_size += varSizebytesList
                    }
                }
                if hasBoolValue {
                    serialize_size += boolValue.computeBoolSize(fieldNumber: 7)
                }
                if hasBoolList {
                    if let varSizeboolList = boolList?.computeMessageSize(fieldNumber: 8) {
                        serialize_size += varSizeboolList
                    }
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.HparamDef.HparamType.Builder {
                return Tensorflow.HparamDef.HparamType.classBuilder() as! Tensorflow.HparamDef.HparamType.Builder
            }
            public func getBuilder() -> Tensorflow.HparamDef.HparamType.Builder {
                return classBuilder() as! Tensorflow.HparamDef.HparamType.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.HparamDef.HparamType.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.HparamDef.HparamType.Builder()
            }
            public func toBuilder() throws -> Tensorflow.HparamDef.HparamType.Builder {
                return try Tensorflow.HparamDef.HparamType.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.HparamDef.HparamType) throws -> Tensorflow.HparamDef.HparamType.Builder {
                return try Tensorflow.HparamDef.HparamType.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasInt64Value {
                    jsonMap["int64Value"] = "\(int64Value)"
                }
                if hasFloatValue {
                    jsonMap["floatValue"] = Float(floatValue)
                }
                if hasBytesValue {
                    jsonMap["bytesValue"] = bytesValue.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
                }
                if hasBoolValue {
                    jsonMap["boolValue"] = boolValue
                }
                if hasInt64List {
                    jsonMap["int64List"] = try int64List.encode()
                }
                if hasFloatList {
                    jsonMap["floatList"] = try floatList.encode()
                }
                if hasBytesList {
                    jsonMap["bytesList"] = try bytesList.encode()
                }
                if hasBoolList {
                    jsonMap["boolList"] = try boolList.encode()
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.HparamDef.HparamType {
                return try Tensorflow.HparamDef.HparamType.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.HparamDef.HparamType {
                return try Tensorflow.HparamDef.HparamType.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasInt64Value {
                    output += "\(indent) int64Value: \(int64Value) \n"
                }
                if hasFloatValue {
                    output += "\(indent) floatValue: \(floatValue) \n"
                }
                if hasBytesValue {
                    output += "\(indent) bytesValue: \(bytesValue) \n"
                }
                if hasInt64List {
                    output += "\(indent) int64List {\n"
                    if let outDescInt64List = int64List {
                        output += try outDescInt64List.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                if hasFloatList {
                    output += "\(indent) floatList {\n"
                    if let outDescFloatList = floatList {
                        output += try outDescFloatList.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                if hasBytesList {
                    output += "\(indent) bytesList {\n"
                    if let outDescBytesList = bytesList {
                        output += try outDescBytesList.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                if hasBoolValue {
                    output += "\(indent) boolValue: \(boolValue) \n"
                }
                if hasBoolList {
                    output += "\(indent) boolList {\n"
                    if let outDescBoolList = boolList {
                        output += try outDescBoolList.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasInt64Value {
                        hashCode = (hashCode &* 31) &+ int64Value.hashValue
                    }
                    if hasFloatValue {
                        hashCode = (hashCode &* 31) &+ floatValue.hashValue
                    }
                    if hasBytesValue {
                        hashCode = (hashCode &* 31) &+ bytesValue.hashValue
                    }
                    if hasInt64List {
                        if let hashValueint64List = int64List?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValueint64List
                        }
                    }
                    if hasFloatList {
                        if let hashValuefloatList = floatList?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuefloatList
                        }
                    }
                    if hasBytesList {
                        if let hashValuebytesList = bytesList?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuebytesList
                        }
                    }
                    if hasBoolValue {
                        hashCode = (hashCode &* 31) &+ boolValue.hashValue
                    }
                    if hasBoolList {
                        if let hashValueboolList = boolList?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValueboolList
                        }
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.HparamDef.HparamType"
            }
            override public func className() -> String {
                return "Tensorflow.HparamDef.HparamType"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.HparamDef.HparamType = Tensorflow.HparamDef.HparamType()
                public func getMessage() -> Tensorflow.HparamDef.HparamType {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var int64Value:Int64 {
                    get {
                        return builderResult.int64Value
                    }
                    set (value) {
                        builderResult.hasInt64Value = true
                        builderResult.int64Value = value
                    }
                }
                public var hasInt64Value:Bool {
                    get {
                        return builderResult.hasInt64Value
                    }
                }
                @discardableResult
                public func setInt64Value(_ value:Int64) -> Tensorflow.HparamDef.HparamType.Builder {
                    self.int64Value = value
                    return self
                }
                @discardableResult
                public func clearInt64Value() -> Tensorflow.HparamDef.HparamType.Builder{
                    builderResult.hasInt64Value = false
                    builderResult.int64Value = Int64(0)
                    return self
                }
                public var floatValue:Float {
                    get {
                        return builderResult.floatValue
                    }
                    set (value) {
                        builderResult.hasFloatValue = true
                        builderResult.floatValue = value
                    }
                }
                public var hasFloatValue:Bool {
                    get {
                        return builderResult.hasFloatValue
                    }
                }
                @discardableResult
                public func setFloatValue(_ value:Float) -> Tensorflow.HparamDef.HparamType.Builder {
                    self.floatValue = value
                    return self
                }
                @discardableResult
                public func clearFloatValue() -> Tensorflow.HparamDef.HparamType.Builder{
                    builderResult.hasFloatValue = false
                    builderResult.floatValue = Float(0)
                    return self
                }
                public var bytesValue:Data {
                    get {
                        return builderResult.bytesValue
                    }
                    set (value) {
                        builderResult.hasBytesValue = true
                        builderResult.bytesValue = value
                    }
                }
                public var hasBytesValue:Bool {
                    get {
                        return builderResult.hasBytesValue
                    }
                }
                @discardableResult
                public func setBytesValue(_ value:Data) -> Tensorflow.HparamDef.HparamType.Builder {
                    self.bytesValue = value
                    return self
                }
                @discardableResult
                public func clearBytesValue() -> Tensorflow.HparamDef.HparamType.Builder{
                    builderResult.hasBytesValue = false
                    builderResult.bytesValue = Data()
                    return self
                }
                public var boolValue:Bool {
                    get {
                        return builderResult.boolValue
                    }
                    set (value) {
                        builderResult.hasBoolValue = true
                        builderResult.boolValue = value
                    }
                }
                public var hasBoolValue:Bool {
                    get {
                        return builderResult.hasBoolValue
                    }
                }
                @discardableResult
                public func setBoolValue(_ value:Bool) -> Tensorflow.HparamDef.HparamType.Builder {
                    self.boolValue = value
                    return self
                }
                @discardableResult
                public func clearBoolValue() -> Tensorflow.HparamDef.HparamType.Builder{
                    builderResult.hasBoolValue = false
                    builderResult.boolValue = false
                    return self
                }
                public var int64List:Tensorflow.HparamDef.Int64List! {
                    get {
                        if int64ListBuilder_ != nil {
                            builderResult.int64List = int64ListBuilder_.getMessage()
                        }
                        return builderResult.int64List
                    }
                    set (value) {
                        builderResult.hasInt64List = true
                        builderResult.int64List = value
                    }
                }
                public var hasInt64List:Bool {
                    get {
                        return builderResult.hasInt64List
                    }
                }
                fileprivate var int64ListBuilder_:Tensorflow.HparamDef.Int64List.Builder! {
                    didSet {
                        builderResult.hasInt64List = true
                    }
                }
                public func getInt64ListBuilder() -> Tensorflow.HparamDef.Int64List.Builder {
                    if int64ListBuilder_ == nil {
                        int64ListBuilder_ = Tensorflow.HparamDef.Int64List.Builder()
                        builderResult.int64List = int64ListBuilder_.getMessage()
                        if int64List != nil {
                            try! int64ListBuilder_.mergeFrom(other: int64List)
                        }
                    }
                    return int64ListBuilder_
                }
                @discardableResult
                public func setInt64List(_ value:Tensorflow.HparamDef.Int64List!) -> Tensorflow.HparamDef.HparamType.Builder {
                    self.int64List = value
                    return self
                }
                @discardableResult
                public func mergeInt64List(value:Tensorflow.HparamDef.Int64List) throws -> Tensorflow.HparamDef.HparamType.Builder {
                    if builderResult.hasInt64List {
                        builderResult.int64List = try Tensorflow.HparamDef.Int64List.builderWithPrototype(prototype:builderResult.int64List).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.int64List = value
                    }
                    builderResult.hasInt64List = true
                    return self
                }
                @discardableResult
                public func clearInt64List() -> Tensorflow.HparamDef.HparamType.Builder {
                    int64ListBuilder_ = nil
                    builderResult.hasInt64List = false
                    builderResult.int64List = nil
                    return self
                }
                public var floatList:Tensorflow.HparamDef.FloatList! {
                    get {
                        if floatListBuilder_ != nil {
                            builderResult.floatList = floatListBuilder_.getMessage()
                        }
                        return builderResult.floatList
                    }
                    set (value) {
                        builderResult.hasFloatList = true
                        builderResult.floatList = value
                    }
                }
                public var hasFloatList:Bool {
                    get {
                        return builderResult.hasFloatList
                    }
                }
                fileprivate var floatListBuilder_:Tensorflow.HparamDef.FloatList.Builder! {
                    didSet {
                        builderResult.hasFloatList = true
                    }
                }
                public func getFloatListBuilder() -> Tensorflow.HparamDef.FloatList.Builder {
                    if floatListBuilder_ == nil {
                        floatListBuilder_ = Tensorflow.HparamDef.FloatList.Builder()
                        builderResult.floatList = floatListBuilder_.getMessage()
                        if floatList != nil {
                            try! floatListBuilder_.mergeFrom(other: floatList)
                        }
                    }
                    return floatListBuilder_
                }
                @discardableResult
                public func setFloatList(_ value:Tensorflow.HparamDef.FloatList!) -> Tensorflow.HparamDef.HparamType.Builder {
                    self.floatList = value
                    return self
                }
                @discardableResult
                public func mergeFloatList(value:Tensorflow.HparamDef.FloatList) throws -> Tensorflow.HparamDef.HparamType.Builder {
                    if builderResult.hasFloatList {
                        builderResult.floatList = try Tensorflow.HparamDef.FloatList.builderWithPrototype(prototype:builderResult.floatList).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.floatList = value
                    }
                    builderResult.hasFloatList = true
                    return self
                }
                @discardableResult
                public func clearFloatList() -> Tensorflow.HparamDef.HparamType.Builder {
                    floatListBuilder_ = nil
                    builderResult.hasFloatList = false
                    builderResult.floatList = nil
                    return self
                }
                public var bytesList:Tensorflow.HparamDef.BytesList! {
                    get {
                        if bytesListBuilder_ != nil {
                            builderResult.bytesList = bytesListBuilder_.getMessage()
                        }
                        return builderResult.bytesList
                    }
                    set (value) {
                        builderResult.hasBytesList = true
                        builderResult.bytesList = value
                    }
                }
                public var hasBytesList:Bool {
                    get {
                        return builderResult.hasBytesList
                    }
                }
                fileprivate var bytesListBuilder_:Tensorflow.HparamDef.BytesList.Builder! {
                    didSet {
                        builderResult.hasBytesList = true
                    }
                }
                public func getBytesListBuilder() -> Tensorflow.HparamDef.BytesList.Builder {
                    if bytesListBuilder_ == nil {
                        bytesListBuilder_ = Tensorflow.HparamDef.BytesList.Builder()
                        builderResult.bytesList = bytesListBuilder_.getMessage()
                        if bytesList != nil {
                            try! bytesListBuilder_.mergeFrom(other: bytesList)
                        }
                    }
                    return bytesListBuilder_
                }
                @discardableResult
                public func setBytesList(_ value:Tensorflow.HparamDef.BytesList!) -> Tensorflow.HparamDef.HparamType.Builder {
                    self.bytesList = value
                    return self
                }
                @discardableResult
                public func mergeBytesList(value:Tensorflow.HparamDef.BytesList) throws -> Tensorflow.HparamDef.HparamType.Builder {
                    if builderResult.hasBytesList {
                        builderResult.bytesList = try Tensorflow.HparamDef.BytesList.builderWithPrototype(prototype:builderResult.bytesList).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.bytesList = value
                    }
                    builderResult.hasBytesList = true
                    return self
                }
                @discardableResult
                public func clearBytesList() -> Tensorflow.HparamDef.HparamType.Builder {
                    bytesListBuilder_ = nil
                    builderResult.hasBytesList = false
                    builderResult.bytesList = nil
                    return self
                }
                public var boolList:Tensorflow.HparamDef.BoolList! {
                    get {
                        if boolListBuilder_ != nil {
                            builderResult.boolList = boolListBuilder_.getMessage()
                        }
                        return builderResult.boolList
                    }
                    set (value) {
                        builderResult.hasBoolList = true
                        builderResult.boolList = value
                    }
                }
                public var hasBoolList:Bool {
                    get {
                        return builderResult.hasBoolList
                    }
                }
                fileprivate var boolListBuilder_:Tensorflow.HparamDef.BoolList.Builder! {
                    didSet {
                        builderResult.hasBoolList = true
                    }
                }
                public func getBoolListBuilder() -> Tensorflow.HparamDef.BoolList.Builder {
                    if boolListBuilder_ == nil {
                        boolListBuilder_ = Tensorflow.HparamDef.BoolList.Builder()
                        builderResult.boolList = boolListBuilder_.getMessage()
                        if boolList != nil {
                            try! boolListBuilder_.mergeFrom(other: boolList)
                        }
                    }
                    return boolListBuilder_
                }
                @discardableResult
                public func setBoolList(_ value:Tensorflow.HparamDef.BoolList!) -> Tensorflow.HparamDef.HparamType.Builder {
                    self.boolList = value
                    return self
                }
                @discardableResult
                public func mergeBoolList(value:Tensorflow.HparamDef.BoolList) throws -> Tensorflow.HparamDef.HparamType.Builder {
                    if builderResult.hasBoolList {
                        builderResult.boolList = try Tensorflow.HparamDef.BoolList.builderWithPrototype(prototype:builderResult.boolList).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.boolList = value
                    }
                    builderResult.hasBoolList = true
                    return self
                }
                @discardableResult
                public func clearBoolList() -> Tensorflow.HparamDef.HparamType.Builder {
                    boolListBuilder_ = nil
                    builderResult.hasBoolList = false
                    builderResult.boolList = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.HparamDef.HparamType.Builder {
                    builderResult = Tensorflow.HparamDef.HparamType()
                    return self
                }
                override public func clone() throws -> Tensorflow.HparamDef.HparamType.Builder {
                    return try Tensorflow.HparamDef.HparamType.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.HparamDef.HparamType {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.HparamDef.HparamType {
                    let returnMe:Tensorflow.HparamDef.HparamType = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.HparamDef.HparamType) throws -> Tensorflow.HparamDef.HparamType.Builder {
                    if other == Tensorflow.HparamDef.HparamType() {
                        return self
                    }
                    if other.hasInt64Value {
                        int64Value = other.int64Value
                    }
                    if other.hasFloatValue {
                        floatValue = other.floatValue
                    }
                    if other.hasBytesValue {
                        bytesValue = other.bytesValue
                    }
                    if other.hasBoolValue {
                        boolValue = other.boolValue
                    }
                    if (other.hasInt64List) {
                        try mergeInt64List(value: other.int64List)
                    }
                    if (other.hasFloatList) {
                        try mergeFloatList(value: other.floatList)
                    }
                    if (other.hasBytesList) {
                        try mergeBytesList(value: other.bytesList)
                    }
                    if (other.hasBoolList) {
                        try mergeBoolList(value: other.boolList)
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.HparamDef.HparamType.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.HparamDef.HparamType.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 8:
                            int64Value = try codedInputStream.readInt64()

                        case 21:
                            floatValue = try codedInputStream.readFloat()

                        case 26:
                            bytesValue = try codedInputStream.readData()

                        case 34:
                            let subBuilder:Tensorflow.HparamDef.Int64List.Builder = Tensorflow.HparamDef.Int64List.Builder()
                            if hasInt64List {
                                try subBuilder.mergeFrom(other: int64List)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            int64List = subBuilder.buildPartial()

                        case 42:
                            let subBuilder:Tensorflow.HparamDef.FloatList.Builder = Tensorflow.HparamDef.FloatList.Builder()
                            if hasFloatList {
                                try subBuilder.mergeFrom(other: floatList)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            floatList = subBuilder.buildPartial()

                        case 50:
                            let subBuilder:Tensorflow.HparamDef.BytesList.Builder = Tensorflow.HparamDef.BytesList.Builder()
                            if hasBytesList {
                                try subBuilder.mergeFrom(other: bytesList)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            bytesList = subBuilder.buildPartial()

                        case 56:
                            boolValue = try codedInputStream.readBool()

                        case 66:
                            let subBuilder:Tensorflow.HparamDef.BoolList.Builder = Tensorflow.HparamDef.BoolList.Builder()
                            if hasBoolList {
                                try subBuilder.mergeFrom(other: boolList)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            boolList = subBuilder.buildPartial()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.HparamDef.HparamType.Builder {
                    let resultDecodedBuilder = Tensorflow.HparamDef.HparamType.Builder()
                    if let jsonValueInt64Value = jsonMap["int64Value"] as? String {
                        resultDecodedBuilder.int64Value = Int64(jsonValueInt64Value)!
                    } else if let jsonValueInt64Value = jsonMap["int64Value"] as? Int {
                        resultDecodedBuilder.int64Value = Int64(jsonValueInt64Value)
                    }
                    if let jsonValueFloatValue = jsonMap["floatValue"] as? Float {
                        resultDecodedBuilder.floatValue = Float(jsonValueFloatValue)
                    } else if let jsonValueFloatValue = jsonMap["floatValue"] as? String {
                        resultDecodedBuilder.floatValue = Float(jsonValueFloatValue)!
                    }
                    if let jsonValueBytesValue = jsonMap["bytesValue"] as? String {
                        resultDecodedBuilder.bytesValue = Data(base64Encoded:jsonValueBytesValue, options: Data.Base64DecodingOptions(rawValue:0))!
                    }
                    if let jsonValueBoolValue = jsonMap["boolValue"] as? Bool {
                        resultDecodedBuilder.boolValue = jsonValueBoolValue
                    }
                    if let jsonValueInt64List = jsonMap["int64List"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.int64List = try Tensorflow.HparamDef.Int64List.Builder.decodeToBuilder(jsonMap:jsonValueInt64List).build()

                    }
                    if let jsonValueFloatList = jsonMap["floatList"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.floatList = try Tensorflow.HparamDef.FloatList.Builder.decodeToBuilder(jsonMap:jsonValueFloatList).build()

                    }
                    if let jsonValueBytesList = jsonMap["bytesList"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.bytesList = try Tensorflow.HparamDef.BytesList.Builder.decodeToBuilder(jsonMap:jsonValueBytesList).build()

                    }
                    if let jsonValueBoolList = jsonMap["boolList"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.boolList = try Tensorflow.HparamDef.BoolList.Builder.decodeToBuilder(jsonMap:jsonValueBoolList).build()

                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.HparamDef.HparamType.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.HparamDef.HparamType.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        final public class HparamEntry : GeneratedMessage {

            public static func == (lhs: Tensorflow.HparamDef.HparamEntry, rhs: Tensorflow.HparamDef.HparamEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:String = ""
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:Tensorflow.HparamDef.HparamType!
            public fileprivate(set) var hasValue:Bool = false
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeString(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeMessage(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeStringSize(fieldNumber: 1)
                }
                if hasValue {
                    if let varSizevalue = value?.computeMessageSize(fieldNumber: 2) {
                        serialize_size += varSizevalue
                    }
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.HparamDef.HparamEntry.Builder {
                return Tensorflow.HparamDef.HparamEntry.classBuilder() as! Tensorflow.HparamDef.HparamEntry.Builder
            }
            public func getBuilder() -> Tensorflow.HparamDef.HparamEntry.Builder {
                return classBuilder() as! Tensorflow.HparamDef.HparamEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.HparamDef.HparamEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.HparamDef.HparamEntry.Builder()
            }
            public func toBuilder() throws -> Tensorflow.HparamDef.HparamEntry.Builder {
                return try Tensorflow.HparamDef.HparamEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.HparamDef.HparamEntry) throws -> Tensorflow.HparamDef.HparamEntry.Builder {
                return try Tensorflow.HparamDef.HparamEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = key
                }
                if hasValue {
                    jsonMap["value"] = try value.encode()
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.HparamDef.HparamEntry {
                return try Tensorflow.HparamDef.HparamEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.HparamDef.HparamEntry {
                return try Tensorflow.HparamDef.HparamEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value {\n"
                    if let outDescValue = value {
                        output += try outDescValue.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        if let hashValuevalue = value?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuevalue
                        }
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.HparamDef.HparamEntry"
            }
            override public func className() -> String {
                return "Tensorflow.HparamDef.HparamEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.HparamDef.HparamEntry = Tensorflow.HparamDef.HparamEntry()
                public func getMessage() -> Tensorflow.HparamDef.HparamEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:String {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:String) -> Tensorflow.HparamDef.HparamEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> Tensorflow.HparamDef.HparamEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = ""
                    return self
                }
                public var value:Tensorflow.HparamDef.HparamType! {
                    get {
                        if valueBuilder_ != nil {
                            builderResult.value = valueBuilder_.getMessage()
                        }
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                fileprivate var valueBuilder_:Tensorflow.HparamDef.HparamType.Builder! {
                    didSet {
                        builderResult.hasValue = true
                    }
                }
                public func getValueBuilder() -> Tensorflow.HparamDef.HparamType.Builder {
                    if valueBuilder_ == nil {
                        valueBuilder_ = Tensorflow.HparamDef.HparamType.Builder()
                        builderResult.value = valueBuilder_.getMessage()
                        if value != nil {
                            try! valueBuilder_.mergeFrom(other: value)
                        }
                    }
                    return valueBuilder_
                }
                @discardableResult
                public func setValue(_ value:Tensorflow.HparamDef.HparamType!) -> Tensorflow.HparamDef.HparamEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func mergeValue(value:Tensorflow.HparamDef.HparamType) throws -> Tensorflow.HparamDef.HparamEntry.Builder {
                    if builderResult.hasValue {
                        builderResult.value = try Tensorflow.HparamDef.HparamType.builderWithPrototype(prototype:builderResult.value).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.value = value
                    }
                    builderResult.hasValue = true
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.HparamDef.HparamEntry.Builder {
                    valueBuilder_ = nil
                    builderResult.hasValue = false
                    builderResult.value = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.HparamDef.HparamEntry.Builder {
                    builderResult = Tensorflow.HparamDef.HparamEntry()
                    return self
                }
                override public func clone() throws -> Tensorflow.HparamDef.HparamEntry.Builder {
                    return try Tensorflow.HparamDef.HparamEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.HparamDef.HparamEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.HparamDef.HparamEntry {
                    let returnMe:Tensorflow.HparamDef.HparamEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.HparamDef.HparamEntry) throws -> Tensorflow.HparamDef.HparamEntry.Builder {
                    if other == Tensorflow.HparamDef.HparamEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if (other.hasValue) {
                        try mergeValue(value: other.value)
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.HparamDef.HparamEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.HparamDef.HparamEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            key = try codedInputStream.readString()

                        case 18:
                            let subBuilder:Tensorflow.HparamDef.HparamType.Builder = Tensorflow.HparamDef.HparamType.Builder()
                            if hasValue {
                                try subBuilder.mergeFrom(other: value)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            value = subBuilder.buildPartial()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.HparamDef.HparamEntry.Builder {
                    let resultDecodedBuilder = Tensorflow.HparamDef.HparamEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = jsonValueKey
                    }
                    if let jsonValueValue = jsonMap["value"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.value = try Tensorflow.HparamDef.HparamType.Builder.decodeToBuilder(jsonMap:jsonValueValue).build()

                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.HparamDef.HparamEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.HparamDef.HparamEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        public fileprivate(set) var hparam:Dictionary<String,Tensorflow.HparamDef.HparamType> = Dictionary<String,Tensorflow.HparamDef.HparamType>()

        public fileprivate(set) var hasHparam:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasHparam {
                for (keyHparam, valueHparam) in hparam {
                    let valueOfHparam = try! Tensorflow.HparamDef.HparamEntry.Builder().setKey(keyHparam).setValue(valueHparam).build()
                      try codedOutputStream.writeMessage(fieldNumber: 1, value:valueOfHparam)
                  }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasHparam {
                  for (keyHparam, valueHparam) in hparam {
                      let valueOfHparam = try! Tensorflow.HparamDef.HparamEntry.Builder().setKey(keyHparam).setValue(valueHparam).build()
                serialize_size += valueOfHparam.computeMessageSize(fieldNumber: 1)
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.HparamDef.Builder {
            return Tensorflow.HparamDef.classBuilder() as! Tensorflow.HparamDef.Builder
        }
        public func getBuilder() -> Tensorflow.HparamDef.Builder {
            return classBuilder() as! Tensorflow.HparamDef.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.HparamDef.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.HparamDef.Builder()
        }
        public func toBuilder() throws -> Tensorflow.HparamDef.Builder {
            return try Tensorflow.HparamDef.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.HparamDef) throws -> Tensorflow.HparamDef.Builder {
            return try Tensorflow.HparamDef.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasHparam {
                var mapHparam = Dictionary<String, Dictionary<String,Any>>()
                for (keyHparam, valueHparam) in hparam {
                    mapHparam["\(keyHparam)"] = try valueHparam.encode()
                }
                jsonMap["hparam"] = mapHparam
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.HparamDef {
            return try Tensorflow.HparamDef.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.HparamDef {
            return try Tensorflow.HparamDef.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasHparam {
                output += "\(indent) hparam: \(hparam) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasHparam {
                    for (keyHparam, valueHparam) in hparam {
                        hashCode = (hashCode &* 31) &+ keyHparam.hashValue
                        hashCode = (hashCode &* 31) &+ valueHparam.hashValue
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.HparamDef"
        }
        override public func className() -> String {
            return "Tensorflow.HparamDef"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.HparamDef = Tensorflow.HparamDef()
            public func getMessage() -> Tensorflow.HparamDef {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var hasHparam:Bool {
                get {
                    return builderResult.hasHparam
                }
            }
            public var hparam:Dictionary<String,Tensorflow.HparamDef.HparamType> {
                get {
                    return builderResult.hparam
                }
                set (value) {
                    builderResult.hasHparam = true
                    builderResult.hparam = value
                }
            }
            @discardableResult
            public func setHparam(_ value:Dictionary<String,Tensorflow.HparamDef.HparamType>) -> Tensorflow.HparamDef.Builder {
                self.hparam = value
                return self
            }
            @discardableResult
            public func clearHparam() -> Tensorflow.HparamDef.Builder{
                builderResult.hasHparam = false
                builderResult.hparam = Dictionary<String,Tensorflow.HparamDef.HparamType>()
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.HparamDef.Builder {
                builderResult = Tensorflow.HparamDef()
                return self
            }
            override public func clone() throws -> Tensorflow.HparamDef.Builder {
                return try Tensorflow.HparamDef.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.HparamDef {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.HparamDef {
                let returnMe:Tensorflow.HparamDef = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.HparamDef) throws -> Tensorflow.HparamDef.Builder {
                if other == Tensorflow.HparamDef() {
                    return self
                }
                if other.hasHparam {
                    hparam = other.hparam
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.HparamDef.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.HparamDef.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Tensorflow.HparamDef.HparamEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfHparam = subBuilder.buildPartial()
                        hparam[buildOfHparam.key] = buildOfHparam.value

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.HparamDef.Builder {
                let resultDecodedBuilder = Tensorflow.HparamDef.Builder()
                if let jsonValueHparam = jsonMap["hparam"] as? Dictionary<String, Dictionary<String,Any>> {
                    var mapHparam = Dictionary<String, Tensorflow.HparamDef.HparamType>()
                    for (keyHparam, valueHparam) in jsonValueHparam {
                        guard let keyFromHparam = String(keyHparam) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapHparam[keyFromHparam] = try Tensorflow.HparamDef.HparamType.Builder.decodeToBuilder(jsonMap:valueHparam).build()

                    }
                    resultDecodedBuilder.hparam = mapHparam
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.HparamDef.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.HparamDef.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.HparamDef: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.HparamDef> {
        var mergedArray = Array<Tensorflow.HparamDef>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.HparamDef? {
        return try Tensorflow.HparamDef.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.HparamDef {
        return try Tensorflow.HparamDef.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.HparamRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.HparamDef {
        return try Tensorflow.HparamDef.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.HparamDef {
        return try Tensorflow.HparamDef.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.HparamDef {
        return try Tensorflow.HparamDef.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.HparamDef {
        return try Tensorflow.HparamDef.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.HparamDef {
        return try Tensorflow.HparamDef.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "hparam": return self.hparam
        default: return nil
        }
    }
}
extension Tensorflow.HparamDef.BytesList: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.HparamDef.BytesList> {
        var mergedArray = Array<Tensorflow.HparamDef.BytesList>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.HparamDef.BytesList? {
        return try Tensorflow.HparamDef.BytesList.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.HparamDef.BytesList {
        return try Tensorflow.HparamDef.BytesList.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.HparamRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.HparamDef.BytesList {
        return try Tensorflow.HparamDef.BytesList.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.HparamDef.BytesList {
        return try Tensorflow.HparamDef.BytesList.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.HparamDef.BytesList {
        return try Tensorflow.HparamDef.BytesList.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.HparamDef.BytesList {
        return try Tensorflow.HparamDef.BytesList.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.HparamDef.BytesList {
        return try Tensorflow.HparamDef.BytesList.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.HparamDef.FloatList: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.HparamDef.FloatList> {
        var mergedArray = Array<Tensorflow.HparamDef.FloatList>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.HparamDef.FloatList? {
        return try Tensorflow.HparamDef.FloatList.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.HparamDef.FloatList {
        return try Tensorflow.HparamDef.FloatList.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.HparamRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.HparamDef.FloatList {
        return try Tensorflow.HparamDef.FloatList.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.HparamDef.FloatList {
        return try Tensorflow.HparamDef.FloatList.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.HparamDef.FloatList {
        return try Tensorflow.HparamDef.FloatList.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.HparamDef.FloatList {
        return try Tensorflow.HparamDef.FloatList.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.HparamDef.FloatList {
        return try Tensorflow.HparamDef.FloatList.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.HparamDef.Int64List: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.HparamDef.Int64List> {
        var mergedArray = Array<Tensorflow.HparamDef.Int64List>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.HparamDef.Int64List? {
        return try Tensorflow.HparamDef.Int64List.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.HparamDef.Int64List {
        return try Tensorflow.HparamDef.Int64List.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.HparamRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.HparamDef.Int64List {
        return try Tensorflow.HparamDef.Int64List.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.HparamDef.Int64List {
        return try Tensorflow.HparamDef.Int64List.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.HparamDef.Int64List {
        return try Tensorflow.HparamDef.Int64List.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.HparamDef.Int64List {
        return try Tensorflow.HparamDef.Int64List.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.HparamDef.Int64List {
        return try Tensorflow.HparamDef.Int64List.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.HparamDef.BoolList: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.HparamDef.BoolList> {
        var mergedArray = Array<Tensorflow.HparamDef.BoolList>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.HparamDef.BoolList? {
        return try Tensorflow.HparamDef.BoolList.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.HparamDef.BoolList {
        return try Tensorflow.HparamDef.BoolList.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.HparamRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.HparamDef.BoolList {
        return try Tensorflow.HparamDef.BoolList.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.HparamDef.BoolList {
        return try Tensorflow.HparamDef.BoolList.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.HparamDef.BoolList {
        return try Tensorflow.HparamDef.BoolList.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.HparamDef.BoolList {
        return try Tensorflow.HparamDef.BoolList.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.HparamDef.BoolList {
        return try Tensorflow.HparamDef.BoolList.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.HparamDef.HparamType: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.HparamDef.HparamType> {
        var mergedArray = Array<Tensorflow.HparamDef.HparamType>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.HparamDef.HparamType? {
        return try Tensorflow.HparamDef.HparamType.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.HparamDef.HparamType {
        return try Tensorflow.HparamDef.HparamType.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.HparamRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.HparamDef.HparamType {
        return try Tensorflow.HparamDef.HparamType.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.HparamDef.HparamType {
        return try Tensorflow.HparamDef.HparamType.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.HparamDef.HparamType {
        return try Tensorflow.HparamDef.HparamType.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.HparamDef.HparamType {
        return try Tensorflow.HparamDef.HparamType.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.HparamDef.HparamType {
        return try Tensorflow.HparamDef.HparamType.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "int64Value": return self.int64Value
        case "floatValue": return self.floatValue
        case "bytesValue": return self.bytesValue
        case "boolValue": return self.boolValue
        case "int64List": return self.int64List
        case "floatList": return self.floatList
        case "bytesList": return self.bytesList
        case "boolList": return self.boolList
        default: return nil
        }
    }
}
extension Tensorflow.HparamDef.HparamEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.HparamDef.HparamEntry> {
        var mergedArray = Array<Tensorflow.HparamDef.HparamEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.HparamDef.HparamEntry? {
        return try Tensorflow.HparamDef.HparamEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.HparamDef.HparamEntry {
        return try Tensorflow.HparamDef.HparamEntry.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.HparamRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.HparamDef.HparamEntry {
        return try Tensorflow.HparamDef.HparamEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.HparamDef.HparamEntry {
        return try Tensorflow.HparamDef.HparamEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.HparamDef.HparamEntry {
        return try Tensorflow.HparamDef.HparamEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.HparamDef.HparamEntry {
        return try Tensorflow.HparamDef.HparamEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.HparamDef.HparamEntry {
        return try Tensorflow.HparamDef.HparamEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.HparamDef.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "hparam": return self.hparam
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "hparam":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,Tensorflow.HparamDef.HparamType> else {
                    return
                }
                self.hparam = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.HparamDef.BytesList.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Array<Data> else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.HparamDef.FloatList.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Array<Float> else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.HparamDef.Int64List.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.HparamDef.BoolList.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Array<Bool> else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.HparamDef.HparamType.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "int64Value": return self.int64Value
            case "floatValue": return self.floatValue
            case "bytesValue": return self.bytesValue
            case "boolValue": return self.boolValue
            case "int64List": return self.int64List
            case "floatList": return self.floatList
            case "bytesList": return self.bytesList
            case "boolList": return self.boolList
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "int64Value":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.int64Value = newSubscriptValue
            case "floatValue":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.floatValue = newSubscriptValue
            case "bytesValue":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.bytesValue = newSubscriptValue
            case "boolValue":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.boolValue = newSubscriptValue
            case "int64List":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.HparamDef.Int64List else {
                    return
                }
                self.int64List = newSubscriptValue
            case "floatList":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.HparamDef.FloatList else {
                    return
                }
                self.floatList = newSubscriptValue
            case "bytesList":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.HparamDef.BytesList else {
                    return
                }
                self.bytesList = newSubscriptValue
            case "boolList":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.HparamDef.BoolList else {
                    return
                }
                self.boolList = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.HparamDef.HparamEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.HparamDef.HparamType else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

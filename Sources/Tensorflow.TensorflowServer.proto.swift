/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "tensorflow_server.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { }

public extension Tensorflow {
    public struct TensorflowServerRoot {
        public static let `default` = TensorflowServerRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Tensorflow.ConfigRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    /// Defines a single job in a TensorFlow cluster.
    final public class JobDef : GeneratedMessage {

        public static func == (lhs: Tensorflow.JobDef, rhs: Tensorflow.JobDef) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
            fieldCheck = fieldCheck && (lhs.hasTasks == rhs.hasTasks) && (!lhs.hasTasks || lhs.tasks == rhs.tasks)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        final public class TasksEntry : GeneratedMessage {

            public static func == (lhs: Tensorflow.JobDef.TasksEntry, rhs: Tensorflow.JobDef.TasksEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:Int32 = Int32(0)
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:String = ""
            public fileprivate(set) var hasValue:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeInt32(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeString(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeInt32Size(fieldNumber: 1)
                }
                if hasValue {
                    serialize_size += value.computeStringSize(fieldNumber: 2)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.JobDef.TasksEntry.Builder {
                return Tensorflow.JobDef.TasksEntry.classBuilder() as! Tensorflow.JobDef.TasksEntry.Builder
            }
            public func getBuilder() -> Tensorflow.JobDef.TasksEntry.Builder {
                return classBuilder() as! Tensorflow.JobDef.TasksEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.JobDef.TasksEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.JobDef.TasksEntry.Builder()
            }
            public func toBuilder() throws -> Tensorflow.JobDef.TasksEntry.Builder {
                return try Tensorflow.JobDef.TasksEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.JobDef.TasksEntry) throws -> Tensorflow.JobDef.TasksEntry.Builder {
                return try Tensorflow.JobDef.TasksEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = Int(key)
                }
                if hasValue {
                    jsonMap["value"] = value
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.JobDef.TasksEntry {
                return try Tensorflow.JobDef.TasksEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.JobDef.TasksEntry {
                return try Tensorflow.JobDef.TasksEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value: \(value) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        hashCode = (hashCode &* 31) &+ value.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.JobDef.TasksEntry"
            }
            override public func className() -> String {
                return "Tensorflow.JobDef.TasksEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.JobDef.TasksEntry = Tensorflow.JobDef.TasksEntry()
                public func getMessage() -> Tensorflow.JobDef.TasksEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:Int32 {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:Int32) -> Tensorflow.JobDef.TasksEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> Tensorflow.JobDef.TasksEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = Int32(0)
                    return self
                }
                public var value:String {
                    get {
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                @discardableResult
                public func setValue(_ value:String) -> Tensorflow.JobDef.TasksEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.JobDef.TasksEntry.Builder{
                    builderResult.hasValue = false
                    builderResult.value = ""
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.JobDef.TasksEntry.Builder {
                    builderResult = Tensorflow.JobDef.TasksEntry()
                    return self
                }
                override public func clone() throws -> Tensorflow.JobDef.TasksEntry.Builder {
                    return try Tensorflow.JobDef.TasksEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.JobDef.TasksEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.JobDef.TasksEntry {
                    let returnMe:Tensorflow.JobDef.TasksEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.JobDef.TasksEntry) throws -> Tensorflow.JobDef.TasksEntry.Builder {
                    if other == Tensorflow.JobDef.TasksEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if other.hasValue {
                        value = other.value
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.JobDef.TasksEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.JobDef.TasksEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 8:
                            key = try codedInputStream.readInt32()

                        case 18:
                            value = try codedInputStream.readString()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.JobDef.TasksEntry.Builder {
                    let resultDecodedBuilder = Tensorflow.JobDef.TasksEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? Int {
                        resultDecodedBuilder.key = Int32(jsonValueKey)
                    } else if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = Int32(jsonValueKey)!
                    }
                    if let jsonValueValue = jsonMap["value"] as? String {
                        resultDecodedBuilder.value = jsonValueValue
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.JobDef.TasksEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.JobDef.TasksEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        /// The name of this job.
        public fileprivate(set) var name:String = ""
        public fileprivate(set) var hasName:Bool = false

        /// Mapping from task ID to "hostname:port" string.
        /// If the `name` field contains "worker", and the `tasks` map contains a
        /// mapping from 7 to "example.org:2222", then the device prefix
        /// "/job:worker/task:7" will be assigned to "example.org:2222".
        /// NOTE(mrry): Currently, only a dense task ID space starting at 0 is
        /// supported.
        public fileprivate(set) var tasks:Dictionary<Int32,String> = Dictionary<Int32,String>()

        public fileprivate(set) var hasTasks:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasName {
                try codedOutputStream.writeString(fieldNumber: 1, value:name)
            }
            if hasTasks {
                for (keyTasks, valueTasks) in tasks {
                    let valueOfTasks = try! Tensorflow.JobDef.TasksEntry.Builder().setKey(keyTasks).setValue(valueTasks).build()
                      try codedOutputStream.writeMessage(fieldNumber: 2, value:valueOfTasks)
                  }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasName {
                serialize_size += name.computeStringSize(fieldNumber: 1)
            }
            if hasTasks {
                  for (keyTasks, valueTasks) in tasks {
                      let valueOfTasks = try! Tensorflow.JobDef.TasksEntry.Builder().setKey(keyTasks).setValue(valueTasks).build()
                serialize_size += valueOfTasks.computeMessageSize(fieldNumber: 2)
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.JobDef.Builder {
            return Tensorflow.JobDef.classBuilder() as! Tensorflow.JobDef.Builder
        }
        public func getBuilder() -> Tensorflow.JobDef.Builder {
            return classBuilder() as! Tensorflow.JobDef.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.JobDef.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.JobDef.Builder()
        }
        public func toBuilder() throws -> Tensorflow.JobDef.Builder {
            return try Tensorflow.JobDef.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.JobDef) throws -> Tensorflow.JobDef.Builder {
            return try Tensorflow.JobDef.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasName {
                jsonMap["name"] = name
            }
            if hasTasks {
                var mapTasks = Dictionary<String, String>()
                for (keyTasks, valueTasks) in tasks {
                    mapTasks["\(keyTasks)"] = valueTasks
                }
                jsonMap["tasks"] = mapTasks
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.JobDef {
            return try Tensorflow.JobDef.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.JobDef {
            return try Tensorflow.JobDef.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasName {
                output += "\(indent) name: \(name) \n"
            }
            if hasTasks {
                output += "\(indent) tasks: \(tasks) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasName {
                    hashCode = (hashCode &* 31) &+ name.hashValue
                }
                if hasTasks {
                    for (keyTasks, valueTasks) in tasks {
                        hashCode = (hashCode &* 31) &+ keyTasks.hashValue
                        hashCode = (hashCode &* 31) &+ valueTasks.hashValue
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.JobDef"
        }
        override public func className() -> String {
            return "Tensorflow.JobDef"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.JobDef = Tensorflow.JobDef()
            public func getMessage() -> Tensorflow.JobDef {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The name of this job.
            public var name:String {
                get {
                    return builderResult.name
                }
                set (value) {
                    builderResult.hasName = true
                    builderResult.name = value
                }
            }
            public var hasName:Bool {
                get {
                    return builderResult.hasName
                }
            }
            @discardableResult
            public func setName(_ value:String) -> Tensorflow.JobDef.Builder {
                self.name = value
                return self
            }
            @discardableResult
            public func clearName() -> Tensorflow.JobDef.Builder{
                builderResult.hasName = false
                builderResult.name = ""
                return self
            }
            /// Mapping from task ID to "hostname:port" string.
            /// If the `name` field contains "worker", and the `tasks` map contains a
            /// mapping from 7 to "example.org:2222", then the device prefix
            /// "/job:worker/task:7" will be assigned to "example.org:2222".
            /// NOTE(mrry): Currently, only a dense task ID space starting at 0 is
            /// supported.
            public var hasTasks:Bool {
                get {
                    return builderResult.hasTasks
                }
            }
            public var tasks:Dictionary<Int32,String> {
                get {
                    return builderResult.tasks
                }
                set (value) {
                    builderResult.hasTasks = true
                    builderResult.tasks = value
                }
            }
            @discardableResult
            public func setTasks(_ value:Dictionary<Int32,String>) -> Tensorflow.JobDef.Builder {
                self.tasks = value
                return self
            }
            @discardableResult
            public func clearTasks() -> Tensorflow.JobDef.Builder{
                builderResult.hasTasks = false
                builderResult.tasks = Dictionary<Int32,String>()
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.JobDef.Builder {
                builderResult = Tensorflow.JobDef()
                return self
            }
            override public func clone() throws -> Tensorflow.JobDef.Builder {
                return try Tensorflow.JobDef.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.JobDef {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.JobDef {
                let returnMe:Tensorflow.JobDef = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.JobDef) throws -> Tensorflow.JobDef.Builder {
                if other == Tensorflow.JobDef() {
                    return self
                }
                if other.hasName {
                    name = other.name
                }
                if other.hasTasks {
                    tasks = other.tasks
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.JobDef.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.JobDef.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        name = try codedInputStream.readString()

                    case 18:
                        let subBuilder = Tensorflow.JobDef.TasksEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfTasks = subBuilder.buildPartial()
                        tasks[buildOfTasks.key] = buildOfTasks.value

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.JobDef.Builder {
                let resultDecodedBuilder = Tensorflow.JobDef.Builder()
                if let jsonValueName = jsonMap["name"] as? String {
                    resultDecodedBuilder.name = jsonValueName
                }
                if let jsonValueTasks = jsonMap["tasks"] as? Dictionary<String, String> {
                    var mapTasks = Dictionary<Int32, String>()
                    for (keyTasks, valueTasks) in jsonValueTasks {
                        guard let keyFromTasks = Int32(keyTasks) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapTasks[keyFromTasks] = valueTasks
                    }
                    resultDecodedBuilder.tasks = mapTasks
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.JobDef.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.JobDef.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Defines a TensorFlow cluster as a set of jobs.
    final public class ClusterDef : GeneratedMessage {

        public static func == (lhs: Tensorflow.ClusterDef, rhs: Tensorflow.ClusterDef) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.job == rhs.job)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var job:Array<Tensorflow.JobDef>  = Array<Tensorflow.JobDef>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementJob in job {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementJob)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementJob in job {
                serialize_size += oneElementJob.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.ClusterDef.Builder {
            return Tensorflow.ClusterDef.classBuilder() as! Tensorflow.ClusterDef.Builder
        }
        public func getBuilder() -> Tensorflow.ClusterDef.Builder {
            return classBuilder() as! Tensorflow.ClusterDef.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.ClusterDef.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.ClusterDef.Builder()
        }
        public func toBuilder() throws -> Tensorflow.ClusterDef.Builder {
            return try Tensorflow.ClusterDef.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.ClusterDef) throws -> Tensorflow.ClusterDef.Builder {
            return try Tensorflow.ClusterDef.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !job.isEmpty {
                var jsonArrayJob:Array<Dictionary<String,Any>> = []
                for oneValueJob in job {
                    let ecodedMessageJob = try oneValueJob.encode()
                    jsonArrayJob.append(ecodedMessageJob)
                }
                jsonMap["job"] = jsonArrayJob
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.ClusterDef {
            return try Tensorflow.ClusterDef.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.ClusterDef {
            return try Tensorflow.ClusterDef.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var jobElementIndex:Int = 0
            for oneElementJob in job {
                output += "\(indent) job[\(jobElementIndex)] {\n"
                output += try oneElementJob.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                jobElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementJob in job {
                    hashCode = (hashCode &* 31) &+ oneElementJob.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.ClusterDef"
        }
        override public func className() -> String {
            return "Tensorflow.ClusterDef"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.ClusterDef = Tensorflow.ClusterDef()
            public func getMessage() -> Tensorflow.ClusterDef {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The jobs that comprise the cluster.
            public var job:Array<Tensorflow.JobDef> {
                get {
                    return builderResult.job
                }
                set (value) {
                    builderResult.job = value
                }
            }
            @discardableResult
            public func setJob(_ value:Array<Tensorflow.JobDef>) -> Tensorflow.ClusterDef.Builder {
                self.job = value
                return self
            }
            @discardableResult
            public func clearJob() -> Tensorflow.ClusterDef.Builder {
                builderResult.job.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.ClusterDef.Builder {
                builderResult = Tensorflow.ClusterDef()
                return self
            }
            override public func clone() throws -> Tensorflow.ClusterDef.Builder {
                return try Tensorflow.ClusterDef.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.ClusterDef {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.ClusterDef {
                let returnMe:Tensorflow.ClusterDef = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.ClusterDef) throws -> Tensorflow.ClusterDef.Builder {
                if other == Tensorflow.ClusterDef() {
                    return self
                }
                if !other.job.isEmpty  {
                     builderResult.job += other.job
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.ClusterDef.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ClusterDef.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Tensorflow.JobDef.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        job.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.ClusterDef.Builder {
                let resultDecodedBuilder = Tensorflow.ClusterDef.Builder()
                if let jsonValueJob = jsonMap["job"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayJob:Array<Tensorflow.JobDef> = []
                    for oneValueJob in jsonValueJob {
                        let messageFromStringJob = try Tensorflow.JobDef.Builder.decodeToBuilder(jsonMap:oneValueJob).build()

                        jsonArrayJob.append(messageFromStringJob)
                    }
                    resultDecodedBuilder.job = jsonArrayJob
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.ClusterDef.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.ClusterDef.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Defines the configuration of a single TensorFlow server.
    final public class ServerDef : GeneratedMessage {

        public static func == (lhs: Tensorflow.ServerDef, rhs: Tensorflow.ServerDef) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasCluster == rhs.hasCluster) && (!lhs.hasCluster || lhs.cluster == rhs.cluster)
            fieldCheck = fieldCheck && (lhs.hasJobName == rhs.hasJobName) && (!lhs.hasJobName || lhs.jobName == rhs.jobName)
            fieldCheck = fieldCheck && (lhs.hasTaskIndex == rhs.hasTaskIndex) && (!lhs.hasTaskIndex || lhs.taskIndex == rhs.taskIndex)
            fieldCheck = fieldCheck && (lhs.hasDefaultSessionConfig == rhs.hasDefaultSessionConfig) && (!lhs.hasDefaultSessionConfig || lhs.defaultSessionConfig == rhs.defaultSessionConfig)
            fieldCheck = fieldCheck && (lhs.hasProtocol == rhs.hasProtocol) && (!lhs.hasProtocol || lhs.`protocol` == rhs.`protocol`)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var cluster:Tensorflow.ClusterDef!
        public fileprivate(set) var hasCluster:Bool = false
        /// The name of the job of which this server is a member.
        /// NOTE(mrry): The `cluster` field must contain a `JobDef` with a `name` field
        /// that matches this name.
        public fileprivate(set) var jobName:String = ""
        public fileprivate(set) var hasJobName:Bool = false

        /// The task index of this server in its job.
        /// NOTE: The `cluster` field must contain a `JobDef` with a matching `name`
        /// and a mapping in its `tasks` field for this index.
        public fileprivate(set) var taskIndex:Int32 = Int32(0)
        public fileprivate(set) var hasTaskIndex:Bool = false

        public fileprivate(set) var defaultSessionConfig:Tensorflow.ConfigProto!
        public fileprivate(set) var hasDefaultSessionConfig:Bool = false
        /// The protocol to be used by this server.
        /// Acceptable values include: "grpc".
        public fileprivate(set) var `protocol`:String = ""
        public fileprivate(set) var hasProtocol:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasCluster {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:cluster)
            }
            if hasJobName {
                try codedOutputStream.writeString(fieldNumber: 2, value:jobName)
            }
            if hasTaskIndex {
                try codedOutputStream.writeInt32(fieldNumber: 3, value:taskIndex)
            }
            if hasDefaultSessionConfig {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:defaultSessionConfig)
            }
            if hasProtocol {
                try codedOutputStream.writeString(fieldNumber: 5, value:`protocol`)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasCluster {
                if let varSizecluster = cluster?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizecluster
                }
            }
            if hasJobName {
                serialize_size += jobName.computeStringSize(fieldNumber: 2)
            }
            if hasTaskIndex {
                serialize_size += taskIndex.computeInt32Size(fieldNumber: 3)
            }
            if hasDefaultSessionConfig {
                if let varSizedefaultSessionConfig = defaultSessionConfig?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizedefaultSessionConfig
                }
            }
            if hasProtocol {
                serialize_size += `protocol`.computeStringSize(fieldNumber: 5)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.ServerDef.Builder {
            return Tensorflow.ServerDef.classBuilder() as! Tensorflow.ServerDef.Builder
        }
        public func getBuilder() -> Tensorflow.ServerDef.Builder {
            return classBuilder() as! Tensorflow.ServerDef.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.ServerDef.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.ServerDef.Builder()
        }
        public func toBuilder() throws -> Tensorflow.ServerDef.Builder {
            return try Tensorflow.ServerDef.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.ServerDef) throws -> Tensorflow.ServerDef.Builder {
            return try Tensorflow.ServerDef.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasCluster {
                jsonMap["cluster"] = try cluster.encode()
            }
            if hasJobName {
                jsonMap["jobName"] = jobName
            }
            if hasTaskIndex {
                jsonMap["taskIndex"] = Int(taskIndex)
            }
            if hasDefaultSessionConfig {
                jsonMap["defaultSessionConfig"] = try defaultSessionConfig.encode()
            }
            if hasProtocol {
                jsonMap["protocol"] = `protocol`
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.ServerDef {
            return try Tensorflow.ServerDef.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.ServerDef {
            return try Tensorflow.ServerDef.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasCluster {
                output += "\(indent) cluster {\n"
                if let outDescCluster = cluster {
                    output += try outDescCluster.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasJobName {
                output += "\(indent) jobName: \(jobName) \n"
            }
            if hasTaskIndex {
                output += "\(indent) taskIndex: \(taskIndex) \n"
            }
            if hasDefaultSessionConfig {
                output += "\(indent) defaultSessionConfig {\n"
                if let outDescDefaultSessionConfig = defaultSessionConfig {
                    output += try outDescDefaultSessionConfig.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasProtocol {
                output += "\(indent) protocol: \(`protocol`) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasCluster {
                    if let hashValuecluster = cluster?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecluster
                    }
                }
                if hasJobName {
                    hashCode = (hashCode &* 31) &+ jobName.hashValue
                }
                if hasTaskIndex {
                    hashCode = (hashCode &* 31) &+ taskIndex.hashValue
                }
                if hasDefaultSessionConfig {
                    if let hashValuedefaultSessionConfig = defaultSessionConfig?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuedefaultSessionConfig
                    }
                }
                if hasProtocol {
                    hashCode = (hashCode &* 31) &+ `protocol`.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.ServerDef"
        }
        override public func className() -> String {
            return "Tensorflow.ServerDef"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.ServerDef = Tensorflow.ServerDef()
            public func getMessage() -> Tensorflow.ServerDef {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The cluster of which this server is a member.
            public var cluster:Tensorflow.ClusterDef! {
                get {
                    if clusterBuilder_ != nil {
                        builderResult.cluster = clusterBuilder_.getMessage()
                    }
                    return builderResult.cluster
                }
                set (value) {
                    builderResult.hasCluster = true
                    builderResult.cluster = value
                }
            }
            public var hasCluster:Bool {
                get {
                    return builderResult.hasCluster
                }
            }
            fileprivate var clusterBuilder_:Tensorflow.ClusterDef.Builder! {
                didSet {
                    builderResult.hasCluster = true
                }
            }
            public func getClusterBuilder() -> Tensorflow.ClusterDef.Builder {
                if clusterBuilder_ == nil {
                    clusterBuilder_ = Tensorflow.ClusterDef.Builder()
                    builderResult.cluster = clusterBuilder_.getMessage()
                    if cluster != nil {
                        try! clusterBuilder_.mergeFrom(other: cluster)
                    }
                }
                return clusterBuilder_
            }
            @discardableResult
            public func setCluster(_ value:Tensorflow.ClusterDef!) -> Tensorflow.ServerDef.Builder {
                self.cluster = value
                return self
            }
            @discardableResult
            public func mergeCluster(value:Tensorflow.ClusterDef) throws -> Tensorflow.ServerDef.Builder {
                if builderResult.hasCluster {
                    builderResult.cluster = try Tensorflow.ClusterDef.builderWithPrototype(prototype:builderResult.cluster).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.cluster = value
                }
                builderResult.hasCluster = true
                return self
            }
            @discardableResult
            public func clearCluster() -> Tensorflow.ServerDef.Builder {
                clusterBuilder_ = nil
                builderResult.hasCluster = false
                builderResult.cluster = nil
                return self
            }
            /// The name of the job of which this server is a member.
            /// NOTE(mrry): The `cluster` field must contain a `JobDef` with a `name` field
            /// that matches this name.
            public var jobName:String {
                get {
                    return builderResult.jobName
                }
                set (value) {
                    builderResult.hasJobName = true
                    builderResult.jobName = value
                }
            }
            public var hasJobName:Bool {
                get {
                    return builderResult.hasJobName
                }
            }
            @discardableResult
            public func setJobName(_ value:String) -> Tensorflow.ServerDef.Builder {
                self.jobName = value
                return self
            }
            @discardableResult
            public func clearJobName() -> Tensorflow.ServerDef.Builder{
                builderResult.hasJobName = false
                builderResult.jobName = ""
                return self
            }
            /// The task index of this server in its job.
            /// NOTE: The `cluster` field must contain a `JobDef` with a matching `name`
            /// and a mapping in its `tasks` field for this index.
            public var taskIndex:Int32 {
                get {
                    return builderResult.taskIndex
                }
                set (value) {
                    builderResult.hasTaskIndex = true
                    builderResult.taskIndex = value
                }
            }
            public var hasTaskIndex:Bool {
                get {
                    return builderResult.hasTaskIndex
                }
            }
            @discardableResult
            public func setTaskIndex(_ value:Int32) -> Tensorflow.ServerDef.Builder {
                self.taskIndex = value
                return self
            }
            @discardableResult
            public func clearTaskIndex() -> Tensorflow.ServerDef.Builder{
                builderResult.hasTaskIndex = false
                builderResult.taskIndex = Int32(0)
                return self
            }
            /// The default configuration for sessions that run on this server.
            public var defaultSessionConfig:Tensorflow.ConfigProto! {
                get {
                    if defaultSessionConfigBuilder_ != nil {
                        builderResult.defaultSessionConfig = defaultSessionConfigBuilder_.getMessage()
                    }
                    return builderResult.defaultSessionConfig
                }
                set (value) {
                    builderResult.hasDefaultSessionConfig = true
                    builderResult.defaultSessionConfig = value
                }
            }
            public var hasDefaultSessionConfig:Bool {
                get {
                    return builderResult.hasDefaultSessionConfig
                }
            }
            fileprivate var defaultSessionConfigBuilder_:Tensorflow.ConfigProto.Builder! {
                didSet {
                    builderResult.hasDefaultSessionConfig = true
                }
            }
            public func getDefaultSessionConfigBuilder() -> Tensorflow.ConfigProto.Builder {
                if defaultSessionConfigBuilder_ == nil {
                    defaultSessionConfigBuilder_ = Tensorflow.ConfigProto.Builder()
                    builderResult.defaultSessionConfig = defaultSessionConfigBuilder_.getMessage()
                    if defaultSessionConfig != nil {
                        try! defaultSessionConfigBuilder_.mergeFrom(other: defaultSessionConfig)
                    }
                }
                return defaultSessionConfigBuilder_
            }
            @discardableResult
            public func setDefaultSessionConfig(_ value:Tensorflow.ConfigProto!) -> Tensorflow.ServerDef.Builder {
                self.defaultSessionConfig = value
                return self
            }
            @discardableResult
            public func mergeDefaultSessionConfig(value:Tensorflow.ConfigProto) throws -> Tensorflow.ServerDef.Builder {
                if builderResult.hasDefaultSessionConfig {
                    builderResult.defaultSessionConfig = try Tensorflow.ConfigProto.builderWithPrototype(prototype:builderResult.defaultSessionConfig).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.defaultSessionConfig = value
                }
                builderResult.hasDefaultSessionConfig = true
                return self
            }
            @discardableResult
            public func clearDefaultSessionConfig() -> Tensorflow.ServerDef.Builder {
                defaultSessionConfigBuilder_ = nil
                builderResult.hasDefaultSessionConfig = false
                builderResult.defaultSessionConfig = nil
                return self
            }
            /// The protocol to be used by this server.
            /// Acceptable values include: "grpc".
            public var `protocol`:String {
                get {
                    return builderResult.`protocol`
                }
                set (value) {
                    builderResult.hasProtocol = true
                    builderResult.`protocol` = value
                }
            }
            public var hasProtocol:Bool {
                get {
                    return builderResult.hasProtocol
                }
            }
            @discardableResult
            public func setProtocol(_ value:String) -> Tensorflow.ServerDef.Builder {
                self.`protocol` = value
                return self
            }
            @discardableResult
            public func clearProtocol() -> Tensorflow.ServerDef.Builder{
                builderResult.hasProtocol = false
                builderResult.`protocol` = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.ServerDef.Builder {
                builderResult = Tensorflow.ServerDef()
                return self
            }
            override public func clone() throws -> Tensorflow.ServerDef.Builder {
                return try Tensorflow.ServerDef.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.ServerDef {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.ServerDef {
                let returnMe:Tensorflow.ServerDef = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.ServerDef) throws -> Tensorflow.ServerDef.Builder {
                if other == Tensorflow.ServerDef() {
                    return self
                }
                if (other.hasCluster) {
                    try mergeCluster(value: other.cluster)
                }
                if other.hasJobName {
                    jobName = other.jobName
                }
                if other.hasTaskIndex {
                    taskIndex = other.taskIndex
                }
                if (other.hasDefaultSessionConfig) {
                    try mergeDefaultSessionConfig(value: other.defaultSessionConfig)
                }
                if other.hasProtocol {
                    `protocol` = other.`protocol`
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.ServerDef.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ServerDef.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Tensorflow.ClusterDef.Builder = Tensorflow.ClusterDef.Builder()
                        if hasCluster {
                            try subBuilder.mergeFrom(other: cluster)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        cluster = subBuilder.buildPartial()

                    case 18:
                        jobName = try codedInputStream.readString()

                    case 24:
                        taskIndex = try codedInputStream.readInt32()

                    case 34:
                        let subBuilder:Tensorflow.ConfigProto.Builder = Tensorflow.ConfigProto.Builder()
                        if hasDefaultSessionConfig {
                            try subBuilder.mergeFrom(other: defaultSessionConfig)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        defaultSessionConfig = subBuilder.buildPartial()

                    case 42:
                        `protocol` = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.ServerDef.Builder {
                let resultDecodedBuilder = Tensorflow.ServerDef.Builder()
                if let jsonValueCluster = jsonMap["cluster"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.cluster = try Tensorflow.ClusterDef.Builder.decodeToBuilder(jsonMap:jsonValueCluster).build()

                }
                if let jsonValueJobName = jsonMap["jobName"] as? String {
                    resultDecodedBuilder.jobName = jsonValueJobName
                }
                if let jsonValueTaskIndex = jsonMap["taskIndex"] as? Int {
                    resultDecodedBuilder.taskIndex = Int32(jsonValueTaskIndex)
                } else if let jsonValueTaskIndex = jsonMap["taskIndex"] as? String {
                    resultDecodedBuilder.taskIndex = Int32(jsonValueTaskIndex)!
                }
                if let jsonValueDefaultSessionConfig = jsonMap["defaultSessionConfig"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.defaultSessionConfig = try Tensorflow.ConfigProto.Builder.decodeToBuilder(jsonMap:jsonValueDefaultSessionConfig).build()

                }
                if let jsonValueProtocol = jsonMap["protocol"] as? String {
                    resultDecodedBuilder.`protocol` = jsonValueProtocol
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.ServerDef.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.ServerDef.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.JobDef: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.JobDef> {
        var mergedArray = Array<Tensorflow.JobDef>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.JobDef? {
        return try Tensorflow.JobDef.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.JobDef {
        return try Tensorflow.JobDef.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.TensorflowServerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.JobDef {
        return try Tensorflow.JobDef.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.JobDef {
        return try Tensorflow.JobDef.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.JobDef {
        return try Tensorflow.JobDef.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.JobDef {
        return try Tensorflow.JobDef.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.JobDef {
        return try Tensorflow.JobDef.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "name": return self.name
        case "tasks": return self.tasks
        default: return nil
        }
    }
}
extension Tensorflow.JobDef.TasksEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.JobDef.TasksEntry> {
        var mergedArray = Array<Tensorflow.JobDef.TasksEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.JobDef.TasksEntry? {
        return try Tensorflow.JobDef.TasksEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.JobDef.TasksEntry {
        return try Tensorflow.JobDef.TasksEntry.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.TensorflowServerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.JobDef.TasksEntry {
        return try Tensorflow.JobDef.TasksEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.JobDef.TasksEntry {
        return try Tensorflow.JobDef.TasksEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.JobDef.TasksEntry {
        return try Tensorflow.JobDef.TasksEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.JobDef.TasksEntry {
        return try Tensorflow.JobDef.TasksEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.JobDef.TasksEntry {
        return try Tensorflow.JobDef.TasksEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.JobDef.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "name": return self.name
            case "tasks": return self.tasks
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "tasks":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<Int32,String> else {
                    return
                }
                self.tasks = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.JobDef.TasksEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.ClusterDef: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.ClusterDef> {
        var mergedArray = Array<Tensorflow.ClusterDef>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.ClusterDef? {
        return try Tensorflow.ClusterDef.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.ClusterDef {
        return try Tensorflow.ClusterDef.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.TensorflowServerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ClusterDef {
        return try Tensorflow.ClusterDef.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.ClusterDef {
        return try Tensorflow.ClusterDef.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ClusterDef {
        return try Tensorflow.ClusterDef.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.ClusterDef {
        return try Tensorflow.ClusterDef.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ClusterDef {
        return try Tensorflow.ClusterDef.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "job": return self.job
        default: return nil
        }
    }
}
extension Tensorflow.ClusterDef.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "job": return self.job
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "job":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.JobDef> else {
                    return
                }
                self.job = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.ServerDef: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.ServerDef> {
        var mergedArray = Array<Tensorflow.ServerDef>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.ServerDef? {
        return try Tensorflow.ServerDef.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.ServerDef {
        return try Tensorflow.ServerDef.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.TensorflowServerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ServerDef {
        return try Tensorflow.ServerDef.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.ServerDef {
        return try Tensorflow.ServerDef.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ServerDef {
        return try Tensorflow.ServerDef.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.ServerDef {
        return try Tensorflow.ServerDef.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ServerDef {
        return try Tensorflow.ServerDef.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "cluster": return self.cluster
        case "jobName": return self.jobName
        case "taskIndex": return self.taskIndex
        case "defaultSessionConfig": return self.defaultSessionConfig
        case "`protocol`": return self.`protocol`
        default: return nil
        }
    }
}
extension Tensorflow.ServerDef.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "cluster": return self.cluster
            case "jobName": return self.jobName
            case "taskIndex": return self.taskIndex
            case "defaultSessionConfig": return self.defaultSessionConfig
            case "`protocol`": return self.`protocol`
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "cluster":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.ClusterDef else {
                    return
                }
                self.cluster = newSubscriptValue
            case "jobName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.jobName = newSubscriptValue
            case "taskIndex":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.taskIndex = newSubscriptValue
            case "defaultSessionConfig":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.ConfigProto else {
                    return
                }
                self.defaultSessionConfig = newSubscriptValue
            case "`protocol`":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.`protocol` = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

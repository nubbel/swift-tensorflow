/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "example_parser_configuration.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { }

public extension Tensorflow {
    public struct ExampleParserConfigurationRoot {
        public static let `default` = ExampleParserConfigurationRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Tensorflow.TensorShapeRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.TensorRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.TypesRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    final public class VarLenFeatureProto : GeneratedMessage {

        public static func == (lhs: Tensorflow.VarLenFeatureProto, rhs: Tensorflow.VarLenFeatureProto) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasDtype == rhs.hasDtype) && (!lhs.hasDtype || lhs.dtype == rhs.dtype)
            fieldCheck = fieldCheck && (lhs.hasValuesOutputTensorName == rhs.hasValuesOutputTensorName) && (!lhs.hasValuesOutputTensorName || lhs.valuesOutputTensorName == rhs.valuesOutputTensorName)
            fieldCheck = fieldCheck && (lhs.hasIndicesOutputTensorName == rhs.hasIndicesOutputTensorName) && (!lhs.hasIndicesOutputTensorName || lhs.indicesOutputTensorName == rhs.indicesOutputTensorName)
            fieldCheck = fieldCheck && (lhs.hasShapesOutputTensorName == rhs.hasShapesOutputTensorName) && (!lhs.hasShapesOutputTensorName || lhs.shapesOutputTensorName == rhs.shapesOutputTensorName)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var dtype:Tensorflow.DataType = Tensorflow.DataType.dtInvalid
        public fileprivate(set) var hasDtype:Bool = false
        public fileprivate(set) var valuesOutputTensorName:String = ""
        public fileprivate(set) var hasValuesOutputTensorName:Bool = false

        public fileprivate(set) var indicesOutputTensorName:String = ""
        public fileprivate(set) var hasIndicesOutputTensorName:Bool = false

        public fileprivate(set) var shapesOutputTensorName:String = ""
        public fileprivate(set) var hasShapesOutputTensorName:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasDtype {
                try codedOutputStream.writeEnum(fieldNumber: 1, value:dtype.rawValue)
            }
            if hasValuesOutputTensorName {
                try codedOutputStream.writeString(fieldNumber: 2, value:valuesOutputTensorName)
            }
            if hasIndicesOutputTensorName {
                try codedOutputStream.writeString(fieldNumber: 3, value:indicesOutputTensorName)
            }
            if hasShapesOutputTensorName {
                try codedOutputStream.writeString(fieldNumber: 4, value:shapesOutputTensorName)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if (hasDtype) {
                serialize_size += dtype.rawValue.computeEnumSize(fieldNumber: 1)
            }
            if hasValuesOutputTensorName {
                serialize_size += valuesOutputTensorName.computeStringSize(fieldNumber: 2)
            }
            if hasIndicesOutputTensorName {
                serialize_size += indicesOutputTensorName.computeStringSize(fieldNumber: 3)
            }
            if hasShapesOutputTensorName {
                serialize_size += shapesOutputTensorName.computeStringSize(fieldNumber: 4)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.VarLenFeatureProto.Builder {
            return Tensorflow.VarLenFeatureProto.classBuilder() as! Tensorflow.VarLenFeatureProto.Builder
        }
        public func getBuilder() -> Tensorflow.VarLenFeatureProto.Builder {
            return classBuilder() as! Tensorflow.VarLenFeatureProto.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.VarLenFeatureProto.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.VarLenFeatureProto.Builder()
        }
        public func toBuilder() throws -> Tensorflow.VarLenFeatureProto.Builder {
            return try Tensorflow.VarLenFeatureProto.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.VarLenFeatureProto) throws -> Tensorflow.VarLenFeatureProto.Builder {
            return try Tensorflow.VarLenFeatureProto.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasDtype {
                jsonMap["dtype"] = dtype.toString()
            }
            if hasValuesOutputTensorName {
                jsonMap["valuesOutputTensorName"] = valuesOutputTensorName
            }
            if hasIndicesOutputTensorName {
                jsonMap["indicesOutputTensorName"] = indicesOutputTensorName
            }
            if hasShapesOutputTensorName {
                jsonMap["shapesOutputTensorName"] = shapesOutputTensorName
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.VarLenFeatureProto {
            return try Tensorflow.VarLenFeatureProto.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.VarLenFeatureProto {
            return try Tensorflow.VarLenFeatureProto.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if (hasDtype) {
                output += "\(indent) dtype: \(dtype.description)\n"
            }
            if hasValuesOutputTensorName {
                output += "\(indent) valuesOutputTensorName: \(valuesOutputTensorName) \n"
            }
            if hasIndicesOutputTensorName {
                output += "\(indent) indicesOutputTensorName: \(indicesOutputTensorName) \n"
            }
            if hasShapesOutputTensorName {
                output += "\(indent) shapesOutputTensorName: \(shapesOutputTensorName) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasDtype {
                     hashCode = (hashCode &* 31) &+ dtype.hashValue
                }
                if hasValuesOutputTensorName {
                    hashCode = (hashCode &* 31) &+ valuesOutputTensorName.hashValue
                }
                if hasIndicesOutputTensorName {
                    hashCode = (hashCode &* 31) &+ indicesOutputTensorName.hashValue
                }
                if hasShapesOutputTensorName {
                    hashCode = (hashCode &* 31) &+ shapesOutputTensorName.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.VarLenFeatureProto"
        }
        override public func className() -> String {
            return "Tensorflow.VarLenFeatureProto"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.VarLenFeatureProto = Tensorflow.VarLenFeatureProto()
            public func getMessage() -> Tensorflow.VarLenFeatureProto {
                return builderResult
            }

            required override public init () {
                super.init()
            }
                public var dtype:Tensorflow.DataType {
                    get {
                        return builderResult.dtype
                    }
                    set (value) {
                        builderResult.hasDtype = true
                        builderResult.dtype = value
                    }
                }
                public var hasDtype:Bool{
                    get {
                        return builderResult.hasDtype
                    }
                }
            @discardableResult
                public func setDtype(_ value:Tensorflow.DataType) -> Tensorflow.VarLenFeatureProto.Builder {
                  self.dtype = value
                  return self
                }
            @discardableResult
                public func clearDtype() -> Tensorflow.VarLenFeatureProto.Builder {
                   builderResult.hasDtype = false
                   builderResult.dtype = .dtInvalid
                   return self
                }
            public var valuesOutputTensorName:String {
                get {
                    return builderResult.valuesOutputTensorName
                }
                set (value) {
                    builderResult.hasValuesOutputTensorName = true
                    builderResult.valuesOutputTensorName = value
                }
            }
            public var hasValuesOutputTensorName:Bool {
                get {
                    return builderResult.hasValuesOutputTensorName
                }
            }
            @discardableResult
            public func setValuesOutputTensorName(_ value:String) -> Tensorflow.VarLenFeatureProto.Builder {
                self.valuesOutputTensorName = value
                return self
            }
            @discardableResult
            public func clearValuesOutputTensorName() -> Tensorflow.VarLenFeatureProto.Builder{
                builderResult.hasValuesOutputTensorName = false
                builderResult.valuesOutputTensorName = ""
                return self
            }
            public var indicesOutputTensorName:String {
                get {
                    return builderResult.indicesOutputTensorName
                }
                set (value) {
                    builderResult.hasIndicesOutputTensorName = true
                    builderResult.indicesOutputTensorName = value
                }
            }
            public var hasIndicesOutputTensorName:Bool {
                get {
                    return builderResult.hasIndicesOutputTensorName
                }
            }
            @discardableResult
            public func setIndicesOutputTensorName(_ value:String) -> Tensorflow.VarLenFeatureProto.Builder {
                self.indicesOutputTensorName = value
                return self
            }
            @discardableResult
            public func clearIndicesOutputTensorName() -> Tensorflow.VarLenFeatureProto.Builder{
                builderResult.hasIndicesOutputTensorName = false
                builderResult.indicesOutputTensorName = ""
                return self
            }
            public var shapesOutputTensorName:String {
                get {
                    return builderResult.shapesOutputTensorName
                }
                set (value) {
                    builderResult.hasShapesOutputTensorName = true
                    builderResult.shapesOutputTensorName = value
                }
            }
            public var hasShapesOutputTensorName:Bool {
                get {
                    return builderResult.hasShapesOutputTensorName
                }
            }
            @discardableResult
            public func setShapesOutputTensorName(_ value:String) -> Tensorflow.VarLenFeatureProto.Builder {
                self.shapesOutputTensorName = value
                return self
            }
            @discardableResult
            public func clearShapesOutputTensorName() -> Tensorflow.VarLenFeatureProto.Builder{
                builderResult.hasShapesOutputTensorName = false
                builderResult.shapesOutputTensorName = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.VarLenFeatureProto.Builder {
                builderResult = Tensorflow.VarLenFeatureProto()
                return self
            }
            override public func clone() throws -> Tensorflow.VarLenFeatureProto.Builder {
                return try Tensorflow.VarLenFeatureProto.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.VarLenFeatureProto {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.VarLenFeatureProto {
                let returnMe:Tensorflow.VarLenFeatureProto = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.VarLenFeatureProto) throws -> Tensorflow.VarLenFeatureProto.Builder {
                if other == Tensorflow.VarLenFeatureProto() {
                    return self
                }
                if other.hasDtype {
                    dtype = other.dtype
                }
                if other.hasValuesOutputTensorName {
                    valuesOutputTensorName = other.valuesOutputTensorName
                }
                if other.hasIndicesOutputTensorName {
                    indicesOutputTensorName = other.indicesOutputTensorName
                }
                if other.hasShapesOutputTensorName {
                    shapesOutputTensorName = other.shapesOutputTensorName
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.VarLenFeatureProto.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.VarLenFeatureProto.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        let valueIntdtype = try codedInputStream.readEnum()
                        if let enumsdtype = Tensorflow.DataType(rawValue:valueIntdtype){
                            dtype = enumsdtype
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntdtype))
                        }

                    case 18:
                        valuesOutputTensorName = try codedInputStream.readString()

                    case 26:
                        indicesOutputTensorName = try codedInputStream.readString()

                    case 34:
                        shapesOutputTensorName = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.VarLenFeatureProto.Builder {
                let resultDecodedBuilder = Tensorflow.VarLenFeatureProto.Builder()
                if let jsonValueDtype = jsonMap["dtype"] as? String {
                    resultDecodedBuilder.dtype = try Tensorflow.DataType.fromString(str: jsonValueDtype)
                }
                if let jsonValueValuesOutputTensorName = jsonMap["valuesOutputTensorName"] as? String {
                    resultDecodedBuilder.valuesOutputTensorName = jsonValueValuesOutputTensorName
                }
                if let jsonValueIndicesOutputTensorName = jsonMap["indicesOutputTensorName"] as? String {
                    resultDecodedBuilder.indicesOutputTensorName = jsonValueIndicesOutputTensorName
                }
                if let jsonValueShapesOutputTensorName = jsonMap["shapesOutputTensorName"] as? String {
                    resultDecodedBuilder.shapesOutputTensorName = jsonValueShapesOutputTensorName
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.VarLenFeatureProto.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.VarLenFeatureProto.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class FixedLenFeatureProto : GeneratedMessage {

        public static func == (lhs: Tensorflow.FixedLenFeatureProto, rhs: Tensorflow.FixedLenFeatureProto) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasDtype == rhs.hasDtype) && (!lhs.hasDtype || lhs.dtype == rhs.dtype)
            fieldCheck = fieldCheck && (lhs.hasShape == rhs.hasShape) && (!lhs.hasShape || lhs.shape == rhs.shape)
            fieldCheck = fieldCheck && (lhs.hasDefaultValue == rhs.hasDefaultValue) && (!lhs.hasDefaultValue || lhs.defaultValue == rhs.defaultValue)
            fieldCheck = fieldCheck && (lhs.hasValuesOutputTensorName == rhs.hasValuesOutputTensorName) && (!lhs.hasValuesOutputTensorName || lhs.valuesOutputTensorName == rhs.valuesOutputTensorName)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var dtype:Tensorflow.DataType = Tensorflow.DataType.dtInvalid
        public fileprivate(set) var hasDtype:Bool = false
        public fileprivate(set) var shape:Tensorflow.TensorShapeProto!
        public fileprivate(set) var hasShape:Bool = false
        public fileprivate(set) var defaultValue:Tensorflow.TensorProto!
        public fileprivate(set) var hasDefaultValue:Bool = false
        public fileprivate(set) var valuesOutputTensorName:String = ""
        public fileprivate(set) var hasValuesOutputTensorName:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasDtype {
                try codedOutputStream.writeEnum(fieldNumber: 1, value:dtype.rawValue)
            }
            if hasShape {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:shape)
            }
            if hasDefaultValue {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:defaultValue)
            }
            if hasValuesOutputTensorName {
                try codedOutputStream.writeString(fieldNumber: 4, value:valuesOutputTensorName)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if (hasDtype) {
                serialize_size += dtype.rawValue.computeEnumSize(fieldNumber: 1)
            }
            if hasShape {
                if let varSizeshape = shape?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeshape
                }
            }
            if hasDefaultValue {
                if let varSizedefaultValue = defaultValue?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizedefaultValue
                }
            }
            if hasValuesOutputTensorName {
                serialize_size += valuesOutputTensorName.computeStringSize(fieldNumber: 4)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.FixedLenFeatureProto.Builder {
            return Tensorflow.FixedLenFeatureProto.classBuilder() as! Tensorflow.FixedLenFeatureProto.Builder
        }
        public func getBuilder() -> Tensorflow.FixedLenFeatureProto.Builder {
            return classBuilder() as! Tensorflow.FixedLenFeatureProto.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.FixedLenFeatureProto.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.FixedLenFeatureProto.Builder()
        }
        public func toBuilder() throws -> Tensorflow.FixedLenFeatureProto.Builder {
            return try Tensorflow.FixedLenFeatureProto.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.FixedLenFeatureProto) throws -> Tensorflow.FixedLenFeatureProto.Builder {
            return try Tensorflow.FixedLenFeatureProto.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasDtype {
                jsonMap["dtype"] = dtype.toString()
            }
            if hasShape {
                jsonMap["shape"] = try shape.encode()
            }
            if hasDefaultValue {
                jsonMap["defaultValue"] = try defaultValue.encode()
            }
            if hasValuesOutputTensorName {
                jsonMap["valuesOutputTensorName"] = valuesOutputTensorName
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.FixedLenFeatureProto {
            return try Tensorflow.FixedLenFeatureProto.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.FixedLenFeatureProto {
            return try Tensorflow.FixedLenFeatureProto.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if (hasDtype) {
                output += "\(indent) dtype: \(dtype.description)\n"
            }
            if hasShape {
                output += "\(indent) shape {\n"
                if let outDescShape = shape {
                    output += try outDescShape.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasDefaultValue {
                output += "\(indent) defaultValue {\n"
                if let outDescDefaultValue = defaultValue {
                    output += try outDescDefaultValue.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasValuesOutputTensorName {
                output += "\(indent) valuesOutputTensorName: \(valuesOutputTensorName) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasDtype {
                     hashCode = (hashCode &* 31) &+ dtype.hashValue
                }
                if hasShape {
                    if let hashValueshape = shape?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueshape
                    }
                }
                if hasDefaultValue {
                    if let hashValuedefaultValue = defaultValue?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuedefaultValue
                    }
                }
                if hasValuesOutputTensorName {
                    hashCode = (hashCode &* 31) &+ valuesOutputTensorName.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.FixedLenFeatureProto"
        }
        override public func className() -> String {
            return "Tensorflow.FixedLenFeatureProto"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.FixedLenFeatureProto = Tensorflow.FixedLenFeatureProto()
            public func getMessage() -> Tensorflow.FixedLenFeatureProto {
                return builderResult
            }

            required override public init () {
                super.init()
            }
                public var dtype:Tensorflow.DataType {
                    get {
                        return builderResult.dtype
                    }
                    set (value) {
                        builderResult.hasDtype = true
                        builderResult.dtype = value
                    }
                }
                public var hasDtype:Bool{
                    get {
                        return builderResult.hasDtype
                    }
                }
            @discardableResult
                public func setDtype(_ value:Tensorflow.DataType) -> Tensorflow.FixedLenFeatureProto.Builder {
                  self.dtype = value
                  return self
                }
            @discardableResult
                public func clearDtype() -> Tensorflow.FixedLenFeatureProto.Builder {
                   builderResult.hasDtype = false
                   builderResult.dtype = .dtInvalid
                   return self
                }
            public var shape:Tensorflow.TensorShapeProto! {
                get {
                    if shapeBuilder_ != nil {
                        builderResult.shape = shapeBuilder_.getMessage()
                    }
                    return builderResult.shape
                }
                set (value) {
                    builderResult.hasShape = true
                    builderResult.shape = value
                }
            }
            public var hasShape:Bool {
                get {
                    return builderResult.hasShape
                }
            }
            fileprivate var shapeBuilder_:Tensorflow.TensorShapeProto.Builder! {
                didSet {
                    builderResult.hasShape = true
                }
            }
            public func getShapeBuilder() -> Tensorflow.TensorShapeProto.Builder {
                if shapeBuilder_ == nil {
                    shapeBuilder_ = Tensorflow.TensorShapeProto.Builder()
                    builderResult.shape = shapeBuilder_.getMessage()
                    if shape != nil {
                        try! shapeBuilder_.mergeFrom(other: shape)
                    }
                }
                return shapeBuilder_
            }
            @discardableResult
            public func setShape(_ value:Tensorflow.TensorShapeProto!) -> Tensorflow.FixedLenFeatureProto.Builder {
                self.shape = value
                return self
            }
            @discardableResult
            public func mergeShape(value:Tensorflow.TensorShapeProto) throws -> Tensorflow.FixedLenFeatureProto.Builder {
                if builderResult.hasShape {
                    builderResult.shape = try Tensorflow.TensorShapeProto.builderWithPrototype(prototype:builderResult.shape).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.shape = value
                }
                builderResult.hasShape = true
                return self
            }
            @discardableResult
            public func clearShape() -> Tensorflow.FixedLenFeatureProto.Builder {
                shapeBuilder_ = nil
                builderResult.hasShape = false
                builderResult.shape = nil
                return self
            }
            public var defaultValue:Tensorflow.TensorProto! {
                get {
                    if defaultValueBuilder_ != nil {
                        builderResult.defaultValue = defaultValueBuilder_.getMessage()
                    }
                    return builderResult.defaultValue
                }
                set (value) {
                    builderResult.hasDefaultValue = true
                    builderResult.defaultValue = value
                }
            }
            public var hasDefaultValue:Bool {
                get {
                    return builderResult.hasDefaultValue
                }
            }
            fileprivate var defaultValueBuilder_:Tensorflow.TensorProto.Builder! {
                didSet {
                    builderResult.hasDefaultValue = true
                }
            }
            public func getDefaultValueBuilder() -> Tensorflow.TensorProto.Builder {
                if defaultValueBuilder_ == nil {
                    defaultValueBuilder_ = Tensorflow.TensorProto.Builder()
                    builderResult.defaultValue = defaultValueBuilder_.getMessage()
                    if defaultValue != nil {
                        try! defaultValueBuilder_.mergeFrom(other: defaultValue)
                    }
                }
                return defaultValueBuilder_
            }
            @discardableResult
            public func setDefaultValue(_ value:Tensorflow.TensorProto!) -> Tensorflow.FixedLenFeatureProto.Builder {
                self.defaultValue = value
                return self
            }
            @discardableResult
            public func mergeDefaultValue(value:Tensorflow.TensorProto) throws -> Tensorflow.FixedLenFeatureProto.Builder {
                if builderResult.hasDefaultValue {
                    builderResult.defaultValue = try Tensorflow.TensorProto.builderWithPrototype(prototype:builderResult.defaultValue).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.defaultValue = value
                }
                builderResult.hasDefaultValue = true
                return self
            }
            @discardableResult
            public func clearDefaultValue() -> Tensorflow.FixedLenFeatureProto.Builder {
                defaultValueBuilder_ = nil
                builderResult.hasDefaultValue = false
                builderResult.defaultValue = nil
                return self
            }
            public var valuesOutputTensorName:String {
                get {
                    return builderResult.valuesOutputTensorName
                }
                set (value) {
                    builderResult.hasValuesOutputTensorName = true
                    builderResult.valuesOutputTensorName = value
                }
            }
            public var hasValuesOutputTensorName:Bool {
                get {
                    return builderResult.hasValuesOutputTensorName
                }
            }
            @discardableResult
            public func setValuesOutputTensorName(_ value:String) -> Tensorflow.FixedLenFeatureProto.Builder {
                self.valuesOutputTensorName = value
                return self
            }
            @discardableResult
            public func clearValuesOutputTensorName() -> Tensorflow.FixedLenFeatureProto.Builder{
                builderResult.hasValuesOutputTensorName = false
                builderResult.valuesOutputTensorName = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.FixedLenFeatureProto.Builder {
                builderResult = Tensorflow.FixedLenFeatureProto()
                return self
            }
            override public func clone() throws -> Tensorflow.FixedLenFeatureProto.Builder {
                return try Tensorflow.FixedLenFeatureProto.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.FixedLenFeatureProto {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.FixedLenFeatureProto {
                let returnMe:Tensorflow.FixedLenFeatureProto = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.FixedLenFeatureProto) throws -> Tensorflow.FixedLenFeatureProto.Builder {
                if other == Tensorflow.FixedLenFeatureProto() {
                    return self
                }
                if other.hasDtype {
                    dtype = other.dtype
                }
                if (other.hasShape) {
                    try mergeShape(value: other.shape)
                }
                if (other.hasDefaultValue) {
                    try mergeDefaultValue(value: other.defaultValue)
                }
                if other.hasValuesOutputTensorName {
                    valuesOutputTensorName = other.valuesOutputTensorName
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.FixedLenFeatureProto.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FixedLenFeatureProto.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        let valueIntdtype = try codedInputStream.readEnum()
                        if let enumsdtype = Tensorflow.DataType(rawValue:valueIntdtype){
                            dtype = enumsdtype
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntdtype))
                        }

                    case 18:
                        let subBuilder:Tensorflow.TensorShapeProto.Builder = Tensorflow.TensorShapeProto.Builder()
                        if hasShape {
                            try subBuilder.mergeFrom(other: shape)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        shape = subBuilder.buildPartial()

                    case 26:
                        let subBuilder:Tensorflow.TensorProto.Builder = Tensorflow.TensorProto.Builder()
                        if hasDefaultValue {
                            try subBuilder.mergeFrom(other: defaultValue)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        defaultValue = subBuilder.buildPartial()

                    case 34:
                        valuesOutputTensorName = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.FixedLenFeatureProto.Builder {
                let resultDecodedBuilder = Tensorflow.FixedLenFeatureProto.Builder()
                if let jsonValueDtype = jsonMap["dtype"] as? String {
                    resultDecodedBuilder.dtype = try Tensorflow.DataType.fromString(str: jsonValueDtype)
                }
                if let jsonValueShape = jsonMap["shape"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.shape = try Tensorflow.TensorShapeProto.Builder.decodeToBuilder(jsonMap:jsonValueShape).build()

                }
                if let jsonValueDefaultValue = jsonMap["defaultValue"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.defaultValue = try Tensorflow.TensorProto.Builder.decodeToBuilder(jsonMap:jsonValueDefaultValue).build()

                }
                if let jsonValueValuesOutputTensorName = jsonMap["valuesOutputTensorName"] as? String {
                    resultDecodedBuilder.valuesOutputTensorName = jsonValueValuesOutputTensorName
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.FixedLenFeatureProto.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.FixedLenFeatureProto.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class FeatureConfiguration : GeneratedMessage {

        public static func == (lhs: Tensorflow.FeatureConfiguration, rhs: Tensorflow.FeatureConfiguration) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasFixedLenFeature == rhs.hasFixedLenFeature) && (!lhs.hasFixedLenFeature || lhs.fixedLenFeature == rhs.fixedLenFeature)
            fieldCheck = fieldCheck && (lhs.hasVarLenFeature == rhs.hasVarLenFeature) && (!lhs.hasVarLenFeature || lhs.varLenFeature == rhs.varLenFeature)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //OneOf declaration start

        public enum Config {
            case OneOfConfigNotSet

            public func checkOneOfIsSet() -> Bool {
                switch self {
                case .OneOfConfigNotSet: return false
                default: return true
                }
            }
            case FixedLenFeature(Tensorflow.FixedLenFeatureProto)

            public static func getFixedLenFeature(_ value:Config) -> Tensorflow.FixedLenFeatureProto? {
                switch value {
                case .FixedLenFeature(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case VarLenFeature(Tensorflow.VarLenFeatureProto)

            public static func getVarLenFeature(_ value:Config) -> Tensorflow.VarLenFeatureProto? {
                switch value {
                case .VarLenFeature(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
        }
        //OneOf declaration end

        fileprivate var storageConfig:FeatureConfiguration.Config =  FeatureConfiguration.Config.OneOfConfigNotSet
        public func getOneOfConfig() ->  FeatureConfiguration.Config {
            let copyObjectConfig = storageConfig
            return copyObjectConfig
        }
        public fileprivate(set) var fixedLenFeature:Tensorflow.FixedLenFeatureProto!{
            get {
                return FeatureConfiguration.Config.getFixedLenFeature(storageConfig)
            }
            set (newvalue) {
                storageConfig = FeatureConfiguration.Config.FixedLenFeature(newvalue)
            }
        }
        public fileprivate(set) var hasFixedLenFeature:Bool {
            get {
                guard let _ = FeatureConfiguration.Config.getFixedLenFeature(storageConfig) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var varLenFeature:Tensorflow.VarLenFeatureProto!{
            get {
                return FeatureConfiguration.Config.getVarLenFeature(storageConfig)
            }
            set (newvalue) {
                storageConfig = FeatureConfiguration.Config.VarLenFeature(newvalue)
            }
        }
        public fileprivate(set) var hasVarLenFeature:Bool {
            get {
                guard let _ = FeatureConfiguration.Config.getVarLenFeature(storageConfig) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasFixedLenFeature {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:fixedLenFeature)
            }
            if hasVarLenFeature {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:varLenFeature)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasFixedLenFeature {
                if let varSizefixedLenFeature = fixedLenFeature?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizefixedLenFeature
                }
            }
            if hasVarLenFeature {
                if let varSizevarLenFeature = varLenFeature?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizevarLenFeature
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.FeatureConfiguration.Builder {
            return Tensorflow.FeatureConfiguration.classBuilder() as! Tensorflow.FeatureConfiguration.Builder
        }
        public func getBuilder() -> Tensorflow.FeatureConfiguration.Builder {
            return classBuilder() as! Tensorflow.FeatureConfiguration.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.FeatureConfiguration.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.FeatureConfiguration.Builder()
        }
        public func toBuilder() throws -> Tensorflow.FeatureConfiguration.Builder {
            return try Tensorflow.FeatureConfiguration.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.FeatureConfiguration) throws -> Tensorflow.FeatureConfiguration.Builder {
            return try Tensorflow.FeatureConfiguration.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasFixedLenFeature {
                jsonMap["fixedLenFeature"] = try fixedLenFeature.encode()
            }
            if hasVarLenFeature {
                jsonMap["varLenFeature"] = try varLenFeature.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.FeatureConfiguration {
            return try Tensorflow.FeatureConfiguration.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.FeatureConfiguration {
            return try Tensorflow.FeatureConfiguration.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasFixedLenFeature {
                output += "\(indent) fixedLenFeature {\n"
                if let outDescFixedLenFeature = fixedLenFeature {
                    output += try outDescFixedLenFeature.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasVarLenFeature {
                output += "\(indent) varLenFeature {\n"
                if let outDescVarLenFeature = varLenFeature {
                    output += try outDescVarLenFeature.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasFixedLenFeature {
                    if let hashValuefixedLenFeature = fixedLenFeature?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuefixedLenFeature
                    }
                }
                if hasVarLenFeature {
                    if let hashValuevarLenFeature = varLenFeature?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuevarLenFeature
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.FeatureConfiguration"
        }
        override public func className() -> String {
            return "Tensorflow.FeatureConfiguration"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.FeatureConfiguration = Tensorflow.FeatureConfiguration()
            public func getMessage() -> Tensorflow.FeatureConfiguration {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var fixedLenFeature:Tensorflow.FixedLenFeatureProto! {
                get {
                    if fixedLenFeatureBuilder_ != nil {
                        builderResult.fixedLenFeature = fixedLenFeatureBuilder_.getMessage()
                    }
                    return builderResult.fixedLenFeature
                }
                set (value) {
                    builderResult.hasFixedLenFeature = true
                    builderResult.fixedLenFeature = value
                }
            }
            public var hasFixedLenFeature:Bool {
                get {
                    return builderResult.hasFixedLenFeature
                }
            }
            fileprivate var fixedLenFeatureBuilder_:Tensorflow.FixedLenFeatureProto.Builder! {
                didSet {
                    builderResult.hasFixedLenFeature = true
                }
            }
            public func getFixedLenFeatureBuilder() -> Tensorflow.FixedLenFeatureProto.Builder {
                if fixedLenFeatureBuilder_ == nil {
                    fixedLenFeatureBuilder_ = Tensorflow.FixedLenFeatureProto.Builder()
                    builderResult.fixedLenFeature = fixedLenFeatureBuilder_.getMessage()
                    if fixedLenFeature != nil {
                        try! fixedLenFeatureBuilder_.mergeFrom(other: fixedLenFeature)
                    }
                }
                return fixedLenFeatureBuilder_
            }
            @discardableResult
            public func setFixedLenFeature(_ value:Tensorflow.FixedLenFeatureProto!) -> Tensorflow.FeatureConfiguration.Builder {
                self.fixedLenFeature = value
                return self
            }
            @discardableResult
            public func mergeFixedLenFeature(value:Tensorflow.FixedLenFeatureProto) throws -> Tensorflow.FeatureConfiguration.Builder {
                if builderResult.hasFixedLenFeature {
                    builderResult.fixedLenFeature = try Tensorflow.FixedLenFeatureProto.builderWithPrototype(prototype:builderResult.fixedLenFeature).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.fixedLenFeature = value
                }
                builderResult.hasFixedLenFeature = true
                return self
            }
            @discardableResult
            public func clearFixedLenFeature() -> Tensorflow.FeatureConfiguration.Builder {
                fixedLenFeatureBuilder_ = nil
                builderResult.hasFixedLenFeature = false
                builderResult.fixedLenFeature = nil
                return self
            }
            public var varLenFeature:Tensorflow.VarLenFeatureProto! {
                get {
                    if varLenFeatureBuilder_ != nil {
                        builderResult.varLenFeature = varLenFeatureBuilder_.getMessage()
                    }
                    return builderResult.varLenFeature
                }
                set (value) {
                    builderResult.hasVarLenFeature = true
                    builderResult.varLenFeature = value
                }
            }
            public var hasVarLenFeature:Bool {
                get {
                    return builderResult.hasVarLenFeature
                }
            }
            fileprivate var varLenFeatureBuilder_:Tensorflow.VarLenFeatureProto.Builder! {
                didSet {
                    builderResult.hasVarLenFeature = true
                }
            }
            public func getVarLenFeatureBuilder() -> Tensorflow.VarLenFeatureProto.Builder {
                if varLenFeatureBuilder_ == nil {
                    varLenFeatureBuilder_ = Tensorflow.VarLenFeatureProto.Builder()
                    builderResult.varLenFeature = varLenFeatureBuilder_.getMessage()
                    if varLenFeature != nil {
                        try! varLenFeatureBuilder_.mergeFrom(other: varLenFeature)
                    }
                }
                return varLenFeatureBuilder_
            }
            @discardableResult
            public func setVarLenFeature(_ value:Tensorflow.VarLenFeatureProto!) -> Tensorflow.FeatureConfiguration.Builder {
                self.varLenFeature = value
                return self
            }
            @discardableResult
            public func mergeVarLenFeature(value:Tensorflow.VarLenFeatureProto) throws -> Tensorflow.FeatureConfiguration.Builder {
                if builderResult.hasVarLenFeature {
                    builderResult.varLenFeature = try Tensorflow.VarLenFeatureProto.builderWithPrototype(prototype:builderResult.varLenFeature).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.varLenFeature = value
                }
                builderResult.hasVarLenFeature = true
                return self
            }
            @discardableResult
            public func clearVarLenFeature() -> Tensorflow.FeatureConfiguration.Builder {
                varLenFeatureBuilder_ = nil
                builderResult.hasVarLenFeature = false
                builderResult.varLenFeature = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.FeatureConfiguration.Builder {
                builderResult = Tensorflow.FeatureConfiguration()
                return self
            }
            override public func clone() throws -> Tensorflow.FeatureConfiguration.Builder {
                return try Tensorflow.FeatureConfiguration.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.FeatureConfiguration {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.FeatureConfiguration {
                let returnMe:Tensorflow.FeatureConfiguration = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.FeatureConfiguration) throws -> Tensorflow.FeatureConfiguration.Builder {
                if other == Tensorflow.FeatureConfiguration() {
                    return self
                }
                if (other.hasFixedLenFeature) {
                    try mergeFixedLenFeature(value: other.fixedLenFeature)
                }
                if (other.hasVarLenFeature) {
                    try mergeVarLenFeature(value: other.varLenFeature)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.FeatureConfiguration.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FeatureConfiguration.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Tensorflow.FixedLenFeatureProto.Builder = Tensorflow.FixedLenFeatureProto.Builder()
                        if hasFixedLenFeature {
                            try subBuilder.mergeFrom(other: fixedLenFeature)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        fixedLenFeature = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Tensorflow.VarLenFeatureProto.Builder = Tensorflow.VarLenFeatureProto.Builder()
                        if hasVarLenFeature {
                            try subBuilder.mergeFrom(other: varLenFeature)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        varLenFeature = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.FeatureConfiguration.Builder {
                let resultDecodedBuilder = Tensorflow.FeatureConfiguration.Builder()
                if let jsonValueFixedLenFeature = jsonMap["fixedLenFeature"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.fixedLenFeature = try Tensorflow.FixedLenFeatureProto.Builder.decodeToBuilder(jsonMap:jsonValueFixedLenFeature).build()

                }
                if let jsonValueVarLenFeature = jsonMap["varLenFeature"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.varLenFeature = try Tensorflow.VarLenFeatureProto.Builder.decodeToBuilder(jsonMap:jsonValueVarLenFeature).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.FeatureConfiguration.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.FeatureConfiguration.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ExampleParserConfiguration : GeneratedMessage {

        public static func == (lhs: Tensorflow.ExampleParserConfiguration, rhs: Tensorflow.ExampleParserConfiguration) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasFeatureMap == rhs.hasFeatureMap) && (!lhs.hasFeatureMap || lhs.featureMap == rhs.featureMap)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        final public class FeatureMapEntry : GeneratedMessage {

            public static func == (lhs: Tensorflow.ExampleParserConfiguration.FeatureMapEntry, rhs: Tensorflow.ExampleParserConfiguration.FeatureMapEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:String = ""
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:Tensorflow.FeatureConfiguration!
            public fileprivate(set) var hasValue:Bool = false
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeString(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeMessage(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeStringSize(fieldNumber: 1)
                }
                if hasValue {
                    if let varSizevalue = value?.computeMessageSize(fieldNumber: 2) {
                        serialize_size += varSizevalue
                    }
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder {
                return Tensorflow.ExampleParserConfiguration.FeatureMapEntry.classBuilder() as! Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder
            }
            public func getBuilder() -> Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder {
                return classBuilder() as! Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder()
            }
            public func toBuilder() throws -> Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder {
                return try Tensorflow.ExampleParserConfiguration.FeatureMapEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.ExampleParserConfiguration.FeatureMapEntry) throws -> Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder {
                return try Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = key
                }
                if hasValue {
                    jsonMap["value"] = try value.encode()
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.ExampleParserConfiguration.FeatureMapEntry {
                return try Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.ExampleParserConfiguration.FeatureMapEntry {
                return try Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value {\n"
                    if let outDescValue = value {
                        output += try outDescValue.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        if let hashValuevalue = value?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuevalue
                        }
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.ExampleParserConfiguration.FeatureMapEntry"
            }
            override public func className() -> String {
                return "Tensorflow.ExampleParserConfiguration.FeatureMapEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.ExampleParserConfiguration.FeatureMapEntry = Tensorflow.ExampleParserConfiguration.FeatureMapEntry()
                public func getMessage() -> Tensorflow.ExampleParserConfiguration.FeatureMapEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:String {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:String) -> Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = ""
                    return self
                }
                public var value:Tensorflow.FeatureConfiguration! {
                    get {
                        if valueBuilder_ != nil {
                            builderResult.value = valueBuilder_.getMessage()
                        }
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                fileprivate var valueBuilder_:Tensorflow.FeatureConfiguration.Builder! {
                    didSet {
                        builderResult.hasValue = true
                    }
                }
                public func getValueBuilder() -> Tensorflow.FeatureConfiguration.Builder {
                    if valueBuilder_ == nil {
                        valueBuilder_ = Tensorflow.FeatureConfiguration.Builder()
                        builderResult.value = valueBuilder_.getMessage()
                        if value != nil {
                            try! valueBuilder_.mergeFrom(other: value)
                        }
                    }
                    return valueBuilder_
                }
                @discardableResult
                public func setValue(_ value:Tensorflow.FeatureConfiguration!) -> Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func mergeValue(value:Tensorflow.FeatureConfiguration) throws -> Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder {
                    if builderResult.hasValue {
                        builderResult.value = try Tensorflow.FeatureConfiguration.builderWithPrototype(prototype:builderResult.value).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.value = value
                    }
                    builderResult.hasValue = true
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder {
                    valueBuilder_ = nil
                    builderResult.hasValue = false
                    builderResult.value = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder {
                    builderResult = Tensorflow.ExampleParserConfiguration.FeatureMapEntry()
                    return self
                }
                override public func clone() throws -> Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder {
                    return try Tensorflow.ExampleParserConfiguration.FeatureMapEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.ExampleParserConfiguration.FeatureMapEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.ExampleParserConfiguration.FeatureMapEntry {
                    let returnMe:Tensorflow.ExampleParserConfiguration.FeatureMapEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.ExampleParserConfiguration.FeatureMapEntry) throws -> Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder {
                    if other == Tensorflow.ExampleParserConfiguration.FeatureMapEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if (other.hasValue) {
                        try mergeValue(value: other.value)
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            key = try codedInputStream.readString()

                        case 18:
                            let subBuilder:Tensorflow.FeatureConfiguration.Builder = Tensorflow.FeatureConfiguration.Builder()
                            if hasValue {
                                try subBuilder.mergeFrom(other: value)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            value = subBuilder.buildPartial()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder {
                    let resultDecodedBuilder = Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = jsonValueKey
                    }
                    if let jsonValueValue = jsonMap["value"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.value = try Tensorflow.FeatureConfiguration.Builder.decodeToBuilder(jsonMap:jsonValueValue).build()

                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        public fileprivate(set) var featureMap:Dictionary<String,Tensorflow.FeatureConfiguration> = Dictionary<String,Tensorflow.FeatureConfiguration>()

        public fileprivate(set) var hasFeatureMap:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasFeatureMap {
                for (keyFeatureMap, valueFeatureMap) in featureMap {
                    let valueOfFeatureMap = try! Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder().setKey(keyFeatureMap).setValue(valueFeatureMap).build()
                      try codedOutputStream.writeMessage(fieldNumber: 1, value:valueOfFeatureMap)
                  }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasFeatureMap {
                  for (keyFeatureMap, valueFeatureMap) in featureMap {
                      let valueOfFeatureMap = try! Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder().setKey(keyFeatureMap).setValue(valueFeatureMap).build()
                serialize_size += valueOfFeatureMap.computeMessageSize(fieldNumber: 1)
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.ExampleParserConfiguration.Builder {
            return Tensorflow.ExampleParserConfiguration.classBuilder() as! Tensorflow.ExampleParserConfiguration.Builder
        }
        public func getBuilder() -> Tensorflow.ExampleParserConfiguration.Builder {
            return classBuilder() as! Tensorflow.ExampleParserConfiguration.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.ExampleParserConfiguration.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.ExampleParserConfiguration.Builder()
        }
        public func toBuilder() throws -> Tensorflow.ExampleParserConfiguration.Builder {
            return try Tensorflow.ExampleParserConfiguration.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.ExampleParserConfiguration) throws -> Tensorflow.ExampleParserConfiguration.Builder {
            return try Tensorflow.ExampleParserConfiguration.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasFeatureMap {
                var mapFeatureMap = Dictionary<String, Dictionary<String,Any>>()
                for (keyFeatureMap, valueFeatureMap) in featureMap {
                    mapFeatureMap["\(keyFeatureMap)"] = try valueFeatureMap.encode()
                }
                jsonMap["featureMap"] = mapFeatureMap
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.ExampleParserConfiguration {
            return try Tensorflow.ExampleParserConfiguration.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.ExampleParserConfiguration {
            return try Tensorflow.ExampleParserConfiguration.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasFeatureMap {
                output += "\(indent) featureMap: \(featureMap) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasFeatureMap {
                    for (keyFeatureMap, valueFeatureMap) in featureMap {
                        hashCode = (hashCode &* 31) &+ keyFeatureMap.hashValue
                        hashCode = (hashCode &* 31) &+ valueFeatureMap.hashValue
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.ExampleParserConfiguration"
        }
        override public func className() -> String {
            return "Tensorflow.ExampleParserConfiguration"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.ExampleParserConfiguration = Tensorflow.ExampleParserConfiguration()
            public func getMessage() -> Tensorflow.ExampleParserConfiguration {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var hasFeatureMap:Bool {
                get {
                    return builderResult.hasFeatureMap
                }
            }
            public var featureMap:Dictionary<String,Tensorflow.FeatureConfiguration> {
                get {
                    return builderResult.featureMap
                }
                set (value) {
                    builderResult.hasFeatureMap = true
                    builderResult.featureMap = value
                }
            }
            @discardableResult
            public func setFeatureMap(_ value:Dictionary<String,Tensorflow.FeatureConfiguration>) -> Tensorflow.ExampleParserConfiguration.Builder {
                self.featureMap = value
                return self
            }
            @discardableResult
            public func clearFeatureMap() -> Tensorflow.ExampleParserConfiguration.Builder{
                builderResult.hasFeatureMap = false
                builderResult.featureMap = Dictionary<String,Tensorflow.FeatureConfiguration>()
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.ExampleParserConfiguration.Builder {
                builderResult = Tensorflow.ExampleParserConfiguration()
                return self
            }
            override public func clone() throws -> Tensorflow.ExampleParserConfiguration.Builder {
                return try Tensorflow.ExampleParserConfiguration.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.ExampleParserConfiguration {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.ExampleParserConfiguration {
                let returnMe:Tensorflow.ExampleParserConfiguration = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.ExampleParserConfiguration) throws -> Tensorflow.ExampleParserConfiguration.Builder {
                if other == Tensorflow.ExampleParserConfiguration() {
                    return self
                }
                if other.hasFeatureMap {
                    featureMap = other.featureMap
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.ExampleParserConfiguration.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ExampleParserConfiguration.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfFeatureMap = subBuilder.buildPartial()
                        featureMap[buildOfFeatureMap.key] = buildOfFeatureMap.value

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.ExampleParserConfiguration.Builder {
                let resultDecodedBuilder = Tensorflow.ExampleParserConfiguration.Builder()
                if let jsonValueFeatureMap = jsonMap["featureMap"] as? Dictionary<String, Dictionary<String,Any>> {
                    var mapFeatureMap = Dictionary<String, Tensorflow.FeatureConfiguration>()
                    for (keyFeatureMap, valueFeatureMap) in jsonValueFeatureMap {
                        guard let keyFromFeatureMap = String(keyFeatureMap) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapFeatureMap[keyFromFeatureMap] = try Tensorflow.FeatureConfiguration.Builder.decodeToBuilder(jsonMap:valueFeatureMap).build()

                    }
                    resultDecodedBuilder.featureMap = mapFeatureMap
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.ExampleParserConfiguration.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.ExampleParserConfiguration.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.VarLenFeatureProto: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.VarLenFeatureProto> {
        var mergedArray = Array<Tensorflow.VarLenFeatureProto>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.VarLenFeatureProto? {
        return try Tensorflow.VarLenFeatureProto.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.VarLenFeatureProto {
        return try Tensorflow.VarLenFeatureProto.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.ExampleParserConfigurationRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.VarLenFeatureProto {
        return try Tensorflow.VarLenFeatureProto.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.VarLenFeatureProto {
        return try Tensorflow.VarLenFeatureProto.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.VarLenFeatureProto {
        return try Tensorflow.VarLenFeatureProto.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.VarLenFeatureProto {
        return try Tensorflow.VarLenFeatureProto.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.VarLenFeatureProto {
        return try Tensorflow.VarLenFeatureProto.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "dtype": return self.dtype
        case "valuesOutputTensorName": return self.valuesOutputTensorName
        case "indicesOutputTensorName": return self.indicesOutputTensorName
        case "shapesOutputTensorName": return self.shapesOutputTensorName
        default: return nil
        }
    }
}
extension Tensorflow.VarLenFeatureProto.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "dtype": return self.dtype
            case "valuesOutputTensorName": return self.valuesOutputTensorName
            case "indicesOutputTensorName": return self.indicesOutputTensorName
            case "shapesOutputTensorName": return self.shapesOutputTensorName
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "dtype":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.DataType else {
                    return
                }
                self.dtype = newSubscriptValue
            case "valuesOutputTensorName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.valuesOutputTensorName = newSubscriptValue
            case "indicesOutputTensorName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.indicesOutputTensorName = newSubscriptValue
            case "shapesOutputTensorName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.shapesOutputTensorName = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.FixedLenFeatureProto: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.FixedLenFeatureProto> {
        var mergedArray = Array<Tensorflow.FixedLenFeatureProto>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.FixedLenFeatureProto? {
        return try Tensorflow.FixedLenFeatureProto.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.FixedLenFeatureProto {
        return try Tensorflow.FixedLenFeatureProto.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.ExampleParserConfigurationRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FixedLenFeatureProto {
        return try Tensorflow.FixedLenFeatureProto.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.FixedLenFeatureProto {
        return try Tensorflow.FixedLenFeatureProto.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FixedLenFeatureProto {
        return try Tensorflow.FixedLenFeatureProto.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.FixedLenFeatureProto {
        return try Tensorflow.FixedLenFeatureProto.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FixedLenFeatureProto {
        return try Tensorflow.FixedLenFeatureProto.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "dtype": return self.dtype
        case "shape": return self.shape
        case "defaultValue": return self.defaultValue
        case "valuesOutputTensorName": return self.valuesOutputTensorName
        default: return nil
        }
    }
}
extension Tensorflow.FixedLenFeatureProto.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "dtype": return self.dtype
            case "shape": return self.shape
            case "defaultValue": return self.defaultValue
            case "valuesOutputTensorName": return self.valuesOutputTensorName
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "dtype":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.DataType else {
                    return
                }
                self.dtype = newSubscriptValue
            case "shape":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.TensorShapeProto else {
                    return
                }
                self.shape = newSubscriptValue
            case "defaultValue":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.TensorProto else {
                    return
                }
                self.defaultValue = newSubscriptValue
            case "valuesOutputTensorName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.valuesOutputTensorName = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.FeatureConfiguration: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.FeatureConfiguration> {
        var mergedArray = Array<Tensorflow.FeatureConfiguration>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.FeatureConfiguration? {
        return try Tensorflow.FeatureConfiguration.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.FeatureConfiguration {
        return try Tensorflow.FeatureConfiguration.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.ExampleParserConfigurationRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FeatureConfiguration {
        return try Tensorflow.FeatureConfiguration.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.FeatureConfiguration {
        return try Tensorflow.FeatureConfiguration.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FeatureConfiguration {
        return try Tensorflow.FeatureConfiguration.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.FeatureConfiguration {
        return try Tensorflow.FeatureConfiguration.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FeatureConfiguration {
        return try Tensorflow.FeatureConfiguration.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "fixedLenFeature": return self.fixedLenFeature
        case "varLenFeature": return self.varLenFeature
        default: return nil
        }
    }
}
extension Tensorflow.FeatureConfiguration.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "fixedLenFeature": return self.fixedLenFeature
            case "varLenFeature": return self.varLenFeature
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "fixedLenFeature":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.FixedLenFeatureProto else {
                    return
                }
                self.fixedLenFeature = newSubscriptValue
            case "varLenFeature":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.VarLenFeatureProto else {
                    return
                }
                self.varLenFeature = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.ExampleParserConfiguration: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.ExampleParserConfiguration> {
        var mergedArray = Array<Tensorflow.ExampleParserConfiguration>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.ExampleParserConfiguration? {
        return try Tensorflow.ExampleParserConfiguration.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.ExampleParserConfiguration {
        return try Tensorflow.ExampleParserConfiguration.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.ExampleParserConfigurationRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ExampleParserConfiguration {
        return try Tensorflow.ExampleParserConfiguration.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.ExampleParserConfiguration {
        return try Tensorflow.ExampleParserConfiguration.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ExampleParserConfiguration {
        return try Tensorflow.ExampleParserConfiguration.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.ExampleParserConfiguration {
        return try Tensorflow.ExampleParserConfiguration.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ExampleParserConfiguration {
        return try Tensorflow.ExampleParserConfiguration.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "featureMap": return self.featureMap
        default: return nil
        }
    }
}
extension Tensorflow.ExampleParserConfiguration.FeatureMapEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.ExampleParserConfiguration.FeatureMapEntry> {
        var mergedArray = Array<Tensorflow.ExampleParserConfiguration.FeatureMapEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.ExampleParserConfiguration.FeatureMapEntry? {
        return try Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.ExampleParserConfiguration.FeatureMapEntry {
        return try Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.ExampleParserConfigurationRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ExampleParserConfiguration.FeatureMapEntry {
        return try Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.ExampleParserConfiguration.FeatureMapEntry {
        return try Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ExampleParserConfiguration.FeatureMapEntry {
        return try Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.ExampleParserConfiguration.FeatureMapEntry {
        return try Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ExampleParserConfiguration.FeatureMapEntry {
        return try Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.ExampleParserConfiguration.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "featureMap": return self.featureMap
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "featureMap":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,Tensorflow.FeatureConfiguration> else {
                    return
                }
                self.featureMap = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.ExampleParserConfiguration.FeatureMapEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.FeatureConfiguration else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

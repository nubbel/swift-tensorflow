/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "control_flow.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { }

public extension Tensorflow {
    public struct ControlFlowRoot {
        public static let `default` = ControlFlowRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    /// Protocol buffer representing the values in ControlFlowContext.
    final public class ValuesDef : GeneratedMessage {

        public static func == (lhs: Tensorflow.ValuesDef, rhs: Tensorflow.ValuesDef) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.values == rhs.values)
            fieldCheck = fieldCheck && (lhs.hasExternalValues == rhs.hasExternalValues) && (!lhs.hasExternalValues || lhs.externalValues == rhs.externalValues)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        final public class ExternalValuesEntry : GeneratedMessage {

            public static func == (lhs: Tensorflow.ValuesDef.ExternalValuesEntry, rhs: Tensorflow.ValuesDef.ExternalValuesEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:String = ""
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:String = ""
            public fileprivate(set) var hasValue:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeString(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeString(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeStringSize(fieldNumber: 1)
                }
                if hasValue {
                    serialize_size += value.computeStringSize(fieldNumber: 2)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.ValuesDef.ExternalValuesEntry.Builder {
                return Tensorflow.ValuesDef.ExternalValuesEntry.classBuilder() as! Tensorflow.ValuesDef.ExternalValuesEntry.Builder
            }
            public func getBuilder() -> Tensorflow.ValuesDef.ExternalValuesEntry.Builder {
                return classBuilder() as! Tensorflow.ValuesDef.ExternalValuesEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.ValuesDef.ExternalValuesEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.ValuesDef.ExternalValuesEntry.Builder()
            }
            public func toBuilder() throws -> Tensorflow.ValuesDef.ExternalValuesEntry.Builder {
                return try Tensorflow.ValuesDef.ExternalValuesEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.ValuesDef.ExternalValuesEntry) throws -> Tensorflow.ValuesDef.ExternalValuesEntry.Builder {
                return try Tensorflow.ValuesDef.ExternalValuesEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = key
                }
                if hasValue {
                    jsonMap["value"] = value
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.ValuesDef.ExternalValuesEntry {
                return try Tensorflow.ValuesDef.ExternalValuesEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.ValuesDef.ExternalValuesEntry {
                return try Tensorflow.ValuesDef.ExternalValuesEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value: \(value) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        hashCode = (hashCode &* 31) &+ value.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.ValuesDef.ExternalValuesEntry"
            }
            override public func className() -> String {
                return "Tensorflow.ValuesDef.ExternalValuesEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.ValuesDef.ExternalValuesEntry = Tensorflow.ValuesDef.ExternalValuesEntry()
                public func getMessage() -> Tensorflow.ValuesDef.ExternalValuesEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:String {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:String) -> Tensorflow.ValuesDef.ExternalValuesEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> Tensorflow.ValuesDef.ExternalValuesEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = ""
                    return self
                }
                public var value:String {
                    get {
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                @discardableResult
                public func setValue(_ value:String) -> Tensorflow.ValuesDef.ExternalValuesEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.ValuesDef.ExternalValuesEntry.Builder{
                    builderResult.hasValue = false
                    builderResult.value = ""
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.ValuesDef.ExternalValuesEntry.Builder {
                    builderResult = Tensorflow.ValuesDef.ExternalValuesEntry()
                    return self
                }
                override public func clone() throws -> Tensorflow.ValuesDef.ExternalValuesEntry.Builder {
                    return try Tensorflow.ValuesDef.ExternalValuesEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.ValuesDef.ExternalValuesEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.ValuesDef.ExternalValuesEntry {
                    let returnMe:Tensorflow.ValuesDef.ExternalValuesEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.ValuesDef.ExternalValuesEntry) throws -> Tensorflow.ValuesDef.ExternalValuesEntry.Builder {
                    if other == Tensorflow.ValuesDef.ExternalValuesEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if other.hasValue {
                        value = other.value
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.ValuesDef.ExternalValuesEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ValuesDef.ExternalValuesEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            key = try codedInputStream.readString()

                        case 18:
                            value = try codedInputStream.readString()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.ValuesDef.ExternalValuesEntry.Builder {
                    let resultDecodedBuilder = Tensorflow.ValuesDef.ExternalValuesEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = jsonValueKey
                    }
                    if let jsonValueValue = jsonMap["value"] as? String {
                        resultDecodedBuilder.value = jsonValueValue
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.ValuesDef.ExternalValuesEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.ValuesDef.ExternalValuesEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        /// Value names that have been seen in this context.
        public fileprivate(set) var values:Array<String> = Array<String>()
        /// Value names referenced by but external to this context.
        public fileprivate(set) var externalValues:Dictionary<String,String> = Dictionary<String,String>()

        public fileprivate(set) var hasExternalValues:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if !values.isEmpty {
                for oneValuevalues in values {
                    try codedOutputStream.writeString(fieldNumber: 1, value:oneValuevalues)
                }
            }
            if hasExternalValues {
                for (keyExternalValues, valueExternalValues) in externalValues {
                    let valueOfExternalValues = try! Tensorflow.ValuesDef.ExternalValuesEntry.Builder().setKey(keyExternalValues).setValue(valueExternalValues).build()
                      try codedOutputStream.writeMessage(fieldNumber: 2, value:valueOfExternalValues)
                  }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            var dataSizeValues:Int32 = 0
            for oneValuevalues in values {
                dataSizeValues += oneValuevalues.computeStringSizeNoTag()
            }
            serialize_size += dataSizeValues
            serialize_size += 1 * Int32(values.count)
            if hasExternalValues {
                  for (keyExternalValues, valueExternalValues) in externalValues {
                      let valueOfExternalValues = try! Tensorflow.ValuesDef.ExternalValuesEntry.Builder().setKey(keyExternalValues).setValue(valueExternalValues).build()
                serialize_size += valueOfExternalValues.computeMessageSize(fieldNumber: 2)
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.ValuesDef.Builder {
            return Tensorflow.ValuesDef.classBuilder() as! Tensorflow.ValuesDef.Builder
        }
        public func getBuilder() -> Tensorflow.ValuesDef.Builder {
            return classBuilder() as! Tensorflow.ValuesDef.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.ValuesDef.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.ValuesDef.Builder()
        }
        public func toBuilder() throws -> Tensorflow.ValuesDef.Builder {
            return try Tensorflow.ValuesDef.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.ValuesDef) throws -> Tensorflow.ValuesDef.Builder {
            return try Tensorflow.ValuesDef.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !values.isEmpty {
                var jsonArrayValues:Array<String> = []
                for oneValueValues in values {
                    jsonArrayValues.append(oneValueValues)
                }
                jsonMap["values"] = jsonArrayValues
            }
            if hasExternalValues {
                var mapExternalValues = Dictionary<String, String>()
                for (keyExternalValues, valueExternalValues) in externalValues {
                    mapExternalValues["\(keyExternalValues)"] = valueExternalValues
                }
                jsonMap["externalValues"] = mapExternalValues
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.ValuesDef {
            return try Tensorflow.ValuesDef.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.ValuesDef {
            return try Tensorflow.ValuesDef.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var valuesElementIndex:Int = 0
            for oneValueValues in values  {
                output += "\(indent) values[\(valuesElementIndex)]: \(oneValueValues)\n"
                valuesElementIndex += 1
            }
            if hasExternalValues {
                output += "\(indent) externalValues: \(externalValues) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneValueValues in values {
                    hashCode = (hashCode &* 31) &+ oneValueValues.hashValue
                }
                if hasExternalValues {
                    for (keyExternalValues, valueExternalValues) in externalValues {
                        hashCode = (hashCode &* 31) &+ keyExternalValues.hashValue
                        hashCode = (hashCode &* 31) &+ valueExternalValues.hashValue
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.ValuesDef"
        }
        override public func className() -> String {
            return "Tensorflow.ValuesDef"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.ValuesDef = Tensorflow.ValuesDef()
            public func getMessage() -> Tensorflow.ValuesDef {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Value names that have been seen in this context.
            public var values:Array<String> {
                get {
                    return builderResult.values
                }
                set (array) {
                    builderResult.values = array
                }
            }
            @discardableResult
            public func setValues(_ value:Array<String>) -> Tensorflow.ValuesDef.Builder {
                self.values = value
                return self
            }
            @discardableResult
            public func clearValues() -> Tensorflow.ValuesDef.Builder {
                builderResult.values.removeAll(keepingCapacity: false)
                return self
            }
            /// Value names referenced by but external to this context.
            public var hasExternalValues:Bool {
                get {
                    return builderResult.hasExternalValues
                }
            }
            public var externalValues:Dictionary<String,String> {
                get {
                    return builderResult.externalValues
                }
                set (value) {
                    builderResult.hasExternalValues = true
                    builderResult.externalValues = value
                }
            }
            @discardableResult
            public func setExternalValues(_ value:Dictionary<String,String>) -> Tensorflow.ValuesDef.Builder {
                self.externalValues = value
                return self
            }
            @discardableResult
            public func clearExternalValues() -> Tensorflow.ValuesDef.Builder{
                builderResult.hasExternalValues = false
                builderResult.externalValues = Dictionary<String,String>()
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.ValuesDef.Builder {
                builderResult = Tensorflow.ValuesDef()
                return self
            }
            override public func clone() throws -> Tensorflow.ValuesDef.Builder {
                return try Tensorflow.ValuesDef.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.ValuesDef {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.ValuesDef {
                let returnMe:Tensorflow.ValuesDef = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.ValuesDef) throws -> Tensorflow.ValuesDef.Builder {
                if other == Tensorflow.ValuesDef() {
                    return self
                }
                if !other.values.isEmpty {
                    builderResult.values += other.values
                }
                if other.hasExternalValues {
                    externalValues = other.externalValues
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.ValuesDef.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ValuesDef.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        values += [try codedInputStream.readString()]

                    case 18:
                        let subBuilder = Tensorflow.ValuesDef.ExternalValuesEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfExternalValues = subBuilder.buildPartial()
                        externalValues[buildOfExternalValues.key] = buildOfExternalValues.value

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.ValuesDef.Builder {
                let resultDecodedBuilder = Tensorflow.ValuesDef.Builder()
                if let jsonValueValues = jsonMap["values"] as? Array<String> {
                    var jsonArrayValues:Array<String> = []
                    for oneValueValues in jsonValueValues {
                        jsonArrayValues.append(oneValueValues)
                    }
                    resultDecodedBuilder.values = jsonArrayValues
                }
                if let jsonValueExternalValues = jsonMap["externalValues"] as? Dictionary<String, String> {
                    var mapExternalValues = Dictionary<String, String>()
                    for (keyExternalValues, valueExternalValues) in jsonValueExternalValues {
                        guard let keyFromExternalValues = String(keyExternalValues) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapExternalValues[keyFromExternalValues] = valueExternalValues
                    }
                    resultDecodedBuilder.externalValues = mapExternalValues
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.ValuesDef.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.ValuesDef.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Protocol buffer representing a CondContext object.
    final public class CondContextDef : GeneratedMessage {

        public static func == (lhs: Tensorflow.CondContextDef, rhs: Tensorflow.CondContextDef) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasContextName == rhs.hasContextName) && (!lhs.hasContextName || lhs.contextName == rhs.contextName)
            fieldCheck = fieldCheck && (lhs.hasPredName == rhs.hasPredName) && (!lhs.hasPredName || lhs.predName == rhs.predName)
            fieldCheck = fieldCheck && (lhs.hasPivotName == rhs.hasPivotName) && (!lhs.hasPivotName || lhs.pivotName == rhs.pivotName)
            fieldCheck = fieldCheck && (lhs.hasBranch == rhs.hasBranch) && (!lhs.hasBranch || lhs.branch == rhs.branch)
            fieldCheck = fieldCheck && (lhs.hasValuesDef == rhs.hasValuesDef) && (!lhs.hasValuesDef || lhs.valuesDef == rhs.valuesDef)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Name of the context.
        public fileprivate(set) var contextName:String = ""
        public fileprivate(set) var hasContextName:Bool = false

        /// Name of the pred tensor.
        public fileprivate(set) var predName:String = ""
        public fileprivate(set) var hasPredName:Bool = false

        /// Name of the pivot tensor.
        public fileprivate(set) var pivotName:String = ""
        public fileprivate(set) var hasPivotName:Bool = false

        /// Branch prediction. 0 or 1.
        public fileprivate(set) var branch:Int32 = Int32(0)
        public fileprivate(set) var hasBranch:Bool = false

        public fileprivate(set) var valuesDef:Tensorflow.ValuesDef!
        public fileprivate(set) var hasValuesDef:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasContextName {
                try codedOutputStream.writeString(fieldNumber: 1, value:contextName)
            }
            if hasPredName {
                try codedOutputStream.writeString(fieldNumber: 2, value:predName)
            }
            if hasPivotName {
                try codedOutputStream.writeString(fieldNumber: 3, value:pivotName)
            }
            if hasBranch {
                try codedOutputStream.writeInt32(fieldNumber: 4, value:branch)
            }
            if hasValuesDef {
                try codedOutputStream.writeMessage(fieldNumber: 5, value:valuesDef)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasContextName {
                serialize_size += contextName.computeStringSize(fieldNumber: 1)
            }
            if hasPredName {
                serialize_size += predName.computeStringSize(fieldNumber: 2)
            }
            if hasPivotName {
                serialize_size += pivotName.computeStringSize(fieldNumber: 3)
            }
            if hasBranch {
                serialize_size += branch.computeInt32Size(fieldNumber: 4)
            }
            if hasValuesDef {
                if let varSizevaluesDef = valuesDef?.computeMessageSize(fieldNumber: 5) {
                    serialize_size += varSizevaluesDef
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.CondContextDef.Builder {
            return Tensorflow.CondContextDef.classBuilder() as! Tensorflow.CondContextDef.Builder
        }
        public func getBuilder() -> Tensorflow.CondContextDef.Builder {
            return classBuilder() as! Tensorflow.CondContextDef.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.CondContextDef.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.CondContextDef.Builder()
        }
        public func toBuilder() throws -> Tensorflow.CondContextDef.Builder {
            return try Tensorflow.CondContextDef.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.CondContextDef) throws -> Tensorflow.CondContextDef.Builder {
            return try Tensorflow.CondContextDef.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasContextName {
                jsonMap["contextName"] = contextName
            }
            if hasPredName {
                jsonMap["predName"] = predName
            }
            if hasPivotName {
                jsonMap["pivotName"] = pivotName
            }
            if hasBranch {
                jsonMap["branch"] = Int(branch)
            }
            if hasValuesDef {
                jsonMap["valuesDef"] = try valuesDef.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CondContextDef {
            return try Tensorflow.CondContextDef.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.CondContextDef {
            return try Tensorflow.CondContextDef.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasContextName {
                output += "\(indent) contextName: \(contextName) \n"
            }
            if hasPredName {
                output += "\(indent) predName: \(predName) \n"
            }
            if hasPivotName {
                output += "\(indent) pivotName: \(pivotName) \n"
            }
            if hasBranch {
                output += "\(indent) branch: \(branch) \n"
            }
            if hasValuesDef {
                output += "\(indent) valuesDef {\n"
                if let outDescValuesDef = valuesDef {
                    output += try outDescValuesDef.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasContextName {
                    hashCode = (hashCode &* 31) &+ contextName.hashValue
                }
                if hasPredName {
                    hashCode = (hashCode &* 31) &+ predName.hashValue
                }
                if hasPivotName {
                    hashCode = (hashCode &* 31) &+ pivotName.hashValue
                }
                if hasBranch {
                    hashCode = (hashCode &* 31) &+ branch.hashValue
                }
                if hasValuesDef {
                    if let hashValuevaluesDef = valuesDef?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuevaluesDef
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.CondContextDef"
        }
        override public func className() -> String {
            return "Tensorflow.CondContextDef"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.CondContextDef = Tensorflow.CondContextDef()
            public func getMessage() -> Tensorflow.CondContextDef {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Name of the context.
            public var contextName:String {
                get {
                    return builderResult.contextName
                }
                set (value) {
                    builderResult.hasContextName = true
                    builderResult.contextName = value
                }
            }
            public var hasContextName:Bool {
                get {
                    return builderResult.hasContextName
                }
            }
            @discardableResult
            public func setContextName(_ value:String) -> Tensorflow.CondContextDef.Builder {
                self.contextName = value
                return self
            }
            @discardableResult
            public func clearContextName() -> Tensorflow.CondContextDef.Builder{
                builderResult.hasContextName = false
                builderResult.contextName = ""
                return self
            }
            /// Name of the pred tensor.
            public var predName:String {
                get {
                    return builderResult.predName
                }
                set (value) {
                    builderResult.hasPredName = true
                    builderResult.predName = value
                }
            }
            public var hasPredName:Bool {
                get {
                    return builderResult.hasPredName
                }
            }
            @discardableResult
            public func setPredName(_ value:String) -> Tensorflow.CondContextDef.Builder {
                self.predName = value
                return self
            }
            @discardableResult
            public func clearPredName() -> Tensorflow.CondContextDef.Builder{
                builderResult.hasPredName = false
                builderResult.predName = ""
                return self
            }
            /// Name of the pivot tensor.
            public var pivotName:String {
                get {
                    return builderResult.pivotName
                }
                set (value) {
                    builderResult.hasPivotName = true
                    builderResult.pivotName = value
                }
            }
            public var hasPivotName:Bool {
                get {
                    return builderResult.hasPivotName
                }
            }
            @discardableResult
            public func setPivotName(_ value:String) -> Tensorflow.CondContextDef.Builder {
                self.pivotName = value
                return self
            }
            @discardableResult
            public func clearPivotName() -> Tensorflow.CondContextDef.Builder{
                builderResult.hasPivotName = false
                builderResult.pivotName = ""
                return self
            }
            /// Branch prediction. 0 or 1.
            public var branch:Int32 {
                get {
                    return builderResult.branch
                }
                set (value) {
                    builderResult.hasBranch = true
                    builderResult.branch = value
                }
            }
            public var hasBranch:Bool {
                get {
                    return builderResult.hasBranch
                }
            }
            @discardableResult
            public func setBranch(_ value:Int32) -> Tensorflow.CondContextDef.Builder {
                self.branch = value
                return self
            }
            @discardableResult
            public func clearBranch() -> Tensorflow.CondContextDef.Builder{
                builderResult.hasBranch = false
                builderResult.branch = Int32(0)
                return self
            }
            /// Values and external values in control flow context.
            public var valuesDef:Tensorflow.ValuesDef! {
                get {
                    if valuesDefBuilder_ != nil {
                        builderResult.valuesDef = valuesDefBuilder_.getMessage()
                    }
                    return builderResult.valuesDef
                }
                set (value) {
                    builderResult.hasValuesDef = true
                    builderResult.valuesDef = value
                }
            }
            public var hasValuesDef:Bool {
                get {
                    return builderResult.hasValuesDef
                }
            }
            fileprivate var valuesDefBuilder_:Tensorflow.ValuesDef.Builder! {
                didSet {
                    builderResult.hasValuesDef = true
                }
            }
            public func getValuesDefBuilder() -> Tensorflow.ValuesDef.Builder {
                if valuesDefBuilder_ == nil {
                    valuesDefBuilder_ = Tensorflow.ValuesDef.Builder()
                    builderResult.valuesDef = valuesDefBuilder_.getMessage()
                    if valuesDef != nil {
                        try! valuesDefBuilder_.mergeFrom(other: valuesDef)
                    }
                }
                return valuesDefBuilder_
            }
            @discardableResult
            public func setValuesDef(_ value:Tensorflow.ValuesDef!) -> Tensorflow.CondContextDef.Builder {
                self.valuesDef = value
                return self
            }
            @discardableResult
            public func mergeValuesDef(value:Tensorflow.ValuesDef) throws -> Tensorflow.CondContextDef.Builder {
                if builderResult.hasValuesDef {
                    builderResult.valuesDef = try Tensorflow.ValuesDef.builderWithPrototype(prototype:builderResult.valuesDef).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.valuesDef = value
                }
                builderResult.hasValuesDef = true
                return self
            }
            @discardableResult
            public func clearValuesDef() -> Tensorflow.CondContextDef.Builder {
                valuesDefBuilder_ = nil
                builderResult.hasValuesDef = false
                builderResult.valuesDef = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.CondContextDef.Builder {
                builderResult = Tensorflow.CondContextDef()
                return self
            }
            override public func clone() throws -> Tensorflow.CondContextDef.Builder {
                return try Tensorflow.CondContextDef.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.CondContextDef {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.CondContextDef {
                let returnMe:Tensorflow.CondContextDef = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.CondContextDef) throws -> Tensorflow.CondContextDef.Builder {
                if other == Tensorflow.CondContextDef() {
                    return self
                }
                if other.hasContextName {
                    contextName = other.contextName
                }
                if other.hasPredName {
                    predName = other.predName
                }
                if other.hasPivotName {
                    pivotName = other.pivotName
                }
                if other.hasBranch {
                    branch = other.branch
                }
                if (other.hasValuesDef) {
                    try mergeValuesDef(value: other.valuesDef)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CondContextDef.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CondContextDef.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        contextName = try codedInputStream.readString()

                    case 18:
                        predName = try codedInputStream.readString()

                    case 26:
                        pivotName = try codedInputStream.readString()

                    case 32:
                        branch = try codedInputStream.readInt32()

                    case 42:
                        let subBuilder:Tensorflow.ValuesDef.Builder = Tensorflow.ValuesDef.Builder()
                        if hasValuesDef {
                            try subBuilder.mergeFrom(other: valuesDef)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        valuesDef = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CondContextDef.Builder {
                let resultDecodedBuilder = Tensorflow.CondContextDef.Builder()
                if let jsonValueContextName = jsonMap["contextName"] as? String {
                    resultDecodedBuilder.contextName = jsonValueContextName
                }
                if let jsonValuePredName = jsonMap["predName"] as? String {
                    resultDecodedBuilder.predName = jsonValuePredName
                }
                if let jsonValuePivotName = jsonMap["pivotName"] as? String {
                    resultDecodedBuilder.pivotName = jsonValuePivotName
                }
                if let jsonValueBranch = jsonMap["branch"] as? Int {
                    resultDecodedBuilder.branch = Int32(jsonValueBranch)
                } else if let jsonValueBranch = jsonMap["branch"] as? String {
                    resultDecodedBuilder.branch = Int32(jsonValueBranch)!
                }
                if let jsonValueValuesDef = jsonMap["valuesDef"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.valuesDef = try Tensorflow.ValuesDef.Builder.decodeToBuilder(jsonMap:jsonValueValuesDef).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.CondContextDef.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.CondContextDef.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Protocol buffer representing a WhileContext object.
    final public class WhileContextDef : GeneratedMessage {

        public static func == (lhs: Tensorflow.WhileContextDef, rhs: Tensorflow.WhileContextDef) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasContextName == rhs.hasContextName) && (!lhs.hasContextName || lhs.contextName == rhs.contextName)
            fieldCheck = fieldCheck && (lhs.hasParallelIterations == rhs.hasParallelIterations) && (!lhs.hasParallelIterations || lhs.parallelIterations == rhs.parallelIterations)
            fieldCheck = fieldCheck && (lhs.hasBackProp == rhs.hasBackProp) && (!lhs.hasBackProp || lhs.backProp == rhs.backProp)
            fieldCheck = fieldCheck && (lhs.hasSwapMemory == rhs.hasSwapMemory) && (!lhs.hasSwapMemory || lhs.swapMemory == rhs.swapMemory)
            fieldCheck = fieldCheck && (lhs.hasPivotName == rhs.hasPivotName) && (!lhs.hasPivotName || lhs.pivotName == rhs.pivotName)
            fieldCheck = fieldCheck && (lhs.hasPivotForPredName == rhs.hasPivotForPredName) && (!lhs.hasPivotForPredName || lhs.pivotForPredName == rhs.pivotForPredName)
            fieldCheck = fieldCheck && (lhs.hasPivotForBodyName == rhs.hasPivotForBodyName) && (!lhs.hasPivotForBodyName || lhs.pivotForBodyName == rhs.pivotForBodyName)
            fieldCheck = fieldCheck && (lhs.loopExitNames == rhs.loopExitNames)
            fieldCheck = fieldCheck && (lhs.hasValuesDef == rhs.hasValuesDef) && (!lhs.hasValuesDef || lhs.valuesDef == rhs.valuesDef)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Name of the context.
        public fileprivate(set) var contextName:String = ""
        public fileprivate(set) var hasContextName:Bool = false

        /// The number of iterations allowed to run in parallel.
        public fileprivate(set) var parallelIterations:Int32 = Int32(0)
        public fileprivate(set) var hasParallelIterations:Bool = false

        /// Whether backprop is enabled for this while loop.
        public fileprivate(set) var backProp:Bool = false
        public fileprivate(set) var hasBackProp:Bool = false

        /// Whether GPU-CPU memory swap is enabled for this loop.
        public fileprivate(set) var swapMemory:Bool = false
        public fileprivate(set) var hasSwapMemory:Bool = false

        /// Name of the pivot tensor.
        public fileprivate(set) var pivotName:String = ""
        public fileprivate(set) var hasPivotName:Bool = false

        /// Name of the pivot_for_pred tensor.
        public fileprivate(set) var pivotForPredName:String = ""
        public fileprivate(set) var hasPivotForPredName:Bool = false

        /// Name of the pivot_for_body tensor.
        public fileprivate(set) var pivotForBodyName:String = ""
        public fileprivate(set) var hasPivotForBodyName:Bool = false

        /// List of names for exit tensors.
        public fileprivate(set) var loopExitNames:Array<String> = Array<String>()
        public fileprivate(set) var valuesDef:Tensorflow.ValuesDef!
        public fileprivate(set) var hasValuesDef:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasContextName {
                try codedOutputStream.writeString(fieldNumber: 1, value:contextName)
            }
            if hasParallelIterations {
                try codedOutputStream.writeInt32(fieldNumber: 2, value:parallelIterations)
            }
            if hasBackProp {
                try codedOutputStream.writeBool(fieldNumber: 3, value:backProp)
            }
            if hasSwapMemory {
                try codedOutputStream.writeBool(fieldNumber: 4, value:swapMemory)
            }
            if hasPivotName {
                try codedOutputStream.writeString(fieldNumber: 5, value:pivotName)
            }
            if hasPivotForPredName {
                try codedOutputStream.writeString(fieldNumber: 6, value:pivotForPredName)
            }
            if hasPivotForBodyName {
                try codedOutputStream.writeString(fieldNumber: 7, value:pivotForBodyName)
            }
            if !loopExitNames.isEmpty {
                for oneValueloopExitNames in loopExitNames {
                    try codedOutputStream.writeString(fieldNumber: 8, value:oneValueloopExitNames)
                }
            }
            if hasValuesDef {
                try codedOutputStream.writeMessage(fieldNumber: 9, value:valuesDef)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasContextName {
                serialize_size += contextName.computeStringSize(fieldNumber: 1)
            }
            if hasParallelIterations {
                serialize_size += parallelIterations.computeInt32Size(fieldNumber: 2)
            }
            if hasBackProp {
                serialize_size += backProp.computeBoolSize(fieldNumber: 3)
            }
            if hasSwapMemory {
                serialize_size += swapMemory.computeBoolSize(fieldNumber: 4)
            }
            if hasPivotName {
                serialize_size += pivotName.computeStringSize(fieldNumber: 5)
            }
            if hasPivotForPredName {
                serialize_size += pivotForPredName.computeStringSize(fieldNumber: 6)
            }
            if hasPivotForBodyName {
                serialize_size += pivotForBodyName.computeStringSize(fieldNumber: 7)
            }
            var dataSizeLoopExitNames:Int32 = 0
            for oneValueloopExitNames in loopExitNames {
                dataSizeLoopExitNames += oneValueloopExitNames.computeStringSizeNoTag()
            }
            serialize_size += dataSizeLoopExitNames
            serialize_size += 1 * Int32(loopExitNames.count)
            if hasValuesDef {
                if let varSizevaluesDef = valuesDef?.computeMessageSize(fieldNumber: 9) {
                    serialize_size += varSizevaluesDef
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.WhileContextDef.Builder {
            return Tensorflow.WhileContextDef.classBuilder() as! Tensorflow.WhileContextDef.Builder
        }
        public func getBuilder() -> Tensorflow.WhileContextDef.Builder {
            return classBuilder() as! Tensorflow.WhileContextDef.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.WhileContextDef.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.WhileContextDef.Builder()
        }
        public func toBuilder() throws -> Tensorflow.WhileContextDef.Builder {
            return try Tensorflow.WhileContextDef.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.WhileContextDef) throws -> Tensorflow.WhileContextDef.Builder {
            return try Tensorflow.WhileContextDef.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasContextName {
                jsonMap["contextName"] = contextName
            }
            if hasParallelIterations {
                jsonMap["parallelIterations"] = Int(parallelIterations)
            }
            if hasBackProp {
                jsonMap["backProp"] = backProp
            }
            if hasSwapMemory {
                jsonMap["swapMemory"] = swapMemory
            }
            if hasPivotName {
                jsonMap["pivotName"] = pivotName
            }
            if hasPivotForPredName {
                jsonMap["pivotForPredName"] = pivotForPredName
            }
            if hasPivotForBodyName {
                jsonMap["pivotForBodyName"] = pivotForBodyName
            }
            if !loopExitNames.isEmpty {
                var jsonArrayLoopExitNames:Array<String> = []
                for oneValueLoopExitNames in loopExitNames {
                    jsonArrayLoopExitNames.append(oneValueLoopExitNames)
                }
                jsonMap["loopExitNames"] = jsonArrayLoopExitNames
            }
            if hasValuesDef {
                jsonMap["valuesDef"] = try valuesDef.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.WhileContextDef {
            return try Tensorflow.WhileContextDef.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.WhileContextDef {
            return try Tensorflow.WhileContextDef.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasContextName {
                output += "\(indent) contextName: \(contextName) \n"
            }
            if hasParallelIterations {
                output += "\(indent) parallelIterations: \(parallelIterations) \n"
            }
            if hasBackProp {
                output += "\(indent) backProp: \(backProp) \n"
            }
            if hasSwapMemory {
                output += "\(indent) swapMemory: \(swapMemory) \n"
            }
            if hasPivotName {
                output += "\(indent) pivotName: \(pivotName) \n"
            }
            if hasPivotForPredName {
                output += "\(indent) pivotForPredName: \(pivotForPredName) \n"
            }
            if hasPivotForBodyName {
                output += "\(indent) pivotForBodyName: \(pivotForBodyName) \n"
            }
            var loopExitNamesElementIndex:Int = 0
            for oneValueLoopExitNames in loopExitNames  {
                output += "\(indent) loopExitNames[\(loopExitNamesElementIndex)]: \(oneValueLoopExitNames)\n"
                loopExitNamesElementIndex += 1
            }
            if hasValuesDef {
                output += "\(indent) valuesDef {\n"
                if let outDescValuesDef = valuesDef {
                    output += try outDescValuesDef.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasContextName {
                    hashCode = (hashCode &* 31) &+ contextName.hashValue
                }
                if hasParallelIterations {
                    hashCode = (hashCode &* 31) &+ parallelIterations.hashValue
                }
                if hasBackProp {
                    hashCode = (hashCode &* 31) &+ backProp.hashValue
                }
                if hasSwapMemory {
                    hashCode = (hashCode &* 31) &+ swapMemory.hashValue
                }
                if hasPivotName {
                    hashCode = (hashCode &* 31) &+ pivotName.hashValue
                }
                if hasPivotForPredName {
                    hashCode = (hashCode &* 31) &+ pivotForPredName.hashValue
                }
                if hasPivotForBodyName {
                    hashCode = (hashCode &* 31) &+ pivotForBodyName.hashValue
                }
                for oneValueLoopExitNames in loopExitNames {
                    hashCode = (hashCode &* 31) &+ oneValueLoopExitNames.hashValue
                }
                if hasValuesDef {
                    if let hashValuevaluesDef = valuesDef?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuevaluesDef
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.WhileContextDef"
        }
        override public func className() -> String {
            return "Tensorflow.WhileContextDef"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.WhileContextDef = Tensorflow.WhileContextDef()
            public func getMessage() -> Tensorflow.WhileContextDef {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Name of the context.
            public var contextName:String {
                get {
                    return builderResult.contextName
                }
                set (value) {
                    builderResult.hasContextName = true
                    builderResult.contextName = value
                }
            }
            public var hasContextName:Bool {
                get {
                    return builderResult.hasContextName
                }
            }
            @discardableResult
            public func setContextName(_ value:String) -> Tensorflow.WhileContextDef.Builder {
                self.contextName = value
                return self
            }
            @discardableResult
            public func clearContextName() -> Tensorflow.WhileContextDef.Builder{
                builderResult.hasContextName = false
                builderResult.contextName = ""
                return self
            }
            /// The number of iterations allowed to run in parallel.
            public var parallelIterations:Int32 {
                get {
                    return builderResult.parallelIterations
                }
                set (value) {
                    builderResult.hasParallelIterations = true
                    builderResult.parallelIterations = value
                }
            }
            public var hasParallelIterations:Bool {
                get {
                    return builderResult.hasParallelIterations
                }
            }
            @discardableResult
            public func setParallelIterations(_ value:Int32) -> Tensorflow.WhileContextDef.Builder {
                self.parallelIterations = value
                return self
            }
            @discardableResult
            public func clearParallelIterations() -> Tensorflow.WhileContextDef.Builder{
                builderResult.hasParallelIterations = false
                builderResult.parallelIterations = Int32(0)
                return self
            }
            /// Whether backprop is enabled for this while loop.
            public var backProp:Bool {
                get {
                    return builderResult.backProp
                }
                set (value) {
                    builderResult.hasBackProp = true
                    builderResult.backProp = value
                }
            }
            public var hasBackProp:Bool {
                get {
                    return builderResult.hasBackProp
                }
            }
            @discardableResult
            public func setBackProp(_ value:Bool) -> Tensorflow.WhileContextDef.Builder {
                self.backProp = value
                return self
            }
            @discardableResult
            public func clearBackProp() -> Tensorflow.WhileContextDef.Builder{
                builderResult.hasBackProp = false
                builderResult.backProp = false
                return self
            }
            /// Whether GPU-CPU memory swap is enabled for this loop.
            public var swapMemory:Bool {
                get {
                    return builderResult.swapMemory
                }
                set (value) {
                    builderResult.hasSwapMemory = true
                    builderResult.swapMemory = value
                }
            }
            public var hasSwapMemory:Bool {
                get {
                    return builderResult.hasSwapMemory
                }
            }
            @discardableResult
            public func setSwapMemory(_ value:Bool) -> Tensorflow.WhileContextDef.Builder {
                self.swapMemory = value
                return self
            }
            @discardableResult
            public func clearSwapMemory() -> Tensorflow.WhileContextDef.Builder{
                builderResult.hasSwapMemory = false
                builderResult.swapMemory = false
                return self
            }
            /// Name of the pivot tensor.
            public var pivotName:String {
                get {
                    return builderResult.pivotName
                }
                set (value) {
                    builderResult.hasPivotName = true
                    builderResult.pivotName = value
                }
            }
            public var hasPivotName:Bool {
                get {
                    return builderResult.hasPivotName
                }
            }
            @discardableResult
            public func setPivotName(_ value:String) -> Tensorflow.WhileContextDef.Builder {
                self.pivotName = value
                return self
            }
            @discardableResult
            public func clearPivotName() -> Tensorflow.WhileContextDef.Builder{
                builderResult.hasPivotName = false
                builderResult.pivotName = ""
                return self
            }
            /// Name of the pivot_for_pred tensor.
            public var pivotForPredName:String {
                get {
                    return builderResult.pivotForPredName
                }
                set (value) {
                    builderResult.hasPivotForPredName = true
                    builderResult.pivotForPredName = value
                }
            }
            public var hasPivotForPredName:Bool {
                get {
                    return builderResult.hasPivotForPredName
                }
            }
            @discardableResult
            public func setPivotForPredName(_ value:String) -> Tensorflow.WhileContextDef.Builder {
                self.pivotForPredName = value
                return self
            }
            @discardableResult
            public func clearPivotForPredName() -> Tensorflow.WhileContextDef.Builder{
                builderResult.hasPivotForPredName = false
                builderResult.pivotForPredName = ""
                return self
            }
            /// Name of the pivot_for_body tensor.
            public var pivotForBodyName:String {
                get {
                    return builderResult.pivotForBodyName
                }
                set (value) {
                    builderResult.hasPivotForBodyName = true
                    builderResult.pivotForBodyName = value
                }
            }
            public var hasPivotForBodyName:Bool {
                get {
                    return builderResult.hasPivotForBodyName
                }
            }
            @discardableResult
            public func setPivotForBodyName(_ value:String) -> Tensorflow.WhileContextDef.Builder {
                self.pivotForBodyName = value
                return self
            }
            @discardableResult
            public func clearPivotForBodyName() -> Tensorflow.WhileContextDef.Builder{
                builderResult.hasPivotForBodyName = false
                builderResult.pivotForBodyName = ""
                return self
            }
            /// List of names for exit tensors.
            public var loopExitNames:Array<String> {
                get {
                    return builderResult.loopExitNames
                }
                set (array) {
                    builderResult.loopExitNames = array
                }
            }
            @discardableResult
            public func setLoopExitNames(_ value:Array<String>) -> Tensorflow.WhileContextDef.Builder {
                self.loopExitNames = value
                return self
            }
            @discardableResult
            public func clearLoopExitNames() -> Tensorflow.WhileContextDef.Builder {
                builderResult.loopExitNames.removeAll(keepingCapacity: false)
                return self
            }
            /// Values and external values in control flow context.
            public var valuesDef:Tensorflow.ValuesDef! {
                get {
                    if valuesDefBuilder_ != nil {
                        builderResult.valuesDef = valuesDefBuilder_.getMessage()
                    }
                    return builderResult.valuesDef
                }
                set (value) {
                    builderResult.hasValuesDef = true
                    builderResult.valuesDef = value
                }
            }
            public var hasValuesDef:Bool {
                get {
                    return builderResult.hasValuesDef
                }
            }
            fileprivate var valuesDefBuilder_:Tensorflow.ValuesDef.Builder! {
                didSet {
                    builderResult.hasValuesDef = true
                }
            }
            public func getValuesDefBuilder() -> Tensorflow.ValuesDef.Builder {
                if valuesDefBuilder_ == nil {
                    valuesDefBuilder_ = Tensorflow.ValuesDef.Builder()
                    builderResult.valuesDef = valuesDefBuilder_.getMessage()
                    if valuesDef != nil {
                        try! valuesDefBuilder_.mergeFrom(other: valuesDef)
                    }
                }
                return valuesDefBuilder_
            }
            @discardableResult
            public func setValuesDef(_ value:Tensorflow.ValuesDef!) -> Tensorflow.WhileContextDef.Builder {
                self.valuesDef = value
                return self
            }
            @discardableResult
            public func mergeValuesDef(value:Tensorflow.ValuesDef) throws -> Tensorflow.WhileContextDef.Builder {
                if builderResult.hasValuesDef {
                    builderResult.valuesDef = try Tensorflow.ValuesDef.builderWithPrototype(prototype:builderResult.valuesDef).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.valuesDef = value
                }
                builderResult.hasValuesDef = true
                return self
            }
            @discardableResult
            public func clearValuesDef() -> Tensorflow.WhileContextDef.Builder {
                valuesDefBuilder_ = nil
                builderResult.hasValuesDef = false
                builderResult.valuesDef = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.WhileContextDef.Builder {
                builderResult = Tensorflow.WhileContextDef()
                return self
            }
            override public func clone() throws -> Tensorflow.WhileContextDef.Builder {
                return try Tensorflow.WhileContextDef.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.WhileContextDef {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.WhileContextDef {
                let returnMe:Tensorflow.WhileContextDef = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.WhileContextDef) throws -> Tensorflow.WhileContextDef.Builder {
                if other == Tensorflow.WhileContextDef() {
                    return self
                }
                if other.hasContextName {
                    contextName = other.contextName
                }
                if other.hasParallelIterations {
                    parallelIterations = other.parallelIterations
                }
                if other.hasBackProp {
                    backProp = other.backProp
                }
                if other.hasSwapMemory {
                    swapMemory = other.swapMemory
                }
                if other.hasPivotName {
                    pivotName = other.pivotName
                }
                if other.hasPivotForPredName {
                    pivotForPredName = other.pivotForPredName
                }
                if other.hasPivotForBodyName {
                    pivotForBodyName = other.pivotForBodyName
                }
                if !other.loopExitNames.isEmpty {
                    builderResult.loopExitNames += other.loopExitNames
                }
                if (other.hasValuesDef) {
                    try mergeValuesDef(value: other.valuesDef)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.WhileContextDef.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.WhileContextDef.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        contextName = try codedInputStream.readString()

                    case 16:
                        parallelIterations = try codedInputStream.readInt32()

                    case 24:
                        backProp = try codedInputStream.readBool()

                    case 32:
                        swapMemory = try codedInputStream.readBool()

                    case 42:
                        pivotName = try codedInputStream.readString()

                    case 50:
                        pivotForPredName = try codedInputStream.readString()

                    case 58:
                        pivotForBodyName = try codedInputStream.readString()

                    case 66:
                        loopExitNames += [try codedInputStream.readString()]

                    case 74:
                        let subBuilder:Tensorflow.ValuesDef.Builder = Tensorflow.ValuesDef.Builder()
                        if hasValuesDef {
                            try subBuilder.mergeFrom(other: valuesDef)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        valuesDef = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.WhileContextDef.Builder {
                let resultDecodedBuilder = Tensorflow.WhileContextDef.Builder()
                if let jsonValueContextName = jsonMap["contextName"] as? String {
                    resultDecodedBuilder.contextName = jsonValueContextName
                }
                if let jsonValueParallelIterations = jsonMap["parallelIterations"] as? Int {
                    resultDecodedBuilder.parallelIterations = Int32(jsonValueParallelIterations)
                } else if let jsonValueParallelIterations = jsonMap["parallelIterations"] as? String {
                    resultDecodedBuilder.parallelIterations = Int32(jsonValueParallelIterations)!
                }
                if let jsonValueBackProp = jsonMap["backProp"] as? Bool {
                    resultDecodedBuilder.backProp = jsonValueBackProp
                }
                if let jsonValueSwapMemory = jsonMap["swapMemory"] as? Bool {
                    resultDecodedBuilder.swapMemory = jsonValueSwapMemory
                }
                if let jsonValuePivotName = jsonMap["pivotName"] as? String {
                    resultDecodedBuilder.pivotName = jsonValuePivotName
                }
                if let jsonValuePivotForPredName = jsonMap["pivotForPredName"] as? String {
                    resultDecodedBuilder.pivotForPredName = jsonValuePivotForPredName
                }
                if let jsonValuePivotForBodyName = jsonMap["pivotForBodyName"] as? String {
                    resultDecodedBuilder.pivotForBodyName = jsonValuePivotForBodyName
                }
                if let jsonValueLoopExitNames = jsonMap["loopExitNames"] as? Array<String> {
                    var jsonArrayLoopExitNames:Array<String> = []
                    for oneValueLoopExitNames in jsonValueLoopExitNames {
                        jsonArrayLoopExitNames.append(oneValueLoopExitNames)
                    }
                    resultDecodedBuilder.loopExitNames = jsonArrayLoopExitNames
                }
                if let jsonValueValuesDef = jsonMap["valuesDef"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.valuesDef = try Tensorflow.ValuesDef.Builder.decodeToBuilder(jsonMap:jsonValueValuesDef).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.WhileContextDef.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.WhileContextDef.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.ValuesDef: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.ValuesDef> {
        var mergedArray = Array<Tensorflow.ValuesDef>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.ValuesDef? {
        return try Tensorflow.ValuesDef.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.ValuesDef {
        return try Tensorflow.ValuesDef.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.ControlFlowRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ValuesDef {
        return try Tensorflow.ValuesDef.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.ValuesDef {
        return try Tensorflow.ValuesDef.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ValuesDef {
        return try Tensorflow.ValuesDef.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.ValuesDef {
        return try Tensorflow.ValuesDef.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ValuesDef {
        return try Tensorflow.ValuesDef.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "values": return self.values
        case "externalValues": return self.externalValues
        default: return nil
        }
    }
}
extension Tensorflow.ValuesDef.ExternalValuesEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.ValuesDef.ExternalValuesEntry> {
        var mergedArray = Array<Tensorflow.ValuesDef.ExternalValuesEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.ValuesDef.ExternalValuesEntry? {
        return try Tensorflow.ValuesDef.ExternalValuesEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.ValuesDef.ExternalValuesEntry {
        return try Tensorflow.ValuesDef.ExternalValuesEntry.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.ControlFlowRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ValuesDef.ExternalValuesEntry {
        return try Tensorflow.ValuesDef.ExternalValuesEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.ValuesDef.ExternalValuesEntry {
        return try Tensorflow.ValuesDef.ExternalValuesEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ValuesDef.ExternalValuesEntry {
        return try Tensorflow.ValuesDef.ExternalValuesEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.ValuesDef.ExternalValuesEntry {
        return try Tensorflow.ValuesDef.ExternalValuesEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ValuesDef.ExternalValuesEntry {
        return try Tensorflow.ValuesDef.ExternalValuesEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.ValuesDef.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "values": return self.values
            case "externalValues": return self.externalValues
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "values":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.values = newSubscriptValue
            case "externalValues":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,String> else {
                    return
                }
                self.externalValues = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.ValuesDef.ExternalValuesEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.CondContextDef: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.CondContextDef> {
        var mergedArray = Array<Tensorflow.CondContextDef>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.CondContextDef? {
        return try Tensorflow.CondContextDef.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.CondContextDef {
        return try Tensorflow.CondContextDef.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.ControlFlowRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CondContextDef {
        return try Tensorflow.CondContextDef.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.CondContextDef {
        return try Tensorflow.CondContextDef.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CondContextDef {
        return try Tensorflow.CondContextDef.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CondContextDef {
        return try Tensorflow.CondContextDef.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CondContextDef {
        return try Tensorflow.CondContextDef.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "contextName": return self.contextName
        case "predName": return self.predName
        case "pivotName": return self.pivotName
        case "branch": return self.branch
        case "valuesDef": return self.valuesDef
        default: return nil
        }
    }
}
extension Tensorflow.CondContextDef.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "contextName": return self.contextName
            case "predName": return self.predName
            case "pivotName": return self.pivotName
            case "branch": return self.branch
            case "valuesDef": return self.valuesDef
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "contextName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.contextName = newSubscriptValue
            case "predName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.predName = newSubscriptValue
            case "pivotName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.pivotName = newSubscriptValue
            case "branch":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.branch = newSubscriptValue
            case "valuesDef":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.ValuesDef else {
                    return
                }
                self.valuesDef = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.WhileContextDef: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.WhileContextDef> {
        var mergedArray = Array<Tensorflow.WhileContextDef>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.WhileContextDef? {
        return try Tensorflow.WhileContextDef.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.WhileContextDef {
        return try Tensorflow.WhileContextDef.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.ControlFlowRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.WhileContextDef {
        return try Tensorflow.WhileContextDef.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.WhileContextDef {
        return try Tensorflow.WhileContextDef.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.WhileContextDef {
        return try Tensorflow.WhileContextDef.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.WhileContextDef {
        return try Tensorflow.WhileContextDef.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.WhileContextDef {
        return try Tensorflow.WhileContextDef.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "contextName": return self.contextName
        case "parallelIterations": return self.parallelIterations
        case "backProp": return self.backProp
        case "swapMemory": return self.swapMemory
        case "pivotName": return self.pivotName
        case "pivotForPredName": return self.pivotForPredName
        case "pivotForBodyName": return self.pivotForBodyName
        case "loopExitNames": return self.loopExitNames
        case "valuesDef": return self.valuesDef
        default: return nil
        }
    }
}
extension Tensorflow.WhileContextDef.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "contextName": return self.contextName
            case "parallelIterations": return self.parallelIterations
            case "backProp": return self.backProp
            case "swapMemory": return self.swapMemory
            case "pivotName": return self.pivotName
            case "pivotForPredName": return self.pivotForPredName
            case "pivotForBodyName": return self.pivotForBodyName
            case "loopExitNames": return self.loopExitNames
            case "valuesDef": return self.valuesDef
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "contextName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.contextName = newSubscriptValue
            case "parallelIterations":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.parallelIterations = newSubscriptValue
            case "backProp":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.backProp = newSubscriptValue
            case "swapMemory":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.swapMemory = newSubscriptValue
            case "pivotName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.pivotName = newSubscriptValue
            case "pivotForPredName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.pivotForPredName = newSubscriptValue
            case "pivotForBodyName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.pivotForBodyName = newSubscriptValue
            case "loopExitNames":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.loopExitNames = newSubscriptValue
            case "valuesDef":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.ValuesDef else {
                    return
                }
                self.valuesDef = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

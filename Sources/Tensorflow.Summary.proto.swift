/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "summary.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { }

public extension Tensorflow {
    public struct SummaryRoot {
        public static let `default` = SummaryRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Tensorflow.TensorRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    /// Metadata associated with a series of Summary data
    final public class SummaryDescription : GeneratedMessage {

        public static func == (lhs: Tensorflow.SummaryDescription, rhs: Tensorflow.SummaryDescription) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasTypeHint == rhs.hasTypeHint) && (!lhs.hasTypeHint || lhs.typeHint == rhs.typeHint)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Hint on how plugins should process the data in this series.
        /// Supported values include "scalar", "histogram", "image", "audio"
        public fileprivate(set) var typeHint:String = ""
        public fileprivate(set) var hasTypeHint:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasTypeHint {
                try codedOutputStream.writeString(fieldNumber: 1, value:typeHint)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasTypeHint {
                serialize_size += typeHint.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.SummaryDescription.Builder {
            return Tensorflow.SummaryDescription.classBuilder() as! Tensorflow.SummaryDescription.Builder
        }
        public func getBuilder() -> Tensorflow.SummaryDescription.Builder {
            return classBuilder() as! Tensorflow.SummaryDescription.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.SummaryDescription.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.SummaryDescription.Builder()
        }
        public func toBuilder() throws -> Tensorflow.SummaryDescription.Builder {
            return try Tensorflow.SummaryDescription.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.SummaryDescription) throws -> Tensorflow.SummaryDescription.Builder {
            return try Tensorflow.SummaryDescription.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasTypeHint {
                jsonMap["typeHint"] = typeHint
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.SummaryDescription {
            return try Tensorflow.SummaryDescription.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.SummaryDescription {
            return try Tensorflow.SummaryDescription.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasTypeHint {
                output += "\(indent) typeHint: \(typeHint) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasTypeHint {
                    hashCode = (hashCode &* 31) &+ typeHint.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.SummaryDescription"
        }
        override public func className() -> String {
            return "Tensorflow.SummaryDescription"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.SummaryDescription = Tensorflow.SummaryDescription()
            public func getMessage() -> Tensorflow.SummaryDescription {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Hint on how plugins should process the data in this series.
            /// Supported values include "scalar", "histogram", "image", "audio"
            public var typeHint:String {
                get {
                    return builderResult.typeHint
                }
                set (value) {
                    builderResult.hasTypeHint = true
                    builderResult.typeHint = value
                }
            }
            public var hasTypeHint:Bool {
                get {
                    return builderResult.hasTypeHint
                }
            }
            @discardableResult
            public func setTypeHint(_ value:String) -> Tensorflow.SummaryDescription.Builder {
                self.typeHint = value
                return self
            }
            @discardableResult
            public func clearTypeHint() -> Tensorflow.SummaryDescription.Builder{
                builderResult.hasTypeHint = false
                builderResult.typeHint = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.SummaryDescription.Builder {
                builderResult = Tensorflow.SummaryDescription()
                return self
            }
            override public func clone() throws -> Tensorflow.SummaryDescription.Builder {
                return try Tensorflow.SummaryDescription.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.SummaryDescription {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.SummaryDescription {
                let returnMe:Tensorflow.SummaryDescription = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.SummaryDescription) throws -> Tensorflow.SummaryDescription.Builder {
                if other == Tensorflow.SummaryDescription() {
                    return self
                }
                if other.hasTypeHint {
                    typeHint = other.typeHint
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.SummaryDescription.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.SummaryDescription.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        typeHint = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.SummaryDescription.Builder {
                let resultDecodedBuilder = Tensorflow.SummaryDescription.Builder()
                if let jsonValueTypeHint = jsonMap["typeHint"] as? String {
                    resultDecodedBuilder.typeHint = jsonValueTypeHint
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.SummaryDescription.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.SummaryDescription.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Serialization format for histogram module in
    /// core/lib/histogram/histogram.h
    final public class HistogramProto : GeneratedMessage {

        public static func == (lhs: Tensorflow.HistogramProto, rhs: Tensorflow.HistogramProto) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasMin == rhs.hasMin) && (!lhs.hasMin || lhs.min == rhs.min)
            fieldCheck = fieldCheck && (lhs.hasMax == rhs.hasMax) && (!lhs.hasMax || lhs.max == rhs.max)
            fieldCheck = fieldCheck && (lhs.hasNum == rhs.hasNum) && (!lhs.hasNum || lhs.num == rhs.num)
            fieldCheck = fieldCheck && (lhs.hasSum == rhs.hasSum) && (!lhs.hasSum || lhs.sum == rhs.sum)
            fieldCheck = fieldCheck && (lhs.hasSumSquares == rhs.hasSumSquares) && (!lhs.hasSumSquares || lhs.sumSquares == rhs.sumSquares)
            fieldCheck = fieldCheck && (lhs.bucketLimit == rhs.bucketLimit)
            fieldCheck = fieldCheck && (lhs.bucket == rhs.bucket)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var min:Double = Double(0)
        public fileprivate(set) var hasMin:Bool = false

        public fileprivate(set) var max:Double = Double(0)
        public fileprivate(set) var hasMax:Bool = false

        public fileprivate(set) var num:Double = Double(0)
        public fileprivate(set) var hasNum:Bool = false

        public fileprivate(set) var sum:Double = Double(0)
        public fileprivate(set) var hasSum:Bool = false

        public fileprivate(set) var sumSquares:Double = Double(0)
        public fileprivate(set) var hasSumSquares:Bool = false

        /// Parallel arrays encoding the bucket boundaries and the bucket values.
        /// bucket(i) is the count for the bucket i.  The range for
        /// a bucket is:
        ///   i == 0:  -DBL_MAX .. bucket_limit(0)
        ///   i != 0:  bucket_limit(i-1) .. bucket_limit(i)
        public fileprivate(set) var bucketLimit:Array<Double> = Array<Double>()
        private var bucketLimitMemoizedSerializedSize:Int32 = -1
        public fileprivate(set) var bucket:Array<Double> = Array<Double>()
        private var bucketMemoizedSerializedSize:Int32 = -1
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasMin {
                try codedOutputStream.writeDouble(fieldNumber: 1, value:min)
            }
            if hasMax {
                try codedOutputStream.writeDouble(fieldNumber: 2, value:max)
            }
            if hasNum {
                try codedOutputStream.writeDouble(fieldNumber: 3, value:num)
            }
            if hasSum {
                try codedOutputStream.writeDouble(fieldNumber: 4, value:sum)
            }
            if hasSumSquares {
                try codedOutputStream.writeDouble(fieldNumber: 5, value:sumSquares)
            }
            if !bucketLimit.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 50)
                try codedOutputStream.writeRawVarint32(value: bucketLimitMemoizedSerializedSize)
                for oneValuebucketLimit in bucketLimit {
                    try codedOutputStream.writeDoubleNoTag(value: oneValuebucketLimit)
                }
            }
            if !bucket.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 58)
                try codedOutputStream.writeRawVarint32(value: bucketMemoizedSerializedSize)
                for oneValuebucket in bucket {
                    try codedOutputStream.writeDoubleNoTag(value: oneValuebucket)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasMin {
                serialize_size += min.computeDoubleSize(fieldNumber: 1)
            }
            if hasMax {
                serialize_size += max.computeDoubleSize(fieldNumber: 2)
            }
            if hasNum {
                serialize_size += num.computeDoubleSize(fieldNumber: 3)
            }
            if hasSum {
                serialize_size += sum.computeDoubleSize(fieldNumber: 4)
            }
            if hasSumSquares {
                serialize_size += sumSquares.computeDoubleSize(fieldNumber: 5)
            }
            var dataSizeBucketLimit:Int32 = 0
            dataSizeBucketLimit = 8 * Int32(bucketLimit.count)
            serialize_size += dataSizeBucketLimit
            if !bucketLimit.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeBucketLimit.computeInt32SizeNoTag()
            }
            bucketLimitMemoizedSerializedSize = dataSizeBucketLimit
            var dataSizeBucket:Int32 = 0
            dataSizeBucket = 8 * Int32(bucket.count)
            serialize_size += dataSizeBucket
            if !bucket.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeBucket.computeInt32SizeNoTag()
            }
            bucketMemoizedSerializedSize = dataSizeBucket
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.HistogramProto.Builder {
            return Tensorflow.HistogramProto.classBuilder() as! Tensorflow.HistogramProto.Builder
        }
        public func getBuilder() -> Tensorflow.HistogramProto.Builder {
            return classBuilder() as! Tensorflow.HistogramProto.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.HistogramProto.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.HistogramProto.Builder()
        }
        public func toBuilder() throws -> Tensorflow.HistogramProto.Builder {
            return try Tensorflow.HistogramProto.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.HistogramProto) throws -> Tensorflow.HistogramProto.Builder {
            return try Tensorflow.HistogramProto.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasMin {
                jsonMap["min"] = Double(min)
            }
            if hasMax {
                jsonMap["max"] = Double(max)
            }
            if hasNum {
                jsonMap["num"] = Double(num)
            }
            if hasSum {
                jsonMap["sum"] = Double(sum)
            }
            if hasSumSquares {
                jsonMap["sumSquares"] = Double(sumSquares)
            }
            if !bucketLimit.isEmpty {
                var jsonArrayBucketLimit:Array<Double> = []
                for oneValueBucketLimit in bucketLimit {
                    jsonArrayBucketLimit.append(Double(oneValueBucketLimit))
                }
                jsonMap["bucketLimit"] = jsonArrayBucketLimit
            }
            if !bucket.isEmpty {
                var jsonArrayBucket:Array<Double> = []
                for oneValueBucket in bucket {
                    jsonArrayBucket.append(Double(oneValueBucket))
                }
                jsonMap["bucket"] = jsonArrayBucket
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.HistogramProto {
            return try Tensorflow.HistogramProto.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.HistogramProto {
            return try Tensorflow.HistogramProto.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasMin {
                output += "\(indent) min: \(min) \n"
            }
            if hasMax {
                output += "\(indent) max: \(max) \n"
            }
            if hasNum {
                output += "\(indent) num: \(num) \n"
            }
            if hasSum {
                output += "\(indent) sum: \(sum) \n"
            }
            if hasSumSquares {
                output += "\(indent) sumSquares: \(sumSquares) \n"
            }
            var bucketLimitElementIndex:Int = 0
            for oneValueBucketLimit in bucketLimit  {
                output += "\(indent) bucketLimit[\(bucketLimitElementIndex)]: \(oneValueBucketLimit)\n"
                bucketLimitElementIndex += 1
            }
            var bucketElementIndex:Int = 0
            for oneValueBucket in bucket  {
                output += "\(indent) bucket[\(bucketElementIndex)]: \(oneValueBucket)\n"
                bucketElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasMin {
                    hashCode = (hashCode &* 31) &+ min.hashValue
                }
                if hasMax {
                    hashCode = (hashCode &* 31) &+ max.hashValue
                }
                if hasNum {
                    hashCode = (hashCode &* 31) &+ num.hashValue
                }
                if hasSum {
                    hashCode = (hashCode &* 31) &+ sum.hashValue
                }
                if hasSumSquares {
                    hashCode = (hashCode &* 31) &+ sumSquares.hashValue
                }
                for oneValueBucketLimit in bucketLimit {
                    hashCode = (hashCode &* 31) &+ oneValueBucketLimit.hashValue
                }
                for oneValueBucket in bucket {
                    hashCode = (hashCode &* 31) &+ oneValueBucket.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.HistogramProto"
        }
        override public func className() -> String {
            return "Tensorflow.HistogramProto"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.HistogramProto = Tensorflow.HistogramProto()
            public func getMessage() -> Tensorflow.HistogramProto {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var min:Double {
                get {
                    return builderResult.min
                }
                set (value) {
                    builderResult.hasMin = true
                    builderResult.min = value
                }
            }
            public var hasMin:Bool {
                get {
                    return builderResult.hasMin
                }
            }
            @discardableResult
            public func setMin(_ value:Double) -> Tensorflow.HistogramProto.Builder {
                self.min = value
                return self
            }
            @discardableResult
            public func clearMin() -> Tensorflow.HistogramProto.Builder{
                builderResult.hasMin = false
                builderResult.min = Double(0)
                return self
            }
            public var max:Double {
                get {
                    return builderResult.max
                }
                set (value) {
                    builderResult.hasMax = true
                    builderResult.max = value
                }
            }
            public var hasMax:Bool {
                get {
                    return builderResult.hasMax
                }
            }
            @discardableResult
            public func setMax(_ value:Double) -> Tensorflow.HistogramProto.Builder {
                self.max = value
                return self
            }
            @discardableResult
            public func clearMax() -> Tensorflow.HistogramProto.Builder{
                builderResult.hasMax = false
                builderResult.max = Double(0)
                return self
            }
            public var num:Double {
                get {
                    return builderResult.num
                }
                set (value) {
                    builderResult.hasNum = true
                    builderResult.num = value
                }
            }
            public var hasNum:Bool {
                get {
                    return builderResult.hasNum
                }
            }
            @discardableResult
            public func setNum(_ value:Double) -> Tensorflow.HistogramProto.Builder {
                self.num = value
                return self
            }
            @discardableResult
            public func clearNum() -> Tensorflow.HistogramProto.Builder{
                builderResult.hasNum = false
                builderResult.num = Double(0)
                return self
            }
            public var sum:Double {
                get {
                    return builderResult.sum
                }
                set (value) {
                    builderResult.hasSum = true
                    builderResult.sum = value
                }
            }
            public var hasSum:Bool {
                get {
                    return builderResult.hasSum
                }
            }
            @discardableResult
            public func setSum(_ value:Double) -> Tensorflow.HistogramProto.Builder {
                self.sum = value
                return self
            }
            @discardableResult
            public func clearSum() -> Tensorflow.HistogramProto.Builder{
                builderResult.hasSum = false
                builderResult.sum = Double(0)
                return self
            }
            public var sumSquares:Double {
                get {
                    return builderResult.sumSquares
                }
                set (value) {
                    builderResult.hasSumSquares = true
                    builderResult.sumSquares = value
                }
            }
            public var hasSumSquares:Bool {
                get {
                    return builderResult.hasSumSquares
                }
            }
            @discardableResult
            public func setSumSquares(_ value:Double) -> Tensorflow.HistogramProto.Builder {
                self.sumSquares = value
                return self
            }
            @discardableResult
            public func clearSumSquares() -> Tensorflow.HistogramProto.Builder{
                builderResult.hasSumSquares = false
                builderResult.sumSquares = Double(0)
                return self
            }
            /// Parallel arrays encoding the bucket boundaries and the bucket values.
            /// bucket(i) is the count for the bucket i.  The range for
            /// a bucket is:
            ///   i == 0:  -DBL_MAX .. bucket_limit(0)
            ///   i != 0:  bucket_limit(i-1) .. bucket_limit(i)
            public var bucketLimit:Array<Double> {
                get {
                    return builderResult.bucketLimit
                }
                set (array) {
                    builderResult.bucketLimit = array
                }
            }
            @discardableResult
            public func setBucketLimit(_ value:Array<Double>) -> Tensorflow.HistogramProto.Builder {
                self.bucketLimit = value
                return self
            }
            @discardableResult
            public func clearBucketLimit() -> Tensorflow.HistogramProto.Builder {
                builderResult.bucketLimit.removeAll(keepingCapacity: false)
                return self
            }
            public var bucket:Array<Double> {
                get {
                    return builderResult.bucket
                }
                set (array) {
                    builderResult.bucket = array
                }
            }
            @discardableResult
            public func setBucket(_ value:Array<Double>) -> Tensorflow.HistogramProto.Builder {
                self.bucket = value
                return self
            }
            @discardableResult
            public func clearBucket() -> Tensorflow.HistogramProto.Builder {
                builderResult.bucket.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.HistogramProto.Builder {
                builderResult = Tensorflow.HistogramProto()
                return self
            }
            override public func clone() throws -> Tensorflow.HistogramProto.Builder {
                return try Tensorflow.HistogramProto.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.HistogramProto {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.HistogramProto {
                let returnMe:Tensorflow.HistogramProto = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.HistogramProto) throws -> Tensorflow.HistogramProto.Builder {
                if other == Tensorflow.HistogramProto() {
                    return self
                }
                if other.hasMin {
                    min = other.min
                }
                if other.hasMax {
                    max = other.max
                }
                if other.hasNum {
                    num = other.num
                }
                if other.hasSum {
                    sum = other.sum
                }
                if other.hasSumSquares {
                    sumSquares = other.sumSquares
                }
                if !other.bucketLimit.isEmpty {
                    builderResult.bucketLimit += other.bucketLimit
                }
                if !other.bucket.isEmpty {
                    builderResult.bucket += other.bucket
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.HistogramProto.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.HistogramProto.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 9:
                        min = try codedInputStream.readDouble()

                    case 17:
                        max = try codedInputStream.readDouble()

                    case 25:
                        num = try codedInputStream.readDouble()

                    case 33:
                        sum = try codedInputStream.readDouble()

                    case 41:
                        sumSquares = try codedInputStream.readDouble()

                    case 50:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.bucketLimit.append(try codedInputStream.readDouble())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 58:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.bucket.append(try codedInputStream.readDouble())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.HistogramProto.Builder {
                let resultDecodedBuilder = Tensorflow.HistogramProto.Builder()
                if let jsonValueMin = jsonMap["min"] as? Double {
                    resultDecodedBuilder.min = Double(jsonValueMin)
                } else if let jsonValueMin = jsonMap["min"] as? String {
                    resultDecodedBuilder.min = Double(jsonValueMin)!
                }
                if let jsonValueMax = jsonMap["max"] as? Double {
                    resultDecodedBuilder.max = Double(jsonValueMax)
                } else if let jsonValueMax = jsonMap["max"] as? String {
                    resultDecodedBuilder.max = Double(jsonValueMax)!
                }
                if let jsonValueNum = jsonMap["num"] as? Double {
                    resultDecodedBuilder.num = Double(jsonValueNum)
                } else if let jsonValueNum = jsonMap["num"] as? String {
                    resultDecodedBuilder.num = Double(jsonValueNum)!
                }
                if let jsonValueSum = jsonMap["sum"] as? Double {
                    resultDecodedBuilder.sum = Double(jsonValueSum)
                } else if let jsonValueSum = jsonMap["sum"] as? String {
                    resultDecodedBuilder.sum = Double(jsonValueSum)!
                }
                if let jsonValueSumSquares = jsonMap["sumSquares"] as? Double {
                    resultDecodedBuilder.sumSquares = Double(jsonValueSumSquares)
                } else if let jsonValueSumSquares = jsonMap["sumSquares"] as? String {
                    resultDecodedBuilder.sumSquares = Double(jsonValueSumSquares)!
                }
                if let jsonValueBucketLimit = jsonMap["bucketLimit"] as? Array<Double> {
                    var jsonArrayBucketLimit:Array<Double> = []
                    for oneValueBucketLimit in jsonValueBucketLimit {
                        jsonArrayBucketLimit.append(Double(oneValueBucketLimit))
                    }
                    resultDecodedBuilder.bucketLimit = jsonArrayBucketLimit
                }
                if let jsonValueBucket = jsonMap["bucket"] as? Array<Double> {
                    var jsonArrayBucket:Array<Double> = []
                    for oneValueBucket in jsonValueBucket {
                        jsonArrayBucket.append(Double(oneValueBucket))
                    }
                    resultDecodedBuilder.bucket = jsonArrayBucket
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.HistogramProto.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.HistogramProto.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// A Summary is a set of named values to be displayed by the
    /// visualizer.
    /// Summaries are produced regularly during training, as controlled by
    /// the "summary_interval_secs" attribute of the training operation.
    /// Summaries are also produced at the end of an evaluation.
    final public class Summary : GeneratedMessage {

        public static func == (lhs: Tensorflow.Summary, rhs: Tensorflow.Summary) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.value == rhs.value)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        final public class Image : GeneratedMessage {

            public static func == (lhs: Tensorflow.Summary.Image, rhs: Tensorflow.Summary.Image) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasHeight == rhs.hasHeight) && (!lhs.hasHeight || lhs.height == rhs.height)
                fieldCheck = fieldCheck && (lhs.hasWidth == rhs.hasWidth) && (!lhs.hasWidth || lhs.width == rhs.width)
                fieldCheck = fieldCheck && (lhs.hasColorspace == rhs.hasColorspace) && (!lhs.hasColorspace || lhs.colorspace == rhs.colorspace)
                fieldCheck = fieldCheck && (lhs.hasEncodedImageString == rhs.hasEncodedImageString) && (!lhs.hasEncodedImageString || lhs.encodedImageString == rhs.encodedImageString)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            /// Dimensions of the image.
            public fileprivate(set) var height:Int32 = Int32(0)
            public fileprivate(set) var hasHeight:Bool = false

            public fileprivate(set) var width:Int32 = Int32(0)
            public fileprivate(set) var hasWidth:Bool = false

            /// Valid colorspace values are
            ///   1 - grayscale
            ///   2 - grayscale + alpha
            ///   3 - RGB
            ///   4 - RGBA
            ///   5 - DIGITAL_YUV
            ///   6 - BGRA
            public fileprivate(set) var colorspace:Int32 = Int32(0)
            public fileprivate(set) var hasColorspace:Bool = false

            /// Image data in encoded format.  All image formats supported by
            /// image_codec::CoderUtil can be stored here.
            public fileprivate(set) var encodedImageString:Data = Data()
            public fileprivate(set) var hasEncodedImageString:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasHeight {
                    try codedOutputStream.writeInt32(fieldNumber: 1, value:height)
                }
                if hasWidth {
                    try codedOutputStream.writeInt32(fieldNumber: 2, value:width)
                }
                if hasColorspace {
                    try codedOutputStream.writeInt32(fieldNumber: 3, value:colorspace)
                }
                if hasEncodedImageString {
                    try codedOutputStream.writeData(fieldNumber: 4, value:encodedImageString)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasHeight {
                    serialize_size += height.computeInt32Size(fieldNumber: 1)
                }
                if hasWidth {
                    serialize_size += width.computeInt32Size(fieldNumber: 2)
                }
                if hasColorspace {
                    serialize_size += colorspace.computeInt32Size(fieldNumber: 3)
                }
                if hasEncodedImageString {
                    serialize_size += encodedImageString.computeDataSize(fieldNumber: 4)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.Summary.Image.Builder {
                return Tensorflow.Summary.Image.classBuilder() as! Tensorflow.Summary.Image.Builder
            }
            public func getBuilder() -> Tensorflow.Summary.Image.Builder {
                return classBuilder() as! Tensorflow.Summary.Image.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.Summary.Image.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.Summary.Image.Builder()
            }
            public func toBuilder() throws -> Tensorflow.Summary.Image.Builder {
                return try Tensorflow.Summary.Image.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.Summary.Image) throws -> Tensorflow.Summary.Image.Builder {
                return try Tensorflow.Summary.Image.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasHeight {
                    jsonMap["height"] = Int(height)
                }
                if hasWidth {
                    jsonMap["width"] = Int(width)
                }
                if hasColorspace {
                    jsonMap["colorspace"] = Int(colorspace)
                }
                if hasEncodedImageString {
                    jsonMap["encodedImageString"] = encodedImageString.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Summary.Image {
                return try Tensorflow.Summary.Image.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.Summary.Image {
                return try Tensorflow.Summary.Image.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasHeight {
                    output += "\(indent) height: \(height) \n"
                }
                if hasWidth {
                    output += "\(indent) width: \(width) \n"
                }
                if hasColorspace {
                    output += "\(indent) colorspace: \(colorspace) \n"
                }
                if hasEncodedImageString {
                    output += "\(indent) encodedImageString: \(encodedImageString) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasHeight {
                        hashCode = (hashCode &* 31) &+ height.hashValue
                    }
                    if hasWidth {
                        hashCode = (hashCode &* 31) &+ width.hashValue
                    }
                    if hasColorspace {
                        hashCode = (hashCode &* 31) &+ colorspace.hashValue
                    }
                    if hasEncodedImageString {
                        hashCode = (hashCode &* 31) &+ encodedImageString.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.Summary.Image"
            }
            override public func className() -> String {
                return "Tensorflow.Summary.Image"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.Summary.Image = Tensorflow.Summary.Image()
                public func getMessage() -> Tensorflow.Summary.Image {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                /// Dimensions of the image.
                public var height:Int32 {
                    get {
                        return builderResult.height
                    }
                    set (value) {
                        builderResult.hasHeight = true
                        builderResult.height = value
                    }
                }
                public var hasHeight:Bool {
                    get {
                        return builderResult.hasHeight
                    }
                }
                @discardableResult
                public func setHeight(_ value:Int32) -> Tensorflow.Summary.Image.Builder {
                    self.height = value
                    return self
                }
                @discardableResult
                public func clearHeight() -> Tensorflow.Summary.Image.Builder{
                    builderResult.hasHeight = false
                    builderResult.height = Int32(0)
                    return self
                }
                public var width:Int32 {
                    get {
                        return builderResult.width
                    }
                    set (value) {
                        builderResult.hasWidth = true
                        builderResult.width = value
                    }
                }
                public var hasWidth:Bool {
                    get {
                        return builderResult.hasWidth
                    }
                }
                @discardableResult
                public func setWidth(_ value:Int32) -> Tensorflow.Summary.Image.Builder {
                    self.width = value
                    return self
                }
                @discardableResult
                public func clearWidth() -> Tensorflow.Summary.Image.Builder{
                    builderResult.hasWidth = false
                    builderResult.width = Int32(0)
                    return self
                }
                /// Valid colorspace values are
                ///   1 - grayscale
                ///   2 - grayscale + alpha
                ///   3 - RGB
                ///   4 - RGBA
                ///   5 - DIGITAL_YUV
                ///   6 - BGRA
                public var colorspace:Int32 {
                    get {
                        return builderResult.colorspace
                    }
                    set (value) {
                        builderResult.hasColorspace = true
                        builderResult.colorspace = value
                    }
                }
                public var hasColorspace:Bool {
                    get {
                        return builderResult.hasColorspace
                    }
                }
                @discardableResult
                public func setColorspace(_ value:Int32) -> Tensorflow.Summary.Image.Builder {
                    self.colorspace = value
                    return self
                }
                @discardableResult
                public func clearColorspace() -> Tensorflow.Summary.Image.Builder{
                    builderResult.hasColorspace = false
                    builderResult.colorspace = Int32(0)
                    return self
                }
                /// Image data in encoded format.  All image formats supported by
                /// image_codec::CoderUtil can be stored here.
                public var encodedImageString:Data {
                    get {
                        return builderResult.encodedImageString
                    }
                    set (value) {
                        builderResult.hasEncodedImageString = true
                        builderResult.encodedImageString = value
                    }
                }
                public var hasEncodedImageString:Bool {
                    get {
                        return builderResult.hasEncodedImageString
                    }
                }
                @discardableResult
                public func setEncodedImageString(_ value:Data) -> Tensorflow.Summary.Image.Builder {
                    self.encodedImageString = value
                    return self
                }
                @discardableResult
                public func clearEncodedImageString() -> Tensorflow.Summary.Image.Builder{
                    builderResult.hasEncodedImageString = false
                    builderResult.encodedImageString = Data()
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.Summary.Image.Builder {
                    builderResult = Tensorflow.Summary.Image()
                    return self
                }
                override public func clone() throws -> Tensorflow.Summary.Image.Builder {
                    return try Tensorflow.Summary.Image.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.Summary.Image {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.Summary.Image {
                    let returnMe:Tensorflow.Summary.Image = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.Summary.Image) throws -> Tensorflow.Summary.Image.Builder {
                    if other == Tensorflow.Summary.Image() {
                        return self
                    }
                    if other.hasHeight {
                        height = other.height
                    }
                    if other.hasWidth {
                        width = other.width
                    }
                    if other.hasColorspace {
                        colorspace = other.colorspace
                    }
                    if other.hasEncodedImageString {
                        encodedImageString = other.encodedImageString
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Summary.Image.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Summary.Image.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 8:
                            height = try codedInputStream.readInt32()

                        case 16:
                            width = try codedInputStream.readInt32()

                        case 24:
                            colorspace = try codedInputStream.readInt32()

                        case 34:
                            encodedImageString = try codedInputStream.readData()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Summary.Image.Builder {
                    let resultDecodedBuilder = Tensorflow.Summary.Image.Builder()
                    if let jsonValueHeight = jsonMap["height"] as? Int {
                        resultDecodedBuilder.height = Int32(jsonValueHeight)
                    } else if let jsonValueHeight = jsonMap["height"] as? String {
                        resultDecodedBuilder.height = Int32(jsonValueHeight)!
                    }
                    if let jsonValueWidth = jsonMap["width"] as? Int {
                        resultDecodedBuilder.width = Int32(jsonValueWidth)
                    } else if let jsonValueWidth = jsonMap["width"] as? String {
                        resultDecodedBuilder.width = Int32(jsonValueWidth)!
                    }
                    if let jsonValueColorspace = jsonMap["colorspace"] as? Int {
                        resultDecodedBuilder.colorspace = Int32(jsonValueColorspace)
                    } else if let jsonValueColorspace = jsonMap["colorspace"] as? String {
                        resultDecodedBuilder.colorspace = Int32(jsonValueColorspace)!
                    }
                    if let jsonValueEncodedImageString = jsonMap["encodedImageString"] as? String {
                        resultDecodedBuilder.encodedImageString = Data(base64Encoded:jsonValueEncodedImageString, options: Data.Base64DecodingOptions(rawValue:0))!
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Summary.Image.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.Summary.Image.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        final public class Audio : GeneratedMessage {

            public static func == (lhs: Tensorflow.Summary.Audio, rhs: Tensorflow.Summary.Audio) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasSampleRate == rhs.hasSampleRate) && (!lhs.hasSampleRate || lhs.sampleRate == rhs.sampleRate)
                fieldCheck = fieldCheck && (lhs.hasNumChannels == rhs.hasNumChannels) && (!lhs.hasNumChannels || lhs.numChannels == rhs.numChannels)
                fieldCheck = fieldCheck && (lhs.hasLengthFrames == rhs.hasLengthFrames) && (!lhs.hasLengthFrames || lhs.lengthFrames == rhs.lengthFrames)
                fieldCheck = fieldCheck && (lhs.hasEncodedAudioString == rhs.hasEncodedAudioString) && (!lhs.hasEncodedAudioString || lhs.encodedAudioString == rhs.encodedAudioString)
                fieldCheck = fieldCheck && (lhs.hasContentType == rhs.hasContentType) && (!lhs.hasContentType || lhs.contentType == rhs.contentType)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            /// Sample rate of the audio in Hz.
            public fileprivate(set) var sampleRate:Float = Float(0)
            public fileprivate(set) var hasSampleRate:Bool = false

            /// Number of channels of audio.
            public fileprivate(set) var numChannels:Int64 = Int64(0)
            public fileprivate(set) var hasNumChannels:Bool = false

            /// Length of the audio in frames (samples per channel).
            public fileprivate(set) var lengthFrames:Int64 = Int64(0)
            public fileprivate(set) var hasLengthFrames:Bool = false

            /// Encoded audio data and its associated RFC 2045 content type (e.g.
            /// "audio/wav").
            public fileprivate(set) var encodedAudioString:Data = Data()
            public fileprivate(set) var hasEncodedAudioString:Bool = false

            public fileprivate(set) var contentType:String = ""
            public fileprivate(set) var hasContentType:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasSampleRate {
                    try codedOutputStream.writeFloat(fieldNumber: 1, value:sampleRate)
                }
                if hasNumChannels {
                    try codedOutputStream.writeInt64(fieldNumber: 2, value:numChannels)
                }
                if hasLengthFrames {
                    try codedOutputStream.writeInt64(fieldNumber: 3, value:lengthFrames)
                }
                if hasEncodedAudioString {
                    try codedOutputStream.writeData(fieldNumber: 4, value:encodedAudioString)
                }
                if hasContentType {
                    try codedOutputStream.writeString(fieldNumber: 5, value:contentType)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasSampleRate {
                    serialize_size += sampleRate.computeFloatSize(fieldNumber: 1)
                }
                if hasNumChannels {
                    serialize_size += numChannels.computeInt64Size(fieldNumber: 2)
                }
                if hasLengthFrames {
                    serialize_size += lengthFrames.computeInt64Size(fieldNumber: 3)
                }
                if hasEncodedAudioString {
                    serialize_size += encodedAudioString.computeDataSize(fieldNumber: 4)
                }
                if hasContentType {
                    serialize_size += contentType.computeStringSize(fieldNumber: 5)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.Summary.Audio.Builder {
                return Tensorflow.Summary.Audio.classBuilder() as! Tensorflow.Summary.Audio.Builder
            }
            public func getBuilder() -> Tensorflow.Summary.Audio.Builder {
                return classBuilder() as! Tensorflow.Summary.Audio.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.Summary.Audio.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.Summary.Audio.Builder()
            }
            public func toBuilder() throws -> Tensorflow.Summary.Audio.Builder {
                return try Tensorflow.Summary.Audio.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.Summary.Audio) throws -> Tensorflow.Summary.Audio.Builder {
                return try Tensorflow.Summary.Audio.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasSampleRate {
                    jsonMap["sampleRate"] = Float(sampleRate)
                }
                if hasNumChannels {
                    jsonMap["numChannels"] = "\(numChannels)"
                }
                if hasLengthFrames {
                    jsonMap["lengthFrames"] = "\(lengthFrames)"
                }
                if hasEncodedAudioString {
                    jsonMap["encodedAudioString"] = encodedAudioString.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
                }
                if hasContentType {
                    jsonMap["contentType"] = contentType
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Summary.Audio {
                return try Tensorflow.Summary.Audio.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.Summary.Audio {
                return try Tensorflow.Summary.Audio.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasSampleRate {
                    output += "\(indent) sampleRate: \(sampleRate) \n"
                }
                if hasNumChannels {
                    output += "\(indent) numChannels: \(numChannels) \n"
                }
                if hasLengthFrames {
                    output += "\(indent) lengthFrames: \(lengthFrames) \n"
                }
                if hasEncodedAudioString {
                    output += "\(indent) encodedAudioString: \(encodedAudioString) \n"
                }
                if hasContentType {
                    output += "\(indent) contentType: \(contentType) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasSampleRate {
                        hashCode = (hashCode &* 31) &+ sampleRate.hashValue
                    }
                    if hasNumChannels {
                        hashCode = (hashCode &* 31) &+ numChannels.hashValue
                    }
                    if hasLengthFrames {
                        hashCode = (hashCode &* 31) &+ lengthFrames.hashValue
                    }
                    if hasEncodedAudioString {
                        hashCode = (hashCode &* 31) &+ encodedAudioString.hashValue
                    }
                    if hasContentType {
                        hashCode = (hashCode &* 31) &+ contentType.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.Summary.Audio"
            }
            override public func className() -> String {
                return "Tensorflow.Summary.Audio"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.Summary.Audio = Tensorflow.Summary.Audio()
                public func getMessage() -> Tensorflow.Summary.Audio {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                /// Sample rate of the audio in Hz.
                public var sampleRate:Float {
                    get {
                        return builderResult.sampleRate
                    }
                    set (value) {
                        builderResult.hasSampleRate = true
                        builderResult.sampleRate = value
                    }
                }
                public var hasSampleRate:Bool {
                    get {
                        return builderResult.hasSampleRate
                    }
                }
                @discardableResult
                public func setSampleRate(_ value:Float) -> Tensorflow.Summary.Audio.Builder {
                    self.sampleRate = value
                    return self
                }
                @discardableResult
                public func clearSampleRate() -> Tensorflow.Summary.Audio.Builder{
                    builderResult.hasSampleRate = false
                    builderResult.sampleRate = Float(0)
                    return self
                }
                /// Number of channels of audio.
                public var numChannels:Int64 {
                    get {
                        return builderResult.numChannels
                    }
                    set (value) {
                        builderResult.hasNumChannels = true
                        builderResult.numChannels = value
                    }
                }
                public var hasNumChannels:Bool {
                    get {
                        return builderResult.hasNumChannels
                    }
                }
                @discardableResult
                public func setNumChannels(_ value:Int64) -> Tensorflow.Summary.Audio.Builder {
                    self.numChannels = value
                    return self
                }
                @discardableResult
                public func clearNumChannels() -> Tensorflow.Summary.Audio.Builder{
                    builderResult.hasNumChannels = false
                    builderResult.numChannels = Int64(0)
                    return self
                }
                /// Length of the audio in frames (samples per channel).
                public var lengthFrames:Int64 {
                    get {
                        return builderResult.lengthFrames
                    }
                    set (value) {
                        builderResult.hasLengthFrames = true
                        builderResult.lengthFrames = value
                    }
                }
                public var hasLengthFrames:Bool {
                    get {
                        return builderResult.hasLengthFrames
                    }
                }
                @discardableResult
                public func setLengthFrames(_ value:Int64) -> Tensorflow.Summary.Audio.Builder {
                    self.lengthFrames = value
                    return self
                }
                @discardableResult
                public func clearLengthFrames() -> Tensorflow.Summary.Audio.Builder{
                    builderResult.hasLengthFrames = false
                    builderResult.lengthFrames = Int64(0)
                    return self
                }
                /// Encoded audio data and its associated RFC 2045 content type (e.g.
                /// "audio/wav").
                public var encodedAudioString:Data {
                    get {
                        return builderResult.encodedAudioString
                    }
                    set (value) {
                        builderResult.hasEncodedAudioString = true
                        builderResult.encodedAudioString = value
                    }
                }
                public var hasEncodedAudioString:Bool {
                    get {
                        return builderResult.hasEncodedAudioString
                    }
                }
                @discardableResult
                public func setEncodedAudioString(_ value:Data) -> Tensorflow.Summary.Audio.Builder {
                    self.encodedAudioString = value
                    return self
                }
                @discardableResult
                public func clearEncodedAudioString() -> Tensorflow.Summary.Audio.Builder{
                    builderResult.hasEncodedAudioString = false
                    builderResult.encodedAudioString = Data()
                    return self
                }
                public var contentType:String {
                    get {
                        return builderResult.contentType
                    }
                    set (value) {
                        builderResult.hasContentType = true
                        builderResult.contentType = value
                    }
                }
                public var hasContentType:Bool {
                    get {
                        return builderResult.hasContentType
                    }
                }
                @discardableResult
                public func setContentType(_ value:String) -> Tensorflow.Summary.Audio.Builder {
                    self.contentType = value
                    return self
                }
                @discardableResult
                public func clearContentType() -> Tensorflow.Summary.Audio.Builder{
                    builderResult.hasContentType = false
                    builderResult.contentType = ""
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.Summary.Audio.Builder {
                    builderResult = Tensorflow.Summary.Audio()
                    return self
                }
                override public func clone() throws -> Tensorflow.Summary.Audio.Builder {
                    return try Tensorflow.Summary.Audio.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.Summary.Audio {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.Summary.Audio {
                    let returnMe:Tensorflow.Summary.Audio = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.Summary.Audio) throws -> Tensorflow.Summary.Audio.Builder {
                    if other == Tensorflow.Summary.Audio() {
                        return self
                    }
                    if other.hasSampleRate {
                        sampleRate = other.sampleRate
                    }
                    if other.hasNumChannels {
                        numChannels = other.numChannels
                    }
                    if other.hasLengthFrames {
                        lengthFrames = other.lengthFrames
                    }
                    if other.hasEncodedAudioString {
                        encodedAudioString = other.encodedAudioString
                    }
                    if other.hasContentType {
                        contentType = other.contentType
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Summary.Audio.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Summary.Audio.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 13:
                            sampleRate = try codedInputStream.readFloat()

                        case 16:
                            numChannels = try codedInputStream.readInt64()

                        case 24:
                            lengthFrames = try codedInputStream.readInt64()

                        case 34:
                            encodedAudioString = try codedInputStream.readData()

                        case 42:
                            contentType = try codedInputStream.readString()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Summary.Audio.Builder {
                    let resultDecodedBuilder = Tensorflow.Summary.Audio.Builder()
                    if let jsonValueSampleRate = jsonMap["sampleRate"] as? Float {
                        resultDecodedBuilder.sampleRate = Float(jsonValueSampleRate)
                    } else if let jsonValueSampleRate = jsonMap["sampleRate"] as? String {
                        resultDecodedBuilder.sampleRate = Float(jsonValueSampleRate)!
                    }
                    if let jsonValueNumChannels = jsonMap["numChannels"] as? String {
                        resultDecodedBuilder.numChannels = Int64(jsonValueNumChannels)!
                    } else if let jsonValueNumChannels = jsonMap["numChannels"] as? Int {
                        resultDecodedBuilder.numChannels = Int64(jsonValueNumChannels)
                    }
                    if let jsonValueLengthFrames = jsonMap["lengthFrames"] as? String {
                        resultDecodedBuilder.lengthFrames = Int64(jsonValueLengthFrames)!
                    } else if let jsonValueLengthFrames = jsonMap["lengthFrames"] as? Int {
                        resultDecodedBuilder.lengthFrames = Int64(jsonValueLengthFrames)
                    }
                    if let jsonValueEncodedAudioString = jsonMap["encodedAudioString"] as? String {
                        resultDecodedBuilder.encodedAudioString = Data(base64Encoded:jsonValueEncodedAudioString, options: Data.Base64DecodingOptions(rawValue:0))!
                    }
                    if let jsonValueContentType = jsonMap["contentType"] as? String {
                        resultDecodedBuilder.contentType = jsonValueContentType
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Summary.Audio.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.Summary.Audio.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        final public class Value : GeneratedMessage {

            public static func == (lhs: Tensorflow.Summary.Value, rhs: Tensorflow.Summary.Value) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasTag == rhs.hasTag) && (!lhs.hasTag || lhs.tag == rhs.tag)
                fieldCheck = fieldCheck && (lhs.hasSimpleValue == rhs.hasSimpleValue) && (!lhs.hasSimpleValue || lhs.simpleValue == rhs.simpleValue)
                fieldCheck = fieldCheck && (lhs.hasObsoleteOldStyleHistogram == rhs.hasObsoleteOldStyleHistogram) && (!lhs.hasObsoleteOldStyleHistogram || lhs.obsoleteOldStyleHistogram == rhs.obsoleteOldStyleHistogram)
                fieldCheck = fieldCheck && (lhs.hasImage == rhs.hasImage) && (!lhs.hasImage || lhs.image == rhs.image)
                fieldCheck = fieldCheck && (lhs.hasHisto == rhs.hasHisto) && (!lhs.hasHisto || lhs.histo == rhs.histo)
                fieldCheck = fieldCheck && (lhs.hasAudio == rhs.hasAudio) && (!lhs.hasAudio || lhs.audio == rhs.audio)
                fieldCheck = fieldCheck && (lhs.hasNodeName == rhs.hasNodeName) && (!lhs.hasNodeName || lhs.nodeName == rhs.nodeName)
                fieldCheck = fieldCheck && (lhs.hasTensor == rhs.hasTensor) && (!lhs.hasTensor || lhs.tensor == rhs.tensor)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }



            //OneOf declaration start

            /// Value associated with the tag.
            public enum Value {
                case OneOfValueNotSet

                public func checkOneOfIsSet() -> Bool {
                    switch self {
                    case .OneOfValueNotSet: return false
                    default: return true
                    }
                }
                case SimpleValue(Float)

                public static func getSimpleValue(_ value:Value) -> Float? {
                    switch value {
                    case .SimpleValue(let enumValue): return enumValue
                    default: return nil
                    }
                }
                case ObsoleteOldStyleHistogram(Data)

                public static func getObsoleteOldStyleHistogram(_ value:Value) -> Data? {
                    switch value {
                    case .ObsoleteOldStyleHistogram(let enumValue): return enumValue
                    default: return nil
                    }
                }
                case Image(Tensorflow.Summary.Image)

                public static func getImage(_ value:Value) -> Tensorflow.Summary.Image? {
                    switch value {
                    case .Image(let enumValue):
                        return enumValue
                        default: return nil
                    }
                }
                case Histo(Tensorflow.HistogramProto)

                public static func getHisto(_ value:Value) -> Tensorflow.HistogramProto? {
                    switch value {
                    case .Histo(let enumValue):
                        return enumValue
                        default: return nil
                    }
                }
                case Audio(Tensorflow.Summary.Audio)

                public static func getAudio(_ value:Value) -> Tensorflow.Summary.Audio? {
                    switch value {
                    case .Audio(let enumValue):
                        return enumValue
                        default: return nil
                    }
                }
                case Tensor(Tensorflow.TensorProto)

                public static func getTensor(_ value:Value) -> Tensorflow.TensorProto? {
                    switch value {
                    case .Tensor(let enumValue):
                        return enumValue
                        default: return nil
                    }
                }
            }
            //OneOf declaration end

            fileprivate var storageValue:Summary.Value.Value =  Summary.Value.Value.OneOfValueNotSet
            public func getOneOfValue() ->  Summary.Value.Value {
                let copyObjectValue = storageValue
                return copyObjectValue
            }
            /// Name of the node that output this summary; in general, the name of a
            /// TensorSummary node. If the node in question has multiple outputs, then
            /// a ":\d+" suffix will be appended, like "some_op:13".
            /// Might not be set for legacy summaries (i.e. those not using the tensor
            /// value field)
            public fileprivate(set) var nodeName:String = ""
            public fileprivate(set) var hasNodeName:Bool = false

            /// Tag name for the data.  Will only be used by legacy summaries
            /// (ie. those not using the tensor value field)
            /// For legacy summaries, will be used as the title of the graph
            /// in the visualizer.
            /// Tag is usually "op_name:value_name", where "op_name" itself can have
            /// structure to indicate grouping.
            public fileprivate(set) var tag:String = ""
            public fileprivate(set) var hasTag:Bool = false

            public fileprivate(set) var simpleValue:Float!{
                get {
                    return Summary.Value.Value.getSimpleValue(storageValue)
                }
                set (newvalue) {
                    storageValue = Summary.Value.Value.SimpleValue(newvalue)
                }
            }
            public fileprivate(set) var hasSimpleValue:Bool {
                get {
                    guard let _ = Summary.Value.Value.getSimpleValue(storageValue) else {
                        return false
                    }
                    return true
                }
                set(newValue) {
                }
            }
            public fileprivate(set) var obsoleteOldStyleHistogram:Data!{
                get {
                    return Summary.Value.Value.getObsoleteOldStyleHistogram(storageValue)
                }
                set (newvalue) {
                    storageValue = Summary.Value.Value.ObsoleteOldStyleHistogram(newvalue)
                }
            }
            public fileprivate(set) var hasObsoleteOldStyleHistogram:Bool {
                get {
                    guard let _ = Summary.Value.Value.getObsoleteOldStyleHistogram(storageValue) else {
                        return false
                    }
                    return true
                }
                set(newValue) {
                }
            }
            public fileprivate(set) var image:Tensorflow.Summary.Image!{
                get {
                    return Summary.Value.Value.getImage(storageValue)
                }
                set (newvalue) {
                    storageValue = Summary.Value.Value.Image(newvalue)
                }
            }
            public fileprivate(set) var hasImage:Bool {
                get {
                    guard let _ = Summary.Value.Value.getImage(storageValue) else {
                        return false
                    }
                    return true
                }
                set(newValue) {
                }
            }
            public fileprivate(set) var histo:Tensorflow.HistogramProto!{
                get {
                    return Summary.Value.Value.getHisto(storageValue)
                }
                set (newvalue) {
                    storageValue = Summary.Value.Value.Histo(newvalue)
                }
            }
            public fileprivate(set) var hasHisto:Bool {
                get {
                    guard let _ = Summary.Value.Value.getHisto(storageValue) else {
                        return false
                    }
                    return true
                }
                set(newValue) {
                }
            }
            public fileprivate(set) var audio:Tensorflow.Summary.Audio!{
                get {
                    return Summary.Value.Value.getAudio(storageValue)
                }
                set (newvalue) {
                    storageValue = Summary.Value.Value.Audio(newvalue)
                }
            }
            public fileprivate(set) var hasAudio:Bool {
                get {
                    guard let _ = Summary.Value.Value.getAudio(storageValue) else {
                        return false
                    }
                    return true
                }
                set(newValue) {
                }
            }
            public fileprivate(set) var tensor:Tensorflow.TensorProto!{
                get {
                    return Summary.Value.Value.getTensor(storageValue)
                }
                set (newvalue) {
                    storageValue = Summary.Value.Value.Tensor(newvalue)
                }
            }
            public fileprivate(set) var hasTensor:Bool {
                get {
                    guard let _ = Summary.Value.Value.getTensor(storageValue) else {
                        return false
                    }
                    return true
                }
                set(newValue) {
                }
            }
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasTag {
                    try codedOutputStream.writeString(fieldNumber: 1, value:tag)
                }
                if hasSimpleValue {
                    try codedOutputStream.writeFloat(fieldNumber: 2, value:simpleValue)
                }
                if hasObsoleteOldStyleHistogram {
                    try codedOutputStream.writeData(fieldNumber: 3, value:obsoleteOldStyleHistogram)
                }
                if hasImage {
                    try codedOutputStream.writeMessage(fieldNumber: 4, value:image)
                }
                if hasHisto {
                    try codedOutputStream.writeMessage(fieldNumber: 5, value:histo)
                }
                if hasAudio {
                    try codedOutputStream.writeMessage(fieldNumber: 6, value:audio)
                }
                if hasNodeName {
                    try codedOutputStream.writeString(fieldNumber: 7, value:nodeName)
                }
                if hasTensor {
                    try codedOutputStream.writeMessage(fieldNumber: 8, value:tensor)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasTag {
                    serialize_size += tag.computeStringSize(fieldNumber: 1)
                }
                if hasSimpleValue {
                    serialize_size += simpleValue.computeFloatSize(fieldNumber: 2)
                }
                if hasObsoleteOldStyleHistogram {
                    serialize_size += obsoleteOldStyleHistogram.computeDataSize(fieldNumber: 3)
                }
                if hasImage {
                    if let varSizeimage = image?.computeMessageSize(fieldNumber: 4) {
                        serialize_size += varSizeimage
                    }
                }
                if hasHisto {
                    if let varSizehisto = histo?.computeMessageSize(fieldNumber: 5) {
                        serialize_size += varSizehisto
                    }
                }
                if hasAudio {
                    if let varSizeaudio = audio?.computeMessageSize(fieldNumber: 6) {
                        serialize_size += varSizeaudio
                    }
                }
                if hasNodeName {
                    serialize_size += nodeName.computeStringSize(fieldNumber: 7)
                }
                if hasTensor {
                    if let varSizetensor = tensor?.computeMessageSize(fieldNumber: 8) {
                        serialize_size += varSizetensor
                    }
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.Summary.Value.Builder {
                return Tensorflow.Summary.Value.classBuilder() as! Tensorflow.Summary.Value.Builder
            }
            public func getBuilder() -> Tensorflow.Summary.Value.Builder {
                return classBuilder() as! Tensorflow.Summary.Value.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.Summary.Value.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.Summary.Value.Builder()
            }
            public func toBuilder() throws -> Tensorflow.Summary.Value.Builder {
                return try Tensorflow.Summary.Value.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.Summary.Value) throws -> Tensorflow.Summary.Value.Builder {
                return try Tensorflow.Summary.Value.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasNodeName {
                    jsonMap["nodeName"] = nodeName
                }
                if hasTag {
                    jsonMap["tag"] = tag
                }
                if hasSimpleValue {
                    jsonMap["simpleValue"] = Float(simpleValue)
                }
                if hasObsoleteOldStyleHistogram {
                    jsonMap["obsoleteOldStyleHistogram"] = obsoleteOldStyleHistogram.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
                }
                if hasImage {
                    jsonMap["image"] = try image.encode()
                }
                if hasHisto {
                    jsonMap["histo"] = try histo.encode()
                }
                if hasAudio {
                    jsonMap["audio"] = try audio.encode()
                }
                if hasTensor {
                    jsonMap["tensor"] = try tensor.encode()
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Summary.Value {
                return try Tensorflow.Summary.Value.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.Summary.Value {
                return try Tensorflow.Summary.Value.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasTag {
                    output += "\(indent) tag: \(tag) \n"
                }
                if hasSimpleValue {
                    output += "\(indent) simpleValue: \(simpleValue) \n"
                }
                if hasObsoleteOldStyleHistogram {
                    output += "\(indent) obsoleteOldStyleHistogram: \(obsoleteOldStyleHistogram) \n"
                }
                if hasImage {
                    output += "\(indent) image {\n"
                    if let outDescImage = image {
                        output += try outDescImage.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                if hasHisto {
                    output += "\(indent) histo {\n"
                    if let outDescHisto = histo {
                        output += try outDescHisto.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                if hasAudio {
                    output += "\(indent) audio {\n"
                    if let outDescAudio = audio {
                        output += try outDescAudio.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                if hasNodeName {
                    output += "\(indent) nodeName: \(nodeName) \n"
                }
                if hasTensor {
                    output += "\(indent) tensor {\n"
                    if let outDescTensor = tensor {
                        output += try outDescTensor.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasTag {
                        hashCode = (hashCode &* 31) &+ tag.hashValue
                    }
                    if hasSimpleValue {
                        hashCode = (hashCode &* 31) &+ simpleValue.hashValue
                    }
                    if hasObsoleteOldStyleHistogram {
                        hashCode = (hashCode &* 31) &+ obsoleteOldStyleHistogram.hashValue
                    }
                    if hasImage {
                        if let hashValueimage = image?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValueimage
                        }
                    }
                    if hasHisto {
                        if let hashValuehisto = histo?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuehisto
                        }
                    }
                    if hasAudio {
                        if let hashValueaudio = audio?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValueaudio
                        }
                    }
                    if hasNodeName {
                        hashCode = (hashCode &* 31) &+ nodeName.hashValue
                    }
                    if hasTensor {
                        if let hashValuetensor = tensor?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuetensor
                        }
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.Summary.Value"
            }
            override public func className() -> String {
                return "Tensorflow.Summary.Value"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.Summary.Value = Tensorflow.Summary.Value()
                public func getMessage() -> Tensorflow.Summary.Value {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                /// Name of the node that output this summary; in general, the name of a
                /// TensorSummary node. If the node in question has multiple outputs, then
                /// a ":\d+" suffix will be appended, like "some_op:13".
                /// Might not be set for legacy summaries (i.e. those not using the tensor
                /// value field)
                public var nodeName:String {
                    get {
                        return builderResult.nodeName
                    }
                    set (value) {
                        builderResult.hasNodeName = true
                        builderResult.nodeName = value
                    }
                }
                public var hasNodeName:Bool {
                    get {
                        return builderResult.hasNodeName
                    }
                }
                @discardableResult
                public func setNodeName(_ value:String) -> Tensorflow.Summary.Value.Builder {
                    self.nodeName = value
                    return self
                }
                @discardableResult
                public func clearNodeName() -> Tensorflow.Summary.Value.Builder{
                    builderResult.hasNodeName = false
                    builderResult.nodeName = ""
                    return self
                }
                /// Tag name for the data.  Will only be used by legacy summaries
                /// (ie. those not using the tensor value field)
                /// For legacy summaries, will be used as the title of the graph
                /// in the visualizer.
                /// Tag is usually "op_name:value_name", where "op_name" itself can have
                /// structure to indicate grouping.
                public var tag:String {
                    get {
                        return builderResult.tag
                    }
                    set (value) {
                        builderResult.hasTag = true
                        builderResult.tag = value
                    }
                }
                public var hasTag:Bool {
                    get {
                        return builderResult.hasTag
                    }
                }
                @discardableResult
                public func setTag(_ value:String) -> Tensorflow.Summary.Value.Builder {
                    self.tag = value
                    return self
                }
                @discardableResult
                public func clearTag() -> Tensorflow.Summary.Value.Builder{
                    builderResult.hasTag = false
                    builderResult.tag = ""
                    return self
                }
                public var simpleValue:Float {
                    get {
                        return builderResult.simpleValue
                    }
                    set (value) {
                        builderResult.hasSimpleValue = true
                        builderResult.simpleValue = value
                    }
                }
                public var hasSimpleValue:Bool {
                    get {
                        return builderResult.hasSimpleValue
                    }
                }
                @discardableResult
                public func setSimpleValue(_ value:Float) -> Tensorflow.Summary.Value.Builder {
                    self.simpleValue = value
                    return self
                }
                @discardableResult
                public func clearSimpleValue() -> Tensorflow.Summary.Value.Builder{
                    builderResult.hasSimpleValue = false
                    builderResult.simpleValue = Float(0)
                    return self
                }
                public var obsoleteOldStyleHistogram:Data {
                    get {
                        return builderResult.obsoleteOldStyleHistogram
                    }
                    set (value) {
                        builderResult.hasObsoleteOldStyleHistogram = true
                        builderResult.obsoleteOldStyleHistogram = value
                    }
                }
                public var hasObsoleteOldStyleHistogram:Bool {
                    get {
                        return builderResult.hasObsoleteOldStyleHistogram
                    }
                }
                @discardableResult
                public func setObsoleteOldStyleHistogram(_ value:Data) -> Tensorflow.Summary.Value.Builder {
                    self.obsoleteOldStyleHistogram = value
                    return self
                }
                @discardableResult
                public func clearObsoleteOldStyleHistogram() -> Tensorflow.Summary.Value.Builder{
                    builderResult.hasObsoleteOldStyleHistogram = false
                    builderResult.obsoleteOldStyleHistogram = Data()
                    return self
                }
                public var image:Tensorflow.Summary.Image! {
                    get {
                        if imageBuilder_ != nil {
                            builderResult.image = imageBuilder_.getMessage()
                        }
                        return builderResult.image
                    }
                    set (value) {
                        builderResult.hasImage = true
                        builderResult.image = value
                    }
                }
                public var hasImage:Bool {
                    get {
                        return builderResult.hasImage
                    }
                }
                fileprivate var imageBuilder_:Tensorflow.Summary.Image.Builder! {
                    didSet {
                        builderResult.hasImage = true
                    }
                }
                public func getImageBuilder() -> Tensorflow.Summary.Image.Builder {
                    if imageBuilder_ == nil {
                        imageBuilder_ = Tensorflow.Summary.Image.Builder()
                        builderResult.image = imageBuilder_.getMessage()
                        if image != nil {
                            try! imageBuilder_.mergeFrom(other: image)
                        }
                    }
                    return imageBuilder_
                }
                @discardableResult
                public func setImage(_ value:Tensorflow.Summary.Image!) -> Tensorflow.Summary.Value.Builder {
                    self.image = value
                    return self
                }
                @discardableResult
                public func mergeImage(value:Tensorflow.Summary.Image) throws -> Tensorflow.Summary.Value.Builder {
                    if builderResult.hasImage {
                        builderResult.image = try Tensorflow.Summary.Image.builderWithPrototype(prototype:builderResult.image).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.image = value
                    }
                    builderResult.hasImage = true
                    return self
                }
                @discardableResult
                public func clearImage() -> Tensorflow.Summary.Value.Builder {
                    imageBuilder_ = nil
                    builderResult.hasImage = false
                    builderResult.image = nil
                    return self
                }
                public var histo:Tensorflow.HistogramProto! {
                    get {
                        if histoBuilder_ != nil {
                            builderResult.histo = histoBuilder_.getMessage()
                        }
                        return builderResult.histo
                    }
                    set (value) {
                        builderResult.hasHisto = true
                        builderResult.histo = value
                    }
                }
                public var hasHisto:Bool {
                    get {
                        return builderResult.hasHisto
                    }
                }
                fileprivate var histoBuilder_:Tensorflow.HistogramProto.Builder! {
                    didSet {
                        builderResult.hasHisto = true
                    }
                }
                public func getHistoBuilder() -> Tensorflow.HistogramProto.Builder {
                    if histoBuilder_ == nil {
                        histoBuilder_ = Tensorflow.HistogramProto.Builder()
                        builderResult.histo = histoBuilder_.getMessage()
                        if histo != nil {
                            try! histoBuilder_.mergeFrom(other: histo)
                        }
                    }
                    return histoBuilder_
                }
                @discardableResult
                public func setHisto(_ value:Tensorflow.HistogramProto!) -> Tensorflow.Summary.Value.Builder {
                    self.histo = value
                    return self
                }
                @discardableResult
                public func mergeHisto(value:Tensorflow.HistogramProto) throws -> Tensorflow.Summary.Value.Builder {
                    if builderResult.hasHisto {
                        builderResult.histo = try Tensorflow.HistogramProto.builderWithPrototype(prototype:builderResult.histo).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.histo = value
                    }
                    builderResult.hasHisto = true
                    return self
                }
                @discardableResult
                public func clearHisto() -> Tensorflow.Summary.Value.Builder {
                    histoBuilder_ = nil
                    builderResult.hasHisto = false
                    builderResult.histo = nil
                    return self
                }
                public var audio:Tensorflow.Summary.Audio! {
                    get {
                        if audioBuilder_ != nil {
                            builderResult.audio = audioBuilder_.getMessage()
                        }
                        return builderResult.audio
                    }
                    set (value) {
                        builderResult.hasAudio = true
                        builderResult.audio = value
                    }
                }
                public var hasAudio:Bool {
                    get {
                        return builderResult.hasAudio
                    }
                }
                fileprivate var audioBuilder_:Tensorflow.Summary.Audio.Builder! {
                    didSet {
                        builderResult.hasAudio = true
                    }
                }
                public func getAudioBuilder() -> Tensorflow.Summary.Audio.Builder {
                    if audioBuilder_ == nil {
                        audioBuilder_ = Tensorflow.Summary.Audio.Builder()
                        builderResult.audio = audioBuilder_.getMessage()
                        if audio != nil {
                            try! audioBuilder_.mergeFrom(other: audio)
                        }
                    }
                    return audioBuilder_
                }
                @discardableResult
                public func setAudio(_ value:Tensorflow.Summary.Audio!) -> Tensorflow.Summary.Value.Builder {
                    self.audio = value
                    return self
                }
                @discardableResult
                public func mergeAudio(value:Tensorflow.Summary.Audio) throws -> Tensorflow.Summary.Value.Builder {
                    if builderResult.hasAudio {
                        builderResult.audio = try Tensorflow.Summary.Audio.builderWithPrototype(prototype:builderResult.audio).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.audio = value
                    }
                    builderResult.hasAudio = true
                    return self
                }
                @discardableResult
                public func clearAudio() -> Tensorflow.Summary.Value.Builder {
                    audioBuilder_ = nil
                    builderResult.hasAudio = false
                    builderResult.audio = nil
                    return self
                }
                public var tensor:Tensorflow.TensorProto! {
                    get {
                        if tensorBuilder_ != nil {
                            builderResult.tensor = tensorBuilder_.getMessage()
                        }
                        return builderResult.tensor
                    }
                    set (value) {
                        builderResult.hasTensor = true
                        builderResult.tensor = value
                    }
                }
                public var hasTensor:Bool {
                    get {
                        return builderResult.hasTensor
                    }
                }
                fileprivate var tensorBuilder_:Tensorflow.TensorProto.Builder! {
                    didSet {
                        builderResult.hasTensor = true
                    }
                }
                public func getTensorBuilder() -> Tensorflow.TensorProto.Builder {
                    if tensorBuilder_ == nil {
                        tensorBuilder_ = Tensorflow.TensorProto.Builder()
                        builderResult.tensor = tensorBuilder_.getMessage()
                        if tensor != nil {
                            try! tensorBuilder_.mergeFrom(other: tensor)
                        }
                    }
                    return tensorBuilder_
                }
                @discardableResult
                public func setTensor(_ value:Tensorflow.TensorProto!) -> Tensorflow.Summary.Value.Builder {
                    self.tensor = value
                    return self
                }
                @discardableResult
                public func mergeTensor(value:Tensorflow.TensorProto) throws -> Tensorflow.Summary.Value.Builder {
                    if builderResult.hasTensor {
                        builderResult.tensor = try Tensorflow.TensorProto.builderWithPrototype(prototype:builderResult.tensor).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.tensor = value
                    }
                    builderResult.hasTensor = true
                    return self
                }
                @discardableResult
                public func clearTensor() -> Tensorflow.Summary.Value.Builder {
                    tensorBuilder_ = nil
                    builderResult.hasTensor = false
                    builderResult.tensor = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.Summary.Value.Builder {
                    builderResult = Tensorflow.Summary.Value()
                    return self
                }
                override public func clone() throws -> Tensorflow.Summary.Value.Builder {
                    return try Tensorflow.Summary.Value.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.Summary.Value {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.Summary.Value {
                    let returnMe:Tensorflow.Summary.Value = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.Summary.Value) throws -> Tensorflow.Summary.Value.Builder {
                    if other == Tensorflow.Summary.Value() {
                        return self
                    }
                    if other.hasNodeName {
                        nodeName = other.nodeName
                    }
                    if other.hasTag {
                        tag = other.tag
                    }
                    if other.hasSimpleValue {
                        simpleValue = other.simpleValue
                    }
                    if other.hasObsoleteOldStyleHistogram {
                        obsoleteOldStyleHistogram = other.obsoleteOldStyleHistogram
                    }
                    if (other.hasImage) {
                        try mergeImage(value: other.image)
                    }
                    if (other.hasHisto) {
                        try mergeHisto(value: other.histo)
                    }
                    if (other.hasAudio) {
                        try mergeAudio(value: other.audio)
                    }
                    if (other.hasTensor) {
                        try mergeTensor(value: other.tensor)
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Summary.Value.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Summary.Value.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            tag = try codedInputStream.readString()

                        case 21:
                            simpleValue = try codedInputStream.readFloat()

                        case 26:
                            obsoleteOldStyleHistogram = try codedInputStream.readData()

                        case 34:
                            let subBuilder:Tensorflow.Summary.Image.Builder = Tensorflow.Summary.Image.Builder()
                            if hasImage {
                                try subBuilder.mergeFrom(other: image)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            image = subBuilder.buildPartial()

                        case 42:
                            let subBuilder:Tensorflow.HistogramProto.Builder = Tensorflow.HistogramProto.Builder()
                            if hasHisto {
                                try subBuilder.mergeFrom(other: histo)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            histo = subBuilder.buildPartial()

                        case 50:
                            let subBuilder:Tensorflow.Summary.Audio.Builder = Tensorflow.Summary.Audio.Builder()
                            if hasAudio {
                                try subBuilder.mergeFrom(other: audio)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            audio = subBuilder.buildPartial()

                        case 58:
                            nodeName = try codedInputStream.readString()

                        case 66:
                            let subBuilder:Tensorflow.TensorProto.Builder = Tensorflow.TensorProto.Builder()
                            if hasTensor {
                                try subBuilder.mergeFrom(other: tensor)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            tensor = subBuilder.buildPartial()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Summary.Value.Builder {
                    let resultDecodedBuilder = Tensorflow.Summary.Value.Builder()
                    if let jsonValueNodeName = jsonMap["nodeName"] as? String {
                        resultDecodedBuilder.nodeName = jsonValueNodeName
                    }
                    if let jsonValueTag = jsonMap["tag"] as? String {
                        resultDecodedBuilder.tag = jsonValueTag
                    }
                    if let jsonValueSimpleValue = jsonMap["simpleValue"] as? Float {
                        resultDecodedBuilder.simpleValue = Float(jsonValueSimpleValue)
                    } else if let jsonValueSimpleValue = jsonMap["simpleValue"] as? String {
                        resultDecodedBuilder.simpleValue = Float(jsonValueSimpleValue)!
                    }
                    if let jsonValueObsoleteOldStyleHistogram = jsonMap["obsoleteOldStyleHistogram"] as? String {
                        resultDecodedBuilder.obsoleteOldStyleHistogram = Data(base64Encoded:jsonValueObsoleteOldStyleHistogram, options: Data.Base64DecodingOptions(rawValue:0))!
                    }
                    if let jsonValueImage = jsonMap["image"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.image = try Tensorflow.Summary.Image.Builder.decodeToBuilder(jsonMap:jsonValueImage).build()

                    }
                    if let jsonValueHisto = jsonMap["histo"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.histo = try Tensorflow.HistogramProto.Builder.decodeToBuilder(jsonMap:jsonValueHisto).build()

                    }
                    if let jsonValueAudio = jsonMap["audio"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.audio = try Tensorflow.Summary.Audio.Builder.decodeToBuilder(jsonMap:jsonValueAudio).build()

                    }
                    if let jsonValueTensor = jsonMap["tensor"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.tensor = try Tensorflow.TensorProto.Builder.decodeToBuilder(jsonMap:jsonValueTensor).build()

                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Summary.Value.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.Summary.Value.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        public fileprivate(set) var value:Array<Tensorflow.Summary.Value>  = Array<Tensorflow.Summary.Value>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementValue in value {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementValue)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementValue in value {
                serialize_size += oneElementValue.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.Summary.Builder {
            return Tensorflow.Summary.classBuilder() as! Tensorflow.Summary.Builder
        }
        public func getBuilder() -> Tensorflow.Summary.Builder {
            return classBuilder() as! Tensorflow.Summary.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Summary.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Summary.Builder()
        }
        public func toBuilder() throws -> Tensorflow.Summary.Builder {
            return try Tensorflow.Summary.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.Summary) throws -> Tensorflow.Summary.Builder {
            return try Tensorflow.Summary.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !value.isEmpty {
                var jsonArrayValue:Array<Dictionary<String,Any>> = []
                for oneValueValue in value {
                    let ecodedMessageValue = try oneValueValue.encode()
                    jsonArrayValue.append(ecodedMessageValue)
                }
                jsonMap["value"] = jsonArrayValue
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Summary {
            return try Tensorflow.Summary.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.Summary {
            return try Tensorflow.Summary.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var valueElementIndex:Int = 0
            for oneElementValue in value {
                output += "\(indent) value[\(valueElementIndex)] {\n"
                output += try oneElementValue.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                valueElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementValue in value {
                    hashCode = (hashCode &* 31) &+ oneElementValue.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.Summary"
        }
        override public func className() -> String {
            return "Tensorflow.Summary"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.Summary = Tensorflow.Summary()
            public func getMessage() -> Tensorflow.Summary {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Set of values for the summary.
            public var value:Array<Tensorflow.Summary.Value> {
                get {
                    return builderResult.value
                }
                set (value) {
                    builderResult.value = value
                }
            }
            @discardableResult
            public func setValue(_ value:Array<Tensorflow.Summary.Value>) -> Tensorflow.Summary.Builder {
                self.value = value
                return self
            }
            @discardableResult
            public func clearValue() -> Tensorflow.Summary.Builder {
                builderResult.value.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.Summary.Builder {
                builderResult = Tensorflow.Summary()
                return self
            }
            override public func clone() throws -> Tensorflow.Summary.Builder {
                return try Tensorflow.Summary.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.Summary {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.Summary {
                let returnMe:Tensorflow.Summary = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.Summary) throws -> Tensorflow.Summary.Builder {
                if other == Tensorflow.Summary() {
                    return self
                }
                if !other.value.isEmpty  {
                     builderResult.value += other.value
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Summary.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Summary.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Tensorflow.Summary.Value.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        value.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Summary.Builder {
                let resultDecodedBuilder = Tensorflow.Summary.Builder()
                if let jsonValueValue = jsonMap["value"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayValue:Array<Tensorflow.Summary.Value> = []
                    for oneValueValue in jsonValueValue {
                        let messageFromStringValue = try Tensorflow.Summary.Value.Builder.decodeToBuilder(jsonMap:oneValueValue).build()

                        jsonArrayValue.append(messageFromStringValue)
                    }
                    resultDecodedBuilder.value = jsonArrayValue
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Summary.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.Summary.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.SummaryDescription: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.SummaryDescription> {
        var mergedArray = Array<Tensorflow.SummaryDescription>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.SummaryDescription? {
        return try Tensorflow.SummaryDescription.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.SummaryDescription {
        return try Tensorflow.SummaryDescription.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.SummaryRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.SummaryDescription {
        return try Tensorflow.SummaryDescription.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.SummaryDescription {
        return try Tensorflow.SummaryDescription.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.SummaryDescription {
        return try Tensorflow.SummaryDescription.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.SummaryDescription {
        return try Tensorflow.SummaryDescription.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.SummaryDescription {
        return try Tensorflow.SummaryDescription.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "typeHint": return self.typeHint
        default: return nil
        }
    }
}
extension Tensorflow.SummaryDescription.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "typeHint": return self.typeHint
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "typeHint":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.typeHint = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.HistogramProto: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.HistogramProto> {
        var mergedArray = Array<Tensorflow.HistogramProto>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.HistogramProto? {
        return try Tensorflow.HistogramProto.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.HistogramProto {
        return try Tensorflow.HistogramProto.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.SummaryRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.HistogramProto {
        return try Tensorflow.HistogramProto.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.HistogramProto {
        return try Tensorflow.HistogramProto.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.HistogramProto {
        return try Tensorflow.HistogramProto.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.HistogramProto {
        return try Tensorflow.HistogramProto.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.HistogramProto {
        return try Tensorflow.HistogramProto.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "min": return self.min
        case "max": return self.max
        case "num": return self.num
        case "sum": return self.sum
        case "sumSquares": return self.sumSquares
        case "bucketLimit": return self.bucketLimit
        case "bucket": return self.bucket
        default: return nil
        }
    }
}
extension Tensorflow.HistogramProto.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "min": return self.min
            case "max": return self.max
            case "num": return self.num
            case "sum": return self.sum
            case "sumSquares": return self.sumSquares
            case "bucketLimit": return self.bucketLimit
            case "bucket": return self.bucket
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "min":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.min = newSubscriptValue
            case "max":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.max = newSubscriptValue
            case "num":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.num = newSubscriptValue
            case "sum":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.sum = newSubscriptValue
            case "sumSquares":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.sumSquares = newSubscriptValue
            case "bucketLimit":
                guard let newSubscriptValue = newSubscriptValue as? Array<Double> else {
                    return
                }
                self.bucketLimit = newSubscriptValue
            case "bucket":
                guard let newSubscriptValue = newSubscriptValue as? Array<Double> else {
                    return
                }
                self.bucket = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Summary: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Summary> {
        var mergedArray = Array<Tensorflow.Summary>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Summary? {
        return try Tensorflow.Summary.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Summary {
        return try Tensorflow.Summary.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.SummaryRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Summary {
        return try Tensorflow.Summary.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Summary {
        return try Tensorflow.Summary.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Summary {
        return try Tensorflow.Summary.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Summary {
        return try Tensorflow.Summary.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Summary {
        return try Tensorflow.Summary.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.Summary.Image: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Summary.Image> {
        var mergedArray = Array<Tensorflow.Summary.Image>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Summary.Image? {
        return try Tensorflow.Summary.Image.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Summary.Image {
        return try Tensorflow.Summary.Image.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.SummaryRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Summary.Image {
        return try Tensorflow.Summary.Image.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Summary.Image {
        return try Tensorflow.Summary.Image.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Summary.Image {
        return try Tensorflow.Summary.Image.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Summary.Image {
        return try Tensorflow.Summary.Image.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Summary.Image {
        return try Tensorflow.Summary.Image.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "height": return self.height
        case "width": return self.width
        case "colorspace": return self.colorspace
        case "encodedImageString": return self.encodedImageString
        default: return nil
        }
    }
}
extension Tensorflow.Summary.Audio: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Summary.Audio> {
        var mergedArray = Array<Tensorflow.Summary.Audio>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Summary.Audio? {
        return try Tensorflow.Summary.Audio.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Summary.Audio {
        return try Tensorflow.Summary.Audio.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.SummaryRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Summary.Audio {
        return try Tensorflow.Summary.Audio.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Summary.Audio {
        return try Tensorflow.Summary.Audio.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Summary.Audio {
        return try Tensorflow.Summary.Audio.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Summary.Audio {
        return try Tensorflow.Summary.Audio.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Summary.Audio {
        return try Tensorflow.Summary.Audio.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "sampleRate": return self.sampleRate
        case "numChannels": return self.numChannels
        case "lengthFrames": return self.lengthFrames
        case "encodedAudioString": return self.encodedAudioString
        case "contentType": return self.contentType
        default: return nil
        }
    }
}
extension Tensorflow.Summary.Value: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Summary.Value> {
        var mergedArray = Array<Tensorflow.Summary.Value>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Summary.Value? {
        return try Tensorflow.Summary.Value.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Summary.Value {
        return try Tensorflow.Summary.Value.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.SummaryRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Summary.Value {
        return try Tensorflow.Summary.Value.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Summary.Value {
        return try Tensorflow.Summary.Value.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Summary.Value {
        return try Tensorflow.Summary.Value.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Summary.Value {
        return try Tensorflow.Summary.Value.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Summary.Value {
        return try Tensorflow.Summary.Value.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "nodeName": return self.nodeName
        case "tag": return self.tag
        case "simpleValue": return self.simpleValue
        case "obsoleteOldStyleHistogram": return self.obsoleteOldStyleHistogram
        case "image": return self.image
        case "histo": return self.histo
        case "audio": return self.audio
        case "tensor": return self.tensor
        default: return nil
        }
    }
}
extension Tensorflow.Summary.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.Summary.Value> else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Summary.Image.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "height": return self.height
            case "width": return self.width
            case "colorspace": return self.colorspace
            case "encodedImageString": return self.encodedImageString
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "height":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.height = newSubscriptValue
            case "width":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.width = newSubscriptValue
            case "colorspace":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.colorspace = newSubscriptValue
            case "encodedImageString":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.encodedImageString = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Summary.Audio.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "sampleRate": return self.sampleRate
            case "numChannels": return self.numChannels
            case "lengthFrames": return self.lengthFrames
            case "encodedAudioString": return self.encodedAudioString
            case "contentType": return self.contentType
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "sampleRate":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.sampleRate = newSubscriptValue
            case "numChannels":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.numChannels = newSubscriptValue
            case "lengthFrames":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.lengthFrames = newSubscriptValue
            case "encodedAudioString":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.encodedAudioString = newSubscriptValue
            case "contentType":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.contentType = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Summary.Value.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "nodeName": return self.nodeName
            case "tag": return self.tag
            case "simpleValue": return self.simpleValue
            case "obsoleteOldStyleHistogram": return self.obsoleteOldStyleHistogram
            case "image": return self.image
            case "histo": return self.histo
            case "audio": return self.audio
            case "tensor": return self.tensor
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "nodeName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.nodeName = newSubscriptValue
            case "tag":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.tag = newSubscriptValue
            case "simpleValue":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.simpleValue = newSubscriptValue
            case "obsoleteOldStyleHistogram":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.obsoleteOldStyleHistogram = newSubscriptValue
            case "image":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Summary.Image else {
                    return
                }
                self.image = newSubscriptValue
            case "histo":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.HistogramProto else {
                    return
                }
                self.histo = newSubscriptValue
            case "audio":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Summary.Audio else {
                    return
                }
                self.audio = newSubscriptValue
            case "tensor":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.TensorProto else {
                    return
                }
                self.tensor = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

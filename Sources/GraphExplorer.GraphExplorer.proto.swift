/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "graph_explorer.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct GraphExplorer { }

public extension GraphExplorer {
    public struct GraphExplorerRoot {
        public static let `default` = GraphExplorerRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    /// There are two types of nodes. A 'metanode' contains other
    /// nodes and a 'leaf node' has no internal structure.  The metanode containment
    /// relationship is acyclic, meaning that if a metanode 'A' contains the metanode
    /// 'B', then 'B' cannot contain 'A'.
    final public class Node : GeneratedMessage {

        public static func == (lhs: GraphExplorer.Node, rhs: GraphExplorer.Node) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
            fieldCheck = fieldCheck && (lhs.hasNodeAttr == rhs.hasNodeAttr) && (!lhs.hasNodeAttr || lhs.nodeAttr == rhs.nodeAttr)
            fieldCheck = fieldCheck && (lhs.hasMetanodeAttr == rhs.hasMetanodeAttr) && (!lhs.hasMetanodeAttr || lhs.metanodeAttr == rhs.metanodeAttr)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        final public class NodeAttrEntry : GeneratedMessage {

            public static func == (lhs: GraphExplorer.Node.NodeAttrEntry, rhs: GraphExplorer.Node.NodeAttrEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:String = ""
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:String = ""
            public fileprivate(set) var hasValue:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeString(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeString(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeStringSize(fieldNumber: 1)
                }
                if hasValue {
                    serialize_size += value.computeStringSize(fieldNumber: 2)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> GraphExplorer.Node.NodeAttrEntry.Builder {
                return GraphExplorer.Node.NodeAttrEntry.classBuilder() as! GraphExplorer.Node.NodeAttrEntry.Builder
            }
            public func getBuilder() -> GraphExplorer.Node.NodeAttrEntry.Builder {
                return classBuilder() as! GraphExplorer.Node.NodeAttrEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return GraphExplorer.Node.NodeAttrEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return GraphExplorer.Node.NodeAttrEntry.Builder()
            }
            public func toBuilder() throws -> GraphExplorer.Node.NodeAttrEntry.Builder {
                return try GraphExplorer.Node.NodeAttrEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:GraphExplorer.Node.NodeAttrEntry) throws -> GraphExplorer.Node.NodeAttrEntry.Builder {
                return try GraphExplorer.Node.NodeAttrEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = key
                }
                if hasValue {
                    jsonMap["value"] = value
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> GraphExplorer.Node.NodeAttrEntry {
                return try GraphExplorer.Node.NodeAttrEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> GraphExplorer.Node.NodeAttrEntry {
                return try GraphExplorer.Node.NodeAttrEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value: \(value) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        hashCode = (hashCode &* 31) &+ value.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "GraphExplorer.Node.NodeAttrEntry"
            }
            override public func className() -> String {
                return "GraphExplorer.Node.NodeAttrEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:GraphExplorer.Node.NodeAttrEntry = GraphExplorer.Node.NodeAttrEntry()
                public func getMessage() -> GraphExplorer.Node.NodeAttrEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:String {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:String) -> GraphExplorer.Node.NodeAttrEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> GraphExplorer.Node.NodeAttrEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = ""
                    return self
                }
                public var value:String {
                    get {
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                @discardableResult
                public func setValue(_ value:String) -> GraphExplorer.Node.NodeAttrEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func clearValue() -> GraphExplorer.Node.NodeAttrEntry.Builder{
                    builderResult.hasValue = false
                    builderResult.value = ""
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> GraphExplorer.Node.NodeAttrEntry.Builder {
                    builderResult = GraphExplorer.Node.NodeAttrEntry()
                    return self
                }
                override public func clone() throws -> GraphExplorer.Node.NodeAttrEntry.Builder {
                    return try GraphExplorer.Node.NodeAttrEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> GraphExplorer.Node.NodeAttrEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> GraphExplorer.Node.NodeAttrEntry {
                    let returnMe:GraphExplorer.Node.NodeAttrEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:GraphExplorer.Node.NodeAttrEntry) throws -> GraphExplorer.Node.NodeAttrEntry.Builder {
                    if other == GraphExplorer.Node.NodeAttrEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if other.hasValue {
                        value = other.value
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> GraphExplorer.Node.NodeAttrEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Node.NodeAttrEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            key = try codedInputStream.readString()

                        case 18:
                            value = try codedInputStream.readString()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> GraphExplorer.Node.NodeAttrEntry.Builder {
                    let resultDecodedBuilder = GraphExplorer.Node.NodeAttrEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = jsonValueKey
                    }
                    if let jsonValueValue = jsonMap["value"] as? String {
                        resultDecodedBuilder.value = jsonValueValue
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> GraphExplorer.Node.NodeAttrEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try GraphExplorer.Node.NodeAttrEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        final public class MetanodeAttrEntry : GeneratedMessage {

            public static func == (lhs: GraphExplorer.Node.MetanodeAttrEntry, rhs: GraphExplorer.Node.MetanodeAttrEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:String = ""
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:String = ""
            public fileprivate(set) var hasValue:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeString(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeString(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeStringSize(fieldNumber: 1)
                }
                if hasValue {
                    serialize_size += value.computeStringSize(fieldNumber: 2)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> GraphExplorer.Node.MetanodeAttrEntry.Builder {
                return GraphExplorer.Node.MetanodeAttrEntry.classBuilder() as! GraphExplorer.Node.MetanodeAttrEntry.Builder
            }
            public func getBuilder() -> GraphExplorer.Node.MetanodeAttrEntry.Builder {
                return classBuilder() as! GraphExplorer.Node.MetanodeAttrEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return GraphExplorer.Node.MetanodeAttrEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return GraphExplorer.Node.MetanodeAttrEntry.Builder()
            }
            public func toBuilder() throws -> GraphExplorer.Node.MetanodeAttrEntry.Builder {
                return try GraphExplorer.Node.MetanodeAttrEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:GraphExplorer.Node.MetanodeAttrEntry) throws -> GraphExplorer.Node.MetanodeAttrEntry.Builder {
                return try GraphExplorer.Node.MetanodeAttrEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = key
                }
                if hasValue {
                    jsonMap["value"] = value
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> GraphExplorer.Node.MetanodeAttrEntry {
                return try GraphExplorer.Node.MetanodeAttrEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> GraphExplorer.Node.MetanodeAttrEntry {
                return try GraphExplorer.Node.MetanodeAttrEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value: \(value) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        hashCode = (hashCode &* 31) &+ value.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "GraphExplorer.Node.MetanodeAttrEntry"
            }
            override public func className() -> String {
                return "GraphExplorer.Node.MetanodeAttrEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:GraphExplorer.Node.MetanodeAttrEntry = GraphExplorer.Node.MetanodeAttrEntry()
                public func getMessage() -> GraphExplorer.Node.MetanodeAttrEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:String {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:String) -> GraphExplorer.Node.MetanodeAttrEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> GraphExplorer.Node.MetanodeAttrEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = ""
                    return self
                }
                public var value:String {
                    get {
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                @discardableResult
                public func setValue(_ value:String) -> GraphExplorer.Node.MetanodeAttrEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func clearValue() -> GraphExplorer.Node.MetanodeAttrEntry.Builder{
                    builderResult.hasValue = false
                    builderResult.value = ""
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> GraphExplorer.Node.MetanodeAttrEntry.Builder {
                    builderResult = GraphExplorer.Node.MetanodeAttrEntry()
                    return self
                }
                override public func clone() throws -> GraphExplorer.Node.MetanodeAttrEntry.Builder {
                    return try GraphExplorer.Node.MetanodeAttrEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> GraphExplorer.Node.MetanodeAttrEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> GraphExplorer.Node.MetanodeAttrEntry {
                    let returnMe:GraphExplorer.Node.MetanodeAttrEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:GraphExplorer.Node.MetanodeAttrEntry) throws -> GraphExplorer.Node.MetanodeAttrEntry.Builder {
                    if other == GraphExplorer.Node.MetanodeAttrEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if other.hasValue {
                        value = other.value
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> GraphExplorer.Node.MetanodeAttrEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Node.MetanodeAttrEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            key = try codedInputStream.readString()

                        case 18:
                            value = try codedInputStream.readString()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> GraphExplorer.Node.MetanodeAttrEntry.Builder {
                    let resultDecodedBuilder = GraphExplorer.Node.MetanodeAttrEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = jsonValueKey
                    }
                    if let jsonValueValue = jsonMap["value"] as? String {
                        resultDecodedBuilder.value = jsonValueValue
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> GraphExplorer.Node.MetanodeAttrEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try GraphExplorer.Node.MetanodeAttrEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        /// The identifier of a node is a sequence of strings separated by '/'. The
        /// identifier provides a unique name for a node and defines its hierarchical
        /// relation to other nodes.  If no label is provided  the last part of the
        /// identifier is used as a label.
        /// Example: In the graph below, metanodes are written with square brackets and
        /// leaf nodes with parentheses. The metanode 'node1' contains the leaf node
        /// 'node4' and the metanode 'node2', which contains the leaf node 'node3'.
        ///   [node1 [node2 (node3)] (node4)]
        /// The identifiers for these nodes are: "node1", "node1/node2",
        /// "node1/node2/node3", and "node1/node4".
        public fileprivate(set) var name:String = ""
        public fileprivate(set) var hasName:Bool = false

        /// A node attribute is information used by Graph Explorer to style a node.
        public fileprivate(set) var nodeAttr:Dictionary<String,String> = Dictionary<String,String>()

        public fileprivate(set) var hasNodeAttr:Bool = false
        /// A metanode attribute is one that is inherited by all nodes inside the
        /// current metanode. If an attribute applies only to the current node and
        /// should not be inherited, it should be specified as a node attribute.
        public fileprivate(set) var metanodeAttr:Dictionary<String,String> = Dictionary<String,String>()

        public fileprivate(set) var hasMetanodeAttr:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasName {
                try codedOutputStream.writeString(fieldNumber: 1, value:name)
            }
            if hasNodeAttr {
                for (keyNodeAttr, valueNodeAttr) in nodeAttr {
                    let valueOfNodeAttr = try! GraphExplorer.Node.NodeAttrEntry.Builder().setKey(keyNodeAttr).setValue(valueNodeAttr).build()
                      try codedOutputStream.writeMessage(fieldNumber: 2, value:valueOfNodeAttr)
                  }
            }
            if hasMetanodeAttr {
                for (keyMetanodeAttr, valueMetanodeAttr) in metanodeAttr {
                    let valueOfMetanodeAttr = try! GraphExplorer.Node.MetanodeAttrEntry.Builder().setKey(keyMetanodeAttr).setValue(valueMetanodeAttr).build()
                      try codedOutputStream.writeMessage(fieldNumber: 3, value:valueOfMetanodeAttr)
                  }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasName {
                serialize_size += name.computeStringSize(fieldNumber: 1)
            }
            if hasNodeAttr {
                  for (keyNodeAttr, valueNodeAttr) in nodeAttr {
                      let valueOfNodeAttr = try! GraphExplorer.Node.NodeAttrEntry.Builder().setKey(keyNodeAttr).setValue(valueNodeAttr).build()
                serialize_size += valueOfNodeAttr.computeMessageSize(fieldNumber: 2)
                }
            }
            if hasMetanodeAttr {
                  for (keyMetanodeAttr, valueMetanodeAttr) in metanodeAttr {
                      let valueOfMetanodeAttr = try! GraphExplorer.Node.MetanodeAttrEntry.Builder().setKey(keyMetanodeAttr).setValue(valueMetanodeAttr).build()
                serialize_size += valueOfMetanodeAttr.computeMessageSize(fieldNumber: 3)
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> GraphExplorer.Node.Builder {
            return GraphExplorer.Node.classBuilder() as! GraphExplorer.Node.Builder
        }
        public func getBuilder() -> GraphExplorer.Node.Builder {
            return classBuilder() as! GraphExplorer.Node.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return GraphExplorer.Node.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return GraphExplorer.Node.Builder()
        }
        public func toBuilder() throws -> GraphExplorer.Node.Builder {
            return try GraphExplorer.Node.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:GraphExplorer.Node) throws -> GraphExplorer.Node.Builder {
            return try GraphExplorer.Node.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasName {
                jsonMap["name"] = name
            }
            if hasNodeAttr {
                var mapNodeAttr = Dictionary<String, String>()
                for (keyNodeAttr, valueNodeAttr) in nodeAttr {
                    mapNodeAttr["\(keyNodeAttr)"] = valueNodeAttr
                }
                jsonMap["nodeAttr"] = mapNodeAttr
            }
            if hasMetanodeAttr {
                var mapMetanodeAttr = Dictionary<String, String>()
                for (keyMetanodeAttr, valueMetanodeAttr) in metanodeAttr {
                    mapMetanodeAttr["\(keyMetanodeAttr)"] = valueMetanodeAttr
                }
                jsonMap["metanodeAttr"] = mapMetanodeAttr
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> GraphExplorer.Node {
            return try GraphExplorer.Node.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> GraphExplorer.Node {
            return try GraphExplorer.Node.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasName {
                output += "\(indent) name: \(name) \n"
            }
            if hasNodeAttr {
                output += "\(indent) nodeAttr: \(nodeAttr) \n"
            }
            if hasMetanodeAttr {
                output += "\(indent) metanodeAttr: \(metanodeAttr) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasName {
                    hashCode = (hashCode &* 31) &+ name.hashValue
                }
                if hasNodeAttr {
                    for (keyNodeAttr, valueNodeAttr) in nodeAttr {
                        hashCode = (hashCode &* 31) &+ keyNodeAttr.hashValue
                        hashCode = (hashCode &* 31) &+ valueNodeAttr.hashValue
                    }
                }
                if hasMetanodeAttr {
                    for (keyMetanodeAttr, valueMetanodeAttr) in metanodeAttr {
                        hashCode = (hashCode &* 31) &+ keyMetanodeAttr.hashValue
                        hashCode = (hashCode &* 31) &+ valueMetanodeAttr.hashValue
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "GraphExplorer.Node"
        }
        override public func className() -> String {
            return "GraphExplorer.Node"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:GraphExplorer.Node = GraphExplorer.Node()
            public func getMessage() -> GraphExplorer.Node {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The identifier of a node is a sequence of strings separated by '/'. The
            /// identifier provides a unique name for a node and defines its hierarchical
            /// relation to other nodes.  If no label is provided  the last part of the
            /// identifier is used as a label.
            /// Example: In the graph below, metanodes are written with square brackets and
            /// leaf nodes with parentheses. The metanode 'node1' contains the leaf node
            /// 'node4' and the metanode 'node2', which contains the leaf node 'node3'.
            ///   [node1 [node2 (node3)] (node4)]
            /// The identifiers for these nodes are: "node1", "node1/node2",
            /// "node1/node2/node3", and "node1/node4".
            public var name:String {
                get {
                    return builderResult.name
                }
                set (value) {
                    builderResult.hasName = true
                    builderResult.name = value
                }
            }
            public var hasName:Bool {
                get {
                    return builderResult.hasName
                }
            }
            @discardableResult
            public func setName(_ value:String) -> GraphExplorer.Node.Builder {
                self.name = value
                return self
            }
            @discardableResult
            public func clearName() -> GraphExplorer.Node.Builder{
                builderResult.hasName = false
                builderResult.name = ""
                return self
            }
            /// A node attribute is information used by Graph Explorer to style a node.
            public var hasNodeAttr:Bool {
                get {
                    return builderResult.hasNodeAttr
                }
            }
            public var nodeAttr:Dictionary<String,String> {
                get {
                    return builderResult.nodeAttr
                }
                set (value) {
                    builderResult.hasNodeAttr = true
                    builderResult.nodeAttr = value
                }
            }
            @discardableResult
            public func setNodeAttr(_ value:Dictionary<String,String>) -> GraphExplorer.Node.Builder {
                self.nodeAttr = value
                return self
            }
            @discardableResult
            public func clearNodeAttr() -> GraphExplorer.Node.Builder{
                builderResult.hasNodeAttr = false
                builderResult.nodeAttr = Dictionary<String,String>()
                return self
            }
            /// A metanode attribute is one that is inherited by all nodes inside the
            /// current metanode. If an attribute applies only to the current node and
            /// should not be inherited, it should be specified as a node attribute.
            public var hasMetanodeAttr:Bool {
                get {
                    return builderResult.hasMetanodeAttr
                }
            }
            public var metanodeAttr:Dictionary<String,String> {
                get {
                    return builderResult.metanodeAttr
                }
                set (value) {
                    builderResult.hasMetanodeAttr = true
                    builderResult.metanodeAttr = value
                }
            }
            @discardableResult
            public func setMetanodeAttr(_ value:Dictionary<String,String>) -> GraphExplorer.Node.Builder {
                self.metanodeAttr = value
                return self
            }
            @discardableResult
            public func clearMetanodeAttr() -> GraphExplorer.Node.Builder{
                builderResult.hasMetanodeAttr = false
                builderResult.metanodeAttr = Dictionary<String,String>()
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> GraphExplorer.Node.Builder {
                builderResult = GraphExplorer.Node()
                return self
            }
            override public func clone() throws -> GraphExplorer.Node.Builder {
                return try GraphExplorer.Node.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> GraphExplorer.Node {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> GraphExplorer.Node {
                let returnMe:GraphExplorer.Node = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:GraphExplorer.Node) throws -> GraphExplorer.Node.Builder {
                if other == GraphExplorer.Node() {
                    return self
                }
                if other.hasName {
                    name = other.name
                }
                if other.hasNodeAttr {
                    nodeAttr = other.nodeAttr
                }
                if other.hasMetanodeAttr {
                    metanodeAttr = other.metanodeAttr
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> GraphExplorer.Node.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Node.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        name = try codedInputStream.readString()

                    case 18:
                        let subBuilder = GraphExplorer.Node.NodeAttrEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfNodeAttr = subBuilder.buildPartial()
                        nodeAttr[buildOfNodeAttr.key] = buildOfNodeAttr.value

                    case 26:
                        let subBuilder = GraphExplorer.Node.MetanodeAttrEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfMetanodeAttr = subBuilder.buildPartial()
                        metanodeAttr[buildOfMetanodeAttr.key] = buildOfMetanodeAttr.value

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> GraphExplorer.Node.Builder {
                let resultDecodedBuilder = GraphExplorer.Node.Builder()
                if let jsonValueName = jsonMap["name"] as? String {
                    resultDecodedBuilder.name = jsonValueName
                }
                if let jsonValueNodeAttr = jsonMap["nodeAttr"] as? Dictionary<String, String> {
                    var mapNodeAttr = Dictionary<String, String>()
                    for (keyNodeAttr, valueNodeAttr) in jsonValueNodeAttr {
                        guard let keyFromNodeAttr = String(keyNodeAttr) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapNodeAttr[keyFromNodeAttr] = valueNodeAttr
                    }
                    resultDecodedBuilder.nodeAttr = mapNodeAttr
                }
                if let jsonValueMetanodeAttr = jsonMap["metanodeAttr"] as? Dictionary<String, String> {
                    var mapMetanodeAttr = Dictionary<String, String>()
                    for (keyMetanodeAttr, valueMetanodeAttr) in jsonValueMetanodeAttr {
                        guard let keyFromMetanodeAttr = String(keyMetanodeAttr) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapMetanodeAttr[keyFromMetanodeAttr] = valueMetanodeAttr
                    }
                    resultDecodedBuilder.metanodeAttr = mapMetanodeAttr
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> GraphExplorer.Node.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try GraphExplorer.Node.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// An edge consists of a source and a target node, specified by their
    /// identifiers. An edge has attributes and data that are similar to node
    /// attributes and node data. Edges do not form a hierarchy so there are no
    /// metanode attributes.
    final public class Edge : GeneratedMessage {

        public static func == (lhs: GraphExplorer.Edge, rhs: GraphExplorer.Edge) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasSource == rhs.hasSource) && (!lhs.hasSource || lhs.source == rhs.source)
            fieldCheck = fieldCheck && (lhs.hasTarget == rhs.hasTarget) && (!lhs.hasTarget || lhs.target == rhs.target)
            fieldCheck = fieldCheck && (lhs.hasEdgeAttr == rhs.hasEdgeAttr) && (!lhs.hasEdgeAttr || lhs.edgeAttr == rhs.edgeAttr)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        final public class EdgeAttrEntry : GeneratedMessage {

            public static func == (lhs: GraphExplorer.Edge.EdgeAttrEntry, rhs: GraphExplorer.Edge.EdgeAttrEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:String = ""
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:String = ""
            public fileprivate(set) var hasValue:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeString(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeString(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeStringSize(fieldNumber: 1)
                }
                if hasValue {
                    serialize_size += value.computeStringSize(fieldNumber: 2)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> GraphExplorer.Edge.EdgeAttrEntry.Builder {
                return GraphExplorer.Edge.EdgeAttrEntry.classBuilder() as! GraphExplorer.Edge.EdgeAttrEntry.Builder
            }
            public func getBuilder() -> GraphExplorer.Edge.EdgeAttrEntry.Builder {
                return classBuilder() as! GraphExplorer.Edge.EdgeAttrEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return GraphExplorer.Edge.EdgeAttrEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return GraphExplorer.Edge.EdgeAttrEntry.Builder()
            }
            public func toBuilder() throws -> GraphExplorer.Edge.EdgeAttrEntry.Builder {
                return try GraphExplorer.Edge.EdgeAttrEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:GraphExplorer.Edge.EdgeAttrEntry) throws -> GraphExplorer.Edge.EdgeAttrEntry.Builder {
                return try GraphExplorer.Edge.EdgeAttrEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = key
                }
                if hasValue {
                    jsonMap["value"] = value
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> GraphExplorer.Edge.EdgeAttrEntry {
                return try GraphExplorer.Edge.EdgeAttrEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> GraphExplorer.Edge.EdgeAttrEntry {
                return try GraphExplorer.Edge.EdgeAttrEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value: \(value) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        hashCode = (hashCode &* 31) &+ value.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "GraphExplorer.Edge.EdgeAttrEntry"
            }
            override public func className() -> String {
                return "GraphExplorer.Edge.EdgeAttrEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:GraphExplorer.Edge.EdgeAttrEntry = GraphExplorer.Edge.EdgeAttrEntry()
                public func getMessage() -> GraphExplorer.Edge.EdgeAttrEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:String {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:String) -> GraphExplorer.Edge.EdgeAttrEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> GraphExplorer.Edge.EdgeAttrEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = ""
                    return self
                }
                public var value:String {
                    get {
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                @discardableResult
                public func setValue(_ value:String) -> GraphExplorer.Edge.EdgeAttrEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func clearValue() -> GraphExplorer.Edge.EdgeAttrEntry.Builder{
                    builderResult.hasValue = false
                    builderResult.value = ""
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> GraphExplorer.Edge.EdgeAttrEntry.Builder {
                    builderResult = GraphExplorer.Edge.EdgeAttrEntry()
                    return self
                }
                override public func clone() throws -> GraphExplorer.Edge.EdgeAttrEntry.Builder {
                    return try GraphExplorer.Edge.EdgeAttrEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> GraphExplorer.Edge.EdgeAttrEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> GraphExplorer.Edge.EdgeAttrEntry {
                    let returnMe:GraphExplorer.Edge.EdgeAttrEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:GraphExplorer.Edge.EdgeAttrEntry) throws -> GraphExplorer.Edge.EdgeAttrEntry.Builder {
                    if other == GraphExplorer.Edge.EdgeAttrEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if other.hasValue {
                        value = other.value
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> GraphExplorer.Edge.EdgeAttrEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Edge.EdgeAttrEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            key = try codedInputStream.readString()

                        case 18:
                            value = try codedInputStream.readString()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> GraphExplorer.Edge.EdgeAttrEntry.Builder {
                    let resultDecodedBuilder = GraphExplorer.Edge.EdgeAttrEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = jsonValueKey
                    }
                    if let jsonValueValue = jsonMap["value"] as? String {
                        resultDecodedBuilder.value = jsonValueValue
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> GraphExplorer.Edge.EdgeAttrEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try GraphExplorer.Edge.EdgeAttrEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        /// The source and target fields must have the format of a Node name.
        public fileprivate(set) var source:String = ""
        public fileprivate(set) var hasSource:Bool = false

        public fileprivate(set) var target:String = ""
        public fileprivate(set) var hasTarget:Bool = false

        /// Edge attributes.
        public fileprivate(set) var edgeAttr:Dictionary<String,String> = Dictionary<String,String>()

        public fileprivate(set) var hasEdgeAttr:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasSource {
                try codedOutputStream.writeString(fieldNumber: 1, value:source)
            }
            if hasTarget {
                try codedOutputStream.writeString(fieldNumber: 2, value:target)
            }
            if hasEdgeAttr {
                for (keyEdgeAttr, valueEdgeAttr) in edgeAttr {
                    let valueOfEdgeAttr = try! GraphExplorer.Edge.EdgeAttrEntry.Builder().setKey(keyEdgeAttr).setValue(valueEdgeAttr).build()
                      try codedOutputStream.writeMessage(fieldNumber: 3, value:valueOfEdgeAttr)
                  }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasSource {
                serialize_size += source.computeStringSize(fieldNumber: 1)
            }
            if hasTarget {
                serialize_size += target.computeStringSize(fieldNumber: 2)
            }
            if hasEdgeAttr {
                  for (keyEdgeAttr, valueEdgeAttr) in edgeAttr {
                      let valueOfEdgeAttr = try! GraphExplorer.Edge.EdgeAttrEntry.Builder().setKey(keyEdgeAttr).setValue(valueEdgeAttr).build()
                serialize_size += valueOfEdgeAttr.computeMessageSize(fieldNumber: 3)
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> GraphExplorer.Edge.Builder {
            return GraphExplorer.Edge.classBuilder() as! GraphExplorer.Edge.Builder
        }
        public func getBuilder() -> GraphExplorer.Edge.Builder {
            return classBuilder() as! GraphExplorer.Edge.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return GraphExplorer.Edge.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return GraphExplorer.Edge.Builder()
        }
        public func toBuilder() throws -> GraphExplorer.Edge.Builder {
            return try GraphExplorer.Edge.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:GraphExplorer.Edge) throws -> GraphExplorer.Edge.Builder {
            return try GraphExplorer.Edge.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasSource {
                jsonMap["source"] = source
            }
            if hasTarget {
                jsonMap["target"] = target
            }
            if hasEdgeAttr {
                var mapEdgeAttr = Dictionary<String, String>()
                for (keyEdgeAttr, valueEdgeAttr) in edgeAttr {
                    mapEdgeAttr["\(keyEdgeAttr)"] = valueEdgeAttr
                }
                jsonMap["edgeAttr"] = mapEdgeAttr
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> GraphExplorer.Edge {
            return try GraphExplorer.Edge.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> GraphExplorer.Edge {
            return try GraphExplorer.Edge.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasSource {
                output += "\(indent) source: \(source) \n"
            }
            if hasTarget {
                output += "\(indent) target: \(target) \n"
            }
            if hasEdgeAttr {
                output += "\(indent) edgeAttr: \(edgeAttr) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasSource {
                    hashCode = (hashCode &* 31) &+ source.hashValue
                }
                if hasTarget {
                    hashCode = (hashCode &* 31) &+ target.hashValue
                }
                if hasEdgeAttr {
                    for (keyEdgeAttr, valueEdgeAttr) in edgeAttr {
                        hashCode = (hashCode &* 31) &+ keyEdgeAttr.hashValue
                        hashCode = (hashCode &* 31) &+ valueEdgeAttr.hashValue
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "GraphExplorer.Edge"
        }
        override public func className() -> String {
            return "GraphExplorer.Edge"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:GraphExplorer.Edge = GraphExplorer.Edge()
            public func getMessage() -> GraphExplorer.Edge {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The source and target fields must have the format of a Node name.
            public var source:String {
                get {
                    return builderResult.source
                }
                set (value) {
                    builderResult.hasSource = true
                    builderResult.source = value
                }
            }
            public var hasSource:Bool {
                get {
                    return builderResult.hasSource
                }
            }
            @discardableResult
            public func setSource(_ value:String) -> GraphExplorer.Edge.Builder {
                self.source = value
                return self
            }
            @discardableResult
            public func clearSource() -> GraphExplorer.Edge.Builder{
                builderResult.hasSource = false
                builderResult.source = ""
                return self
            }
            public var target:String {
                get {
                    return builderResult.target
                }
                set (value) {
                    builderResult.hasTarget = true
                    builderResult.target = value
                }
            }
            public var hasTarget:Bool {
                get {
                    return builderResult.hasTarget
                }
            }
            @discardableResult
            public func setTarget(_ value:String) -> GraphExplorer.Edge.Builder {
                self.target = value
                return self
            }
            @discardableResult
            public func clearTarget() -> GraphExplorer.Edge.Builder{
                builderResult.hasTarget = false
                builderResult.target = ""
                return self
            }
            /// Edge attributes.
            public var hasEdgeAttr:Bool {
                get {
                    return builderResult.hasEdgeAttr
                }
            }
            public var edgeAttr:Dictionary<String,String> {
                get {
                    return builderResult.edgeAttr
                }
                set (value) {
                    builderResult.hasEdgeAttr = true
                    builderResult.edgeAttr = value
                }
            }
            @discardableResult
            public func setEdgeAttr(_ value:Dictionary<String,String>) -> GraphExplorer.Edge.Builder {
                self.edgeAttr = value
                return self
            }
            @discardableResult
            public func clearEdgeAttr() -> GraphExplorer.Edge.Builder{
                builderResult.hasEdgeAttr = false
                builderResult.edgeAttr = Dictionary<String,String>()
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> GraphExplorer.Edge.Builder {
                builderResult = GraphExplorer.Edge()
                return self
            }
            override public func clone() throws -> GraphExplorer.Edge.Builder {
                return try GraphExplorer.Edge.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> GraphExplorer.Edge {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> GraphExplorer.Edge {
                let returnMe:GraphExplorer.Edge = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:GraphExplorer.Edge) throws -> GraphExplorer.Edge.Builder {
                if other == GraphExplorer.Edge() {
                    return self
                }
                if other.hasSource {
                    source = other.source
                }
                if other.hasTarget {
                    target = other.target
                }
                if other.hasEdgeAttr {
                    edgeAttr = other.edgeAttr
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> GraphExplorer.Edge.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Edge.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        source = try codedInputStream.readString()

                    case 18:
                        target = try codedInputStream.readString()

                    case 26:
                        let subBuilder = GraphExplorer.Edge.EdgeAttrEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfEdgeAttr = subBuilder.buildPartial()
                        edgeAttr[buildOfEdgeAttr.key] = buildOfEdgeAttr.value

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> GraphExplorer.Edge.Builder {
                let resultDecodedBuilder = GraphExplorer.Edge.Builder()
                if let jsonValueSource = jsonMap["source"] as? String {
                    resultDecodedBuilder.source = jsonValueSource
                }
                if let jsonValueTarget = jsonMap["target"] as? String {
                    resultDecodedBuilder.target = jsonValueTarget
                }
                if let jsonValueEdgeAttr = jsonMap["edgeAttr"] as? Dictionary<String, String> {
                    var mapEdgeAttr = Dictionary<String, String>()
                    for (keyEdgeAttr, valueEdgeAttr) in jsonValueEdgeAttr {
                        guard let keyFromEdgeAttr = String(keyEdgeAttr) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapEdgeAttr[keyFromEdgeAttr] = valueEdgeAttr
                    }
                    resultDecodedBuilder.edgeAttr = mapEdgeAttr
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> GraphExplorer.Edge.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try GraphExplorer.Edge.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class Graph : GeneratedMessage {

        public static func == (lhs: GraphExplorer.Graph, rhs: GraphExplorer.Graph) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.node == rhs.node)
            fieldCheck = fieldCheck && (lhs.edge == rhs.edge)
            fieldCheck = fieldCheck && (lhs.hasNodeAttr == rhs.hasNodeAttr) && (!lhs.hasNodeAttr || lhs.nodeAttr == rhs.nodeAttr)
            fieldCheck = fieldCheck && (lhs.hasMetanodeAttr == rhs.hasMetanodeAttr) && (!lhs.hasMetanodeAttr || lhs.metanodeAttr == rhs.metanodeAttr)
            fieldCheck = fieldCheck && (lhs.hasEdgeAttr == rhs.hasEdgeAttr) && (!lhs.hasEdgeAttr || lhs.edgeAttr == rhs.edgeAttr)
            fieldCheck = fieldCheck && (lhs.hasGraphAttr == rhs.hasGraphAttr) && (!lhs.hasGraphAttr || lhs.graphAttr == rhs.graphAttr)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        final public class NodeAttrEntry : GeneratedMessage {

            public static func == (lhs: GraphExplorer.Graph.NodeAttrEntry, rhs: GraphExplorer.Graph.NodeAttrEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:String = ""
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:String = ""
            public fileprivate(set) var hasValue:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeString(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeString(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeStringSize(fieldNumber: 1)
                }
                if hasValue {
                    serialize_size += value.computeStringSize(fieldNumber: 2)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> GraphExplorer.Graph.NodeAttrEntry.Builder {
                return GraphExplorer.Graph.NodeAttrEntry.classBuilder() as! GraphExplorer.Graph.NodeAttrEntry.Builder
            }
            public func getBuilder() -> GraphExplorer.Graph.NodeAttrEntry.Builder {
                return classBuilder() as! GraphExplorer.Graph.NodeAttrEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return GraphExplorer.Graph.NodeAttrEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return GraphExplorer.Graph.NodeAttrEntry.Builder()
            }
            public func toBuilder() throws -> GraphExplorer.Graph.NodeAttrEntry.Builder {
                return try GraphExplorer.Graph.NodeAttrEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:GraphExplorer.Graph.NodeAttrEntry) throws -> GraphExplorer.Graph.NodeAttrEntry.Builder {
                return try GraphExplorer.Graph.NodeAttrEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = key
                }
                if hasValue {
                    jsonMap["value"] = value
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> GraphExplorer.Graph.NodeAttrEntry {
                return try GraphExplorer.Graph.NodeAttrEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> GraphExplorer.Graph.NodeAttrEntry {
                return try GraphExplorer.Graph.NodeAttrEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value: \(value) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        hashCode = (hashCode &* 31) &+ value.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "GraphExplorer.Graph.NodeAttrEntry"
            }
            override public func className() -> String {
                return "GraphExplorer.Graph.NodeAttrEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:GraphExplorer.Graph.NodeAttrEntry = GraphExplorer.Graph.NodeAttrEntry()
                public func getMessage() -> GraphExplorer.Graph.NodeAttrEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:String {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:String) -> GraphExplorer.Graph.NodeAttrEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> GraphExplorer.Graph.NodeAttrEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = ""
                    return self
                }
                public var value:String {
                    get {
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                @discardableResult
                public func setValue(_ value:String) -> GraphExplorer.Graph.NodeAttrEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func clearValue() -> GraphExplorer.Graph.NodeAttrEntry.Builder{
                    builderResult.hasValue = false
                    builderResult.value = ""
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> GraphExplorer.Graph.NodeAttrEntry.Builder {
                    builderResult = GraphExplorer.Graph.NodeAttrEntry()
                    return self
                }
                override public func clone() throws -> GraphExplorer.Graph.NodeAttrEntry.Builder {
                    return try GraphExplorer.Graph.NodeAttrEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> GraphExplorer.Graph.NodeAttrEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> GraphExplorer.Graph.NodeAttrEntry {
                    let returnMe:GraphExplorer.Graph.NodeAttrEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:GraphExplorer.Graph.NodeAttrEntry) throws -> GraphExplorer.Graph.NodeAttrEntry.Builder {
                    if other == GraphExplorer.Graph.NodeAttrEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if other.hasValue {
                        value = other.value
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> GraphExplorer.Graph.NodeAttrEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Graph.NodeAttrEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            key = try codedInputStream.readString()

                        case 18:
                            value = try codedInputStream.readString()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> GraphExplorer.Graph.NodeAttrEntry.Builder {
                    let resultDecodedBuilder = GraphExplorer.Graph.NodeAttrEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = jsonValueKey
                    }
                    if let jsonValueValue = jsonMap["value"] as? String {
                        resultDecodedBuilder.value = jsonValueValue
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> GraphExplorer.Graph.NodeAttrEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try GraphExplorer.Graph.NodeAttrEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        final public class MetanodeAttrEntry : GeneratedMessage {

            public static func == (lhs: GraphExplorer.Graph.MetanodeAttrEntry, rhs: GraphExplorer.Graph.MetanodeAttrEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:String = ""
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:String = ""
            public fileprivate(set) var hasValue:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeString(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeString(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeStringSize(fieldNumber: 1)
                }
                if hasValue {
                    serialize_size += value.computeStringSize(fieldNumber: 2)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> GraphExplorer.Graph.MetanodeAttrEntry.Builder {
                return GraphExplorer.Graph.MetanodeAttrEntry.classBuilder() as! GraphExplorer.Graph.MetanodeAttrEntry.Builder
            }
            public func getBuilder() -> GraphExplorer.Graph.MetanodeAttrEntry.Builder {
                return classBuilder() as! GraphExplorer.Graph.MetanodeAttrEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return GraphExplorer.Graph.MetanodeAttrEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return GraphExplorer.Graph.MetanodeAttrEntry.Builder()
            }
            public func toBuilder() throws -> GraphExplorer.Graph.MetanodeAttrEntry.Builder {
                return try GraphExplorer.Graph.MetanodeAttrEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:GraphExplorer.Graph.MetanodeAttrEntry) throws -> GraphExplorer.Graph.MetanodeAttrEntry.Builder {
                return try GraphExplorer.Graph.MetanodeAttrEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = key
                }
                if hasValue {
                    jsonMap["value"] = value
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> GraphExplorer.Graph.MetanodeAttrEntry {
                return try GraphExplorer.Graph.MetanodeAttrEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> GraphExplorer.Graph.MetanodeAttrEntry {
                return try GraphExplorer.Graph.MetanodeAttrEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value: \(value) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        hashCode = (hashCode &* 31) &+ value.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "GraphExplorer.Graph.MetanodeAttrEntry"
            }
            override public func className() -> String {
                return "GraphExplorer.Graph.MetanodeAttrEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:GraphExplorer.Graph.MetanodeAttrEntry = GraphExplorer.Graph.MetanodeAttrEntry()
                public func getMessage() -> GraphExplorer.Graph.MetanodeAttrEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:String {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:String) -> GraphExplorer.Graph.MetanodeAttrEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> GraphExplorer.Graph.MetanodeAttrEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = ""
                    return self
                }
                public var value:String {
                    get {
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                @discardableResult
                public func setValue(_ value:String) -> GraphExplorer.Graph.MetanodeAttrEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func clearValue() -> GraphExplorer.Graph.MetanodeAttrEntry.Builder{
                    builderResult.hasValue = false
                    builderResult.value = ""
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> GraphExplorer.Graph.MetanodeAttrEntry.Builder {
                    builderResult = GraphExplorer.Graph.MetanodeAttrEntry()
                    return self
                }
                override public func clone() throws -> GraphExplorer.Graph.MetanodeAttrEntry.Builder {
                    return try GraphExplorer.Graph.MetanodeAttrEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> GraphExplorer.Graph.MetanodeAttrEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> GraphExplorer.Graph.MetanodeAttrEntry {
                    let returnMe:GraphExplorer.Graph.MetanodeAttrEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:GraphExplorer.Graph.MetanodeAttrEntry) throws -> GraphExplorer.Graph.MetanodeAttrEntry.Builder {
                    if other == GraphExplorer.Graph.MetanodeAttrEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if other.hasValue {
                        value = other.value
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> GraphExplorer.Graph.MetanodeAttrEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Graph.MetanodeAttrEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            key = try codedInputStream.readString()

                        case 18:
                            value = try codedInputStream.readString()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> GraphExplorer.Graph.MetanodeAttrEntry.Builder {
                    let resultDecodedBuilder = GraphExplorer.Graph.MetanodeAttrEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = jsonValueKey
                    }
                    if let jsonValueValue = jsonMap["value"] as? String {
                        resultDecodedBuilder.value = jsonValueValue
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> GraphExplorer.Graph.MetanodeAttrEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try GraphExplorer.Graph.MetanodeAttrEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        final public class EdgeAttrEntry : GeneratedMessage {

            public static func == (lhs: GraphExplorer.Graph.EdgeAttrEntry, rhs: GraphExplorer.Graph.EdgeAttrEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:String = ""
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:String = ""
            public fileprivate(set) var hasValue:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeString(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeString(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeStringSize(fieldNumber: 1)
                }
                if hasValue {
                    serialize_size += value.computeStringSize(fieldNumber: 2)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> GraphExplorer.Graph.EdgeAttrEntry.Builder {
                return GraphExplorer.Graph.EdgeAttrEntry.classBuilder() as! GraphExplorer.Graph.EdgeAttrEntry.Builder
            }
            public func getBuilder() -> GraphExplorer.Graph.EdgeAttrEntry.Builder {
                return classBuilder() as! GraphExplorer.Graph.EdgeAttrEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return GraphExplorer.Graph.EdgeAttrEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return GraphExplorer.Graph.EdgeAttrEntry.Builder()
            }
            public func toBuilder() throws -> GraphExplorer.Graph.EdgeAttrEntry.Builder {
                return try GraphExplorer.Graph.EdgeAttrEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:GraphExplorer.Graph.EdgeAttrEntry) throws -> GraphExplorer.Graph.EdgeAttrEntry.Builder {
                return try GraphExplorer.Graph.EdgeAttrEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = key
                }
                if hasValue {
                    jsonMap["value"] = value
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> GraphExplorer.Graph.EdgeAttrEntry {
                return try GraphExplorer.Graph.EdgeAttrEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> GraphExplorer.Graph.EdgeAttrEntry {
                return try GraphExplorer.Graph.EdgeAttrEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value: \(value) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        hashCode = (hashCode &* 31) &+ value.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "GraphExplorer.Graph.EdgeAttrEntry"
            }
            override public func className() -> String {
                return "GraphExplorer.Graph.EdgeAttrEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:GraphExplorer.Graph.EdgeAttrEntry = GraphExplorer.Graph.EdgeAttrEntry()
                public func getMessage() -> GraphExplorer.Graph.EdgeAttrEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:String {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:String) -> GraphExplorer.Graph.EdgeAttrEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> GraphExplorer.Graph.EdgeAttrEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = ""
                    return self
                }
                public var value:String {
                    get {
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                @discardableResult
                public func setValue(_ value:String) -> GraphExplorer.Graph.EdgeAttrEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func clearValue() -> GraphExplorer.Graph.EdgeAttrEntry.Builder{
                    builderResult.hasValue = false
                    builderResult.value = ""
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> GraphExplorer.Graph.EdgeAttrEntry.Builder {
                    builderResult = GraphExplorer.Graph.EdgeAttrEntry()
                    return self
                }
                override public func clone() throws -> GraphExplorer.Graph.EdgeAttrEntry.Builder {
                    return try GraphExplorer.Graph.EdgeAttrEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> GraphExplorer.Graph.EdgeAttrEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> GraphExplorer.Graph.EdgeAttrEntry {
                    let returnMe:GraphExplorer.Graph.EdgeAttrEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:GraphExplorer.Graph.EdgeAttrEntry) throws -> GraphExplorer.Graph.EdgeAttrEntry.Builder {
                    if other == GraphExplorer.Graph.EdgeAttrEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if other.hasValue {
                        value = other.value
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> GraphExplorer.Graph.EdgeAttrEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Graph.EdgeAttrEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            key = try codedInputStream.readString()

                        case 18:
                            value = try codedInputStream.readString()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> GraphExplorer.Graph.EdgeAttrEntry.Builder {
                    let resultDecodedBuilder = GraphExplorer.Graph.EdgeAttrEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = jsonValueKey
                    }
                    if let jsonValueValue = jsonMap["value"] as? String {
                        resultDecodedBuilder.value = jsonValueValue
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> GraphExplorer.Graph.EdgeAttrEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try GraphExplorer.Graph.EdgeAttrEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        final public class GraphAttrEntry : GeneratedMessage {

            public static func == (lhs: GraphExplorer.Graph.GraphAttrEntry, rhs: GraphExplorer.Graph.GraphAttrEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:String = ""
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:String = ""
            public fileprivate(set) var hasValue:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeString(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeString(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeStringSize(fieldNumber: 1)
                }
                if hasValue {
                    serialize_size += value.computeStringSize(fieldNumber: 2)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> GraphExplorer.Graph.GraphAttrEntry.Builder {
                return GraphExplorer.Graph.GraphAttrEntry.classBuilder() as! GraphExplorer.Graph.GraphAttrEntry.Builder
            }
            public func getBuilder() -> GraphExplorer.Graph.GraphAttrEntry.Builder {
                return classBuilder() as! GraphExplorer.Graph.GraphAttrEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return GraphExplorer.Graph.GraphAttrEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return GraphExplorer.Graph.GraphAttrEntry.Builder()
            }
            public func toBuilder() throws -> GraphExplorer.Graph.GraphAttrEntry.Builder {
                return try GraphExplorer.Graph.GraphAttrEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:GraphExplorer.Graph.GraphAttrEntry) throws -> GraphExplorer.Graph.GraphAttrEntry.Builder {
                return try GraphExplorer.Graph.GraphAttrEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = key
                }
                if hasValue {
                    jsonMap["value"] = value
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> GraphExplorer.Graph.GraphAttrEntry {
                return try GraphExplorer.Graph.GraphAttrEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> GraphExplorer.Graph.GraphAttrEntry {
                return try GraphExplorer.Graph.GraphAttrEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value: \(value) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        hashCode = (hashCode &* 31) &+ value.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "GraphExplorer.Graph.GraphAttrEntry"
            }
            override public func className() -> String {
                return "GraphExplorer.Graph.GraphAttrEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:GraphExplorer.Graph.GraphAttrEntry = GraphExplorer.Graph.GraphAttrEntry()
                public func getMessage() -> GraphExplorer.Graph.GraphAttrEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:String {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:String) -> GraphExplorer.Graph.GraphAttrEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> GraphExplorer.Graph.GraphAttrEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = ""
                    return self
                }
                public var value:String {
                    get {
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                @discardableResult
                public func setValue(_ value:String) -> GraphExplorer.Graph.GraphAttrEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func clearValue() -> GraphExplorer.Graph.GraphAttrEntry.Builder{
                    builderResult.hasValue = false
                    builderResult.value = ""
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> GraphExplorer.Graph.GraphAttrEntry.Builder {
                    builderResult = GraphExplorer.Graph.GraphAttrEntry()
                    return self
                }
                override public func clone() throws -> GraphExplorer.Graph.GraphAttrEntry.Builder {
                    return try GraphExplorer.Graph.GraphAttrEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> GraphExplorer.Graph.GraphAttrEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> GraphExplorer.Graph.GraphAttrEntry {
                    let returnMe:GraphExplorer.Graph.GraphAttrEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:GraphExplorer.Graph.GraphAttrEntry) throws -> GraphExplorer.Graph.GraphAttrEntry.Builder {
                    if other == GraphExplorer.Graph.GraphAttrEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if other.hasValue {
                        value = other.value
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> GraphExplorer.Graph.GraphAttrEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Graph.GraphAttrEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            key = try codedInputStream.readString()

                        case 18:
                            value = try codedInputStream.readString()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> GraphExplorer.Graph.GraphAttrEntry.Builder {
                    let resultDecodedBuilder = GraphExplorer.Graph.GraphAttrEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = jsonValueKey
                    }
                    if let jsonValueValue = jsonMap["value"] as? String {
                        resultDecodedBuilder.value = jsonValueValue
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> GraphExplorer.Graph.GraphAttrEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try GraphExplorer.Graph.GraphAttrEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        public fileprivate(set) var node:Array<GraphExplorer.Node>  = Array<GraphExplorer.Node>()
        public fileprivate(set) var edge:Array<GraphExplorer.Edge>  = Array<GraphExplorer.Edge>()
        /// Default values of node, metanode and edge attributes.
        public fileprivate(set) var nodeAttr:Dictionary<String,String> = Dictionary<String,String>()

        public fileprivate(set) var hasNodeAttr:Bool = false
        public fileprivate(set) var metanodeAttr:Dictionary<String,String> = Dictionary<String,String>()

        public fileprivate(set) var hasMetanodeAttr:Bool = false
        public fileprivate(set) var edgeAttr:Dictionary<String,String> = Dictionary<String,String>()

        public fileprivate(set) var hasEdgeAttr:Bool = false
        /// Graph attributes.
        public fileprivate(set) var graphAttr:Dictionary<String,String> = Dictionary<String,String>()

        public fileprivate(set) var hasGraphAttr:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementNode in node {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementNode)
            }
            for oneElementEdge in edge {
                  try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementEdge)
            }
            if hasNodeAttr {
                for (keyNodeAttr, valueNodeAttr) in nodeAttr {
                    let valueOfNodeAttr = try! GraphExplorer.Graph.NodeAttrEntry.Builder().setKey(keyNodeAttr).setValue(valueNodeAttr).build()
                      try codedOutputStream.writeMessage(fieldNumber: 3, value:valueOfNodeAttr)
                  }
            }
            if hasMetanodeAttr {
                for (keyMetanodeAttr, valueMetanodeAttr) in metanodeAttr {
                    let valueOfMetanodeAttr = try! GraphExplorer.Graph.MetanodeAttrEntry.Builder().setKey(keyMetanodeAttr).setValue(valueMetanodeAttr).build()
                      try codedOutputStream.writeMessage(fieldNumber: 4, value:valueOfMetanodeAttr)
                  }
            }
            if hasEdgeAttr {
                for (keyEdgeAttr, valueEdgeAttr) in edgeAttr {
                    let valueOfEdgeAttr = try! GraphExplorer.Graph.EdgeAttrEntry.Builder().setKey(keyEdgeAttr).setValue(valueEdgeAttr).build()
                      try codedOutputStream.writeMessage(fieldNumber: 5, value:valueOfEdgeAttr)
                  }
            }
            if hasGraphAttr {
                for (keyGraphAttr, valueGraphAttr) in graphAttr {
                    let valueOfGraphAttr = try! GraphExplorer.Graph.GraphAttrEntry.Builder().setKey(keyGraphAttr).setValue(valueGraphAttr).build()
                      try codedOutputStream.writeMessage(fieldNumber: 6, value:valueOfGraphAttr)
                  }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementNode in node {
                serialize_size += oneElementNode.computeMessageSize(fieldNumber: 1)
            }
            for oneElementEdge in edge {
                serialize_size += oneElementEdge.computeMessageSize(fieldNumber: 2)
            }
            if hasNodeAttr {
                  for (keyNodeAttr, valueNodeAttr) in nodeAttr {
                      let valueOfNodeAttr = try! GraphExplorer.Graph.NodeAttrEntry.Builder().setKey(keyNodeAttr).setValue(valueNodeAttr).build()
                serialize_size += valueOfNodeAttr.computeMessageSize(fieldNumber: 3)
                }
            }
            if hasMetanodeAttr {
                  for (keyMetanodeAttr, valueMetanodeAttr) in metanodeAttr {
                      let valueOfMetanodeAttr = try! GraphExplorer.Graph.MetanodeAttrEntry.Builder().setKey(keyMetanodeAttr).setValue(valueMetanodeAttr).build()
                serialize_size += valueOfMetanodeAttr.computeMessageSize(fieldNumber: 4)
                }
            }
            if hasEdgeAttr {
                  for (keyEdgeAttr, valueEdgeAttr) in edgeAttr {
                      let valueOfEdgeAttr = try! GraphExplorer.Graph.EdgeAttrEntry.Builder().setKey(keyEdgeAttr).setValue(valueEdgeAttr).build()
                serialize_size += valueOfEdgeAttr.computeMessageSize(fieldNumber: 5)
                }
            }
            if hasGraphAttr {
                  for (keyGraphAttr, valueGraphAttr) in graphAttr {
                      let valueOfGraphAttr = try! GraphExplorer.Graph.GraphAttrEntry.Builder().setKey(keyGraphAttr).setValue(valueGraphAttr).build()
                serialize_size += valueOfGraphAttr.computeMessageSize(fieldNumber: 6)
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> GraphExplorer.Graph.Builder {
            return GraphExplorer.Graph.classBuilder() as! GraphExplorer.Graph.Builder
        }
        public func getBuilder() -> GraphExplorer.Graph.Builder {
            return classBuilder() as! GraphExplorer.Graph.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return GraphExplorer.Graph.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return GraphExplorer.Graph.Builder()
        }
        public func toBuilder() throws -> GraphExplorer.Graph.Builder {
            return try GraphExplorer.Graph.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:GraphExplorer.Graph) throws -> GraphExplorer.Graph.Builder {
            return try GraphExplorer.Graph.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !node.isEmpty {
                var jsonArrayNode:Array<Dictionary<String,Any>> = []
                for oneValueNode in node {
                    let ecodedMessageNode = try oneValueNode.encode()
                    jsonArrayNode.append(ecodedMessageNode)
                }
                jsonMap["node"] = jsonArrayNode
            }
            if !edge.isEmpty {
                var jsonArrayEdge:Array<Dictionary<String,Any>> = []
                for oneValueEdge in edge {
                    let ecodedMessageEdge = try oneValueEdge.encode()
                    jsonArrayEdge.append(ecodedMessageEdge)
                }
                jsonMap["edge"] = jsonArrayEdge
            }
            if hasNodeAttr {
                var mapNodeAttr = Dictionary<String, String>()
                for (keyNodeAttr, valueNodeAttr) in nodeAttr {
                    mapNodeAttr["\(keyNodeAttr)"] = valueNodeAttr
                }
                jsonMap["nodeAttr"] = mapNodeAttr
            }
            if hasMetanodeAttr {
                var mapMetanodeAttr = Dictionary<String, String>()
                for (keyMetanodeAttr, valueMetanodeAttr) in metanodeAttr {
                    mapMetanodeAttr["\(keyMetanodeAttr)"] = valueMetanodeAttr
                }
                jsonMap["metanodeAttr"] = mapMetanodeAttr
            }
            if hasEdgeAttr {
                var mapEdgeAttr = Dictionary<String, String>()
                for (keyEdgeAttr, valueEdgeAttr) in edgeAttr {
                    mapEdgeAttr["\(keyEdgeAttr)"] = valueEdgeAttr
                }
                jsonMap["edgeAttr"] = mapEdgeAttr
            }
            if hasGraphAttr {
                var mapGraphAttr = Dictionary<String, String>()
                for (keyGraphAttr, valueGraphAttr) in graphAttr {
                    mapGraphAttr["\(keyGraphAttr)"] = valueGraphAttr
                }
                jsonMap["graphAttr"] = mapGraphAttr
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> GraphExplorer.Graph {
            return try GraphExplorer.Graph.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> GraphExplorer.Graph {
            return try GraphExplorer.Graph.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var nodeElementIndex:Int = 0
            for oneElementNode in node {
                output += "\(indent) node[\(nodeElementIndex)] {\n"
                output += try oneElementNode.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                nodeElementIndex += 1
            }
            var edgeElementIndex:Int = 0
            for oneElementEdge in edge {
                output += "\(indent) edge[\(edgeElementIndex)] {\n"
                output += try oneElementEdge.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                edgeElementIndex += 1
            }
            if hasNodeAttr {
                output += "\(indent) nodeAttr: \(nodeAttr) \n"
            }
            if hasMetanodeAttr {
                output += "\(indent) metanodeAttr: \(metanodeAttr) \n"
            }
            if hasEdgeAttr {
                output += "\(indent) edgeAttr: \(edgeAttr) \n"
            }
            if hasGraphAttr {
                output += "\(indent) graphAttr: \(graphAttr) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementNode in node {
                    hashCode = (hashCode &* 31) &+ oneElementNode.hashValue
                }
                for oneElementEdge in edge {
                    hashCode = (hashCode &* 31) &+ oneElementEdge.hashValue
                }
                if hasNodeAttr {
                    for (keyNodeAttr, valueNodeAttr) in nodeAttr {
                        hashCode = (hashCode &* 31) &+ keyNodeAttr.hashValue
                        hashCode = (hashCode &* 31) &+ valueNodeAttr.hashValue
                    }
                }
                if hasMetanodeAttr {
                    for (keyMetanodeAttr, valueMetanodeAttr) in metanodeAttr {
                        hashCode = (hashCode &* 31) &+ keyMetanodeAttr.hashValue
                        hashCode = (hashCode &* 31) &+ valueMetanodeAttr.hashValue
                    }
                }
                if hasEdgeAttr {
                    for (keyEdgeAttr, valueEdgeAttr) in edgeAttr {
                        hashCode = (hashCode &* 31) &+ keyEdgeAttr.hashValue
                        hashCode = (hashCode &* 31) &+ valueEdgeAttr.hashValue
                    }
                }
                if hasGraphAttr {
                    for (keyGraphAttr, valueGraphAttr) in graphAttr {
                        hashCode = (hashCode &* 31) &+ keyGraphAttr.hashValue
                        hashCode = (hashCode &* 31) &+ valueGraphAttr.hashValue
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "GraphExplorer.Graph"
        }
        override public func className() -> String {
            return "GraphExplorer.Graph"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:GraphExplorer.Graph = GraphExplorer.Graph()
            public func getMessage() -> GraphExplorer.Graph {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// List of nodes in the graph.
            public var node:Array<GraphExplorer.Node> {
                get {
                    return builderResult.node
                }
                set (value) {
                    builderResult.node = value
                }
            }
            @discardableResult
            public func setNode(_ value:Array<GraphExplorer.Node>) -> GraphExplorer.Graph.Builder {
                self.node = value
                return self
            }
            @discardableResult
            public func clearNode() -> GraphExplorer.Graph.Builder {
                builderResult.node.removeAll(keepingCapacity: false)
                return self
            }
            /// List of edges in the graph.
            public var edge:Array<GraphExplorer.Edge> {
                get {
                    return builderResult.edge
                }
                set (value) {
                    builderResult.edge = value
                }
            }
            @discardableResult
            public func setEdge(_ value:Array<GraphExplorer.Edge>) -> GraphExplorer.Graph.Builder {
                self.edge = value
                return self
            }
            @discardableResult
            public func clearEdge() -> GraphExplorer.Graph.Builder {
                builderResult.edge.removeAll(keepingCapacity: false)
                return self
            }
            /// Default values of node, metanode and edge attributes.
            public var hasNodeAttr:Bool {
                get {
                    return builderResult.hasNodeAttr
                }
            }
            public var nodeAttr:Dictionary<String,String> {
                get {
                    return builderResult.nodeAttr
                }
                set (value) {
                    builderResult.hasNodeAttr = true
                    builderResult.nodeAttr = value
                }
            }
            @discardableResult
            public func setNodeAttr(_ value:Dictionary<String,String>) -> GraphExplorer.Graph.Builder {
                self.nodeAttr = value
                return self
            }
            @discardableResult
            public func clearNodeAttr() -> GraphExplorer.Graph.Builder{
                builderResult.hasNodeAttr = false
                builderResult.nodeAttr = Dictionary<String,String>()
                return self
            }
            public var hasMetanodeAttr:Bool {
                get {
                    return builderResult.hasMetanodeAttr
                }
            }
            public var metanodeAttr:Dictionary<String,String> {
                get {
                    return builderResult.metanodeAttr
                }
                set (value) {
                    builderResult.hasMetanodeAttr = true
                    builderResult.metanodeAttr = value
                }
            }
            @discardableResult
            public func setMetanodeAttr(_ value:Dictionary<String,String>) -> GraphExplorer.Graph.Builder {
                self.metanodeAttr = value
                return self
            }
            @discardableResult
            public func clearMetanodeAttr() -> GraphExplorer.Graph.Builder{
                builderResult.hasMetanodeAttr = false
                builderResult.metanodeAttr = Dictionary<String,String>()
                return self
            }
            public var hasEdgeAttr:Bool {
                get {
                    return builderResult.hasEdgeAttr
                }
            }
            public var edgeAttr:Dictionary<String,String> {
                get {
                    return builderResult.edgeAttr
                }
                set (value) {
                    builderResult.hasEdgeAttr = true
                    builderResult.edgeAttr = value
                }
            }
            @discardableResult
            public func setEdgeAttr(_ value:Dictionary<String,String>) -> GraphExplorer.Graph.Builder {
                self.edgeAttr = value
                return self
            }
            @discardableResult
            public func clearEdgeAttr() -> GraphExplorer.Graph.Builder{
                builderResult.hasEdgeAttr = false
                builderResult.edgeAttr = Dictionary<String,String>()
                return self
            }
            /// Graph attributes.
            public var hasGraphAttr:Bool {
                get {
                    return builderResult.hasGraphAttr
                }
            }
            public var graphAttr:Dictionary<String,String> {
                get {
                    return builderResult.graphAttr
                }
                set (value) {
                    builderResult.hasGraphAttr = true
                    builderResult.graphAttr = value
                }
            }
            @discardableResult
            public func setGraphAttr(_ value:Dictionary<String,String>) -> GraphExplorer.Graph.Builder {
                self.graphAttr = value
                return self
            }
            @discardableResult
            public func clearGraphAttr() -> GraphExplorer.Graph.Builder{
                builderResult.hasGraphAttr = false
                builderResult.graphAttr = Dictionary<String,String>()
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> GraphExplorer.Graph.Builder {
                builderResult = GraphExplorer.Graph()
                return self
            }
            override public func clone() throws -> GraphExplorer.Graph.Builder {
                return try GraphExplorer.Graph.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> GraphExplorer.Graph {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> GraphExplorer.Graph {
                let returnMe:GraphExplorer.Graph = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:GraphExplorer.Graph) throws -> GraphExplorer.Graph.Builder {
                if other == GraphExplorer.Graph() {
                    return self
                }
                if !other.node.isEmpty  {
                     builderResult.node += other.node
                }
                if !other.edge.isEmpty  {
                     builderResult.edge += other.edge
                }
                if other.hasNodeAttr {
                    nodeAttr = other.nodeAttr
                }
                if other.hasMetanodeAttr {
                    metanodeAttr = other.metanodeAttr
                }
                if other.hasEdgeAttr {
                    edgeAttr = other.edgeAttr
                }
                if other.hasGraphAttr {
                    graphAttr = other.graphAttr
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> GraphExplorer.Graph.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Graph.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = GraphExplorer.Node.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        node.append(subBuilder.buildPartial())

                    case 18:
                        let subBuilder = GraphExplorer.Edge.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        edge.append(subBuilder.buildPartial())

                    case 26:
                        let subBuilder = GraphExplorer.Graph.NodeAttrEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfNodeAttr = subBuilder.buildPartial()
                        nodeAttr[buildOfNodeAttr.key] = buildOfNodeAttr.value

                    case 34:
                        let subBuilder = GraphExplorer.Graph.MetanodeAttrEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfMetanodeAttr = subBuilder.buildPartial()
                        metanodeAttr[buildOfMetanodeAttr.key] = buildOfMetanodeAttr.value

                    case 42:
                        let subBuilder = GraphExplorer.Graph.EdgeAttrEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfEdgeAttr = subBuilder.buildPartial()
                        edgeAttr[buildOfEdgeAttr.key] = buildOfEdgeAttr.value

                    case 50:
                        let subBuilder = GraphExplorer.Graph.GraphAttrEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfGraphAttr = subBuilder.buildPartial()
                        graphAttr[buildOfGraphAttr.key] = buildOfGraphAttr.value

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> GraphExplorer.Graph.Builder {
                let resultDecodedBuilder = GraphExplorer.Graph.Builder()
                if let jsonValueNode = jsonMap["node"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayNode:Array<GraphExplorer.Node> = []
                    for oneValueNode in jsonValueNode {
                        let messageFromStringNode = try GraphExplorer.Node.Builder.decodeToBuilder(jsonMap:oneValueNode).build()

                        jsonArrayNode.append(messageFromStringNode)
                    }
                    resultDecodedBuilder.node = jsonArrayNode
                }
                if let jsonValueEdge = jsonMap["edge"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayEdge:Array<GraphExplorer.Edge> = []
                    for oneValueEdge in jsonValueEdge {
                        let messageFromStringEdge = try GraphExplorer.Edge.Builder.decodeToBuilder(jsonMap:oneValueEdge).build()

                        jsonArrayEdge.append(messageFromStringEdge)
                    }
                    resultDecodedBuilder.edge = jsonArrayEdge
                }
                if let jsonValueNodeAttr = jsonMap["nodeAttr"] as? Dictionary<String, String> {
                    var mapNodeAttr = Dictionary<String, String>()
                    for (keyNodeAttr, valueNodeAttr) in jsonValueNodeAttr {
                        guard let keyFromNodeAttr = String(keyNodeAttr) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapNodeAttr[keyFromNodeAttr] = valueNodeAttr
                    }
                    resultDecodedBuilder.nodeAttr = mapNodeAttr
                }
                if let jsonValueMetanodeAttr = jsonMap["metanodeAttr"] as? Dictionary<String, String> {
                    var mapMetanodeAttr = Dictionary<String, String>()
                    for (keyMetanodeAttr, valueMetanodeAttr) in jsonValueMetanodeAttr {
                        guard let keyFromMetanodeAttr = String(keyMetanodeAttr) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapMetanodeAttr[keyFromMetanodeAttr] = valueMetanodeAttr
                    }
                    resultDecodedBuilder.metanodeAttr = mapMetanodeAttr
                }
                if let jsonValueEdgeAttr = jsonMap["edgeAttr"] as? Dictionary<String, String> {
                    var mapEdgeAttr = Dictionary<String, String>()
                    for (keyEdgeAttr, valueEdgeAttr) in jsonValueEdgeAttr {
                        guard let keyFromEdgeAttr = String(keyEdgeAttr) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapEdgeAttr[keyFromEdgeAttr] = valueEdgeAttr
                    }
                    resultDecodedBuilder.edgeAttr = mapEdgeAttr
                }
                if let jsonValueGraphAttr = jsonMap["graphAttr"] as? Dictionary<String, String> {
                    var mapGraphAttr = Dictionary<String, String>()
                    for (keyGraphAttr, valueGraphAttr) in jsonValueGraphAttr {
                        guard let keyFromGraphAttr = String(keyGraphAttr) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapGraphAttr[keyFromGraphAttr] = valueGraphAttr
                    }
                    resultDecodedBuilder.graphAttr = mapGraphAttr
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> GraphExplorer.Graph.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try GraphExplorer.Graph.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension GraphExplorer.Node: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<GraphExplorer.Node> {
        var mergedArray = Array<GraphExplorer.Node>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> GraphExplorer.Node? {
        return try GraphExplorer.Node.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> GraphExplorer.Node {
        return try GraphExplorer.Node.Builder().mergeFrom(data: data, extensionRegistry:GraphExplorer.GraphExplorerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Node {
        return try GraphExplorer.Node.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> GraphExplorer.Node {
        return try GraphExplorer.Node.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Node {
        return try GraphExplorer.Node.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> GraphExplorer.Node {
        return try GraphExplorer.Node.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Node {
        return try GraphExplorer.Node.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "name": return self.name
        case "nodeAttr": return self.nodeAttr
        case "metanodeAttr": return self.metanodeAttr
        default: return nil
        }
    }
}
extension GraphExplorer.Node.NodeAttrEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<GraphExplorer.Node.NodeAttrEntry> {
        var mergedArray = Array<GraphExplorer.Node.NodeAttrEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> GraphExplorer.Node.NodeAttrEntry? {
        return try GraphExplorer.Node.NodeAttrEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> GraphExplorer.Node.NodeAttrEntry {
        return try GraphExplorer.Node.NodeAttrEntry.Builder().mergeFrom(data: data, extensionRegistry:GraphExplorer.GraphExplorerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Node.NodeAttrEntry {
        return try GraphExplorer.Node.NodeAttrEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> GraphExplorer.Node.NodeAttrEntry {
        return try GraphExplorer.Node.NodeAttrEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Node.NodeAttrEntry {
        return try GraphExplorer.Node.NodeAttrEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> GraphExplorer.Node.NodeAttrEntry {
        return try GraphExplorer.Node.NodeAttrEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Node.NodeAttrEntry {
        return try GraphExplorer.Node.NodeAttrEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension GraphExplorer.Node.MetanodeAttrEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<GraphExplorer.Node.MetanodeAttrEntry> {
        var mergedArray = Array<GraphExplorer.Node.MetanodeAttrEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> GraphExplorer.Node.MetanodeAttrEntry? {
        return try GraphExplorer.Node.MetanodeAttrEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> GraphExplorer.Node.MetanodeAttrEntry {
        return try GraphExplorer.Node.MetanodeAttrEntry.Builder().mergeFrom(data: data, extensionRegistry:GraphExplorer.GraphExplorerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Node.MetanodeAttrEntry {
        return try GraphExplorer.Node.MetanodeAttrEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> GraphExplorer.Node.MetanodeAttrEntry {
        return try GraphExplorer.Node.MetanodeAttrEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Node.MetanodeAttrEntry {
        return try GraphExplorer.Node.MetanodeAttrEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> GraphExplorer.Node.MetanodeAttrEntry {
        return try GraphExplorer.Node.MetanodeAttrEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Node.MetanodeAttrEntry {
        return try GraphExplorer.Node.MetanodeAttrEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension GraphExplorer.Node.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "name": return self.name
            case "nodeAttr": return self.nodeAttr
            case "metanodeAttr": return self.metanodeAttr
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "nodeAttr":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,String> else {
                    return
                }
                self.nodeAttr = newSubscriptValue
            case "metanodeAttr":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,String> else {
                    return
                }
                self.metanodeAttr = newSubscriptValue
            default: return
            }
        }
    }
}
extension GraphExplorer.Node.NodeAttrEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension GraphExplorer.Node.MetanodeAttrEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension GraphExplorer.Edge: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<GraphExplorer.Edge> {
        var mergedArray = Array<GraphExplorer.Edge>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> GraphExplorer.Edge? {
        return try GraphExplorer.Edge.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> GraphExplorer.Edge {
        return try GraphExplorer.Edge.Builder().mergeFrom(data: data, extensionRegistry:GraphExplorer.GraphExplorerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Edge {
        return try GraphExplorer.Edge.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> GraphExplorer.Edge {
        return try GraphExplorer.Edge.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Edge {
        return try GraphExplorer.Edge.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> GraphExplorer.Edge {
        return try GraphExplorer.Edge.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Edge {
        return try GraphExplorer.Edge.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "source": return self.source
        case "target": return self.target
        case "edgeAttr": return self.edgeAttr
        default: return nil
        }
    }
}
extension GraphExplorer.Edge.EdgeAttrEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<GraphExplorer.Edge.EdgeAttrEntry> {
        var mergedArray = Array<GraphExplorer.Edge.EdgeAttrEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> GraphExplorer.Edge.EdgeAttrEntry? {
        return try GraphExplorer.Edge.EdgeAttrEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> GraphExplorer.Edge.EdgeAttrEntry {
        return try GraphExplorer.Edge.EdgeAttrEntry.Builder().mergeFrom(data: data, extensionRegistry:GraphExplorer.GraphExplorerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Edge.EdgeAttrEntry {
        return try GraphExplorer.Edge.EdgeAttrEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> GraphExplorer.Edge.EdgeAttrEntry {
        return try GraphExplorer.Edge.EdgeAttrEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Edge.EdgeAttrEntry {
        return try GraphExplorer.Edge.EdgeAttrEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> GraphExplorer.Edge.EdgeAttrEntry {
        return try GraphExplorer.Edge.EdgeAttrEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Edge.EdgeAttrEntry {
        return try GraphExplorer.Edge.EdgeAttrEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension GraphExplorer.Edge.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "source": return self.source
            case "target": return self.target
            case "edgeAttr": return self.edgeAttr
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "source":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.source = newSubscriptValue
            case "target":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.target = newSubscriptValue
            case "edgeAttr":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,String> else {
                    return
                }
                self.edgeAttr = newSubscriptValue
            default: return
            }
        }
    }
}
extension GraphExplorer.Edge.EdgeAttrEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension GraphExplorer.Graph: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<GraphExplorer.Graph> {
        var mergedArray = Array<GraphExplorer.Graph>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> GraphExplorer.Graph? {
        return try GraphExplorer.Graph.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> GraphExplorer.Graph {
        return try GraphExplorer.Graph.Builder().mergeFrom(data: data, extensionRegistry:GraphExplorer.GraphExplorerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Graph {
        return try GraphExplorer.Graph.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> GraphExplorer.Graph {
        return try GraphExplorer.Graph.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Graph {
        return try GraphExplorer.Graph.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> GraphExplorer.Graph {
        return try GraphExplorer.Graph.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Graph {
        return try GraphExplorer.Graph.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "node": return self.node
        case "edge": return self.edge
        case "nodeAttr": return self.nodeAttr
        case "metanodeAttr": return self.metanodeAttr
        case "edgeAttr": return self.edgeAttr
        case "graphAttr": return self.graphAttr
        default: return nil
        }
    }
}
extension GraphExplorer.Graph.NodeAttrEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<GraphExplorer.Graph.NodeAttrEntry> {
        var mergedArray = Array<GraphExplorer.Graph.NodeAttrEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> GraphExplorer.Graph.NodeAttrEntry? {
        return try GraphExplorer.Graph.NodeAttrEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> GraphExplorer.Graph.NodeAttrEntry {
        return try GraphExplorer.Graph.NodeAttrEntry.Builder().mergeFrom(data: data, extensionRegistry:GraphExplorer.GraphExplorerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Graph.NodeAttrEntry {
        return try GraphExplorer.Graph.NodeAttrEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> GraphExplorer.Graph.NodeAttrEntry {
        return try GraphExplorer.Graph.NodeAttrEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Graph.NodeAttrEntry {
        return try GraphExplorer.Graph.NodeAttrEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> GraphExplorer.Graph.NodeAttrEntry {
        return try GraphExplorer.Graph.NodeAttrEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Graph.NodeAttrEntry {
        return try GraphExplorer.Graph.NodeAttrEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension GraphExplorer.Graph.MetanodeAttrEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<GraphExplorer.Graph.MetanodeAttrEntry> {
        var mergedArray = Array<GraphExplorer.Graph.MetanodeAttrEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> GraphExplorer.Graph.MetanodeAttrEntry? {
        return try GraphExplorer.Graph.MetanodeAttrEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> GraphExplorer.Graph.MetanodeAttrEntry {
        return try GraphExplorer.Graph.MetanodeAttrEntry.Builder().mergeFrom(data: data, extensionRegistry:GraphExplorer.GraphExplorerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Graph.MetanodeAttrEntry {
        return try GraphExplorer.Graph.MetanodeAttrEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> GraphExplorer.Graph.MetanodeAttrEntry {
        return try GraphExplorer.Graph.MetanodeAttrEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Graph.MetanodeAttrEntry {
        return try GraphExplorer.Graph.MetanodeAttrEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> GraphExplorer.Graph.MetanodeAttrEntry {
        return try GraphExplorer.Graph.MetanodeAttrEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Graph.MetanodeAttrEntry {
        return try GraphExplorer.Graph.MetanodeAttrEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension GraphExplorer.Graph.EdgeAttrEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<GraphExplorer.Graph.EdgeAttrEntry> {
        var mergedArray = Array<GraphExplorer.Graph.EdgeAttrEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> GraphExplorer.Graph.EdgeAttrEntry? {
        return try GraphExplorer.Graph.EdgeAttrEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> GraphExplorer.Graph.EdgeAttrEntry {
        return try GraphExplorer.Graph.EdgeAttrEntry.Builder().mergeFrom(data: data, extensionRegistry:GraphExplorer.GraphExplorerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Graph.EdgeAttrEntry {
        return try GraphExplorer.Graph.EdgeAttrEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> GraphExplorer.Graph.EdgeAttrEntry {
        return try GraphExplorer.Graph.EdgeAttrEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Graph.EdgeAttrEntry {
        return try GraphExplorer.Graph.EdgeAttrEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> GraphExplorer.Graph.EdgeAttrEntry {
        return try GraphExplorer.Graph.EdgeAttrEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Graph.EdgeAttrEntry {
        return try GraphExplorer.Graph.EdgeAttrEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension GraphExplorer.Graph.GraphAttrEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<GraphExplorer.Graph.GraphAttrEntry> {
        var mergedArray = Array<GraphExplorer.Graph.GraphAttrEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> GraphExplorer.Graph.GraphAttrEntry? {
        return try GraphExplorer.Graph.GraphAttrEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> GraphExplorer.Graph.GraphAttrEntry {
        return try GraphExplorer.Graph.GraphAttrEntry.Builder().mergeFrom(data: data, extensionRegistry:GraphExplorer.GraphExplorerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Graph.GraphAttrEntry {
        return try GraphExplorer.Graph.GraphAttrEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> GraphExplorer.Graph.GraphAttrEntry {
        return try GraphExplorer.Graph.GraphAttrEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Graph.GraphAttrEntry {
        return try GraphExplorer.Graph.GraphAttrEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> GraphExplorer.Graph.GraphAttrEntry {
        return try GraphExplorer.Graph.GraphAttrEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GraphExplorer.Graph.GraphAttrEntry {
        return try GraphExplorer.Graph.GraphAttrEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension GraphExplorer.Graph.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "node": return self.node
            case "edge": return self.edge
            case "nodeAttr": return self.nodeAttr
            case "metanodeAttr": return self.metanodeAttr
            case "edgeAttr": return self.edgeAttr
            case "graphAttr": return self.graphAttr
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "node":
                guard let newSubscriptValue = newSubscriptValue as? Array<GraphExplorer.Node> else {
                    return
                }
                self.node = newSubscriptValue
            case "edge":
                guard let newSubscriptValue = newSubscriptValue as? Array<GraphExplorer.Edge> else {
                    return
                }
                self.edge = newSubscriptValue
            case "nodeAttr":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,String> else {
                    return
                }
                self.nodeAttr = newSubscriptValue
            case "metanodeAttr":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,String> else {
                    return
                }
                self.metanodeAttr = newSubscriptValue
            case "edgeAttr":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,String> else {
                    return
                }
                self.edgeAttr = newSubscriptValue
            case "graphAttr":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,String> else {
                    return
                }
                self.graphAttr = newSubscriptValue
            default: return
            }
        }
    }
}
extension GraphExplorer.Graph.NodeAttrEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension GraphExplorer.Graph.MetanodeAttrEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension GraphExplorer.Graph.EdgeAttrEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension GraphExplorer.Graph.GraphAttrEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

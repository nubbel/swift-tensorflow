// Code generated by protoc-gen-go.
// source: serving/tensorflow/compiler/xla/service/hlo.proto
// DO NOT EDIT!

/*
Package xla is a generated protocol buffer package.

It is generated from these files:
	serving/tensorflow/compiler/xla/service/hlo.proto

It has these top-level messages:
	HloInstructionProto
	HloComputationProto
	HloModuleProto
	HloOrderingProto
	LogicalBufferProto
	BufferAllocationProto
	HeapSimulatorTrace
	BufferAssignmentProto
	HloProto
*/
package xla

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import xla1 "tensorflow/compiler/xla"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type HeapSimulatorTrace_Event_Kind int32

const (
	HeapSimulatorTrace_Event_ALLOC HeapSimulatorTrace_Event_Kind = 0
	HeapSimulatorTrace_Event_FREE  HeapSimulatorTrace_Event_Kind = 1
	// A buffer was shared with another (canonical) buffer. This is similar to
	// ALLOC, except that instead of allocating a new region of memory, the
	// memory region of the canonical buffer is directly re-used. Multiple
	// buffers may share with the same canonical buffer. The lifetime of the
	// canonical buffer is extended to the union of all lifetimes.
	HeapSimulatorTrace_Event_SHARE_WITH HeapSimulatorTrace_Event_Kind = 2
)

var HeapSimulatorTrace_Event_Kind_name = map[int32]string{
	0: "ALLOC",
	1: "FREE",
	2: "SHARE_WITH",
}
var HeapSimulatorTrace_Event_Kind_value = map[string]int32{
	"ALLOC":      0,
	"FREE":       1,
	"SHARE_WITH": 2,
}

func (x HeapSimulatorTrace_Event_Kind) String() string {
	return proto.EnumName(HeapSimulatorTrace_Event_Kind_name, int32(x))
}
func (HeapSimulatorTrace_Event_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{6, 0, 0}
}

// Serialization of HloInstruction.
type HloInstructionProto struct {
	Name                    string           `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Opcode                  string           `protobuf:"bytes,2,opt,name=opcode" json:"opcode,omitempty"`
	Shape                   *xla1.Shape      `protobuf:"bytes,3,opt,name=shape" json:"shape,omitempty"`
	OperandNames            []string         `protobuf:"bytes,4,rep,name=operand_names,json=operandNames" json:"operand_names,omitempty"`
	ControlPredecessorNames []string         `protobuf:"bytes,5,rep,name=control_predecessor_names,json=controlPredecessorNames" json:"control_predecessor_names,omitempty"`
	CalledComputationNames  []string         `protobuf:"bytes,6,rep,name=called_computation_names,json=calledComputationNames" json:"called_computation_names,omitempty"`
	Metadata                *xla1.OpMetadata `protobuf:"bytes,7,opt,name=metadata" json:"metadata,omitempty"`
	// Literal, only present for kConstant.
	Literal *xla1.Literal `protobuf:"bytes,8,opt,name=literal" json:"literal,omitempty"`
	// Parameter info, only present for kParameter.
	ParameterNumber int64  `protobuf:"varint,9,opt,name=parameter_number,json=parameterNumber" json:"parameter_number,omitempty"`
	ParameterName   string `protobuf:"bytes,10,opt,name=parameter_name,json=parameterName" json:"parameter_name,omitempty"`
	// Fusion state, only present for kFusion.
	FusionKind                   string               `protobuf:"bytes,11,opt,name=fusion_kind,json=fusionKind" json:"fusion_kind,omitempty"`
	FusedInstructionsComputation *HloComputationProto `protobuf:"bytes,12,opt,name=fused_instructions_computation,json=fusedInstructionsComputation" json:"fused_instructions_computation,omitempty"`
	// Index for kGetTupleElement.
	TupleIndex int64 `protobuf:"varint,13,opt,name=tuple_index,json=tupleIndex" json:"tuple_index,omitempty"`
}

func (m *HloInstructionProto) Reset()                    { *m = HloInstructionProto{} }
func (m *HloInstructionProto) String() string            { return proto.CompactTextString(m) }
func (*HloInstructionProto) ProtoMessage()               {}
func (*HloInstructionProto) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *HloInstructionProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HloInstructionProto) GetOpcode() string {
	if m != nil {
		return m.Opcode
	}
	return ""
}

func (m *HloInstructionProto) GetShape() *xla1.Shape {
	if m != nil {
		return m.Shape
	}
	return nil
}

func (m *HloInstructionProto) GetOperandNames() []string {
	if m != nil {
		return m.OperandNames
	}
	return nil
}

func (m *HloInstructionProto) GetControlPredecessorNames() []string {
	if m != nil {
		return m.ControlPredecessorNames
	}
	return nil
}

func (m *HloInstructionProto) GetCalledComputationNames() []string {
	if m != nil {
		return m.CalledComputationNames
	}
	return nil
}

func (m *HloInstructionProto) GetMetadata() *xla1.OpMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *HloInstructionProto) GetLiteral() *xla1.Literal {
	if m != nil {
		return m.Literal
	}
	return nil
}

func (m *HloInstructionProto) GetParameterNumber() int64 {
	if m != nil {
		return m.ParameterNumber
	}
	return 0
}

func (m *HloInstructionProto) GetParameterName() string {
	if m != nil {
		return m.ParameterName
	}
	return ""
}

func (m *HloInstructionProto) GetFusionKind() string {
	if m != nil {
		return m.FusionKind
	}
	return ""
}

func (m *HloInstructionProto) GetFusedInstructionsComputation() *HloComputationProto {
	if m != nil {
		return m.FusedInstructionsComputation
	}
	return nil
}

func (m *HloInstructionProto) GetTupleIndex() int64 {
	if m != nil {
		return m.TupleIndex
	}
	return 0
}

// Serialization of HloComputation.
type HloComputationProto struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The array of instructions is always in a valid dependency order, where
	// operands appear before their users.
	Instructions []*HloInstructionProto `protobuf:"bytes,2,rep,name=instructions" json:"instructions,omitempty"`
}

func (m *HloComputationProto) Reset()                    { *m = HloComputationProto{} }
func (m *HloComputationProto) String() string            { return proto.CompactTextString(m) }
func (*HloComputationProto) ProtoMessage()               {}
func (*HloComputationProto) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *HloComputationProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HloComputationProto) GetInstructions() []*HloInstructionProto {
	if m != nil {
		return m.Instructions
	}
	return nil
}

// Serialization of HloModule.
type HloModuleProto struct {
	Name                 string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	EntryComputationName string `protobuf:"bytes,2,opt,name=entry_computation_name,json=entryComputationName" json:"entry_computation_name,omitempty"`
	// The array of computations is always in a valid dependency order, where
	// callees appear before their callers.
	Computations []*HloComputationProto `protobuf:"bytes,3,rep,name=computations" json:"computations,omitempty"`
}

func (m *HloModuleProto) Reset()                    { *m = HloModuleProto{} }
func (m *HloModuleProto) String() string            { return proto.CompactTextString(m) }
func (*HloModuleProto) ProtoMessage()               {}
func (*HloModuleProto) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *HloModuleProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HloModuleProto) GetEntryComputationName() string {
	if m != nil {
		return m.EntryComputationName
	}
	return ""
}

func (m *HloModuleProto) GetComputations() []*HloComputationProto {
	if m != nil {
		return m.Computations
	}
	return nil
}

// Serialization of HloOrdering.
type HloOrderingProto struct {
	SequentialComputations []*HloOrderingProto_SequentialComputation `protobuf:"bytes,1,rep,name=sequential_computations,json=sequentialComputations" json:"sequential_computations,omitempty"`
}

func (m *HloOrderingProto) Reset()                    { *m = HloOrderingProto{} }
func (m *HloOrderingProto) String() string            { return proto.CompactTextString(m) }
func (*HloOrderingProto) ProtoMessage()               {}
func (*HloOrderingProto) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *HloOrderingProto) GetSequentialComputations() []*HloOrderingProto_SequentialComputation {
	if m != nil {
		return m.SequentialComputations
	}
	return nil
}

// NOTE: currently only sequential orderings are serialized.
type HloOrderingProto_SequentialComputation struct {
	ComputationName  string   `protobuf:"bytes,1,opt,name=computation_name,json=computationName" json:"computation_name,omitempty"`
	InstructionNames []string `protobuf:"bytes,2,rep,name=instruction_names,json=instructionNames" json:"instruction_names,omitempty"`
}

func (m *HloOrderingProto_SequentialComputation) Reset() {
	*m = HloOrderingProto_SequentialComputation{}
}
func (m *HloOrderingProto_SequentialComputation) String() string { return proto.CompactTextString(m) }
func (*HloOrderingProto_SequentialComputation) ProtoMessage()    {}
func (*HloOrderingProto_SequentialComputation) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{3, 0}
}

func (m *HloOrderingProto_SequentialComputation) GetComputationName() string {
	if m != nil {
		return m.ComputationName
	}
	return ""
}

func (m *HloOrderingProto_SequentialComputation) GetInstructionNames() []string {
	if m != nil {
		return m.InstructionNames
	}
	return nil
}

// Serialization of LogicalBuffer.
type LogicalBufferProto struct {
	Id   int64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	Size int64 `protobuf:"varint,2,opt,name=size" json:"size,omitempty"`
	// The location where the buffer is defined.
	DefinedAt *LogicalBufferProto_Location `protobuf:"bytes,3,opt,name=defined_at,json=definedAt" json:"defined_at,omitempty"`
}

func (m *LogicalBufferProto) Reset()                    { *m = LogicalBufferProto{} }
func (m *LogicalBufferProto) String() string            { return proto.CompactTextString(m) }
func (*LogicalBufferProto) ProtoMessage()               {}
func (*LogicalBufferProto) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *LogicalBufferProto) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *LogicalBufferProto) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *LogicalBufferProto) GetDefinedAt() *LogicalBufferProto_Location {
	if m != nil {
		return m.DefinedAt
	}
	return nil
}

// Location represents an instruction and its shape index, which uniquely
// identifies a point where a buffer is needed.
type LogicalBufferProto_Location struct {
	// NOTE: module_name isn't necessary, since all LogicalBuffers are
	// associated with a single HloModule.
	ComputationName string  `protobuf:"bytes,1,opt,name=computation_name,json=computationName" json:"computation_name,omitempty"`
	InstructionName string  `protobuf:"bytes,2,opt,name=instruction_name,json=instructionName" json:"instruction_name,omitempty"`
	ShapeIndex      []int64 `protobuf:"varint,3,rep,packed,name=shape_index,json=shapeIndex" json:"shape_index,omitempty"`
}

func (m *LogicalBufferProto_Location) Reset()                    { *m = LogicalBufferProto_Location{} }
func (m *LogicalBufferProto_Location) String() string            { return proto.CompactTextString(m) }
func (*LogicalBufferProto_Location) ProtoMessage()               {}
func (*LogicalBufferProto_Location) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

func (m *LogicalBufferProto_Location) GetComputationName() string {
	if m != nil {
		return m.ComputationName
	}
	return ""
}

func (m *LogicalBufferProto_Location) GetInstructionName() string {
	if m != nil {
		return m.InstructionName
	}
	return ""
}

func (m *LogicalBufferProto_Location) GetShapeIndex() []int64 {
	if m != nil {
		return m.ShapeIndex
	}
	return nil
}

// Serialization of BufferAllocation.
type BufferAllocationProto struct {
	Index                       int64                             `protobuf:"varint,1,opt,name=index" json:"index,omitempty"`
	Size                        int64                             `protobuf:"varint,2,opt,name=size" json:"size,omitempty"`
	IsThreadLocal               bool                              `protobuf:"varint,3,opt,name=is_thread_local,json=isThreadLocal" json:"is_thread_local,omitempty"`
	IsReusable                  bool                              `protobuf:"varint,4,opt,name=is_reusable,json=isReusable" json:"is_reusable,omitempty"`
	IsEntryComputationParameter bool                              `protobuf:"varint,5,opt,name=is_entry_computation_parameter,json=isEntryComputationParameter" json:"is_entry_computation_parameter,omitempty"`
	ParameterNumber             int64                             `protobuf:"varint,6,opt,name=parameter_number,json=parameterNumber" json:"parameter_number,omitempty"`
	MaybeLiveOut                bool                              `protobuf:"varint,7,opt,name=maybe_live_out,json=maybeLiveOut" json:"maybe_live_out,omitempty"`
	Assigned                    []*BufferAllocationProto_Assigned `protobuf:"bytes,8,rep,name=assigned" json:"assigned,omitempty"`
}

func (m *BufferAllocationProto) Reset()                    { *m = BufferAllocationProto{} }
func (m *BufferAllocationProto) String() string            { return proto.CompactTextString(m) }
func (*BufferAllocationProto) ProtoMessage()               {}
func (*BufferAllocationProto) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *BufferAllocationProto) GetIndex() int64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *BufferAllocationProto) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *BufferAllocationProto) GetIsThreadLocal() bool {
	if m != nil {
		return m.IsThreadLocal
	}
	return false
}

func (m *BufferAllocationProto) GetIsReusable() bool {
	if m != nil {
		return m.IsReusable
	}
	return false
}

func (m *BufferAllocationProto) GetIsEntryComputationParameter() bool {
	if m != nil {
		return m.IsEntryComputationParameter
	}
	return false
}

func (m *BufferAllocationProto) GetParameterNumber() int64 {
	if m != nil {
		return m.ParameterNumber
	}
	return 0
}

func (m *BufferAllocationProto) GetMaybeLiveOut() bool {
	if m != nil {
		return m.MaybeLiveOut
	}
	return false
}

func (m *BufferAllocationProto) GetAssigned() []*BufferAllocationProto_Assigned {
	if m != nil {
		return m.Assigned
	}
	return nil
}

// Assigned represents a single LogicalBuffer that is assigned to this
// BufferAllocation.
type BufferAllocationProto_Assigned struct {
	LogicalBufferId int64 `protobuf:"varint,1,opt,name=logical_buffer_id,json=logicalBufferId" json:"logical_buffer_id,omitempty"`
	Offset          int64 `protobuf:"varint,2,opt,name=offset" json:"offset,omitempty"`
	Size            int64 `protobuf:"varint,3,opt,name=size" json:"size,omitempty"`
}

func (m *BufferAllocationProto_Assigned) Reset()         { *m = BufferAllocationProto_Assigned{} }
func (m *BufferAllocationProto_Assigned) String() string { return proto.CompactTextString(m) }
func (*BufferAllocationProto_Assigned) ProtoMessage()    {}
func (*BufferAllocationProto_Assigned) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{5, 0}
}

func (m *BufferAllocationProto_Assigned) GetLogicalBufferId() int64 {
	if m != nil {
		return m.LogicalBufferId
	}
	return 0
}

func (m *BufferAllocationProto_Assigned) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *BufferAllocationProto_Assigned) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

// A trace of a HeapSimulator run.
type HeapSimulatorTrace struct {
	Events                []*HeapSimulatorTrace_Event `protobuf:"bytes,1,rep,name=events" json:"events,omitempty"`
	WholeModuleSimulation bool                        `protobuf:"varint,2,opt,name=whole_module_simulation,json=wholeModuleSimulation" json:"whole_module_simulation,omitempty"`
}

func (m *HeapSimulatorTrace) Reset()                    { *m = HeapSimulatorTrace{} }
func (m *HeapSimulatorTrace) String() string            { return proto.CompactTextString(m) }
func (*HeapSimulatorTrace) ProtoMessage()               {}
func (*HeapSimulatorTrace) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *HeapSimulatorTrace) GetEvents() []*HeapSimulatorTrace_Event {
	if m != nil {
		return m.Events
	}
	return nil
}

func (m *HeapSimulatorTrace) GetWholeModuleSimulation() bool {
	if m != nil {
		return m.WholeModuleSimulation
	}
	return false
}

// The trace includes a list of events, where each event describes one action
// performed by the heap simulator.
type HeapSimulatorTrace_Event struct {
	Kind HeapSimulatorTrace_Event_Kind `protobuf:"varint,1,opt,name=kind,enum=xla.HeapSimulatorTrace_Event_Kind" json:"kind,omitempty"`
	// The id of the LogicalBuffer that the event applies to.
	BufferId int64 `protobuf:"varint,2,opt,name=buffer_id,json=bufferId" json:"buffer_id,omitempty"`
	// The HloInstruction that the simulation was processing that caused this
	// event to occur, identified by its computation and instruction name. E.g.
	// buffers defined by instruction A are allocated when processing A.
	ComputationName string `protobuf:"bytes,3,opt,name=computation_name,json=computationName" json:"computation_name,omitempty"`
	InstructionName string `protobuf:"bytes,4,opt,name=instruction_name,json=instructionName" json:"instruction_name,omitempty"`
	// The id of the canonical LogicalBuffer that the buffer shares with. Only
	// set for SHARE_WITH events.
	ShareWithCanonicalId int64 `protobuf:"varint,5,opt,name=share_with_canonical_id,json=shareWithCanonicalId" json:"share_with_canonical_id,omitempty"`
}

func (m *HeapSimulatorTrace_Event) Reset()                    { *m = HeapSimulatorTrace_Event{} }
func (m *HeapSimulatorTrace_Event) String() string            { return proto.CompactTextString(m) }
func (*HeapSimulatorTrace_Event) ProtoMessage()               {}
func (*HeapSimulatorTrace_Event) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 0} }

func (m *HeapSimulatorTrace_Event) GetKind() HeapSimulatorTrace_Event_Kind {
	if m != nil {
		return m.Kind
	}
	return HeapSimulatorTrace_Event_ALLOC
}

func (m *HeapSimulatorTrace_Event) GetBufferId() int64 {
	if m != nil {
		return m.BufferId
	}
	return 0
}

func (m *HeapSimulatorTrace_Event) GetComputationName() string {
	if m != nil {
		return m.ComputationName
	}
	return ""
}

func (m *HeapSimulatorTrace_Event) GetInstructionName() string {
	if m != nil {
		return m.InstructionName
	}
	return ""
}

func (m *HeapSimulatorTrace_Event) GetShareWithCanonicalId() int64 {
	if m != nil {
		return m.ShareWithCanonicalId
	}
	return 0
}

// Serialization of BufferAssignment.
type BufferAssignmentProto struct {
	LogicalBuffers      []*LogicalBufferProto                `protobuf:"bytes,1,rep,name=logical_buffers,json=logicalBuffers" json:"logical_buffers,omitempty"`
	BufferAliases       []*BufferAssignmentProto_BufferAlias `protobuf:"bytes,2,rep,name=buffer_aliases,json=bufferAliases" json:"buffer_aliases,omitempty"`
	BufferAllocations   []*BufferAllocationProto             `protobuf:"bytes,3,rep,name=buffer_allocations,json=bufferAllocations" json:"buffer_allocations,omitempty"`
	HeapSimulatorTraces []*HeapSimulatorTrace                `protobuf:"bytes,4,rep,name=heap_simulator_traces,json=heapSimulatorTraces" json:"heap_simulator_traces,omitempty"`
}

func (m *BufferAssignmentProto) Reset()                    { *m = BufferAssignmentProto{} }
func (m *BufferAssignmentProto) String() string            { return proto.CompactTextString(m) }
func (*BufferAssignmentProto) ProtoMessage()               {}
func (*BufferAssignmentProto) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *BufferAssignmentProto) GetLogicalBuffers() []*LogicalBufferProto {
	if m != nil {
		return m.LogicalBuffers
	}
	return nil
}

func (m *BufferAssignmentProto) GetBufferAliases() []*BufferAssignmentProto_BufferAlias {
	if m != nil {
		return m.BufferAliases
	}
	return nil
}

func (m *BufferAssignmentProto) GetBufferAllocations() []*BufferAllocationProto {
	if m != nil {
		return m.BufferAllocations
	}
	return nil
}

func (m *BufferAssignmentProto) GetHeapSimulatorTraces() []*HeapSimulatorTrace {
	if m != nil {
		return m.HeapSimulatorTraces
	}
	return nil
}

// Alias represents a source LogicalBuffer, and the buffer location that
// aliases it.
type BufferAssignmentProto_BufferAlias struct {
	SourceBufferId int64                        `protobuf:"varint,1,opt,name=source_buffer_id,json=sourceBufferId" json:"source_buffer_id,omitempty"`
	Location       *LogicalBufferProto_Location `protobuf:"bytes,2,opt,name=location" json:"location,omitempty"`
}

func (m *BufferAssignmentProto_BufferAlias) Reset()         { *m = BufferAssignmentProto_BufferAlias{} }
func (m *BufferAssignmentProto_BufferAlias) String() string { return proto.CompactTextString(m) }
func (*BufferAssignmentProto_BufferAlias) ProtoMessage()    {}
func (*BufferAssignmentProto_BufferAlias) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{7, 0}
}

func (m *BufferAssignmentProto_BufferAlias) GetSourceBufferId() int64 {
	if m != nil {
		return m.SourceBufferId
	}
	return 0
}

func (m *BufferAssignmentProto_BufferAlias) GetLocation() *LogicalBufferProto_Location {
	if m != nil {
		return m.Location
	}
	return nil
}

// Grouping message that contains all of the information above.
type HloProto struct {
	HloModule        *HloModuleProto        `protobuf:"bytes,1,opt,name=hlo_module,json=hloModule" json:"hlo_module,omitempty"`
	HloOrdering      *HloOrderingProto      `protobuf:"bytes,2,opt,name=hlo_ordering,json=hloOrdering" json:"hlo_ordering,omitempty"`
	BufferAssignment *BufferAssignmentProto `protobuf:"bytes,3,opt,name=buffer_assignment,json=bufferAssignment" json:"buffer_assignment,omitempty"`
}

func (m *HloProto) Reset()                    { *m = HloProto{} }
func (m *HloProto) String() string            { return proto.CompactTextString(m) }
func (*HloProto) ProtoMessage()               {}
func (*HloProto) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *HloProto) GetHloModule() *HloModuleProto {
	if m != nil {
		return m.HloModule
	}
	return nil
}

func (m *HloProto) GetHloOrdering() *HloOrderingProto {
	if m != nil {
		return m.HloOrdering
	}
	return nil
}

func (m *HloProto) GetBufferAssignment() *BufferAssignmentProto {
	if m != nil {
		return m.BufferAssignment
	}
	return nil
}

func init() {
	proto.RegisterType((*HloInstructionProto)(nil), "xla.HloInstructionProto")
	proto.RegisterType((*HloComputationProto)(nil), "xla.HloComputationProto")
	proto.RegisterType((*HloModuleProto)(nil), "xla.HloModuleProto")
	proto.RegisterType((*HloOrderingProto)(nil), "xla.HloOrderingProto")
	proto.RegisterType((*HloOrderingProto_SequentialComputation)(nil), "xla.HloOrderingProto.SequentialComputation")
	proto.RegisterType((*LogicalBufferProto)(nil), "xla.LogicalBufferProto")
	proto.RegisterType((*LogicalBufferProto_Location)(nil), "xla.LogicalBufferProto.Location")
	proto.RegisterType((*BufferAllocationProto)(nil), "xla.BufferAllocationProto")
	proto.RegisterType((*BufferAllocationProto_Assigned)(nil), "xla.BufferAllocationProto.Assigned")
	proto.RegisterType((*HeapSimulatorTrace)(nil), "xla.HeapSimulatorTrace")
	proto.RegisterType((*HeapSimulatorTrace_Event)(nil), "xla.HeapSimulatorTrace.Event")
	proto.RegisterType((*BufferAssignmentProto)(nil), "xla.BufferAssignmentProto")
	proto.RegisterType((*BufferAssignmentProto_BufferAlias)(nil), "xla.BufferAssignmentProto.BufferAlias")
	proto.RegisterType((*HloProto)(nil), "xla.HloProto")
	proto.RegisterEnum("xla.HeapSimulatorTrace_Event_Kind", HeapSimulatorTrace_Event_Kind_name, HeapSimulatorTrace_Event_Kind_value)
}

func init() { proto.RegisterFile("serving/tensorflow/compiler/xla/service/hlo.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1237 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0xcf, 0x6e, 0xdb, 0xc6,
	0x13, 0xfe, 0x51, 0x94, 0x1d, 0x69, 0x6c, 0x4b, 0xf2, 0x26, 0xb6, 0xf9, 0x53, 0xda, 0x54, 0x50,
	0x5a, 0xc3, 0xa9, 0x01, 0x19, 0x75, 0x9b, 0x20, 0x28, 0x02, 0xa4, 0x8e, 0xe1, 0x56, 0x46, 0x9c,
	0x38, 0x58, 0x07, 0xc8, 0xad, 0xc4, 0x8a, 0x5c, 0x59, 0x8b, 0xae, 0xb8, 0x2a, 0x97, 0x74, 0x9c,
	0xde, 0xfa, 0x12, 0x45, 0x0f, 0x7d, 0x8f, 0x9e, 0x7b, 0x28, 0xfa, 0x2c, 0x7d, 0x83, 0x5e, 0x0a,
	0x14, 0x3b, 0x4b, 0x52, 0xd4, 0x1f, 0x17, 0xe9, 0x4d, 0xfc, 0x66, 0x66, 0x77, 0xe6, 0x9b, 0x6f,
	0x66, 0x05, 0x9f, 0x69, 0x1e, 0x5f, 0x89, 0xe8, 0xf2, 0x20, 0xe1, 0x91, 0x56, 0xf1, 0x50, 0xaa,
	0xb7, 0x07, 0x81, 0x1a, 0x4f, 0x84, 0xe4, 0xf1, 0xc1, 0xb5, 0x64, 0x07, 0x68, 0x0f, 0xf8, 0xc1,
	0x48, 0xaa, 0xde, 0x24, 0x56, 0x89, 0x22, 0xee, 0xb5, 0x64, 0xed, 0xdd, 0x9b, 0xfc, 0xaf, 0x25,
	0xf3, 0x43, 0x96, 0x30, 0xeb, 0xdc, 0xfd, 0xa3, 0x0a, 0xb7, 0xfb, 0x52, 0x9d, 0x46, 0x3a, 0x89,
	0xd3, 0x20, 0x11, 0x2a, 0x7a, 0x85, 0x87, 0x10, 0xa8, 0x46, 0x6c, 0xcc, 0x3d, 0xa7, 0xe3, 0xec,
	0xd5, 0x29, 0xfe, 0x26, 0xdb, 0xb0, 0xaa, 0x26, 0x81, 0x0a, 0xb9, 0x57, 0x41, 0x34, 0xfb, 0x22,
	0x1d, 0x58, 0xd1, 0x23, 0x36, 0xe1, 0x9e, 0xdb, 0x71, 0xf6, 0xd6, 0x0e, 0xa1, 0x77, 0x2d, 0x59,
	0xef, 0xc2, 0x20, 0xd4, 0x1a, 0xc8, 0x7d, 0xd8, 0x50, 0x13, 0x1e, 0xb3, 0x28, 0xf4, 0xcd, 0x49,
	0xda, 0xab, 0x76, 0xdc, 0xbd, 0x3a, 0x5d, 0xcf, 0xc0, 0x97, 0x06, 0x23, 0x5f, 0xc2, 0xff, 0x03,
	0x15, 0x25, 0xb1, 0x92, 0xfe, 0x24, 0xe6, 0x21, 0x0f, 0xb8, 0xd6, 0x2a, 0xce, 0x02, 0x56, 0x30,
	0x60, 0x27, 0x73, 0x78, 0x35, 0xb5, 0xdb, 0xd8, 0xc7, 0xe0, 0x05, 0x4c, 0x4a, 0x1e, 0xfa, 0xa6,
	0xd8, 0x34, 0x61, 0xa6, 0x92, 0x2c, 0x74, 0x15, 0x43, 0xb7, 0xad, 0xfd, 0x78, 0x6a, 0xb6, 0x91,
	0xfb, 0x50, 0x1b, 0xf3, 0x84, 0x19, 0x4a, 0xbc, 0x5b, 0x98, 0x7f, 0x13, 0xf3, 0x3f, 0x9f, 0xbc,
	0xc8, 0x60, 0x5a, 0x38, 0x90, 0x5d, 0xb8, 0x25, 0x45, 0xc2, 0x63, 0x26, 0xbd, 0x1a, 0xfa, 0xae,
	0xa3, 0xef, 0x99, 0xc5, 0x68, 0x6e, 0x24, 0x0f, 0xa0, 0x35, 0x61, 0x31, 0x1b, 0xf3, 0x84, 0xc7,
	0x7e, 0x94, 0x8e, 0x07, 0x3c, 0xf6, 0xea, 0x1d, 0x67, 0xcf, 0xa5, 0xcd, 0x02, 0x7f, 0x89, 0x30,
	0xf9, 0x04, 0x1a, 0x25, 0x57, 0x43, 0x39, 0x20, 0xb9, 0x1b, 0x53, 0x47, 0xc3, 0xfd, 0x47, 0xb0,
	0x36, 0x4c, 0xb5, 0x29, 0xea, 0x3b, 0x11, 0x85, 0xde, 0x1a, 0xfa, 0x80, 0x85, 0x9e, 0x8b, 0x28,
	0x24, 0xdf, 0xc2, 0xbd, 0x61, 0xaa, 0x79, 0xe8, 0x8b, 0x69, 0x2b, 0x75, 0x99, 0x0d, 0x6f, 0x1d,
	0x33, 0xf6, 0x30, 0xe3, 0xbe, 0x54, 0x25, 0x26, 0xb0, 0xe5, 0xf4, 0x03, 0x8c, 0x2f, 0x29, 0x41,
	0x97, 0x5c, 0x4c, 0x02, 0x49, 0x3a, 0x91, 0xdc, 0x17, 0x51, 0xc8, 0xaf, 0xbd, 0x0d, 0xac, 0x06,
	0x10, 0x3a, 0x35, 0x48, 0xf7, 0x12, 0x85, 0x34, 0x7f, 0xea, 0x52, 0x21, 0x3d, 0x81, 0xf5, 0x72,
	0x96, 0x5e, 0xa5, 0xe3, 0x96, 0x33, 0x9b, 0x17, 0x23, 0x9d, 0xf1, 0xee, 0xfe, 0xec, 0x40, 0xa3,
	0x2f, 0xd5, 0x0b, 0x15, 0xa6, 0x92, 0xdf, 0x7c, 0xc9, 0x17, 0xb0, 0xcd, 0xa3, 0x24, 0x7e, 0xb7,
	0xa0, 0x88, 0x4c, 0xbd, 0x77, 0xd0, 0x3a, 0xa7, 0x07, 0x93, 0x5a, 0xc9, 0x5f, 0x7b, 0xee, 0x6c,
	0x6a, 0x0b, 0xa4, 0xcd, 0x78, 0x77, 0xff, 0x74, 0xa0, 0xd5, 0x97, 0xea, 0x3c, 0x0e, 0x79, 0x2c,
	0xa2, 0x4b, 0x9b, 0x5c, 0x08, 0x3b, 0x9a, 0x7f, 0x9f, 0xf2, 0x28, 0x11, 0x4c, 0xfa, 0x33, 0xa7,
	0x3b, 0x78, 0xfa, 0x7e, 0x7e, 0xfa, 0x4c, 0x5c, 0xef, 0xa2, 0x08, 0x2a, 0xdd, 0x4a, 0xb7, 0xf5,
	0x32, 0x58, 0xb7, 0x15, 0x6c, 0x2d, 0x0d, 0x30, 0x5a, 0x5c, 0x60, 0xc0, 0xf2, 0xd4, 0x0c, 0xe6,
	0x8a, 0xdf, 0x87, 0xcd, 0x12, 0xd3, 0xd9, 0xf8, 0x54, 0x70, 0x7c, 0x5a, 0x25, 0x03, 0x0e, 0x4e,
	0xf7, 0x6f, 0x07, 0xc8, 0x99, 0xba, 0x14, 0x01, 0x93, 0xcf, 0xd2, 0xe1, 0x90, 0xc7, 0xb6, 0xda,
	0x06, 0x54, 0x44, 0x88, 0x17, 0xb8, 0xb4, 0x22, 0x42, 0xd3, 0x1a, 0x2d, 0x7e, 0xb0, 0xa4, 0xbb,
	0x14, 0x7f, 0x93, 0xa7, 0x00, 0x21, 0x1f, 0x8a, 0x88, 0x87, 0x3e, 0x4b, 0xb2, 0xad, 0xd1, 0xb1,
	0x93, 0xb4, 0x70, 0x60, 0xef, 0x4c, 0x05, 0xb6, 0xf2, 0x7a, 0x16, 0x73, 0x94, 0xb4, 0x7f, 0x74,
	0xa0, 0x96, 0xe3, 0xff, 0xa5, 0xc0, 0x07, 0xd0, 0x9a, 0x2f, 0x30, 0x53, 0x43, 0x73, 0xae, 0x3e,
	0xa3, 0x77, 0xdc, 0x5d, 0x99, 0xde, 0x8d, 0x0e, 0x5c, 0x0a, 0x08, 0x59, 0xbd, 0xff, 0xee, 0xc2,
	0x96, 0xcd, 0xf3, 0x48, 0xca, 0x2c, 0x17, 0x4b, 0xc1, 0x1d, 0x58, 0xb1, 0x41, 0x96, 0x05, 0xfb,
	0xb1, 0x94, 0x88, 0x5d, 0x68, 0x0a, 0xed, 0x27, 0xa3, 0x98, 0xb3, 0xd0, 0x37, 0x87, 0x48, 0x64,
	0xa3, 0x46, 0x37, 0x84, 0x7e, 0x8d, 0xa8, 0xa9, 0x52, 0x9a, 0x64, 0x84, 0xf6, 0x63, 0x9e, 0x6a,
	0x36, 0x90, 0xdc, 0xab, 0xa2, 0x0f, 0x08, 0x4d, 0x33, 0x84, 0x1c, 0xc3, 0x3d, 0xa1, 0xfd, 0x45,
	0xbd, 0x17, 0x4b, 0xc4, 0x5b, 0xc1, 0x98, 0xbb, 0x42, 0x9f, 0xcc, 0xc9, 0xfe, 0x55, 0xee, 0xb2,
	0x74, 0x6b, 0xad, 0x2e, 0xdf, 0x5a, 0x1f, 0x43, 0x63, 0xcc, 0xde, 0x0d, 0xb8, 0x2f, 0xc5, 0x15,
	0xf7, 0x55, 0x9a, 0xe0, 0xee, 0xac, 0xd1, 0x75, 0x44, 0xcf, 0xc4, 0x15, 0x3f, 0x4f, 0x13, 0xf2,
	0x14, 0x6a, 0x4c, 0x6b, 0x71, 0x19, 0xf1, 0xd0, 0xab, 0xa1, 0xd4, 0xef, 0x63, 0x97, 0x97, 0xd2,
	0xd6, 0x3b, 0xca, 0x5c, 0x69, 0x11, 0xd4, 0x1e, 0x40, 0x2d, 0x47, 0xc9, 0xa7, 0xb0, 0x29, 0xad,
	0x3a, 0xfc, 0x01, 0xc6, 0xfb, 0x85, 0xce, 0x9a, 0xb2, 0x2c, 0x9b, 0xd3, 0x10, 0x5f, 0xaa, 0xe1,
	0x50, 0xf3, 0x24, 0x63, 0x3b, 0xfb, 0x2a, 0x7a, 0xe0, 0x4e, 0x7b, 0xd0, 0xfd, 0xc5, 0x05, 0xd2,
	0xe7, 0x6c, 0x72, 0x21, 0xc6, 0xa9, 0x64, 0x89, 0x8a, 0x5f, 0xc7, 0x2c, 0xe0, 0xe4, 0x21, 0xac,
	0xf2, 0x2b, 0x1e, 0x25, 0xf9, 0x90, 0x7e, 0x68, 0x87, 0x74, 0xc1, 0xb1, 0x77, 0x62, 0xbc, 0x68,
	0xe6, 0x4c, 0x1e, 0xc1, 0xce, 0xdb, 0x91, 0x92, 0xdc, 0x1f, 0xe3, 0x7a, 0xf2, 0xb5, 0x75, 0x36,
	0xfb, 0xb7, 0x82, 0x0c, 0x6d, 0xa1, 0xd9, 0x2e, 0xaf, 0x8b, 0xc2, 0xd8, 0xfe, 0xa9, 0x02, 0x2b,
	0x78, 0x12, 0x79, 0x04, 0x55, 0x5c, 0xf1, 0xa6, 0xb4, 0xc6, 0x61, 0xf7, 0x5f, 0xaf, 0xed, 0x99,
	0xd5, 0x4f, 0xd1, 0x9f, 0xdc, 0x85, 0xfa, 0x94, 0x17, 0x5b, 0x76, 0x6d, 0x90, 0x13, 0xb2, 0x6c,
	0x46, 0xdc, 0xf7, 0x9f, 0x91, 0xea, 0xf2, 0x19, 0x79, 0x08, 0x3b, 0x7a, 0xc4, 0x62, 0xee, 0xbf,
	0x15, 0xc9, 0xc8, 0x0f, 0x58, 0xa4, 0x22, 0xec, 0x8f, 0x08, 0x51, 0x6e, 0x2e, 0xbd, 0x83, 0xe6,
	0x37, 0x22, 0x19, 0x1d, 0xe7, 0xc6, 0xd3, 0xb0, 0xbb, 0x0f, 0x55, 0x7c, 0xb2, 0xea, 0xb0, 0x72,
	0x74, 0x76, 0x76, 0x7e, 0xdc, 0xfa, 0x1f, 0xa9, 0x41, 0xf5, 0x6b, 0x7a, 0x72, 0xd2, 0x72, 0x48,
	0x03, 0xe0, 0xa2, 0x7f, 0x44, 0x4f, 0xfc, 0x37, 0xa7, 0xaf, 0xfb, 0xad, 0x4a, 0xf7, 0xd7, 0xe9,
	0x98, 0xa1, 0x12, 0xc6, 0x3c, 0x4a, 0xec, 0x98, 0x7d, 0x05, 0xcd, 0x59, 0x41, 0xe4, 0xad, 0xda,
	0xb9, 0x61, 0x95, 0xd0, 0xc6, 0x8c, 0x4e, 0x34, 0x79, 0x01, 0x8d, 0x8c, 0x32, 0x26, 0x05, 0xd3,
	0x3c, 0x7f, 0x89, 0x76, 0xcb, 0x2a, 0x9d, 0xbd, 0xb5, 0xd0, 0xae, 0x60, 0x9a, 0x6e, 0x0c, 0xa6,
	0x1f, 0x5c, 0x93, 0x53, 0x20, 0xc5, 0x71, 0xb9, 0xb4, 0xf3, 0x17, 0xa4, 0x7d, 0xb3, 0xf0, 0xe9,
	0xe6, 0x60, 0x0e, 0xd6, 0xe4, 0x39, 0x6c, 0x8d, 0x38, 0x9b, 0xe4, 0xf2, 0x51, 0xb1, 0x9f, 0x98,
	0xae, 0xdb, 0x3f, 0x4e, 0x79, 0x85, 0x8b, 0xaa, 0xa0, 0xb7, 0x47, 0x0b, 0x98, 0x6e, 0xa7, 0xb0,
	0x56, 0xca, 0x9a, 0xec, 0x41, 0x4b, 0xab, 0x34, 0x0e, 0xf8, 0xc2, 0x1c, 0x35, 0x2c, 0x5e, 0x8c,
	0xd1, 0x13, 0xa8, 0xe5, 0x29, 0xa1, 0xa2, 0xde, 0x67, 0x4b, 0x17, 0x11, 0xdd, 0xdf, 0x1c, 0xa8,
	0xf5, 0xa5, 0xb2, 0xcd, 0x3a, 0x04, 0x18, 0x49, 0x95, 0x4d, 0x05, 0x5e, 0xb7, 0x76, 0x78, 0x3b,
	0x7f, 0xf7, 0x4a, 0x4f, 0x39, 0xad, 0x8f, 0xf2, 0x6f, 0xf2, 0x18, 0xd6, 0x4d, 0x8c, 0xca, 0x5e,
	0xc5, 0x2c, 0x85, 0xad, 0xa5, 0xaf, 0x25, 0x5d, 0x1b, 0x4d, 0x11, 0xf2, 0x0d, 0x6c, 0xe6, 0x9d,
	0x28, 0xda, 0x97, 0xbd, 0x33, 0xed, 0x9b, 0x7b, 0x4b, 0x5b, 0x83, 0x39, 0xf8, 0x99, 0xfb, 0x97,
	0xe3, 0x0c, 0x56, 0xf1, 0xaf, 0xf2, 0xe7, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0x24, 0xe7, 0x9b,
	0xa1, 0x8c, 0x0b, 0x00, 0x00,
}

/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "tfprof_options.proto"
/// Syntax "Proto2"

import Foundation
import ProtocolBuffers


public struct Tensorflow { public struct Tfprof { }}

public extension Tensorflow.Tfprof {
    public struct TfprofOptionsRoot {
        public static let `default` = TfprofOptionsRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    /// Refers to tfprof_options.h/cc for documentation.
    /// Only used to pass tfprof options from Python to C++.
    final public class OptionsProto : GeneratedMessage {

        public static func == (lhs: Tensorflow.Tfprof.OptionsProto, rhs: Tensorflow.Tfprof.OptionsProto) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasMaxDepth == rhs.hasMaxDepth) && (!lhs.hasMaxDepth || lhs.maxDepth == rhs.maxDepth)
            fieldCheck = fieldCheck && (lhs.hasMinBytes == rhs.hasMinBytes) && (!lhs.hasMinBytes || lhs.minBytes == rhs.minBytes)
            fieldCheck = fieldCheck && (lhs.hasMinMicros == rhs.hasMinMicros) && (!lhs.hasMinMicros || lhs.minMicros == rhs.minMicros)
            fieldCheck = fieldCheck && (lhs.hasMinParams == rhs.hasMinParams) && (!lhs.hasMinParams || lhs.minParams == rhs.minParams)
            fieldCheck = fieldCheck && (lhs.hasMinFloatOps == rhs.hasMinFloatOps) && (!lhs.hasMinFloatOps || lhs.minFloatOps == rhs.minFloatOps)
            fieldCheck = fieldCheck && (lhs.deviceRegexes == rhs.deviceRegexes)
            fieldCheck = fieldCheck && (lhs.hasOrderBy == rhs.hasOrderBy) && (!lhs.hasOrderBy || lhs.orderBy == rhs.orderBy)
            fieldCheck = fieldCheck && (lhs.accountTypeRegexes == rhs.accountTypeRegexes)
            fieldCheck = fieldCheck && (lhs.startNameRegexes == rhs.startNameRegexes)
            fieldCheck = fieldCheck && (lhs.trimNameRegexes == rhs.trimNameRegexes)
            fieldCheck = fieldCheck && (lhs.showNameRegexes == rhs.showNameRegexes)
            fieldCheck = fieldCheck && (lhs.hideNameRegexes == rhs.hideNameRegexes)
            fieldCheck = fieldCheck && (lhs.hasAccountDisplayedOpOnly == rhs.hasAccountDisplayedOpOnly) && (!lhs.hasAccountDisplayedOpOnly || lhs.accountDisplayedOpOnly == rhs.accountDisplayedOpOnly)
            fieldCheck = fieldCheck && (lhs.select == rhs.select)
            fieldCheck = fieldCheck && (lhs.hasViz == rhs.hasViz) && (!lhs.hasViz || lhs.viz == rhs.viz)
            fieldCheck = fieldCheck && (lhs.hasDumpToFile == rhs.hasDumpToFile) && (!lhs.hasDumpToFile || lhs.dumpToFile == rhs.dumpToFile)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var maxDepth:Int64 = Int64(0)
        public fileprivate(set) var hasMaxDepth:Bool = false

        public fileprivate(set) var minBytes:Int64 = Int64(0)
        public fileprivate(set) var hasMinBytes:Bool = false

        public fileprivate(set) var minMicros:Int64 = Int64(0)
        public fileprivate(set) var hasMinMicros:Bool = false

        public fileprivate(set) var minParams:Int64 = Int64(0)
        public fileprivate(set) var hasMinParams:Bool = false

        public fileprivate(set) var minFloatOps:Int64 = Int64(0)
        public fileprivate(set) var hasMinFloatOps:Bool = false

        public fileprivate(set) var deviceRegexes:Array<String> = Array<String>()
        public fileprivate(set) var orderBy:String = ""
        public fileprivate(set) var hasOrderBy:Bool = false

        public fileprivate(set) var accountTypeRegexes:Array<String> = Array<String>()
        public fileprivate(set) var startNameRegexes:Array<String> = Array<String>()
        public fileprivate(set) var trimNameRegexes:Array<String> = Array<String>()
        public fileprivate(set) var showNameRegexes:Array<String> = Array<String>()
        public fileprivate(set) var hideNameRegexes:Array<String> = Array<String>()
        public fileprivate(set) var accountDisplayedOpOnly:Bool = false
        public fileprivate(set) var hasAccountDisplayedOpOnly:Bool = false

        public fileprivate(set) var select:Array<String> = Array<String>()
        public fileprivate(set) var viz:Bool = false
        public fileprivate(set) var hasViz:Bool = false

        public fileprivate(set) var dumpToFile:String = ""
        public fileprivate(set) var hasDumpToFile:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasMaxDepth {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:maxDepth)
            }
            if hasMinBytes {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:minBytes)
            }
            if hasMinMicros {
                try codedOutputStream.writeInt64(fieldNumber: 3, value:minMicros)
            }
            if hasMinParams {
                try codedOutputStream.writeInt64(fieldNumber: 4, value:minParams)
            }
            if hasMinFloatOps {
                try codedOutputStream.writeInt64(fieldNumber: 5, value:minFloatOps)
            }
            if !deviceRegexes.isEmpty {
                for oneValuedeviceRegexes in deviceRegexes {
                    try codedOutputStream.writeString(fieldNumber: 6, value:oneValuedeviceRegexes)
                }
            }
            if hasOrderBy {
                try codedOutputStream.writeString(fieldNumber: 7, value:orderBy)
            }
            if !accountTypeRegexes.isEmpty {
                for oneValueaccountTypeRegexes in accountTypeRegexes {
                    try codedOutputStream.writeString(fieldNumber: 8, value:oneValueaccountTypeRegexes)
                }
            }
            if !startNameRegexes.isEmpty {
                for oneValuestartNameRegexes in startNameRegexes {
                    try codedOutputStream.writeString(fieldNumber: 9, value:oneValuestartNameRegexes)
                }
            }
            if !trimNameRegexes.isEmpty {
                for oneValuetrimNameRegexes in trimNameRegexes {
                    try codedOutputStream.writeString(fieldNumber: 10, value:oneValuetrimNameRegexes)
                }
            }
            if !showNameRegexes.isEmpty {
                for oneValueshowNameRegexes in showNameRegexes {
                    try codedOutputStream.writeString(fieldNumber: 11, value:oneValueshowNameRegexes)
                }
            }
            if !hideNameRegexes.isEmpty {
                for oneValuehideNameRegexes in hideNameRegexes {
                    try codedOutputStream.writeString(fieldNumber: 12, value:oneValuehideNameRegexes)
                }
            }
            if hasAccountDisplayedOpOnly {
                try codedOutputStream.writeBool(fieldNumber: 13, value:accountDisplayedOpOnly)
            }
            if !select.isEmpty {
                for oneValueselect in select {
                    try codedOutputStream.writeString(fieldNumber: 14, value:oneValueselect)
                }
            }
            if hasViz {
                try codedOutputStream.writeBool(fieldNumber: 15, value:viz)
            }
            if hasDumpToFile {
                try codedOutputStream.writeString(fieldNumber: 16, value:dumpToFile)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasMaxDepth {
                serialize_size += maxDepth.computeInt64Size(fieldNumber: 1)
            }
            if hasMinBytes {
                serialize_size += minBytes.computeInt64Size(fieldNumber: 2)
            }
            if hasMinMicros {
                serialize_size += minMicros.computeInt64Size(fieldNumber: 3)
            }
            if hasMinParams {
                serialize_size += minParams.computeInt64Size(fieldNumber: 4)
            }
            if hasMinFloatOps {
                serialize_size += minFloatOps.computeInt64Size(fieldNumber: 5)
            }
            var dataSizeDeviceRegexes:Int32 = 0
            for oneValuedeviceRegexes in deviceRegexes {
                dataSizeDeviceRegexes += oneValuedeviceRegexes.computeStringSizeNoTag()
            }
            serialize_size += dataSizeDeviceRegexes
            serialize_size += 1 * Int32(deviceRegexes.count)
            if hasOrderBy {
                serialize_size += orderBy.computeStringSize(fieldNumber: 7)
            }
            var dataSizeAccountTypeRegexes:Int32 = 0
            for oneValueaccountTypeRegexes in accountTypeRegexes {
                dataSizeAccountTypeRegexes += oneValueaccountTypeRegexes.computeStringSizeNoTag()
            }
            serialize_size += dataSizeAccountTypeRegexes
            serialize_size += 1 * Int32(accountTypeRegexes.count)
            var dataSizeStartNameRegexes:Int32 = 0
            for oneValuestartNameRegexes in startNameRegexes {
                dataSizeStartNameRegexes += oneValuestartNameRegexes.computeStringSizeNoTag()
            }
            serialize_size += dataSizeStartNameRegexes
            serialize_size += 1 * Int32(startNameRegexes.count)
            var dataSizeTrimNameRegexes:Int32 = 0
            for oneValuetrimNameRegexes in trimNameRegexes {
                dataSizeTrimNameRegexes += oneValuetrimNameRegexes.computeStringSizeNoTag()
            }
            serialize_size += dataSizeTrimNameRegexes
            serialize_size += 1 * Int32(trimNameRegexes.count)
            var dataSizeShowNameRegexes:Int32 = 0
            for oneValueshowNameRegexes in showNameRegexes {
                dataSizeShowNameRegexes += oneValueshowNameRegexes.computeStringSizeNoTag()
            }
            serialize_size += dataSizeShowNameRegexes
            serialize_size += 1 * Int32(showNameRegexes.count)
            var dataSizeHideNameRegexes:Int32 = 0
            for oneValuehideNameRegexes in hideNameRegexes {
                dataSizeHideNameRegexes += oneValuehideNameRegexes.computeStringSizeNoTag()
            }
            serialize_size += dataSizeHideNameRegexes
            serialize_size += 1 * Int32(hideNameRegexes.count)
            if hasAccountDisplayedOpOnly {
                serialize_size += accountDisplayedOpOnly.computeBoolSize(fieldNumber: 13)
            }
            var dataSizeSelect:Int32 = 0
            for oneValueselect in select {
                dataSizeSelect += oneValueselect.computeStringSizeNoTag()
            }
            serialize_size += dataSizeSelect
            serialize_size += 1 * Int32(select.count)
            if hasViz {
                serialize_size += viz.computeBoolSize(fieldNumber: 15)
            }
            if hasDumpToFile {
                serialize_size += dumpToFile.computeStringSize(fieldNumber: 16)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.Tfprof.OptionsProto.Builder {
            return Tensorflow.Tfprof.OptionsProto.classBuilder() as! Tensorflow.Tfprof.OptionsProto.Builder
        }
        public func getBuilder() -> Tensorflow.Tfprof.OptionsProto.Builder {
            return classBuilder() as! Tensorflow.Tfprof.OptionsProto.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Tfprof.OptionsProto.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Tfprof.OptionsProto.Builder()
        }
        public func toBuilder() throws -> Tensorflow.Tfprof.OptionsProto.Builder {
            return try Tensorflow.Tfprof.OptionsProto.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.Tfprof.OptionsProto) throws -> Tensorflow.Tfprof.OptionsProto.Builder {
            return try Tensorflow.Tfprof.OptionsProto.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasMaxDepth {
                jsonMap["maxDepth"] = "\(maxDepth)"
            }
            if hasMinBytes {
                jsonMap["minBytes"] = "\(minBytes)"
            }
            if hasMinMicros {
                jsonMap["minMicros"] = "\(minMicros)"
            }
            if hasMinParams {
                jsonMap["minParams"] = "\(minParams)"
            }
            if hasMinFloatOps {
                jsonMap["minFloatOps"] = "\(minFloatOps)"
            }
            if !deviceRegexes.isEmpty {
                var jsonArrayDeviceRegexes:Array<String> = []
                for oneValueDeviceRegexes in deviceRegexes {
                    jsonArrayDeviceRegexes.append(oneValueDeviceRegexes)
                }
                jsonMap["deviceRegexes"] = jsonArrayDeviceRegexes
            }
            if hasOrderBy {
                jsonMap["orderBy"] = orderBy
            }
            if !accountTypeRegexes.isEmpty {
                var jsonArrayAccountTypeRegexes:Array<String> = []
                for oneValueAccountTypeRegexes in accountTypeRegexes {
                    jsonArrayAccountTypeRegexes.append(oneValueAccountTypeRegexes)
                }
                jsonMap["accountTypeRegexes"] = jsonArrayAccountTypeRegexes
            }
            if !startNameRegexes.isEmpty {
                var jsonArrayStartNameRegexes:Array<String> = []
                for oneValueStartNameRegexes in startNameRegexes {
                    jsonArrayStartNameRegexes.append(oneValueStartNameRegexes)
                }
                jsonMap["startNameRegexes"] = jsonArrayStartNameRegexes
            }
            if !trimNameRegexes.isEmpty {
                var jsonArrayTrimNameRegexes:Array<String> = []
                for oneValueTrimNameRegexes in trimNameRegexes {
                    jsonArrayTrimNameRegexes.append(oneValueTrimNameRegexes)
                }
                jsonMap["trimNameRegexes"] = jsonArrayTrimNameRegexes
            }
            if !showNameRegexes.isEmpty {
                var jsonArrayShowNameRegexes:Array<String> = []
                for oneValueShowNameRegexes in showNameRegexes {
                    jsonArrayShowNameRegexes.append(oneValueShowNameRegexes)
                }
                jsonMap["showNameRegexes"] = jsonArrayShowNameRegexes
            }
            if !hideNameRegexes.isEmpty {
                var jsonArrayHideNameRegexes:Array<String> = []
                for oneValueHideNameRegexes in hideNameRegexes {
                    jsonArrayHideNameRegexes.append(oneValueHideNameRegexes)
                }
                jsonMap["hideNameRegexes"] = jsonArrayHideNameRegexes
            }
            if hasAccountDisplayedOpOnly {
                jsonMap["accountDisplayedOpOnly"] = accountDisplayedOpOnly
            }
            if !select.isEmpty {
                var jsonArraySelect:Array<String> = []
                for oneValueSelect in select {
                    jsonArraySelect.append(oneValueSelect)
                }
                jsonMap["select"] = jsonArraySelect
            }
            if hasViz {
                jsonMap["viz"] = viz
            }
            if hasDumpToFile {
                jsonMap["dumpToFile"] = dumpToFile
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Tfprof.OptionsProto {
            return try Tensorflow.Tfprof.OptionsProto.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.Tfprof.OptionsProto {
            return try Tensorflow.Tfprof.OptionsProto.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasMaxDepth {
                output += "\(indent) maxDepth: \(maxDepth) \n"
            }
            if hasMinBytes {
                output += "\(indent) minBytes: \(minBytes) \n"
            }
            if hasMinMicros {
                output += "\(indent) minMicros: \(minMicros) \n"
            }
            if hasMinParams {
                output += "\(indent) minParams: \(minParams) \n"
            }
            if hasMinFloatOps {
                output += "\(indent) minFloatOps: \(minFloatOps) \n"
            }
            var deviceRegexesElementIndex:Int = 0
            for oneValueDeviceRegexes in deviceRegexes  {
                output += "\(indent) deviceRegexes[\(deviceRegexesElementIndex)]: \(oneValueDeviceRegexes)\n"
                deviceRegexesElementIndex += 1
            }
            if hasOrderBy {
                output += "\(indent) orderBy: \(orderBy) \n"
            }
            var accountTypeRegexesElementIndex:Int = 0
            for oneValueAccountTypeRegexes in accountTypeRegexes  {
                output += "\(indent) accountTypeRegexes[\(accountTypeRegexesElementIndex)]: \(oneValueAccountTypeRegexes)\n"
                accountTypeRegexesElementIndex += 1
            }
            var startNameRegexesElementIndex:Int = 0
            for oneValueStartNameRegexes in startNameRegexes  {
                output += "\(indent) startNameRegexes[\(startNameRegexesElementIndex)]: \(oneValueStartNameRegexes)\n"
                startNameRegexesElementIndex += 1
            }
            var trimNameRegexesElementIndex:Int = 0
            for oneValueTrimNameRegexes in trimNameRegexes  {
                output += "\(indent) trimNameRegexes[\(trimNameRegexesElementIndex)]: \(oneValueTrimNameRegexes)\n"
                trimNameRegexesElementIndex += 1
            }
            var showNameRegexesElementIndex:Int = 0
            for oneValueShowNameRegexes in showNameRegexes  {
                output += "\(indent) showNameRegexes[\(showNameRegexesElementIndex)]: \(oneValueShowNameRegexes)\n"
                showNameRegexesElementIndex += 1
            }
            var hideNameRegexesElementIndex:Int = 0
            for oneValueHideNameRegexes in hideNameRegexes  {
                output += "\(indent) hideNameRegexes[\(hideNameRegexesElementIndex)]: \(oneValueHideNameRegexes)\n"
                hideNameRegexesElementIndex += 1
            }
            if hasAccountDisplayedOpOnly {
                output += "\(indent) accountDisplayedOpOnly: \(accountDisplayedOpOnly) \n"
            }
            var selectElementIndex:Int = 0
            for oneValueSelect in select  {
                output += "\(indent) select[\(selectElementIndex)]: \(oneValueSelect)\n"
                selectElementIndex += 1
            }
            if hasViz {
                output += "\(indent) viz: \(viz) \n"
            }
            if hasDumpToFile {
                output += "\(indent) dumpToFile: \(dumpToFile) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasMaxDepth {
                    hashCode = (hashCode &* 31) &+ maxDepth.hashValue
                }
                if hasMinBytes {
                    hashCode = (hashCode &* 31) &+ minBytes.hashValue
                }
                if hasMinMicros {
                    hashCode = (hashCode &* 31) &+ minMicros.hashValue
                }
                if hasMinParams {
                    hashCode = (hashCode &* 31) &+ minParams.hashValue
                }
                if hasMinFloatOps {
                    hashCode = (hashCode &* 31) &+ minFloatOps.hashValue
                }
                for oneValueDeviceRegexes in deviceRegexes {
                    hashCode = (hashCode &* 31) &+ oneValueDeviceRegexes.hashValue
                }
                if hasOrderBy {
                    hashCode = (hashCode &* 31) &+ orderBy.hashValue
                }
                for oneValueAccountTypeRegexes in accountTypeRegexes {
                    hashCode = (hashCode &* 31) &+ oneValueAccountTypeRegexes.hashValue
                }
                for oneValueStartNameRegexes in startNameRegexes {
                    hashCode = (hashCode &* 31) &+ oneValueStartNameRegexes.hashValue
                }
                for oneValueTrimNameRegexes in trimNameRegexes {
                    hashCode = (hashCode &* 31) &+ oneValueTrimNameRegexes.hashValue
                }
                for oneValueShowNameRegexes in showNameRegexes {
                    hashCode = (hashCode &* 31) &+ oneValueShowNameRegexes.hashValue
                }
                for oneValueHideNameRegexes in hideNameRegexes {
                    hashCode = (hashCode &* 31) &+ oneValueHideNameRegexes.hashValue
                }
                if hasAccountDisplayedOpOnly {
                    hashCode = (hashCode &* 31) &+ accountDisplayedOpOnly.hashValue
                }
                for oneValueSelect in select {
                    hashCode = (hashCode &* 31) &+ oneValueSelect.hashValue
                }
                if hasViz {
                    hashCode = (hashCode &* 31) &+ viz.hashValue
                }
                if hasDumpToFile {
                    hashCode = (hashCode &* 31) &+ dumpToFile.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.Tfprof.OptionsProto"
        }
        override public func className() -> String {
            return "Tensorflow.Tfprof.OptionsProto"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.Tfprof.OptionsProto = Tensorflow.Tfprof.OptionsProto()
            public func getMessage() -> Tensorflow.Tfprof.OptionsProto {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var maxDepth:Int64 {
                get {
                    return builderResult.maxDepth
                }
                set (value) {
                    builderResult.hasMaxDepth = true
                    builderResult.maxDepth = value
                }
            }
            public var hasMaxDepth:Bool {
                get {
                    return builderResult.hasMaxDepth
                }
            }
            @discardableResult
            public func setMaxDepth(_ value:Int64) -> Tensorflow.Tfprof.OptionsProto.Builder {
                self.maxDepth = value
                return self
            }
            @discardableResult
            public func clearMaxDepth() -> Tensorflow.Tfprof.OptionsProto.Builder{
                builderResult.hasMaxDepth = false
                builderResult.maxDepth = Int64(0)
                return self
            }
            public var minBytes:Int64 {
                get {
                    return builderResult.minBytes
                }
                set (value) {
                    builderResult.hasMinBytes = true
                    builderResult.minBytes = value
                }
            }
            public var hasMinBytes:Bool {
                get {
                    return builderResult.hasMinBytes
                }
            }
            @discardableResult
            public func setMinBytes(_ value:Int64) -> Tensorflow.Tfprof.OptionsProto.Builder {
                self.minBytes = value
                return self
            }
            @discardableResult
            public func clearMinBytes() -> Tensorflow.Tfprof.OptionsProto.Builder{
                builderResult.hasMinBytes = false
                builderResult.minBytes = Int64(0)
                return self
            }
            public var minMicros:Int64 {
                get {
                    return builderResult.minMicros
                }
                set (value) {
                    builderResult.hasMinMicros = true
                    builderResult.minMicros = value
                }
            }
            public var hasMinMicros:Bool {
                get {
                    return builderResult.hasMinMicros
                }
            }
            @discardableResult
            public func setMinMicros(_ value:Int64) -> Tensorflow.Tfprof.OptionsProto.Builder {
                self.minMicros = value
                return self
            }
            @discardableResult
            public func clearMinMicros() -> Tensorflow.Tfprof.OptionsProto.Builder{
                builderResult.hasMinMicros = false
                builderResult.minMicros = Int64(0)
                return self
            }
            public var minParams:Int64 {
                get {
                    return builderResult.minParams
                }
                set (value) {
                    builderResult.hasMinParams = true
                    builderResult.minParams = value
                }
            }
            public var hasMinParams:Bool {
                get {
                    return builderResult.hasMinParams
                }
            }
            @discardableResult
            public func setMinParams(_ value:Int64) -> Tensorflow.Tfprof.OptionsProto.Builder {
                self.minParams = value
                return self
            }
            @discardableResult
            public func clearMinParams() -> Tensorflow.Tfprof.OptionsProto.Builder{
                builderResult.hasMinParams = false
                builderResult.minParams = Int64(0)
                return self
            }
            public var minFloatOps:Int64 {
                get {
                    return builderResult.minFloatOps
                }
                set (value) {
                    builderResult.hasMinFloatOps = true
                    builderResult.minFloatOps = value
                }
            }
            public var hasMinFloatOps:Bool {
                get {
                    return builderResult.hasMinFloatOps
                }
            }
            @discardableResult
            public func setMinFloatOps(_ value:Int64) -> Tensorflow.Tfprof.OptionsProto.Builder {
                self.minFloatOps = value
                return self
            }
            @discardableResult
            public func clearMinFloatOps() -> Tensorflow.Tfprof.OptionsProto.Builder{
                builderResult.hasMinFloatOps = false
                builderResult.minFloatOps = Int64(0)
                return self
            }
            public var deviceRegexes:Array<String> {
                get {
                    return builderResult.deviceRegexes
                }
                set (array) {
                    builderResult.deviceRegexes = array
                }
            }
            @discardableResult
            public func setDeviceRegexes(_ value:Array<String>) -> Tensorflow.Tfprof.OptionsProto.Builder {
                self.deviceRegexes = value
                return self
            }
            @discardableResult
            public func clearDeviceRegexes() -> Tensorflow.Tfprof.OptionsProto.Builder {
                builderResult.deviceRegexes.removeAll(keepingCapacity: false)
                return self
            }
            public var orderBy:String {
                get {
                    return builderResult.orderBy
                }
                set (value) {
                    builderResult.hasOrderBy = true
                    builderResult.orderBy = value
                }
            }
            public var hasOrderBy:Bool {
                get {
                    return builderResult.hasOrderBy
                }
            }
            @discardableResult
            public func setOrderBy(_ value:String) -> Tensorflow.Tfprof.OptionsProto.Builder {
                self.orderBy = value
                return self
            }
            @discardableResult
            public func clearOrderBy() -> Tensorflow.Tfprof.OptionsProto.Builder{
                builderResult.hasOrderBy = false
                builderResult.orderBy = ""
                return self
            }
            public var accountTypeRegexes:Array<String> {
                get {
                    return builderResult.accountTypeRegexes
                }
                set (array) {
                    builderResult.accountTypeRegexes = array
                }
            }
            @discardableResult
            public func setAccountTypeRegexes(_ value:Array<String>) -> Tensorflow.Tfprof.OptionsProto.Builder {
                self.accountTypeRegexes = value
                return self
            }
            @discardableResult
            public func clearAccountTypeRegexes() -> Tensorflow.Tfprof.OptionsProto.Builder {
                builderResult.accountTypeRegexes.removeAll(keepingCapacity: false)
                return self
            }
            public var startNameRegexes:Array<String> {
                get {
                    return builderResult.startNameRegexes
                }
                set (array) {
                    builderResult.startNameRegexes = array
                }
            }
            @discardableResult
            public func setStartNameRegexes(_ value:Array<String>) -> Tensorflow.Tfprof.OptionsProto.Builder {
                self.startNameRegexes = value
                return self
            }
            @discardableResult
            public func clearStartNameRegexes() -> Tensorflow.Tfprof.OptionsProto.Builder {
                builderResult.startNameRegexes.removeAll(keepingCapacity: false)
                return self
            }
            public var trimNameRegexes:Array<String> {
                get {
                    return builderResult.trimNameRegexes
                }
                set (array) {
                    builderResult.trimNameRegexes = array
                }
            }
            @discardableResult
            public func setTrimNameRegexes(_ value:Array<String>) -> Tensorflow.Tfprof.OptionsProto.Builder {
                self.trimNameRegexes = value
                return self
            }
            @discardableResult
            public func clearTrimNameRegexes() -> Tensorflow.Tfprof.OptionsProto.Builder {
                builderResult.trimNameRegexes.removeAll(keepingCapacity: false)
                return self
            }
            public var showNameRegexes:Array<String> {
                get {
                    return builderResult.showNameRegexes
                }
                set (array) {
                    builderResult.showNameRegexes = array
                }
            }
            @discardableResult
            public func setShowNameRegexes(_ value:Array<String>) -> Tensorflow.Tfprof.OptionsProto.Builder {
                self.showNameRegexes = value
                return self
            }
            @discardableResult
            public func clearShowNameRegexes() -> Tensorflow.Tfprof.OptionsProto.Builder {
                builderResult.showNameRegexes.removeAll(keepingCapacity: false)
                return self
            }
            public var hideNameRegexes:Array<String> {
                get {
                    return builderResult.hideNameRegexes
                }
                set (array) {
                    builderResult.hideNameRegexes = array
                }
            }
            @discardableResult
            public func setHideNameRegexes(_ value:Array<String>) -> Tensorflow.Tfprof.OptionsProto.Builder {
                self.hideNameRegexes = value
                return self
            }
            @discardableResult
            public func clearHideNameRegexes() -> Tensorflow.Tfprof.OptionsProto.Builder {
                builderResult.hideNameRegexes.removeAll(keepingCapacity: false)
                return self
            }
            public var accountDisplayedOpOnly:Bool {
                get {
                    return builderResult.accountDisplayedOpOnly
                }
                set (value) {
                    builderResult.hasAccountDisplayedOpOnly = true
                    builderResult.accountDisplayedOpOnly = value
                }
            }
            public var hasAccountDisplayedOpOnly:Bool {
                get {
                    return builderResult.hasAccountDisplayedOpOnly
                }
            }
            @discardableResult
            public func setAccountDisplayedOpOnly(_ value:Bool) -> Tensorflow.Tfprof.OptionsProto.Builder {
                self.accountDisplayedOpOnly = value
                return self
            }
            @discardableResult
            public func clearAccountDisplayedOpOnly() -> Tensorflow.Tfprof.OptionsProto.Builder{
                builderResult.hasAccountDisplayedOpOnly = false
                builderResult.accountDisplayedOpOnly = false
                return self
            }
            public var select:Array<String> {
                get {
                    return builderResult.select
                }
                set (array) {
                    builderResult.select = array
                }
            }
            @discardableResult
            public func setSelect(_ value:Array<String>) -> Tensorflow.Tfprof.OptionsProto.Builder {
                self.select = value
                return self
            }
            @discardableResult
            public func clearSelect() -> Tensorflow.Tfprof.OptionsProto.Builder {
                builderResult.select.removeAll(keepingCapacity: false)
                return self
            }
            public var viz:Bool {
                get {
                    return builderResult.viz
                }
                set (value) {
                    builderResult.hasViz = true
                    builderResult.viz = value
                }
            }
            public var hasViz:Bool {
                get {
                    return builderResult.hasViz
                }
            }
            @discardableResult
            public func setViz(_ value:Bool) -> Tensorflow.Tfprof.OptionsProto.Builder {
                self.viz = value
                return self
            }
            @discardableResult
            public func clearViz() -> Tensorflow.Tfprof.OptionsProto.Builder{
                builderResult.hasViz = false
                builderResult.viz = false
                return self
            }
            public var dumpToFile:String {
                get {
                    return builderResult.dumpToFile
                }
                set (value) {
                    builderResult.hasDumpToFile = true
                    builderResult.dumpToFile = value
                }
            }
            public var hasDumpToFile:Bool {
                get {
                    return builderResult.hasDumpToFile
                }
            }
            @discardableResult
            public func setDumpToFile(_ value:String) -> Tensorflow.Tfprof.OptionsProto.Builder {
                self.dumpToFile = value
                return self
            }
            @discardableResult
            public func clearDumpToFile() -> Tensorflow.Tfprof.OptionsProto.Builder{
                builderResult.hasDumpToFile = false
                builderResult.dumpToFile = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.Tfprof.OptionsProto.Builder {
                builderResult = Tensorflow.Tfprof.OptionsProto()
                return self
            }
            override public func clone() throws -> Tensorflow.Tfprof.OptionsProto.Builder {
                return try Tensorflow.Tfprof.OptionsProto.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.Tfprof.OptionsProto {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.Tfprof.OptionsProto {
                let returnMe:Tensorflow.Tfprof.OptionsProto = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.Tfprof.OptionsProto) throws -> Tensorflow.Tfprof.OptionsProto.Builder {
                if other == Tensorflow.Tfprof.OptionsProto() {
                    return self
                }
                if other.hasMaxDepth {
                    maxDepth = other.maxDepth
                }
                if other.hasMinBytes {
                    minBytes = other.minBytes
                }
                if other.hasMinMicros {
                    minMicros = other.minMicros
                }
                if other.hasMinParams {
                    minParams = other.minParams
                }
                if other.hasMinFloatOps {
                    minFloatOps = other.minFloatOps
                }
                if !other.deviceRegexes.isEmpty {
                    builderResult.deviceRegexes += other.deviceRegexes
                }
                if other.hasOrderBy {
                    orderBy = other.orderBy
                }
                if !other.accountTypeRegexes.isEmpty {
                    builderResult.accountTypeRegexes += other.accountTypeRegexes
                }
                if !other.startNameRegexes.isEmpty {
                    builderResult.startNameRegexes += other.startNameRegexes
                }
                if !other.trimNameRegexes.isEmpty {
                    builderResult.trimNameRegexes += other.trimNameRegexes
                }
                if !other.showNameRegexes.isEmpty {
                    builderResult.showNameRegexes += other.showNameRegexes
                }
                if !other.hideNameRegexes.isEmpty {
                    builderResult.hideNameRegexes += other.hideNameRegexes
                }
                if other.hasAccountDisplayedOpOnly {
                    accountDisplayedOpOnly = other.accountDisplayedOpOnly
                }
                if !other.select.isEmpty {
                    builderResult.select += other.select
                }
                if other.hasViz {
                    viz = other.viz
                }
                if other.hasDumpToFile {
                    dumpToFile = other.dumpToFile
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Tfprof.OptionsProto.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Tfprof.OptionsProto.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        maxDepth = try codedInputStream.readInt64()

                    case 16:
                        minBytes = try codedInputStream.readInt64()

                    case 24:
                        minMicros = try codedInputStream.readInt64()

                    case 32:
                        minParams = try codedInputStream.readInt64()

                    case 40:
                        minFloatOps = try codedInputStream.readInt64()

                    case 50:
                        deviceRegexes += [try codedInputStream.readString()]

                    case 58:
                        orderBy = try codedInputStream.readString()

                    case 66:
                        accountTypeRegexes += [try codedInputStream.readString()]

                    case 74:
                        startNameRegexes += [try codedInputStream.readString()]

                    case 82:
                        trimNameRegexes += [try codedInputStream.readString()]

                    case 90:
                        showNameRegexes += [try codedInputStream.readString()]

                    case 98:
                        hideNameRegexes += [try codedInputStream.readString()]

                    case 104:
                        accountDisplayedOpOnly = try codedInputStream.readBool()

                    case 114:
                        select += [try codedInputStream.readString()]

                    case 120:
                        viz = try codedInputStream.readBool()

                    case 130:
                        dumpToFile = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Tfprof.OptionsProto.Builder {
                let resultDecodedBuilder = Tensorflow.Tfprof.OptionsProto.Builder()
                if let jsonValueMaxDepth = jsonMap["maxDepth"] as? String {
                    resultDecodedBuilder.maxDepth = Int64(jsonValueMaxDepth)!
                } else if let jsonValueMaxDepth = jsonMap["maxDepth"] as? Int {
                    resultDecodedBuilder.maxDepth = Int64(jsonValueMaxDepth)
                }
                if let jsonValueMinBytes = jsonMap["minBytes"] as? String {
                    resultDecodedBuilder.minBytes = Int64(jsonValueMinBytes)!
                } else if let jsonValueMinBytes = jsonMap["minBytes"] as? Int {
                    resultDecodedBuilder.minBytes = Int64(jsonValueMinBytes)
                }
                if let jsonValueMinMicros = jsonMap["minMicros"] as? String {
                    resultDecodedBuilder.minMicros = Int64(jsonValueMinMicros)!
                } else if let jsonValueMinMicros = jsonMap["minMicros"] as? Int {
                    resultDecodedBuilder.minMicros = Int64(jsonValueMinMicros)
                }
                if let jsonValueMinParams = jsonMap["minParams"] as? String {
                    resultDecodedBuilder.minParams = Int64(jsonValueMinParams)!
                } else if let jsonValueMinParams = jsonMap["minParams"] as? Int {
                    resultDecodedBuilder.minParams = Int64(jsonValueMinParams)
                }
                if let jsonValueMinFloatOps = jsonMap["minFloatOps"] as? String {
                    resultDecodedBuilder.minFloatOps = Int64(jsonValueMinFloatOps)!
                } else if let jsonValueMinFloatOps = jsonMap["minFloatOps"] as? Int {
                    resultDecodedBuilder.minFloatOps = Int64(jsonValueMinFloatOps)
                }
                if let jsonValueDeviceRegexes = jsonMap["deviceRegexes"] as? Array<String> {
                    var jsonArrayDeviceRegexes:Array<String> = []
                    for oneValueDeviceRegexes in jsonValueDeviceRegexes {
                        jsonArrayDeviceRegexes.append(oneValueDeviceRegexes)
                    }
                    resultDecodedBuilder.deviceRegexes = jsonArrayDeviceRegexes
                }
                if let jsonValueOrderBy = jsonMap["orderBy"] as? String {
                    resultDecodedBuilder.orderBy = jsonValueOrderBy
                }
                if let jsonValueAccountTypeRegexes = jsonMap["accountTypeRegexes"] as? Array<String> {
                    var jsonArrayAccountTypeRegexes:Array<String> = []
                    for oneValueAccountTypeRegexes in jsonValueAccountTypeRegexes {
                        jsonArrayAccountTypeRegexes.append(oneValueAccountTypeRegexes)
                    }
                    resultDecodedBuilder.accountTypeRegexes = jsonArrayAccountTypeRegexes
                }
                if let jsonValueStartNameRegexes = jsonMap["startNameRegexes"] as? Array<String> {
                    var jsonArrayStartNameRegexes:Array<String> = []
                    for oneValueStartNameRegexes in jsonValueStartNameRegexes {
                        jsonArrayStartNameRegexes.append(oneValueStartNameRegexes)
                    }
                    resultDecodedBuilder.startNameRegexes = jsonArrayStartNameRegexes
                }
                if let jsonValueTrimNameRegexes = jsonMap["trimNameRegexes"] as? Array<String> {
                    var jsonArrayTrimNameRegexes:Array<String> = []
                    for oneValueTrimNameRegexes in jsonValueTrimNameRegexes {
                        jsonArrayTrimNameRegexes.append(oneValueTrimNameRegexes)
                    }
                    resultDecodedBuilder.trimNameRegexes = jsonArrayTrimNameRegexes
                }
                if let jsonValueShowNameRegexes = jsonMap["showNameRegexes"] as? Array<String> {
                    var jsonArrayShowNameRegexes:Array<String> = []
                    for oneValueShowNameRegexes in jsonValueShowNameRegexes {
                        jsonArrayShowNameRegexes.append(oneValueShowNameRegexes)
                    }
                    resultDecodedBuilder.showNameRegexes = jsonArrayShowNameRegexes
                }
                if let jsonValueHideNameRegexes = jsonMap["hideNameRegexes"] as? Array<String> {
                    var jsonArrayHideNameRegexes:Array<String> = []
                    for oneValueHideNameRegexes in jsonValueHideNameRegexes {
                        jsonArrayHideNameRegexes.append(oneValueHideNameRegexes)
                    }
                    resultDecodedBuilder.hideNameRegexes = jsonArrayHideNameRegexes
                }
                if let jsonValueAccountDisplayedOpOnly = jsonMap["accountDisplayedOpOnly"] as? Bool {
                    resultDecodedBuilder.accountDisplayedOpOnly = jsonValueAccountDisplayedOpOnly
                }
                if let jsonValueSelect = jsonMap["select"] as? Array<String> {
                    var jsonArraySelect:Array<String> = []
                    for oneValueSelect in jsonValueSelect {
                        jsonArraySelect.append(oneValueSelect)
                    }
                    resultDecodedBuilder.select = jsonArraySelect
                }
                if let jsonValueViz = jsonMap["viz"] as? Bool {
                    resultDecodedBuilder.viz = jsonValueViz
                }
                if let jsonValueDumpToFile = jsonMap["dumpToFile"] as? String {
                    resultDecodedBuilder.dumpToFile = jsonValueDumpToFile
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Tfprof.OptionsProto.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.Tfprof.OptionsProto.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.Tfprof.OptionsProto: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Tfprof.OptionsProto> {
        var mergedArray = Array<Tensorflow.Tfprof.OptionsProto>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Tfprof.OptionsProto? {
        return try Tensorflow.Tfprof.OptionsProto.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Tfprof.OptionsProto {
        return try Tensorflow.Tfprof.OptionsProto.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.Tfprof.TfprofOptionsRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Tfprof.OptionsProto {
        return try Tensorflow.Tfprof.OptionsProto.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Tfprof.OptionsProto {
        return try Tensorflow.Tfprof.OptionsProto.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Tfprof.OptionsProto {
        return try Tensorflow.Tfprof.OptionsProto.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Tfprof.OptionsProto {
        return try Tensorflow.Tfprof.OptionsProto.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Tfprof.OptionsProto {
        return try Tensorflow.Tfprof.OptionsProto.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "maxDepth": return self.maxDepth
        case "minBytes": return self.minBytes
        case "minMicros": return self.minMicros
        case "minParams": return self.minParams
        case "minFloatOps": return self.minFloatOps
        case "deviceRegexes": return self.deviceRegexes
        case "orderBy": return self.orderBy
        case "accountTypeRegexes": return self.accountTypeRegexes
        case "startNameRegexes": return self.startNameRegexes
        case "trimNameRegexes": return self.trimNameRegexes
        case "showNameRegexes": return self.showNameRegexes
        case "hideNameRegexes": return self.hideNameRegexes
        case "accountDisplayedOpOnly": return self.accountDisplayedOpOnly
        case "select": return self.select
        case "viz": return self.viz
        case "dumpToFile": return self.dumpToFile
        default: return nil
        }
    }
}
extension Tensorflow.Tfprof.OptionsProto.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "maxDepth": return self.maxDepth
            case "minBytes": return self.minBytes
            case "minMicros": return self.minMicros
            case "minParams": return self.minParams
            case "minFloatOps": return self.minFloatOps
            case "deviceRegexes": return self.deviceRegexes
            case "orderBy": return self.orderBy
            case "accountTypeRegexes": return self.accountTypeRegexes
            case "startNameRegexes": return self.startNameRegexes
            case "trimNameRegexes": return self.trimNameRegexes
            case "showNameRegexes": return self.showNameRegexes
            case "hideNameRegexes": return self.hideNameRegexes
            case "accountDisplayedOpOnly": return self.accountDisplayedOpOnly
            case "select": return self.select
            case "viz": return self.viz
            case "dumpToFile": return self.dumpToFile
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "maxDepth":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.maxDepth = newSubscriptValue
            case "minBytes":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.minBytes = newSubscriptValue
            case "minMicros":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.minMicros = newSubscriptValue
            case "minParams":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.minParams = newSubscriptValue
            case "minFloatOps":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.minFloatOps = newSubscriptValue
            case "deviceRegexes":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.deviceRegexes = newSubscriptValue
            case "orderBy":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.orderBy = newSubscriptValue
            case "accountTypeRegexes":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.accountTypeRegexes = newSubscriptValue
            case "startNameRegexes":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.startNameRegexes = newSubscriptValue
            case "trimNameRegexes":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.trimNameRegexes = newSubscriptValue
            case "showNameRegexes":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.showNameRegexes = newSubscriptValue
            case "hideNameRegexes":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.hideNameRegexes = newSubscriptValue
            case "accountDisplayedOpOnly":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.accountDisplayedOpOnly = newSubscriptValue
            case "select":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.select = newSubscriptValue
            case "viz":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.viz = newSubscriptValue
            case "dumpToFile":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.dumpToFile = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "manifest.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { public struct Serving { }}

public extension Tensorflow.Serving {
    public struct ManifestRoot {
        public static let `default` = ManifestRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    /// Signatures of model export.
    final public class Signatures : GeneratedMessage {

        public static func == (lhs: Tensorflow.Serving.Signatures, rhs: Tensorflow.Serving.Signatures) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasDefaultSignature == rhs.hasDefaultSignature) && (!lhs.hasDefaultSignature || lhs.defaultSignature == rhs.defaultSignature)
            fieldCheck = fieldCheck && (lhs.hasNamedSignatures == rhs.hasNamedSignatures) && (!lhs.hasNamedSignatures || lhs.namedSignatures == rhs.namedSignatures)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        final public class NamedSignaturesEntry : GeneratedMessage {

            public static func == (lhs: Tensorflow.Serving.Signatures.NamedSignaturesEntry, rhs: Tensorflow.Serving.Signatures.NamedSignaturesEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:String = ""
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:Tensorflow.Serving.Signature!
            public fileprivate(set) var hasValue:Bool = false
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeString(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeMessage(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeStringSize(fieldNumber: 1)
                }
                if hasValue {
                    if let varSizevalue = value?.computeMessageSize(fieldNumber: 2) {
                        serialize_size += varSizevalue
                    }
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder {
                return Tensorflow.Serving.Signatures.NamedSignaturesEntry.classBuilder() as! Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder
            }
            public func getBuilder() -> Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder {
                return classBuilder() as! Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder()
            }
            public func toBuilder() throws -> Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder {
                return try Tensorflow.Serving.Signatures.NamedSignaturesEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.Serving.Signatures.NamedSignaturesEntry) throws -> Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder {
                return try Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = key
                }
                if hasValue {
                    jsonMap["value"] = try value.encode()
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Serving.Signatures.NamedSignaturesEntry {
                return try Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.Serving.Signatures.NamedSignaturesEntry {
                return try Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value {\n"
                    if let outDescValue = value {
                        output += try outDescValue.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        if let hashValuevalue = value?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuevalue
                        }
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.Serving.Signatures.NamedSignaturesEntry"
            }
            override public func className() -> String {
                return "Tensorflow.Serving.Signatures.NamedSignaturesEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.Serving.Signatures.NamedSignaturesEntry = Tensorflow.Serving.Signatures.NamedSignaturesEntry()
                public func getMessage() -> Tensorflow.Serving.Signatures.NamedSignaturesEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:String {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:String) -> Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = ""
                    return self
                }
                public var value:Tensorflow.Serving.Signature! {
                    get {
                        if valueBuilder_ != nil {
                            builderResult.value = valueBuilder_.getMessage()
                        }
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                fileprivate var valueBuilder_:Tensorflow.Serving.Signature.Builder! {
                    didSet {
                        builderResult.hasValue = true
                    }
                }
                public func getValueBuilder() -> Tensorflow.Serving.Signature.Builder {
                    if valueBuilder_ == nil {
                        valueBuilder_ = Tensorflow.Serving.Signature.Builder()
                        builderResult.value = valueBuilder_.getMessage()
                        if value != nil {
                            try! valueBuilder_.mergeFrom(other: value)
                        }
                    }
                    return valueBuilder_
                }
                @discardableResult
                public func setValue(_ value:Tensorflow.Serving.Signature!) -> Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func mergeValue(value:Tensorflow.Serving.Signature) throws -> Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder {
                    if builderResult.hasValue {
                        builderResult.value = try Tensorflow.Serving.Signature.builderWithPrototype(prototype:builderResult.value).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.value = value
                    }
                    builderResult.hasValue = true
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder {
                    valueBuilder_ = nil
                    builderResult.hasValue = false
                    builderResult.value = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder {
                    builderResult = Tensorflow.Serving.Signatures.NamedSignaturesEntry()
                    return self
                }
                override public func clone() throws -> Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder {
                    return try Tensorflow.Serving.Signatures.NamedSignaturesEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.Serving.Signatures.NamedSignaturesEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.Serving.Signatures.NamedSignaturesEntry {
                    let returnMe:Tensorflow.Serving.Signatures.NamedSignaturesEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.Serving.Signatures.NamedSignaturesEntry) throws -> Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder {
                    if other == Tensorflow.Serving.Signatures.NamedSignaturesEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if (other.hasValue) {
                        try mergeValue(value: other.value)
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            key = try codedInputStream.readString()

                        case 18:
                            let subBuilder:Tensorflow.Serving.Signature.Builder = Tensorflow.Serving.Signature.Builder()
                            if hasValue {
                                try subBuilder.mergeFrom(other: value)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            value = subBuilder.buildPartial()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder {
                    let resultDecodedBuilder = Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = jsonValueKey
                    }
                    if let jsonValueValue = jsonMap["value"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.value = try Tensorflow.Serving.Signature.Builder.decodeToBuilder(jsonMap:jsonValueValue).build()

                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        public fileprivate(set) var defaultSignature:Tensorflow.Serving.Signature!
        public fileprivate(set) var hasDefaultSignature:Bool = false
        /// Named signatures of the graph.
        public fileprivate(set) var namedSignatures:Dictionary<String,Tensorflow.Serving.Signature> = Dictionary<String,Tensorflow.Serving.Signature>()

        public fileprivate(set) var hasNamedSignatures:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasDefaultSignature {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:defaultSignature)
            }
            if hasNamedSignatures {
                for (keyNamedSignatures, valueNamedSignatures) in namedSignatures {
                    let valueOfNamedSignatures = try! Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder().setKey(keyNamedSignatures).setValue(valueNamedSignatures).build()
                      try codedOutputStream.writeMessage(fieldNumber: 2, value:valueOfNamedSignatures)
                  }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasDefaultSignature {
                if let varSizedefaultSignature = defaultSignature?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizedefaultSignature
                }
            }
            if hasNamedSignatures {
                  for (keyNamedSignatures, valueNamedSignatures) in namedSignatures {
                      let valueOfNamedSignatures = try! Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder().setKey(keyNamedSignatures).setValue(valueNamedSignatures).build()
                serialize_size += valueOfNamedSignatures.computeMessageSize(fieldNumber: 2)
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.Serving.Signatures.Builder {
            return Tensorflow.Serving.Signatures.classBuilder() as! Tensorflow.Serving.Signatures.Builder
        }
        public func getBuilder() -> Tensorflow.Serving.Signatures.Builder {
            return classBuilder() as! Tensorflow.Serving.Signatures.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Serving.Signatures.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Serving.Signatures.Builder()
        }
        public func toBuilder() throws -> Tensorflow.Serving.Signatures.Builder {
            return try Tensorflow.Serving.Signatures.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.Serving.Signatures) throws -> Tensorflow.Serving.Signatures.Builder {
            return try Tensorflow.Serving.Signatures.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasDefaultSignature {
                jsonMap["defaultSignature"] = try defaultSignature.encode()
            }
            if hasNamedSignatures {
                var mapNamedSignatures = Dictionary<String, Dictionary<String,Any>>()
                for (keyNamedSignatures, valueNamedSignatures) in namedSignatures {
                    mapNamedSignatures["\(keyNamedSignatures)"] = try valueNamedSignatures.encode()
                }
                jsonMap["namedSignatures"] = mapNamedSignatures
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Serving.Signatures {
            return try Tensorflow.Serving.Signatures.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.Serving.Signatures {
            return try Tensorflow.Serving.Signatures.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasDefaultSignature {
                output += "\(indent) defaultSignature {\n"
                if let outDescDefaultSignature = defaultSignature {
                    output += try outDescDefaultSignature.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasNamedSignatures {
                output += "\(indent) namedSignatures: \(namedSignatures) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasDefaultSignature {
                    if let hashValuedefaultSignature = defaultSignature?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuedefaultSignature
                    }
                }
                if hasNamedSignatures {
                    for (keyNamedSignatures, valueNamedSignatures) in namedSignatures {
                        hashCode = (hashCode &* 31) &+ keyNamedSignatures.hashValue
                        hashCode = (hashCode &* 31) &+ valueNamedSignatures.hashValue
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.Serving.Signatures"
        }
        override public func className() -> String {
            return "Tensorflow.Serving.Signatures"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.Serving.Signatures = Tensorflow.Serving.Signatures()
            public func getMessage() -> Tensorflow.Serving.Signatures {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Default signature of the graph.
            /// WARNING(break-tutorial-inline-code): The following code snippet is
            /// in-lined in tutorials, please update tutorial documents accordingly
            /// whenever code changes.
            public var defaultSignature:Tensorflow.Serving.Signature! {
                get {
                    if defaultSignatureBuilder_ != nil {
                        builderResult.defaultSignature = defaultSignatureBuilder_.getMessage()
                    }
                    return builderResult.defaultSignature
                }
                set (value) {
                    builderResult.hasDefaultSignature = true
                    builderResult.defaultSignature = value
                }
            }
            public var hasDefaultSignature:Bool {
                get {
                    return builderResult.hasDefaultSignature
                }
            }
            fileprivate var defaultSignatureBuilder_:Tensorflow.Serving.Signature.Builder! {
                didSet {
                    builderResult.hasDefaultSignature = true
                }
            }
            public func getDefaultSignatureBuilder() -> Tensorflow.Serving.Signature.Builder {
                if defaultSignatureBuilder_ == nil {
                    defaultSignatureBuilder_ = Tensorflow.Serving.Signature.Builder()
                    builderResult.defaultSignature = defaultSignatureBuilder_.getMessage()
                    if defaultSignature != nil {
                        try! defaultSignatureBuilder_.mergeFrom(other: defaultSignature)
                    }
                }
                return defaultSignatureBuilder_
            }
            @discardableResult
            public func setDefaultSignature(_ value:Tensorflow.Serving.Signature!) -> Tensorflow.Serving.Signatures.Builder {
                self.defaultSignature = value
                return self
            }
            @discardableResult
            public func mergeDefaultSignature(value:Tensorflow.Serving.Signature) throws -> Tensorflow.Serving.Signatures.Builder {
                if builderResult.hasDefaultSignature {
                    builderResult.defaultSignature = try Tensorflow.Serving.Signature.builderWithPrototype(prototype:builderResult.defaultSignature).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.defaultSignature = value
                }
                builderResult.hasDefaultSignature = true
                return self
            }
            @discardableResult
            public func clearDefaultSignature() -> Tensorflow.Serving.Signatures.Builder {
                defaultSignatureBuilder_ = nil
                builderResult.hasDefaultSignature = false
                builderResult.defaultSignature = nil
                return self
            }
            /// Named signatures of the graph.
            public var hasNamedSignatures:Bool {
                get {
                    return builderResult.hasNamedSignatures
                }
            }
            public var namedSignatures:Dictionary<String,Tensorflow.Serving.Signature> {
                get {
                    return builderResult.namedSignatures
                }
                set (value) {
                    builderResult.hasNamedSignatures = true
                    builderResult.namedSignatures = value
                }
            }
            @discardableResult
            public func setNamedSignatures(_ value:Dictionary<String,Tensorflow.Serving.Signature>) -> Tensorflow.Serving.Signatures.Builder {
                self.namedSignatures = value
                return self
            }
            @discardableResult
            public func clearNamedSignatures() -> Tensorflow.Serving.Signatures.Builder{
                builderResult.hasNamedSignatures = false
                builderResult.namedSignatures = Dictionary<String,Tensorflow.Serving.Signature>()
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.Serving.Signatures.Builder {
                builderResult = Tensorflow.Serving.Signatures()
                return self
            }
            override public func clone() throws -> Tensorflow.Serving.Signatures.Builder {
                return try Tensorflow.Serving.Signatures.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.Serving.Signatures {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.Serving.Signatures {
                let returnMe:Tensorflow.Serving.Signatures = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.Serving.Signatures) throws -> Tensorflow.Serving.Signatures.Builder {
                if other == Tensorflow.Serving.Signatures() {
                    return self
                }
                if (other.hasDefaultSignature) {
                    try mergeDefaultSignature(value: other.defaultSignature)
                }
                if other.hasNamedSignatures {
                    namedSignatures = other.namedSignatures
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Serving.Signatures.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.Signatures.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Tensorflow.Serving.Signature.Builder = Tensorflow.Serving.Signature.Builder()
                        if hasDefaultSignature {
                            try subBuilder.mergeFrom(other: defaultSignature)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        defaultSignature = subBuilder.buildPartial()

                    case 18:
                        let subBuilder = Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfNamedSignatures = subBuilder.buildPartial()
                        namedSignatures[buildOfNamedSignatures.key] = buildOfNamedSignatures.value

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Serving.Signatures.Builder {
                let resultDecodedBuilder = Tensorflow.Serving.Signatures.Builder()
                if let jsonValueDefaultSignature = jsonMap["defaultSignature"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.defaultSignature = try Tensorflow.Serving.Signature.Builder.decodeToBuilder(jsonMap:jsonValueDefaultSignature).build()

                }
                if let jsonValueNamedSignatures = jsonMap["namedSignatures"] as? Dictionary<String, Dictionary<String,Any>> {
                    var mapNamedSignatures = Dictionary<String, Tensorflow.Serving.Signature>()
                    for (keyNamedSignatures, valueNamedSignatures) in jsonValueNamedSignatures {
                        guard let keyFromNamedSignatures = String(keyNamedSignatures) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapNamedSignatures[keyFromNamedSignatures] = try Tensorflow.Serving.Signature.Builder.decodeToBuilder(jsonMap:valueNamedSignatures).build()

                    }
                    resultDecodedBuilder.namedSignatures = mapNamedSignatures
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Serving.Signatures.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.Serving.Signatures.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// A binding to a tensor including the name and, possibly in the future, type
    /// or other metadata. For example, this may specify whether a tensor supports
    /// batch vs single inference.
    final public class TensorBinding : GeneratedMessage {

        public static func == (lhs: Tensorflow.Serving.TensorBinding, rhs: Tensorflow.Serving.TensorBinding) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasTensorName == rhs.hasTensorName) && (!lhs.hasTensorName || lhs.tensorName == rhs.tensorName)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// The name of the tensor to bind to.
        public fileprivate(set) var tensorName:String = ""
        public fileprivate(set) var hasTensorName:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasTensorName {
                try codedOutputStream.writeString(fieldNumber: 1, value:tensorName)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasTensorName {
                serialize_size += tensorName.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.Serving.TensorBinding.Builder {
            return Tensorflow.Serving.TensorBinding.classBuilder() as! Tensorflow.Serving.TensorBinding.Builder
        }
        public func getBuilder() -> Tensorflow.Serving.TensorBinding.Builder {
            return classBuilder() as! Tensorflow.Serving.TensorBinding.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Serving.TensorBinding.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Serving.TensorBinding.Builder()
        }
        public func toBuilder() throws -> Tensorflow.Serving.TensorBinding.Builder {
            return try Tensorflow.Serving.TensorBinding.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.Serving.TensorBinding) throws -> Tensorflow.Serving.TensorBinding.Builder {
            return try Tensorflow.Serving.TensorBinding.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasTensorName {
                jsonMap["tensorName"] = tensorName
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Serving.TensorBinding {
            return try Tensorflow.Serving.TensorBinding.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.Serving.TensorBinding {
            return try Tensorflow.Serving.TensorBinding.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasTensorName {
                output += "\(indent) tensorName: \(tensorName) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasTensorName {
                    hashCode = (hashCode &* 31) &+ tensorName.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.Serving.TensorBinding"
        }
        override public func className() -> String {
            return "Tensorflow.Serving.TensorBinding"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.Serving.TensorBinding = Tensorflow.Serving.TensorBinding()
            public func getMessage() -> Tensorflow.Serving.TensorBinding {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The name of the tensor to bind to.
            public var tensorName:String {
                get {
                    return builderResult.tensorName
                }
                set (value) {
                    builderResult.hasTensorName = true
                    builderResult.tensorName = value
                }
            }
            public var hasTensorName:Bool {
                get {
                    return builderResult.hasTensorName
                }
            }
            @discardableResult
            public func setTensorName(_ value:String) -> Tensorflow.Serving.TensorBinding.Builder {
                self.tensorName = value
                return self
            }
            @discardableResult
            public func clearTensorName() -> Tensorflow.Serving.TensorBinding.Builder{
                builderResult.hasTensorName = false
                builderResult.tensorName = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.Serving.TensorBinding.Builder {
                builderResult = Tensorflow.Serving.TensorBinding()
                return self
            }
            override public func clone() throws -> Tensorflow.Serving.TensorBinding.Builder {
                return try Tensorflow.Serving.TensorBinding.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.Serving.TensorBinding {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.Serving.TensorBinding {
                let returnMe:Tensorflow.Serving.TensorBinding = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.Serving.TensorBinding) throws -> Tensorflow.Serving.TensorBinding.Builder {
                if other == Tensorflow.Serving.TensorBinding() {
                    return self
                }
                if other.hasTensorName {
                    tensorName = other.tensorName
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Serving.TensorBinding.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.TensorBinding.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        tensorName = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Serving.TensorBinding.Builder {
                let resultDecodedBuilder = Tensorflow.Serving.TensorBinding.Builder()
                if let jsonValueTensorName = jsonMap["tensorName"] as? String {
                    resultDecodedBuilder.tensorName = jsonValueTensorName
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Serving.TensorBinding.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.Serving.TensorBinding.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// An asset file or set of sharded files with the same name that will be bound
    /// to a tensor at init / session_bundle load time.
    final public class AssetFile : GeneratedMessage {

        public static func == (lhs: Tensorflow.Serving.AssetFile, rhs: Tensorflow.Serving.AssetFile) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasTensorBinding == rhs.hasTensorBinding) && (!lhs.hasTensorBinding || lhs.tensorBinding == rhs.tensorBinding)
            fieldCheck = fieldCheck && (lhs.hasFilename == rhs.hasFilename) && (!lhs.hasFilename || lhs.filename == rhs.filename)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var tensorBinding:Tensorflow.Serving.TensorBinding!
        public fileprivate(set) var hasTensorBinding:Bool = false
        /// The filename within the assets directory. Note: does not include the base
        /// path or asset directory prefix. Base paths can and will change when models
        /// are deployed for serving.
        public fileprivate(set) var filename:String = ""
        public fileprivate(set) var hasFilename:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasTensorBinding {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:tensorBinding)
            }
            if hasFilename {
                try codedOutputStream.writeString(fieldNumber: 2, value:filename)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasTensorBinding {
                if let varSizetensorBinding = tensorBinding?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizetensorBinding
                }
            }
            if hasFilename {
                serialize_size += filename.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.Serving.AssetFile.Builder {
            return Tensorflow.Serving.AssetFile.classBuilder() as! Tensorflow.Serving.AssetFile.Builder
        }
        public func getBuilder() -> Tensorflow.Serving.AssetFile.Builder {
            return classBuilder() as! Tensorflow.Serving.AssetFile.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Serving.AssetFile.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Serving.AssetFile.Builder()
        }
        public func toBuilder() throws -> Tensorflow.Serving.AssetFile.Builder {
            return try Tensorflow.Serving.AssetFile.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.Serving.AssetFile) throws -> Tensorflow.Serving.AssetFile.Builder {
            return try Tensorflow.Serving.AssetFile.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasTensorBinding {
                jsonMap["tensorBinding"] = try tensorBinding.encode()
            }
            if hasFilename {
                jsonMap["filename"] = filename
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Serving.AssetFile {
            return try Tensorflow.Serving.AssetFile.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.Serving.AssetFile {
            return try Tensorflow.Serving.AssetFile.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasTensorBinding {
                output += "\(indent) tensorBinding {\n"
                if let outDescTensorBinding = tensorBinding {
                    output += try outDescTensorBinding.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasFilename {
                output += "\(indent) filename: \(filename) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasTensorBinding {
                    if let hashValuetensorBinding = tensorBinding?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuetensorBinding
                    }
                }
                if hasFilename {
                    hashCode = (hashCode &* 31) &+ filename.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.Serving.AssetFile"
        }
        override public func className() -> String {
            return "Tensorflow.Serving.AssetFile"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.Serving.AssetFile = Tensorflow.Serving.AssetFile()
            public func getMessage() -> Tensorflow.Serving.AssetFile {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The tensor to bind the asset filename to.
            public var tensorBinding:Tensorflow.Serving.TensorBinding! {
                get {
                    if tensorBindingBuilder_ != nil {
                        builderResult.tensorBinding = tensorBindingBuilder_.getMessage()
                    }
                    return builderResult.tensorBinding
                }
                set (value) {
                    builderResult.hasTensorBinding = true
                    builderResult.tensorBinding = value
                }
            }
            public var hasTensorBinding:Bool {
                get {
                    return builderResult.hasTensorBinding
                }
            }
            fileprivate var tensorBindingBuilder_:Tensorflow.Serving.TensorBinding.Builder! {
                didSet {
                    builderResult.hasTensorBinding = true
                }
            }
            public func getTensorBindingBuilder() -> Tensorflow.Serving.TensorBinding.Builder {
                if tensorBindingBuilder_ == nil {
                    tensorBindingBuilder_ = Tensorflow.Serving.TensorBinding.Builder()
                    builderResult.tensorBinding = tensorBindingBuilder_.getMessage()
                    if tensorBinding != nil {
                        try! tensorBindingBuilder_.mergeFrom(other: tensorBinding)
                    }
                }
                return tensorBindingBuilder_
            }
            @discardableResult
            public func setTensorBinding(_ value:Tensorflow.Serving.TensorBinding!) -> Tensorflow.Serving.AssetFile.Builder {
                self.tensorBinding = value
                return self
            }
            @discardableResult
            public func mergeTensorBinding(value:Tensorflow.Serving.TensorBinding) throws -> Tensorflow.Serving.AssetFile.Builder {
                if builderResult.hasTensorBinding {
                    builderResult.tensorBinding = try Tensorflow.Serving.TensorBinding.builderWithPrototype(prototype:builderResult.tensorBinding).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.tensorBinding = value
                }
                builderResult.hasTensorBinding = true
                return self
            }
            @discardableResult
            public func clearTensorBinding() -> Tensorflow.Serving.AssetFile.Builder {
                tensorBindingBuilder_ = nil
                builderResult.hasTensorBinding = false
                builderResult.tensorBinding = nil
                return self
            }
            /// The filename within the assets directory. Note: does not include the base
            /// path or asset directory prefix. Base paths can and will change when models
            /// are deployed for serving.
            public var filename:String {
                get {
                    return builderResult.filename
                }
                set (value) {
                    builderResult.hasFilename = true
                    builderResult.filename = value
                }
            }
            public var hasFilename:Bool {
                get {
                    return builderResult.hasFilename
                }
            }
            @discardableResult
            public func setFilename(_ value:String) -> Tensorflow.Serving.AssetFile.Builder {
                self.filename = value
                return self
            }
            @discardableResult
            public func clearFilename() -> Tensorflow.Serving.AssetFile.Builder{
                builderResult.hasFilename = false
                builderResult.filename = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.Serving.AssetFile.Builder {
                builderResult = Tensorflow.Serving.AssetFile()
                return self
            }
            override public func clone() throws -> Tensorflow.Serving.AssetFile.Builder {
                return try Tensorflow.Serving.AssetFile.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.Serving.AssetFile {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.Serving.AssetFile {
                let returnMe:Tensorflow.Serving.AssetFile = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.Serving.AssetFile) throws -> Tensorflow.Serving.AssetFile.Builder {
                if other == Tensorflow.Serving.AssetFile() {
                    return self
                }
                if (other.hasTensorBinding) {
                    try mergeTensorBinding(value: other.tensorBinding)
                }
                if other.hasFilename {
                    filename = other.filename
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Serving.AssetFile.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.AssetFile.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Tensorflow.Serving.TensorBinding.Builder = Tensorflow.Serving.TensorBinding.Builder()
                        if hasTensorBinding {
                            try subBuilder.mergeFrom(other: tensorBinding)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        tensorBinding = subBuilder.buildPartial()

                    case 18:
                        filename = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Serving.AssetFile.Builder {
                let resultDecodedBuilder = Tensorflow.Serving.AssetFile.Builder()
                if let jsonValueTensorBinding = jsonMap["tensorBinding"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.tensorBinding = try Tensorflow.Serving.TensorBinding.Builder.decodeToBuilder(jsonMap:jsonValueTensorBinding).build()

                }
                if let jsonValueFilename = jsonMap["filename"] as? String {
                    resultDecodedBuilder.filename = jsonValueFilename
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Serving.AssetFile.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.Serving.AssetFile.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// A Signature specifies the inputs and outputs of commonly used graphs.
    final public class Signature : GeneratedMessage {

        public static func == (lhs: Tensorflow.Serving.Signature, rhs: Tensorflow.Serving.Signature) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasRegressionSignature == rhs.hasRegressionSignature) && (!lhs.hasRegressionSignature || lhs.regressionSignature == rhs.regressionSignature)
            fieldCheck = fieldCheck && (lhs.hasClassificationSignature == rhs.hasClassificationSignature) && (!lhs.hasClassificationSignature || lhs.classificationSignature == rhs.classificationSignature)
            fieldCheck = fieldCheck && (lhs.hasGenericSignature == rhs.hasGenericSignature) && (!lhs.hasGenericSignature || lhs.genericSignature == rhs.genericSignature)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //OneOf declaration start

        public enum `Type` {
            case OneOfTypeNotSet

            public func checkOneOfIsSet() -> Bool {
                switch self {
                case .OneOfTypeNotSet: return false
                default: return true
                }
            }
            case RegressionSignature(Tensorflow.Serving.RegressionSignature)

            public static func getRegressionSignature(_ value:Type) -> Tensorflow.Serving.RegressionSignature? {
                switch value {
                case .RegressionSignature(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case ClassificationSignature(Tensorflow.Serving.ClassificationSignature)

            public static func getClassificationSignature(_ value:Type) -> Tensorflow.Serving.ClassificationSignature? {
                switch value {
                case .ClassificationSignature(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case GenericSignature(Tensorflow.Serving.GenericSignature)

            public static func getGenericSignature(_ value:Type) -> Tensorflow.Serving.GenericSignature? {
                switch value {
                case .GenericSignature(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
        }
        //OneOf declaration end

        fileprivate var storageType:Signature.Type =  Signature.Type.OneOfTypeNotSet
        public func getOneOfType() ->  Signature.Type {
            let copyObjectType = storageType
            return copyObjectType
        }
        public fileprivate(set) var regressionSignature:Tensorflow.Serving.RegressionSignature!{
            get {
                return Signature.Type.getRegressionSignature(storageType)
            }
            set (newvalue) {
                storageType = Signature.Type.RegressionSignature(newvalue)
            }
        }
        public fileprivate(set) var hasRegressionSignature:Bool {
            get {
                guard let _ = Signature.Type.getRegressionSignature(storageType) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var classificationSignature:Tensorflow.Serving.ClassificationSignature!{
            get {
                return Signature.Type.getClassificationSignature(storageType)
            }
            set (newvalue) {
                storageType = Signature.Type.ClassificationSignature(newvalue)
            }
        }
        public fileprivate(set) var hasClassificationSignature:Bool {
            get {
                guard let _ = Signature.Type.getClassificationSignature(storageType) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var genericSignature:Tensorflow.Serving.GenericSignature!{
            get {
                return Signature.Type.getGenericSignature(storageType)
            }
            set (newvalue) {
                storageType = Signature.Type.GenericSignature(newvalue)
            }
        }
        public fileprivate(set) var hasGenericSignature:Bool {
            get {
                guard let _ = Signature.Type.getGenericSignature(storageType) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasRegressionSignature {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:regressionSignature)
            }
            if hasClassificationSignature {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:classificationSignature)
            }
            if hasGenericSignature {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:genericSignature)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasRegressionSignature {
                if let varSizeregressionSignature = regressionSignature?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeregressionSignature
                }
            }
            if hasClassificationSignature {
                if let varSizeclassificationSignature = classificationSignature?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeclassificationSignature
                }
            }
            if hasGenericSignature {
                if let varSizegenericSignature = genericSignature?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizegenericSignature
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.Serving.Signature.Builder {
            return Tensorflow.Serving.Signature.classBuilder() as! Tensorflow.Serving.Signature.Builder
        }
        public func getBuilder() -> Tensorflow.Serving.Signature.Builder {
            return classBuilder() as! Tensorflow.Serving.Signature.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Serving.Signature.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Serving.Signature.Builder()
        }
        public func toBuilder() throws -> Tensorflow.Serving.Signature.Builder {
            return try Tensorflow.Serving.Signature.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.Serving.Signature) throws -> Tensorflow.Serving.Signature.Builder {
            return try Tensorflow.Serving.Signature.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasRegressionSignature {
                jsonMap["regressionSignature"] = try regressionSignature.encode()
            }
            if hasClassificationSignature {
                jsonMap["classificationSignature"] = try classificationSignature.encode()
            }
            if hasGenericSignature {
                jsonMap["genericSignature"] = try genericSignature.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Serving.Signature {
            return try Tensorflow.Serving.Signature.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.Serving.Signature {
            return try Tensorflow.Serving.Signature.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasRegressionSignature {
                output += "\(indent) regressionSignature {\n"
                if let outDescRegressionSignature = regressionSignature {
                    output += try outDescRegressionSignature.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasClassificationSignature {
                output += "\(indent) classificationSignature {\n"
                if let outDescClassificationSignature = classificationSignature {
                    output += try outDescClassificationSignature.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasGenericSignature {
                output += "\(indent) genericSignature {\n"
                if let outDescGenericSignature = genericSignature {
                    output += try outDescGenericSignature.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasRegressionSignature {
                    if let hashValueregressionSignature = regressionSignature?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueregressionSignature
                    }
                }
                if hasClassificationSignature {
                    if let hashValueclassificationSignature = classificationSignature?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueclassificationSignature
                    }
                }
                if hasGenericSignature {
                    if let hashValuegenericSignature = genericSignature?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuegenericSignature
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.Serving.Signature"
        }
        override public func className() -> String {
            return "Tensorflow.Serving.Signature"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.Serving.Signature = Tensorflow.Serving.Signature()
            public func getMessage() -> Tensorflow.Serving.Signature {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var regressionSignature:Tensorflow.Serving.RegressionSignature! {
                get {
                    if regressionSignatureBuilder_ != nil {
                        builderResult.regressionSignature = regressionSignatureBuilder_.getMessage()
                    }
                    return builderResult.regressionSignature
                }
                set (value) {
                    builderResult.hasRegressionSignature = true
                    builderResult.regressionSignature = value
                }
            }
            public var hasRegressionSignature:Bool {
                get {
                    return builderResult.hasRegressionSignature
                }
            }
            fileprivate var regressionSignatureBuilder_:Tensorflow.Serving.RegressionSignature.Builder! {
                didSet {
                    builderResult.hasRegressionSignature = true
                }
            }
            public func getRegressionSignatureBuilder() -> Tensorflow.Serving.RegressionSignature.Builder {
                if regressionSignatureBuilder_ == nil {
                    regressionSignatureBuilder_ = Tensorflow.Serving.RegressionSignature.Builder()
                    builderResult.regressionSignature = regressionSignatureBuilder_.getMessage()
                    if regressionSignature != nil {
                        try! regressionSignatureBuilder_.mergeFrom(other: regressionSignature)
                    }
                }
                return regressionSignatureBuilder_
            }
            @discardableResult
            public func setRegressionSignature(_ value:Tensorflow.Serving.RegressionSignature!) -> Tensorflow.Serving.Signature.Builder {
                self.regressionSignature = value
                return self
            }
            @discardableResult
            public func mergeRegressionSignature(value:Tensorflow.Serving.RegressionSignature) throws -> Tensorflow.Serving.Signature.Builder {
                if builderResult.hasRegressionSignature {
                    builderResult.regressionSignature = try Tensorflow.Serving.RegressionSignature.builderWithPrototype(prototype:builderResult.regressionSignature).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.regressionSignature = value
                }
                builderResult.hasRegressionSignature = true
                return self
            }
            @discardableResult
            public func clearRegressionSignature() -> Tensorflow.Serving.Signature.Builder {
                regressionSignatureBuilder_ = nil
                builderResult.hasRegressionSignature = false
                builderResult.regressionSignature = nil
                return self
            }
            public var classificationSignature:Tensorflow.Serving.ClassificationSignature! {
                get {
                    if classificationSignatureBuilder_ != nil {
                        builderResult.classificationSignature = classificationSignatureBuilder_.getMessage()
                    }
                    return builderResult.classificationSignature
                }
                set (value) {
                    builderResult.hasClassificationSignature = true
                    builderResult.classificationSignature = value
                }
            }
            public var hasClassificationSignature:Bool {
                get {
                    return builderResult.hasClassificationSignature
                }
            }
            fileprivate var classificationSignatureBuilder_:Tensorflow.Serving.ClassificationSignature.Builder! {
                didSet {
                    builderResult.hasClassificationSignature = true
                }
            }
            public func getClassificationSignatureBuilder() -> Tensorflow.Serving.ClassificationSignature.Builder {
                if classificationSignatureBuilder_ == nil {
                    classificationSignatureBuilder_ = Tensorflow.Serving.ClassificationSignature.Builder()
                    builderResult.classificationSignature = classificationSignatureBuilder_.getMessage()
                    if classificationSignature != nil {
                        try! classificationSignatureBuilder_.mergeFrom(other: classificationSignature)
                    }
                }
                return classificationSignatureBuilder_
            }
            @discardableResult
            public func setClassificationSignature(_ value:Tensorflow.Serving.ClassificationSignature!) -> Tensorflow.Serving.Signature.Builder {
                self.classificationSignature = value
                return self
            }
            @discardableResult
            public func mergeClassificationSignature(value:Tensorflow.Serving.ClassificationSignature) throws -> Tensorflow.Serving.Signature.Builder {
                if builderResult.hasClassificationSignature {
                    builderResult.classificationSignature = try Tensorflow.Serving.ClassificationSignature.builderWithPrototype(prototype:builderResult.classificationSignature).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.classificationSignature = value
                }
                builderResult.hasClassificationSignature = true
                return self
            }
            @discardableResult
            public func clearClassificationSignature() -> Tensorflow.Serving.Signature.Builder {
                classificationSignatureBuilder_ = nil
                builderResult.hasClassificationSignature = false
                builderResult.classificationSignature = nil
                return self
            }
            public var genericSignature:Tensorflow.Serving.GenericSignature! {
                get {
                    if genericSignatureBuilder_ != nil {
                        builderResult.genericSignature = genericSignatureBuilder_.getMessage()
                    }
                    return builderResult.genericSignature
                }
                set (value) {
                    builderResult.hasGenericSignature = true
                    builderResult.genericSignature = value
                }
            }
            public var hasGenericSignature:Bool {
                get {
                    return builderResult.hasGenericSignature
                }
            }
            fileprivate var genericSignatureBuilder_:Tensorflow.Serving.GenericSignature.Builder! {
                didSet {
                    builderResult.hasGenericSignature = true
                }
            }
            public func getGenericSignatureBuilder() -> Tensorflow.Serving.GenericSignature.Builder {
                if genericSignatureBuilder_ == nil {
                    genericSignatureBuilder_ = Tensorflow.Serving.GenericSignature.Builder()
                    builderResult.genericSignature = genericSignatureBuilder_.getMessage()
                    if genericSignature != nil {
                        try! genericSignatureBuilder_.mergeFrom(other: genericSignature)
                    }
                }
                return genericSignatureBuilder_
            }
            @discardableResult
            public func setGenericSignature(_ value:Tensorflow.Serving.GenericSignature!) -> Tensorflow.Serving.Signature.Builder {
                self.genericSignature = value
                return self
            }
            @discardableResult
            public func mergeGenericSignature(value:Tensorflow.Serving.GenericSignature) throws -> Tensorflow.Serving.Signature.Builder {
                if builderResult.hasGenericSignature {
                    builderResult.genericSignature = try Tensorflow.Serving.GenericSignature.builderWithPrototype(prototype:builderResult.genericSignature).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.genericSignature = value
                }
                builderResult.hasGenericSignature = true
                return self
            }
            @discardableResult
            public func clearGenericSignature() -> Tensorflow.Serving.Signature.Builder {
                genericSignatureBuilder_ = nil
                builderResult.hasGenericSignature = false
                builderResult.genericSignature = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.Serving.Signature.Builder {
                builderResult = Tensorflow.Serving.Signature()
                return self
            }
            override public func clone() throws -> Tensorflow.Serving.Signature.Builder {
                return try Tensorflow.Serving.Signature.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.Serving.Signature {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.Serving.Signature {
                let returnMe:Tensorflow.Serving.Signature = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.Serving.Signature) throws -> Tensorflow.Serving.Signature.Builder {
                if other == Tensorflow.Serving.Signature() {
                    return self
                }
                if (other.hasRegressionSignature) {
                    try mergeRegressionSignature(value: other.regressionSignature)
                }
                if (other.hasClassificationSignature) {
                    try mergeClassificationSignature(value: other.classificationSignature)
                }
                if (other.hasGenericSignature) {
                    try mergeGenericSignature(value: other.genericSignature)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Serving.Signature.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.Signature.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Tensorflow.Serving.RegressionSignature.Builder = Tensorflow.Serving.RegressionSignature.Builder()
                        if hasRegressionSignature {
                            try subBuilder.mergeFrom(other: regressionSignature)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        regressionSignature = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Tensorflow.Serving.ClassificationSignature.Builder = Tensorflow.Serving.ClassificationSignature.Builder()
                        if hasClassificationSignature {
                            try subBuilder.mergeFrom(other: classificationSignature)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        classificationSignature = subBuilder.buildPartial()

                    case 26:
                        let subBuilder:Tensorflow.Serving.GenericSignature.Builder = Tensorflow.Serving.GenericSignature.Builder()
                        if hasGenericSignature {
                            try subBuilder.mergeFrom(other: genericSignature)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        genericSignature = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Serving.Signature.Builder {
                let resultDecodedBuilder = Tensorflow.Serving.Signature.Builder()
                if let jsonValueRegressionSignature = jsonMap["regressionSignature"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.regressionSignature = try Tensorflow.Serving.RegressionSignature.Builder.decodeToBuilder(jsonMap:jsonValueRegressionSignature).build()

                }
                if let jsonValueClassificationSignature = jsonMap["classificationSignature"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.classificationSignature = try Tensorflow.Serving.ClassificationSignature.Builder.decodeToBuilder(jsonMap:jsonValueClassificationSignature).build()

                }
                if let jsonValueGenericSignature = jsonMap["genericSignature"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.genericSignature = try Tensorflow.Serving.GenericSignature.Builder.decodeToBuilder(jsonMap:jsonValueGenericSignature).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Serving.Signature.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.Serving.Signature.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// RegressionSignature specifies a graph that takes an input and returns an
    /// output.
    final public class RegressionSignature : GeneratedMessage {

        public static func == (lhs: Tensorflow.Serving.RegressionSignature, rhs: Tensorflow.Serving.RegressionSignature) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasInput == rhs.hasInput) && (!lhs.hasInput || lhs.input == rhs.input)
            fieldCheck = fieldCheck && (lhs.hasOutput == rhs.hasOutput) && (!lhs.hasOutput || lhs.output == rhs.output)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var input:Tensorflow.Serving.TensorBinding!
        public fileprivate(set) var hasInput:Bool = false
        public fileprivate(set) var output:Tensorflow.Serving.TensorBinding!
        public fileprivate(set) var hasOutput:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasInput {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:input)
            }
            if hasOutput {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:output)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasInput {
                if let varSizeinput = input?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeinput
                }
            }
            if hasOutput {
                if let varSizeoutput = output?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeoutput
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.Serving.RegressionSignature.Builder {
            return Tensorflow.Serving.RegressionSignature.classBuilder() as! Tensorflow.Serving.RegressionSignature.Builder
        }
        public func getBuilder() -> Tensorflow.Serving.RegressionSignature.Builder {
            return classBuilder() as! Tensorflow.Serving.RegressionSignature.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Serving.RegressionSignature.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Serving.RegressionSignature.Builder()
        }
        public func toBuilder() throws -> Tensorflow.Serving.RegressionSignature.Builder {
            return try Tensorflow.Serving.RegressionSignature.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.Serving.RegressionSignature) throws -> Tensorflow.Serving.RegressionSignature.Builder {
            return try Tensorflow.Serving.RegressionSignature.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasInput {
                jsonMap["input"] = try input.encode()
            }
            if hasOutput {
                jsonMap["output"] = try output.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Serving.RegressionSignature {
            return try Tensorflow.Serving.RegressionSignature.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.Serving.RegressionSignature {
            return try Tensorflow.Serving.RegressionSignature.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasInput {
                output += "\(indent) input {\n"
                if let outDescInput = input {
                    output += try outDescInput.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasOutput {
                output += "\(indent) output {\n"
                if let outDescOutput = output {
                    output += try outDescOutput.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasInput {
                    if let hashValueinput = input?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueinput
                    }
                }
                if hasOutput {
                    if let hashValueoutput = output?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoutput
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.Serving.RegressionSignature"
        }
        override public func className() -> String {
            return "Tensorflow.Serving.RegressionSignature"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.Serving.RegressionSignature = Tensorflow.Serving.RegressionSignature()
            public func getMessage() -> Tensorflow.Serving.RegressionSignature {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var input:Tensorflow.Serving.TensorBinding! {
                get {
                    if inputBuilder_ != nil {
                        builderResult.input = inputBuilder_.getMessage()
                    }
                    return builderResult.input
                }
                set (value) {
                    builderResult.hasInput = true
                    builderResult.input = value
                }
            }
            public var hasInput:Bool {
                get {
                    return builderResult.hasInput
                }
            }
            fileprivate var inputBuilder_:Tensorflow.Serving.TensorBinding.Builder! {
                didSet {
                    builderResult.hasInput = true
                }
            }
            public func getInputBuilder() -> Tensorflow.Serving.TensorBinding.Builder {
                if inputBuilder_ == nil {
                    inputBuilder_ = Tensorflow.Serving.TensorBinding.Builder()
                    builderResult.input = inputBuilder_.getMessage()
                    if input != nil {
                        try! inputBuilder_.mergeFrom(other: input)
                    }
                }
                return inputBuilder_
            }
            @discardableResult
            public func setInput(_ value:Tensorflow.Serving.TensorBinding!) -> Tensorflow.Serving.RegressionSignature.Builder {
                self.input = value
                return self
            }
            @discardableResult
            public func mergeInput(value:Tensorflow.Serving.TensorBinding) throws -> Tensorflow.Serving.RegressionSignature.Builder {
                if builderResult.hasInput {
                    builderResult.input = try Tensorflow.Serving.TensorBinding.builderWithPrototype(prototype:builderResult.input).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.input = value
                }
                builderResult.hasInput = true
                return self
            }
            @discardableResult
            public func clearInput() -> Tensorflow.Serving.RegressionSignature.Builder {
                inputBuilder_ = nil
                builderResult.hasInput = false
                builderResult.input = nil
                return self
            }
            public var output:Tensorflow.Serving.TensorBinding! {
                get {
                    if outputBuilder_ != nil {
                        builderResult.output = outputBuilder_.getMessage()
                    }
                    return builderResult.output
                }
                set (value) {
                    builderResult.hasOutput = true
                    builderResult.output = value
                }
            }
            public var hasOutput:Bool {
                get {
                    return builderResult.hasOutput
                }
            }
            fileprivate var outputBuilder_:Tensorflow.Serving.TensorBinding.Builder! {
                didSet {
                    builderResult.hasOutput = true
                }
            }
            public func getOutputBuilder() -> Tensorflow.Serving.TensorBinding.Builder {
                if outputBuilder_ == nil {
                    outputBuilder_ = Tensorflow.Serving.TensorBinding.Builder()
                    builderResult.output = outputBuilder_.getMessage()
                    if output != nil {
                        try! outputBuilder_.mergeFrom(other: output)
                    }
                }
                return outputBuilder_
            }
            @discardableResult
            public func setOutput(_ value:Tensorflow.Serving.TensorBinding!) -> Tensorflow.Serving.RegressionSignature.Builder {
                self.output = value
                return self
            }
            @discardableResult
            public func mergeOutput(value:Tensorflow.Serving.TensorBinding) throws -> Tensorflow.Serving.RegressionSignature.Builder {
                if builderResult.hasOutput {
                    builderResult.output = try Tensorflow.Serving.TensorBinding.builderWithPrototype(prototype:builderResult.output).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.output = value
                }
                builderResult.hasOutput = true
                return self
            }
            @discardableResult
            public func clearOutput() -> Tensorflow.Serving.RegressionSignature.Builder {
                outputBuilder_ = nil
                builderResult.hasOutput = false
                builderResult.output = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.Serving.RegressionSignature.Builder {
                builderResult = Tensorflow.Serving.RegressionSignature()
                return self
            }
            override public func clone() throws -> Tensorflow.Serving.RegressionSignature.Builder {
                return try Tensorflow.Serving.RegressionSignature.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.Serving.RegressionSignature {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.Serving.RegressionSignature {
                let returnMe:Tensorflow.Serving.RegressionSignature = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.Serving.RegressionSignature) throws -> Tensorflow.Serving.RegressionSignature.Builder {
                if other == Tensorflow.Serving.RegressionSignature() {
                    return self
                }
                if (other.hasInput) {
                    try mergeInput(value: other.input)
                }
                if (other.hasOutput) {
                    try mergeOutput(value: other.output)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Serving.RegressionSignature.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.RegressionSignature.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Tensorflow.Serving.TensorBinding.Builder = Tensorflow.Serving.TensorBinding.Builder()
                        if hasInput {
                            try subBuilder.mergeFrom(other: input)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        input = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Tensorflow.Serving.TensorBinding.Builder = Tensorflow.Serving.TensorBinding.Builder()
                        if hasOutput {
                            try subBuilder.mergeFrom(other: output)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        output = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Serving.RegressionSignature.Builder {
                let resultDecodedBuilder = Tensorflow.Serving.RegressionSignature.Builder()
                if let jsonValueInput = jsonMap["input"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.input = try Tensorflow.Serving.TensorBinding.Builder.decodeToBuilder(jsonMap:jsonValueInput).build()

                }
                if let jsonValueOutput = jsonMap["output"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.output = try Tensorflow.Serving.TensorBinding.Builder.decodeToBuilder(jsonMap:jsonValueOutput).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Serving.RegressionSignature.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.Serving.RegressionSignature.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// ClassificationSignature specifies a graph that takes an input and returns
    /// classes and their scores.
    /// WARNING(break-tutorial-inline-code): The following code snippet is
    /// in-lined in tutorials, please update tutorial documents accordingly
    /// whenever code changes.
    final public class ClassificationSignature : GeneratedMessage {

        public static func == (lhs: Tensorflow.Serving.ClassificationSignature, rhs: Tensorflow.Serving.ClassificationSignature) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasInput == rhs.hasInput) && (!lhs.hasInput || lhs.input == rhs.input)
            fieldCheck = fieldCheck && (lhs.hasClasses == rhs.hasClasses) && (!lhs.hasClasses || lhs.classes == rhs.classes)
            fieldCheck = fieldCheck && (lhs.hasScores == rhs.hasScores) && (!lhs.hasScores || lhs.scores == rhs.scores)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var input:Tensorflow.Serving.TensorBinding!
        public fileprivate(set) var hasInput:Bool = false
        public fileprivate(set) var classes:Tensorflow.Serving.TensorBinding!
        public fileprivate(set) var hasClasses:Bool = false
        public fileprivate(set) var scores:Tensorflow.Serving.TensorBinding!
        public fileprivate(set) var hasScores:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasInput {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:input)
            }
            if hasClasses {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:classes)
            }
            if hasScores {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:scores)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasInput {
                if let varSizeinput = input?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeinput
                }
            }
            if hasClasses {
                if let varSizeclasses = classes?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeclasses
                }
            }
            if hasScores {
                if let varSizescores = scores?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizescores
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.Serving.ClassificationSignature.Builder {
            return Tensorflow.Serving.ClassificationSignature.classBuilder() as! Tensorflow.Serving.ClassificationSignature.Builder
        }
        public func getBuilder() -> Tensorflow.Serving.ClassificationSignature.Builder {
            return classBuilder() as! Tensorflow.Serving.ClassificationSignature.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Serving.ClassificationSignature.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Serving.ClassificationSignature.Builder()
        }
        public func toBuilder() throws -> Tensorflow.Serving.ClassificationSignature.Builder {
            return try Tensorflow.Serving.ClassificationSignature.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.Serving.ClassificationSignature) throws -> Tensorflow.Serving.ClassificationSignature.Builder {
            return try Tensorflow.Serving.ClassificationSignature.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasInput {
                jsonMap["input"] = try input.encode()
            }
            if hasClasses {
                jsonMap["classes"] = try classes.encode()
            }
            if hasScores {
                jsonMap["scores"] = try scores.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Serving.ClassificationSignature {
            return try Tensorflow.Serving.ClassificationSignature.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.Serving.ClassificationSignature {
            return try Tensorflow.Serving.ClassificationSignature.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasInput {
                output += "\(indent) input {\n"
                if let outDescInput = input {
                    output += try outDescInput.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasClasses {
                output += "\(indent) classes {\n"
                if let outDescClasses = classes {
                    output += try outDescClasses.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasScores {
                output += "\(indent) scores {\n"
                if let outDescScores = scores {
                    output += try outDescScores.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasInput {
                    if let hashValueinput = input?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueinput
                    }
                }
                if hasClasses {
                    if let hashValueclasses = classes?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueclasses
                    }
                }
                if hasScores {
                    if let hashValuescores = scores?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuescores
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.Serving.ClassificationSignature"
        }
        override public func className() -> String {
            return "Tensorflow.Serving.ClassificationSignature"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.Serving.ClassificationSignature = Tensorflow.Serving.ClassificationSignature()
            public func getMessage() -> Tensorflow.Serving.ClassificationSignature {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var input:Tensorflow.Serving.TensorBinding! {
                get {
                    if inputBuilder_ != nil {
                        builderResult.input = inputBuilder_.getMessage()
                    }
                    return builderResult.input
                }
                set (value) {
                    builderResult.hasInput = true
                    builderResult.input = value
                }
            }
            public var hasInput:Bool {
                get {
                    return builderResult.hasInput
                }
            }
            fileprivate var inputBuilder_:Tensorflow.Serving.TensorBinding.Builder! {
                didSet {
                    builderResult.hasInput = true
                }
            }
            public func getInputBuilder() -> Tensorflow.Serving.TensorBinding.Builder {
                if inputBuilder_ == nil {
                    inputBuilder_ = Tensorflow.Serving.TensorBinding.Builder()
                    builderResult.input = inputBuilder_.getMessage()
                    if input != nil {
                        try! inputBuilder_.mergeFrom(other: input)
                    }
                }
                return inputBuilder_
            }
            @discardableResult
            public func setInput(_ value:Tensorflow.Serving.TensorBinding!) -> Tensorflow.Serving.ClassificationSignature.Builder {
                self.input = value
                return self
            }
            @discardableResult
            public func mergeInput(value:Tensorflow.Serving.TensorBinding) throws -> Tensorflow.Serving.ClassificationSignature.Builder {
                if builderResult.hasInput {
                    builderResult.input = try Tensorflow.Serving.TensorBinding.builderWithPrototype(prototype:builderResult.input).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.input = value
                }
                builderResult.hasInput = true
                return self
            }
            @discardableResult
            public func clearInput() -> Tensorflow.Serving.ClassificationSignature.Builder {
                inputBuilder_ = nil
                builderResult.hasInput = false
                builderResult.input = nil
                return self
            }
            public var classes:Tensorflow.Serving.TensorBinding! {
                get {
                    if classesBuilder_ != nil {
                        builderResult.classes = classesBuilder_.getMessage()
                    }
                    return builderResult.classes
                }
                set (value) {
                    builderResult.hasClasses = true
                    builderResult.classes = value
                }
            }
            public var hasClasses:Bool {
                get {
                    return builderResult.hasClasses
                }
            }
            fileprivate var classesBuilder_:Tensorflow.Serving.TensorBinding.Builder! {
                didSet {
                    builderResult.hasClasses = true
                }
            }
            public func getClassesBuilder() -> Tensorflow.Serving.TensorBinding.Builder {
                if classesBuilder_ == nil {
                    classesBuilder_ = Tensorflow.Serving.TensorBinding.Builder()
                    builderResult.classes = classesBuilder_.getMessage()
                    if classes != nil {
                        try! classesBuilder_.mergeFrom(other: classes)
                    }
                }
                return classesBuilder_
            }
            @discardableResult
            public func setClasses(_ value:Tensorflow.Serving.TensorBinding!) -> Tensorflow.Serving.ClassificationSignature.Builder {
                self.classes = value
                return self
            }
            @discardableResult
            public func mergeClasses(value:Tensorflow.Serving.TensorBinding) throws -> Tensorflow.Serving.ClassificationSignature.Builder {
                if builderResult.hasClasses {
                    builderResult.classes = try Tensorflow.Serving.TensorBinding.builderWithPrototype(prototype:builderResult.classes).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.classes = value
                }
                builderResult.hasClasses = true
                return self
            }
            @discardableResult
            public func clearClasses() -> Tensorflow.Serving.ClassificationSignature.Builder {
                classesBuilder_ = nil
                builderResult.hasClasses = false
                builderResult.classes = nil
                return self
            }
            public var scores:Tensorflow.Serving.TensorBinding! {
                get {
                    if scoresBuilder_ != nil {
                        builderResult.scores = scoresBuilder_.getMessage()
                    }
                    return builderResult.scores
                }
                set (value) {
                    builderResult.hasScores = true
                    builderResult.scores = value
                }
            }
            public var hasScores:Bool {
                get {
                    return builderResult.hasScores
                }
            }
            fileprivate var scoresBuilder_:Tensorflow.Serving.TensorBinding.Builder! {
                didSet {
                    builderResult.hasScores = true
                }
            }
            public func getScoresBuilder() -> Tensorflow.Serving.TensorBinding.Builder {
                if scoresBuilder_ == nil {
                    scoresBuilder_ = Tensorflow.Serving.TensorBinding.Builder()
                    builderResult.scores = scoresBuilder_.getMessage()
                    if scores != nil {
                        try! scoresBuilder_.mergeFrom(other: scores)
                    }
                }
                return scoresBuilder_
            }
            @discardableResult
            public func setScores(_ value:Tensorflow.Serving.TensorBinding!) -> Tensorflow.Serving.ClassificationSignature.Builder {
                self.scores = value
                return self
            }
            @discardableResult
            public func mergeScores(value:Tensorflow.Serving.TensorBinding) throws -> Tensorflow.Serving.ClassificationSignature.Builder {
                if builderResult.hasScores {
                    builderResult.scores = try Tensorflow.Serving.TensorBinding.builderWithPrototype(prototype:builderResult.scores).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.scores = value
                }
                builderResult.hasScores = true
                return self
            }
            @discardableResult
            public func clearScores() -> Tensorflow.Serving.ClassificationSignature.Builder {
                scoresBuilder_ = nil
                builderResult.hasScores = false
                builderResult.scores = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.Serving.ClassificationSignature.Builder {
                builderResult = Tensorflow.Serving.ClassificationSignature()
                return self
            }
            override public func clone() throws -> Tensorflow.Serving.ClassificationSignature.Builder {
                return try Tensorflow.Serving.ClassificationSignature.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.Serving.ClassificationSignature {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.Serving.ClassificationSignature {
                let returnMe:Tensorflow.Serving.ClassificationSignature = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.Serving.ClassificationSignature) throws -> Tensorflow.Serving.ClassificationSignature.Builder {
                if other == Tensorflow.Serving.ClassificationSignature() {
                    return self
                }
                if (other.hasInput) {
                    try mergeInput(value: other.input)
                }
                if (other.hasClasses) {
                    try mergeClasses(value: other.classes)
                }
                if (other.hasScores) {
                    try mergeScores(value: other.scores)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Serving.ClassificationSignature.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.ClassificationSignature.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Tensorflow.Serving.TensorBinding.Builder = Tensorflow.Serving.TensorBinding.Builder()
                        if hasInput {
                            try subBuilder.mergeFrom(other: input)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        input = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Tensorflow.Serving.TensorBinding.Builder = Tensorflow.Serving.TensorBinding.Builder()
                        if hasClasses {
                            try subBuilder.mergeFrom(other: classes)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        classes = subBuilder.buildPartial()

                    case 26:
                        let subBuilder:Tensorflow.Serving.TensorBinding.Builder = Tensorflow.Serving.TensorBinding.Builder()
                        if hasScores {
                            try subBuilder.mergeFrom(other: scores)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        scores = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Serving.ClassificationSignature.Builder {
                let resultDecodedBuilder = Tensorflow.Serving.ClassificationSignature.Builder()
                if let jsonValueInput = jsonMap["input"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.input = try Tensorflow.Serving.TensorBinding.Builder.decodeToBuilder(jsonMap:jsonValueInput).build()

                }
                if let jsonValueClasses = jsonMap["classes"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.classes = try Tensorflow.Serving.TensorBinding.Builder.decodeToBuilder(jsonMap:jsonValueClasses).build()

                }
                if let jsonValueScores = jsonMap["scores"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.scores = try Tensorflow.Serving.TensorBinding.Builder.decodeToBuilder(jsonMap:jsonValueScores).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Serving.ClassificationSignature.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.Serving.ClassificationSignature.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// GenericSignature specifies a map from logical name to Tensor name.
    /// Typical application of GenericSignature is to use a single GenericSignature
    /// that includes all of the Tensor nodes and target names that may be useful at
    /// serving, analysis or debugging time. The recommended name for this signature
    /// in the ModelManifest is "generic_bindings".
    final public class GenericSignature : GeneratedMessage {

        public static func == (lhs: Tensorflow.Serving.GenericSignature, rhs: Tensorflow.Serving.GenericSignature) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasMap == rhs.hasMap) && (!lhs.hasMap || lhs.map == rhs.map)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        final public class MapEntry : GeneratedMessage {

            public static func == (lhs: Tensorflow.Serving.GenericSignature.MapEntry, rhs: Tensorflow.Serving.GenericSignature.MapEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:String = ""
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:Tensorflow.Serving.TensorBinding!
            public fileprivate(set) var hasValue:Bool = false
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeString(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeMessage(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeStringSize(fieldNumber: 1)
                }
                if hasValue {
                    if let varSizevalue = value?.computeMessageSize(fieldNumber: 2) {
                        serialize_size += varSizevalue
                    }
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.Serving.GenericSignature.MapEntry.Builder {
                return Tensorflow.Serving.GenericSignature.MapEntry.classBuilder() as! Tensorflow.Serving.GenericSignature.MapEntry.Builder
            }
            public func getBuilder() -> Tensorflow.Serving.GenericSignature.MapEntry.Builder {
                return classBuilder() as! Tensorflow.Serving.GenericSignature.MapEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.Serving.GenericSignature.MapEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.Serving.GenericSignature.MapEntry.Builder()
            }
            public func toBuilder() throws -> Tensorflow.Serving.GenericSignature.MapEntry.Builder {
                return try Tensorflow.Serving.GenericSignature.MapEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.Serving.GenericSignature.MapEntry) throws -> Tensorflow.Serving.GenericSignature.MapEntry.Builder {
                return try Tensorflow.Serving.GenericSignature.MapEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = key
                }
                if hasValue {
                    jsonMap["value"] = try value.encode()
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Serving.GenericSignature.MapEntry {
                return try Tensorflow.Serving.GenericSignature.MapEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.Serving.GenericSignature.MapEntry {
                return try Tensorflow.Serving.GenericSignature.MapEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value {\n"
                    if let outDescValue = value {
                        output += try outDescValue.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        if let hashValuevalue = value?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuevalue
                        }
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.Serving.GenericSignature.MapEntry"
            }
            override public func className() -> String {
                return "Tensorflow.Serving.GenericSignature.MapEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.Serving.GenericSignature.MapEntry = Tensorflow.Serving.GenericSignature.MapEntry()
                public func getMessage() -> Tensorflow.Serving.GenericSignature.MapEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:String {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:String) -> Tensorflow.Serving.GenericSignature.MapEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> Tensorflow.Serving.GenericSignature.MapEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = ""
                    return self
                }
                public var value:Tensorflow.Serving.TensorBinding! {
                    get {
                        if valueBuilder_ != nil {
                            builderResult.value = valueBuilder_.getMessage()
                        }
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                fileprivate var valueBuilder_:Tensorflow.Serving.TensorBinding.Builder! {
                    didSet {
                        builderResult.hasValue = true
                    }
                }
                public func getValueBuilder() -> Tensorflow.Serving.TensorBinding.Builder {
                    if valueBuilder_ == nil {
                        valueBuilder_ = Tensorflow.Serving.TensorBinding.Builder()
                        builderResult.value = valueBuilder_.getMessage()
                        if value != nil {
                            try! valueBuilder_.mergeFrom(other: value)
                        }
                    }
                    return valueBuilder_
                }
                @discardableResult
                public func setValue(_ value:Tensorflow.Serving.TensorBinding!) -> Tensorflow.Serving.GenericSignature.MapEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func mergeValue(value:Tensorflow.Serving.TensorBinding) throws -> Tensorflow.Serving.GenericSignature.MapEntry.Builder {
                    if builderResult.hasValue {
                        builderResult.value = try Tensorflow.Serving.TensorBinding.builderWithPrototype(prototype:builderResult.value).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.value = value
                    }
                    builderResult.hasValue = true
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.Serving.GenericSignature.MapEntry.Builder {
                    valueBuilder_ = nil
                    builderResult.hasValue = false
                    builderResult.value = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.Serving.GenericSignature.MapEntry.Builder {
                    builderResult = Tensorflow.Serving.GenericSignature.MapEntry()
                    return self
                }
                override public func clone() throws -> Tensorflow.Serving.GenericSignature.MapEntry.Builder {
                    return try Tensorflow.Serving.GenericSignature.MapEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.Serving.GenericSignature.MapEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.Serving.GenericSignature.MapEntry {
                    let returnMe:Tensorflow.Serving.GenericSignature.MapEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.Serving.GenericSignature.MapEntry) throws -> Tensorflow.Serving.GenericSignature.MapEntry.Builder {
                    if other == Tensorflow.Serving.GenericSignature.MapEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if (other.hasValue) {
                        try mergeValue(value: other.value)
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Serving.GenericSignature.MapEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.GenericSignature.MapEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            key = try codedInputStream.readString()

                        case 18:
                            let subBuilder:Tensorflow.Serving.TensorBinding.Builder = Tensorflow.Serving.TensorBinding.Builder()
                            if hasValue {
                                try subBuilder.mergeFrom(other: value)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            value = subBuilder.buildPartial()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Serving.GenericSignature.MapEntry.Builder {
                    let resultDecodedBuilder = Tensorflow.Serving.GenericSignature.MapEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = jsonValueKey
                    }
                    if let jsonValueValue = jsonMap["value"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.value = try Tensorflow.Serving.TensorBinding.Builder.decodeToBuilder(jsonMap:jsonValueValue).build()

                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Serving.GenericSignature.MapEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.Serving.GenericSignature.MapEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        public fileprivate(set) var map:Dictionary<String,Tensorflow.Serving.TensorBinding> = Dictionary<String,Tensorflow.Serving.TensorBinding>()

        public fileprivate(set) var hasMap:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasMap {
                for (keyMap, valueMap) in map {
                    let valueOfMap = try! Tensorflow.Serving.GenericSignature.MapEntry.Builder().setKey(keyMap).setValue(valueMap).build()
                      try codedOutputStream.writeMessage(fieldNumber: 1, value:valueOfMap)
                  }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasMap {
                  for (keyMap, valueMap) in map {
                      let valueOfMap = try! Tensorflow.Serving.GenericSignature.MapEntry.Builder().setKey(keyMap).setValue(valueMap).build()
                serialize_size += valueOfMap.computeMessageSize(fieldNumber: 1)
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.Serving.GenericSignature.Builder {
            return Tensorflow.Serving.GenericSignature.classBuilder() as! Tensorflow.Serving.GenericSignature.Builder
        }
        public func getBuilder() -> Tensorflow.Serving.GenericSignature.Builder {
            return classBuilder() as! Tensorflow.Serving.GenericSignature.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Serving.GenericSignature.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Serving.GenericSignature.Builder()
        }
        public func toBuilder() throws -> Tensorflow.Serving.GenericSignature.Builder {
            return try Tensorflow.Serving.GenericSignature.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.Serving.GenericSignature) throws -> Tensorflow.Serving.GenericSignature.Builder {
            return try Tensorflow.Serving.GenericSignature.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasMap {
                var mapMap = Dictionary<String, Dictionary<String,Any>>()
                for (keyMap, valueMap) in map {
                    mapMap["\(keyMap)"] = try valueMap.encode()
                }
                jsonMap["map"] = mapMap
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Serving.GenericSignature {
            return try Tensorflow.Serving.GenericSignature.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.Serving.GenericSignature {
            return try Tensorflow.Serving.GenericSignature.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasMap {
                output += "\(indent) map: \(map) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasMap {
                    for (keyMap, valueMap) in map {
                        hashCode = (hashCode &* 31) &+ keyMap.hashValue
                        hashCode = (hashCode &* 31) &+ valueMap.hashValue
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.Serving.GenericSignature"
        }
        override public func className() -> String {
            return "Tensorflow.Serving.GenericSignature"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.Serving.GenericSignature = Tensorflow.Serving.GenericSignature()
            public func getMessage() -> Tensorflow.Serving.GenericSignature {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var hasMap:Bool {
                get {
                    return builderResult.hasMap
                }
            }
            public var map:Dictionary<String,Tensorflow.Serving.TensorBinding> {
                get {
                    return builderResult.map
                }
                set (value) {
                    builderResult.hasMap = true
                    builderResult.map = value
                }
            }
            @discardableResult
            public func setMap(_ value:Dictionary<String,Tensorflow.Serving.TensorBinding>) -> Tensorflow.Serving.GenericSignature.Builder {
                self.map = value
                return self
            }
            @discardableResult
            public func clearMap() -> Tensorflow.Serving.GenericSignature.Builder{
                builderResult.hasMap = false
                builderResult.map = Dictionary<String,Tensorflow.Serving.TensorBinding>()
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.Serving.GenericSignature.Builder {
                builderResult = Tensorflow.Serving.GenericSignature()
                return self
            }
            override public func clone() throws -> Tensorflow.Serving.GenericSignature.Builder {
                return try Tensorflow.Serving.GenericSignature.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.Serving.GenericSignature {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.Serving.GenericSignature {
                let returnMe:Tensorflow.Serving.GenericSignature = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.Serving.GenericSignature) throws -> Tensorflow.Serving.GenericSignature.Builder {
                if other == Tensorflow.Serving.GenericSignature() {
                    return self
                }
                if other.hasMap {
                    map = other.map
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Serving.GenericSignature.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.GenericSignature.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Tensorflow.Serving.GenericSignature.MapEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfMap = subBuilder.buildPartial()
                        map[buildOfMap.key] = buildOfMap.value

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Serving.GenericSignature.Builder {
                let resultDecodedBuilder = Tensorflow.Serving.GenericSignature.Builder()
                if let jsonValueMap = jsonMap["map"] as? Dictionary<String, Dictionary<String,Any>> {
                    var mapMap = Dictionary<String, Tensorflow.Serving.TensorBinding>()
                    for (keyMap, valueMap) in jsonValueMap {
                        guard let keyFromMap = String(keyMap) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapMap[keyFromMap] = try Tensorflow.Serving.TensorBinding.Builder.decodeToBuilder(jsonMap:valueMap).build()

                    }
                    resultDecodedBuilder.map = mapMap
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Serving.GenericSignature.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.Serving.GenericSignature.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.Serving.Signatures: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Serving.Signatures> {
        var mergedArray = Array<Tensorflow.Serving.Signatures>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Serving.Signatures? {
        return try Tensorflow.Serving.Signatures.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Serving.Signatures {
        return try Tensorflow.Serving.Signatures.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.Serving.ManifestRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.Signatures {
        return try Tensorflow.Serving.Signatures.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Serving.Signatures {
        return try Tensorflow.Serving.Signatures.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.Signatures {
        return try Tensorflow.Serving.Signatures.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Serving.Signatures {
        return try Tensorflow.Serving.Signatures.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.Signatures {
        return try Tensorflow.Serving.Signatures.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "defaultSignature": return self.defaultSignature
        case "namedSignatures": return self.namedSignatures
        default: return nil
        }
    }
}
extension Tensorflow.Serving.Signatures.NamedSignaturesEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Serving.Signatures.NamedSignaturesEntry> {
        var mergedArray = Array<Tensorflow.Serving.Signatures.NamedSignaturesEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Serving.Signatures.NamedSignaturesEntry? {
        return try Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Serving.Signatures.NamedSignaturesEntry {
        return try Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.Serving.ManifestRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.Signatures.NamedSignaturesEntry {
        return try Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Serving.Signatures.NamedSignaturesEntry {
        return try Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.Signatures.NamedSignaturesEntry {
        return try Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Serving.Signatures.NamedSignaturesEntry {
        return try Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.Signatures.NamedSignaturesEntry {
        return try Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.Serving.Signatures.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "defaultSignature": return self.defaultSignature
            case "namedSignatures": return self.namedSignatures
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "defaultSignature":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Serving.Signature else {
                    return
                }
                self.defaultSignature = newSubscriptValue
            case "namedSignatures":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,Tensorflow.Serving.Signature> else {
                    return
                }
                self.namedSignatures = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Serving.Signatures.NamedSignaturesEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Serving.Signature else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Serving.TensorBinding: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Serving.TensorBinding> {
        var mergedArray = Array<Tensorflow.Serving.TensorBinding>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Serving.TensorBinding? {
        return try Tensorflow.Serving.TensorBinding.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Serving.TensorBinding {
        return try Tensorflow.Serving.TensorBinding.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.Serving.ManifestRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.TensorBinding {
        return try Tensorflow.Serving.TensorBinding.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Serving.TensorBinding {
        return try Tensorflow.Serving.TensorBinding.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.TensorBinding {
        return try Tensorflow.Serving.TensorBinding.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Serving.TensorBinding {
        return try Tensorflow.Serving.TensorBinding.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.TensorBinding {
        return try Tensorflow.Serving.TensorBinding.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "tensorName": return self.tensorName
        default: return nil
        }
    }
}
extension Tensorflow.Serving.TensorBinding.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "tensorName": return self.tensorName
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "tensorName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.tensorName = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Serving.AssetFile: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Serving.AssetFile> {
        var mergedArray = Array<Tensorflow.Serving.AssetFile>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Serving.AssetFile? {
        return try Tensorflow.Serving.AssetFile.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Serving.AssetFile {
        return try Tensorflow.Serving.AssetFile.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.Serving.ManifestRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.AssetFile {
        return try Tensorflow.Serving.AssetFile.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Serving.AssetFile {
        return try Tensorflow.Serving.AssetFile.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.AssetFile {
        return try Tensorflow.Serving.AssetFile.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Serving.AssetFile {
        return try Tensorflow.Serving.AssetFile.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.AssetFile {
        return try Tensorflow.Serving.AssetFile.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "tensorBinding": return self.tensorBinding
        case "filename": return self.filename
        default: return nil
        }
    }
}
extension Tensorflow.Serving.AssetFile.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "tensorBinding": return self.tensorBinding
            case "filename": return self.filename
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "tensorBinding":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Serving.TensorBinding else {
                    return
                }
                self.tensorBinding = newSubscriptValue
            case "filename":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.filename = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Serving.Signature: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Serving.Signature> {
        var mergedArray = Array<Tensorflow.Serving.Signature>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Serving.Signature? {
        return try Tensorflow.Serving.Signature.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Serving.Signature {
        return try Tensorflow.Serving.Signature.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.Serving.ManifestRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.Signature {
        return try Tensorflow.Serving.Signature.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Serving.Signature {
        return try Tensorflow.Serving.Signature.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.Signature {
        return try Tensorflow.Serving.Signature.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Serving.Signature {
        return try Tensorflow.Serving.Signature.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.Signature {
        return try Tensorflow.Serving.Signature.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "regressionSignature": return self.regressionSignature
        case "classificationSignature": return self.classificationSignature
        case "genericSignature": return self.genericSignature
        default: return nil
        }
    }
}
extension Tensorflow.Serving.Signature.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "regressionSignature": return self.regressionSignature
            case "classificationSignature": return self.classificationSignature
            case "genericSignature": return self.genericSignature
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "regressionSignature":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Serving.RegressionSignature else {
                    return
                }
                self.regressionSignature = newSubscriptValue
            case "classificationSignature":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Serving.ClassificationSignature else {
                    return
                }
                self.classificationSignature = newSubscriptValue
            case "genericSignature":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Serving.GenericSignature else {
                    return
                }
                self.genericSignature = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Serving.RegressionSignature: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Serving.RegressionSignature> {
        var mergedArray = Array<Tensorflow.Serving.RegressionSignature>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Serving.RegressionSignature? {
        return try Tensorflow.Serving.RegressionSignature.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Serving.RegressionSignature {
        return try Tensorflow.Serving.RegressionSignature.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.Serving.ManifestRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.RegressionSignature {
        return try Tensorflow.Serving.RegressionSignature.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Serving.RegressionSignature {
        return try Tensorflow.Serving.RegressionSignature.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.RegressionSignature {
        return try Tensorflow.Serving.RegressionSignature.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Serving.RegressionSignature {
        return try Tensorflow.Serving.RegressionSignature.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.RegressionSignature {
        return try Tensorflow.Serving.RegressionSignature.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "input": return self.input
        case "output": return self.output
        default: return nil
        }
    }
}
extension Tensorflow.Serving.RegressionSignature.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "input": return self.input
            case "output": return self.output
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "input":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Serving.TensorBinding else {
                    return
                }
                self.input = newSubscriptValue
            case "output":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Serving.TensorBinding else {
                    return
                }
                self.output = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Serving.ClassificationSignature: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Serving.ClassificationSignature> {
        var mergedArray = Array<Tensorflow.Serving.ClassificationSignature>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Serving.ClassificationSignature? {
        return try Tensorflow.Serving.ClassificationSignature.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Serving.ClassificationSignature {
        return try Tensorflow.Serving.ClassificationSignature.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.Serving.ManifestRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.ClassificationSignature {
        return try Tensorflow.Serving.ClassificationSignature.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Serving.ClassificationSignature {
        return try Tensorflow.Serving.ClassificationSignature.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.ClassificationSignature {
        return try Tensorflow.Serving.ClassificationSignature.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Serving.ClassificationSignature {
        return try Tensorflow.Serving.ClassificationSignature.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.ClassificationSignature {
        return try Tensorflow.Serving.ClassificationSignature.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "input": return self.input
        case "classes": return self.classes
        case "scores": return self.scores
        default: return nil
        }
    }
}
extension Tensorflow.Serving.ClassificationSignature.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "input": return self.input
            case "classes": return self.classes
            case "scores": return self.scores
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "input":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Serving.TensorBinding else {
                    return
                }
                self.input = newSubscriptValue
            case "classes":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Serving.TensorBinding else {
                    return
                }
                self.classes = newSubscriptValue
            case "scores":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Serving.TensorBinding else {
                    return
                }
                self.scores = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Serving.GenericSignature: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Serving.GenericSignature> {
        var mergedArray = Array<Tensorflow.Serving.GenericSignature>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Serving.GenericSignature? {
        return try Tensorflow.Serving.GenericSignature.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Serving.GenericSignature {
        return try Tensorflow.Serving.GenericSignature.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.Serving.ManifestRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.GenericSignature {
        return try Tensorflow.Serving.GenericSignature.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Serving.GenericSignature {
        return try Tensorflow.Serving.GenericSignature.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.GenericSignature {
        return try Tensorflow.Serving.GenericSignature.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Serving.GenericSignature {
        return try Tensorflow.Serving.GenericSignature.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.GenericSignature {
        return try Tensorflow.Serving.GenericSignature.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "map": return self.map
        default: return nil
        }
    }
}
extension Tensorflow.Serving.GenericSignature.MapEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Serving.GenericSignature.MapEntry> {
        var mergedArray = Array<Tensorflow.Serving.GenericSignature.MapEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Serving.GenericSignature.MapEntry? {
        return try Tensorflow.Serving.GenericSignature.MapEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Serving.GenericSignature.MapEntry {
        return try Tensorflow.Serving.GenericSignature.MapEntry.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.Serving.ManifestRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.GenericSignature.MapEntry {
        return try Tensorflow.Serving.GenericSignature.MapEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Serving.GenericSignature.MapEntry {
        return try Tensorflow.Serving.GenericSignature.MapEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.GenericSignature.MapEntry {
        return try Tensorflow.Serving.GenericSignature.MapEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Serving.GenericSignature.MapEntry {
        return try Tensorflow.Serving.GenericSignature.MapEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Serving.GenericSignature.MapEntry {
        return try Tensorflow.Serving.GenericSignature.MapEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.Serving.GenericSignature.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "map": return self.map
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "map":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,Tensorflow.Serving.TensorBinding> else {
                    return
                }
                self.map = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Serving.GenericSignature.MapEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Serving.TensorBinding else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

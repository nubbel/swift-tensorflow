/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "test.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { public struct Test { }}

public extension Tensorflow.Test {
    public struct TestRoot {
        public static let `default` = TestRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }



    //Enum type declaration start 

    public enum ForeignEnum:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
        case foreignZero = 0
        case foreignFoo = 4
        case foreignBar = 5
        case foreignBaz = 6
        public func toString() -> String {
            switch self {
            case .foreignZero: return "FOREIGN_ZERO"
            case .foreignFoo: return "FOREIGN_FOO"
            case .foreignBar: return "FOREIGN_BAR"
            case .foreignBaz: return "FOREIGN_BAZ"
            }
        }
        public static func fromString(str:String) throws -> Tensorflow.Test.ForeignEnum {
            switch str {
            case "FOREIGN_ZERO":    return .foreignZero
            case "FOREIGN_FOO":    return .foreignFoo
            case "FOREIGN_BAR":    return .foreignBar
            case "FOREIGN_BAZ":    return .foreignBaz
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .foreignZero: return ".foreignZero"
            case .foreignFoo: return ".foreignFoo"
            case .foreignBar: return ".foreignBar"
            case .foreignBaz: return ".foreignBaz"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:ForeignEnum, rhs:ForeignEnum) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 

    final public class TestAllTypes : GeneratedMessage {

        public static func == (lhs: Tensorflow.Test.TestAllTypes, rhs: Tensorflow.Test.TestAllTypes) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasOptionalInt64 == rhs.hasOptionalInt64) && (!lhs.hasOptionalInt64 || lhs.optionalInt64 == rhs.optionalInt64)
            fieldCheck = fieldCheck && (lhs.hasOptionalUint32 == rhs.hasOptionalUint32) && (!lhs.hasOptionalUint32 || lhs.optionalUint32 == rhs.optionalUint32)
            fieldCheck = fieldCheck && (lhs.hasOptionalSint32 == rhs.hasOptionalSint32) && (!lhs.hasOptionalSint32 || lhs.optionalSint32 == rhs.optionalSint32)
            fieldCheck = fieldCheck && (lhs.hasOptionalSint64 == rhs.hasOptionalSint64) && (!lhs.hasOptionalSint64 || lhs.optionalSint64 == rhs.optionalSint64)
            fieldCheck = fieldCheck && (lhs.hasOptionalFixed32 == rhs.hasOptionalFixed32) && (!lhs.hasOptionalFixed32 || lhs.optionalFixed32 == rhs.optionalFixed32)
            fieldCheck = fieldCheck && (lhs.hasOptionalFixed64 == rhs.hasOptionalFixed64) && (!lhs.hasOptionalFixed64 || lhs.optionalFixed64 == rhs.optionalFixed64)
            fieldCheck = fieldCheck && (lhs.hasOptionalSfixed32 == rhs.hasOptionalSfixed32) && (!lhs.hasOptionalSfixed32 || lhs.optionalSfixed32 == rhs.optionalSfixed32)
            fieldCheck = fieldCheck && (lhs.hasOptionalSfixed64 == rhs.hasOptionalSfixed64) && (!lhs.hasOptionalSfixed64 || lhs.optionalSfixed64 == rhs.optionalSfixed64)
            fieldCheck = fieldCheck && (lhs.hasOptionalFloat == rhs.hasOptionalFloat) && (!lhs.hasOptionalFloat || lhs.optionalFloat == rhs.optionalFloat)
            fieldCheck = fieldCheck && (lhs.hasOptionalDouble == rhs.hasOptionalDouble) && (!lhs.hasOptionalDouble || lhs.optionalDouble == rhs.optionalDouble)
            fieldCheck = fieldCheck && (lhs.hasOptionalBool == rhs.hasOptionalBool) && (!lhs.hasOptionalBool || lhs.optionalBool == rhs.optionalBool)
            fieldCheck = fieldCheck && (lhs.hasOptionalString == rhs.hasOptionalString) && (!lhs.hasOptionalString || lhs.optionalString == rhs.optionalString)
            fieldCheck = fieldCheck && (lhs.hasOptionalBytes == rhs.hasOptionalBytes) && (!lhs.hasOptionalBytes || lhs.optionalBytes == rhs.optionalBytes)
            fieldCheck = fieldCheck && (lhs.hasOptionalNestedMessage == rhs.hasOptionalNestedMessage) && (!lhs.hasOptionalNestedMessage || lhs.optionalNestedMessage == rhs.optionalNestedMessage)
            fieldCheck = fieldCheck && (lhs.hasOptionalForeignMessage == rhs.hasOptionalForeignMessage) && (!lhs.hasOptionalForeignMessage || lhs.optionalForeignMessage == rhs.optionalForeignMessage)
            fieldCheck = fieldCheck && (lhs.hasOptionalNestedEnum == rhs.hasOptionalNestedEnum) && (!lhs.hasOptionalNestedEnum || lhs.optionalNestedEnum == rhs.optionalNestedEnum)
            fieldCheck = fieldCheck && (lhs.hasOptionalForeignEnum == rhs.hasOptionalForeignEnum) && (!lhs.hasOptionalForeignEnum || lhs.optionalForeignEnum == rhs.optionalForeignEnum)
            fieldCheck = fieldCheck && (lhs.hasOptionalCord == rhs.hasOptionalCord) && (!lhs.hasOptionalCord || lhs.optionalCord == rhs.optionalCord)
            fieldCheck = fieldCheck && (lhs.repeatedInt32 == rhs.repeatedInt32)
            fieldCheck = fieldCheck && (lhs.repeatedInt64 == rhs.repeatedInt64)
            fieldCheck = fieldCheck && (lhs.repeatedUint32 == rhs.repeatedUint32)
            fieldCheck = fieldCheck && (lhs.repeatedUint64 == rhs.repeatedUint64)
            fieldCheck = fieldCheck && (lhs.repeatedSint32 == rhs.repeatedSint32)
            fieldCheck = fieldCheck && (lhs.repeatedSint64 == rhs.repeatedSint64)
            fieldCheck = fieldCheck && (lhs.repeatedFixed32 == rhs.repeatedFixed32)
            fieldCheck = fieldCheck && (lhs.repeatedFixed64 == rhs.repeatedFixed64)
            fieldCheck = fieldCheck && (lhs.repeatedSfixed32 == rhs.repeatedSfixed32)
            fieldCheck = fieldCheck && (lhs.repeatedSfixed64 == rhs.repeatedSfixed64)
            fieldCheck = fieldCheck && (lhs.repeatedFloat == rhs.repeatedFloat)
            fieldCheck = fieldCheck && (lhs.repeatedDouble == rhs.repeatedDouble)
            fieldCheck = fieldCheck && (lhs.repeatedBool == rhs.repeatedBool)
            fieldCheck = fieldCheck && (lhs.repeatedString == rhs.repeatedString)
            fieldCheck = fieldCheck && (lhs.repeatedBytes == rhs.repeatedBytes)
            fieldCheck = fieldCheck && (lhs.repeatedNestedMessage == rhs.repeatedNestedMessage)
            fieldCheck = fieldCheck && (lhs.repeatedNestedEnum == rhs.repeatedNestedEnum)
            fieldCheck = fieldCheck && (lhs.repeatedCord == rhs.repeatedCord)
            fieldCheck = fieldCheck && (lhs.hasMapStringToMessage == rhs.hasMapStringToMessage) && (!lhs.hasMapStringToMessage || lhs.mapStringToMessage == rhs.mapStringToMessage)
            fieldCheck = fieldCheck && (lhs.hasMapInt32ToMessage == rhs.hasMapInt32ToMessage) && (!lhs.hasMapInt32ToMessage || lhs.mapInt32ToMessage == rhs.mapInt32ToMessage)
            fieldCheck = fieldCheck && (lhs.hasMapInt64ToMessage == rhs.hasMapInt64ToMessage) && (!lhs.hasMapInt64ToMessage || lhs.mapInt64ToMessage == rhs.mapInt64ToMessage)
            fieldCheck = fieldCheck && (lhs.hasMapBoolToMessage == rhs.hasMapBoolToMessage) && (!lhs.hasMapBoolToMessage || lhs.mapBoolToMessage == rhs.mapBoolToMessage)
            fieldCheck = fieldCheck && (lhs.hasMapStringToInt64 == rhs.hasMapStringToInt64) && (!lhs.hasMapStringToInt64 || lhs.mapStringToInt64 == rhs.mapStringToInt64)
            fieldCheck = fieldCheck && (lhs.hasMapInt64ToString == rhs.hasMapInt64ToString) && (!lhs.hasMapInt64ToString || lhs.mapInt64ToString == rhs.mapInt64ToString)
            fieldCheck = fieldCheck && (lhs.packedRepeatedInt64 == rhs.packedRepeatedInt64)
            fieldCheck = fieldCheck && (lhs.hasAnotherMapStringToMessage == rhs.hasAnotherMapStringToMessage) && (!lhs.hasAnotherMapStringToMessage || lhs.anotherMapStringToMessage == rhs.anotherMapStringToMessage)
            fieldCheck = fieldCheck && (lhs.hasOneofEnum == rhs.hasOneofEnum) && (!lhs.hasOneofEnum || lhs.oneofEnum == rhs.oneofEnum)
            fieldCheck = fieldCheck && (lhs.hasOneofUint32 == rhs.hasOneofUint32) && (!lhs.hasOneofUint32 || lhs.oneofUint32 == rhs.oneofUint32)
            fieldCheck = fieldCheck && (lhs.hasOneofNestedMessage == rhs.hasOneofNestedMessage) && (!lhs.hasOneofNestedMessage || lhs.oneofNestedMessage == rhs.oneofNestedMessage)
            fieldCheck = fieldCheck && (lhs.hasOneofString == rhs.hasOneofString) && (!lhs.hasOneofString || lhs.oneofString == rhs.oneofString)
            fieldCheck = fieldCheck && (lhs.hasOneofBytes == rhs.hasOneofBytes) && (!lhs.hasOneofBytes || lhs.oneofBytes == rhs.oneofBytes)
            fieldCheck = fieldCheck && (lhs.hasOptionalUint64 == rhs.hasOptionalUint64) && (!lhs.hasOptionalUint64 || lhs.optionalUint64 == rhs.optionalUint64)
            fieldCheck = fieldCheck && (lhs.hasOptionalInt32 == rhs.hasOptionalInt32) && (!lhs.hasOptionalInt32 || lhs.optionalInt32 == rhs.optionalInt32)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        final public class NestedMessage : GeneratedMessage {

            public static func == (lhs: Tensorflow.Test.TestAllTypes.NestedMessage, rhs: Tensorflow.Test.TestAllTypes.NestedMessage) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasOptionalInt32 == rhs.hasOptionalInt32) && (!lhs.hasOptionalInt32 || lhs.optionalInt32 == rhs.optionalInt32)
                fieldCheck = fieldCheck && (lhs.repeatedInt32 == rhs.repeatedInt32)
                fieldCheck = fieldCheck && (lhs.hasMsg == rhs.hasMsg) && (!lhs.hasMsg || lhs.msg == rhs.msg)
                fieldCheck = fieldCheck && (lhs.hasOptionalInt64 == rhs.hasOptionalInt64) && (!lhs.hasOptionalInt64 || lhs.optionalInt64 == rhs.optionalInt64)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }



            //Nested type declaration start

            final public class DoubleNestedMessage : GeneratedMessage {

                public static func == (lhs: Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage, rhs: Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage) -> Bool {
                    if lhs === rhs {
                        return true
                    }
                    var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                    fieldCheck = fieldCheck && (lhs.hasOptionalString == rhs.hasOptionalString) && (!lhs.hasOptionalString || lhs.optionalString == rhs.optionalString)
                    fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                    return fieldCheck
                }

                public fileprivate(set) var optionalString:String = ""
                public fileprivate(set) var hasOptionalString:Bool = false

                required public init() {
                    super.init()
                }
                override public func isInitialized() -> Bool {
                    return true
                }
                override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                    if hasOptionalString {
                        try codedOutputStream.writeString(fieldNumber: 1, value:optionalString)
                    }
                    try unknownFields.writeTo(codedOutputStream: codedOutputStream)
                }
                override public func serializedSize() -> Int32 {
                    var serialize_size:Int32 = memoizedSerializedSize
                    if serialize_size != -1 {
                     return serialize_size
                    }

                    serialize_size = 0
                    if hasOptionalString {
                        serialize_size += optionalString.computeStringSize(fieldNumber: 1)
                    }
                    serialize_size += unknownFields.serializedSize()
                    memoizedSerializedSize = serialize_size
                    return serialize_size
                }
                public class func getBuilder() -> Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder {
                    return Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.classBuilder() as! Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder
                }
                public func getBuilder() -> Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder {
                    return classBuilder() as! Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder
                }
                override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                    return Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder()
                }
                override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                    return Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder()
                }
                public func toBuilder() throws -> Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder {
                    return try Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.builderWithPrototype(prototype:self)
                }
                public class func builderWithPrototype(prototype:Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage) throws -> Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder {
                    return try Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder().mergeFrom(other:prototype)
                }
                override public func encode() throws -> Dictionary<String,Any> {
                    guard isInitialized() else {
                        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                    }

                    var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                    if hasOptionalString {
                        jsonMap["optionalString"] = optionalString
                    }
                    return jsonMap
                }
                override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage {
                    return try Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder.decodeToBuilder(jsonMap:jsonMap).build()
                }
                override class public func fromJSON(data:Data) throws -> Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage {
                    return try Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder.fromJSONToBuilder(data:data).build()
                }
                override public func getDescription(indent:String) throws -> String {
                    var output = ""
                    if hasOptionalString {
                        output += "\(indent) optionalString: \(optionalString) \n"
                    }
                    output += unknownFields.getDescription(indent: indent)
                    return output
                }
                override public var hashValue:Int {
                    get {
                        var hashCode:Int = 7
                        if hasOptionalString {
                            hashCode = (hashCode &* 31) &+ optionalString.hashValue
                        }
                        hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                        return hashCode
                    }
                }


                //Meta information declaration start

                override public class func className() -> String {
                    return "Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage"
                }
                override public func className() -> String {
                    return "Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage"
                }
                //Meta information declaration end

                final public class Builder : GeneratedMessageBuilder {
                    fileprivate var builderResult:Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage = Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage()
                    public func getMessage() -> Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage {
                        return builderResult
                    }

                    required override public init () {
                        super.init()
                    }
                    public var optionalString:String {
                        get {
                            return builderResult.optionalString
                        }
                        set (value) {
                            builderResult.hasOptionalString = true
                            builderResult.optionalString = value
                        }
                    }
                    public var hasOptionalString:Bool {
                        get {
                            return builderResult.hasOptionalString
                        }
                    }
                    @discardableResult
                    public func setOptionalString(_ value:String) -> Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder {
                        self.optionalString = value
                        return self
                    }
                    @discardableResult
                    public func clearOptionalString() -> Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder{
                        builderResult.hasOptionalString = false
                        builderResult.optionalString = ""
                        return self
                    }
                    override public var internalGetResult:GeneratedMessage {
                        get {
                            return builderResult
                        }
                    }
                    @discardableResult
                    override public func clear() -> Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder {
                        builderResult = Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage()
                        return self
                    }
                    override public func clone() throws -> Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder {
                        return try Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.builderWithPrototype(prototype:builderResult)
                    }
                    override public func build() throws -> Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage {
                        try checkInitialized()
                        return buildPartial()
                    }
                    public func buildPartial() -> Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage {
                        let returnMe:Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage = builderResult
                        return returnMe
                    }
                    @discardableResult
                    public func mergeFrom(other:Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage) throws -> Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder {
                        if other == Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage() {
                            return self
                        }
                        if other.hasOptionalString {
                            optionalString = other.optionalString
                        }
                        try merge(unknownField: other.unknownFields)
                        return self
                    }
                    @discardableResult
                    override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder {
                        return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                    }
                    @discardableResult
                    override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder {
                        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                        while (true) {
                            let protobufTag = try codedInputStream.readTag()
                            switch protobufTag {
                            case 0: 
                                self.unknownFields = try unknownFieldsBuilder.build()
                                return self

                            case 10:
                                optionalString = try codedInputStream.readString()

                            default:
                                if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                    unknownFields = try unknownFieldsBuilder.build()
                                    return self
                                }
                            }
                        }
                    }
                    class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder {
                        let resultDecodedBuilder = Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder()
                        if let jsonValueOptionalString = jsonMap["optionalString"] as? String {
                            resultDecodedBuilder.optionalString = jsonValueOptionalString
                        }
                        return resultDecodedBuilder
                    }
                    override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder {
                        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        return try Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder.decodeToBuilder(jsonMap:jsDataCast)
                    }
                }

            }

            //Nested type declaration end

            public fileprivate(set) var optionalInt32:Int32 = Int32(0)
            public fileprivate(set) var hasOptionalInt32:Bool = false

            public fileprivate(set) var repeatedInt32:Array<Int32> = Array<Int32>()
            private var repeatedInt32MemoizedSerializedSize:Int32 = -1
            public fileprivate(set) var msg:Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage!
            public fileprivate(set) var hasMsg:Bool = false
            public fileprivate(set) var optionalInt64:Int64 = Int64(0)
            public fileprivate(set) var hasOptionalInt64:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasOptionalInt32 {
                    try codedOutputStream.writeInt32(fieldNumber: 1, value:optionalInt32)
                }
                if !repeatedInt32.isEmpty {
                    try codedOutputStream.writeRawVarint32(value: 18)
                    try codedOutputStream.writeRawVarint32(value: repeatedInt32MemoizedSerializedSize)
                    for oneValuerepeatedInt32 in repeatedInt32 {
                        try codedOutputStream.writeInt32NoTag(value: oneValuerepeatedInt32)
                    }
                }
                if hasMsg {
                    try codedOutputStream.writeMessage(fieldNumber: 3, value:msg)
                }
                if hasOptionalInt64 {
                    try codedOutputStream.writeInt64(fieldNumber: 4, value:optionalInt64)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasOptionalInt32 {
                    serialize_size += optionalInt32.computeInt32Size(fieldNumber: 1)
                }
                var dataSizeRepeatedInt32:Int32 = 0
                for oneValuerepeatedInt32 in repeatedInt32 {
                    dataSizeRepeatedInt32 += oneValuerepeatedInt32.computeInt32SizeNoTag()
                }
                serialize_size += dataSizeRepeatedInt32
                if !repeatedInt32.isEmpty {
                    serialize_size += 1
                    serialize_size += dataSizeRepeatedInt32.computeInt32SizeNoTag()
                }
                repeatedInt32MemoizedSerializedSize = dataSizeRepeatedInt32
                if hasMsg {
                    if let varSizemsg = msg?.computeMessageSize(fieldNumber: 3) {
                        serialize_size += varSizemsg
                    }
                }
                if hasOptionalInt64 {
                    serialize_size += optionalInt64.computeInt64Size(fieldNumber: 4)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.Test.TestAllTypes.NestedMessage.Builder {
                return Tensorflow.Test.TestAllTypes.NestedMessage.classBuilder() as! Tensorflow.Test.TestAllTypes.NestedMessage.Builder
            }
            public func getBuilder() -> Tensorflow.Test.TestAllTypes.NestedMessage.Builder {
                return classBuilder() as! Tensorflow.Test.TestAllTypes.NestedMessage.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.Test.TestAllTypes.NestedMessage.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.Test.TestAllTypes.NestedMessage.Builder()
            }
            public func toBuilder() throws -> Tensorflow.Test.TestAllTypes.NestedMessage.Builder {
                return try Tensorflow.Test.TestAllTypes.NestedMessage.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.Test.TestAllTypes.NestedMessage) throws -> Tensorflow.Test.TestAllTypes.NestedMessage.Builder {
                return try Tensorflow.Test.TestAllTypes.NestedMessage.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasOptionalInt32 {
                    jsonMap["optionalInt32"] = Int(optionalInt32)
                }
                if !repeatedInt32.isEmpty {
                    var jsonArrayRepeatedInt32:Array<Int> = []
                    for oneValueRepeatedInt32 in repeatedInt32 {
                        jsonArrayRepeatedInt32.append(Int(oneValueRepeatedInt32))
                    }
                    jsonMap["repeatedInt32"] = jsonArrayRepeatedInt32
                }
                if hasMsg {
                    jsonMap["msg"] = try msg.encode()
                }
                if hasOptionalInt64 {
                    jsonMap["optionalInt64"] = "\(optionalInt64)"
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Test.TestAllTypes.NestedMessage {
                return try Tensorflow.Test.TestAllTypes.NestedMessage.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.Test.TestAllTypes.NestedMessage {
                return try Tensorflow.Test.TestAllTypes.NestedMessage.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasOptionalInt32 {
                    output += "\(indent) optionalInt32: \(optionalInt32) \n"
                }
                var repeatedInt32ElementIndex:Int = 0
                for oneValueRepeatedInt32 in repeatedInt32  {
                    output += "\(indent) repeatedInt32[\(repeatedInt32ElementIndex)]: \(oneValueRepeatedInt32)\n"
                    repeatedInt32ElementIndex += 1
                }
                if hasMsg {
                    output += "\(indent) msg {\n"
                    if let outDescMsg = msg {
                        output += try outDescMsg.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                if hasOptionalInt64 {
                    output += "\(indent) optionalInt64: \(optionalInt64) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasOptionalInt32 {
                        hashCode = (hashCode &* 31) &+ optionalInt32.hashValue
                    }
                    for oneValueRepeatedInt32 in repeatedInt32 {
                        hashCode = (hashCode &* 31) &+ oneValueRepeatedInt32.hashValue
                    }
                    if hasMsg {
                        if let hashValuemsg = msg?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuemsg
                        }
                    }
                    if hasOptionalInt64 {
                        hashCode = (hashCode &* 31) &+ optionalInt64.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.Test.TestAllTypes.NestedMessage"
            }
            override public func className() -> String {
                return "Tensorflow.Test.TestAllTypes.NestedMessage"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.Test.TestAllTypes.NestedMessage = Tensorflow.Test.TestAllTypes.NestedMessage()
                public func getMessage() -> Tensorflow.Test.TestAllTypes.NestedMessage {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var optionalInt32:Int32 {
                    get {
                        return builderResult.optionalInt32
                    }
                    set (value) {
                        builderResult.hasOptionalInt32 = true
                        builderResult.optionalInt32 = value
                    }
                }
                public var hasOptionalInt32:Bool {
                    get {
                        return builderResult.hasOptionalInt32
                    }
                }
                @discardableResult
                public func setOptionalInt32(_ value:Int32) -> Tensorflow.Test.TestAllTypes.NestedMessage.Builder {
                    self.optionalInt32 = value
                    return self
                }
                @discardableResult
                public func clearOptionalInt32() -> Tensorflow.Test.TestAllTypes.NestedMessage.Builder{
                    builderResult.hasOptionalInt32 = false
                    builderResult.optionalInt32 = Int32(0)
                    return self
                }
                public var repeatedInt32:Array<Int32> {
                    get {
                        return builderResult.repeatedInt32
                    }
                    set (array) {
                        builderResult.repeatedInt32 = array
                    }
                }
                @discardableResult
                public func setRepeatedInt32(_ value:Array<Int32>) -> Tensorflow.Test.TestAllTypes.NestedMessage.Builder {
                    self.repeatedInt32 = value
                    return self
                }
                @discardableResult
                public func clearRepeatedInt32() -> Tensorflow.Test.TestAllTypes.NestedMessage.Builder {
                    builderResult.repeatedInt32.removeAll(keepingCapacity: false)
                    return self
                }
                public var msg:Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage! {
                    get {
                        if msgBuilder_ != nil {
                            builderResult.msg = msgBuilder_.getMessage()
                        }
                        return builderResult.msg
                    }
                    set (value) {
                        builderResult.hasMsg = true
                        builderResult.msg = value
                    }
                }
                public var hasMsg:Bool {
                    get {
                        return builderResult.hasMsg
                    }
                }
                fileprivate var msgBuilder_:Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder! {
                    didSet {
                        builderResult.hasMsg = true
                    }
                }
                public func getMsgBuilder() -> Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder {
                    if msgBuilder_ == nil {
                        msgBuilder_ = Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder()
                        builderResult.msg = msgBuilder_.getMessage()
                        if msg != nil {
                            try! msgBuilder_.mergeFrom(other: msg)
                        }
                    }
                    return msgBuilder_
                }
                @discardableResult
                public func setMsg(_ value:Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage!) -> Tensorflow.Test.TestAllTypes.NestedMessage.Builder {
                    self.msg = value
                    return self
                }
                @discardableResult
                public func mergeMsg(value:Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage) throws -> Tensorflow.Test.TestAllTypes.NestedMessage.Builder {
                    if builderResult.hasMsg {
                        builderResult.msg = try Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.builderWithPrototype(prototype:builderResult.msg).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.msg = value
                    }
                    builderResult.hasMsg = true
                    return self
                }
                @discardableResult
                public func clearMsg() -> Tensorflow.Test.TestAllTypes.NestedMessage.Builder {
                    msgBuilder_ = nil
                    builderResult.hasMsg = false
                    builderResult.msg = nil
                    return self
                }
                public var optionalInt64:Int64 {
                    get {
                        return builderResult.optionalInt64
                    }
                    set (value) {
                        builderResult.hasOptionalInt64 = true
                        builderResult.optionalInt64 = value
                    }
                }
                public var hasOptionalInt64:Bool {
                    get {
                        return builderResult.hasOptionalInt64
                    }
                }
                @discardableResult
                public func setOptionalInt64(_ value:Int64) -> Tensorflow.Test.TestAllTypes.NestedMessage.Builder {
                    self.optionalInt64 = value
                    return self
                }
                @discardableResult
                public func clearOptionalInt64() -> Tensorflow.Test.TestAllTypes.NestedMessage.Builder{
                    builderResult.hasOptionalInt64 = false
                    builderResult.optionalInt64 = Int64(0)
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.Test.TestAllTypes.NestedMessage.Builder {
                    builderResult = Tensorflow.Test.TestAllTypes.NestedMessage()
                    return self
                }
                override public func clone() throws -> Tensorflow.Test.TestAllTypes.NestedMessage.Builder {
                    return try Tensorflow.Test.TestAllTypes.NestedMessage.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.Test.TestAllTypes.NestedMessage {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.Test.TestAllTypes.NestedMessage {
                    let returnMe:Tensorflow.Test.TestAllTypes.NestedMessage = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.Test.TestAllTypes.NestedMessage) throws -> Tensorflow.Test.TestAllTypes.NestedMessage.Builder {
                    if other == Tensorflow.Test.TestAllTypes.NestedMessage() {
                        return self
                    }
                    if other.hasOptionalInt32 {
                        optionalInt32 = other.optionalInt32
                    }
                    if !other.repeatedInt32.isEmpty {
                        builderResult.repeatedInt32 += other.repeatedInt32
                    }
                    if (other.hasMsg) {
                        try mergeMsg(value: other.msg)
                    }
                    if other.hasOptionalInt64 {
                        optionalInt64 = other.optionalInt64
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Test.TestAllTypes.NestedMessage.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.NestedMessage.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 8:
                            optionalInt32 = try codedInputStream.readInt32()

                        case 18:
                            let length = Int(try codedInputStream.readRawVarint32())
                            let limit = try codedInputStream.pushLimit(byteLimit: length)
                            while (codedInputStream.bytesUntilLimit() > 0) {
                                builderResult.repeatedInt32.append(try codedInputStream.readInt32())
                            }
                            codedInputStream.popLimit(oldLimit: limit)

                        case 26:
                            let subBuilder:Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder = Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder()
                            if hasMsg {
                                try subBuilder.mergeFrom(other: msg)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            msg = subBuilder.buildPartial()

                        case 32:
                            optionalInt64 = try codedInputStream.readInt64()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Test.TestAllTypes.NestedMessage.Builder {
                    let resultDecodedBuilder = Tensorflow.Test.TestAllTypes.NestedMessage.Builder()
                    if let jsonValueOptionalInt32 = jsonMap["optionalInt32"] as? Int {
                        resultDecodedBuilder.optionalInt32 = Int32(jsonValueOptionalInt32)
                    } else if let jsonValueOptionalInt32 = jsonMap["optionalInt32"] as? String {
                        resultDecodedBuilder.optionalInt32 = Int32(jsonValueOptionalInt32)!
                    }
                    if let jsonValueRepeatedInt32 = jsonMap["repeatedInt32"] as? Array<Int> {
                        var jsonArrayRepeatedInt32:Array<Int32> = []
                        for oneValueRepeatedInt32 in jsonValueRepeatedInt32 {
                            jsonArrayRepeatedInt32.append(Int32(oneValueRepeatedInt32))
                        }
                        resultDecodedBuilder.repeatedInt32 = jsonArrayRepeatedInt32
                    }
                    if let jsonValueMsg = jsonMap["msg"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.msg = try Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder.decodeToBuilder(jsonMap:jsonValueMsg).build()

                    }
                    if let jsonValueOptionalInt64 = jsonMap["optionalInt64"] as? String {
                        resultDecodedBuilder.optionalInt64 = Int64(jsonValueOptionalInt64)!
                    } else if let jsonValueOptionalInt64 = jsonMap["optionalInt64"] as? Int {
                        resultDecodedBuilder.optionalInt64 = Int64(jsonValueOptionalInt64)
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Test.TestAllTypes.NestedMessage.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.Test.TestAllTypes.NestedMessage.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        final public class MapStringToMessageEntry : GeneratedMessage {

            public static func == (lhs: Tensorflow.Test.TestAllTypes.MapStringToMessageEntry, rhs: Tensorflow.Test.TestAllTypes.MapStringToMessageEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:String = ""
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:Tensorflow.Test.TestAllTypes.NestedMessage!
            public fileprivate(set) var hasValue:Bool = false
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeString(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeMessage(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeStringSize(fieldNumber: 1)
                }
                if hasValue {
                    if let varSizevalue = value?.computeMessageSize(fieldNumber: 2) {
                        serialize_size += varSizevalue
                    }
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder {
                return Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.classBuilder() as! Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder
            }
            public func getBuilder() -> Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder {
                return classBuilder() as! Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder()
            }
            public func toBuilder() throws -> Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder {
                return try Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.Test.TestAllTypes.MapStringToMessageEntry) throws -> Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder {
                return try Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = key
                }
                if hasValue {
                    jsonMap["value"] = try value.encode()
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Test.TestAllTypes.MapStringToMessageEntry {
                return try Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.Test.TestAllTypes.MapStringToMessageEntry {
                return try Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value {\n"
                    if let outDescValue = value {
                        output += try outDescValue.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        if let hashValuevalue = value?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuevalue
                        }
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.Test.TestAllTypes.MapStringToMessageEntry"
            }
            override public func className() -> String {
                return "Tensorflow.Test.TestAllTypes.MapStringToMessageEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.Test.TestAllTypes.MapStringToMessageEntry = Tensorflow.Test.TestAllTypes.MapStringToMessageEntry()
                public func getMessage() -> Tensorflow.Test.TestAllTypes.MapStringToMessageEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:String {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:String) -> Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = ""
                    return self
                }
                public var value:Tensorflow.Test.TestAllTypes.NestedMessage! {
                    get {
                        if valueBuilder_ != nil {
                            builderResult.value = valueBuilder_.getMessage()
                        }
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                fileprivate var valueBuilder_:Tensorflow.Test.TestAllTypes.NestedMessage.Builder! {
                    didSet {
                        builderResult.hasValue = true
                    }
                }
                public func getValueBuilder() -> Tensorflow.Test.TestAllTypes.NestedMessage.Builder {
                    if valueBuilder_ == nil {
                        valueBuilder_ = Tensorflow.Test.TestAllTypes.NestedMessage.Builder()
                        builderResult.value = valueBuilder_.getMessage()
                        if value != nil {
                            try! valueBuilder_.mergeFrom(other: value)
                        }
                    }
                    return valueBuilder_
                }
                @discardableResult
                public func setValue(_ value:Tensorflow.Test.TestAllTypes.NestedMessage!) -> Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func mergeValue(value:Tensorflow.Test.TestAllTypes.NestedMessage) throws -> Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder {
                    if builderResult.hasValue {
                        builderResult.value = try Tensorflow.Test.TestAllTypes.NestedMessage.builderWithPrototype(prototype:builderResult.value).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.value = value
                    }
                    builderResult.hasValue = true
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder {
                    valueBuilder_ = nil
                    builderResult.hasValue = false
                    builderResult.value = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder {
                    builderResult = Tensorflow.Test.TestAllTypes.MapStringToMessageEntry()
                    return self
                }
                override public func clone() throws -> Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder {
                    return try Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.Test.TestAllTypes.MapStringToMessageEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.Test.TestAllTypes.MapStringToMessageEntry {
                    let returnMe:Tensorflow.Test.TestAllTypes.MapStringToMessageEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.Test.TestAllTypes.MapStringToMessageEntry) throws -> Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder {
                    if other == Tensorflow.Test.TestAllTypes.MapStringToMessageEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if (other.hasValue) {
                        try mergeValue(value: other.value)
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            key = try codedInputStream.readString()

                        case 18:
                            let subBuilder:Tensorflow.Test.TestAllTypes.NestedMessage.Builder = Tensorflow.Test.TestAllTypes.NestedMessage.Builder()
                            if hasValue {
                                try subBuilder.mergeFrom(other: value)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            value = subBuilder.buildPartial()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder {
                    let resultDecodedBuilder = Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = jsonValueKey
                    }
                    if let jsonValueValue = jsonMap["value"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.value = try Tensorflow.Test.TestAllTypes.NestedMessage.Builder.decodeToBuilder(jsonMap:jsonValueValue).build()

                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        final public class MapInt32ToMessageEntry : GeneratedMessage {

            public static func == (lhs: Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry, rhs: Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:Int32 = Int32(0)
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:Tensorflow.Test.TestAllTypes.NestedMessage!
            public fileprivate(set) var hasValue:Bool = false
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeInt32(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeMessage(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeInt32Size(fieldNumber: 1)
                }
                if hasValue {
                    if let varSizevalue = value?.computeMessageSize(fieldNumber: 2) {
                        serialize_size += varSizevalue
                    }
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder {
                return Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.classBuilder() as! Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder
            }
            public func getBuilder() -> Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder {
                return classBuilder() as! Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder()
            }
            public func toBuilder() throws -> Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder {
                return try Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry) throws -> Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder {
                return try Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = Int(key)
                }
                if hasValue {
                    jsonMap["value"] = try value.encode()
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry {
                return try Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry {
                return try Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value {\n"
                    if let outDescValue = value {
                        output += try outDescValue.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        if let hashValuevalue = value?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuevalue
                        }
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry"
            }
            override public func className() -> String {
                return "Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry = Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry()
                public func getMessage() -> Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:Int32 {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:Int32) -> Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = Int32(0)
                    return self
                }
                public var value:Tensorflow.Test.TestAllTypes.NestedMessage! {
                    get {
                        if valueBuilder_ != nil {
                            builderResult.value = valueBuilder_.getMessage()
                        }
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                fileprivate var valueBuilder_:Tensorflow.Test.TestAllTypes.NestedMessage.Builder! {
                    didSet {
                        builderResult.hasValue = true
                    }
                }
                public func getValueBuilder() -> Tensorflow.Test.TestAllTypes.NestedMessage.Builder {
                    if valueBuilder_ == nil {
                        valueBuilder_ = Tensorflow.Test.TestAllTypes.NestedMessage.Builder()
                        builderResult.value = valueBuilder_.getMessage()
                        if value != nil {
                            try! valueBuilder_.mergeFrom(other: value)
                        }
                    }
                    return valueBuilder_
                }
                @discardableResult
                public func setValue(_ value:Tensorflow.Test.TestAllTypes.NestedMessage!) -> Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func mergeValue(value:Tensorflow.Test.TestAllTypes.NestedMessage) throws -> Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder {
                    if builderResult.hasValue {
                        builderResult.value = try Tensorflow.Test.TestAllTypes.NestedMessage.builderWithPrototype(prototype:builderResult.value).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.value = value
                    }
                    builderResult.hasValue = true
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder {
                    valueBuilder_ = nil
                    builderResult.hasValue = false
                    builderResult.value = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder {
                    builderResult = Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry()
                    return self
                }
                override public func clone() throws -> Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder {
                    return try Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry {
                    let returnMe:Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry) throws -> Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder {
                    if other == Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if (other.hasValue) {
                        try mergeValue(value: other.value)
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 8:
                            key = try codedInputStream.readInt32()

                        case 18:
                            let subBuilder:Tensorflow.Test.TestAllTypes.NestedMessage.Builder = Tensorflow.Test.TestAllTypes.NestedMessage.Builder()
                            if hasValue {
                                try subBuilder.mergeFrom(other: value)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            value = subBuilder.buildPartial()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder {
                    let resultDecodedBuilder = Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? Int {
                        resultDecodedBuilder.key = Int32(jsonValueKey)
                    } else if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = Int32(jsonValueKey)!
                    }
                    if let jsonValueValue = jsonMap["value"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.value = try Tensorflow.Test.TestAllTypes.NestedMessage.Builder.decodeToBuilder(jsonMap:jsonValueValue).build()

                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        final public class MapInt64ToMessageEntry : GeneratedMessage {

            public static func == (lhs: Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry, rhs: Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:Int64 = Int64(0)
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:Tensorflow.Test.TestAllTypes.NestedMessage!
            public fileprivate(set) var hasValue:Bool = false
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeInt64(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeMessage(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeInt64Size(fieldNumber: 1)
                }
                if hasValue {
                    if let varSizevalue = value?.computeMessageSize(fieldNumber: 2) {
                        serialize_size += varSizevalue
                    }
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder {
                return Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.classBuilder() as! Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder
            }
            public func getBuilder() -> Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder {
                return classBuilder() as! Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder()
            }
            public func toBuilder() throws -> Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder {
                return try Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry) throws -> Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder {
                return try Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = "\(key)"
                }
                if hasValue {
                    jsonMap["value"] = try value.encode()
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry {
                return try Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry {
                return try Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value {\n"
                    if let outDescValue = value {
                        output += try outDescValue.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        if let hashValuevalue = value?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuevalue
                        }
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry"
            }
            override public func className() -> String {
                return "Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry = Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry()
                public func getMessage() -> Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:Int64 {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:Int64) -> Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = Int64(0)
                    return self
                }
                public var value:Tensorflow.Test.TestAllTypes.NestedMessage! {
                    get {
                        if valueBuilder_ != nil {
                            builderResult.value = valueBuilder_.getMessage()
                        }
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                fileprivate var valueBuilder_:Tensorflow.Test.TestAllTypes.NestedMessage.Builder! {
                    didSet {
                        builderResult.hasValue = true
                    }
                }
                public func getValueBuilder() -> Tensorflow.Test.TestAllTypes.NestedMessage.Builder {
                    if valueBuilder_ == nil {
                        valueBuilder_ = Tensorflow.Test.TestAllTypes.NestedMessage.Builder()
                        builderResult.value = valueBuilder_.getMessage()
                        if value != nil {
                            try! valueBuilder_.mergeFrom(other: value)
                        }
                    }
                    return valueBuilder_
                }
                @discardableResult
                public func setValue(_ value:Tensorflow.Test.TestAllTypes.NestedMessage!) -> Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func mergeValue(value:Tensorflow.Test.TestAllTypes.NestedMessage) throws -> Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder {
                    if builderResult.hasValue {
                        builderResult.value = try Tensorflow.Test.TestAllTypes.NestedMessage.builderWithPrototype(prototype:builderResult.value).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.value = value
                    }
                    builderResult.hasValue = true
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder {
                    valueBuilder_ = nil
                    builderResult.hasValue = false
                    builderResult.value = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder {
                    builderResult = Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry()
                    return self
                }
                override public func clone() throws -> Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder {
                    return try Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry {
                    let returnMe:Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry) throws -> Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder {
                    if other == Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if (other.hasValue) {
                        try mergeValue(value: other.value)
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 8:
                            key = try codedInputStream.readInt64()

                        case 18:
                            let subBuilder:Tensorflow.Test.TestAllTypes.NestedMessage.Builder = Tensorflow.Test.TestAllTypes.NestedMessage.Builder()
                            if hasValue {
                                try subBuilder.mergeFrom(other: value)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            value = subBuilder.buildPartial()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder {
                    let resultDecodedBuilder = Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = Int64(jsonValueKey)!
                    } else if let jsonValueKey = jsonMap["key"] as? Int {
                        resultDecodedBuilder.key = Int64(jsonValueKey)
                    }
                    if let jsonValueValue = jsonMap["value"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.value = try Tensorflow.Test.TestAllTypes.NestedMessage.Builder.decodeToBuilder(jsonMap:jsonValueValue).build()

                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        final public class MapBoolToMessageEntry : GeneratedMessage {

            public static func == (lhs: Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry, rhs: Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:Bool = false
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:Tensorflow.Test.TestAllTypes.NestedMessage!
            public fileprivate(set) var hasValue:Bool = false
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeBool(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeMessage(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeBoolSize(fieldNumber: 1)
                }
                if hasValue {
                    if let varSizevalue = value?.computeMessageSize(fieldNumber: 2) {
                        serialize_size += varSizevalue
                    }
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder {
                return Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.classBuilder() as! Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder
            }
            public func getBuilder() -> Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder {
                return classBuilder() as! Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder()
            }
            public func toBuilder() throws -> Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder {
                return try Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry) throws -> Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder {
                return try Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = key
                }
                if hasValue {
                    jsonMap["value"] = try value.encode()
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry {
                return try Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry {
                return try Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value {\n"
                    if let outDescValue = value {
                        output += try outDescValue.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        if let hashValuevalue = value?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuevalue
                        }
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry"
            }
            override public func className() -> String {
                return "Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry = Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry()
                public func getMessage() -> Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:Bool {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:Bool) -> Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = false
                    return self
                }
                public var value:Tensorflow.Test.TestAllTypes.NestedMessage! {
                    get {
                        if valueBuilder_ != nil {
                            builderResult.value = valueBuilder_.getMessage()
                        }
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                fileprivate var valueBuilder_:Tensorflow.Test.TestAllTypes.NestedMessage.Builder! {
                    didSet {
                        builderResult.hasValue = true
                    }
                }
                public func getValueBuilder() -> Tensorflow.Test.TestAllTypes.NestedMessage.Builder {
                    if valueBuilder_ == nil {
                        valueBuilder_ = Tensorflow.Test.TestAllTypes.NestedMessage.Builder()
                        builderResult.value = valueBuilder_.getMessage()
                        if value != nil {
                            try! valueBuilder_.mergeFrom(other: value)
                        }
                    }
                    return valueBuilder_
                }
                @discardableResult
                public func setValue(_ value:Tensorflow.Test.TestAllTypes.NestedMessage!) -> Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func mergeValue(value:Tensorflow.Test.TestAllTypes.NestedMessage) throws -> Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder {
                    if builderResult.hasValue {
                        builderResult.value = try Tensorflow.Test.TestAllTypes.NestedMessage.builderWithPrototype(prototype:builderResult.value).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.value = value
                    }
                    builderResult.hasValue = true
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder {
                    valueBuilder_ = nil
                    builderResult.hasValue = false
                    builderResult.value = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder {
                    builderResult = Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry()
                    return self
                }
                override public func clone() throws -> Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder {
                    return try Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry {
                    let returnMe:Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry) throws -> Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder {
                    if other == Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if (other.hasValue) {
                        try mergeValue(value: other.value)
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 8:
                            key = try codedInputStream.readBool()

                        case 18:
                            let subBuilder:Tensorflow.Test.TestAllTypes.NestedMessage.Builder = Tensorflow.Test.TestAllTypes.NestedMessage.Builder()
                            if hasValue {
                                try subBuilder.mergeFrom(other: value)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            value = subBuilder.buildPartial()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder {
                    let resultDecodedBuilder = Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? Bool {
                        resultDecodedBuilder.key = jsonValueKey
                    }
                    if let jsonValueValue = jsonMap["value"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.value = try Tensorflow.Test.TestAllTypes.NestedMessage.Builder.decodeToBuilder(jsonMap:jsonValueValue).build()

                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        final public class MapStringToInt64Entry : GeneratedMessage {

            public static func == (lhs: Tensorflow.Test.TestAllTypes.MapStringToInt64Entry, rhs: Tensorflow.Test.TestAllTypes.MapStringToInt64Entry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:String = ""
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:Int64 = Int64(0)
            public fileprivate(set) var hasValue:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeString(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeInt64(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeStringSize(fieldNumber: 1)
                }
                if hasValue {
                    serialize_size += value.computeInt64Size(fieldNumber: 2)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder {
                return Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.classBuilder() as! Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder
            }
            public func getBuilder() -> Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder {
                return classBuilder() as! Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder()
            }
            public func toBuilder() throws -> Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder {
                return try Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.Test.TestAllTypes.MapStringToInt64Entry) throws -> Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder {
                return try Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = key
                }
                if hasValue {
                    jsonMap["value"] = "\(value)"
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Test.TestAllTypes.MapStringToInt64Entry {
                return try Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.Test.TestAllTypes.MapStringToInt64Entry {
                return try Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value: \(value) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        hashCode = (hashCode &* 31) &+ value.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.Test.TestAllTypes.MapStringToInt64Entry"
            }
            override public func className() -> String {
                return "Tensorflow.Test.TestAllTypes.MapStringToInt64Entry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.Test.TestAllTypes.MapStringToInt64Entry = Tensorflow.Test.TestAllTypes.MapStringToInt64Entry()
                public func getMessage() -> Tensorflow.Test.TestAllTypes.MapStringToInt64Entry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:String {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:String) -> Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = ""
                    return self
                }
                public var value:Int64 {
                    get {
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                @discardableResult
                public func setValue(_ value:Int64) -> Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder{
                    builderResult.hasValue = false
                    builderResult.value = Int64(0)
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder {
                    builderResult = Tensorflow.Test.TestAllTypes.MapStringToInt64Entry()
                    return self
                }
                override public func clone() throws -> Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder {
                    return try Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.Test.TestAllTypes.MapStringToInt64Entry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.Test.TestAllTypes.MapStringToInt64Entry {
                    let returnMe:Tensorflow.Test.TestAllTypes.MapStringToInt64Entry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.Test.TestAllTypes.MapStringToInt64Entry) throws -> Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder {
                    if other == Tensorflow.Test.TestAllTypes.MapStringToInt64Entry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if other.hasValue {
                        value = other.value
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            key = try codedInputStream.readString()

                        case 16:
                            value = try codedInputStream.readInt64()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder {
                    let resultDecodedBuilder = Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = jsonValueKey
                    }
                    if let jsonValueValue = jsonMap["value"] as? String {
                        resultDecodedBuilder.value = Int64(jsonValueValue)!
                    } else if let jsonValueValue = jsonMap["value"] as? Int {
                        resultDecodedBuilder.value = Int64(jsonValueValue)
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        final public class MapInt64ToStringEntry : GeneratedMessage {

            public static func == (lhs: Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry, rhs: Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:Int64 = Int64(0)
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:String = ""
            public fileprivate(set) var hasValue:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeInt64(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeString(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeInt64Size(fieldNumber: 1)
                }
                if hasValue {
                    serialize_size += value.computeStringSize(fieldNumber: 2)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder {
                return Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.classBuilder() as! Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder
            }
            public func getBuilder() -> Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder {
                return classBuilder() as! Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder()
            }
            public func toBuilder() throws -> Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder {
                return try Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry) throws -> Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder {
                return try Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = "\(key)"
                }
                if hasValue {
                    jsonMap["value"] = value
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry {
                return try Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry {
                return try Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value: \(value) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        hashCode = (hashCode &* 31) &+ value.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry"
            }
            override public func className() -> String {
                return "Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry = Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry()
                public func getMessage() -> Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:Int64 {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:Int64) -> Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = Int64(0)
                    return self
                }
                public var value:String {
                    get {
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                @discardableResult
                public func setValue(_ value:String) -> Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder{
                    builderResult.hasValue = false
                    builderResult.value = ""
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder {
                    builderResult = Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry()
                    return self
                }
                override public func clone() throws -> Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder {
                    return try Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry {
                    let returnMe:Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry) throws -> Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder {
                    if other == Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if other.hasValue {
                        value = other.value
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 8:
                            key = try codedInputStream.readInt64()

                        case 18:
                            value = try codedInputStream.readString()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder {
                    let resultDecodedBuilder = Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = Int64(jsonValueKey)!
                    } else if let jsonValueKey = jsonMap["key"] as? Int {
                        resultDecodedBuilder.key = Int64(jsonValueKey)
                    }
                    if let jsonValueValue = jsonMap["value"] as? String {
                        resultDecodedBuilder.value = jsonValueValue
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        final public class AnotherMapStringToMessageEntry : GeneratedMessage {

            public static func == (lhs: Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry, rhs: Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:String = ""
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:Tensorflow.Test.TestAllTypes.NestedMessage!
            public fileprivate(set) var hasValue:Bool = false
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeString(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeMessage(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeStringSize(fieldNumber: 1)
                }
                if hasValue {
                    if let varSizevalue = value?.computeMessageSize(fieldNumber: 2) {
                        serialize_size += varSizevalue
                    }
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder {
                return Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.classBuilder() as! Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder
            }
            public func getBuilder() -> Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder {
                return classBuilder() as! Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder()
            }
            public func toBuilder() throws -> Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder {
                return try Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry) throws -> Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder {
                return try Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = key
                }
                if hasValue {
                    jsonMap["value"] = try value.encode()
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry {
                return try Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry {
                return try Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value {\n"
                    if let outDescValue = value {
                        output += try outDescValue.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        if let hashValuevalue = value?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuevalue
                        }
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry"
            }
            override public func className() -> String {
                return "Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry = Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry()
                public func getMessage() -> Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:String {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:String) -> Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = ""
                    return self
                }
                public var value:Tensorflow.Test.TestAllTypes.NestedMessage! {
                    get {
                        if valueBuilder_ != nil {
                            builderResult.value = valueBuilder_.getMessage()
                        }
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                fileprivate var valueBuilder_:Tensorflow.Test.TestAllTypes.NestedMessage.Builder! {
                    didSet {
                        builderResult.hasValue = true
                    }
                }
                public func getValueBuilder() -> Tensorflow.Test.TestAllTypes.NestedMessage.Builder {
                    if valueBuilder_ == nil {
                        valueBuilder_ = Tensorflow.Test.TestAllTypes.NestedMessage.Builder()
                        builderResult.value = valueBuilder_.getMessage()
                        if value != nil {
                            try! valueBuilder_.mergeFrom(other: value)
                        }
                    }
                    return valueBuilder_
                }
                @discardableResult
                public func setValue(_ value:Tensorflow.Test.TestAllTypes.NestedMessage!) -> Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func mergeValue(value:Tensorflow.Test.TestAllTypes.NestedMessage) throws -> Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder {
                    if builderResult.hasValue {
                        builderResult.value = try Tensorflow.Test.TestAllTypes.NestedMessage.builderWithPrototype(prototype:builderResult.value).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.value = value
                    }
                    builderResult.hasValue = true
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder {
                    valueBuilder_ = nil
                    builderResult.hasValue = false
                    builderResult.value = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder {
                    builderResult = Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry()
                    return self
                }
                override public func clone() throws -> Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder {
                    return try Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry {
                    let returnMe:Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry) throws -> Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder {
                    if other == Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if (other.hasValue) {
                        try mergeValue(value: other.value)
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            key = try codedInputStream.readString()

                        case 18:
                            let subBuilder:Tensorflow.Test.TestAllTypes.NestedMessage.Builder = Tensorflow.Test.TestAllTypes.NestedMessage.Builder()
                            if hasValue {
                                try subBuilder.mergeFrom(other: value)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            value = subBuilder.buildPartial()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder {
                    let resultDecodedBuilder = Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = jsonValueKey
                    }
                    if let jsonValueValue = jsonMap["value"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.value = try Tensorflow.Test.TestAllTypes.NestedMessage.Builder.decodeToBuilder(jsonMap:jsonValueValue).build()

                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //OneOf declaration start

        public enum OneofField {
            case OneOfOneofFieldNotSet

            public func checkOneOfIsSet() -> Bool {
                switch self {
                case .OneOfOneofFieldNotSet: return false
                default: return true
                }
            }
            case OneofUint32(UInt32)

            public static func getOneofUint32(_ value:OneofField) -> UInt32? {
                switch value {
                case .OneofUint32(let enumValue): return enumValue
                default: return nil
                }
            }
            case OneofNestedMessage(Tensorflow.Test.TestAllTypes.NestedMessage)

            public static func getOneofNestedMessage(_ value:OneofField) -> Tensorflow.Test.TestAllTypes.NestedMessage? {
                switch value {
                case .OneofNestedMessage(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case OneofString(String)

            public static func getOneofString(_ value:OneofField) -> String? {
                switch value {
                case .OneofString(let enumValue): return enumValue
                default: return nil
                }
            }
            case OneofBytes(Data)

            public static func getOneofBytes(_ value:OneofField) -> Data? {
                switch value {
                case .OneofBytes(let enumValue): return enumValue
                default: return nil
                }
            }
            case OneofEnum(Tensorflow.Test.TestAllTypes.NestedEnum)

            public static func getOneofEnum(_ value:OneofField) -> Tensorflow.Test.TestAllTypes.NestedEnum? {
                switch value {
                case .OneofEnum(let enumValue): return enumValue
                default: return nil
                }
            }
        }
        //OneOf declaration end

        fileprivate var storageOneofField:TestAllTypes.OneofField =  TestAllTypes.OneofField.OneOfOneofFieldNotSet
        public func getOneOfOneofField() ->  TestAllTypes.OneofField {
            let copyObjectOneofField = storageOneofField
            return copyObjectOneofField
        }


            //Enum type declaration start 

            public enum NestedEnum:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
                case zero = 0
                case foo = 1
                case bar = 2
                case baz = 3

                /// Intentionally negative.
                case neg = -1
                public func toString() -> String {
                    switch self {
                    case .zero: return "ZERO"
                    case .foo: return "FOO"
                    case .bar: return "BAR"
                    case .baz: return "BAZ"
                    case .neg: return "NEG"
                    }
                }
                public static func fromString(str:String) throws -> Tensorflow.Test.TestAllTypes.NestedEnum {
                    switch str {
                    case "ZERO":    return .zero
                    case "FOO":    return .foo
                    case "BAR":    return .bar
                    case "BAZ":    return .baz
                    case "NEG":    return .neg
                    default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
                    }
                }
                public var debugDescription:String { return getDescription() }
                public var description:String { return getDescription() }
                private func getDescription() -> String { 
                    switch self {
                    case .zero: return ".zero"
                    case .foo: return ".foo"
                    case .bar: return ".bar"
                    case .baz: return ".baz"
                    case .neg: return ".neg"
                    }
                }
                public var hashValue:Int {
                    return self.rawValue.hashValue
                }
                public static func ==(lhs:NestedEnum, rhs:NestedEnum) -> Bool {
                    return lhs.hashValue == rhs.hashValue
                }
            }

            //Enum type declaration end 

        /// Singular
        public fileprivate(set) var optionalInt32:Int32 = Int32(0)
        public fileprivate(set) var hasOptionalInt32:Bool = false

        public fileprivate(set) var optionalInt64:Int64 = Int64(0)
        public fileprivate(set) var hasOptionalInt64:Bool = false

        public fileprivate(set) var optionalUint32:UInt32 = UInt32(0)
        public fileprivate(set) var hasOptionalUint32:Bool = false

        /// use large tag to test output order.
        public fileprivate(set) var optionalUint64:UInt64 = UInt64(0)
        public fileprivate(set) var hasOptionalUint64:Bool = false

        public fileprivate(set) var optionalSint32:Int32 = Int32(0)
        public fileprivate(set) var hasOptionalSint32:Bool = false

        public fileprivate(set) var optionalSint64:Int64 = Int64(0)
        public fileprivate(set) var hasOptionalSint64:Bool = false

        public fileprivate(set) var optionalFixed32:UInt32 = UInt32(0)
        public fileprivate(set) var hasOptionalFixed32:Bool = false

        public fileprivate(set) var optionalFixed64:UInt64 = UInt64(0)
        public fileprivate(set) var hasOptionalFixed64:Bool = false

        public fileprivate(set) var optionalSfixed32:Int32 = Int32(0)
        public fileprivate(set) var hasOptionalSfixed32:Bool = false

        public fileprivate(set) var optionalSfixed64:Int64 = Int64(0)
        public fileprivate(set) var hasOptionalSfixed64:Bool = false

        public fileprivate(set) var optionalFloat:Float = Float(0)
        public fileprivate(set) var hasOptionalFloat:Bool = false

        public fileprivate(set) var optionalDouble:Double = Double(0)
        public fileprivate(set) var hasOptionalDouble:Bool = false

        public fileprivate(set) var optionalBool:Bool = false
        public fileprivate(set) var hasOptionalBool:Bool = false

        public fileprivate(set) var optionalString:String = ""
        public fileprivate(set) var hasOptionalString:Bool = false

        public fileprivate(set) var optionalBytes:Data = Data()
        public fileprivate(set) var hasOptionalBytes:Bool = false

        public fileprivate(set) var optionalNestedMessage:Tensorflow.Test.TestAllTypes.NestedMessage!
        public fileprivate(set) var hasOptionalNestedMessage:Bool = false
        public fileprivate(set) var optionalForeignMessage:Tensorflow.Test.ForeignMessage!
        public fileprivate(set) var hasOptionalForeignMessage:Bool = false
        public fileprivate(set) var optionalNestedEnum:Tensorflow.Test.TestAllTypes.NestedEnum = Tensorflow.Test.TestAllTypes.NestedEnum.zero
        public fileprivate(set) var hasOptionalNestedEnum:Bool = false
        public fileprivate(set) var optionalForeignEnum:Tensorflow.Test.ForeignEnum = Tensorflow.Test.ForeignEnum.foreignZero
        public fileprivate(set) var hasOptionalForeignEnum:Bool = false
        public fileprivate(set) var optionalCord:String = ""
        public fileprivate(set) var hasOptionalCord:Bool = false

        /// Repeated
        public fileprivate(set) var repeatedInt32:Array<Int32> = Array<Int32>()
        private var repeatedInt32MemoizedSerializedSize:Int32 = -1
        public fileprivate(set) var repeatedInt64:Array<Int64> = Array<Int64>()
        private var repeatedInt64MemoizedSerializedSize:Int32 = -1
        public fileprivate(set) var repeatedUint32:Array<UInt32> = Array<UInt32>()
        private var repeatedUint32MemoizedSerializedSize:Int32 = -1
        public fileprivate(set) var repeatedUint64:Array<UInt64> = Array<UInt64>()
        private var repeatedUint64MemoizedSerializedSize:Int32 = -1
        public fileprivate(set) var repeatedSint32:Array<Int32> = Array<Int32>()
        private var repeatedSint32MemoizedSerializedSize:Int32 = -1
        public fileprivate(set) var repeatedSint64:Array<Int64> = Array<Int64>()
        private var repeatedSint64MemoizedSerializedSize:Int32 = -1
        public fileprivate(set) var repeatedFixed32:Array<UInt32> = Array<UInt32>()
        private var repeatedFixed32MemoizedSerializedSize:Int32 = -1
        public fileprivate(set) var repeatedFixed64:Array<UInt64> = Array<UInt64>()
        private var repeatedFixed64MemoizedSerializedSize:Int32 = -1
        public fileprivate(set) var repeatedSfixed32:Array<Int32> = Array<Int32>()
        private var repeatedSfixed32MemoizedSerializedSize:Int32 = -1
        public fileprivate(set) var repeatedSfixed64:Array<Int64> = Array<Int64>()
        private var repeatedSfixed64MemoizedSerializedSize:Int32 = -1
        public fileprivate(set) var repeatedFloat:Array<Float> = Array<Float>()
        private var repeatedFloatMemoizedSerializedSize:Int32 = -1
        public fileprivate(set) var repeatedDouble:Array<Double> = Array<Double>()
        private var repeatedDoubleMemoizedSerializedSize:Int32 = -1
        public fileprivate(set) var repeatedBool:Array<Bool> = Array<Bool>()
        private var repeatedBoolMemoizedSerializedSize:Int32 = -1
        public fileprivate(set) var repeatedString:Array<String> = Array<String>()
        public fileprivate(set) var repeatedBytes:Array<Data> = Array<Data>()
        public fileprivate(set) var repeatedNestedMessage:Array<Tensorflow.Test.TestAllTypes.NestedMessage>  = Array<Tensorflow.Test.TestAllTypes.NestedMessage>()
        private var repeatedNestedEnumMemoizedSerializedSize:Int32 = 0
        public fileprivate(set) var repeatedNestedEnum:Array<Tensorflow.Test.TestAllTypes.NestedEnum> = Array<Tensorflow.Test.TestAllTypes.NestedEnum>()
        public fileprivate(set) var repeatedCord:Array<String> = Array<String>()
        public fileprivate(set) var oneofUint32:UInt32!{
            get {
                return TestAllTypes.OneofField.getOneofUint32(storageOneofField)
            }
            set (newvalue) {
                storageOneofField = TestAllTypes.OneofField.OneofUint32(newvalue)
            }
        }
        public fileprivate(set) var hasOneofUint32:Bool {
            get {
                guard let _ = TestAllTypes.OneofField.getOneofUint32(storageOneofField) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var oneofNestedMessage:Tensorflow.Test.TestAllTypes.NestedMessage!{
            get {
                return TestAllTypes.OneofField.getOneofNestedMessage(storageOneofField)
            }
            set (newvalue) {
                storageOneofField = TestAllTypes.OneofField.OneofNestedMessage(newvalue)
            }
        }
        public fileprivate(set) var hasOneofNestedMessage:Bool {
            get {
                guard let _ = TestAllTypes.OneofField.getOneofNestedMessage(storageOneofField) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var oneofString:String!{
            get {
                return TestAllTypes.OneofField.getOneofString(storageOneofField)
            }
            set (newvalue) {
                storageOneofField = TestAllTypes.OneofField.OneofString(newvalue)
            }
        }
        public fileprivate(set) var hasOneofString:Bool {
            get {
                guard let _ = TestAllTypes.OneofField.getOneofString(storageOneofField) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var oneofBytes:Data!{
            get {
                return TestAllTypes.OneofField.getOneofBytes(storageOneofField)
            }
            set (newvalue) {
                storageOneofField = TestAllTypes.OneofField.OneofBytes(newvalue)
            }
        }
        public fileprivate(set) var hasOneofBytes:Bool {
            get {
                guard let _ = TestAllTypes.OneofField.getOneofBytes(storageOneofField) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var oneofEnum:Tensorflow.Test.TestAllTypes.NestedEnum!{
            get {
                return TestAllTypes.OneofField.getOneofEnum(storageOneofField)
            }
            set (newvalue) {
                storageOneofField = TestAllTypes.OneofField.OneofEnum(newvalue)
            }
        }
        public fileprivate(set) var hasOneofEnum:Bool {
            get {
                guard let _ = TestAllTypes.OneofField.getOneofEnum(storageOneofField) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var mapStringToMessage:Dictionary<String,Tensorflow.Test.TestAllTypes.NestedMessage> = Dictionary<String,Tensorflow.Test.TestAllTypes.NestedMessage>()

        public fileprivate(set) var hasMapStringToMessage:Bool = false
        public fileprivate(set) var mapInt32ToMessage:Dictionary<Int32,Tensorflow.Test.TestAllTypes.NestedMessage> = Dictionary<Int32,Tensorflow.Test.TestAllTypes.NestedMessage>()

        public fileprivate(set) var hasMapInt32ToMessage:Bool = false
        public fileprivate(set) var mapInt64ToMessage:Dictionary<Int64,Tensorflow.Test.TestAllTypes.NestedMessage> = Dictionary<Int64,Tensorflow.Test.TestAllTypes.NestedMessage>()

        public fileprivate(set) var hasMapInt64ToMessage:Bool = false
        public fileprivate(set) var mapBoolToMessage:Dictionary<Bool,Tensorflow.Test.TestAllTypes.NestedMessage> = Dictionary<Bool,Tensorflow.Test.TestAllTypes.NestedMessage>()

        public fileprivate(set) var hasMapBoolToMessage:Bool = false
        public fileprivate(set) var mapStringToInt64:Dictionary<String,Int64> = Dictionary<String,Int64>()

        public fileprivate(set) var hasMapStringToInt64:Bool = false
        public fileprivate(set) var mapInt64ToString:Dictionary<Int64,String> = Dictionary<Int64,String>()

        public fileprivate(set) var hasMapInt64ToString:Bool = false
        public fileprivate(set) var anotherMapStringToMessage:Dictionary<String,Tensorflow.Test.TestAllTypes.NestedMessage> = Dictionary<String,Tensorflow.Test.TestAllTypes.NestedMessage>()

        public fileprivate(set) var hasAnotherMapStringToMessage:Bool = false
        public fileprivate(set) var packedRepeatedInt64:Array<Int64> = Array<Int64>()
        private var packedRepeatedInt64MemoizedSerializedSize:Int32 = -1
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasOptionalInt64 {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:optionalInt64)
            }
            if hasOptionalUint32 {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:optionalUint32)
            }
            if hasOptionalSint32 {
                try codedOutputStream.writeSInt32(fieldNumber: 5, value:optionalSint32)
            }
            if hasOptionalSint64 {
                try codedOutputStream.writeSInt64(fieldNumber: 6, value:optionalSint64)
            }
            if hasOptionalFixed32 {
                try codedOutputStream.writeFixed32(fieldNumber: 7, value:optionalFixed32)
            }
            if hasOptionalFixed64 {
                try codedOutputStream.writeFixed64(fieldNumber: 8, value:optionalFixed64)
            }
            if hasOptionalSfixed32 {
                try codedOutputStream.writeSFixed32(fieldNumber: 9, value:optionalSfixed32)
            }
            if hasOptionalSfixed64 {
                try codedOutputStream.writeSFixed64(fieldNumber: 10, value:optionalSfixed64)
            }
            if hasOptionalFloat {
                try codedOutputStream.writeFloat(fieldNumber: 11, value:optionalFloat)
            }
            if hasOptionalDouble {
                try codedOutputStream.writeDouble(fieldNumber: 12, value:optionalDouble)
            }
            if hasOptionalBool {
                try codedOutputStream.writeBool(fieldNumber: 13, value:optionalBool)
            }
            if hasOptionalString {
                try codedOutputStream.writeString(fieldNumber: 14, value:optionalString)
            }
            if hasOptionalBytes {
                try codedOutputStream.writeData(fieldNumber: 15, value:optionalBytes)
            }
            if hasOptionalNestedMessage {
                try codedOutputStream.writeMessage(fieldNumber: 18, value:optionalNestedMessage)
            }
            if hasOptionalForeignMessage {
                try codedOutputStream.writeMessage(fieldNumber: 19, value:optionalForeignMessage)
            }
            if hasOptionalNestedEnum {
                try codedOutputStream.writeEnum(fieldNumber: 21, value:optionalNestedEnum.rawValue)
            }
            if hasOptionalForeignEnum {
                try codedOutputStream.writeEnum(fieldNumber: 22, value:optionalForeignEnum.rawValue)
            }
            if hasOptionalCord {
                try codedOutputStream.writeString(fieldNumber: 25, value:optionalCord)
            }
            if !repeatedInt32.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 250)
                try codedOutputStream.writeRawVarint32(value: repeatedInt32MemoizedSerializedSize)
                for oneValuerepeatedInt32 in repeatedInt32 {
                    try codedOutputStream.writeInt32NoTag(value: oneValuerepeatedInt32)
                }
            }
            if !repeatedInt64.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 258)
                try codedOutputStream.writeRawVarint32(value: repeatedInt64MemoizedSerializedSize)
                for oneValuerepeatedInt64 in repeatedInt64 {
                    try codedOutputStream.writeInt64NoTag(value: oneValuerepeatedInt64)
                }
            }
            if !repeatedUint32.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 266)
                try codedOutputStream.writeRawVarint32(value: repeatedUint32MemoizedSerializedSize)
                for oneValuerepeatedUint32 in repeatedUint32 {
                    try codedOutputStream.writeUInt32NoTag(value: oneValuerepeatedUint32)
                }
            }
            if !repeatedUint64.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 274)
                try codedOutputStream.writeRawVarint32(value: repeatedUint64MemoizedSerializedSize)
                for oneValuerepeatedUint64 in repeatedUint64 {
                    try codedOutputStream.writeUInt64NoTag(value: oneValuerepeatedUint64)
                }
            }
            if !repeatedSint32.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 282)
                try codedOutputStream.writeRawVarint32(value: repeatedSint32MemoizedSerializedSize)
                for oneValuerepeatedSint32 in repeatedSint32 {
                    try codedOutputStream.writeSInt32NoTag(value: oneValuerepeatedSint32)
                }
            }
            if !repeatedSint64.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 290)
                try codedOutputStream.writeRawVarint32(value: repeatedSint64MemoizedSerializedSize)
                for oneValuerepeatedSint64 in repeatedSint64 {
                    try codedOutputStream.writeSInt64NoTag(value: oneValuerepeatedSint64)
                }
            }
            if !repeatedFixed32.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 298)
                try codedOutputStream.writeRawVarint32(value: repeatedFixed32MemoizedSerializedSize)
                for oneValuerepeatedFixed32 in repeatedFixed32 {
                    try codedOutputStream.writeFixed32NoTag(value: oneValuerepeatedFixed32)
                }
            }
            if !repeatedFixed64.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 306)
                try codedOutputStream.writeRawVarint32(value: repeatedFixed64MemoizedSerializedSize)
                for oneValuerepeatedFixed64 in repeatedFixed64 {
                    try codedOutputStream.writeFixed64NoTag(value: oneValuerepeatedFixed64)
                }
            }
            if !repeatedSfixed32.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 314)
                try codedOutputStream.writeRawVarint32(value: repeatedSfixed32MemoizedSerializedSize)
                for oneValuerepeatedSfixed32 in repeatedSfixed32 {
                    try codedOutputStream.writeSFixed32NoTag(value: oneValuerepeatedSfixed32)
                }
            }
            if !repeatedSfixed64.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 322)
                try codedOutputStream.writeRawVarint32(value: repeatedSfixed64MemoizedSerializedSize)
                for oneValuerepeatedSfixed64 in repeatedSfixed64 {
                    try codedOutputStream.writeSFixed64NoTag(value: oneValuerepeatedSfixed64)
                }
            }
            if !repeatedFloat.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 330)
                try codedOutputStream.writeRawVarint32(value: repeatedFloatMemoizedSerializedSize)
                for oneValuerepeatedFloat in repeatedFloat {
                    try codedOutputStream.writeFloatNoTag(value: oneValuerepeatedFloat)
                }
            }
            if !repeatedDouble.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 338)
                try codedOutputStream.writeRawVarint32(value: repeatedDoubleMemoizedSerializedSize)
                for oneValuerepeatedDouble in repeatedDouble {
                    try codedOutputStream.writeDoubleNoTag(value: oneValuerepeatedDouble)
                }
            }
            if !repeatedBool.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 346)
                try codedOutputStream.writeRawVarint32(value: repeatedBoolMemoizedSerializedSize)
                for oneValuerepeatedBool in repeatedBool {
                    try codedOutputStream.writeBoolNoTag(value: oneValuerepeatedBool)
                }
            }
            if !repeatedString.isEmpty {
                for oneValuerepeatedString in repeatedString {
                    try codedOutputStream.writeString(fieldNumber: 44, value:oneValuerepeatedString)
                }
            }
            if !repeatedBytes.isEmpty {
                for oneValuerepeatedBytes in repeatedBytes {
                    try codedOutputStream.writeData(fieldNumber: 45, value:oneValuerepeatedBytes)
                }
            }
            for oneElementRepeatedNestedMessage in repeatedNestedMessage {
                  try codedOutputStream.writeMessage(fieldNumber: 48, value:oneElementRepeatedNestedMessage)
            }
            if !repeatedNestedEnum.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 410)
                try codedOutputStream.writeRawVarint32(value: repeatedNestedEnumMemoizedSerializedSize)
            }
            for oneValueOfrepeatedNestedEnum in repeatedNestedEnum {
                  try codedOutputStream.writeEnumNoTag(value: oneValueOfrepeatedNestedEnum.rawValue)
            }
            if !repeatedCord.isEmpty {
                for oneValuerepeatedCord in repeatedCord {
                    try codedOutputStream.writeString(fieldNumber: 55, value:oneValuerepeatedCord)
                }
            }
            if hasMapStringToMessage {
                for (keyMapStringToMessage, valueMapStringToMessage) in mapStringToMessage {
                    let valueOfMapStringToMessage = try! Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder().setKey(keyMapStringToMessage).setValue(valueMapStringToMessage).build()
                      try codedOutputStream.writeMessage(fieldNumber: 58, value:valueOfMapStringToMessage)
                  }
            }
            if hasMapInt32ToMessage {
                for (keyMapInt32ToMessage, valueMapInt32ToMessage) in mapInt32ToMessage {
                    let valueOfMapInt32ToMessage = try! Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder().setKey(keyMapInt32ToMessage).setValue(valueMapInt32ToMessage).build()
                      try codedOutputStream.writeMessage(fieldNumber: 59, value:valueOfMapInt32ToMessage)
                  }
            }
            if hasMapInt64ToMessage {
                for (keyMapInt64ToMessage, valueMapInt64ToMessage) in mapInt64ToMessage {
                    let valueOfMapInt64ToMessage = try! Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder().setKey(keyMapInt64ToMessage).setValue(valueMapInt64ToMessage).build()
                      try codedOutputStream.writeMessage(fieldNumber: 60, value:valueOfMapInt64ToMessage)
                  }
            }
            if hasMapBoolToMessage {
                for (keyMapBoolToMessage, valueMapBoolToMessage) in mapBoolToMessage {
                    let valueOfMapBoolToMessage = try! Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder().setKey(keyMapBoolToMessage).setValue(valueMapBoolToMessage).build()
                      try codedOutputStream.writeMessage(fieldNumber: 61, value:valueOfMapBoolToMessage)
                  }
            }
            if hasMapStringToInt64 {
                for (keyMapStringToInt64, valueMapStringToInt64) in mapStringToInt64 {
                    let valueOfMapStringToInt64 = try! Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder().setKey(keyMapStringToInt64).setValue(valueMapStringToInt64).build()
                      try codedOutputStream.writeMessage(fieldNumber: 62, value:valueOfMapStringToInt64)
                  }
            }
            if hasMapInt64ToString {
                for (keyMapInt64ToString, valueMapInt64ToString) in mapInt64ToString {
                    let valueOfMapInt64ToString = try! Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder().setKey(keyMapInt64ToString).setValue(valueMapInt64ToString).build()
                      try codedOutputStream.writeMessage(fieldNumber: 63, value:valueOfMapInt64ToString)
                  }
            }
            if !packedRepeatedInt64.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 514)
                try codedOutputStream.writeRawVarint32(value: packedRepeatedInt64MemoizedSerializedSize)
                for oneValuepackedRepeatedInt64 in packedRepeatedInt64 {
                    try codedOutputStream.writeInt64NoTag(value: oneValuepackedRepeatedInt64)
                }
            }
            if hasAnotherMapStringToMessage {
                for (keyAnotherMapStringToMessage, valueAnotherMapStringToMessage) in anotherMapStringToMessage {
                    let valueOfAnotherMapStringToMessage = try! Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder().setKey(keyAnotherMapStringToMessage).setValue(valueAnotherMapStringToMessage).build()
                      try codedOutputStream.writeMessage(fieldNumber: 65, value:valueOfAnotherMapStringToMessage)
                  }
            }
            if hasOneofEnum {
                try codedOutputStream.writeEnum(fieldNumber: 100, value:oneofEnum.rawValue)
            }
            if hasOneofUint32 {
                try codedOutputStream.writeUInt32(fieldNumber: 111, value:oneofUint32)
            }
            if hasOneofNestedMessage {
                try codedOutputStream.writeMessage(fieldNumber: 112, value:oneofNestedMessage)
            }
            if hasOneofString {
                try codedOutputStream.writeString(fieldNumber: 113, value:oneofString)
            }
            if hasOneofBytes {
                try codedOutputStream.writeData(fieldNumber: 114, value:oneofBytes)
            }
            if hasOptionalUint64 {
                try codedOutputStream.writeUInt64(fieldNumber: 999, value:optionalUint64)
            }
            if hasOptionalInt32 {
                try codedOutputStream.writeInt32(fieldNumber: 1000, value:optionalInt32)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasOptionalInt64 {
                serialize_size += optionalInt64.computeInt64Size(fieldNumber: 2)
            }
            if hasOptionalUint32 {
                serialize_size += optionalUint32.computeUInt32Size(fieldNumber: 3)
            }
            if hasOptionalSint32 {
                serialize_size += optionalSint32.computeSInt32Size(fieldNumber: 5)
            }
            if hasOptionalSint64 {
                serialize_size += optionalSint64.computeSInt64Size(fieldNumber: 6)
            }
            if hasOptionalFixed32 {
                serialize_size += optionalFixed32.computeFixed32Size(fieldNumber: 7)
            }
            if hasOptionalFixed64 {
                serialize_size += optionalFixed64.computeFixed64Size(fieldNumber: 8)
            }
            if hasOptionalSfixed32 {
                serialize_size += optionalSfixed32.computeSFixed32Size(fieldNumber: 9)
            }
            if hasOptionalSfixed64 {
                serialize_size += optionalSfixed64.computeSFixed64Size(fieldNumber: 10)
            }
            if hasOptionalFloat {
                serialize_size += optionalFloat.computeFloatSize(fieldNumber: 11)
            }
            if hasOptionalDouble {
                serialize_size += optionalDouble.computeDoubleSize(fieldNumber: 12)
            }
            if hasOptionalBool {
                serialize_size += optionalBool.computeBoolSize(fieldNumber: 13)
            }
            if hasOptionalString {
                serialize_size += optionalString.computeStringSize(fieldNumber: 14)
            }
            if hasOptionalBytes {
                serialize_size += optionalBytes.computeDataSize(fieldNumber: 15)
            }
            if hasOptionalNestedMessage {
                if let varSizeoptionalNestedMessage = optionalNestedMessage?.computeMessageSize(fieldNumber: 18) {
                    serialize_size += varSizeoptionalNestedMessage
                }
            }
            if hasOptionalForeignMessage {
                if let varSizeoptionalForeignMessage = optionalForeignMessage?.computeMessageSize(fieldNumber: 19) {
                    serialize_size += varSizeoptionalForeignMessage
                }
            }
            if (hasOptionalNestedEnum) {
                serialize_size += optionalNestedEnum.rawValue.computeEnumSize(fieldNumber: 21)
            }
            if (hasOptionalForeignEnum) {
                serialize_size += optionalForeignEnum.rawValue.computeEnumSize(fieldNumber: 22)
            }
            if hasOptionalCord {
                serialize_size += optionalCord.computeStringSize(fieldNumber: 25)
            }
            var dataSizeRepeatedInt32:Int32 = 0
            for oneValuerepeatedInt32 in repeatedInt32 {
                dataSizeRepeatedInt32 += oneValuerepeatedInt32.computeInt32SizeNoTag()
            }
            serialize_size += dataSizeRepeatedInt32
            if !repeatedInt32.isEmpty {
                serialize_size += 2
                serialize_size += dataSizeRepeatedInt32.computeInt32SizeNoTag()
            }
            repeatedInt32MemoizedSerializedSize = dataSizeRepeatedInt32
            var dataSizeRepeatedInt64:Int32 = 0
            for oneValuerepeatedInt64 in repeatedInt64 {
                dataSizeRepeatedInt64 += oneValuerepeatedInt64.computeInt64SizeNoTag()
            }
            serialize_size += dataSizeRepeatedInt64
            if !repeatedInt64.isEmpty {
                serialize_size += 2
                serialize_size += dataSizeRepeatedInt64.computeInt32SizeNoTag()
            }
            repeatedInt64MemoizedSerializedSize = dataSizeRepeatedInt64
            var dataSizeRepeatedUint32:Int32 = 0
            for oneValuerepeatedUint32 in repeatedUint32 {
                dataSizeRepeatedUint32 += oneValuerepeatedUint32.computeUInt32SizeNoTag()
            }
            serialize_size += dataSizeRepeatedUint32
            if !repeatedUint32.isEmpty {
                serialize_size += 2
                serialize_size += dataSizeRepeatedUint32.computeInt32SizeNoTag()
            }
            repeatedUint32MemoizedSerializedSize = dataSizeRepeatedUint32
            var dataSizeRepeatedUint64:Int32 = 0
            for oneValuerepeatedUint64 in repeatedUint64 {
                dataSizeRepeatedUint64 += oneValuerepeatedUint64.computeUInt64SizeNoTag()
            }
            serialize_size += dataSizeRepeatedUint64
            if !repeatedUint64.isEmpty {
                serialize_size += 2
                serialize_size += dataSizeRepeatedUint64.computeInt32SizeNoTag()
            }
            repeatedUint64MemoizedSerializedSize = dataSizeRepeatedUint64
            var dataSizeRepeatedSint32:Int32 = 0
            for oneValuerepeatedSint32 in repeatedSint32 {
                dataSizeRepeatedSint32 += oneValuerepeatedSint32.computeSInt32SizeNoTag()
            }
            serialize_size += dataSizeRepeatedSint32
            if !repeatedSint32.isEmpty {
                serialize_size += 2
                serialize_size += dataSizeRepeatedSint32.computeInt32SizeNoTag()
            }
            repeatedSint32MemoizedSerializedSize = dataSizeRepeatedSint32
            var dataSizeRepeatedSint64:Int32 = 0
            for oneValuerepeatedSint64 in repeatedSint64 {
                dataSizeRepeatedSint64 += oneValuerepeatedSint64.computeSInt64SizeNoTag()
            }
            serialize_size += dataSizeRepeatedSint64
            if !repeatedSint64.isEmpty {
                serialize_size += 2
                serialize_size += dataSizeRepeatedSint64.computeInt32SizeNoTag()
            }
            repeatedSint64MemoizedSerializedSize = dataSizeRepeatedSint64
            var dataSizeRepeatedFixed32:Int32 = 0
            dataSizeRepeatedFixed32 = 4 * Int32(repeatedFixed32.count)
            serialize_size += dataSizeRepeatedFixed32
            if !repeatedFixed32.isEmpty {
                serialize_size += 2
                serialize_size += dataSizeRepeatedFixed32.computeInt32SizeNoTag()
            }
            repeatedFixed32MemoizedSerializedSize = dataSizeRepeatedFixed32
            var dataSizeRepeatedFixed64:Int32 = 0
            dataSizeRepeatedFixed64 = 8 * Int32(repeatedFixed64.count)
            serialize_size += dataSizeRepeatedFixed64
            if !repeatedFixed64.isEmpty {
                serialize_size += 2
                serialize_size += dataSizeRepeatedFixed64.computeInt32SizeNoTag()
            }
            repeatedFixed64MemoizedSerializedSize = dataSizeRepeatedFixed64
            var dataSizeRepeatedSfixed32:Int32 = 0
            dataSizeRepeatedSfixed32 = 4 * Int32(repeatedSfixed32.count)
            serialize_size += dataSizeRepeatedSfixed32
            if !repeatedSfixed32.isEmpty {
                serialize_size += 2
                serialize_size += dataSizeRepeatedSfixed32.computeInt32SizeNoTag()
            }
            repeatedSfixed32MemoizedSerializedSize = dataSizeRepeatedSfixed32
            var dataSizeRepeatedSfixed64:Int32 = 0
            dataSizeRepeatedSfixed64 = 8 * Int32(repeatedSfixed64.count)
            serialize_size += dataSizeRepeatedSfixed64
            if !repeatedSfixed64.isEmpty {
                serialize_size += 2
                serialize_size += dataSizeRepeatedSfixed64.computeInt32SizeNoTag()
            }
            repeatedSfixed64MemoizedSerializedSize = dataSizeRepeatedSfixed64
            var dataSizeRepeatedFloat:Int32 = 0
            dataSizeRepeatedFloat = 4 * Int32(repeatedFloat.count)
            serialize_size += dataSizeRepeatedFloat
            if !repeatedFloat.isEmpty {
                serialize_size += 2
                serialize_size += dataSizeRepeatedFloat.computeInt32SizeNoTag()
            }
            repeatedFloatMemoizedSerializedSize = dataSizeRepeatedFloat
            var dataSizeRepeatedDouble:Int32 = 0
            dataSizeRepeatedDouble = 8 * Int32(repeatedDouble.count)
            serialize_size += dataSizeRepeatedDouble
            if !repeatedDouble.isEmpty {
                serialize_size += 2
                serialize_size += dataSizeRepeatedDouble.computeInt32SizeNoTag()
            }
            repeatedDoubleMemoizedSerializedSize = dataSizeRepeatedDouble
            var dataSizeRepeatedBool:Int32 = 0
            dataSizeRepeatedBool = 1 * Int32(repeatedBool.count)
            serialize_size += dataSizeRepeatedBool
            if !repeatedBool.isEmpty {
                serialize_size += 2
                serialize_size += dataSizeRepeatedBool.computeInt32SizeNoTag()
            }
            repeatedBoolMemoizedSerializedSize = dataSizeRepeatedBool
            var dataSizeRepeatedString:Int32 = 0
            for oneValuerepeatedString in repeatedString {
                dataSizeRepeatedString += oneValuerepeatedString.computeStringSizeNoTag()
            }
            serialize_size += dataSizeRepeatedString
            serialize_size += 2 * Int32(repeatedString.count)
            var dataSizeRepeatedBytes:Int32 = 0
            for oneValuerepeatedBytes in repeatedBytes {
                dataSizeRepeatedBytes += oneValuerepeatedBytes.computeDataSizeNoTag()
            }
            serialize_size += dataSizeRepeatedBytes
            serialize_size += 2 * Int32(repeatedBytes.count)
            for oneElementRepeatedNestedMessage in repeatedNestedMessage {
                serialize_size += oneElementRepeatedNestedMessage.computeMessageSize(fieldNumber: 48)
            }
            var dataSizerepeatedNestedEnum:Int32 = 0
            for oneValueOfrepeatedNestedEnum in repeatedNestedEnum {
                dataSizerepeatedNestedEnum += oneValueOfrepeatedNestedEnum.rawValue.computeEnumSizeNoTag()
            }
            serialize_size += dataSizerepeatedNestedEnum
            if !repeatedNestedEnum.isEmpty {
                serialize_size += 2
                serialize_size += dataSizerepeatedNestedEnum.computeRawVarint32Size()
            }
            repeatedNestedEnumMemoizedSerializedSize = dataSizerepeatedNestedEnum
            var dataSizeRepeatedCord:Int32 = 0
            for oneValuerepeatedCord in repeatedCord {
                dataSizeRepeatedCord += oneValuerepeatedCord.computeStringSizeNoTag()
            }
            serialize_size += dataSizeRepeatedCord
            serialize_size += 2 * Int32(repeatedCord.count)
            if hasMapStringToMessage {
                  for (keyMapStringToMessage, valueMapStringToMessage) in mapStringToMessage {
                      let valueOfMapStringToMessage = try! Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder().setKey(keyMapStringToMessage).setValue(valueMapStringToMessage).build()
                serialize_size += valueOfMapStringToMessage.computeMessageSize(fieldNumber: 58)
                }
            }
            if hasMapInt32ToMessage {
                  for (keyMapInt32ToMessage, valueMapInt32ToMessage) in mapInt32ToMessage {
                      let valueOfMapInt32ToMessage = try! Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder().setKey(keyMapInt32ToMessage).setValue(valueMapInt32ToMessage).build()
                serialize_size += valueOfMapInt32ToMessage.computeMessageSize(fieldNumber: 59)
                }
            }
            if hasMapInt64ToMessage {
                  for (keyMapInt64ToMessage, valueMapInt64ToMessage) in mapInt64ToMessage {
                      let valueOfMapInt64ToMessage = try! Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder().setKey(keyMapInt64ToMessage).setValue(valueMapInt64ToMessage).build()
                serialize_size += valueOfMapInt64ToMessage.computeMessageSize(fieldNumber: 60)
                }
            }
            if hasMapBoolToMessage {
                  for (keyMapBoolToMessage, valueMapBoolToMessage) in mapBoolToMessage {
                      let valueOfMapBoolToMessage = try! Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder().setKey(keyMapBoolToMessage).setValue(valueMapBoolToMessage).build()
                serialize_size += valueOfMapBoolToMessage.computeMessageSize(fieldNumber: 61)
                }
            }
            if hasMapStringToInt64 {
                  for (keyMapStringToInt64, valueMapStringToInt64) in mapStringToInt64 {
                      let valueOfMapStringToInt64 = try! Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder().setKey(keyMapStringToInt64).setValue(valueMapStringToInt64).build()
                serialize_size += valueOfMapStringToInt64.computeMessageSize(fieldNumber: 62)
                }
            }
            if hasMapInt64ToString {
                  for (keyMapInt64ToString, valueMapInt64ToString) in mapInt64ToString {
                      let valueOfMapInt64ToString = try! Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder().setKey(keyMapInt64ToString).setValue(valueMapInt64ToString).build()
                serialize_size += valueOfMapInt64ToString.computeMessageSize(fieldNumber: 63)
                }
            }
            var dataSizePackedRepeatedInt64:Int32 = 0
            for oneValuepackedRepeatedInt64 in packedRepeatedInt64 {
                dataSizePackedRepeatedInt64 += oneValuepackedRepeatedInt64.computeInt64SizeNoTag()
            }
            serialize_size += dataSizePackedRepeatedInt64
            if !packedRepeatedInt64.isEmpty {
                serialize_size += 2
                serialize_size += dataSizePackedRepeatedInt64.computeInt32SizeNoTag()
            }
            packedRepeatedInt64MemoizedSerializedSize = dataSizePackedRepeatedInt64
            if hasAnotherMapStringToMessage {
                  for (keyAnotherMapStringToMessage, valueAnotherMapStringToMessage) in anotherMapStringToMessage {
                      let valueOfAnotherMapStringToMessage = try! Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder().setKey(keyAnotherMapStringToMessage).setValue(valueAnotherMapStringToMessage).build()
                serialize_size += valueOfAnotherMapStringToMessage.computeMessageSize(fieldNumber: 65)
                }
            }
            if (hasOneofEnum) {
                serialize_size += oneofEnum.rawValue.computeEnumSize(fieldNumber: 100)
            }
            if hasOneofUint32 {
                serialize_size += oneofUint32.computeUInt32Size(fieldNumber: 111)
            }
            if hasOneofNestedMessage {
                if let varSizeoneofNestedMessage = oneofNestedMessage?.computeMessageSize(fieldNumber: 112) {
                    serialize_size += varSizeoneofNestedMessage
                }
            }
            if hasOneofString {
                serialize_size += oneofString.computeStringSize(fieldNumber: 113)
            }
            if hasOneofBytes {
                serialize_size += oneofBytes.computeDataSize(fieldNumber: 114)
            }
            if hasOptionalUint64 {
                serialize_size += optionalUint64.computeUInt64Size(fieldNumber: 999)
            }
            if hasOptionalInt32 {
                serialize_size += optionalInt32.computeInt32Size(fieldNumber: 1000)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.Test.TestAllTypes.Builder {
            return Tensorflow.Test.TestAllTypes.classBuilder() as! Tensorflow.Test.TestAllTypes.Builder
        }
        public func getBuilder() -> Tensorflow.Test.TestAllTypes.Builder {
            return classBuilder() as! Tensorflow.Test.TestAllTypes.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Test.TestAllTypes.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Test.TestAllTypes.Builder()
        }
        public func toBuilder() throws -> Tensorflow.Test.TestAllTypes.Builder {
            return try Tensorflow.Test.TestAllTypes.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.Test.TestAllTypes) throws -> Tensorflow.Test.TestAllTypes.Builder {
            return try Tensorflow.Test.TestAllTypes.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasOptionalInt32 {
                jsonMap["optionalInt32"] = Int(optionalInt32)
            }
            if hasOptionalInt64 {
                jsonMap["optionalInt64"] = "\(optionalInt64)"
            }
            if hasOptionalUint32 {
                jsonMap["optionalUint32"] = UInt(optionalUint32)
            }
            if hasOptionalUint64 {
                jsonMap["optionalUint64"] = "\(optionalUint64)"
            }
            if hasOptionalSint32 {
                jsonMap["optionalSint32"] = Int(optionalSint32)
            }
            if hasOptionalSint64 {
                jsonMap["optionalSint64"] = "\(optionalSint64)"
            }
            if hasOptionalFixed32 {
                jsonMap["optionalFixed32"] = UInt(optionalFixed32)
            }
            if hasOptionalFixed64 {
                jsonMap["optionalFixed64"] = "\(optionalFixed64)"
            }
            if hasOptionalSfixed32 {
                jsonMap["optionalSfixed32"] = Int(optionalSfixed32)
            }
            if hasOptionalSfixed64 {
                jsonMap["optionalSfixed64"] = "\(optionalSfixed64)"
            }
            if hasOptionalFloat {
                jsonMap["optionalFloat"] = Float(optionalFloat)
            }
            if hasOptionalDouble {
                jsonMap["optionalDouble"] = Double(optionalDouble)
            }
            if hasOptionalBool {
                jsonMap["optionalBool"] = optionalBool
            }
            if hasOptionalString {
                jsonMap["optionalString"] = optionalString
            }
            if hasOptionalBytes {
                jsonMap["optionalBytes"] = optionalBytes.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            if hasOptionalNestedMessage {
                jsonMap["optionalNestedMessage"] = try optionalNestedMessage.encode()
            }
            if hasOptionalForeignMessage {
                jsonMap["optionalForeignMessage"] = try optionalForeignMessage.encode()
            }
            if hasOptionalNestedEnum {
                jsonMap["optionalNestedEnum"] = optionalNestedEnum.toString()
            }
            if hasOptionalForeignEnum {
                jsonMap["optionalForeignEnum"] = optionalForeignEnum.toString()
            }
            if hasOptionalCord {
                jsonMap["optionalCord"] = optionalCord
            }
            if !repeatedInt32.isEmpty {
                var jsonArrayRepeatedInt32:Array<Int> = []
                for oneValueRepeatedInt32 in repeatedInt32 {
                    jsonArrayRepeatedInt32.append(Int(oneValueRepeatedInt32))
                }
                jsonMap["repeatedInt32"] = jsonArrayRepeatedInt32
            }
            if !repeatedInt64.isEmpty {
                var jsonArrayRepeatedInt64:Array<String> = []
                for oneValueRepeatedInt64 in repeatedInt64 {
                    jsonArrayRepeatedInt64.append("\(oneValueRepeatedInt64)")
                }
                jsonMap["repeatedInt64"] = jsonArrayRepeatedInt64
            }
            if !repeatedUint32.isEmpty {
                var jsonArrayRepeatedUint32:Array<UInt> = []
                for oneValueRepeatedUint32 in repeatedUint32 {
                    jsonArrayRepeatedUint32.append(UInt(oneValueRepeatedUint32))
                }
                jsonMap["repeatedUint32"] = jsonArrayRepeatedUint32
            }
            if !repeatedUint64.isEmpty {
                var jsonArrayRepeatedUint64:Array<String> = []
                for oneValueRepeatedUint64 in repeatedUint64 {
                    jsonArrayRepeatedUint64.append("\(oneValueRepeatedUint64)")
                }
                jsonMap["repeatedUint64"] = jsonArrayRepeatedUint64
            }
            if !repeatedSint32.isEmpty {
                var jsonArrayRepeatedSint32:Array<Int> = []
                for oneValueRepeatedSint32 in repeatedSint32 {
                    jsonArrayRepeatedSint32.append(Int(oneValueRepeatedSint32))
                }
                jsonMap["repeatedSint32"] = jsonArrayRepeatedSint32
            }
            if !repeatedSint64.isEmpty {
                var jsonArrayRepeatedSint64:Array<String> = []
                for oneValueRepeatedSint64 in repeatedSint64 {
                    jsonArrayRepeatedSint64.append("\(oneValueRepeatedSint64)")
                }
                jsonMap["repeatedSint64"] = jsonArrayRepeatedSint64
            }
            if !repeatedFixed32.isEmpty {
                var jsonArrayRepeatedFixed32:Array<UInt> = []
                for oneValueRepeatedFixed32 in repeatedFixed32 {
                    jsonArrayRepeatedFixed32.append(UInt(oneValueRepeatedFixed32))
                }
                jsonMap["repeatedFixed32"] = jsonArrayRepeatedFixed32
            }
            if !repeatedFixed64.isEmpty {
                var jsonArrayRepeatedFixed64:Array<String> = []
                for oneValueRepeatedFixed64 in repeatedFixed64 {
                    jsonArrayRepeatedFixed64.append("\(oneValueRepeatedFixed64)")
                }
                jsonMap["repeatedFixed64"] = jsonArrayRepeatedFixed64
            }
            if !repeatedSfixed32.isEmpty {
                var jsonArrayRepeatedSfixed32:Array<Int> = []
                for oneValueRepeatedSfixed32 in repeatedSfixed32 {
                    jsonArrayRepeatedSfixed32.append(Int(oneValueRepeatedSfixed32))
                }
                jsonMap["repeatedSfixed32"] = jsonArrayRepeatedSfixed32
            }
            if !repeatedSfixed64.isEmpty {
                var jsonArrayRepeatedSfixed64:Array<String> = []
                for oneValueRepeatedSfixed64 in repeatedSfixed64 {
                    jsonArrayRepeatedSfixed64.append("\(oneValueRepeatedSfixed64)")
                }
                jsonMap["repeatedSfixed64"] = jsonArrayRepeatedSfixed64
            }
            if !repeatedFloat.isEmpty {
                var jsonArrayRepeatedFloat:Array<Float> = []
                for oneValueRepeatedFloat in repeatedFloat {
                    jsonArrayRepeatedFloat.append(Float(oneValueRepeatedFloat))
                }
                jsonMap["repeatedFloat"] = jsonArrayRepeatedFloat
            }
            if !repeatedDouble.isEmpty {
                var jsonArrayRepeatedDouble:Array<Double> = []
                for oneValueRepeatedDouble in repeatedDouble {
                    jsonArrayRepeatedDouble.append(Double(oneValueRepeatedDouble))
                }
                jsonMap["repeatedDouble"] = jsonArrayRepeatedDouble
            }
            if !repeatedBool.isEmpty {
                var jsonArrayRepeatedBool:Array<Bool> = []
                for oneValueRepeatedBool in repeatedBool {
                    jsonArrayRepeatedBool.append(oneValueRepeatedBool)
                }
                jsonMap["repeatedBool"] = jsonArrayRepeatedBool
            }
            if !repeatedString.isEmpty {
                var jsonArrayRepeatedString:Array<String> = []
                for oneValueRepeatedString in repeatedString {
                    jsonArrayRepeatedString.append(oneValueRepeatedString)
                }
                jsonMap["repeatedString"] = jsonArrayRepeatedString
            }
            if !repeatedBytes.isEmpty {
                var jsonArrayRepeatedBytes:Array<String> = []
                for oneValueRepeatedBytes in repeatedBytes {
                    jsonArrayRepeatedBytes.append(oneValueRepeatedBytes.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0)))
                }
                jsonMap["repeatedBytes"] = jsonArrayRepeatedBytes
            }
            if !repeatedNestedMessage.isEmpty {
                var jsonArrayRepeatedNestedMessage:Array<Dictionary<String,Any>> = []
                for oneValueRepeatedNestedMessage in repeatedNestedMessage {
                    let ecodedMessageRepeatedNestedMessage = try oneValueRepeatedNestedMessage.encode()
                    jsonArrayRepeatedNestedMessage.append(ecodedMessageRepeatedNestedMessage)
                }
                jsonMap["repeatedNestedMessage"] = jsonArrayRepeatedNestedMessage
            }
            if !repeatedNestedEnum.isEmpty {
                var jsonArrayRepeatedNestedEnum:Array<String> = []
                for oneValueRepeatedNestedEnum in repeatedNestedEnum {
                    jsonArrayRepeatedNestedEnum.append(oneValueRepeatedNestedEnum.toString())
                }
                jsonMap["repeatedNestedEnum"] = jsonArrayRepeatedNestedEnum
            }
            if !repeatedCord.isEmpty {
                var jsonArrayRepeatedCord:Array<String> = []
                for oneValueRepeatedCord in repeatedCord {
                    jsonArrayRepeatedCord.append(oneValueRepeatedCord)
                }
                jsonMap["repeatedCord"] = jsonArrayRepeatedCord
            }
            if hasOneofUint32 {
                jsonMap["oneofUint32"] = UInt(oneofUint32)
            }
            if hasOneofNestedMessage {
                jsonMap["oneofNestedMessage"] = try oneofNestedMessage.encode()
            }
            if hasOneofString {
                jsonMap["oneofString"] = oneofString
            }
            if hasOneofBytes {
                jsonMap["oneofBytes"] = oneofBytes.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            if hasOneofEnum {
                jsonMap["oneofEnum"] = oneofEnum.toString()
            }
            if hasMapStringToMessage {
                var mapMapStringToMessage = Dictionary<String, Dictionary<String,Any>>()
                for (keyMapStringToMessage, valueMapStringToMessage) in mapStringToMessage {
                    mapMapStringToMessage["\(keyMapStringToMessage)"] = try valueMapStringToMessage.encode()
                }
                jsonMap["mapStringToMessage"] = mapMapStringToMessage
            }
            if hasMapInt32ToMessage {
                var mapMapInt32ToMessage = Dictionary<String, Dictionary<String,Any>>()
                for (keyMapInt32ToMessage, valueMapInt32ToMessage) in mapInt32ToMessage {
                    mapMapInt32ToMessage["\(keyMapInt32ToMessage)"] = try valueMapInt32ToMessage.encode()
                }
                jsonMap["mapInt32ToMessage"] = mapMapInt32ToMessage
            }
            if hasMapInt64ToMessage {
                var mapMapInt64ToMessage = Dictionary<String, Dictionary<String,Any>>()
                for (keyMapInt64ToMessage, valueMapInt64ToMessage) in mapInt64ToMessage {
                    mapMapInt64ToMessage["\(keyMapInt64ToMessage)"] = try valueMapInt64ToMessage.encode()
                }
                jsonMap["mapInt64ToMessage"] = mapMapInt64ToMessage
            }
            if hasMapBoolToMessage {
                var mapMapBoolToMessage = Dictionary<String, Dictionary<String,Any>>()
                for (keyMapBoolToMessage, valueMapBoolToMessage) in mapBoolToMessage {
                    mapMapBoolToMessage["\(keyMapBoolToMessage)"] = try valueMapBoolToMessage.encode()
                }
                jsonMap["mapBoolToMessage"] = mapMapBoolToMessage
            }
            if hasMapStringToInt64 {
                var mapMapStringToInt64 = Dictionary<String, String>()
                for (keyMapStringToInt64, valueMapStringToInt64) in mapStringToInt64 {
                    mapMapStringToInt64["\(keyMapStringToInt64)"] = "\(valueMapStringToInt64)"
                }
                jsonMap["mapStringToInt64"] = mapMapStringToInt64
            }
            if hasMapInt64ToString {
                var mapMapInt64ToString = Dictionary<String, String>()
                for (keyMapInt64ToString, valueMapInt64ToString) in mapInt64ToString {
                    mapMapInt64ToString["\(keyMapInt64ToString)"] = valueMapInt64ToString
                }
                jsonMap["mapInt64ToString"] = mapMapInt64ToString
            }
            if hasAnotherMapStringToMessage {
                var mapAnotherMapStringToMessage = Dictionary<String, Dictionary<String,Any>>()
                for (keyAnotherMapStringToMessage, valueAnotherMapStringToMessage) in anotherMapStringToMessage {
                    mapAnotherMapStringToMessage["\(keyAnotherMapStringToMessage)"] = try valueAnotherMapStringToMessage.encode()
                }
                jsonMap["anotherMapStringToMessage"] = mapAnotherMapStringToMessage
            }
            if !packedRepeatedInt64.isEmpty {
                var jsonArrayPackedRepeatedInt64:Array<String> = []
                for oneValuePackedRepeatedInt64 in packedRepeatedInt64 {
                    jsonArrayPackedRepeatedInt64.append("\(oneValuePackedRepeatedInt64)")
                }
                jsonMap["packedRepeatedInt64"] = jsonArrayPackedRepeatedInt64
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Test.TestAllTypes {
            return try Tensorflow.Test.TestAllTypes.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.Test.TestAllTypes {
            return try Tensorflow.Test.TestAllTypes.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasOptionalInt64 {
                output += "\(indent) optionalInt64: \(optionalInt64) \n"
            }
            if hasOptionalUint32 {
                output += "\(indent) optionalUint32: \(optionalUint32) \n"
            }
            if hasOptionalSint32 {
                output += "\(indent) optionalSint32: \(optionalSint32) \n"
            }
            if hasOptionalSint64 {
                output += "\(indent) optionalSint64: \(optionalSint64) \n"
            }
            if hasOptionalFixed32 {
                output += "\(indent) optionalFixed32: \(optionalFixed32) \n"
            }
            if hasOptionalFixed64 {
                output += "\(indent) optionalFixed64: \(optionalFixed64) \n"
            }
            if hasOptionalSfixed32 {
                output += "\(indent) optionalSfixed32: \(optionalSfixed32) \n"
            }
            if hasOptionalSfixed64 {
                output += "\(indent) optionalSfixed64: \(optionalSfixed64) \n"
            }
            if hasOptionalFloat {
                output += "\(indent) optionalFloat: \(optionalFloat) \n"
            }
            if hasOptionalDouble {
                output += "\(indent) optionalDouble: \(optionalDouble) \n"
            }
            if hasOptionalBool {
                output += "\(indent) optionalBool: \(optionalBool) \n"
            }
            if hasOptionalString {
                output += "\(indent) optionalString: \(optionalString) \n"
            }
            if hasOptionalBytes {
                output += "\(indent) optionalBytes: \(optionalBytes) \n"
            }
            if hasOptionalNestedMessage {
                output += "\(indent) optionalNestedMessage {\n"
                if let outDescOptionalNestedMessage = optionalNestedMessage {
                    output += try outDescOptionalNestedMessage.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasOptionalForeignMessage {
                output += "\(indent) optionalForeignMessage {\n"
                if let outDescOptionalForeignMessage = optionalForeignMessage {
                    output += try outDescOptionalForeignMessage.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if (hasOptionalNestedEnum) {
                output += "\(indent) optionalNestedEnum: \(optionalNestedEnum.description)\n"
            }
            if (hasOptionalForeignEnum) {
                output += "\(indent) optionalForeignEnum: \(optionalForeignEnum.description)\n"
            }
            if hasOptionalCord {
                output += "\(indent) optionalCord: \(optionalCord) \n"
            }
            var repeatedInt32ElementIndex:Int = 0
            for oneValueRepeatedInt32 in repeatedInt32  {
                output += "\(indent) repeatedInt32[\(repeatedInt32ElementIndex)]: \(oneValueRepeatedInt32)\n"
                repeatedInt32ElementIndex += 1
            }
            var repeatedInt64ElementIndex:Int = 0
            for oneValueRepeatedInt64 in repeatedInt64  {
                output += "\(indent) repeatedInt64[\(repeatedInt64ElementIndex)]: \(oneValueRepeatedInt64)\n"
                repeatedInt64ElementIndex += 1
            }
            var repeatedUint32ElementIndex:Int = 0
            for oneValueRepeatedUint32 in repeatedUint32  {
                output += "\(indent) repeatedUint32[\(repeatedUint32ElementIndex)]: \(oneValueRepeatedUint32)\n"
                repeatedUint32ElementIndex += 1
            }
            var repeatedUint64ElementIndex:Int = 0
            for oneValueRepeatedUint64 in repeatedUint64  {
                output += "\(indent) repeatedUint64[\(repeatedUint64ElementIndex)]: \(oneValueRepeatedUint64)\n"
                repeatedUint64ElementIndex += 1
            }
            var repeatedSint32ElementIndex:Int = 0
            for oneValueRepeatedSint32 in repeatedSint32  {
                output += "\(indent) repeatedSint32[\(repeatedSint32ElementIndex)]: \(oneValueRepeatedSint32)\n"
                repeatedSint32ElementIndex += 1
            }
            var repeatedSint64ElementIndex:Int = 0
            for oneValueRepeatedSint64 in repeatedSint64  {
                output += "\(indent) repeatedSint64[\(repeatedSint64ElementIndex)]: \(oneValueRepeatedSint64)\n"
                repeatedSint64ElementIndex += 1
            }
            var repeatedFixed32ElementIndex:Int = 0
            for oneValueRepeatedFixed32 in repeatedFixed32  {
                output += "\(indent) repeatedFixed32[\(repeatedFixed32ElementIndex)]: \(oneValueRepeatedFixed32)\n"
                repeatedFixed32ElementIndex += 1
            }
            var repeatedFixed64ElementIndex:Int = 0
            for oneValueRepeatedFixed64 in repeatedFixed64  {
                output += "\(indent) repeatedFixed64[\(repeatedFixed64ElementIndex)]: \(oneValueRepeatedFixed64)\n"
                repeatedFixed64ElementIndex += 1
            }
            var repeatedSfixed32ElementIndex:Int = 0
            for oneValueRepeatedSfixed32 in repeatedSfixed32  {
                output += "\(indent) repeatedSfixed32[\(repeatedSfixed32ElementIndex)]: \(oneValueRepeatedSfixed32)\n"
                repeatedSfixed32ElementIndex += 1
            }
            var repeatedSfixed64ElementIndex:Int = 0
            for oneValueRepeatedSfixed64 in repeatedSfixed64  {
                output += "\(indent) repeatedSfixed64[\(repeatedSfixed64ElementIndex)]: \(oneValueRepeatedSfixed64)\n"
                repeatedSfixed64ElementIndex += 1
            }
            var repeatedFloatElementIndex:Int = 0
            for oneValueRepeatedFloat in repeatedFloat  {
                output += "\(indent) repeatedFloat[\(repeatedFloatElementIndex)]: \(oneValueRepeatedFloat)\n"
                repeatedFloatElementIndex += 1
            }
            var repeatedDoubleElementIndex:Int = 0
            for oneValueRepeatedDouble in repeatedDouble  {
                output += "\(indent) repeatedDouble[\(repeatedDoubleElementIndex)]: \(oneValueRepeatedDouble)\n"
                repeatedDoubleElementIndex += 1
            }
            var repeatedBoolElementIndex:Int = 0
            for oneValueRepeatedBool in repeatedBool  {
                output += "\(indent) repeatedBool[\(repeatedBoolElementIndex)]: \(oneValueRepeatedBool)\n"
                repeatedBoolElementIndex += 1
            }
            var repeatedStringElementIndex:Int = 0
            for oneValueRepeatedString in repeatedString  {
                output += "\(indent) repeatedString[\(repeatedStringElementIndex)]: \(oneValueRepeatedString)\n"
                repeatedStringElementIndex += 1
            }
            var repeatedBytesElementIndex:Int = 0
            for oneValueRepeatedBytes in repeatedBytes  {
                output += "\(indent) repeatedBytes[\(repeatedBytesElementIndex)]: \(oneValueRepeatedBytes)\n"
                repeatedBytesElementIndex += 1
            }
            var repeatedNestedMessageElementIndex:Int = 0
            for oneElementRepeatedNestedMessage in repeatedNestedMessage {
                output += "\(indent) repeatedNestedMessage[\(repeatedNestedMessageElementIndex)] {\n"
                output += try oneElementRepeatedNestedMessage.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                repeatedNestedMessageElementIndex += 1
            }
            var repeatedNestedEnumElementIndex:Int = 0
            for oneValueOfrepeatedNestedEnum in repeatedNestedEnum {
                output += "\(indent) repeatedNestedEnum[\(repeatedNestedEnumElementIndex)]: \(oneValueOfrepeatedNestedEnum.description)\n"
                repeatedNestedEnumElementIndex += 1
            }
            var repeatedCordElementIndex:Int = 0
            for oneValueRepeatedCord in repeatedCord  {
                output += "\(indent) repeatedCord[\(repeatedCordElementIndex)]: \(oneValueRepeatedCord)\n"
                repeatedCordElementIndex += 1
            }
            if hasMapStringToMessage {
                output += "\(indent) mapStringToMessage: \(mapStringToMessage) \n"
            }
            if hasMapInt32ToMessage {
                output += "\(indent) mapInt32ToMessage: \(mapInt32ToMessage) \n"
            }
            if hasMapInt64ToMessage {
                output += "\(indent) mapInt64ToMessage: \(mapInt64ToMessage) \n"
            }
            if hasMapBoolToMessage {
                output += "\(indent) mapBoolToMessage: \(mapBoolToMessage) \n"
            }
            if hasMapStringToInt64 {
                output += "\(indent) mapStringToInt64: \(mapStringToInt64) \n"
            }
            if hasMapInt64ToString {
                output += "\(indent) mapInt64ToString: \(mapInt64ToString) \n"
            }
            var packedRepeatedInt64ElementIndex:Int = 0
            for oneValuePackedRepeatedInt64 in packedRepeatedInt64  {
                output += "\(indent) packedRepeatedInt64[\(packedRepeatedInt64ElementIndex)]: \(oneValuePackedRepeatedInt64)\n"
                packedRepeatedInt64ElementIndex += 1
            }
            if hasAnotherMapStringToMessage {
                output += "\(indent) anotherMapStringToMessage: \(anotherMapStringToMessage) \n"
            }
            if (hasOneofEnum) {
                output += "\(indent) oneofEnum: \(oneofEnum.description)\n"
            }
            if hasOneofUint32 {
                output += "\(indent) oneofUint32: \(oneofUint32) \n"
            }
            if hasOneofNestedMessage {
                output += "\(indent) oneofNestedMessage {\n"
                if let outDescOneofNestedMessage = oneofNestedMessage {
                    output += try outDescOneofNestedMessage.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasOneofString {
                output += "\(indent) oneofString: \(oneofString) \n"
            }
            if hasOneofBytes {
                output += "\(indent) oneofBytes: \(oneofBytes) \n"
            }
            if hasOptionalUint64 {
                output += "\(indent) optionalUint64: \(optionalUint64) \n"
            }
            if hasOptionalInt32 {
                output += "\(indent) optionalInt32: \(optionalInt32) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasOptionalInt64 {
                    hashCode = (hashCode &* 31) &+ optionalInt64.hashValue
                }
                if hasOptionalUint32 {
                    hashCode = (hashCode &* 31) &+ optionalUint32.hashValue
                }
                if hasOptionalSint32 {
                    hashCode = (hashCode &* 31) &+ optionalSint32.hashValue
                }
                if hasOptionalSint64 {
                    hashCode = (hashCode &* 31) &+ optionalSint64.hashValue
                }
                if hasOptionalFixed32 {
                    hashCode = (hashCode &* 31) &+ optionalFixed32.hashValue
                }
                if hasOptionalFixed64 {
                    hashCode = (hashCode &* 31) &+ optionalFixed64.hashValue
                }
                if hasOptionalSfixed32 {
                    hashCode = (hashCode &* 31) &+ optionalSfixed32.hashValue
                }
                if hasOptionalSfixed64 {
                    hashCode = (hashCode &* 31) &+ optionalSfixed64.hashValue
                }
                if hasOptionalFloat {
                    hashCode = (hashCode &* 31) &+ optionalFloat.hashValue
                }
                if hasOptionalDouble {
                    hashCode = (hashCode &* 31) &+ optionalDouble.hashValue
                }
                if hasOptionalBool {
                    hashCode = (hashCode &* 31) &+ optionalBool.hashValue
                }
                if hasOptionalString {
                    hashCode = (hashCode &* 31) &+ optionalString.hashValue
                }
                if hasOptionalBytes {
                    hashCode = (hashCode &* 31) &+ optionalBytes.hashValue
                }
                if hasOptionalNestedMessage {
                    if let hashValueoptionalNestedMessage = optionalNestedMessage?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoptionalNestedMessage
                    }
                }
                if hasOptionalForeignMessage {
                    if let hashValueoptionalForeignMessage = optionalForeignMessage?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoptionalForeignMessage
                    }
                }
                if hasOptionalNestedEnum {
                     hashCode = (hashCode &* 31) &+ optionalNestedEnum.hashValue
                }
                if hasOptionalForeignEnum {
                     hashCode = (hashCode &* 31) &+ optionalForeignEnum.hashValue
                }
                if hasOptionalCord {
                    hashCode = (hashCode &* 31) &+ optionalCord.hashValue
                }
                for oneValueRepeatedInt32 in repeatedInt32 {
                    hashCode = (hashCode &* 31) &+ oneValueRepeatedInt32.hashValue
                }
                for oneValueRepeatedInt64 in repeatedInt64 {
                    hashCode = (hashCode &* 31) &+ oneValueRepeatedInt64.hashValue
                }
                for oneValueRepeatedUint32 in repeatedUint32 {
                    hashCode = (hashCode &* 31) &+ oneValueRepeatedUint32.hashValue
                }
                for oneValueRepeatedUint64 in repeatedUint64 {
                    hashCode = (hashCode &* 31) &+ oneValueRepeatedUint64.hashValue
                }
                for oneValueRepeatedSint32 in repeatedSint32 {
                    hashCode = (hashCode &* 31) &+ oneValueRepeatedSint32.hashValue
                }
                for oneValueRepeatedSint64 in repeatedSint64 {
                    hashCode = (hashCode &* 31) &+ oneValueRepeatedSint64.hashValue
                }
                for oneValueRepeatedFixed32 in repeatedFixed32 {
                    hashCode = (hashCode &* 31) &+ oneValueRepeatedFixed32.hashValue
                }
                for oneValueRepeatedFixed64 in repeatedFixed64 {
                    hashCode = (hashCode &* 31) &+ oneValueRepeatedFixed64.hashValue
                }
                for oneValueRepeatedSfixed32 in repeatedSfixed32 {
                    hashCode = (hashCode &* 31) &+ oneValueRepeatedSfixed32.hashValue
                }
                for oneValueRepeatedSfixed64 in repeatedSfixed64 {
                    hashCode = (hashCode &* 31) &+ oneValueRepeatedSfixed64.hashValue
                }
                for oneValueRepeatedFloat in repeatedFloat {
                    hashCode = (hashCode &* 31) &+ oneValueRepeatedFloat.hashValue
                }
                for oneValueRepeatedDouble in repeatedDouble {
                    hashCode = (hashCode &* 31) &+ oneValueRepeatedDouble.hashValue
                }
                for oneValueRepeatedBool in repeatedBool {
                    hashCode = (hashCode &* 31) &+ oneValueRepeatedBool.hashValue
                }
                for oneValueRepeatedString in repeatedString {
                    hashCode = (hashCode &* 31) &+ oneValueRepeatedString.hashValue
                }
                for oneValueRepeatedBytes in repeatedBytes {
                    hashCode = (hashCode &* 31) &+ oneValueRepeatedBytes.hashValue
                }
                for oneElementRepeatedNestedMessage in repeatedNestedMessage {
                    hashCode = (hashCode &* 31) &+ oneElementRepeatedNestedMessage.hashValue
                }
                for oneValueOfrepeatedNestedEnum in repeatedNestedEnum {
                    hashCode = (hashCode &* 31) &+ oneValueOfrepeatedNestedEnum.hashValue
                }
                for oneValueRepeatedCord in repeatedCord {
                    hashCode = (hashCode &* 31) &+ oneValueRepeatedCord.hashValue
                }
                if hasMapStringToMessage {
                    for (keyMapStringToMessage, valueMapStringToMessage) in mapStringToMessage {
                        hashCode = (hashCode &* 31) &+ keyMapStringToMessage.hashValue
                        hashCode = (hashCode &* 31) &+ valueMapStringToMessage.hashValue
                    }
                }
                if hasMapInt32ToMessage {
                    for (keyMapInt32ToMessage, valueMapInt32ToMessage) in mapInt32ToMessage {
                        hashCode = (hashCode &* 31) &+ keyMapInt32ToMessage.hashValue
                        hashCode = (hashCode &* 31) &+ valueMapInt32ToMessage.hashValue
                    }
                }
                if hasMapInt64ToMessage {
                    for (keyMapInt64ToMessage, valueMapInt64ToMessage) in mapInt64ToMessage {
                        hashCode = (hashCode &* 31) &+ keyMapInt64ToMessage.hashValue
                        hashCode = (hashCode &* 31) &+ valueMapInt64ToMessage.hashValue
                    }
                }
                if hasMapBoolToMessage {
                    for (keyMapBoolToMessage, valueMapBoolToMessage) in mapBoolToMessage {
                        hashCode = (hashCode &* 31) &+ keyMapBoolToMessage.hashValue
                        hashCode = (hashCode &* 31) &+ valueMapBoolToMessage.hashValue
                    }
                }
                if hasMapStringToInt64 {
                    for (keyMapStringToInt64, valueMapStringToInt64) in mapStringToInt64 {
                        hashCode = (hashCode &* 31) &+ keyMapStringToInt64.hashValue
                        hashCode = (hashCode &* 31) &+ valueMapStringToInt64.hashValue
                    }
                }
                if hasMapInt64ToString {
                    for (keyMapInt64ToString, valueMapInt64ToString) in mapInt64ToString {
                        hashCode = (hashCode &* 31) &+ keyMapInt64ToString.hashValue
                        hashCode = (hashCode &* 31) &+ valueMapInt64ToString.hashValue
                    }
                }
                for oneValuePackedRepeatedInt64 in packedRepeatedInt64 {
                    hashCode = (hashCode &* 31) &+ oneValuePackedRepeatedInt64.hashValue
                }
                if hasAnotherMapStringToMessage {
                    for (keyAnotherMapStringToMessage, valueAnotherMapStringToMessage) in anotherMapStringToMessage {
                        hashCode = (hashCode &* 31) &+ keyAnotherMapStringToMessage.hashValue
                        hashCode = (hashCode &* 31) &+ valueAnotherMapStringToMessage.hashValue
                    }
                }
                if hasOneofEnum {
                     hashCode = (hashCode &* 31) &+ oneofEnum.hashValue
                }
                if hasOneofUint32 {
                    hashCode = (hashCode &* 31) &+ oneofUint32.hashValue
                }
                if hasOneofNestedMessage {
                    if let hashValueoneofNestedMessage = oneofNestedMessage?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoneofNestedMessage
                    }
                }
                if hasOneofString {
                    hashCode = (hashCode &* 31) &+ oneofString.hashValue
                }
                if hasOneofBytes {
                    hashCode = (hashCode &* 31) &+ oneofBytes.hashValue
                }
                if hasOptionalUint64 {
                    hashCode = (hashCode &* 31) &+ optionalUint64.hashValue
                }
                if hasOptionalInt32 {
                    hashCode = (hashCode &* 31) &+ optionalInt32.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.Test.TestAllTypes"
        }
        override public func className() -> String {
            return "Tensorflow.Test.TestAllTypes"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.Test.TestAllTypes = Tensorflow.Test.TestAllTypes()
            public func getMessage() -> Tensorflow.Test.TestAllTypes {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Singular
            public var optionalInt32:Int32 {
                get {
                    return builderResult.optionalInt32
                }
                set (value) {
                    builderResult.hasOptionalInt32 = true
                    builderResult.optionalInt32 = value
                }
            }
            public var hasOptionalInt32:Bool {
                get {
                    return builderResult.hasOptionalInt32
                }
            }
            @discardableResult
            public func setOptionalInt32(_ value:Int32) -> Tensorflow.Test.TestAllTypes.Builder {
                self.optionalInt32 = value
                return self
            }
            @discardableResult
            public func clearOptionalInt32() -> Tensorflow.Test.TestAllTypes.Builder{
                builderResult.hasOptionalInt32 = false
                builderResult.optionalInt32 = Int32(0)
                return self
            }
            public var optionalInt64:Int64 {
                get {
                    return builderResult.optionalInt64
                }
                set (value) {
                    builderResult.hasOptionalInt64 = true
                    builderResult.optionalInt64 = value
                }
            }
            public var hasOptionalInt64:Bool {
                get {
                    return builderResult.hasOptionalInt64
                }
            }
            @discardableResult
            public func setOptionalInt64(_ value:Int64) -> Tensorflow.Test.TestAllTypes.Builder {
                self.optionalInt64 = value
                return self
            }
            @discardableResult
            public func clearOptionalInt64() -> Tensorflow.Test.TestAllTypes.Builder{
                builderResult.hasOptionalInt64 = false
                builderResult.optionalInt64 = Int64(0)
                return self
            }
            public var optionalUint32:UInt32 {
                get {
                    return builderResult.optionalUint32
                }
                set (value) {
                    builderResult.hasOptionalUint32 = true
                    builderResult.optionalUint32 = value
                }
            }
            public var hasOptionalUint32:Bool {
                get {
                    return builderResult.hasOptionalUint32
                }
            }
            @discardableResult
            public func setOptionalUint32(_ value:UInt32) -> Tensorflow.Test.TestAllTypes.Builder {
                self.optionalUint32 = value
                return self
            }
            @discardableResult
            public func clearOptionalUint32() -> Tensorflow.Test.TestAllTypes.Builder{
                builderResult.hasOptionalUint32 = false
                builderResult.optionalUint32 = UInt32(0)
                return self
            }
            /// use large tag to test output order.
            public var optionalUint64:UInt64 {
                get {
                    return builderResult.optionalUint64
                }
                set (value) {
                    builderResult.hasOptionalUint64 = true
                    builderResult.optionalUint64 = value
                }
            }
            public var hasOptionalUint64:Bool {
                get {
                    return builderResult.hasOptionalUint64
                }
            }
            @discardableResult
            public func setOptionalUint64(_ value:UInt64) -> Tensorflow.Test.TestAllTypes.Builder {
                self.optionalUint64 = value
                return self
            }
            @discardableResult
            public func clearOptionalUint64() -> Tensorflow.Test.TestAllTypes.Builder{
                builderResult.hasOptionalUint64 = false
                builderResult.optionalUint64 = UInt64(0)
                return self
            }
            public var optionalSint32:Int32 {
                get {
                    return builderResult.optionalSint32
                }
                set (value) {
                    builderResult.hasOptionalSint32 = true
                    builderResult.optionalSint32 = value
                }
            }
            public var hasOptionalSint32:Bool {
                get {
                    return builderResult.hasOptionalSint32
                }
            }
            @discardableResult
            public func setOptionalSint32(_ value:Int32) -> Tensorflow.Test.TestAllTypes.Builder {
                self.optionalSint32 = value
                return self
            }
            @discardableResult
            public func clearOptionalSint32() -> Tensorflow.Test.TestAllTypes.Builder{
                builderResult.hasOptionalSint32 = false
                builderResult.optionalSint32 = Int32(0)
                return self
            }
            public var optionalSint64:Int64 {
                get {
                    return builderResult.optionalSint64
                }
                set (value) {
                    builderResult.hasOptionalSint64 = true
                    builderResult.optionalSint64 = value
                }
            }
            public var hasOptionalSint64:Bool {
                get {
                    return builderResult.hasOptionalSint64
                }
            }
            @discardableResult
            public func setOptionalSint64(_ value:Int64) -> Tensorflow.Test.TestAllTypes.Builder {
                self.optionalSint64 = value
                return self
            }
            @discardableResult
            public func clearOptionalSint64() -> Tensorflow.Test.TestAllTypes.Builder{
                builderResult.hasOptionalSint64 = false
                builderResult.optionalSint64 = Int64(0)
                return self
            }
            public var optionalFixed32:UInt32 {
                get {
                    return builderResult.optionalFixed32
                }
                set (value) {
                    builderResult.hasOptionalFixed32 = true
                    builderResult.optionalFixed32 = value
                }
            }
            public var hasOptionalFixed32:Bool {
                get {
                    return builderResult.hasOptionalFixed32
                }
            }
            @discardableResult
            public func setOptionalFixed32(_ value:UInt32) -> Tensorflow.Test.TestAllTypes.Builder {
                self.optionalFixed32 = value
                return self
            }
            @discardableResult
            public func clearOptionalFixed32() -> Tensorflow.Test.TestAllTypes.Builder{
                builderResult.hasOptionalFixed32 = false
                builderResult.optionalFixed32 = UInt32(0)
                return self
            }
            public var optionalFixed64:UInt64 {
                get {
                    return builderResult.optionalFixed64
                }
                set (value) {
                    builderResult.hasOptionalFixed64 = true
                    builderResult.optionalFixed64 = value
                }
            }
            public var hasOptionalFixed64:Bool {
                get {
                    return builderResult.hasOptionalFixed64
                }
            }
            @discardableResult
            public func setOptionalFixed64(_ value:UInt64) -> Tensorflow.Test.TestAllTypes.Builder {
                self.optionalFixed64 = value
                return self
            }
            @discardableResult
            public func clearOptionalFixed64() -> Tensorflow.Test.TestAllTypes.Builder{
                builderResult.hasOptionalFixed64 = false
                builderResult.optionalFixed64 = UInt64(0)
                return self
            }
            public var optionalSfixed32:Int32 {
                get {
                    return builderResult.optionalSfixed32
                }
                set (value) {
                    builderResult.hasOptionalSfixed32 = true
                    builderResult.optionalSfixed32 = value
                }
            }
            public var hasOptionalSfixed32:Bool {
                get {
                    return builderResult.hasOptionalSfixed32
                }
            }
            @discardableResult
            public func setOptionalSfixed32(_ value:Int32) -> Tensorflow.Test.TestAllTypes.Builder {
                self.optionalSfixed32 = value
                return self
            }
            @discardableResult
            public func clearOptionalSfixed32() -> Tensorflow.Test.TestAllTypes.Builder{
                builderResult.hasOptionalSfixed32 = false
                builderResult.optionalSfixed32 = Int32(0)
                return self
            }
            public var optionalSfixed64:Int64 {
                get {
                    return builderResult.optionalSfixed64
                }
                set (value) {
                    builderResult.hasOptionalSfixed64 = true
                    builderResult.optionalSfixed64 = value
                }
            }
            public var hasOptionalSfixed64:Bool {
                get {
                    return builderResult.hasOptionalSfixed64
                }
            }
            @discardableResult
            public func setOptionalSfixed64(_ value:Int64) -> Tensorflow.Test.TestAllTypes.Builder {
                self.optionalSfixed64 = value
                return self
            }
            @discardableResult
            public func clearOptionalSfixed64() -> Tensorflow.Test.TestAllTypes.Builder{
                builderResult.hasOptionalSfixed64 = false
                builderResult.optionalSfixed64 = Int64(0)
                return self
            }
            public var optionalFloat:Float {
                get {
                    return builderResult.optionalFloat
                }
                set (value) {
                    builderResult.hasOptionalFloat = true
                    builderResult.optionalFloat = value
                }
            }
            public var hasOptionalFloat:Bool {
                get {
                    return builderResult.hasOptionalFloat
                }
            }
            @discardableResult
            public func setOptionalFloat(_ value:Float) -> Tensorflow.Test.TestAllTypes.Builder {
                self.optionalFloat = value
                return self
            }
            @discardableResult
            public func clearOptionalFloat() -> Tensorflow.Test.TestAllTypes.Builder{
                builderResult.hasOptionalFloat = false
                builderResult.optionalFloat = Float(0)
                return self
            }
            public var optionalDouble:Double {
                get {
                    return builderResult.optionalDouble
                }
                set (value) {
                    builderResult.hasOptionalDouble = true
                    builderResult.optionalDouble = value
                }
            }
            public var hasOptionalDouble:Bool {
                get {
                    return builderResult.hasOptionalDouble
                }
            }
            @discardableResult
            public func setOptionalDouble(_ value:Double) -> Tensorflow.Test.TestAllTypes.Builder {
                self.optionalDouble = value
                return self
            }
            @discardableResult
            public func clearOptionalDouble() -> Tensorflow.Test.TestAllTypes.Builder{
                builderResult.hasOptionalDouble = false
                builderResult.optionalDouble = Double(0)
                return self
            }
            public var optionalBool:Bool {
                get {
                    return builderResult.optionalBool
                }
                set (value) {
                    builderResult.hasOptionalBool = true
                    builderResult.optionalBool = value
                }
            }
            public var hasOptionalBool:Bool {
                get {
                    return builderResult.hasOptionalBool
                }
            }
            @discardableResult
            public func setOptionalBool(_ value:Bool) -> Tensorflow.Test.TestAllTypes.Builder {
                self.optionalBool = value
                return self
            }
            @discardableResult
            public func clearOptionalBool() -> Tensorflow.Test.TestAllTypes.Builder{
                builderResult.hasOptionalBool = false
                builderResult.optionalBool = false
                return self
            }
            public var optionalString:String {
                get {
                    return builderResult.optionalString
                }
                set (value) {
                    builderResult.hasOptionalString = true
                    builderResult.optionalString = value
                }
            }
            public var hasOptionalString:Bool {
                get {
                    return builderResult.hasOptionalString
                }
            }
            @discardableResult
            public func setOptionalString(_ value:String) -> Tensorflow.Test.TestAllTypes.Builder {
                self.optionalString = value
                return self
            }
            @discardableResult
            public func clearOptionalString() -> Tensorflow.Test.TestAllTypes.Builder{
                builderResult.hasOptionalString = false
                builderResult.optionalString = ""
                return self
            }
            public var optionalBytes:Data {
                get {
                    return builderResult.optionalBytes
                }
                set (value) {
                    builderResult.hasOptionalBytes = true
                    builderResult.optionalBytes = value
                }
            }
            public var hasOptionalBytes:Bool {
                get {
                    return builderResult.hasOptionalBytes
                }
            }
            @discardableResult
            public func setOptionalBytes(_ value:Data) -> Tensorflow.Test.TestAllTypes.Builder {
                self.optionalBytes = value
                return self
            }
            @discardableResult
            public func clearOptionalBytes() -> Tensorflow.Test.TestAllTypes.Builder{
                builderResult.hasOptionalBytes = false
                builderResult.optionalBytes = Data()
                return self
            }
            public var optionalNestedMessage:Tensorflow.Test.TestAllTypes.NestedMessage! {
                get {
                    if optionalNestedMessageBuilder_ != nil {
                        builderResult.optionalNestedMessage = optionalNestedMessageBuilder_.getMessage()
                    }
                    return builderResult.optionalNestedMessage
                }
                set (value) {
                    builderResult.hasOptionalNestedMessage = true
                    builderResult.optionalNestedMessage = value
                }
            }
            public var hasOptionalNestedMessage:Bool {
                get {
                    return builderResult.hasOptionalNestedMessage
                }
            }
            fileprivate var optionalNestedMessageBuilder_:Tensorflow.Test.TestAllTypes.NestedMessage.Builder! {
                didSet {
                    builderResult.hasOptionalNestedMessage = true
                }
            }
            public func getOptionalNestedMessageBuilder() -> Tensorflow.Test.TestAllTypes.NestedMessage.Builder {
                if optionalNestedMessageBuilder_ == nil {
                    optionalNestedMessageBuilder_ = Tensorflow.Test.TestAllTypes.NestedMessage.Builder()
                    builderResult.optionalNestedMessage = optionalNestedMessageBuilder_.getMessage()
                    if optionalNestedMessage != nil {
                        try! optionalNestedMessageBuilder_.mergeFrom(other: optionalNestedMessage)
                    }
                }
                return optionalNestedMessageBuilder_
            }
            @discardableResult
            public func setOptionalNestedMessage(_ value:Tensorflow.Test.TestAllTypes.NestedMessage!) -> Tensorflow.Test.TestAllTypes.Builder {
                self.optionalNestedMessage = value
                return self
            }
            @discardableResult
            public func mergeOptionalNestedMessage(value:Tensorflow.Test.TestAllTypes.NestedMessage) throws -> Tensorflow.Test.TestAllTypes.Builder {
                if builderResult.hasOptionalNestedMessage {
                    builderResult.optionalNestedMessage = try Tensorflow.Test.TestAllTypes.NestedMessage.builderWithPrototype(prototype:builderResult.optionalNestedMessage).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.optionalNestedMessage = value
                }
                builderResult.hasOptionalNestedMessage = true
                return self
            }
            @discardableResult
            public func clearOptionalNestedMessage() -> Tensorflow.Test.TestAllTypes.Builder {
                optionalNestedMessageBuilder_ = nil
                builderResult.hasOptionalNestedMessage = false
                builderResult.optionalNestedMessage = nil
                return self
            }
            public var optionalForeignMessage:Tensorflow.Test.ForeignMessage! {
                get {
                    if optionalForeignMessageBuilder_ != nil {
                        builderResult.optionalForeignMessage = optionalForeignMessageBuilder_.getMessage()
                    }
                    return builderResult.optionalForeignMessage
                }
                set (value) {
                    builderResult.hasOptionalForeignMessage = true
                    builderResult.optionalForeignMessage = value
                }
            }
            public var hasOptionalForeignMessage:Bool {
                get {
                    return builderResult.hasOptionalForeignMessage
                }
            }
            fileprivate var optionalForeignMessageBuilder_:Tensorflow.Test.ForeignMessage.Builder! {
                didSet {
                    builderResult.hasOptionalForeignMessage = true
                }
            }
            public func getOptionalForeignMessageBuilder() -> Tensorflow.Test.ForeignMessage.Builder {
                if optionalForeignMessageBuilder_ == nil {
                    optionalForeignMessageBuilder_ = Tensorflow.Test.ForeignMessage.Builder()
                    builderResult.optionalForeignMessage = optionalForeignMessageBuilder_.getMessage()
                    if optionalForeignMessage != nil {
                        try! optionalForeignMessageBuilder_.mergeFrom(other: optionalForeignMessage)
                    }
                }
                return optionalForeignMessageBuilder_
            }
            @discardableResult
            public func setOptionalForeignMessage(_ value:Tensorflow.Test.ForeignMessage!) -> Tensorflow.Test.TestAllTypes.Builder {
                self.optionalForeignMessage = value
                return self
            }
            @discardableResult
            public func mergeOptionalForeignMessage(value:Tensorflow.Test.ForeignMessage) throws -> Tensorflow.Test.TestAllTypes.Builder {
                if builderResult.hasOptionalForeignMessage {
                    builderResult.optionalForeignMessage = try Tensorflow.Test.ForeignMessage.builderWithPrototype(prototype:builderResult.optionalForeignMessage).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.optionalForeignMessage = value
                }
                builderResult.hasOptionalForeignMessage = true
                return self
            }
            @discardableResult
            public func clearOptionalForeignMessage() -> Tensorflow.Test.TestAllTypes.Builder {
                optionalForeignMessageBuilder_ = nil
                builderResult.hasOptionalForeignMessage = false
                builderResult.optionalForeignMessage = nil
                return self
            }
                public var optionalNestedEnum:Tensorflow.Test.TestAllTypes.NestedEnum {
                    get {
                        return builderResult.optionalNestedEnum
                    }
                    set (value) {
                        builderResult.hasOptionalNestedEnum = true
                        builderResult.optionalNestedEnum = value
                    }
                }
                public var hasOptionalNestedEnum:Bool{
                    get {
                        return builderResult.hasOptionalNestedEnum
                    }
                }
            @discardableResult
                public func setOptionalNestedEnum(_ value:Tensorflow.Test.TestAllTypes.NestedEnum) -> Tensorflow.Test.TestAllTypes.Builder {
                  self.optionalNestedEnum = value
                  return self
                }
            @discardableResult
                public func clearOptionalNestedEnum() -> Tensorflow.Test.TestAllTypes.Builder {
                   builderResult.hasOptionalNestedEnum = false
                   builderResult.optionalNestedEnum = .zero
                   return self
                }
                public var optionalForeignEnum:Tensorflow.Test.ForeignEnum {
                    get {
                        return builderResult.optionalForeignEnum
                    }
                    set (value) {
                        builderResult.hasOptionalForeignEnum = true
                        builderResult.optionalForeignEnum = value
                    }
                }
                public var hasOptionalForeignEnum:Bool{
                    get {
                        return builderResult.hasOptionalForeignEnum
                    }
                }
            @discardableResult
                public func setOptionalForeignEnum(_ value:Tensorflow.Test.ForeignEnum) -> Tensorflow.Test.TestAllTypes.Builder {
                  self.optionalForeignEnum = value
                  return self
                }
            @discardableResult
                public func clearOptionalForeignEnum() -> Tensorflow.Test.TestAllTypes.Builder {
                   builderResult.hasOptionalForeignEnum = false
                   builderResult.optionalForeignEnum = .foreignZero
                   return self
                }
            public var optionalCord:String {
                get {
                    return builderResult.optionalCord
                }
                set (value) {
                    builderResult.hasOptionalCord = true
                    builderResult.optionalCord = value
                }
            }
            public var hasOptionalCord:Bool {
                get {
                    return builderResult.hasOptionalCord
                }
            }
            @discardableResult
            public func setOptionalCord(_ value:String) -> Tensorflow.Test.TestAllTypes.Builder {
                self.optionalCord = value
                return self
            }
            @discardableResult
            public func clearOptionalCord() -> Tensorflow.Test.TestAllTypes.Builder{
                builderResult.hasOptionalCord = false
                builderResult.optionalCord = ""
                return self
            }
            /// Repeated
            public var repeatedInt32:Array<Int32> {
                get {
                    return builderResult.repeatedInt32
                }
                set (array) {
                    builderResult.repeatedInt32 = array
                }
            }
            @discardableResult
            public func setRepeatedInt32(_ value:Array<Int32>) -> Tensorflow.Test.TestAllTypes.Builder {
                self.repeatedInt32 = value
                return self
            }
            @discardableResult
            public func clearRepeatedInt32() -> Tensorflow.Test.TestAllTypes.Builder {
                builderResult.repeatedInt32.removeAll(keepingCapacity: false)
                return self
            }
            public var repeatedInt64:Array<Int64> {
                get {
                    return builderResult.repeatedInt64
                }
                set (array) {
                    builderResult.repeatedInt64 = array
                }
            }
            @discardableResult
            public func setRepeatedInt64(_ value:Array<Int64>) -> Tensorflow.Test.TestAllTypes.Builder {
                self.repeatedInt64 = value
                return self
            }
            @discardableResult
            public func clearRepeatedInt64() -> Tensorflow.Test.TestAllTypes.Builder {
                builderResult.repeatedInt64.removeAll(keepingCapacity: false)
                return self
            }
            public var repeatedUint32:Array<UInt32> {
                get {
                    return builderResult.repeatedUint32
                }
                set (array) {
                    builderResult.repeatedUint32 = array
                }
            }
            @discardableResult
            public func setRepeatedUint32(_ value:Array<UInt32>) -> Tensorflow.Test.TestAllTypes.Builder {
                self.repeatedUint32 = value
                return self
            }
            @discardableResult
            public func clearRepeatedUint32() -> Tensorflow.Test.TestAllTypes.Builder {
                builderResult.repeatedUint32.removeAll(keepingCapacity: false)
                return self
            }
            public var repeatedUint64:Array<UInt64> {
                get {
                    return builderResult.repeatedUint64
                }
                set (array) {
                    builderResult.repeatedUint64 = array
                }
            }
            @discardableResult
            public func setRepeatedUint64(_ value:Array<UInt64>) -> Tensorflow.Test.TestAllTypes.Builder {
                self.repeatedUint64 = value
                return self
            }
            @discardableResult
            public func clearRepeatedUint64() -> Tensorflow.Test.TestAllTypes.Builder {
                builderResult.repeatedUint64.removeAll(keepingCapacity: false)
                return self
            }
            public var repeatedSint32:Array<Int32> {
                get {
                    return builderResult.repeatedSint32
                }
                set (array) {
                    builderResult.repeatedSint32 = array
                }
            }
            @discardableResult
            public func setRepeatedSint32(_ value:Array<Int32>) -> Tensorflow.Test.TestAllTypes.Builder {
                self.repeatedSint32 = value
                return self
            }
            @discardableResult
            public func clearRepeatedSint32() -> Tensorflow.Test.TestAllTypes.Builder {
                builderResult.repeatedSint32.removeAll(keepingCapacity: false)
                return self
            }
            public var repeatedSint64:Array<Int64> {
                get {
                    return builderResult.repeatedSint64
                }
                set (array) {
                    builderResult.repeatedSint64 = array
                }
            }
            @discardableResult
            public func setRepeatedSint64(_ value:Array<Int64>) -> Tensorflow.Test.TestAllTypes.Builder {
                self.repeatedSint64 = value
                return self
            }
            @discardableResult
            public func clearRepeatedSint64() -> Tensorflow.Test.TestAllTypes.Builder {
                builderResult.repeatedSint64.removeAll(keepingCapacity: false)
                return self
            }
            public var repeatedFixed32:Array<UInt32> {
                get {
                    return builderResult.repeatedFixed32
                }
                set (array) {
                    builderResult.repeatedFixed32 = array
                }
            }
            @discardableResult
            public func setRepeatedFixed32(_ value:Array<UInt32>) -> Tensorflow.Test.TestAllTypes.Builder {
                self.repeatedFixed32 = value
                return self
            }
            @discardableResult
            public func clearRepeatedFixed32() -> Tensorflow.Test.TestAllTypes.Builder {
                builderResult.repeatedFixed32.removeAll(keepingCapacity: false)
                return self
            }
            public var repeatedFixed64:Array<UInt64> {
                get {
                    return builderResult.repeatedFixed64
                }
                set (array) {
                    builderResult.repeatedFixed64 = array
                }
            }
            @discardableResult
            public func setRepeatedFixed64(_ value:Array<UInt64>) -> Tensorflow.Test.TestAllTypes.Builder {
                self.repeatedFixed64 = value
                return self
            }
            @discardableResult
            public func clearRepeatedFixed64() -> Tensorflow.Test.TestAllTypes.Builder {
                builderResult.repeatedFixed64.removeAll(keepingCapacity: false)
                return self
            }
            public var repeatedSfixed32:Array<Int32> {
                get {
                    return builderResult.repeatedSfixed32
                }
                set (array) {
                    builderResult.repeatedSfixed32 = array
                }
            }
            @discardableResult
            public func setRepeatedSfixed32(_ value:Array<Int32>) -> Tensorflow.Test.TestAllTypes.Builder {
                self.repeatedSfixed32 = value
                return self
            }
            @discardableResult
            public func clearRepeatedSfixed32() -> Tensorflow.Test.TestAllTypes.Builder {
                builderResult.repeatedSfixed32.removeAll(keepingCapacity: false)
                return self
            }
            public var repeatedSfixed64:Array<Int64> {
                get {
                    return builderResult.repeatedSfixed64
                }
                set (array) {
                    builderResult.repeatedSfixed64 = array
                }
            }
            @discardableResult
            public func setRepeatedSfixed64(_ value:Array<Int64>) -> Tensorflow.Test.TestAllTypes.Builder {
                self.repeatedSfixed64 = value
                return self
            }
            @discardableResult
            public func clearRepeatedSfixed64() -> Tensorflow.Test.TestAllTypes.Builder {
                builderResult.repeatedSfixed64.removeAll(keepingCapacity: false)
                return self
            }
            public var repeatedFloat:Array<Float> {
                get {
                    return builderResult.repeatedFloat
                }
                set (array) {
                    builderResult.repeatedFloat = array
                }
            }
            @discardableResult
            public func setRepeatedFloat(_ value:Array<Float>) -> Tensorflow.Test.TestAllTypes.Builder {
                self.repeatedFloat = value
                return self
            }
            @discardableResult
            public func clearRepeatedFloat() -> Tensorflow.Test.TestAllTypes.Builder {
                builderResult.repeatedFloat.removeAll(keepingCapacity: false)
                return self
            }
            public var repeatedDouble:Array<Double> {
                get {
                    return builderResult.repeatedDouble
                }
                set (array) {
                    builderResult.repeatedDouble = array
                }
            }
            @discardableResult
            public func setRepeatedDouble(_ value:Array<Double>) -> Tensorflow.Test.TestAllTypes.Builder {
                self.repeatedDouble = value
                return self
            }
            @discardableResult
            public func clearRepeatedDouble() -> Tensorflow.Test.TestAllTypes.Builder {
                builderResult.repeatedDouble.removeAll(keepingCapacity: false)
                return self
            }
            public var repeatedBool:Array<Bool> {
                get {
                    return builderResult.repeatedBool
                }
                set (array) {
                    builderResult.repeatedBool = array
                }
            }
            @discardableResult
            public func setRepeatedBool(_ value:Array<Bool>) -> Tensorflow.Test.TestAllTypes.Builder {
                self.repeatedBool = value
                return self
            }
            @discardableResult
            public func clearRepeatedBool() -> Tensorflow.Test.TestAllTypes.Builder {
                builderResult.repeatedBool.removeAll(keepingCapacity: false)
                return self
            }
            public var repeatedString:Array<String> {
                get {
                    return builderResult.repeatedString
                }
                set (array) {
                    builderResult.repeatedString = array
                }
            }
            @discardableResult
            public func setRepeatedString(_ value:Array<String>) -> Tensorflow.Test.TestAllTypes.Builder {
                self.repeatedString = value
                return self
            }
            @discardableResult
            public func clearRepeatedString() -> Tensorflow.Test.TestAllTypes.Builder {
                builderResult.repeatedString.removeAll(keepingCapacity: false)
                return self
            }
            public var repeatedBytes:Array<Data> {
                get {
                    return builderResult.repeatedBytes
                }
                set (array) {
                    builderResult.repeatedBytes = array
                }
            }
            @discardableResult
            public func setRepeatedBytes(_ value:Array<Data>) -> Tensorflow.Test.TestAllTypes.Builder {
                self.repeatedBytes = value
                return self
            }
            @discardableResult
            public func clearRepeatedBytes() -> Tensorflow.Test.TestAllTypes.Builder {
                builderResult.repeatedBytes.removeAll(keepingCapacity: false)
                return self
            }
            public var repeatedNestedMessage:Array<Tensorflow.Test.TestAllTypes.NestedMessage> {
                get {
                    return builderResult.repeatedNestedMessage
                }
                set (value) {
                    builderResult.repeatedNestedMessage = value
                }
            }
            @discardableResult
            public func setRepeatedNestedMessage(_ value:Array<Tensorflow.Test.TestAllTypes.NestedMessage>) -> Tensorflow.Test.TestAllTypes.Builder {
                self.repeatedNestedMessage = value
                return self
            }
            @discardableResult
            public func clearRepeatedNestedMessage() -> Tensorflow.Test.TestAllTypes.Builder {
                builderResult.repeatedNestedMessage.removeAll(keepingCapacity: false)
                return self
            }
            public var repeatedNestedEnum:Array<Tensorflow.Test.TestAllTypes.NestedEnum> {
                get {
                    return builderResult.repeatedNestedEnum
                }
                set (value) {
                    builderResult.repeatedNestedEnum = value
                }
            }
            @discardableResult
            public func setRepeatedNestedEnum(_ value:Array<Tensorflow.Test.TestAllTypes.NestedEnum>) -> Tensorflow.Test.TestAllTypes.Builder {
                self.repeatedNestedEnum = value
                return self
            }
            @discardableResult
            public func clearRepeatedNestedEnum() -> Tensorflow.Test.TestAllTypes.Builder {
                builderResult.repeatedNestedEnum.removeAll(keepingCapacity: false)
                return self
            }
            public var repeatedCord:Array<String> {
                get {
                    return builderResult.repeatedCord
                }
                set (array) {
                    builderResult.repeatedCord = array
                }
            }
            @discardableResult
            public func setRepeatedCord(_ value:Array<String>) -> Tensorflow.Test.TestAllTypes.Builder {
                self.repeatedCord = value
                return self
            }
            @discardableResult
            public func clearRepeatedCord() -> Tensorflow.Test.TestAllTypes.Builder {
                builderResult.repeatedCord.removeAll(keepingCapacity: false)
                return self
            }
            public var oneofUint32:UInt32 {
                get {
                    return builderResult.oneofUint32
                }
                set (value) {
                    builderResult.hasOneofUint32 = true
                    builderResult.oneofUint32 = value
                }
            }
            public var hasOneofUint32:Bool {
                get {
                    return builderResult.hasOneofUint32
                }
            }
            @discardableResult
            public func setOneofUint32(_ value:UInt32) -> Tensorflow.Test.TestAllTypes.Builder {
                self.oneofUint32 = value
                return self
            }
            @discardableResult
            public func clearOneofUint32() -> Tensorflow.Test.TestAllTypes.Builder{
                builderResult.hasOneofUint32 = false
                builderResult.oneofUint32 = UInt32(0)
                return self
            }
            public var oneofNestedMessage:Tensorflow.Test.TestAllTypes.NestedMessage! {
                get {
                    if oneofNestedMessageBuilder_ != nil {
                        builderResult.oneofNestedMessage = oneofNestedMessageBuilder_.getMessage()
                    }
                    return builderResult.oneofNestedMessage
                }
                set (value) {
                    builderResult.hasOneofNestedMessage = true
                    builderResult.oneofNestedMessage = value
                }
            }
            public var hasOneofNestedMessage:Bool {
                get {
                    return builderResult.hasOneofNestedMessage
                }
            }
            fileprivate var oneofNestedMessageBuilder_:Tensorflow.Test.TestAllTypes.NestedMessage.Builder! {
                didSet {
                    builderResult.hasOneofNestedMessage = true
                }
            }
            public func getOneofNestedMessageBuilder() -> Tensorflow.Test.TestAllTypes.NestedMessage.Builder {
                if oneofNestedMessageBuilder_ == nil {
                    oneofNestedMessageBuilder_ = Tensorflow.Test.TestAllTypes.NestedMessage.Builder()
                    builderResult.oneofNestedMessage = oneofNestedMessageBuilder_.getMessage()
                    if oneofNestedMessage != nil {
                        try! oneofNestedMessageBuilder_.mergeFrom(other: oneofNestedMessage)
                    }
                }
                return oneofNestedMessageBuilder_
            }
            @discardableResult
            public func setOneofNestedMessage(_ value:Tensorflow.Test.TestAllTypes.NestedMessage!) -> Tensorflow.Test.TestAllTypes.Builder {
                self.oneofNestedMessage = value
                return self
            }
            @discardableResult
            public func mergeOneofNestedMessage(value:Tensorflow.Test.TestAllTypes.NestedMessage) throws -> Tensorflow.Test.TestAllTypes.Builder {
                if builderResult.hasOneofNestedMessage {
                    builderResult.oneofNestedMessage = try Tensorflow.Test.TestAllTypes.NestedMessage.builderWithPrototype(prototype:builderResult.oneofNestedMessage).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.oneofNestedMessage = value
                }
                builderResult.hasOneofNestedMessage = true
                return self
            }
            @discardableResult
            public func clearOneofNestedMessage() -> Tensorflow.Test.TestAllTypes.Builder {
                oneofNestedMessageBuilder_ = nil
                builderResult.hasOneofNestedMessage = false
                builderResult.oneofNestedMessage = nil
                return self
            }
            public var oneofString:String {
                get {
                    return builderResult.oneofString
                }
                set (value) {
                    builderResult.hasOneofString = true
                    builderResult.oneofString = value
                }
            }
            public var hasOneofString:Bool {
                get {
                    return builderResult.hasOneofString
                }
            }
            @discardableResult
            public func setOneofString(_ value:String) -> Tensorflow.Test.TestAllTypes.Builder {
                self.oneofString = value
                return self
            }
            @discardableResult
            public func clearOneofString() -> Tensorflow.Test.TestAllTypes.Builder{
                builderResult.hasOneofString = false
                builderResult.oneofString = ""
                return self
            }
            public var oneofBytes:Data {
                get {
                    return builderResult.oneofBytes
                }
                set (value) {
                    builderResult.hasOneofBytes = true
                    builderResult.oneofBytes = value
                }
            }
            public var hasOneofBytes:Bool {
                get {
                    return builderResult.hasOneofBytes
                }
            }
            @discardableResult
            public func setOneofBytes(_ value:Data) -> Tensorflow.Test.TestAllTypes.Builder {
                self.oneofBytes = value
                return self
            }
            @discardableResult
            public func clearOneofBytes() -> Tensorflow.Test.TestAllTypes.Builder{
                builderResult.hasOneofBytes = false
                builderResult.oneofBytes = Data()
                return self
            }
                public var oneofEnum:Tensorflow.Test.TestAllTypes.NestedEnum {
                    get {
                        return builderResult.oneofEnum
                    }
                    set (value) {
                        builderResult.hasOneofEnum = true
                        builderResult.oneofEnum = value
                    }
                }
                public var hasOneofEnum:Bool{
                    get {
                        return builderResult.hasOneofEnum
                    }
                }
            @discardableResult
                public func setOneofEnum(_ value:Tensorflow.Test.TestAllTypes.NestedEnum) -> Tensorflow.Test.TestAllTypes.Builder {
                  self.oneofEnum = value
                  return self
                }
            @discardableResult
                public func clearOneofEnum() -> Tensorflow.Test.TestAllTypes.Builder {
                   builderResult.hasOneofEnum = false
                   builderResult.oneofEnum = .zero
                   return self
                }
            public var hasMapStringToMessage:Bool {
                get {
                    return builderResult.hasMapStringToMessage
                }
            }
            public var mapStringToMessage:Dictionary<String,Tensorflow.Test.TestAllTypes.NestedMessage> {
                get {
                    return builderResult.mapStringToMessage
                }
                set (value) {
                    builderResult.hasMapStringToMessage = true
                    builderResult.mapStringToMessage = value
                }
            }
            @discardableResult
            public func setMapStringToMessage(_ value:Dictionary<String,Tensorflow.Test.TestAllTypes.NestedMessage>) -> Tensorflow.Test.TestAllTypes.Builder {
                self.mapStringToMessage = value
                return self
            }
            @discardableResult
            public func clearMapStringToMessage() -> Tensorflow.Test.TestAllTypes.Builder{
                builderResult.hasMapStringToMessage = false
                builderResult.mapStringToMessage = Dictionary<String,Tensorflow.Test.TestAllTypes.NestedMessage>()
                return self
            }
            public var hasMapInt32ToMessage:Bool {
                get {
                    return builderResult.hasMapInt32ToMessage
                }
            }
            public var mapInt32ToMessage:Dictionary<Int32,Tensorflow.Test.TestAllTypes.NestedMessage> {
                get {
                    return builderResult.mapInt32ToMessage
                }
                set (value) {
                    builderResult.hasMapInt32ToMessage = true
                    builderResult.mapInt32ToMessage = value
                }
            }
            @discardableResult
            public func setMapInt32ToMessage(_ value:Dictionary<Int32,Tensorflow.Test.TestAllTypes.NestedMessage>) -> Tensorflow.Test.TestAllTypes.Builder {
                self.mapInt32ToMessage = value
                return self
            }
            @discardableResult
            public func clearMapInt32ToMessage() -> Tensorflow.Test.TestAllTypes.Builder{
                builderResult.hasMapInt32ToMessage = false
                builderResult.mapInt32ToMessage = Dictionary<Int32,Tensorflow.Test.TestAllTypes.NestedMessage>()
                return self
            }
            public var hasMapInt64ToMessage:Bool {
                get {
                    return builderResult.hasMapInt64ToMessage
                }
            }
            public var mapInt64ToMessage:Dictionary<Int64,Tensorflow.Test.TestAllTypes.NestedMessage> {
                get {
                    return builderResult.mapInt64ToMessage
                }
                set (value) {
                    builderResult.hasMapInt64ToMessage = true
                    builderResult.mapInt64ToMessage = value
                }
            }
            @discardableResult
            public func setMapInt64ToMessage(_ value:Dictionary<Int64,Tensorflow.Test.TestAllTypes.NestedMessage>) -> Tensorflow.Test.TestAllTypes.Builder {
                self.mapInt64ToMessage = value
                return self
            }
            @discardableResult
            public func clearMapInt64ToMessage() -> Tensorflow.Test.TestAllTypes.Builder{
                builderResult.hasMapInt64ToMessage = false
                builderResult.mapInt64ToMessage = Dictionary<Int64,Tensorflow.Test.TestAllTypes.NestedMessage>()
                return self
            }
            public var hasMapBoolToMessage:Bool {
                get {
                    return builderResult.hasMapBoolToMessage
                }
            }
            public var mapBoolToMessage:Dictionary<Bool,Tensorflow.Test.TestAllTypes.NestedMessage> {
                get {
                    return builderResult.mapBoolToMessage
                }
                set (value) {
                    builderResult.hasMapBoolToMessage = true
                    builderResult.mapBoolToMessage = value
                }
            }
            @discardableResult
            public func setMapBoolToMessage(_ value:Dictionary<Bool,Tensorflow.Test.TestAllTypes.NestedMessage>) -> Tensorflow.Test.TestAllTypes.Builder {
                self.mapBoolToMessage = value
                return self
            }
            @discardableResult
            public func clearMapBoolToMessage() -> Tensorflow.Test.TestAllTypes.Builder{
                builderResult.hasMapBoolToMessage = false
                builderResult.mapBoolToMessage = Dictionary<Bool,Tensorflow.Test.TestAllTypes.NestedMessage>()
                return self
            }
            public var hasMapStringToInt64:Bool {
                get {
                    return builderResult.hasMapStringToInt64
                }
            }
            public var mapStringToInt64:Dictionary<String,Int64> {
                get {
                    return builderResult.mapStringToInt64
                }
                set (value) {
                    builderResult.hasMapStringToInt64 = true
                    builderResult.mapStringToInt64 = value
                }
            }
            @discardableResult
            public func setMapStringToInt64(_ value:Dictionary<String,Int64>) -> Tensorflow.Test.TestAllTypes.Builder {
                self.mapStringToInt64 = value
                return self
            }
            @discardableResult
            public func clearMapStringToInt64() -> Tensorflow.Test.TestAllTypes.Builder{
                builderResult.hasMapStringToInt64 = false
                builderResult.mapStringToInt64 = Dictionary<String,Int64>()
                return self
            }
            public var hasMapInt64ToString:Bool {
                get {
                    return builderResult.hasMapInt64ToString
                }
            }
            public var mapInt64ToString:Dictionary<Int64,String> {
                get {
                    return builderResult.mapInt64ToString
                }
                set (value) {
                    builderResult.hasMapInt64ToString = true
                    builderResult.mapInt64ToString = value
                }
            }
            @discardableResult
            public func setMapInt64ToString(_ value:Dictionary<Int64,String>) -> Tensorflow.Test.TestAllTypes.Builder {
                self.mapInt64ToString = value
                return self
            }
            @discardableResult
            public func clearMapInt64ToString() -> Tensorflow.Test.TestAllTypes.Builder{
                builderResult.hasMapInt64ToString = false
                builderResult.mapInt64ToString = Dictionary<Int64,String>()
                return self
            }
            public var hasAnotherMapStringToMessage:Bool {
                get {
                    return builderResult.hasAnotherMapStringToMessage
                }
            }
            public var anotherMapStringToMessage:Dictionary<String,Tensorflow.Test.TestAllTypes.NestedMessage> {
                get {
                    return builderResult.anotherMapStringToMessage
                }
                set (value) {
                    builderResult.hasAnotherMapStringToMessage = true
                    builderResult.anotherMapStringToMessage = value
                }
            }
            @discardableResult
            public func setAnotherMapStringToMessage(_ value:Dictionary<String,Tensorflow.Test.TestAllTypes.NestedMessage>) -> Tensorflow.Test.TestAllTypes.Builder {
                self.anotherMapStringToMessage = value
                return self
            }
            @discardableResult
            public func clearAnotherMapStringToMessage() -> Tensorflow.Test.TestAllTypes.Builder{
                builderResult.hasAnotherMapStringToMessage = false
                builderResult.anotherMapStringToMessage = Dictionary<String,Tensorflow.Test.TestAllTypes.NestedMessage>()
                return self
            }
            public var packedRepeatedInt64:Array<Int64> {
                get {
                    return builderResult.packedRepeatedInt64
                }
                set (array) {
                    builderResult.packedRepeatedInt64 = array
                }
            }
            @discardableResult
            public func setPackedRepeatedInt64(_ value:Array<Int64>) -> Tensorflow.Test.TestAllTypes.Builder {
                self.packedRepeatedInt64 = value
                return self
            }
            @discardableResult
            public func clearPackedRepeatedInt64() -> Tensorflow.Test.TestAllTypes.Builder {
                builderResult.packedRepeatedInt64.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.Test.TestAllTypes.Builder {
                builderResult = Tensorflow.Test.TestAllTypes()
                return self
            }
            override public func clone() throws -> Tensorflow.Test.TestAllTypes.Builder {
                return try Tensorflow.Test.TestAllTypes.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.Test.TestAllTypes {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.Test.TestAllTypes {
                let returnMe:Tensorflow.Test.TestAllTypes = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.Test.TestAllTypes) throws -> Tensorflow.Test.TestAllTypes.Builder {
                if other == Tensorflow.Test.TestAllTypes() {
                    return self
                }
                if other.hasOptionalInt32 {
                    optionalInt32 = other.optionalInt32
                }
                if other.hasOptionalInt64 {
                    optionalInt64 = other.optionalInt64
                }
                if other.hasOptionalUint32 {
                    optionalUint32 = other.optionalUint32
                }
                if other.hasOptionalUint64 {
                    optionalUint64 = other.optionalUint64
                }
                if other.hasOptionalSint32 {
                    optionalSint32 = other.optionalSint32
                }
                if other.hasOptionalSint64 {
                    optionalSint64 = other.optionalSint64
                }
                if other.hasOptionalFixed32 {
                    optionalFixed32 = other.optionalFixed32
                }
                if other.hasOptionalFixed64 {
                    optionalFixed64 = other.optionalFixed64
                }
                if other.hasOptionalSfixed32 {
                    optionalSfixed32 = other.optionalSfixed32
                }
                if other.hasOptionalSfixed64 {
                    optionalSfixed64 = other.optionalSfixed64
                }
                if other.hasOptionalFloat {
                    optionalFloat = other.optionalFloat
                }
                if other.hasOptionalDouble {
                    optionalDouble = other.optionalDouble
                }
                if other.hasOptionalBool {
                    optionalBool = other.optionalBool
                }
                if other.hasOptionalString {
                    optionalString = other.optionalString
                }
                if other.hasOptionalBytes {
                    optionalBytes = other.optionalBytes
                }
                if (other.hasOptionalNestedMessage) {
                    try mergeOptionalNestedMessage(value: other.optionalNestedMessage)
                }
                if (other.hasOptionalForeignMessage) {
                    try mergeOptionalForeignMessage(value: other.optionalForeignMessage)
                }
                if other.hasOptionalNestedEnum {
                    optionalNestedEnum = other.optionalNestedEnum
                }
                if other.hasOptionalForeignEnum {
                    optionalForeignEnum = other.optionalForeignEnum
                }
                if other.hasOptionalCord {
                    optionalCord = other.optionalCord
                }
                if !other.repeatedInt32.isEmpty {
                    builderResult.repeatedInt32 += other.repeatedInt32
                }
                if !other.repeatedInt64.isEmpty {
                    builderResult.repeatedInt64 += other.repeatedInt64
                }
                if !other.repeatedUint32.isEmpty {
                    builderResult.repeatedUint32 += other.repeatedUint32
                }
                if !other.repeatedUint64.isEmpty {
                    builderResult.repeatedUint64 += other.repeatedUint64
                }
                if !other.repeatedSint32.isEmpty {
                    builderResult.repeatedSint32 += other.repeatedSint32
                }
                if !other.repeatedSint64.isEmpty {
                    builderResult.repeatedSint64 += other.repeatedSint64
                }
                if !other.repeatedFixed32.isEmpty {
                    builderResult.repeatedFixed32 += other.repeatedFixed32
                }
                if !other.repeatedFixed64.isEmpty {
                    builderResult.repeatedFixed64 += other.repeatedFixed64
                }
                if !other.repeatedSfixed32.isEmpty {
                    builderResult.repeatedSfixed32 += other.repeatedSfixed32
                }
                if !other.repeatedSfixed64.isEmpty {
                    builderResult.repeatedSfixed64 += other.repeatedSfixed64
                }
                if !other.repeatedFloat.isEmpty {
                    builderResult.repeatedFloat += other.repeatedFloat
                }
                if !other.repeatedDouble.isEmpty {
                    builderResult.repeatedDouble += other.repeatedDouble
                }
                if !other.repeatedBool.isEmpty {
                    builderResult.repeatedBool += other.repeatedBool
                }
                if !other.repeatedString.isEmpty {
                    builderResult.repeatedString += other.repeatedString
                }
                if !other.repeatedBytes.isEmpty {
                    builderResult.repeatedBytes += other.repeatedBytes
                }
                if !other.repeatedNestedMessage.isEmpty  {
                     builderResult.repeatedNestedMessage += other.repeatedNestedMessage
                }
                if !other.repeatedNestedEnum.isEmpty {
                     builderResult.repeatedNestedEnum += other.repeatedNestedEnum
                }
                if !other.repeatedCord.isEmpty {
                    builderResult.repeatedCord += other.repeatedCord
                }
                if other.hasOneofUint32 {
                    oneofUint32 = other.oneofUint32
                }
                if (other.hasOneofNestedMessage) {
                    try mergeOneofNestedMessage(value: other.oneofNestedMessage)
                }
                if other.hasOneofString {
                    oneofString = other.oneofString
                }
                if other.hasOneofBytes {
                    oneofBytes = other.oneofBytes
                }
                if other.hasOneofEnum {
                    oneofEnum = other.oneofEnum
                }
                if other.hasMapStringToMessage {
                    mapStringToMessage = other.mapStringToMessage
                }
                if other.hasMapInt32ToMessage {
                    mapInt32ToMessage = other.mapInt32ToMessage
                }
                if other.hasMapInt64ToMessage {
                    mapInt64ToMessage = other.mapInt64ToMessage
                }
                if other.hasMapBoolToMessage {
                    mapBoolToMessage = other.mapBoolToMessage
                }
                if other.hasMapStringToInt64 {
                    mapStringToInt64 = other.mapStringToInt64
                }
                if other.hasMapInt64ToString {
                    mapInt64ToString = other.mapInt64ToString
                }
                if other.hasAnotherMapStringToMessage {
                    anotherMapStringToMessage = other.anotherMapStringToMessage
                }
                if !other.packedRepeatedInt64.isEmpty {
                    builderResult.packedRepeatedInt64 += other.packedRepeatedInt64
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Test.TestAllTypes.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 16:
                        optionalInt64 = try codedInputStream.readInt64()

                    case 24:
                        optionalUint32 = try codedInputStream.readUInt32()

                    case 40:
                        optionalSint32 = try codedInputStream.readSInt32()

                    case 48:
                        optionalSint64 = try codedInputStream.readSInt64()

                    case 61:
                        optionalFixed32 = try codedInputStream.readFixed32()

                    case 65:
                        optionalFixed64 = try codedInputStream.readFixed64()

                    case 77:
                        optionalSfixed32 = try codedInputStream.readSFixed32()

                    case 81:
                        optionalSfixed64 = try codedInputStream.readSFixed64()

                    case 93:
                        optionalFloat = try codedInputStream.readFloat()

                    case 97:
                        optionalDouble = try codedInputStream.readDouble()

                    case 104:
                        optionalBool = try codedInputStream.readBool()

                    case 114:
                        optionalString = try codedInputStream.readString()

                    case 122:
                        optionalBytes = try codedInputStream.readData()

                    case 146:
                        let subBuilder:Tensorflow.Test.TestAllTypes.NestedMessage.Builder = Tensorflow.Test.TestAllTypes.NestedMessage.Builder()
                        if hasOptionalNestedMessage {
                            try subBuilder.mergeFrom(other: optionalNestedMessage)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        optionalNestedMessage = subBuilder.buildPartial()

                    case 154:
                        let subBuilder:Tensorflow.Test.ForeignMessage.Builder = Tensorflow.Test.ForeignMessage.Builder()
                        if hasOptionalForeignMessage {
                            try subBuilder.mergeFrom(other: optionalForeignMessage)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        optionalForeignMessage = subBuilder.buildPartial()

                    case 168:
                        let valueIntoptionalNestedEnum = try codedInputStream.readEnum()
                        if let enumsoptionalNestedEnum = Tensorflow.Test.TestAllTypes.NestedEnum(rawValue:valueIntoptionalNestedEnum){
                            optionalNestedEnum = enumsoptionalNestedEnum
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 21, value:Int64(valueIntoptionalNestedEnum))
                        }

                    case 176:
                        let valueIntoptionalForeignEnum = try codedInputStream.readEnum()
                        if let enumsoptionalForeignEnum = Tensorflow.Test.ForeignEnum(rawValue:valueIntoptionalForeignEnum){
                            optionalForeignEnum = enumsoptionalForeignEnum
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 22, value:Int64(valueIntoptionalForeignEnum))
                        }

                    case 202:
                        optionalCord = try codedInputStream.readString()

                    case 250:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.repeatedInt32.append(try codedInputStream.readInt32())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 258:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.repeatedInt64.append(try codedInputStream.readInt64())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 266:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.repeatedUint32.append(try codedInputStream.readUInt32())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 274:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.repeatedUint64.append(try codedInputStream.readUInt64())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 282:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.repeatedSint32.append(try codedInputStream.readSInt32())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 290:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.repeatedSint64.append(try codedInputStream.readSInt64())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 298:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.repeatedFixed32.append(try codedInputStream.readFixed32())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 306:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.repeatedFixed64.append(try codedInputStream.readFixed64())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 314:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.repeatedSfixed32.append(try codedInputStream.readSFixed32())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 322:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.repeatedSfixed64.append(try codedInputStream.readSFixed64())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 330:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.repeatedFloat.append(try codedInputStream.readFloat())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 338:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.repeatedDouble.append(try codedInputStream.readDouble())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 346:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.repeatedBool.append(try codedInputStream.readBool())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 354:
                        repeatedString += [try codedInputStream.readString()]

                    case 362:
                        repeatedBytes += [try codedInputStream.readData()]

                    case 386:
                        let subBuilder = Tensorflow.Test.TestAllTypes.NestedMessage.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        repeatedNestedMessage.append(subBuilder.buildPartial())

                    case 410:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let oldLimit = try codedInputStream.pushLimit(byteLimit: length)
                        while codedInputStream.bytesUntilLimit() > 0 {
                        let valueIntrepeatedNestedEnum = try codedInputStream.readEnum()
                        if let enumsrepeatedNestedEnum = Tensorflow.Test.TestAllTypes.NestedEnum(rawValue:valueIntrepeatedNestedEnum) {
                            builderResult.repeatedNestedEnum.append(enumsrepeatedNestedEnum)
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 51, value:Int64(valueIntrepeatedNestedEnum))
                        }
                        }
                        codedInputStream.popLimit(oldLimit: oldLimit)

                    case 442:
                        repeatedCord += [try codedInputStream.readString()]

                    case 466:
                        let subBuilder = Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfMapStringToMessage = subBuilder.buildPartial()
                        mapStringToMessage[buildOfMapStringToMessage.key] = buildOfMapStringToMessage.value

                    case 474:
                        let subBuilder = Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfMapInt32ToMessage = subBuilder.buildPartial()
                        mapInt32ToMessage[buildOfMapInt32ToMessage.key] = buildOfMapInt32ToMessage.value

                    case 482:
                        let subBuilder = Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfMapInt64ToMessage = subBuilder.buildPartial()
                        mapInt64ToMessage[buildOfMapInt64ToMessage.key] = buildOfMapInt64ToMessage.value

                    case 490:
                        let subBuilder = Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfMapBoolToMessage = subBuilder.buildPartial()
                        mapBoolToMessage[buildOfMapBoolToMessage.key] = buildOfMapBoolToMessage.value

                    case 498:
                        let subBuilder = Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfMapStringToInt64 = subBuilder.buildPartial()
                        mapStringToInt64[buildOfMapStringToInt64.key] = buildOfMapStringToInt64.value

                    case 506:
                        let subBuilder = Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfMapInt64ToString = subBuilder.buildPartial()
                        mapInt64ToString[buildOfMapInt64ToString.key] = buildOfMapInt64ToString.value

                    case 514:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.packedRepeatedInt64.append(try codedInputStream.readInt64())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 522:
                        let subBuilder = Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfAnotherMapStringToMessage = subBuilder.buildPartial()
                        anotherMapStringToMessage[buildOfAnotherMapStringToMessage.key] = buildOfAnotherMapStringToMessage.value

                    case 800:
                        let valueIntoneofEnum = try codedInputStream.readEnum()
                        if let enumsoneofEnum = Tensorflow.Test.TestAllTypes.NestedEnum(rawValue:valueIntoneofEnum){
                            oneofEnum = enumsoneofEnum
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 100, value:Int64(valueIntoneofEnum))
                        }

                    case 888:
                        oneofUint32 = try codedInputStream.readUInt32()

                    case 898:
                        let subBuilder:Tensorflow.Test.TestAllTypes.NestedMessage.Builder = Tensorflow.Test.TestAllTypes.NestedMessage.Builder()
                        if hasOneofNestedMessage {
                            try subBuilder.mergeFrom(other: oneofNestedMessage)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        oneofNestedMessage = subBuilder.buildPartial()

                    case 906:
                        oneofString = try codedInputStream.readString()

                    case 914:
                        oneofBytes = try codedInputStream.readData()

                    case 7992:
                        optionalUint64 = try codedInputStream.readUInt64()

                    case 8000:
                        optionalInt32 = try codedInputStream.readInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Test.TestAllTypes.Builder {
                let resultDecodedBuilder = Tensorflow.Test.TestAllTypes.Builder()
                if let jsonValueOptionalInt32 = jsonMap["optionalInt32"] as? Int {
                    resultDecodedBuilder.optionalInt32 = Int32(jsonValueOptionalInt32)
                } else if let jsonValueOptionalInt32 = jsonMap["optionalInt32"] as? String {
                    resultDecodedBuilder.optionalInt32 = Int32(jsonValueOptionalInt32)!
                }
                if let jsonValueOptionalInt64 = jsonMap["optionalInt64"] as? String {
                    resultDecodedBuilder.optionalInt64 = Int64(jsonValueOptionalInt64)!
                } else if let jsonValueOptionalInt64 = jsonMap["optionalInt64"] as? Int {
                    resultDecodedBuilder.optionalInt64 = Int64(jsonValueOptionalInt64)
                }
                if let jsonValueOptionalUint32 = jsonMap["optionalUint32"] as? UInt {
                    resultDecodedBuilder.optionalUint32 = UInt32(jsonValueOptionalUint32)
                } else if let jsonValueOptionalUint32 = jsonMap["optionalUint32"] as? String {
                    resultDecodedBuilder.optionalUint32 = UInt32(jsonValueOptionalUint32)!
                }
                if let jsonValueOptionalUint64 = jsonMap["optionalUint64"] as? String {
                    resultDecodedBuilder.optionalUint64 = UInt64(jsonValueOptionalUint64)!
                } else if let jsonValueOptionalUint64 = jsonMap["optionalUint64"] as? UInt {
                    resultDecodedBuilder.optionalUint64 = UInt64(jsonValueOptionalUint64)
                }
                if let jsonValueOptionalSint32 = jsonMap["optionalSint32"] as? Int {
                    resultDecodedBuilder.optionalSint32 = Int32(jsonValueOptionalSint32)
                } else if let jsonValueOptionalSint32 = jsonMap["optionalSint32"] as? String {
                    resultDecodedBuilder.optionalSint32 = Int32(jsonValueOptionalSint32)!
                }
                if let jsonValueOptionalSint64 = jsonMap["optionalSint64"] as? String {
                    resultDecodedBuilder.optionalSint64 = Int64(jsonValueOptionalSint64)!
                } else if let jsonValueOptionalSint64 = jsonMap["optionalSint64"] as? Int {
                    resultDecodedBuilder.optionalSint64 = Int64(jsonValueOptionalSint64)
                }
                if let jsonValueOptionalFixed32 = jsonMap["optionalFixed32"] as? UInt {
                    resultDecodedBuilder.optionalFixed32 = UInt32(jsonValueOptionalFixed32)
                } else if let jsonValueOptionalFixed32 = jsonMap["optionalFixed32"] as? String {
                    resultDecodedBuilder.optionalFixed32 = UInt32(jsonValueOptionalFixed32)!
                }
                if let jsonValueOptionalFixed64 = jsonMap["optionalFixed64"] as? String {
                    resultDecodedBuilder.optionalFixed64 = UInt64(jsonValueOptionalFixed64)!
                } else if let jsonValueOptionalFixed64 = jsonMap["optionalFixed64"] as? UInt {
                    resultDecodedBuilder.optionalFixed64 = UInt64(jsonValueOptionalFixed64)
                }
                if let jsonValueOptionalSfixed32 = jsonMap["optionalSfixed32"] as? Int {
                    resultDecodedBuilder.optionalSfixed32 = Int32(jsonValueOptionalSfixed32)
                } else if let jsonValueOptionalSfixed32 = jsonMap["optionalSfixed32"] as? String {
                    resultDecodedBuilder.optionalSfixed32 = Int32(jsonValueOptionalSfixed32)!
                }
                if let jsonValueOptionalSfixed64 = jsonMap["optionalSfixed64"] as? String {
                    resultDecodedBuilder.optionalSfixed64 = Int64(jsonValueOptionalSfixed64)!
                } else if let jsonValueOptionalSfixed64 = jsonMap["optionalSfixed64"] as? Int {
                    resultDecodedBuilder.optionalSfixed64 = Int64(jsonValueOptionalSfixed64)
                }
                if let jsonValueOptionalFloat = jsonMap["optionalFloat"] as? Float {
                    resultDecodedBuilder.optionalFloat = Float(jsonValueOptionalFloat)
                } else if let jsonValueOptionalFloat = jsonMap["optionalFloat"] as? String {
                    resultDecodedBuilder.optionalFloat = Float(jsonValueOptionalFloat)!
                }
                if let jsonValueOptionalDouble = jsonMap["optionalDouble"] as? Double {
                    resultDecodedBuilder.optionalDouble = Double(jsonValueOptionalDouble)
                } else if let jsonValueOptionalDouble = jsonMap["optionalDouble"] as? String {
                    resultDecodedBuilder.optionalDouble = Double(jsonValueOptionalDouble)!
                }
                if let jsonValueOptionalBool = jsonMap["optionalBool"] as? Bool {
                    resultDecodedBuilder.optionalBool = jsonValueOptionalBool
                }
                if let jsonValueOptionalString = jsonMap["optionalString"] as? String {
                    resultDecodedBuilder.optionalString = jsonValueOptionalString
                }
                if let jsonValueOptionalBytes = jsonMap["optionalBytes"] as? String {
                    resultDecodedBuilder.optionalBytes = Data(base64Encoded:jsonValueOptionalBytes, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                if let jsonValueOptionalNestedMessage = jsonMap["optionalNestedMessage"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.optionalNestedMessage = try Tensorflow.Test.TestAllTypes.NestedMessage.Builder.decodeToBuilder(jsonMap:jsonValueOptionalNestedMessage).build()

                }
                if let jsonValueOptionalForeignMessage = jsonMap["optionalForeignMessage"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.optionalForeignMessage = try Tensorflow.Test.ForeignMessage.Builder.decodeToBuilder(jsonMap:jsonValueOptionalForeignMessage).build()

                }
                if let jsonValueOptionalNestedEnum = jsonMap["optionalNestedEnum"] as? String {
                    resultDecodedBuilder.optionalNestedEnum = try Tensorflow.Test.TestAllTypes.NestedEnum.fromString(str: jsonValueOptionalNestedEnum)
                }
                if let jsonValueOptionalForeignEnum = jsonMap["optionalForeignEnum"] as? String {
                    resultDecodedBuilder.optionalForeignEnum = try Tensorflow.Test.ForeignEnum.fromString(str: jsonValueOptionalForeignEnum)
                }
                if let jsonValueOptionalCord = jsonMap["optionalCord"] as? String {
                    resultDecodedBuilder.optionalCord = jsonValueOptionalCord
                }
                if let jsonValueRepeatedInt32 = jsonMap["repeatedInt32"] as? Array<Int> {
                    var jsonArrayRepeatedInt32:Array<Int32> = []
                    for oneValueRepeatedInt32 in jsonValueRepeatedInt32 {
                        jsonArrayRepeatedInt32.append(Int32(oneValueRepeatedInt32))
                    }
                    resultDecodedBuilder.repeatedInt32 = jsonArrayRepeatedInt32
                }
                if let jsonValueRepeatedInt64 = jsonMap["repeatedInt64"] as? Array<String> {
                    var jsonArrayRepeatedInt64:Array<Int64> = []
                    for oneValueRepeatedInt64 in jsonValueRepeatedInt64 {
                        jsonArrayRepeatedInt64.append(Int64(oneValueRepeatedInt64)!)
                    }
                    resultDecodedBuilder.repeatedInt64 = jsonArrayRepeatedInt64
                }
                if let jsonValueRepeatedUint32 = jsonMap["repeatedUint32"] as? Array<UInt> {
                    var jsonArrayRepeatedUint32:Array<UInt32> = []
                    for oneValueRepeatedUint32 in jsonValueRepeatedUint32 {
                        jsonArrayRepeatedUint32.append(UInt32(oneValueRepeatedUint32))
                    }
                    resultDecodedBuilder.repeatedUint32 = jsonArrayRepeatedUint32
                }
                if let jsonValueRepeatedUint64 = jsonMap["repeatedUint64"] as? Array<String> {
                    var jsonArrayRepeatedUint64:Array<UInt64> = []
                    for oneValueRepeatedUint64 in jsonValueRepeatedUint64 {
                        jsonArrayRepeatedUint64.append(UInt64(oneValueRepeatedUint64)!)
                    }
                    resultDecodedBuilder.repeatedUint64 = jsonArrayRepeatedUint64
                }
                if let jsonValueRepeatedSint32 = jsonMap["repeatedSint32"] as? Array<Int> {
                    var jsonArrayRepeatedSint32:Array<Int32> = []
                    for oneValueRepeatedSint32 in jsonValueRepeatedSint32 {
                        jsonArrayRepeatedSint32.append(Int32(oneValueRepeatedSint32))
                    }
                    resultDecodedBuilder.repeatedSint32 = jsonArrayRepeatedSint32
                }
                if let jsonValueRepeatedSint64 = jsonMap["repeatedSint64"] as? Array<String> {
                    var jsonArrayRepeatedSint64:Array<Int64> = []
                    for oneValueRepeatedSint64 in jsonValueRepeatedSint64 {
                        jsonArrayRepeatedSint64.append(Int64(oneValueRepeatedSint64)!)
                    }
                    resultDecodedBuilder.repeatedSint64 = jsonArrayRepeatedSint64
                }
                if let jsonValueRepeatedFixed32 = jsonMap["repeatedFixed32"] as? Array<UInt> {
                    var jsonArrayRepeatedFixed32:Array<UInt32> = []
                    for oneValueRepeatedFixed32 in jsonValueRepeatedFixed32 {
                        jsonArrayRepeatedFixed32.append(UInt32(oneValueRepeatedFixed32))
                    }
                    resultDecodedBuilder.repeatedFixed32 = jsonArrayRepeatedFixed32
                }
                if let jsonValueRepeatedFixed64 = jsonMap["repeatedFixed64"] as? Array<String> {
                    var jsonArrayRepeatedFixed64:Array<UInt64> = []
                    for oneValueRepeatedFixed64 in jsonValueRepeatedFixed64 {
                        jsonArrayRepeatedFixed64.append(UInt64(oneValueRepeatedFixed64)!)
                    }
                    resultDecodedBuilder.repeatedFixed64 = jsonArrayRepeatedFixed64
                }
                if let jsonValueRepeatedSfixed32 = jsonMap["repeatedSfixed32"] as? Array<Int> {
                    var jsonArrayRepeatedSfixed32:Array<Int32> = []
                    for oneValueRepeatedSfixed32 in jsonValueRepeatedSfixed32 {
                        jsonArrayRepeatedSfixed32.append(Int32(oneValueRepeatedSfixed32))
                    }
                    resultDecodedBuilder.repeatedSfixed32 = jsonArrayRepeatedSfixed32
                }
                if let jsonValueRepeatedSfixed64 = jsonMap["repeatedSfixed64"] as? Array<String> {
                    var jsonArrayRepeatedSfixed64:Array<Int64> = []
                    for oneValueRepeatedSfixed64 in jsonValueRepeatedSfixed64 {
                        jsonArrayRepeatedSfixed64.append(Int64(oneValueRepeatedSfixed64)!)
                    }
                    resultDecodedBuilder.repeatedSfixed64 = jsonArrayRepeatedSfixed64
                }
                if let jsonValueRepeatedFloat = jsonMap["repeatedFloat"] as? Array<Float> {
                    var jsonArrayRepeatedFloat:Array<Float> = []
                    for oneValueRepeatedFloat in jsonValueRepeatedFloat {
                        jsonArrayRepeatedFloat.append(Float(oneValueRepeatedFloat))
                    }
                    resultDecodedBuilder.repeatedFloat = jsonArrayRepeatedFloat
                }
                if let jsonValueRepeatedDouble = jsonMap["repeatedDouble"] as? Array<Double> {
                    var jsonArrayRepeatedDouble:Array<Double> = []
                    for oneValueRepeatedDouble in jsonValueRepeatedDouble {
                        jsonArrayRepeatedDouble.append(Double(oneValueRepeatedDouble))
                    }
                    resultDecodedBuilder.repeatedDouble = jsonArrayRepeatedDouble
                }
                if let jsonValueRepeatedBool = jsonMap["repeatedBool"] as? Array<Bool> {
                    var jsonArrayRepeatedBool:Array<Bool> = []
                    for oneValueRepeatedBool in jsonValueRepeatedBool {
                        jsonArrayRepeatedBool.append(oneValueRepeatedBool)
                    }
                    resultDecodedBuilder.repeatedBool = jsonArrayRepeatedBool
                }
                if let jsonValueRepeatedString = jsonMap["repeatedString"] as? Array<String> {
                    var jsonArrayRepeatedString:Array<String> = []
                    for oneValueRepeatedString in jsonValueRepeatedString {
                        jsonArrayRepeatedString.append(oneValueRepeatedString)
                    }
                    resultDecodedBuilder.repeatedString = jsonArrayRepeatedString
                }
                if let jsonValueRepeatedBytes = jsonMap["repeatedBytes"] as? Array<String> {
                    var jsonArrayRepeatedBytes:Array<Data> = []
                    for oneValueRepeatedBytes in jsonValueRepeatedBytes {
                        jsonArrayRepeatedBytes.append(Data(base64Encoded:oneValueRepeatedBytes, options: Data.Base64DecodingOptions(rawValue:0))!)
                    }
                    resultDecodedBuilder.repeatedBytes = jsonArrayRepeatedBytes
                }
                if let jsonValueRepeatedNestedMessage = jsonMap["repeatedNestedMessage"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayRepeatedNestedMessage:Array<Tensorflow.Test.TestAllTypes.NestedMessage> = []
                    for oneValueRepeatedNestedMessage in jsonValueRepeatedNestedMessage {
                        let messageFromStringRepeatedNestedMessage = try Tensorflow.Test.TestAllTypes.NestedMessage.Builder.decodeToBuilder(jsonMap:oneValueRepeatedNestedMessage).build()

                        jsonArrayRepeatedNestedMessage.append(messageFromStringRepeatedNestedMessage)
                    }
                    resultDecodedBuilder.repeatedNestedMessage = jsonArrayRepeatedNestedMessage
                }
                if let jsonValueRepeatedNestedEnum = jsonMap["repeatedNestedEnum"] as? Array<String> {
                    var jsonArrayRepeatedNestedEnum:Array<Tensorflow.Test.TestAllTypes.NestedEnum> = []
                    for oneValueRepeatedNestedEnum in jsonValueRepeatedNestedEnum {
                        let enumFromStringRepeatedNestedEnum = try Tensorflow.Test.TestAllTypes.NestedEnum.fromString(str: oneValueRepeatedNestedEnum)
                        jsonArrayRepeatedNestedEnum.append(enumFromStringRepeatedNestedEnum)
                    }
                    resultDecodedBuilder.repeatedNestedEnum = jsonArrayRepeatedNestedEnum
                }
                if let jsonValueRepeatedCord = jsonMap["repeatedCord"] as? Array<String> {
                    var jsonArrayRepeatedCord:Array<String> = []
                    for oneValueRepeatedCord in jsonValueRepeatedCord {
                        jsonArrayRepeatedCord.append(oneValueRepeatedCord)
                    }
                    resultDecodedBuilder.repeatedCord = jsonArrayRepeatedCord
                }
                if let jsonValueOneofUint32 = jsonMap["oneofUint32"] as? UInt {
                    resultDecodedBuilder.oneofUint32 = UInt32(jsonValueOneofUint32)
                } else if let jsonValueOneofUint32 = jsonMap["oneofUint32"] as? String {
                    resultDecodedBuilder.oneofUint32 = UInt32(jsonValueOneofUint32)!
                }
                if let jsonValueOneofNestedMessage = jsonMap["oneofNestedMessage"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.oneofNestedMessage = try Tensorflow.Test.TestAllTypes.NestedMessage.Builder.decodeToBuilder(jsonMap:jsonValueOneofNestedMessage).build()

                }
                if let jsonValueOneofString = jsonMap["oneofString"] as? String {
                    resultDecodedBuilder.oneofString = jsonValueOneofString
                }
                if let jsonValueOneofBytes = jsonMap["oneofBytes"] as? String {
                    resultDecodedBuilder.oneofBytes = Data(base64Encoded:jsonValueOneofBytes, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                if let jsonValueOneofEnum = jsonMap["oneofEnum"] as? String {
                    resultDecodedBuilder.oneofEnum = try Tensorflow.Test.TestAllTypes.NestedEnum.fromString(str: jsonValueOneofEnum)
                }
                if let jsonValueMapStringToMessage = jsonMap["mapStringToMessage"] as? Dictionary<String, Dictionary<String,Any>> {
                    var mapMapStringToMessage = Dictionary<String, Tensorflow.Test.TestAllTypes.NestedMessage>()
                    for (keyMapStringToMessage, valueMapStringToMessage) in jsonValueMapStringToMessage {
                        guard let keyFromMapStringToMessage = String(keyMapStringToMessage) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapMapStringToMessage[keyFromMapStringToMessage] = try Tensorflow.Test.TestAllTypes.NestedMessage.Builder.decodeToBuilder(jsonMap:valueMapStringToMessage).build()

                    }
                    resultDecodedBuilder.mapStringToMessage = mapMapStringToMessage
                }
                if let jsonValueMapInt32ToMessage = jsonMap["mapInt32ToMessage"] as? Dictionary<String, Dictionary<String,Any>> {
                    var mapMapInt32ToMessage = Dictionary<Int32, Tensorflow.Test.TestAllTypes.NestedMessage>()
                    for (keyMapInt32ToMessage, valueMapInt32ToMessage) in jsonValueMapInt32ToMessage {
                        guard let keyFromMapInt32ToMessage = Int32(keyMapInt32ToMessage) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapMapInt32ToMessage[keyFromMapInt32ToMessage] = try Tensorflow.Test.TestAllTypes.NestedMessage.Builder.decodeToBuilder(jsonMap:valueMapInt32ToMessage).build()

                    }
                    resultDecodedBuilder.mapInt32ToMessage = mapMapInt32ToMessage
                }
                if let jsonValueMapInt64ToMessage = jsonMap["mapInt64ToMessage"] as? Dictionary<String, Dictionary<String,Any>> {
                    var mapMapInt64ToMessage = Dictionary<Int64, Tensorflow.Test.TestAllTypes.NestedMessage>()
                    for (keyMapInt64ToMessage, valueMapInt64ToMessage) in jsonValueMapInt64ToMessage {
                        guard let keyFromMapInt64ToMessage = Int64(keyMapInt64ToMessage) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapMapInt64ToMessage[keyFromMapInt64ToMessage] = try Tensorflow.Test.TestAllTypes.NestedMessage.Builder.decodeToBuilder(jsonMap:valueMapInt64ToMessage).build()

                    }
                    resultDecodedBuilder.mapInt64ToMessage = mapMapInt64ToMessage
                }
                if let jsonValueMapBoolToMessage = jsonMap["mapBoolToMessage"] as? Dictionary<String, Dictionary<String,Any>> {
                    var mapMapBoolToMessage = Dictionary<Bool, Tensorflow.Test.TestAllTypes.NestedMessage>()
                    for (keyMapBoolToMessage, valueMapBoolToMessage) in jsonValueMapBoolToMessage {
                        guard let keyFromMapBoolToMessage = Bool(keyMapBoolToMessage) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapMapBoolToMessage[keyFromMapBoolToMessage] = try Tensorflow.Test.TestAllTypes.NestedMessage.Builder.decodeToBuilder(jsonMap:valueMapBoolToMessage).build()

                    }
                    resultDecodedBuilder.mapBoolToMessage = mapMapBoolToMessage
                }
                if let jsonValueMapStringToInt64 = jsonMap["mapStringToInt64"] as? Dictionary<String, String> {
                    var mapMapStringToInt64 = Dictionary<String, Int64>()
                    for (keyMapStringToInt64, valueMapStringToInt64) in jsonValueMapStringToInt64 {
                        guard let keyFromMapStringToInt64 = String(keyMapStringToInt64) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapMapStringToInt64[keyFromMapStringToInt64] = Int64(valueMapStringToInt64)!
                    }
                    resultDecodedBuilder.mapStringToInt64 = mapMapStringToInt64
                }
                if let jsonValueMapInt64ToString = jsonMap["mapInt64ToString"] as? Dictionary<String, String> {
                    var mapMapInt64ToString = Dictionary<Int64, String>()
                    for (keyMapInt64ToString, valueMapInt64ToString) in jsonValueMapInt64ToString {
                        guard let keyFromMapInt64ToString = Int64(keyMapInt64ToString) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapMapInt64ToString[keyFromMapInt64ToString] = valueMapInt64ToString
                    }
                    resultDecodedBuilder.mapInt64ToString = mapMapInt64ToString
                }
                if let jsonValueAnotherMapStringToMessage = jsonMap["anotherMapStringToMessage"] as? Dictionary<String, Dictionary<String,Any>> {
                    var mapAnotherMapStringToMessage = Dictionary<String, Tensorflow.Test.TestAllTypes.NestedMessage>()
                    for (keyAnotherMapStringToMessage, valueAnotherMapStringToMessage) in jsonValueAnotherMapStringToMessage {
                        guard let keyFromAnotherMapStringToMessage = String(keyAnotherMapStringToMessage) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapAnotherMapStringToMessage[keyFromAnotherMapStringToMessage] = try Tensorflow.Test.TestAllTypes.NestedMessage.Builder.decodeToBuilder(jsonMap:valueAnotherMapStringToMessage).build()

                    }
                    resultDecodedBuilder.anotherMapStringToMessage = mapAnotherMapStringToMessage
                }
                if let jsonValuePackedRepeatedInt64 = jsonMap["packedRepeatedInt64"] as? Array<String> {
                    var jsonArrayPackedRepeatedInt64:Array<Int64> = []
                    for oneValuePackedRepeatedInt64 in jsonValuePackedRepeatedInt64 {
                        jsonArrayPackedRepeatedInt64.append(Int64(oneValuePackedRepeatedInt64)!)
                    }
                    resultDecodedBuilder.packedRepeatedInt64 = jsonArrayPackedRepeatedInt64
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Test.TestAllTypes.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.Test.TestAllTypes.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// A recursive message.
    final public class NestedTestAllTypes : GeneratedMessage {

        public static func == (lhs: Tensorflow.Test.NestedTestAllTypes, rhs: Tensorflow.Test.NestedTestAllTypes) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasChild == rhs.hasChild) && (!lhs.hasChild || lhs.child == rhs.child)
            fieldCheck = fieldCheck && (lhs.hasPayload == rhs.hasPayload) && (!lhs.hasPayload || lhs.payload == rhs.payload)
            fieldCheck = fieldCheck && (lhs.hasMapStringToInt64 == rhs.hasMapStringToInt64) && (!lhs.hasMapStringToInt64 || lhs.mapStringToInt64 == rhs.mapStringToInt64)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        final public class MapStringToInt64Entry : GeneratedMessage {

            public static func == (lhs: Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry, rhs: Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:String = ""
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:Int64 = Int64(0)
            public fileprivate(set) var hasValue:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeString(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeInt64(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeStringSize(fieldNumber: 1)
                }
                if hasValue {
                    serialize_size += value.computeInt64Size(fieldNumber: 2)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder {
                return Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.classBuilder() as! Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder
            }
            public func getBuilder() -> Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder {
                return classBuilder() as! Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder()
            }
            public func toBuilder() throws -> Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder {
                return try Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry) throws -> Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder {
                return try Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = key
                }
                if hasValue {
                    jsonMap["value"] = "\(value)"
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry {
                return try Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry {
                return try Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value: \(value) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        hashCode = (hashCode &* 31) &+ value.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry"
            }
            override public func className() -> String {
                return "Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry = Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry()
                public func getMessage() -> Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:String {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:String) -> Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = ""
                    return self
                }
                public var value:Int64 {
                    get {
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                @discardableResult
                public func setValue(_ value:Int64) -> Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder{
                    builderResult.hasValue = false
                    builderResult.value = Int64(0)
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder {
                    builderResult = Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry()
                    return self
                }
                override public func clone() throws -> Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder {
                    return try Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry {
                    let returnMe:Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry) throws -> Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder {
                    if other == Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if other.hasValue {
                        value = other.value
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            key = try codedInputStream.readString()

                        case 16:
                            value = try codedInputStream.readInt64()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder {
                    let resultDecodedBuilder = Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = jsonValueKey
                    }
                    if let jsonValueValue = jsonMap["value"] as? String {
                        resultDecodedBuilder.value = Int64(jsonValueValue)!
                    } else if let jsonValueValue = jsonMap["value"] as? Int {
                        resultDecodedBuilder.value = Int64(jsonValueValue)
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        public fileprivate(set) var child:Tensorflow.Test.NestedTestAllTypes!
        public fileprivate(set) var hasChild:Bool = false
        public fileprivate(set) var payload:Tensorflow.Test.TestAllTypes!
        public fileprivate(set) var hasPayload:Bool = false
        public fileprivate(set) var mapStringToInt64:Dictionary<String,Int64> = Dictionary<String,Int64>()

        public fileprivate(set) var hasMapStringToInt64:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasChild {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:child)
            }
            if hasPayload {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:payload)
            }
            if hasMapStringToInt64 {
                for (keyMapStringToInt64, valueMapStringToInt64) in mapStringToInt64 {
                    let valueOfMapStringToInt64 = try! Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder().setKey(keyMapStringToInt64).setValue(valueMapStringToInt64).build()
                      try codedOutputStream.writeMessage(fieldNumber: 3, value:valueOfMapStringToInt64)
                  }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasChild {
                if let varSizechild = child?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizechild
                }
            }
            if hasPayload {
                if let varSizepayload = payload?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizepayload
                }
            }
            if hasMapStringToInt64 {
                  for (keyMapStringToInt64, valueMapStringToInt64) in mapStringToInt64 {
                      let valueOfMapStringToInt64 = try! Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder().setKey(keyMapStringToInt64).setValue(valueMapStringToInt64).build()
                serialize_size += valueOfMapStringToInt64.computeMessageSize(fieldNumber: 3)
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.Test.NestedTestAllTypes.Builder {
            return Tensorflow.Test.NestedTestAllTypes.classBuilder() as! Tensorflow.Test.NestedTestAllTypes.Builder
        }
        public func getBuilder() -> Tensorflow.Test.NestedTestAllTypes.Builder {
            return classBuilder() as! Tensorflow.Test.NestedTestAllTypes.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Test.NestedTestAllTypes.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Test.NestedTestAllTypes.Builder()
        }
        public func toBuilder() throws -> Tensorflow.Test.NestedTestAllTypes.Builder {
            return try Tensorflow.Test.NestedTestAllTypes.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.Test.NestedTestAllTypes) throws -> Tensorflow.Test.NestedTestAllTypes.Builder {
            return try Tensorflow.Test.NestedTestAllTypes.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasChild {
                jsonMap["child"] = try child.encode()
            }
            if hasPayload {
                jsonMap["payload"] = try payload.encode()
            }
            if hasMapStringToInt64 {
                var mapMapStringToInt64 = Dictionary<String, String>()
                for (keyMapStringToInt64, valueMapStringToInt64) in mapStringToInt64 {
                    mapMapStringToInt64["\(keyMapStringToInt64)"] = "\(valueMapStringToInt64)"
                }
                jsonMap["mapStringToInt64"] = mapMapStringToInt64
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Test.NestedTestAllTypes {
            return try Tensorflow.Test.NestedTestAllTypes.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.Test.NestedTestAllTypes {
            return try Tensorflow.Test.NestedTestAllTypes.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasChild {
                output += "\(indent) child {\n"
                if let outDescChild = child {
                    output += try outDescChild.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasPayload {
                output += "\(indent) payload {\n"
                if let outDescPayload = payload {
                    output += try outDescPayload.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasMapStringToInt64 {
                output += "\(indent) mapStringToInt64: \(mapStringToInt64) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasChild {
                    if let hashValuechild = child?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuechild
                    }
                }
                if hasPayload {
                    if let hashValuepayload = payload?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuepayload
                    }
                }
                if hasMapStringToInt64 {
                    for (keyMapStringToInt64, valueMapStringToInt64) in mapStringToInt64 {
                        hashCode = (hashCode &* 31) &+ keyMapStringToInt64.hashValue
                        hashCode = (hashCode &* 31) &+ valueMapStringToInt64.hashValue
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.Test.NestedTestAllTypes"
        }
        override public func className() -> String {
            return "Tensorflow.Test.NestedTestAllTypes"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.Test.NestedTestAllTypes = Tensorflow.Test.NestedTestAllTypes()
            public func getMessage() -> Tensorflow.Test.NestedTestAllTypes {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var child:Tensorflow.Test.NestedTestAllTypes! {
                get {
                    if childBuilder_ != nil {
                        builderResult.child = childBuilder_.getMessage()
                    }
                    return builderResult.child
                }
                set (value) {
                    builderResult.hasChild = true
                    builderResult.child = value
                }
            }
            public var hasChild:Bool {
                get {
                    return builderResult.hasChild
                }
            }
            fileprivate var childBuilder_:Tensorflow.Test.NestedTestAllTypes.Builder! {
                didSet {
                    builderResult.hasChild = true
                }
            }
            public func getChildBuilder() -> Tensorflow.Test.NestedTestAllTypes.Builder {
                if childBuilder_ == nil {
                    childBuilder_ = Tensorflow.Test.NestedTestAllTypes.Builder()
                    builderResult.child = childBuilder_.getMessage()
                    if child != nil {
                        try! childBuilder_.mergeFrom(other: child)
                    }
                }
                return childBuilder_
            }
            @discardableResult
            public func setChild(_ value:Tensorflow.Test.NestedTestAllTypes!) -> Tensorflow.Test.NestedTestAllTypes.Builder {
                self.child = value
                return self
            }
            @discardableResult
            public func mergeChild(value:Tensorflow.Test.NestedTestAllTypes) throws -> Tensorflow.Test.NestedTestAllTypes.Builder {
                if builderResult.hasChild {
                    builderResult.child = try Tensorflow.Test.NestedTestAllTypes.builderWithPrototype(prototype:builderResult.child).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.child = value
                }
                builderResult.hasChild = true
                return self
            }
            @discardableResult
            public func clearChild() -> Tensorflow.Test.NestedTestAllTypes.Builder {
                childBuilder_ = nil
                builderResult.hasChild = false
                builderResult.child = nil
                return self
            }
            public var payload:Tensorflow.Test.TestAllTypes! {
                get {
                    if payloadBuilder_ != nil {
                        builderResult.payload = payloadBuilder_.getMessage()
                    }
                    return builderResult.payload
                }
                set (value) {
                    builderResult.hasPayload = true
                    builderResult.payload = value
                }
            }
            public var hasPayload:Bool {
                get {
                    return builderResult.hasPayload
                }
            }
            fileprivate var payloadBuilder_:Tensorflow.Test.TestAllTypes.Builder! {
                didSet {
                    builderResult.hasPayload = true
                }
            }
            public func getPayloadBuilder() -> Tensorflow.Test.TestAllTypes.Builder {
                if payloadBuilder_ == nil {
                    payloadBuilder_ = Tensorflow.Test.TestAllTypes.Builder()
                    builderResult.payload = payloadBuilder_.getMessage()
                    if payload != nil {
                        try! payloadBuilder_.mergeFrom(other: payload)
                    }
                }
                return payloadBuilder_
            }
            @discardableResult
            public func setPayload(_ value:Tensorflow.Test.TestAllTypes!) -> Tensorflow.Test.NestedTestAllTypes.Builder {
                self.payload = value
                return self
            }
            @discardableResult
            public func mergePayload(value:Tensorflow.Test.TestAllTypes) throws -> Tensorflow.Test.NestedTestAllTypes.Builder {
                if builderResult.hasPayload {
                    builderResult.payload = try Tensorflow.Test.TestAllTypes.builderWithPrototype(prototype:builderResult.payload).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.payload = value
                }
                builderResult.hasPayload = true
                return self
            }
            @discardableResult
            public func clearPayload() -> Tensorflow.Test.NestedTestAllTypes.Builder {
                payloadBuilder_ = nil
                builderResult.hasPayload = false
                builderResult.payload = nil
                return self
            }
            public var hasMapStringToInt64:Bool {
                get {
                    return builderResult.hasMapStringToInt64
                }
            }
            public var mapStringToInt64:Dictionary<String,Int64> {
                get {
                    return builderResult.mapStringToInt64
                }
                set (value) {
                    builderResult.hasMapStringToInt64 = true
                    builderResult.mapStringToInt64 = value
                }
            }
            @discardableResult
            public func setMapStringToInt64(_ value:Dictionary<String,Int64>) -> Tensorflow.Test.NestedTestAllTypes.Builder {
                self.mapStringToInt64 = value
                return self
            }
            @discardableResult
            public func clearMapStringToInt64() -> Tensorflow.Test.NestedTestAllTypes.Builder{
                builderResult.hasMapStringToInt64 = false
                builderResult.mapStringToInt64 = Dictionary<String,Int64>()
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.Test.NestedTestAllTypes.Builder {
                builderResult = Tensorflow.Test.NestedTestAllTypes()
                return self
            }
            override public func clone() throws -> Tensorflow.Test.NestedTestAllTypes.Builder {
                return try Tensorflow.Test.NestedTestAllTypes.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.Test.NestedTestAllTypes {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.Test.NestedTestAllTypes {
                let returnMe:Tensorflow.Test.NestedTestAllTypes = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.Test.NestedTestAllTypes) throws -> Tensorflow.Test.NestedTestAllTypes.Builder {
                if other == Tensorflow.Test.NestedTestAllTypes() {
                    return self
                }
                if (other.hasChild) {
                    try mergeChild(value: other.child)
                }
                if (other.hasPayload) {
                    try mergePayload(value: other.payload)
                }
                if other.hasMapStringToInt64 {
                    mapStringToInt64 = other.mapStringToInt64
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Test.NestedTestAllTypes.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.NestedTestAllTypes.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Tensorflow.Test.NestedTestAllTypes.Builder = Tensorflow.Test.NestedTestAllTypes.Builder()
                        if hasChild {
                            try subBuilder.mergeFrom(other: child)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        child = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Tensorflow.Test.TestAllTypes.Builder = Tensorflow.Test.TestAllTypes.Builder()
                        if hasPayload {
                            try subBuilder.mergeFrom(other: payload)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        payload = subBuilder.buildPartial()

                    case 26:
                        let subBuilder = Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfMapStringToInt64 = subBuilder.buildPartial()
                        mapStringToInt64[buildOfMapStringToInt64.key] = buildOfMapStringToInt64.value

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Test.NestedTestAllTypes.Builder {
                let resultDecodedBuilder = Tensorflow.Test.NestedTestAllTypes.Builder()
                if let jsonValueChild = jsonMap["child"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.child = try Tensorflow.Test.NestedTestAllTypes.Builder.decodeToBuilder(jsonMap:jsonValueChild).build()

                }
                if let jsonValuePayload = jsonMap["payload"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.payload = try Tensorflow.Test.TestAllTypes.Builder.decodeToBuilder(jsonMap:jsonValuePayload).build()

                }
                if let jsonValueMapStringToInt64 = jsonMap["mapStringToInt64"] as? Dictionary<String, String> {
                    var mapMapStringToInt64 = Dictionary<String, Int64>()
                    for (keyMapStringToInt64, valueMapStringToInt64) in jsonValueMapStringToInt64 {
                        guard let keyFromMapStringToInt64 = String(keyMapStringToInt64) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapMapStringToInt64[keyFromMapStringToInt64] = Int64(valueMapStringToInt64)!
                    }
                    resultDecodedBuilder.mapStringToInt64 = mapMapStringToInt64
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Test.NestedTestAllTypes.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.Test.NestedTestAllTypes.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ForeignMessage : GeneratedMessage {

        public static func == (lhs: Tensorflow.Test.ForeignMessage, rhs: Tensorflow.Test.ForeignMessage) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasC == rhs.hasC) && (!lhs.hasC || lhs.c == rhs.c)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var c:Int32 = Int32(0)
        public fileprivate(set) var hasC:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasC {
                try codedOutputStream.writeInt32(fieldNumber: 1, value:c)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasC {
                serialize_size += c.computeInt32Size(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.Test.ForeignMessage.Builder {
            return Tensorflow.Test.ForeignMessage.classBuilder() as! Tensorflow.Test.ForeignMessage.Builder
        }
        public func getBuilder() -> Tensorflow.Test.ForeignMessage.Builder {
            return classBuilder() as! Tensorflow.Test.ForeignMessage.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Test.ForeignMessage.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Test.ForeignMessage.Builder()
        }
        public func toBuilder() throws -> Tensorflow.Test.ForeignMessage.Builder {
            return try Tensorflow.Test.ForeignMessage.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.Test.ForeignMessage) throws -> Tensorflow.Test.ForeignMessage.Builder {
            return try Tensorflow.Test.ForeignMessage.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasC {
                jsonMap["c"] = Int(c)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Test.ForeignMessage {
            return try Tensorflow.Test.ForeignMessage.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.Test.ForeignMessage {
            return try Tensorflow.Test.ForeignMessage.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasC {
                output += "\(indent) c: \(c) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasC {
                    hashCode = (hashCode &* 31) &+ c.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.Test.ForeignMessage"
        }
        override public func className() -> String {
            return "Tensorflow.Test.ForeignMessage"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.Test.ForeignMessage = Tensorflow.Test.ForeignMessage()
            public func getMessage() -> Tensorflow.Test.ForeignMessage {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var c:Int32 {
                get {
                    return builderResult.c
                }
                set (value) {
                    builderResult.hasC = true
                    builderResult.c = value
                }
            }
            public var hasC:Bool {
                get {
                    return builderResult.hasC
                }
            }
            @discardableResult
            public func setC(_ value:Int32) -> Tensorflow.Test.ForeignMessage.Builder {
                self.c = value
                return self
            }
            @discardableResult
            public func clearC() -> Tensorflow.Test.ForeignMessage.Builder{
                builderResult.hasC = false
                builderResult.c = Int32(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.Test.ForeignMessage.Builder {
                builderResult = Tensorflow.Test.ForeignMessage()
                return self
            }
            override public func clone() throws -> Tensorflow.Test.ForeignMessage.Builder {
                return try Tensorflow.Test.ForeignMessage.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.Test.ForeignMessage {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.Test.ForeignMessage {
                let returnMe:Tensorflow.Test.ForeignMessage = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.Test.ForeignMessage) throws -> Tensorflow.Test.ForeignMessage.Builder {
                if other == Tensorflow.Test.ForeignMessage() {
                    return self
                }
                if other.hasC {
                    c = other.c
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Test.ForeignMessage.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.ForeignMessage.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        c = try codedInputStream.readInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Test.ForeignMessage.Builder {
                let resultDecodedBuilder = Tensorflow.Test.ForeignMessage.Builder()
                if let jsonValueC = jsonMap["c"] as? Int {
                    resultDecodedBuilder.c = Int32(jsonValueC)
                } else if let jsonValueC = jsonMap["c"] as? String {
                    resultDecodedBuilder.c = Int32(jsonValueC)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Test.ForeignMessage.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.Test.ForeignMessage.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class TestEmptyMessage : GeneratedMessage {

        public static func == (lhs: Tensorflow.Test.TestEmptyMessage, rhs: Tensorflow.Test.TestEmptyMessage) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.Test.TestEmptyMessage.Builder {
            return Tensorflow.Test.TestEmptyMessage.classBuilder() as! Tensorflow.Test.TestEmptyMessage.Builder
        }
        public func getBuilder() -> Tensorflow.Test.TestEmptyMessage.Builder {
            return classBuilder() as! Tensorflow.Test.TestEmptyMessage.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Test.TestEmptyMessage.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Test.TestEmptyMessage.Builder()
        }
        public func toBuilder() throws -> Tensorflow.Test.TestEmptyMessage.Builder {
            return try Tensorflow.Test.TestEmptyMessage.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.Test.TestEmptyMessage) throws -> Tensorflow.Test.TestEmptyMessage.Builder {
            return try Tensorflow.Test.TestEmptyMessage.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Test.TestEmptyMessage {
            return try Tensorflow.Test.TestEmptyMessage.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.Test.TestEmptyMessage {
            return try Tensorflow.Test.TestEmptyMessage.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.Test.TestEmptyMessage"
        }
        override public func className() -> String {
            return "Tensorflow.Test.TestEmptyMessage"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.Test.TestEmptyMessage = Tensorflow.Test.TestEmptyMessage()
            public func getMessage() -> Tensorflow.Test.TestEmptyMessage {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.Test.TestEmptyMessage.Builder {
                builderResult = Tensorflow.Test.TestEmptyMessage()
                return self
            }
            override public func clone() throws -> Tensorflow.Test.TestEmptyMessage.Builder {
                return try Tensorflow.Test.TestEmptyMessage.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.Test.TestEmptyMessage {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.Test.TestEmptyMessage {
                let returnMe:Tensorflow.Test.TestEmptyMessage = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.Test.TestEmptyMessage) throws -> Tensorflow.Test.TestEmptyMessage.Builder {
                if other == Tensorflow.Test.TestEmptyMessage() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Test.TestEmptyMessage.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestEmptyMessage.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Test.TestEmptyMessage.Builder {
                let resultDecodedBuilder = Tensorflow.Test.TestEmptyMessage.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Test.TestEmptyMessage.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.Test.TestEmptyMessage.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.Test.TestAllTypes: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Test.TestAllTypes> {
        var mergedArray = Array<Tensorflow.Test.TestAllTypes>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Test.TestAllTypes? {
        return try Tensorflow.Test.TestAllTypes.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Test.TestAllTypes {
        return try Tensorflow.Test.TestAllTypes.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.Test.TestRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes {
        return try Tensorflow.Test.TestAllTypes.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Test.TestAllTypes {
        return try Tensorflow.Test.TestAllTypes.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes {
        return try Tensorflow.Test.TestAllTypes.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Test.TestAllTypes {
        return try Tensorflow.Test.TestAllTypes.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes {
        return try Tensorflow.Test.TestAllTypes.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "optionalInt32": return self.optionalInt32
        case "optionalInt64": return self.optionalInt64
        case "optionalUint32": return self.optionalUint32
        case "optionalUint64": return self.optionalUint64
        case "optionalSint32": return self.optionalSint32
        case "optionalSint64": return self.optionalSint64
        case "optionalFixed32": return self.optionalFixed32
        case "optionalFixed64": return self.optionalFixed64
        case "optionalSfixed32": return self.optionalSfixed32
        case "optionalSfixed64": return self.optionalSfixed64
        case "optionalFloat": return self.optionalFloat
        case "optionalDouble": return self.optionalDouble
        case "optionalBool": return self.optionalBool
        case "optionalString": return self.optionalString
        case "optionalBytes": return self.optionalBytes
        case "optionalNestedMessage": return self.optionalNestedMessage
        case "optionalForeignMessage": return self.optionalForeignMessage
        case "optionalNestedEnum": return self.optionalNestedEnum
        case "optionalForeignEnum": return self.optionalForeignEnum
        case "optionalCord": return self.optionalCord
        case "repeatedInt32": return self.repeatedInt32
        case "repeatedInt64": return self.repeatedInt64
        case "repeatedUint32": return self.repeatedUint32
        case "repeatedUint64": return self.repeatedUint64
        case "repeatedSint32": return self.repeatedSint32
        case "repeatedSint64": return self.repeatedSint64
        case "repeatedFixed32": return self.repeatedFixed32
        case "repeatedFixed64": return self.repeatedFixed64
        case "repeatedSfixed32": return self.repeatedSfixed32
        case "repeatedSfixed64": return self.repeatedSfixed64
        case "repeatedFloat": return self.repeatedFloat
        case "repeatedDouble": return self.repeatedDouble
        case "repeatedBool": return self.repeatedBool
        case "repeatedString": return self.repeatedString
        case "repeatedBytes": return self.repeatedBytes
        case "repeatedNestedMessage": return self.repeatedNestedMessage
        case "repeatedNestedEnum": return self.repeatedNestedEnum
        case "repeatedCord": return self.repeatedCord
        case "oneofUint32": return self.oneofUint32
        case "oneofNestedMessage": return self.oneofNestedMessage
        case "oneofString": return self.oneofString
        case "oneofBytes": return self.oneofBytes
        case "oneofEnum": return self.oneofEnum
        case "mapStringToMessage": return self.mapStringToMessage
        case "mapInt32ToMessage": return self.mapInt32ToMessage
        case "mapInt64ToMessage": return self.mapInt64ToMessage
        case "mapBoolToMessage": return self.mapBoolToMessage
        case "mapStringToInt64": return self.mapStringToInt64
        case "mapInt64ToString": return self.mapInt64ToString
        case "anotherMapStringToMessage": return self.anotherMapStringToMessage
        case "packedRepeatedInt64": return self.packedRepeatedInt64
        default: return nil
        }
    }
}
extension Tensorflow.Test.TestAllTypes.NestedMessage: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Test.TestAllTypes.NestedMessage> {
        var mergedArray = Array<Tensorflow.Test.TestAllTypes.NestedMessage>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Test.TestAllTypes.NestedMessage? {
        return try Tensorflow.Test.TestAllTypes.NestedMessage.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Test.TestAllTypes.NestedMessage {
        return try Tensorflow.Test.TestAllTypes.NestedMessage.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.Test.TestRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.NestedMessage {
        return try Tensorflow.Test.TestAllTypes.NestedMessage.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Test.TestAllTypes.NestedMessage {
        return try Tensorflow.Test.TestAllTypes.NestedMessage.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.NestedMessage {
        return try Tensorflow.Test.TestAllTypes.NestedMessage.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Test.TestAllTypes.NestedMessage {
        return try Tensorflow.Test.TestAllTypes.NestedMessage.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.NestedMessage {
        return try Tensorflow.Test.TestAllTypes.NestedMessage.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "optionalInt32": return self.optionalInt32
        case "repeatedInt32": return self.repeatedInt32
        case "msg": return self.msg
        case "optionalInt64": return self.optionalInt64
        default: return nil
        }
    }
}
extension Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage> {
        var mergedArray = Array<Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage? {
        return try Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage {
        return try Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.Test.TestRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage {
        return try Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage {
        return try Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage {
        return try Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage {
        return try Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage {
        return try Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "optionalString": return self.optionalString
        default: return nil
        }
    }
}
extension Tensorflow.Test.TestAllTypes.MapStringToMessageEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Test.TestAllTypes.MapStringToMessageEntry> {
        var mergedArray = Array<Tensorflow.Test.TestAllTypes.MapStringToMessageEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Test.TestAllTypes.MapStringToMessageEntry? {
        return try Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Test.TestAllTypes.MapStringToMessageEntry {
        return try Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.Test.TestRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.MapStringToMessageEntry {
        return try Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Test.TestAllTypes.MapStringToMessageEntry {
        return try Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.MapStringToMessageEntry {
        return try Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Test.TestAllTypes.MapStringToMessageEntry {
        return try Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.MapStringToMessageEntry {
        return try Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry> {
        var mergedArray = Array<Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry? {
        return try Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry {
        return try Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.Test.TestRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry {
        return try Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry {
        return try Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry {
        return try Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry {
        return try Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry {
        return try Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry> {
        var mergedArray = Array<Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry? {
        return try Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry {
        return try Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.Test.TestRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry {
        return try Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry {
        return try Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry {
        return try Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry {
        return try Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry {
        return try Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry> {
        var mergedArray = Array<Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry? {
        return try Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry {
        return try Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.Test.TestRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry {
        return try Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry {
        return try Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry {
        return try Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry {
        return try Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry {
        return try Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.Test.TestAllTypes.MapStringToInt64Entry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Test.TestAllTypes.MapStringToInt64Entry> {
        var mergedArray = Array<Tensorflow.Test.TestAllTypes.MapStringToInt64Entry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Test.TestAllTypes.MapStringToInt64Entry? {
        return try Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Test.TestAllTypes.MapStringToInt64Entry {
        return try Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.Test.TestRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.MapStringToInt64Entry {
        return try Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Test.TestAllTypes.MapStringToInt64Entry {
        return try Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.MapStringToInt64Entry {
        return try Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Test.TestAllTypes.MapStringToInt64Entry {
        return try Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.MapStringToInt64Entry {
        return try Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry> {
        var mergedArray = Array<Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry? {
        return try Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry {
        return try Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.Test.TestRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry {
        return try Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry {
        return try Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry {
        return try Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry {
        return try Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry {
        return try Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry> {
        var mergedArray = Array<Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry? {
        return try Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry {
        return try Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.Test.TestRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry {
        return try Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry {
        return try Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry {
        return try Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry {
        return try Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry {
        return try Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.Test.TestAllTypes.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "optionalInt32": return self.optionalInt32
            case "optionalInt64": return self.optionalInt64
            case "optionalUint32": return self.optionalUint32
            case "optionalUint64": return self.optionalUint64
            case "optionalSint32": return self.optionalSint32
            case "optionalSint64": return self.optionalSint64
            case "optionalFixed32": return self.optionalFixed32
            case "optionalFixed64": return self.optionalFixed64
            case "optionalSfixed32": return self.optionalSfixed32
            case "optionalSfixed64": return self.optionalSfixed64
            case "optionalFloat": return self.optionalFloat
            case "optionalDouble": return self.optionalDouble
            case "optionalBool": return self.optionalBool
            case "optionalString": return self.optionalString
            case "optionalBytes": return self.optionalBytes
            case "optionalNestedMessage": return self.optionalNestedMessage
            case "optionalForeignMessage": return self.optionalForeignMessage
            case "optionalNestedEnum": return self.optionalNestedEnum
            case "optionalForeignEnum": return self.optionalForeignEnum
            case "optionalCord": return self.optionalCord
            case "repeatedInt32": return self.repeatedInt32
            case "repeatedInt64": return self.repeatedInt64
            case "repeatedUint32": return self.repeatedUint32
            case "repeatedUint64": return self.repeatedUint64
            case "repeatedSint32": return self.repeatedSint32
            case "repeatedSint64": return self.repeatedSint64
            case "repeatedFixed32": return self.repeatedFixed32
            case "repeatedFixed64": return self.repeatedFixed64
            case "repeatedSfixed32": return self.repeatedSfixed32
            case "repeatedSfixed64": return self.repeatedSfixed64
            case "repeatedFloat": return self.repeatedFloat
            case "repeatedDouble": return self.repeatedDouble
            case "repeatedBool": return self.repeatedBool
            case "repeatedString": return self.repeatedString
            case "repeatedBytes": return self.repeatedBytes
            case "repeatedNestedMessage": return self.repeatedNestedMessage
            case "repeatedNestedEnum": return self.repeatedNestedEnum
            case "repeatedCord": return self.repeatedCord
            case "oneofUint32": return self.oneofUint32
            case "oneofNestedMessage": return self.oneofNestedMessage
            case "oneofString": return self.oneofString
            case "oneofBytes": return self.oneofBytes
            case "oneofEnum": return self.oneofEnum
            case "mapStringToMessage": return self.mapStringToMessage
            case "mapInt32ToMessage": return self.mapInt32ToMessage
            case "mapInt64ToMessage": return self.mapInt64ToMessage
            case "mapBoolToMessage": return self.mapBoolToMessage
            case "mapStringToInt64": return self.mapStringToInt64
            case "mapInt64ToString": return self.mapInt64ToString
            case "anotherMapStringToMessage": return self.anotherMapStringToMessage
            case "packedRepeatedInt64": return self.packedRepeatedInt64
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "optionalInt32":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.optionalInt32 = newSubscriptValue
            case "optionalInt64":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.optionalInt64 = newSubscriptValue
            case "optionalUint32":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.optionalUint32 = newSubscriptValue
            case "optionalUint64":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.optionalUint64 = newSubscriptValue
            case "optionalSint32":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.optionalSint32 = newSubscriptValue
            case "optionalSint64":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.optionalSint64 = newSubscriptValue
            case "optionalFixed32":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.optionalFixed32 = newSubscriptValue
            case "optionalFixed64":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.optionalFixed64 = newSubscriptValue
            case "optionalSfixed32":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.optionalSfixed32 = newSubscriptValue
            case "optionalSfixed64":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.optionalSfixed64 = newSubscriptValue
            case "optionalFloat":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.optionalFloat = newSubscriptValue
            case "optionalDouble":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.optionalDouble = newSubscriptValue
            case "optionalBool":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.optionalBool = newSubscriptValue
            case "optionalString":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.optionalString = newSubscriptValue
            case "optionalBytes":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.optionalBytes = newSubscriptValue
            case "optionalNestedMessage":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Test.TestAllTypes.NestedMessage else {
                    return
                }
                self.optionalNestedMessage = newSubscriptValue
            case "optionalForeignMessage":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Test.ForeignMessage else {
                    return
                }
                self.optionalForeignMessage = newSubscriptValue
            case "optionalNestedEnum":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Test.TestAllTypes.NestedEnum else {
                    return
                }
                self.optionalNestedEnum = newSubscriptValue
            case "optionalForeignEnum":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Test.ForeignEnum else {
                    return
                }
                self.optionalForeignEnum = newSubscriptValue
            case "optionalCord":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.optionalCord = newSubscriptValue
            case "repeatedInt32":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int32> else {
                    return
                }
                self.repeatedInt32 = newSubscriptValue
            case "repeatedInt64":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.repeatedInt64 = newSubscriptValue
            case "repeatedUint32":
                guard let newSubscriptValue = newSubscriptValue as? Array<UInt32> else {
                    return
                }
                self.repeatedUint32 = newSubscriptValue
            case "repeatedUint64":
                guard let newSubscriptValue = newSubscriptValue as? Array<UInt64> else {
                    return
                }
                self.repeatedUint64 = newSubscriptValue
            case "repeatedSint32":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int32> else {
                    return
                }
                self.repeatedSint32 = newSubscriptValue
            case "repeatedSint64":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.repeatedSint64 = newSubscriptValue
            case "repeatedFixed32":
                guard let newSubscriptValue = newSubscriptValue as? Array<UInt32> else {
                    return
                }
                self.repeatedFixed32 = newSubscriptValue
            case "repeatedFixed64":
                guard let newSubscriptValue = newSubscriptValue as? Array<UInt64> else {
                    return
                }
                self.repeatedFixed64 = newSubscriptValue
            case "repeatedSfixed32":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int32> else {
                    return
                }
                self.repeatedSfixed32 = newSubscriptValue
            case "repeatedSfixed64":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.repeatedSfixed64 = newSubscriptValue
            case "repeatedFloat":
                guard let newSubscriptValue = newSubscriptValue as? Array<Float> else {
                    return
                }
                self.repeatedFloat = newSubscriptValue
            case "repeatedDouble":
                guard let newSubscriptValue = newSubscriptValue as? Array<Double> else {
                    return
                }
                self.repeatedDouble = newSubscriptValue
            case "repeatedBool":
                guard let newSubscriptValue = newSubscriptValue as? Array<Bool> else {
                    return
                }
                self.repeatedBool = newSubscriptValue
            case "repeatedString":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.repeatedString = newSubscriptValue
            case "repeatedBytes":
                guard let newSubscriptValue = newSubscriptValue as? Array<Data> else {
                    return
                }
                self.repeatedBytes = newSubscriptValue
            case "repeatedNestedMessage":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.Test.TestAllTypes.NestedMessage> else {
                    return
                }
                self.repeatedNestedMessage = newSubscriptValue
            case "repeatedNestedEnum":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.Test.TestAllTypes.NestedEnum> else {
                    return
                }
                self.repeatedNestedEnum = newSubscriptValue
            case "repeatedCord":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.repeatedCord = newSubscriptValue
            case "oneofUint32":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.oneofUint32 = newSubscriptValue
            case "oneofNestedMessage":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Test.TestAllTypes.NestedMessage else {
                    return
                }
                self.oneofNestedMessage = newSubscriptValue
            case "oneofString":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.oneofString = newSubscriptValue
            case "oneofBytes":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.oneofBytes = newSubscriptValue
            case "oneofEnum":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Test.TestAllTypes.NestedEnum else {
                    return
                }
                self.oneofEnum = newSubscriptValue
            case "mapStringToMessage":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,Tensorflow.Test.TestAllTypes.NestedMessage> else {
                    return
                }
                self.mapStringToMessage = newSubscriptValue
            case "mapInt32ToMessage":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<Int32,Tensorflow.Test.TestAllTypes.NestedMessage> else {
                    return
                }
                self.mapInt32ToMessage = newSubscriptValue
            case "mapInt64ToMessage":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<Int64,Tensorflow.Test.TestAllTypes.NestedMessage> else {
                    return
                }
                self.mapInt64ToMessage = newSubscriptValue
            case "mapBoolToMessage":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<Bool,Tensorflow.Test.TestAllTypes.NestedMessage> else {
                    return
                }
                self.mapBoolToMessage = newSubscriptValue
            case "mapStringToInt64":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,Int64> else {
                    return
                }
                self.mapStringToInt64 = newSubscriptValue
            case "mapInt64ToString":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<Int64,String> else {
                    return
                }
                self.mapInt64ToString = newSubscriptValue
            case "anotherMapStringToMessage":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,Tensorflow.Test.TestAllTypes.NestedMessage> else {
                    return
                }
                self.anotherMapStringToMessage = newSubscriptValue
            case "packedRepeatedInt64":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.packedRepeatedInt64 = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Test.TestAllTypes.NestedMessage.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "optionalInt32": return self.optionalInt32
            case "repeatedInt32": return self.repeatedInt32
            case "msg": return self.msg
            case "optionalInt64": return self.optionalInt64
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "optionalInt32":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.optionalInt32 = newSubscriptValue
            case "repeatedInt32":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int32> else {
                    return
                }
                self.repeatedInt32 = newSubscriptValue
            case "msg":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage else {
                    return
                }
                self.msg = newSubscriptValue
            case "optionalInt64":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.optionalInt64 = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Test.TestAllTypes.NestedMessage.DoubleNestedMessage.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "optionalString": return self.optionalString
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "optionalString":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.optionalString = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Test.TestAllTypes.MapStringToMessageEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Test.TestAllTypes.NestedMessage else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Test.TestAllTypes.MapInt32ToMessageEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Test.TestAllTypes.NestedMessage else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Test.TestAllTypes.MapInt64ToMessageEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Test.TestAllTypes.NestedMessage else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Test.TestAllTypes.MapBoolToMessageEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Test.TestAllTypes.NestedMessage else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Test.TestAllTypes.MapStringToInt64Entry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Test.TestAllTypes.MapInt64ToStringEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Test.TestAllTypes.AnotherMapStringToMessageEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Test.TestAllTypes.NestedMessage else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Test.NestedTestAllTypes: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Test.NestedTestAllTypes> {
        var mergedArray = Array<Tensorflow.Test.NestedTestAllTypes>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Test.NestedTestAllTypes? {
        return try Tensorflow.Test.NestedTestAllTypes.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Test.NestedTestAllTypes {
        return try Tensorflow.Test.NestedTestAllTypes.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.Test.TestRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.NestedTestAllTypes {
        return try Tensorflow.Test.NestedTestAllTypes.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Test.NestedTestAllTypes {
        return try Tensorflow.Test.NestedTestAllTypes.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.NestedTestAllTypes {
        return try Tensorflow.Test.NestedTestAllTypes.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Test.NestedTestAllTypes {
        return try Tensorflow.Test.NestedTestAllTypes.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.NestedTestAllTypes {
        return try Tensorflow.Test.NestedTestAllTypes.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "child": return self.child
        case "payload": return self.payload
        case "mapStringToInt64": return self.mapStringToInt64
        default: return nil
        }
    }
}
extension Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry> {
        var mergedArray = Array<Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry? {
        return try Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry {
        return try Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.Test.TestRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry {
        return try Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry {
        return try Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry {
        return try Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry {
        return try Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry {
        return try Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.Test.NestedTestAllTypes.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "child": return self.child
            case "payload": return self.payload
            case "mapStringToInt64": return self.mapStringToInt64
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "child":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Test.NestedTestAllTypes else {
                    return
                }
                self.child = newSubscriptValue
            case "payload":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Test.TestAllTypes else {
                    return
                }
                self.payload = newSubscriptValue
            case "mapStringToInt64":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,Int64> else {
                    return
                }
                self.mapStringToInt64 = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Test.NestedTestAllTypes.MapStringToInt64Entry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Test.ForeignMessage: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Test.ForeignMessage> {
        var mergedArray = Array<Tensorflow.Test.ForeignMessage>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Test.ForeignMessage? {
        return try Tensorflow.Test.ForeignMessage.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Test.ForeignMessage {
        return try Tensorflow.Test.ForeignMessage.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.Test.TestRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.ForeignMessage {
        return try Tensorflow.Test.ForeignMessage.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Test.ForeignMessage {
        return try Tensorflow.Test.ForeignMessage.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.ForeignMessage {
        return try Tensorflow.Test.ForeignMessage.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Test.ForeignMessage {
        return try Tensorflow.Test.ForeignMessage.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.ForeignMessage {
        return try Tensorflow.Test.ForeignMessage.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "c": return self.c
        default: return nil
        }
    }
}
extension Tensorflow.Test.ForeignMessage.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "c": return self.c
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "c":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.c = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Test.TestEmptyMessage: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Test.TestEmptyMessage> {
        var mergedArray = Array<Tensorflow.Test.TestEmptyMessage>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Test.TestEmptyMessage? {
        return try Tensorflow.Test.TestEmptyMessage.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Test.TestEmptyMessage {
        return try Tensorflow.Test.TestEmptyMessage.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.Test.TestRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestEmptyMessage {
        return try Tensorflow.Test.TestEmptyMessage.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Test.TestEmptyMessage {
        return try Tensorflow.Test.TestEmptyMessage.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestEmptyMessage {
        return try Tensorflow.Test.TestEmptyMessage.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Test.TestEmptyMessage {
        return try Tensorflow.Test.TestEmptyMessage.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Test.TestEmptyMessage {
        return try Tensorflow.Test.TestEmptyMessage.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Tensorflow.Test.TestEmptyMessage.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}

// @@protoc_insertion_point(global_scope)

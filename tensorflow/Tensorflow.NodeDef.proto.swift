/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "node_def.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { }

public extension Tensorflow {
    public struct NodeDefRoot {
        public static let `default` = NodeDefRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Tensorflow.AttrValueRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    final public class NodeDef : GeneratedMessage {

        public static func == (lhs: Tensorflow.NodeDef, rhs: Tensorflow.NodeDef) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
            fieldCheck = fieldCheck && (lhs.hasOp == rhs.hasOp) && (!lhs.hasOp || lhs.op == rhs.op)
            fieldCheck = fieldCheck && (lhs.input == rhs.input)
            fieldCheck = fieldCheck && (lhs.hasDevice == rhs.hasDevice) && (!lhs.hasDevice || lhs.device == rhs.device)
            fieldCheck = fieldCheck && (lhs.hasAttr == rhs.hasAttr) && (!lhs.hasAttr || lhs.attr == rhs.attr)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        final public class AttrEntry : GeneratedMessage {

            public static func == (lhs: Tensorflow.NodeDef.AttrEntry, rhs: Tensorflow.NodeDef.AttrEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:String = ""
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:Tensorflow.AttrValue!
            public fileprivate(set) var hasValue:Bool = false
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeString(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeMessage(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeStringSize(fieldNumber: 1)
                }
                if hasValue {
                    if let varSizevalue = value?.computeMessageSize(fieldNumber: 2) {
                        serialize_size += varSizevalue
                    }
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.NodeDef.AttrEntry.Builder {
                return Tensorflow.NodeDef.AttrEntry.classBuilder() as! Tensorflow.NodeDef.AttrEntry.Builder
            }
            public func getBuilder() -> Tensorflow.NodeDef.AttrEntry.Builder {
                return classBuilder() as! Tensorflow.NodeDef.AttrEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.NodeDef.AttrEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.NodeDef.AttrEntry.Builder()
            }
            public func toBuilder() throws -> Tensorflow.NodeDef.AttrEntry.Builder {
                return try Tensorflow.NodeDef.AttrEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.NodeDef.AttrEntry) throws -> Tensorflow.NodeDef.AttrEntry.Builder {
                return try Tensorflow.NodeDef.AttrEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = key
                }
                if hasValue {
                    jsonMap["value"] = try value.encode()
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.NodeDef.AttrEntry {
                return try Tensorflow.NodeDef.AttrEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.NodeDef.AttrEntry {
                return try Tensorflow.NodeDef.AttrEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value {\n"
                    if let outDescValue = value {
                        output += try outDescValue.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        if let hashValuevalue = value?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuevalue
                        }
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.NodeDef.AttrEntry"
            }
            override public func className() -> String {
                return "Tensorflow.NodeDef.AttrEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.NodeDef.AttrEntry = Tensorflow.NodeDef.AttrEntry()
                public func getMessage() -> Tensorflow.NodeDef.AttrEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:String {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:String) -> Tensorflow.NodeDef.AttrEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> Tensorflow.NodeDef.AttrEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = ""
                    return self
                }
                public var value:Tensorflow.AttrValue! {
                    get {
                        if valueBuilder_ != nil {
                            builderResult.value = valueBuilder_.getMessage()
                        }
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                fileprivate var valueBuilder_:Tensorflow.AttrValue.Builder! {
                    didSet {
                        builderResult.hasValue = true
                    }
                }
                public func getValueBuilder() -> Tensorflow.AttrValue.Builder {
                    if valueBuilder_ == nil {
                        valueBuilder_ = Tensorflow.AttrValue.Builder()
                        builderResult.value = valueBuilder_.getMessage()
                        if value != nil {
                            try! valueBuilder_.mergeFrom(other: value)
                        }
                    }
                    return valueBuilder_
                }
                @discardableResult
                public func setValue(_ value:Tensorflow.AttrValue!) -> Tensorflow.NodeDef.AttrEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func mergeValue(value:Tensorflow.AttrValue) throws -> Tensorflow.NodeDef.AttrEntry.Builder {
                    if builderResult.hasValue {
                        builderResult.value = try Tensorflow.AttrValue.builderWithPrototype(prototype:builderResult.value).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.value = value
                    }
                    builderResult.hasValue = true
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.NodeDef.AttrEntry.Builder {
                    valueBuilder_ = nil
                    builderResult.hasValue = false
                    builderResult.value = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.NodeDef.AttrEntry.Builder {
                    builderResult = Tensorflow.NodeDef.AttrEntry()
                    return self
                }
                override public func clone() throws -> Tensorflow.NodeDef.AttrEntry.Builder {
                    return try Tensorflow.NodeDef.AttrEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.NodeDef.AttrEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.NodeDef.AttrEntry {
                    let returnMe:Tensorflow.NodeDef.AttrEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.NodeDef.AttrEntry) throws -> Tensorflow.NodeDef.AttrEntry.Builder {
                    if other == Tensorflow.NodeDef.AttrEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if (other.hasValue) {
                        try mergeValue(value: other.value)
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.NodeDef.AttrEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.NodeDef.AttrEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            key = try codedInputStream.readString()

                        case 18:
                            let subBuilder:Tensorflow.AttrValue.Builder = Tensorflow.AttrValue.Builder()
                            if hasValue {
                                try subBuilder.mergeFrom(other: value)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            value = subBuilder.buildPartial()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.NodeDef.AttrEntry.Builder {
                    let resultDecodedBuilder = Tensorflow.NodeDef.AttrEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = jsonValueKey
                    }
                    if let jsonValueValue = jsonMap["value"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.value = try Tensorflow.AttrValue.Builder.decodeToBuilder(jsonMap:jsonValueValue).build()

                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.NodeDef.AttrEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.NodeDef.AttrEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        /// The name given to this operator. Used for naming inputs,
        /// logging, visualization, etc.  Unique within a single GraphDef.
        /// Must match the regexp "[A-Za-z0-9.][A-Za-z0-9_./]*".
        public fileprivate(set) var name:String = ""
        public fileprivate(set) var hasName:Bool = false

        /// The operation name.  There may be custom parameters in attrs.
        /// Op names starting with an underscore are reserved for internal use.
        public fileprivate(set) var op:String = ""
        public fileprivate(set) var hasOp:Bool = false

        /// Each input is "node:src_output" with "node" being a string name and
        /// "src_output" indicating which output tensor to use from "node". If
        /// "src_output" is 0 the ":0" suffix can be omitted.  Regular inputs
        /// may optionally be followed by control inputs that have the format
        /// "^node".
        public fileprivate(set) var input:Array<String> = Array<String>()
        /// A (possibly partial) specification for the device on which this
        /// node should be placed.
        /// The expected syntax for this string is as follows:
        /// DEVICE_SPEC ::= PARTIAL_SPEC
        /// PARTIAL_SPEC ::= ("/" CONSTRAINT) *
        /// CONSTRAINT ::= ("job:" JOB_NAME)
        ///              | ("replica:" [1-9][0-9]*)
        ///              | ("task:" [1-9][0-9]*)
        ///              | ( ("gpu" | "cpu") ":" ([1-9][0-9]* | "*") )
        /// Valid values for this string include:
        /// * "/job:worker/replica:0/task:1/gpu:3"  (full specification)
        /// * "/job:worker/gpu:3"                   (partial specification)
        /// * ""                                    (no specification)
        /// If the constraints do not resolve to a single device (or if this
        /// field is empty or not present), the runtime will attempt to
        /// choose a device automatically.
        public fileprivate(set) var device:String = ""
        public fileprivate(set) var hasDevice:Bool = false

        /// Operation-specific graph-construction-time configuration.
        /// Note that this should include all attrs defined in the
        /// corresponding OpDef, including those with a value matching
        /// the default -- this allows the default to change and makes
        /// NodeDefs easier to interpret on their own.  However, if
        /// an attr with a default is not specified in this list, the
        /// default will be used.
        /// The "names" (keys) must match the regexp "[a-z][a-z0-9_]+" (and
        /// one of the names from the corresponding OpDef's attr field).
        /// The values must have a type matching the corresponding OpDef
        /// attr's type field.
        /// TODO(josh11b): Add some examples here showing best practices.
        public fileprivate(set) var attr:Dictionary<String,Tensorflow.AttrValue> = Dictionary<String,Tensorflow.AttrValue>()

        public fileprivate(set) var hasAttr:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasName {
                try codedOutputStream.writeString(fieldNumber: 1, value:name)
            }
            if hasOp {
                try codedOutputStream.writeString(fieldNumber: 2, value:op)
            }
            if !input.isEmpty {
                for oneValueinput in input {
                    try codedOutputStream.writeString(fieldNumber: 3, value:oneValueinput)
                }
            }
            if hasDevice {
                try codedOutputStream.writeString(fieldNumber: 4, value:device)
            }
            if hasAttr {
                for (keyAttr, valueAttr) in attr {
                    let valueOfAttr = try! Tensorflow.NodeDef.AttrEntry.Builder().setKey(keyAttr).setValue(valueAttr).build()
                      try codedOutputStream.writeMessage(fieldNumber: 5, value:valueOfAttr)
                  }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasName {
                serialize_size += name.computeStringSize(fieldNumber: 1)
            }
            if hasOp {
                serialize_size += op.computeStringSize(fieldNumber: 2)
            }
            var dataSizeInput:Int32 = 0
            for oneValueinput in input {
                dataSizeInput += oneValueinput.computeStringSizeNoTag()
            }
            serialize_size += dataSizeInput
            serialize_size += 1 * Int32(input.count)
            if hasDevice {
                serialize_size += device.computeStringSize(fieldNumber: 4)
            }
            if hasAttr {
                  for (keyAttr, valueAttr) in attr {
                      let valueOfAttr = try! Tensorflow.NodeDef.AttrEntry.Builder().setKey(keyAttr).setValue(valueAttr).build()
                serialize_size += valueOfAttr.computeMessageSize(fieldNumber: 5)
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.NodeDef.Builder {
            return Tensorflow.NodeDef.classBuilder() as! Tensorflow.NodeDef.Builder
        }
        public func getBuilder() -> Tensorflow.NodeDef.Builder {
            return classBuilder() as! Tensorflow.NodeDef.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.NodeDef.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.NodeDef.Builder()
        }
        public func toBuilder() throws -> Tensorflow.NodeDef.Builder {
            return try Tensorflow.NodeDef.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.NodeDef) throws -> Tensorflow.NodeDef.Builder {
            return try Tensorflow.NodeDef.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasName {
                jsonMap["name"] = name
            }
            if hasOp {
                jsonMap["op"] = op
            }
            if !input.isEmpty {
                var jsonArrayInput:Array<String> = []
                for oneValueInput in input {
                    jsonArrayInput.append(oneValueInput)
                }
                jsonMap["input"] = jsonArrayInput
            }
            if hasDevice {
                jsonMap["device"] = device
            }
            if hasAttr {
                var mapAttr = Dictionary<String, Dictionary<String,Any>>()
                for (keyAttr, valueAttr) in attr {
                    mapAttr["\(keyAttr)"] = try valueAttr.encode()
                }
                jsonMap["attr"] = mapAttr
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.NodeDef {
            return try Tensorflow.NodeDef.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.NodeDef {
            return try Tensorflow.NodeDef.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasName {
                output += "\(indent) name: \(name) \n"
            }
            if hasOp {
                output += "\(indent) op: \(op) \n"
            }
            var inputElementIndex:Int = 0
            for oneValueInput in input  {
                output += "\(indent) input[\(inputElementIndex)]: \(oneValueInput)\n"
                inputElementIndex += 1
            }
            if hasDevice {
                output += "\(indent) device: \(device) \n"
            }
            if hasAttr {
                output += "\(indent) attr: \(attr) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasName {
                    hashCode = (hashCode &* 31) &+ name.hashValue
                }
                if hasOp {
                    hashCode = (hashCode &* 31) &+ op.hashValue
                }
                for oneValueInput in input {
                    hashCode = (hashCode &* 31) &+ oneValueInput.hashValue
                }
                if hasDevice {
                    hashCode = (hashCode &* 31) &+ device.hashValue
                }
                if hasAttr {
                    for (keyAttr, valueAttr) in attr {
                        hashCode = (hashCode &* 31) &+ keyAttr.hashValue
                        hashCode = (hashCode &* 31) &+ valueAttr.hashValue
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.NodeDef"
        }
        override public func className() -> String {
            return "Tensorflow.NodeDef"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.NodeDef = Tensorflow.NodeDef()
            public func getMessage() -> Tensorflow.NodeDef {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The name given to this operator. Used for naming inputs,
            /// logging, visualization, etc.  Unique within a single GraphDef.
            /// Must match the regexp "[A-Za-z0-9.][A-Za-z0-9_./]*".
            public var name:String {
                get {
                    return builderResult.name
                }
                set (value) {
                    builderResult.hasName = true
                    builderResult.name = value
                }
            }
            public var hasName:Bool {
                get {
                    return builderResult.hasName
                }
            }
            @discardableResult
            public func setName(_ value:String) -> Tensorflow.NodeDef.Builder {
                self.name = value
                return self
            }
            @discardableResult
            public func clearName() -> Tensorflow.NodeDef.Builder{
                builderResult.hasName = false
                builderResult.name = ""
                return self
            }
            /// The operation name.  There may be custom parameters in attrs.
            /// Op names starting with an underscore are reserved for internal use.
            public var op:String {
                get {
                    return builderResult.op
                }
                set (value) {
                    builderResult.hasOp = true
                    builderResult.op = value
                }
            }
            public var hasOp:Bool {
                get {
                    return builderResult.hasOp
                }
            }
            @discardableResult
            public func setOp(_ value:String) -> Tensorflow.NodeDef.Builder {
                self.op = value
                return self
            }
            @discardableResult
            public func clearOp() -> Tensorflow.NodeDef.Builder{
                builderResult.hasOp = false
                builderResult.op = ""
                return self
            }
            /// Each input is "node:src_output" with "node" being a string name and
            /// "src_output" indicating which output tensor to use from "node". If
            /// "src_output" is 0 the ":0" suffix can be omitted.  Regular inputs
            /// may optionally be followed by control inputs that have the format
            /// "^node".
            public var input:Array<String> {
                get {
                    return builderResult.input
                }
                set (array) {
                    builderResult.input = array
                }
            }
            @discardableResult
            public func setInput(_ value:Array<String>) -> Tensorflow.NodeDef.Builder {
                self.input = value
                return self
            }
            @discardableResult
            public func clearInput() -> Tensorflow.NodeDef.Builder {
                builderResult.input.removeAll(keepingCapacity: false)
                return self
            }
            /// A (possibly partial) specification for the device on which this
            /// node should be placed.
            /// The expected syntax for this string is as follows:
            /// DEVICE_SPEC ::= PARTIAL_SPEC
            /// PARTIAL_SPEC ::= ("/" CONSTRAINT) *
            /// CONSTRAINT ::= ("job:" JOB_NAME)
            ///              | ("replica:" [1-9][0-9]*)
            ///              | ("task:" [1-9][0-9]*)
            ///              | ( ("gpu" | "cpu") ":" ([1-9][0-9]* | "*") )
            /// Valid values for this string include:
            /// * "/job:worker/replica:0/task:1/gpu:3"  (full specification)
            /// * "/job:worker/gpu:3"                   (partial specification)
            /// * ""                                    (no specification)
            /// If the constraints do not resolve to a single device (or if this
            /// field is empty or not present), the runtime will attempt to
            /// choose a device automatically.
            public var device:String {
                get {
                    return builderResult.device
                }
                set (value) {
                    builderResult.hasDevice = true
                    builderResult.device = value
                }
            }
            public var hasDevice:Bool {
                get {
                    return builderResult.hasDevice
                }
            }
            @discardableResult
            public func setDevice(_ value:String) -> Tensorflow.NodeDef.Builder {
                self.device = value
                return self
            }
            @discardableResult
            public func clearDevice() -> Tensorflow.NodeDef.Builder{
                builderResult.hasDevice = false
                builderResult.device = ""
                return self
            }
            /// Operation-specific graph-construction-time configuration.
            /// Note that this should include all attrs defined in the
            /// corresponding OpDef, including those with a value matching
            /// the default -- this allows the default to change and makes
            /// NodeDefs easier to interpret on their own.  However, if
            /// an attr with a default is not specified in this list, the
            /// default will be used.
            /// The "names" (keys) must match the regexp "[a-z][a-z0-9_]+" (and
            /// one of the names from the corresponding OpDef's attr field).
            /// The values must have a type matching the corresponding OpDef
            /// attr's type field.
            /// TODO(josh11b): Add some examples here showing best practices.
            public var hasAttr:Bool {
                get {
                    return builderResult.hasAttr
                }
            }
            public var attr:Dictionary<String,Tensorflow.AttrValue> {
                get {
                    return builderResult.attr
                }
                set (value) {
                    builderResult.hasAttr = true
                    builderResult.attr = value
                }
            }
            @discardableResult
            public func setAttr(_ value:Dictionary<String,Tensorflow.AttrValue>) -> Tensorflow.NodeDef.Builder {
                self.attr = value
                return self
            }
            @discardableResult
            public func clearAttr() -> Tensorflow.NodeDef.Builder{
                builderResult.hasAttr = false
                builderResult.attr = Dictionary<String,Tensorflow.AttrValue>()
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.NodeDef.Builder {
                builderResult = Tensorflow.NodeDef()
                return self
            }
            override public func clone() throws -> Tensorflow.NodeDef.Builder {
                return try Tensorflow.NodeDef.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.NodeDef {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.NodeDef {
                let returnMe:Tensorflow.NodeDef = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.NodeDef) throws -> Tensorflow.NodeDef.Builder {
                if other == Tensorflow.NodeDef() {
                    return self
                }
                if other.hasName {
                    name = other.name
                }
                if other.hasOp {
                    op = other.op
                }
                if !other.input.isEmpty {
                    builderResult.input += other.input
                }
                if other.hasDevice {
                    device = other.device
                }
                if other.hasAttr {
                    attr = other.attr
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.NodeDef.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.NodeDef.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        name = try codedInputStream.readString()

                    case 18:
                        op = try codedInputStream.readString()

                    case 26:
                        input += [try codedInputStream.readString()]

                    case 34:
                        device = try codedInputStream.readString()

                    case 42:
                        let subBuilder = Tensorflow.NodeDef.AttrEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfAttr = subBuilder.buildPartial()
                        attr[buildOfAttr.key] = buildOfAttr.value

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.NodeDef.Builder {
                let resultDecodedBuilder = Tensorflow.NodeDef.Builder()
                if let jsonValueName = jsonMap["name"] as? String {
                    resultDecodedBuilder.name = jsonValueName
                }
                if let jsonValueOp = jsonMap["op"] as? String {
                    resultDecodedBuilder.op = jsonValueOp
                }
                if let jsonValueInput = jsonMap["input"] as? Array<String> {
                    var jsonArrayInput:Array<String> = []
                    for oneValueInput in jsonValueInput {
                        jsonArrayInput.append(oneValueInput)
                    }
                    resultDecodedBuilder.input = jsonArrayInput
                }
                if let jsonValueDevice = jsonMap["device"] as? String {
                    resultDecodedBuilder.device = jsonValueDevice
                }
                if let jsonValueAttr = jsonMap["attr"] as? Dictionary<String, Dictionary<String,Any>> {
                    var mapAttr = Dictionary<String, Tensorflow.AttrValue>()
                    for (keyAttr, valueAttr) in jsonValueAttr {
                        guard let keyFromAttr = String(keyAttr) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapAttr[keyFromAttr] = try Tensorflow.AttrValue.Builder.decodeToBuilder(jsonMap:valueAttr).build()

                    }
                    resultDecodedBuilder.attr = mapAttr
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.NodeDef.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.NodeDef.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.NodeDef: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.NodeDef> {
        var mergedArray = Array<Tensorflow.NodeDef>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.NodeDef? {
        return try Tensorflow.NodeDef.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.NodeDef {
        return try Tensorflow.NodeDef.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.NodeDefRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.NodeDef {
        return try Tensorflow.NodeDef.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.NodeDef {
        return try Tensorflow.NodeDef.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.NodeDef {
        return try Tensorflow.NodeDef.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.NodeDef {
        return try Tensorflow.NodeDef.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.NodeDef {
        return try Tensorflow.NodeDef.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "name": return self.name
        case "op": return self.op
        case "input": return self.input
        case "device": return self.device
        case "attr": return self.attr
        default: return nil
        }
    }
}
extension Tensorflow.NodeDef.AttrEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.NodeDef.AttrEntry> {
        var mergedArray = Array<Tensorflow.NodeDef.AttrEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.NodeDef.AttrEntry? {
        return try Tensorflow.NodeDef.AttrEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.NodeDef.AttrEntry {
        return try Tensorflow.NodeDef.AttrEntry.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.NodeDefRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.NodeDef.AttrEntry {
        return try Tensorflow.NodeDef.AttrEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.NodeDef.AttrEntry {
        return try Tensorflow.NodeDef.AttrEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.NodeDef.AttrEntry {
        return try Tensorflow.NodeDef.AttrEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.NodeDef.AttrEntry {
        return try Tensorflow.NodeDef.AttrEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.NodeDef.AttrEntry {
        return try Tensorflow.NodeDef.AttrEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.NodeDef.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "name": return self.name
            case "op": return self.op
            case "input": return self.input
            case "device": return self.device
            case "attr": return self.attr
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "op":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.op = newSubscriptValue
            case "input":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.input = newSubscriptValue
            case "device":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.device = newSubscriptValue
            case "attr":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,Tensorflow.AttrValue> else {
                    return
                }
                self.attr = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.NodeDef.AttrEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.AttrValue else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

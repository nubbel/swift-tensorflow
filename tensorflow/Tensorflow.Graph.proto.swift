/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "graph.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { }

public extension Tensorflow {
    public struct GraphRoot {
        public static let `default` = GraphRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Tensorflow.NodeDefRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.FunctionRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.VersionsRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    /// Represents the graph of operations
    final public class GraphDef : GeneratedMessage {

        public static func == (lhs: Tensorflow.GraphDef, rhs: Tensorflow.GraphDef) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.node == rhs.node)
            fieldCheck = fieldCheck && (lhs.hasLibrary == rhs.hasLibrary) && (!lhs.hasLibrary || lhs.library == rhs.library)
            fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
            fieldCheck = fieldCheck && (lhs.hasVersions == rhs.hasVersions) && (!lhs.hasVersions || lhs.versions == rhs.versions)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var node:Array<Tensorflow.NodeDef>  = Array<Tensorflow.NodeDef>()
        public fileprivate(set) var versions:Tensorflow.VersionDef!
        public fileprivate(set) var hasVersions:Bool = false
        /// Deprecated single version field; use versions above instead.  Since all
        /// GraphDef changes before "versions" was introduced were forward
        /// compatible, this field is entirely ignored.
        @available(*, deprecated:0.1, message:"version is marked as \"Deprecated\"")
        public fileprivate(set) var version:Int32 = Int32(0)
        public fileprivate(set) var hasVersion:Bool = false

        public fileprivate(set) var library:Tensorflow.FunctionDefLibrary!
        public fileprivate(set) var hasLibrary:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementNode in node {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementNode)
            }
            if hasLibrary {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:library)
            }
            if hasVersion {
                try codedOutputStream.writeInt32(fieldNumber: 3, value:version)
            }
            if hasVersions {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:versions)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementNode in node {
                serialize_size += oneElementNode.computeMessageSize(fieldNumber: 1)
            }
            if hasLibrary {
                if let varSizelibrary = library?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizelibrary
                }
            }
            if hasVersion {
                serialize_size += version.computeInt32Size(fieldNumber: 3)
            }
            if hasVersions {
                if let varSizeversions = versions?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizeversions
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.GraphDef.Builder {
            return Tensorflow.GraphDef.classBuilder() as! Tensorflow.GraphDef.Builder
        }
        public func getBuilder() -> Tensorflow.GraphDef.Builder {
            return classBuilder() as! Tensorflow.GraphDef.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.GraphDef.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.GraphDef.Builder()
        }
        public func toBuilder() throws -> Tensorflow.GraphDef.Builder {
            return try Tensorflow.GraphDef.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.GraphDef) throws -> Tensorflow.GraphDef.Builder {
            return try Tensorflow.GraphDef.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !node.isEmpty {
                var jsonArrayNode:Array<Dictionary<String,Any>> = []
                for oneValueNode in node {
                    let ecodedMessageNode = try oneValueNode.encode()
                    jsonArrayNode.append(ecodedMessageNode)
                }
                jsonMap["node"] = jsonArrayNode
            }
            if hasVersions {
                jsonMap["versions"] = try versions.encode()
            }
            if hasVersion {
                jsonMap["version"] = Int(version)
            }
            if hasLibrary {
                jsonMap["library"] = try library.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.GraphDef {
            return try Tensorflow.GraphDef.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.GraphDef {
            return try Tensorflow.GraphDef.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var nodeElementIndex:Int = 0
            for oneElementNode in node {
                output += "\(indent) node[\(nodeElementIndex)] {\n"
                output += try oneElementNode.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                nodeElementIndex += 1
            }
            if hasLibrary {
                output += "\(indent) library {\n"
                if let outDescLibrary = library {
                    output += try outDescLibrary.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasVersion {
                output += "\(indent) version: \(version) \n"
            }
            if hasVersions {
                output += "\(indent) versions {\n"
                if let outDescVersions = versions {
                    output += try outDescVersions.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementNode in node {
                    hashCode = (hashCode &* 31) &+ oneElementNode.hashValue
                }
                if hasLibrary {
                    if let hashValuelibrary = library?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuelibrary
                    }
                }
                if hasVersion {
                    hashCode = (hashCode &* 31) &+ version.hashValue
                }
                if hasVersions {
                    if let hashValueversions = versions?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueversions
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.GraphDef"
        }
        override public func className() -> String {
            return "Tensorflow.GraphDef"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.GraphDef = Tensorflow.GraphDef()
            public func getMessage() -> Tensorflow.GraphDef {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var node:Array<Tensorflow.NodeDef> {
                get {
                    return builderResult.node
                }
                set (value) {
                    builderResult.node = value
                }
            }
            @discardableResult
            public func setNode(_ value:Array<Tensorflow.NodeDef>) -> Tensorflow.GraphDef.Builder {
                self.node = value
                return self
            }
            @discardableResult
            public func clearNode() -> Tensorflow.GraphDef.Builder {
                builderResult.node.removeAll(keepingCapacity: false)
                return self
            }
            /// Compatibility versions of the graph.  See core/public/version.h for version
            /// history.  The GraphDef version is distinct from the TensorFlow version, and
            /// each release of TensorFlow will support a range of GraphDef versions.
            public var versions:Tensorflow.VersionDef! {
                get {
                    if versionsBuilder_ != nil {
                        builderResult.versions = versionsBuilder_.getMessage()
                    }
                    return builderResult.versions
                }
                set (value) {
                    builderResult.hasVersions = true
                    builderResult.versions = value
                }
            }
            public var hasVersions:Bool {
                get {
                    return builderResult.hasVersions
                }
            }
            fileprivate var versionsBuilder_:Tensorflow.VersionDef.Builder! {
                didSet {
                    builderResult.hasVersions = true
                }
            }
            public func getVersionsBuilder() -> Tensorflow.VersionDef.Builder {
                if versionsBuilder_ == nil {
                    versionsBuilder_ = Tensorflow.VersionDef.Builder()
                    builderResult.versions = versionsBuilder_.getMessage()
                    if versions != nil {
                        try! versionsBuilder_.mergeFrom(other: versions)
                    }
                }
                return versionsBuilder_
            }
            @discardableResult
            public func setVersions(_ value:Tensorflow.VersionDef!) -> Tensorflow.GraphDef.Builder {
                self.versions = value
                return self
            }
            @discardableResult
            public func mergeVersions(value:Tensorflow.VersionDef) throws -> Tensorflow.GraphDef.Builder {
                if builderResult.hasVersions {
                    builderResult.versions = try Tensorflow.VersionDef.builderWithPrototype(prototype:builderResult.versions).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.versions = value
                }
                builderResult.hasVersions = true
                return self
            }
            @discardableResult
            public func clearVersions() -> Tensorflow.GraphDef.Builder {
                versionsBuilder_ = nil
                builderResult.hasVersions = false
                builderResult.versions = nil
                return self
            }
            /// Deprecated single version field; use versions above instead.  Since all
            /// GraphDef changes before "versions" was introduced were forward
            /// compatible, this field is entirely ignored.
            public var version:Int32 {
                get {
                    return builderResult.version
                }
                set (value) {
                    builderResult.hasVersion = true
                    builderResult.version = value
                }
            }
            public var hasVersion:Bool {
                get {
                    return builderResult.hasVersion
                }
            }
            @discardableResult
            public func setVersion(_ value:Int32) -> Tensorflow.GraphDef.Builder {
                self.version = value
                return self
            }
            @discardableResult
            public func clearVersion() -> Tensorflow.GraphDef.Builder{
                builderResult.hasVersion = false
                builderResult.version = Int32(0)
                return self
            }
            /// EXPERIMENTAL. DO NOT USE OR DEPEND ON THIS YET.
            /// "library" provides user-defined functions.
            /// Naming:
            ///   * library.function.name are in a flat namespace.
            ///     NOTE: We may need to change it to be hierarchical to support
            ///     different orgs. E.g.,
            ///     { "/google/nn", { ... }},
            ///     { "/google/vision", { ... }}
            ///     { "/org_foo/module_bar", { ... }}
            ///     map<string, FunctionDefLib> named_lib;
            ///   * If node[i].op is the name of one function in "library",
            ///     node[i] is deemed as a function call. Otherwise, node[i].op
            ///     must be a primitive operation supported by the runtime.
            /// Function call semantics:
            ///   * The callee may start execution as soon as some of its inputs
            ///     are ready. The caller may want to use Tuple() mechanism to
            ///     ensure all inputs are ready in the same time.
            ///   * The consumer of return values may start executing as soon as
            ///     the return values the consumer depends on are ready.  The
            ///     consumer may want to use Tuple() mechanism to ensure the
            ///     consumer does not start until all return values of the callee
            ///     function are ready.
            public var library:Tensorflow.FunctionDefLibrary! {
                get {
                    if libraryBuilder_ != nil {
                        builderResult.library = libraryBuilder_.getMessage()
                    }
                    return builderResult.library
                }
                set (value) {
                    builderResult.hasLibrary = true
                    builderResult.library = value
                }
            }
            public var hasLibrary:Bool {
                get {
                    return builderResult.hasLibrary
                }
            }
            fileprivate var libraryBuilder_:Tensorflow.FunctionDefLibrary.Builder! {
                didSet {
                    builderResult.hasLibrary = true
                }
            }
            public func getLibraryBuilder() -> Tensorflow.FunctionDefLibrary.Builder {
                if libraryBuilder_ == nil {
                    libraryBuilder_ = Tensorflow.FunctionDefLibrary.Builder()
                    builderResult.library = libraryBuilder_.getMessage()
                    if library != nil {
                        try! libraryBuilder_.mergeFrom(other: library)
                    }
                }
                return libraryBuilder_
            }
            @discardableResult
            public func setLibrary(_ value:Tensorflow.FunctionDefLibrary!) -> Tensorflow.GraphDef.Builder {
                self.library = value
                return self
            }
            @discardableResult
            public func mergeLibrary(value:Tensorflow.FunctionDefLibrary) throws -> Tensorflow.GraphDef.Builder {
                if builderResult.hasLibrary {
                    builderResult.library = try Tensorflow.FunctionDefLibrary.builderWithPrototype(prototype:builderResult.library).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.library = value
                }
                builderResult.hasLibrary = true
                return self
            }
            @discardableResult
            public func clearLibrary() -> Tensorflow.GraphDef.Builder {
                libraryBuilder_ = nil
                builderResult.hasLibrary = false
                builderResult.library = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.GraphDef.Builder {
                builderResult = Tensorflow.GraphDef()
                return self
            }
            override public func clone() throws -> Tensorflow.GraphDef.Builder {
                return try Tensorflow.GraphDef.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.GraphDef {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.GraphDef {
                let returnMe:Tensorflow.GraphDef = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.GraphDef) throws -> Tensorflow.GraphDef.Builder {
                if other == Tensorflow.GraphDef() {
                    return self
                }
                if !other.node.isEmpty  {
                     builderResult.node += other.node
                }
                if (other.hasVersions) {
                    try mergeVersions(value: other.versions)
                }
                if other.hasVersion {
                    version = other.version
                }
                if (other.hasLibrary) {
                    try mergeLibrary(value: other.library)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.GraphDef.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphDef.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Tensorflow.NodeDef.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        node.append(subBuilder.buildPartial())

                    case 18:
                        let subBuilder:Tensorflow.FunctionDefLibrary.Builder = Tensorflow.FunctionDefLibrary.Builder()
                        if hasLibrary {
                            try subBuilder.mergeFrom(other: library)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        library = subBuilder.buildPartial()

                    case 24:
                        version = try codedInputStream.readInt32()

                    case 34:
                        let subBuilder:Tensorflow.VersionDef.Builder = Tensorflow.VersionDef.Builder()
                        if hasVersions {
                            try subBuilder.mergeFrom(other: versions)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        versions = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.GraphDef.Builder {
                let resultDecodedBuilder = Tensorflow.GraphDef.Builder()
                if let jsonValueNode = jsonMap["node"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayNode:Array<Tensorflow.NodeDef> = []
                    for oneValueNode in jsonValueNode {
                        let messageFromStringNode = try Tensorflow.NodeDef.Builder.decodeToBuilder(jsonMap:oneValueNode).build()

                        jsonArrayNode.append(messageFromStringNode)
                    }
                    resultDecodedBuilder.node = jsonArrayNode
                }
                if let jsonValueVersions = jsonMap["versions"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.versions = try Tensorflow.VersionDef.Builder.decodeToBuilder(jsonMap:jsonValueVersions).build()

                }
                if let jsonValueVersion = jsonMap["version"] as? Int {
                    resultDecodedBuilder.version = Int32(jsonValueVersion)
                } else if let jsonValueVersion = jsonMap["version"] as? String {
                    resultDecodedBuilder.version = Int32(jsonValueVersion)!
                }
                if let jsonValueLibrary = jsonMap["library"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.library = try Tensorflow.FunctionDefLibrary.Builder.decodeToBuilder(jsonMap:jsonValueLibrary).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.GraphDef.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.GraphDef.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.GraphDef: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.GraphDef> {
        var mergedArray = Array<Tensorflow.GraphDef>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.GraphDef? {
        return try Tensorflow.GraphDef.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.GraphDef {
        return try Tensorflow.GraphDef.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.GraphRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphDef {
        return try Tensorflow.GraphDef.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.GraphDef {
        return try Tensorflow.GraphDef.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphDef {
        return try Tensorflow.GraphDef.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.GraphDef {
        return try Tensorflow.GraphDef.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GraphDef {
        return try Tensorflow.GraphDef.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "node": return self.node
        case "versions": return self.versions
        case "version": return self.version
        case "library": return self.library
        default: return nil
        }
    }
}
extension Tensorflow.GraphDef.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "node": return self.node
            case "versions": return self.versions
            case "version": return self.version
            case "library": return self.library
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "node":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.NodeDef> else {
                    return
                }
                self.node = newSubscriptValue
            case "versions":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.VersionDef else {
                    return
                }
                self.versions = newSubscriptValue
            case "version":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.version = newSubscriptValue
            case "library":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.FunctionDefLibrary else {
                    return
                }
                self.library = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

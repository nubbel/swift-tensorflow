/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "learner.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { public struct BoostedTrees { public struct Learner { }}}

public extension Tensorflow.BoostedTrees.Learner {
    public struct LearnerRoot {
        public static let `default` = LearnerRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    /// Tree regularization config.
    final public class TreeRegularizationConfig : GeneratedMessage {

        public static func == (lhs: Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig, rhs: Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasL1 == rhs.hasL1) && (!lhs.hasL1 || lhs.l1 == rhs.l1)
            fieldCheck = fieldCheck && (lhs.hasL2 == rhs.hasL2) && (!lhs.hasL2 || lhs.l2 == rhs.l2)
            fieldCheck = fieldCheck && (lhs.hasTreeComplexity == rhs.hasTreeComplexity) && (!lhs.hasTreeComplexity || lhs.treeComplexity == rhs.treeComplexity)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Classic L1/L2.
        public fileprivate(set) var l1:Float = Float(0)
        public fileprivate(set) var hasL1:Bool = false

        public fileprivate(set) var l2:Float = Float(0)
        public fileprivate(set) var hasL2:Bool = false

        /// Tree complexity penalizes overall model complexity effectively
        /// limiting how deep the tree can grow in regions with small gain.
        public fileprivate(set) var treeComplexity:Float = Float(0)
        public fileprivate(set) var hasTreeComplexity:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasL1 {
                try codedOutputStream.writeFloat(fieldNumber: 1, value:l1)
            }
            if hasL2 {
                try codedOutputStream.writeFloat(fieldNumber: 2, value:l2)
            }
            if hasTreeComplexity {
                try codedOutputStream.writeFloat(fieldNumber: 3, value:treeComplexity)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasL1 {
                serialize_size += l1.computeFloatSize(fieldNumber: 1)
            }
            if hasL2 {
                serialize_size += l2.computeFloatSize(fieldNumber: 2)
            }
            if hasTreeComplexity {
                serialize_size += treeComplexity.computeFloatSize(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder {
            return Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.classBuilder() as! Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder
        }
        public func getBuilder() -> Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder {
            return classBuilder() as! Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder()
        }
        public func toBuilder() throws -> Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder {
            return try Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig) throws -> Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder {
            return try Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasL1 {
                jsonMap["l1"] = Float(l1)
            }
            if hasL2 {
                jsonMap["l2"] = Float(l2)
            }
            if hasTreeComplexity {
                jsonMap["treeComplexity"] = Float(treeComplexity)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig {
            return try Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig {
            return try Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasL1 {
                output += "\(indent) l1: \(l1) \n"
            }
            if hasL2 {
                output += "\(indent) l2: \(l2) \n"
            }
            if hasTreeComplexity {
                output += "\(indent) treeComplexity: \(treeComplexity) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasL1 {
                    hashCode = (hashCode &* 31) &+ l1.hashValue
                }
                if hasL2 {
                    hashCode = (hashCode &* 31) &+ l2.hashValue
                }
                if hasTreeComplexity {
                    hashCode = (hashCode &* 31) &+ treeComplexity.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig"
        }
        override public func className() -> String {
            return "Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig = Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig()
            public func getMessage() -> Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Classic L1/L2.
            public var l1:Float {
                get {
                    return builderResult.l1
                }
                set (value) {
                    builderResult.hasL1 = true
                    builderResult.l1 = value
                }
            }
            public var hasL1:Bool {
                get {
                    return builderResult.hasL1
                }
            }
            @discardableResult
            public func setL1(_ value:Float) -> Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder {
                self.l1 = value
                return self
            }
            @discardableResult
            public func clearL1() -> Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder{
                builderResult.hasL1 = false
                builderResult.l1 = Float(0)
                return self
            }
            public var l2:Float {
                get {
                    return builderResult.l2
                }
                set (value) {
                    builderResult.hasL2 = true
                    builderResult.l2 = value
                }
            }
            public var hasL2:Bool {
                get {
                    return builderResult.hasL2
                }
            }
            @discardableResult
            public func setL2(_ value:Float) -> Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder {
                self.l2 = value
                return self
            }
            @discardableResult
            public func clearL2() -> Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder{
                builderResult.hasL2 = false
                builderResult.l2 = Float(0)
                return self
            }
            /// Tree complexity penalizes overall model complexity effectively
            /// limiting how deep the tree can grow in regions with small gain.
            public var treeComplexity:Float {
                get {
                    return builderResult.treeComplexity
                }
                set (value) {
                    builderResult.hasTreeComplexity = true
                    builderResult.treeComplexity = value
                }
            }
            public var hasTreeComplexity:Bool {
                get {
                    return builderResult.hasTreeComplexity
                }
            }
            @discardableResult
            public func setTreeComplexity(_ value:Float) -> Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder {
                self.treeComplexity = value
                return self
            }
            @discardableResult
            public func clearTreeComplexity() -> Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder{
                builderResult.hasTreeComplexity = false
                builderResult.treeComplexity = Float(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder {
                builderResult = Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig()
                return self
            }
            override public func clone() throws -> Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder {
                return try Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig {
                let returnMe:Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig) throws -> Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder {
                if other == Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig() {
                    return self
                }
                if other.hasL1 {
                    l1 = other.l1
                }
                if other.hasL2 {
                    l2 = other.l2
                }
                if other.hasTreeComplexity {
                    treeComplexity = other.treeComplexity
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 13:
                        l1 = try codedInputStream.readFloat()

                    case 21:
                        l2 = try codedInputStream.readFloat()

                    case 29:
                        treeComplexity = try codedInputStream.readFloat()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder {
                let resultDecodedBuilder = Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder()
                if let jsonValueL1 = jsonMap["l1"] as? Float {
                    resultDecodedBuilder.l1 = Float(jsonValueL1)
                } else if let jsonValueL1 = jsonMap["l1"] as? String {
                    resultDecodedBuilder.l1 = Float(jsonValueL1)!
                }
                if let jsonValueL2 = jsonMap["l2"] as? Float {
                    resultDecodedBuilder.l2 = Float(jsonValueL2)
                } else if let jsonValueL2 = jsonMap["l2"] as? String {
                    resultDecodedBuilder.l2 = Float(jsonValueL2)!
                }
                if let jsonValueTreeComplexity = jsonMap["treeComplexity"] as? Float {
                    resultDecodedBuilder.treeComplexity = Float(jsonValueTreeComplexity)
                } else if let jsonValueTreeComplexity = jsonMap["treeComplexity"] as? String {
                    resultDecodedBuilder.treeComplexity = Float(jsonValueTreeComplexity)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Tree constraints config.
    final public class TreeConstraintsConfig : GeneratedMessage {

        public static func == (lhs: Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig, rhs: Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasMaxTreeDepth == rhs.hasMaxTreeDepth) && (!lhs.hasMaxTreeDepth || lhs.maxTreeDepth == rhs.maxTreeDepth)
            fieldCheck = fieldCheck && (lhs.hasMinNodeWeight == rhs.hasMinNodeWeight) && (!lhs.hasMinNodeWeight || lhs.minNodeWeight == rhs.minNodeWeight)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Maximum depth of the trees.
        public fileprivate(set) var maxTreeDepth:UInt32 = UInt32(0)
        public fileprivate(set) var hasMaxTreeDepth:Bool = false

        /// Min hessian weight per node.
        public fileprivate(set) var minNodeWeight:Float = Float(0)
        public fileprivate(set) var hasMinNodeWeight:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasMaxTreeDepth {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:maxTreeDepth)
            }
            if hasMinNodeWeight {
                try codedOutputStream.writeFloat(fieldNumber: 2, value:minNodeWeight)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasMaxTreeDepth {
                serialize_size += maxTreeDepth.computeUInt32Size(fieldNumber: 1)
            }
            if hasMinNodeWeight {
                serialize_size += minNodeWeight.computeFloatSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder {
            return Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.classBuilder() as! Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder
        }
        public func getBuilder() -> Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder {
            return classBuilder() as! Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder()
        }
        public func toBuilder() throws -> Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder {
            return try Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig) throws -> Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder {
            return try Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasMaxTreeDepth {
                jsonMap["maxTreeDepth"] = UInt(maxTreeDepth)
            }
            if hasMinNodeWeight {
                jsonMap["minNodeWeight"] = Float(minNodeWeight)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig {
            return try Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig {
            return try Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasMaxTreeDepth {
                output += "\(indent) maxTreeDepth: \(maxTreeDepth) \n"
            }
            if hasMinNodeWeight {
                output += "\(indent) minNodeWeight: \(minNodeWeight) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasMaxTreeDepth {
                    hashCode = (hashCode &* 31) &+ maxTreeDepth.hashValue
                }
                if hasMinNodeWeight {
                    hashCode = (hashCode &* 31) &+ minNodeWeight.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig"
        }
        override public func className() -> String {
            return "Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig = Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig()
            public func getMessage() -> Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Maximum depth of the trees.
            public var maxTreeDepth:UInt32 {
                get {
                    return builderResult.maxTreeDepth
                }
                set (value) {
                    builderResult.hasMaxTreeDepth = true
                    builderResult.maxTreeDepth = value
                }
            }
            public var hasMaxTreeDepth:Bool {
                get {
                    return builderResult.hasMaxTreeDepth
                }
            }
            @discardableResult
            public func setMaxTreeDepth(_ value:UInt32) -> Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder {
                self.maxTreeDepth = value
                return self
            }
            @discardableResult
            public func clearMaxTreeDepth() -> Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder{
                builderResult.hasMaxTreeDepth = false
                builderResult.maxTreeDepth = UInt32(0)
                return self
            }
            /// Min hessian weight per node.
            public var minNodeWeight:Float {
                get {
                    return builderResult.minNodeWeight
                }
                set (value) {
                    builderResult.hasMinNodeWeight = true
                    builderResult.minNodeWeight = value
                }
            }
            public var hasMinNodeWeight:Bool {
                get {
                    return builderResult.hasMinNodeWeight
                }
            }
            @discardableResult
            public func setMinNodeWeight(_ value:Float) -> Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder {
                self.minNodeWeight = value
                return self
            }
            @discardableResult
            public func clearMinNodeWeight() -> Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder{
                builderResult.hasMinNodeWeight = false
                builderResult.minNodeWeight = Float(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder {
                builderResult = Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig()
                return self
            }
            override public func clone() throws -> Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder {
                return try Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig {
                let returnMe:Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig) throws -> Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder {
                if other == Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig() {
                    return self
                }
                if other.hasMaxTreeDepth {
                    maxTreeDepth = other.maxTreeDepth
                }
                if other.hasMinNodeWeight {
                    minNodeWeight = other.minNodeWeight
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        maxTreeDepth = try codedInputStream.readUInt32()

                    case 21:
                        minNodeWeight = try codedInputStream.readFloat()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder {
                let resultDecodedBuilder = Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder()
                if let jsonValueMaxTreeDepth = jsonMap["maxTreeDepth"] as? UInt {
                    resultDecodedBuilder.maxTreeDepth = UInt32(jsonValueMaxTreeDepth)
                } else if let jsonValueMaxTreeDepth = jsonMap["maxTreeDepth"] as? String {
                    resultDecodedBuilder.maxTreeDepth = UInt32(jsonValueMaxTreeDepth)!
                }
                if let jsonValueMinNodeWeight = jsonMap["minNodeWeight"] as? Float {
                    resultDecodedBuilder.minNodeWeight = Float(jsonValueMinNodeWeight)
                } else if let jsonValueMinNodeWeight = jsonMap["minNodeWeight"] as? String {
                    resultDecodedBuilder.minNodeWeight = Float(jsonValueMinNodeWeight)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// LearningRateConfig describes all supported learning rate tuners.
    final public class LearningRateConfig : GeneratedMessage {

        public static func == (lhs: Tensorflow.BoostedTrees.Learner.LearningRateConfig, rhs: Tensorflow.BoostedTrees.Learner.LearningRateConfig) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasFixed == rhs.hasFixed) && (!lhs.hasFixed || lhs.fixed == rhs.fixed)
            fieldCheck = fieldCheck && (lhs.hasDropout == rhs.hasDropout) && (!lhs.hasDropout || lhs.dropout == rhs.dropout)
            fieldCheck = fieldCheck && (lhs.hasLineSearch == rhs.hasLineSearch) && (!lhs.hasLineSearch || lhs.lineSearch == rhs.lineSearch)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //OneOf declaration start

        public enum Tuner {
            case OneOfTunerNotSet

            public func checkOneOfIsSet() -> Bool {
                switch self {
                case .OneOfTunerNotSet: return false
                default: return true
                }
            }
            case Fixed(Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig)

            public static func getFixed(_ value:Tuner) -> Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig? {
                switch value {
                case .Fixed(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case Dropout(Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig)

            public static func getDropout(_ value:Tuner) -> Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig? {
                switch value {
                case .Dropout(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case LineSearch(Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig)

            public static func getLineSearch(_ value:Tuner) -> Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig? {
                switch value {
                case .LineSearch(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
        }
        //OneOf declaration end

        fileprivate var storageTuner:LearningRateConfig.Tuner =  LearningRateConfig.Tuner.OneOfTunerNotSet
        public func getOneOfTuner() ->  LearningRateConfig.Tuner {
            let copyObjectTuner = storageTuner
            return copyObjectTuner
        }
        public fileprivate(set) var fixed:Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig!{
            get {
                return LearningRateConfig.Tuner.getFixed(storageTuner)
            }
            set (newvalue) {
                storageTuner = LearningRateConfig.Tuner.Fixed(newvalue)
            }
        }
        public fileprivate(set) var hasFixed:Bool {
            get {
                guard let _ = LearningRateConfig.Tuner.getFixed(storageTuner) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var dropout:Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig!{
            get {
                return LearningRateConfig.Tuner.getDropout(storageTuner)
            }
            set (newvalue) {
                storageTuner = LearningRateConfig.Tuner.Dropout(newvalue)
            }
        }
        public fileprivate(set) var hasDropout:Bool {
            get {
                guard let _ = LearningRateConfig.Tuner.getDropout(storageTuner) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var lineSearch:Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig!{
            get {
                return LearningRateConfig.Tuner.getLineSearch(storageTuner)
            }
            set (newvalue) {
                storageTuner = LearningRateConfig.Tuner.LineSearch(newvalue)
            }
        }
        public fileprivate(set) var hasLineSearch:Bool {
            get {
                guard let _ = LearningRateConfig.Tuner.getLineSearch(storageTuner) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasFixed {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:fixed)
            }
            if hasDropout {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:dropout)
            }
            if hasLineSearch {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:lineSearch)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasFixed {
                if let varSizefixed = fixed?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizefixed
                }
            }
            if hasDropout {
                if let varSizedropout = dropout?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizedropout
                }
            }
            if hasLineSearch {
                if let varSizelineSearch = lineSearch?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizelineSearch
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder {
            return Tensorflow.BoostedTrees.Learner.LearningRateConfig.classBuilder() as! Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder
        }
        public func getBuilder() -> Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder {
            return classBuilder() as! Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder()
        }
        public func toBuilder() throws -> Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder {
            return try Tensorflow.BoostedTrees.Learner.LearningRateConfig.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.BoostedTrees.Learner.LearningRateConfig) throws -> Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder {
            return try Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasFixed {
                jsonMap["fixed"] = try fixed.encode()
            }
            if hasDropout {
                jsonMap["dropout"] = try dropout.encode()
            }
            if hasLineSearch {
                jsonMap["lineSearch"] = try lineSearch.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Learner.LearningRateConfig {
            return try Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.BoostedTrees.Learner.LearningRateConfig {
            return try Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasFixed {
                output += "\(indent) fixed {\n"
                if let outDescFixed = fixed {
                    output += try outDescFixed.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasDropout {
                output += "\(indent) dropout {\n"
                if let outDescDropout = dropout {
                    output += try outDescDropout.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasLineSearch {
                output += "\(indent) lineSearch {\n"
                if let outDescLineSearch = lineSearch {
                    output += try outDescLineSearch.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasFixed {
                    if let hashValuefixed = fixed?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuefixed
                    }
                }
                if hasDropout {
                    if let hashValuedropout = dropout?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuedropout
                    }
                }
                if hasLineSearch {
                    if let hashValuelineSearch = lineSearch?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuelineSearch
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.BoostedTrees.Learner.LearningRateConfig"
        }
        override public func className() -> String {
            return "Tensorflow.BoostedTrees.Learner.LearningRateConfig"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.BoostedTrees.Learner.LearningRateConfig = Tensorflow.BoostedTrees.Learner.LearningRateConfig()
            public func getMessage() -> Tensorflow.BoostedTrees.Learner.LearningRateConfig {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var fixed:Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig! {
                get {
                    if fixedBuilder_ != nil {
                        builderResult.fixed = fixedBuilder_.getMessage()
                    }
                    return builderResult.fixed
                }
                set (value) {
                    builderResult.hasFixed = true
                    builderResult.fixed = value
                }
            }
            public var hasFixed:Bool {
                get {
                    return builderResult.hasFixed
                }
            }
            fileprivate var fixedBuilder_:Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder! {
                didSet {
                    builderResult.hasFixed = true
                }
            }
            public func getFixedBuilder() -> Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder {
                if fixedBuilder_ == nil {
                    fixedBuilder_ = Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder()
                    builderResult.fixed = fixedBuilder_.getMessage()
                    if fixed != nil {
                        try! fixedBuilder_.mergeFrom(other: fixed)
                    }
                }
                return fixedBuilder_
            }
            @discardableResult
            public func setFixed(_ value:Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig!) -> Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder {
                self.fixed = value
                return self
            }
            @discardableResult
            public func mergeFixed(value:Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig) throws -> Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder {
                if builderResult.hasFixed {
                    builderResult.fixed = try Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.builderWithPrototype(prototype:builderResult.fixed).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.fixed = value
                }
                builderResult.hasFixed = true
                return self
            }
            @discardableResult
            public func clearFixed() -> Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder {
                fixedBuilder_ = nil
                builderResult.hasFixed = false
                builderResult.fixed = nil
                return self
            }
            public var dropout:Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig! {
                get {
                    if dropoutBuilder_ != nil {
                        builderResult.dropout = dropoutBuilder_.getMessage()
                    }
                    return builderResult.dropout
                }
                set (value) {
                    builderResult.hasDropout = true
                    builderResult.dropout = value
                }
            }
            public var hasDropout:Bool {
                get {
                    return builderResult.hasDropout
                }
            }
            fileprivate var dropoutBuilder_:Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder! {
                didSet {
                    builderResult.hasDropout = true
                }
            }
            public func getDropoutBuilder() -> Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder {
                if dropoutBuilder_ == nil {
                    dropoutBuilder_ = Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder()
                    builderResult.dropout = dropoutBuilder_.getMessage()
                    if dropout != nil {
                        try! dropoutBuilder_.mergeFrom(other: dropout)
                    }
                }
                return dropoutBuilder_
            }
            @discardableResult
            public func setDropout(_ value:Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig!) -> Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder {
                self.dropout = value
                return self
            }
            @discardableResult
            public func mergeDropout(value:Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig) throws -> Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder {
                if builderResult.hasDropout {
                    builderResult.dropout = try Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.builderWithPrototype(prototype:builderResult.dropout).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.dropout = value
                }
                builderResult.hasDropout = true
                return self
            }
            @discardableResult
            public func clearDropout() -> Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder {
                dropoutBuilder_ = nil
                builderResult.hasDropout = false
                builderResult.dropout = nil
                return self
            }
            public var lineSearch:Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig! {
                get {
                    if lineSearchBuilder_ != nil {
                        builderResult.lineSearch = lineSearchBuilder_.getMessage()
                    }
                    return builderResult.lineSearch
                }
                set (value) {
                    builderResult.hasLineSearch = true
                    builderResult.lineSearch = value
                }
            }
            public var hasLineSearch:Bool {
                get {
                    return builderResult.hasLineSearch
                }
            }
            fileprivate var lineSearchBuilder_:Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder! {
                didSet {
                    builderResult.hasLineSearch = true
                }
            }
            public func getLineSearchBuilder() -> Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder {
                if lineSearchBuilder_ == nil {
                    lineSearchBuilder_ = Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder()
                    builderResult.lineSearch = lineSearchBuilder_.getMessage()
                    if lineSearch != nil {
                        try! lineSearchBuilder_.mergeFrom(other: lineSearch)
                    }
                }
                return lineSearchBuilder_
            }
            @discardableResult
            public func setLineSearch(_ value:Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig!) -> Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder {
                self.lineSearch = value
                return self
            }
            @discardableResult
            public func mergeLineSearch(value:Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig) throws -> Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder {
                if builderResult.hasLineSearch {
                    builderResult.lineSearch = try Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.builderWithPrototype(prototype:builderResult.lineSearch).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.lineSearch = value
                }
                builderResult.hasLineSearch = true
                return self
            }
            @discardableResult
            public func clearLineSearch() -> Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder {
                lineSearchBuilder_ = nil
                builderResult.hasLineSearch = false
                builderResult.lineSearch = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder {
                builderResult = Tensorflow.BoostedTrees.Learner.LearningRateConfig()
                return self
            }
            override public func clone() throws -> Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder {
                return try Tensorflow.BoostedTrees.Learner.LearningRateConfig.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.BoostedTrees.Learner.LearningRateConfig {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.BoostedTrees.Learner.LearningRateConfig {
                let returnMe:Tensorflow.BoostedTrees.Learner.LearningRateConfig = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.BoostedTrees.Learner.LearningRateConfig) throws -> Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder {
                if other == Tensorflow.BoostedTrees.Learner.LearningRateConfig() {
                    return self
                }
                if (other.hasFixed) {
                    try mergeFixed(value: other.fixed)
                }
                if (other.hasDropout) {
                    try mergeDropout(value: other.dropout)
                }
                if (other.hasLineSearch) {
                    try mergeLineSearch(value: other.lineSearch)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder = Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder()
                        if hasFixed {
                            try subBuilder.mergeFrom(other: fixed)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        fixed = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder = Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder()
                        if hasDropout {
                            try subBuilder.mergeFrom(other: dropout)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        dropout = subBuilder.buildPartial()

                    case 26:
                        let subBuilder:Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder = Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder()
                        if hasLineSearch {
                            try subBuilder.mergeFrom(other: lineSearch)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        lineSearch = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder {
                let resultDecodedBuilder = Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder()
                if let jsonValueFixed = jsonMap["fixed"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.fixed = try Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder.decodeToBuilder(jsonMap:jsonValueFixed).build()

                }
                if let jsonValueDropout = jsonMap["dropout"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.dropout = try Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder.decodeToBuilder(jsonMap:jsonValueDropout).build()

                }
                if let jsonValueLineSearch = jsonMap["lineSearch"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.lineSearch = try Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder.decodeToBuilder(jsonMap:jsonValueLineSearch).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Config for a fixed learning rate.
    final public class LearningRateFixedConfig : GeneratedMessage {

        public static func == (lhs: Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig, rhs: Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasLearningRate == rhs.hasLearningRate) && (!lhs.hasLearningRate || lhs.learningRate == rhs.learningRate)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var learningRate:Float = Float(0)
        public fileprivate(set) var hasLearningRate:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasLearningRate {
                try codedOutputStream.writeFloat(fieldNumber: 1, value:learningRate)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasLearningRate {
                serialize_size += learningRate.computeFloatSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder {
            return Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.classBuilder() as! Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder
        }
        public func getBuilder() -> Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder {
            return classBuilder() as! Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder()
        }
        public func toBuilder() throws -> Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder {
            return try Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig) throws -> Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder {
            return try Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasLearningRate {
                jsonMap["learningRate"] = Float(learningRate)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig {
            return try Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig {
            return try Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasLearningRate {
                output += "\(indent) learningRate: \(learningRate) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasLearningRate {
                    hashCode = (hashCode &* 31) &+ learningRate.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig"
        }
        override public func className() -> String {
            return "Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig = Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig()
            public func getMessage() -> Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var learningRate:Float {
                get {
                    return builderResult.learningRate
                }
                set (value) {
                    builderResult.hasLearningRate = true
                    builderResult.learningRate = value
                }
            }
            public var hasLearningRate:Bool {
                get {
                    return builderResult.hasLearningRate
                }
            }
            @discardableResult
            public func setLearningRate(_ value:Float) -> Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder {
                self.learningRate = value
                return self
            }
            @discardableResult
            public func clearLearningRate() -> Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder{
                builderResult.hasLearningRate = false
                builderResult.learningRate = Float(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder {
                builderResult = Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig()
                return self
            }
            override public func clone() throws -> Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder {
                return try Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig {
                let returnMe:Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig) throws -> Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder {
                if other == Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig() {
                    return self
                }
                if other.hasLearningRate {
                    learningRate = other.learningRate
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 13:
                        learningRate = try codedInputStream.readFloat()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder {
                let resultDecodedBuilder = Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder()
                if let jsonValueLearningRate = jsonMap["learningRate"] as? Float {
                    resultDecodedBuilder.learningRate = Float(jsonValueLearningRate)
                } else if let jsonValueLearningRate = jsonMap["learningRate"] as? String {
                    resultDecodedBuilder.learningRate = Float(jsonValueLearningRate)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Config for a tuned learning rate.
    final public class LearningRateLineSearchConfig : GeneratedMessage {

        public static func == (lhs: Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig, rhs: Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasMaxLearningRate == rhs.hasMaxLearningRate) && (!lhs.hasMaxLearningRate || lhs.maxLearningRate == rhs.maxLearningRate)
            fieldCheck = fieldCheck && (lhs.hasNumSteps == rhs.hasNumSteps) && (!lhs.hasNumSteps || lhs.numSteps == rhs.numSteps)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Max learning rate. Must be strictly positive.
        public fileprivate(set) var maxLearningRate:Float = Float(0)
        public fileprivate(set) var hasMaxLearningRate:Bool = false

        /// Number of learning rate values to consider between [0, max_learning_rate).
        public fileprivate(set) var numSteps:Int32 = Int32(0)
        public fileprivate(set) var hasNumSteps:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasMaxLearningRate {
                try codedOutputStream.writeFloat(fieldNumber: 1, value:maxLearningRate)
            }
            if hasNumSteps {
                try codedOutputStream.writeInt32(fieldNumber: 2, value:numSteps)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasMaxLearningRate {
                serialize_size += maxLearningRate.computeFloatSize(fieldNumber: 1)
            }
            if hasNumSteps {
                serialize_size += numSteps.computeInt32Size(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder {
            return Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.classBuilder() as! Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder
        }
        public func getBuilder() -> Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder {
            return classBuilder() as! Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder()
        }
        public func toBuilder() throws -> Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder {
            return try Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig) throws -> Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder {
            return try Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasMaxLearningRate {
                jsonMap["maxLearningRate"] = Float(maxLearningRate)
            }
            if hasNumSteps {
                jsonMap["numSteps"] = Int(numSteps)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig {
            return try Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig {
            return try Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasMaxLearningRate {
                output += "\(indent) maxLearningRate: \(maxLearningRate) \n"
            }
            if hasNumSteps {
                output += "\(indent) numSteps: \(numSteps) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasMaxLearningRate {
                    hashCode = (hashCode &* 31) &+ maxLearningRate.hashValue
                }
                if hasNumSteps {
                    hashCode = (hashCode &* 31) &+ numSteps.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig"
        }
        override public func className() -> String {
            return "Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig = Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig()
            public func getMessage() -> Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Max learning rate. Must be strictly positive.
            public var maxLearningRate:Float {
                get {
                    return builderResult.maxLearningRate
                }
                set (value) {
                    builderResult.hasMaxLearningRate = true
                    builderResult.maxLearningRate = value
                }
            }
            public var hasMaxLearningRate:Bool {
                get {
                    return builderResult.hasMaxLearningRate
                }
            }
            @discardableResult
            public func setMaxLearningRate(_ value:Float) -> Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder {
                self.maxLearningRate = value
                return self
            }
            @discardableResult
            public func clearMaxLearningRate() -> Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder{
                builderResult.hasMaxLearningRate = false
                builderResult.maxLearningRate = Float(0)
                return self
            }
            /// Number of learning rate values to consider between [0, max_learning_rate).
            public var numSteps:Int32 {
                get {
                    return builderResult.numSteps
                }
                set (value) {
                    builderResult.hasNumSteps = true
                    builderResult.numSteps = value
                }
            }
            public var hasNumSteps:Bool {
                get {
                    return builderResult.hasNumSteps
                }
            }
            @discardableResult
            public func setNumSteps(_ value:Int32) -> Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder {
                self.numSteps = value
                return self
            }
            @discardableResult
            public func clearNumSteps() -> Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder{
                builderResult.hasNumSteps = false
                builderResult.numSteps = Int32(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder {
                builderResult = Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig()
                return self
            }
            override public func clone() throws -> Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder {
                return try Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig {
                let returnMe:Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig) throws -> Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder {
                if other == Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig() {
                    return self
                }
                if other.hasMaxLearningRate {
                    maxLearningRate = other.maxLearningRate
                }
                if other.hasNumSteps {
                    numSteps = other.numSteps
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 13:
                        maxLearningRate = try codedInputStream.readFloat()

                    case 16:
                        numSteps = try codedInputStream.readInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder {
                let resultDecodedBuilder = Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder()
                if let jsonValueMaxLearningRate = jsonMap["maxLearningRate"] as? Float {
                    resultDecodedBuilder.maxLearningRate = Float(jsonValueMaxLearningRate)
                } else if let jsonValueMaxLearningRate = jsonMap["maxLearningRate"] as? String {
                    resultDecodedBuilder.maxLearningRate = Float(jsonValueMaxLearningRate)!
                }
                if let jsonValueNumSteps = jsonMap["numSteps"] as? Int {
                    resultDecodedBuilder.numSteps = Int32(jsonValueNumSteps)
                } else if let jsonValueNumSteps = jsonMap["numSteps"] as? String {
                    resultDecodedBuilder.numSteps = Int32(jsonValueNumSteps)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// When we have a sequence of trees 1, 2, 3 ... n, these essentially represent
    /// weights updates in functional space, and thus we can use averaging of weight
    /// updates to achieve better performance. For example, we can say that our final
    /// ensemble will be an average of ensembles of tree 1, and ensemble of tree 1
    /// and tree 2 etc .. ensemble of all trees.
    /// Note that this averaging will apply ONLY DURING PREDICTION. The training
    /// stays the same.
    final public class AveragingConfig : GeneratedMessage {

        public static func == (lhs: Tensorflow.BoostedTrees.Learner.AveragingConfig, rhs: Tensorflow.BoostedTrees.Learner.AveragingConfig) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasAverageLastNTrees == rhs.hasAverageLastNTrees) && (!lhs.hasAverageLastNTrees || lhs.averageLastNTrees == rhs.averageLastNTrees)
            fieldCheck = fieldCheck && (lhs.hasAverageLastPercentTrees == rhs.hasAverageLastPercentTrees) && (!lhs.hasAverageLastPercentTrees || lhs.averageLastPercentTrees == rhs.averageLastPercentTrees)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //OneOf declaration start

        public enum Config {
            case OneOfConfigNotSet

            public func checkOneOfIsSet() -> Bool {
                switch self {
                case .OneOfConfigNotSet: return false
                default: return true
                }
            }
            case AverageLastNTrees(Float)

            public static func getAverageLastNTrees(_ value:Config) -> Float? {
                switch value {
                case .AverageLastNTrees(let enumValue): return enumValue
                default: return nil
                }
            }
            case AverageLastPercentTrees(Float)

            public static func getAverageLastPercentTrees(_ value:Config) -> Float? {
                switch value {
                case .AverageLastPercentTrees(let enumValue): return enumValue
                default: return nil
                }
            }
        }
        //OneOf declaration end

        fileprivate var storageConfig:AveragingConfig.Config =  AveragingConfig.Config.OneOfConfigNotSet
        public func getOneOfConfig() ->  AveragingConfig.Config {
            let copyObjectConfig = storageConfig
            return copyObjectConfig
        }
        public fileprivate(set) var averageLastNTrees:Float!{
            get {
                return AveragingConfig.Config.getAverageLastNTrees(storageConfig)
            }
            set (newvalue) {
                storageConfig = AveragingConfig.Config.AverageLastNTrees(newvalue)
            }
        }
        public fileprivate(set) var hasAverageLastNTrees:Bool {
            get {
                guard let _ = AveragingConfig.Config.getAverageLastNTrees(storageConfig) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        /// Between 0 and 1. If set to 1.0, we are averaging ensembles of tree 1,
        /// ensemble of tree 1 and tree 2, etc ensemble of all trees. If set to 0.5,
        /// last half of the trees are averaged etc.
        public fileprivate(set) var averageLastPercentTrees:Float!{
            get {
                return AveragingConfig.Config.getAverageLastPercentTrees(storageConfig)
            }
            set (newvalue) {
                storageConfig = AveragingConfig.Config.AverageLastPercentTrees(newvalue)
            }
        }
        public fileprivate(set) var hasAverageLastPercentTrees:Bool {
            get {
                guard let _ = AveragingConfig.Config.getAverageLastPercentTrees(storageConfig) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasAverageLastNTrees {
                try codedOutputStream.writeFloat(fieldNumber: 1, value:averageLastNTrees)
            }
            if hasAverageLastPercentTrees {
                try codedOutputStream.writeFloat(fieldNumber: 2, value:averageLastPercentTrees)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasAverageLastNTrees {
                serialize_size += averageLastNTrees.computeFloatSize(fieldNumber: 1)
            }
            if hasAverageLastPercentTrees {
                serialize_size += averageLastPercentTrees.computeFloatSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder {
            return Tensorflow.BoostedTrees.Learner.AveragingConfig.classBuilder() as! Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder
        }
        public func getBuilder() -> Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder {
            return classBuilder() as! Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder()
        }
        public func toBuilder() throws -> Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder {
            return try Tensorflow.BoostedTrees.Learner.AveragingConfig.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.BoostedTrees.Learner.AveragingConfig) throws -> Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder {
            return try Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasAverageLastNTrees {
                jsonMap["averageLastNTrees"] = Float(averageLastNTrees)
            }
            if hasAverageLastPercentTrees {
                jsonMap["averageLastPercentTrees"] = Float(averageLastPercentTrees)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Learner.AveragingConfig {
            return try Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.BoostedTrees.Learner.AveragingConfig {
            return try Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasAverageLastNTrees {
                output += "\(indent) averageLastNTrees: \(averageLastNTrees) \n"
            }
            if hasAverageLastPercentTrees {
                output += "\(indent) averageLastPercentTrees: \(averageLastPercentTrees) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasAverageLastNTrees {
                    hashCode = (hashCode &* 31) &+ averageLastNTrees.hashValue
                }
                if hasAverageLastPercentTrees {
                    hashCode = (hashCode &* 31) &+ averageLastPercentTrees.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.BoostedTrees.Learner.AveragingConfig"
        }
        override public func className() -> String {
            return "Tensorflow.BoostedTrees.Learner.AveragingConfig"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.BoostedTrees.Learner.AveragingConfig = Tensorflow.BoostedTrees.Learner.AveragingConfig()
            public func getMessage() -> Tensorflow.BoostedTrees.Learner.AveragingConfig {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var averageLastNTrees:Float {
                get {
                    return builderResult.averageLastNTrees
                }
                set (value) {
                    builderResult.hasAverageLastNTrees = true
                    builderResult.averageLastNTrees = value
                }
            }
            public var hasAverageLastNTrees:Bool {
                get {
                    return builderResult.hasAverageLastNTrees
                }
            }
            @discardableResult
            public func setAverageLastNTrees(_ value:Float) -> Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder {
                self.averageLastNTrees = value
                return self
            }
            @discardableResult
            public func clearAverageLastNTrees() -> Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder{
                builderResult.hasAverageLastNTrees = false
                builderResult.averageLastNTrees = Float(0)
                return self
            }
            /// Between 0 and 1. If set to 1.0, we are averaging ensembles of tree 1,
            /// ensemble of tree 1 and tree 2, etc ensemble of all trees. If set to 0.5,
            /// last half of the trees are averaged etc.
            public var averageLastPercentTrees:Float {
                get {
                    return builderResult.averageLastPercentTrees
                }
                set (value) {
                    builderResult.hasAverageLastPercentTrees = true
                    builderResult.averageLastPercentTrees = value
                }
            }
            public var hasAverageLastPercentTrees:Bool {
                get {
                    return builderResult.hasAverageLastPercentTrees
                }
            }
            @discardableResult
            public func setAverageLastPercentTrees(_ value:Float) -> Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder {
                self.averageLastPercentTrees = value
                return self
            }
            @discardableResult
            public func clearAverageLastPercentTrees() -> Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder{
                builderResult.hasAverageLastPercentTrees = false
                builderResult.averageLastPercentTrees = Float(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder {
                builderResult = Tensorflow.BoostedTrees.Learner.AveragingConfig()
                return self
            }
            override public func clone() throws -> Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder {
                return try Tensorflow.BoostedTrees.Learner.AveragingConfig.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.BoostedTrees.Learner.AveragingConfig {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.BoostedTrees.Learner.AveragingConfig {
                let returnMe:Tensorflow.BoostedTrees.Learner.AveragingConfig = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.BoostedTrees.Learner.AveragingConfig) throws -> Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder {
                if other == Tensorflow.BoostedTrees.Learner.AveragingConfig() {
                    return self
                }
                if other.hasAverageLastNTrees {
                    averageLastNTrees = other.averageLastNTrees
                }
                if other.hasAverageLastPercentTrees {
                    averageLastPercentTrees = other.averageLastPercentTrees
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 13:
                        averageLastNTrees = try codedInputStream.readFloat()

                    case 21:
                        averageLastPercentTrees = try codedInputStream.readFloat()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder {
                let resultDecodedBuilder = Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder()
                if let jsonValueAverageLastNTrees = jsonMap["averageLastNTrees"] as? Float {
                    resultDecodedBuilder.averageLastNTrees = Float(jsonValueAverageLastNTrees)
                } else if let jsonValueAverageLastNTrees = jsonMap["averageLastNTrees"] as? String {
                    resultDecodedBuilder.averageLastNTrees = Float(jsonValueAverageLastNTrees)!
                }
                if let jsonValueAverageLastPercentTrees = jsonMap["averageLastPercentTrees"] as? Float {
                    resultDecodedBuilder.averageLastPercentTrees = Float(jsonValueAverageLastPercentTrees)
                } else if let jsonValueAverageLastPercentTrees = jsonMap["averageLastPercentTrees"] as? String {
                    resultDecodedBuilder.averageLastPercentTrees = Float(jsonValueAverageLastPercentTrees)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class LearningRateDropoutDrivenConfig : GeneratedMessage {

        public static func == (lhs: Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig, rhs: Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasDropoutProbability == rhs.hasDropoutProbability) && (!lhs.hasDropoutProbability || lhs.dropoutProbability == rhs.dropoutProbability)
            fieldCheck = fieldCheck && (lhs.hasProbabilityOfSkippingDropout == rhs.hasProbabilityOfSkippingDropout) && (!lhs.hasProbabilityOfSkippingDropout || lhs.probabilityOfSkippingDropout == rhs.probabilityOfSkippingDropout)
            fieldCheck = fieldCheck && (lhs.hasLearningRate == rhs.hasLearningRate) && (!lhs.hasLearningRate || lhs.learningRate == rhs.learningRate)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Probability of dropping each tree in an existing so far ensemble.
        public fileprivate(set) var dropoutProbability:Float = Float(0)
        public fileprivate(set) var hasDropoutProbability:Bool = false

        /// When trees are built after dropout happen, they don't "advance" to the
        /// optimal solution, they just rearrange the path. However you can still
        /// choose to skip dropout periodically, to allow a new tree that "advances"
        /// to be added.
        /// For example, if running for 200 steps with probability of dropout 1/100,
        /// you would expect the dropout to start happening for sure for all iterations
        /// after 100. However you can add probability_of_skipping_dropout of 0.1, this
        /// way iterations 100-200 will include approx 90 iterations of dropout and 10
        /// iterations of normal steps.Set it to 0 if you want just keep building
        /// the refinement trees after dropout kicks in.
        public fileprivate(set) var probabilityOfSkippingDropout:Float = Float(0)
        public fileprivate(set) var hasProbabilityOfSkippingDropout:Bool = false

        /// Between 0 and 1.
        public fileprivate(set) var learningRate:Float = Float(0)
        public fileprivate(set) var hasLearningRate:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasDropoutProbability {
                try codedOutputStream.writeFloat(fieldNumber: 1, value:dropoutProbability)
            }
            if hasProbabilityOfSkippingDropout {
                try codedOutputStream.writeFloat(fieldNumber: 2, value:probabilityOfSkippingDropout)
            }
            if hasLearningRate {
                try codedOutputStream.writeFloat(fieldNumber: 3, value:learningRate)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasDropoutProbability {
                serialize_size += dropoutProbability.computeFloatSize(fieldNumber: 1)
            }
            if hasProbabilityOfSkippingDropout {
                serialize_size += probabilityOfSkippingDropout.computeFloatSize(fieldNumber: 2)
            }
            if hasLearningRate {
                serialize_size += learningRate.computeFloatSize(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder {
            return Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.classBuilder() as! Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder
        }
        public func getBuilder() -> Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder {
            return classBuilder() as! Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder()
        }
        public func toBuilder() throws -> Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder {
            return try Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig) throws -> Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder {
            return try Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasDropoutProbability {
                jsonMap["dropoutProbability"] = Float(dropoutProbability)
            }
            if hasProbabilityOfSkippingDropout {
                jsonMap["probabilityOfSkippingDropout"] = Float(probabilityOfSkippingDropout)
            }
            if hasLearningRate {
                jsonMap["learningRate"] = Float(learningRate)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig {
            return try Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig {
            return try Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasDropoutProbability {
                output += "\(indent) dropoutProbability: \(dropoutProbability) \n"
            }
            if hasProbabilityOfSkippingDropout {
                output += "\(indent) probabilityOfSkippingDropout: \(probabilityOfSkippingDropout) \n"
            }
            if hasLearningRate {
                output += "\(indent) learningRate: \(learningRate) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasDropoutProbability {
                    hashCode = (hashCode &* 31) &+ dropoutProbability.hashValue
                }
                if hasProbabilityOfSkippingDropout {
                    hashCode = (hashCode &* 31) &+ probabilityOfSkippingDropout.hashValue
                }
                if hasLearningRate {
                    hashCode = (hashCode &* 31) &+ learningRate.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig"
        }
        override public func className() -> String {
            return "Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig = Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig()
            public func getMessage() -> Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Probability of dropping each tree in an existing so far ensemble.
            public var dropoutProbability:Float {
                get {
                    return builderResult.dropoutProbability
                }
                set (value) {
                    builderResult.hasDropoutProbability = true
                    builderResult.dropoutProbability = value
                }
            }
            public var hasDropoutProbability:Bool {
                get {
                    return builderResult.hasDropoutProbability
                }
            }
            @discardableResult
            public func setDropoutProbability(_ value:Float) -> Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder {
                self.dropoutProbability = value
                return self
            }
            @discardableResult
            public func clearDropoutProbability() -> Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder{
                builderResult.hasDropoutProbability = false
                builderResult.dropoutProbability = Float(0)
                return self
            }
            /// When trees are built after dropout happen, they don't "advance" to the
            /// optimal solution, they just rearrange the path. However you can still
            /// choose to skip dropout periodically, to allow a new tree that "advances"
            /// to be added.
            /// For example, if running for 200 steps with probability of dropout 1/100,
            /// you would expect the dropout to start happening for sure for all iterations
            /// after 100. However you can add probability_of_skipping_dropout of 0.1, this
            /// way iterations 100-200 will include approx 90 iterations of dropout and 10
            /// iterations of normal steps.Set it to 0 if you want just keep building
            /// the refinement trees after dropout kicks in.
            public var probabilityOfSkippingDropout:Float {
                get {
                    return builderResult.probabilityOfSkippingDropout
                }
                set (value) {
                    builderResult.hasProbabilityOfSkippingDropout = true
                    builderResult.probabilityOfSkippingDropout = value
                }
            }
            public var hasProbabilityOfSkippingDropout:Bool {
                get {
                    return builderResult.hasProbabilityOfSkippingDropout
                }
            }
            @discardableResult
            public func setProbabilityOfSkippingDropout(_ value:Float) -> Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder {
                self.probabilityOfSkippingDropout = value
                return self
            }
            @discardableResult
            public func clearProbabilityOfSkippingDropout() -> Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder{
                builderResult.hasProbabilityOfSkippingDropout = false
                builderResult.probabilityOfSkippingDropout = Float(0)
                return self
            }
            /// Between 0 and 1.
            public var learningRate:Float {
                get {
                    return builderResult.learningRate
                }
                set (value) {
                    builderResult.hasLearningRate = true
                    builderResult.learningRate = value
                }
            }
            public var hasLearningRate:Bool {
                get {
                    return builderResult.hasLearningRate
                }
            }
            @discardableResult
            public func setLearningRate(_ value:Float) -> Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder {
                self.learningRate = value
                return self
            }
            @discardableResult
            public func clearLearningRate() -> Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder{
                builderResult.hasLearningRate = false
                builderResult.learningRate = Float(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder {
                builderResult = Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig()
                return self
            }
            override public func clone() throws -> Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder {
                return try Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig {
                let returnMe:Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig) throws -> Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder {
                if other == Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig() {
                    return self
                }
                if other.hasDropoutProbability {
                    dropoutProbability = other.dropoutProbability
                }
                if other.hasProbabilityOfSkippingDropout {
                    probabilityOfSkippingDropout = other.probabilityOfSkippingDropout
                }
                if other.hasLearningRate {
                    learningRate = other.learningRate
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 13:
                        dropoutProbability = try codedInputStream.readFloat()

                    case 21:
                        probabilityOfSkippingDropout = try codedInputStream.readFloat()

                    case 29:
                        learningRate = try codedInputStream.readFloat()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder {
                let resultDecodedBuilder = Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder()
                if let jsonValueDropoutProbability = jsonMap["dropoutProbability"] as? Float {
                    resultDecodedBuilder.dropoutProbability = Float(jsonValueDropoutProbability)
                } else if let jsonValueDropoutProbability = jsonMap["dropoutProbability"] as? String {
                    resultDecodedBuilder.dropoutProbability = Float(jsonValueDropoutProbability)!
                }
                if let jsonValueProbabilityOfSkippingDropout = jsonMap["probabilityOfSkippingDropout"] as? Float {
                    resultDecodedBuilder.probabilityOfSkippingDropout = Float(jsonValueProbabilityOfSkippingDropout)
                } else if let jsonValueProbabilityOfSkippingDropout = jsonMap["probabilityOfSkippingDropout"] as? String {
                    resultDecodedBuilder.probabilityOfSkippingDropout = Float(jsonValueProbabilityOfSkippingDropout)!
                }
                if let jsonValueLearningRate = jsonMap["learningRate"] as? Float {
                    resultDecodedBuilder.learningRate = Float(jsonValueLearningRate)
                } else if let jsonValueLearningRate = jsonMap["learningRate"] as? String {
                    resultDecodedBuilder.learningRate = Float(jsonValueLearningRate)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class LearnerConfig : GeneratedMessage {

        public static func == (lhs: Tensorflow.BoostedTrees.Learner.LearnerConfig, rhs: Tensorflow.BoostedTrees.Learner.LearnerConfig) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasNumClasses == rhs.hasNumClasses) && (!lhs.hasNumClasses || lhs.numClasses == rhs.numClasses)
            fieldCheck = fieldCheck && (lhs.hasFeatureFractionPerTree == rhs.hasFeatureFractionPerTree) && (!lhs.hasFeatureFractionPerTree || lhs.featureFractionPerTree == rhs.featureFractionPerTree)
            fieldCheck = fieldCheck && (lhs.hasFeatureFractionPerLevel == rhs.hasFeatureFractionPerLevel) && (!lhs.hasFeatureFractionPerLevel || lhs.featureFractionPerLevel == rhs.featureFractionPerLevel)
            fieldCheck = fieldCheck && (lhs.hasRegularization == rhs.hasRegularization) && (!lhs.hasRegularization || lhs.regularization == rhs.regularization)
            fieldCheck = fieldCheck && (lhs.hasConstraints == rhs.hasConstraints) && (!lhs.hasConstraints || lhs.constraints == rhs.constraints)
            fieldCheck = fieldCheck && (lhs.hasLearningRateTuner == rhs.hasLearningRateTuner) && (!lhs.hasLearningRateTuner || lhs.learningRateTuner == rhs.learningRateTuner)
            fieldCheck = fieldCheck && (lhs.hasPruningMode == rhs.hasPruningMode) && (!lhs.hasPruningMode || lhs.pruningMode == rhs.pruningMode)
            fieldCheck = fieldCheck && (lhs.hasGrowingMode == rhs.hasGrowingMode) && (!lhs.hasGrowingMode || lhs.growingMode == rhs.growingMode)
            fieldCheck = fieldCheck && (lhs.hasMultiClassStrategy == rhs.hasMultiClassStrategy) && (!lhs.hasMultiClassStrategy || lhs.multiClassStrategy == rhs.multiClassStrategy)
            fieldCheck = fieldCheck && (lhs.hasAveragingConfig == rhs.hasAveragingConfig) && (!lhs.hasAveragingConfig || lhs.averagingConfig == rhs.averagingConfig)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //OneOf declaration start

        /// Fraction of features to consider in each tree sampled randomly
        /// from all available features.
        public enum FeatureFraction {
            case OneOfFeatureFractionNotSet

            public func checkOneOfIsSet() -> Bool {
                switch self {
                case .OneOfFeatureFractionNotSet: return false
                default: return true
                }
            }
            case FeatureFractionPerTree(Float)

            public static func getFeatureFractionPerTree(_ value:FeatureFraction) -> Float? {
                switch value {
                case .FeatureFractionPerTree(let enumValue): return enumValue
                default: return nil
                }
            }
            case FeatureFractionPerLevel(Float)

            public static func getFeatureFractionPerLevel(_ value:FeatureFraction) -> Float? {
                switch value {
                case .FeatureFractionPerLevel(let enumValue): return enumValue
                default: return nil
                }
            }
        }
        //OneOf declaration end

        fileprivate var storageFeatureFraction:LearnerConfig.FeatureFraction =  LearnerConfig.FeatureFraction.OneOfFeatureFractionNotSet
        public func getOneOfFeatureFraction() ->  LearnerConfig.FeatureFraction {
            let copyObjectFeatureFraction = storageFeatureFraction
            return copyObjectFeatureFraction
        }


            //Enum type declaration start 

            public enum PruningMode:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
                case prePrune = 0
                case postPrune = 1
                public func toString() -> String {
                    switch self {
                    case .prePrune: return "PRE_PRUNE"
                    case .postPrune: return "POST_PRUNE"
                    }
                }
                public static func fromString(str:String) throws -> Tensorflow.BoostedTrees.Learner.LearnerConfig.PruningMode {
                    switch str {
                    case "PRE_PRUNE":    return .prePrune
                    case "POST_PRUNE":    return .postPrune
                    default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
                    }
                }
                public var debugDescription:String { return getDescription() }
                public var description:String { return getDescription() }
                private func getDescription() -> String { 
                    switch self {
                    case .prePrune: return ".prePrune"
                    case .postPrune: return ".postPrune"
                    }
                }
                public var hashValue:Int {
                    return self.rawValue.hashValue
                }
                public static func ==(lhs:PruningMode, rhs:PruningMode) -> Bool {
                    return lhs.hashValue == rhs.hashValue
                }
            }

            //Enum type declaration end 



            //Enum type declaration start 

            public enum GrowingMode:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
                case wholeTree = 0

                /// Layer by layer is only supported by the batch learner.
                case layerByLayer = 1
                public func toString() -> String {
                    switch self {
                    case .wholeTree: return "WHOLE_TREE"
                    case .layerByLayer: return "LAYER_BY_LAYER"
                    }
                }
                public static func fromString(str:String) throws -> Tensorflow.BoostedTrees.Learner.LearnerConfig.GrowingMode {
                    switch str {
                    case "WHOLE_TREE":    return .wholeTree
                    case "LAYER_BY_LAYER":    return .layerByLayer
                    default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
                    }
                }
                public var debugDescription:String { return getDescription() }
                public var description:String { return getDescription() }
                private func getDescription() -> String { 
                    switch self {
                    case .wholeTree: return ".wholeTree"
                    case .layerByLayer: return ".layerByLayer"
                    }
                }
                public var hashValue:Int {
                    return self.rawValue.hashValue
                }
                public static func ==(lhs:GrowingMode, rhs:GrowingMode) -> Bool {
                    return lhs.hashValue == rhs.hashValue
                }
            }

            //Enum type declaration end 



            //Enum type declaration start 

            public enum MultiClassStrategy:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
                case treePerClass = 0
                case fullHessian = 1
                case diagonalHessian = 2
                public func toString() -> String {
                    switch self {
                    case .treePerClass: return "TREE_PER_CLASS"
                    case .fullHessian: return "FULL_HESSIAN"
                    case .diagonalHessian: return "DIAGONAL_HESSIAN"
                    }
                }
                public static func fromString(str:String) throws -> Tensorflow.BoostedTrees.Learner.LearnerConfig.MultiClassStrategy {
                    switch str {
                    case "TREE_PER_CLASS":    return .treePerClass
                    case "FULL_HESSIAN":    return .fullHessian
                    case "DIAGONAL_HESSIAN":    return .diagonalHessian
                    default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
                    }
                }
                public var debugDescription:String { return getDescription() }
                public var description:String { return getDescription() }
                private func getDescription() -> String { 
                    switch self {
                    case .treePerClass: return ".treePerClass"
                    case .fullHessian: return ".fullHessian"
                    case .diagonalHessian: return ".diagonalHessian"
                    }
                }
                public var hashValue:Int {
                    return self.rawValue.hashValue
                }
                public static func ==(lhs:MultiClassStrategy, rhs:MultiClassStrategy) -> Bool {
                    return lhs.hashValue == rhs.hashValue
                }
            }

            //Enum type declaration end 

        /// Number of classes.
        public fileprivate(set) var numClasses:UInt32 = UInt32(0)
        public fileprivate(set) var hasNumClasses:Bool = false

        public fileprivate(set) var featureFractionPerTree:Float!{
            get {
                return LearnerConfig.FeatureFraction.getFeatureFractionPerTree(storageFeatureFraction)
            }
            set (newvalue) {
                storageFeatureFraction = LearnerConfig.FeatureFraction.FeatureFractionPerTree(newvalue)
            }
        }
        public fileprivate(set) var hasFeatureFractionPerTree:Bool {
            get {
                guard let _ = LearnerConfig.FeatureFraction.getFeatureFractionPerTree(storageFeatureFraction) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var featureFractionPerLevel:Float!{
            get {
                return LearnerConfig.FeatureFraction.getFeatureFractionPerLevel(storageFeatureFraction)
            }
            set (newvalue) {
                storageFeatureFraction = LearnerConfig.FeatureFraction.FeatureFractionPerLevel(newvalue)
            }
        }
        public fileprivate(set) var hasFeatureFractionPerLevel:Bool {
            get {
                guard let _ = LearnerConfig.FeatureFraction.getFeatureFractionPerLevel(storageFeatureFraction) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var regularization:Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig!
        public fileprivate(set) var hasRegularization:Bool = false
        public fileprivate(set) var constraints:Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig!
        public fileprivate(set) var hasConstraints:Bool = false
        public fileprivate(set) var pruningMode:Tensorflow.BoostedTrees.Learner.LearnerConfig.PruningMode = Tensorflow.BoostedTrees.Learner.LearnerConfig.PruningMode.prePrune
        public fileprivate(set) var hasPruningMode:Bool = false
        public fileprivate(set) var growingMode:Tensorflow.BoostedTrees.Learner.LearnerConfig.GrowingMode = Tensorflow.BoostedTrees.Learner.LearnerConfig.GrowingMode.wholeTree
        public fileprivate(set) var hasGrowingMode:Bool = false
        public fileprivate(set) var learningRateTuner:Tensorflow.BoostedTrees.Learner.LearningRateConfig!
        public fileprivate(set) var hasLearningRateTuner:Bool = false
        public fileprivate(set) var multiClassStrategy:Tensorflow.BoostedTrees.Learner.LearnerConfig.MultiClassStrategy = Tensorflow.BoostedTrees.Learner.LearnerConfig.MultiClassStrategy.treePerClass
        public fileprivate(set) var hasMultiClassStrategy:Bool = false
        public fileprivate(set) var averagingConfig:Tensorflow.BoostedTrees.Learner.AveragingConfig!
        public fileprivate(set) var hasAveragingConfig:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasNumClasses {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:numClasses)
            }
            if hasFeatureFractionPerTree {
                try codedOutputStream.writeFloat(fieldNumber: 2, value:featureFractionPerTree)
            }
            if hasFeatureFractionPerLevel {
                try codedOutputStream.writeFloat(fieldNumber: 3, value:featureFractionPerLevel)
            }
            if hasRegularization {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:regularization)
            }
            if hasConstraints {
                try codedOutputStream.writeMessage(fieldNumber: 5, value:constraints)
            }
            if hasLearningRateTuner {
                try codedOutputStream.writeMessage(fieldNumber: 6, value:learningRateTuner)
            }
            if hasPruningMode {
                try codedOutputStream.writeEnum(fieldNumber: 8, value:pruningMode.rawValue)
            }
            if hasGrowingMode {
                try codedOutputStream.writeEnum(fieldNumber: 9, value:growingMode.rawValue)
            }
            if hasMultiClassStrategy {
                try codedOutputStream.writeEnum(fieldNumber: 10, value:multiClassStrategy.rawValue)
            }
            if hasAveragingConfig {
                try codedOutputStream.writeMessage(fieldNumber: 11, value:averagingConfig)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasNumClasses {
                serialize_size += numClasses.computeUInt32Size(fieldNumber: 1)
            }
            if hasFeatureFractionPerTree {
                serialize_size += featureFractionPerTree.computeFloatSize(fieldNumber: 2)
            }
            if hasFeatureFractionPerLevel {
                serialize_size += featureFractionPerLevel.computeFloatSize(fieldNumber: 3)
            }
            if hasRegularization {
                if let varSizeregularization = regularization?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizeregularization
                }
            }
            if hasConstraints {
                if let varSizeconstraints = constraints?.computeMessageSize(fieldNumber: 5) {
                    serialize_size += varSizeconstraints
                }
            }
            if hasLearningRateTuner {
                if let varSizelearningRateTuner = learningRateTuner?.computeMessageSize(fieldNumber: 6) {
                    serialize_size += varSizelearningRateTuner
                }
            }
            if (hasPruningMode) {
                serialize_size += pruningMode.rawValue.computeEnumSize(fieldNumber: 8)
            }
            if (hasGrowingMode) {
                serialize_size += growingMode.rawValue.computeEnumSize(fieldNumber: 9)
            }
            if (hasMultiClassStrategy) {
                serialize_size += multiClassStrategy.rawValue.computeEnumSize(fieldNumber: 10)
            }
            if hasAveragingConfig {
                if let varSizeaveragingConfig = averagingConfig?.computeMessageSize(fieldNumber: 11) {
                    serialize_size += varSizeaveragingConfig
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder {
            return Tensorflow.BoostedTrees.Learner.LearnerConfig.classBuilder() as! Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder
        }
        public func getBuilder() -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder {
            return classBuilder() as! Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder()
        }
        public func toBuilder() throws -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder {
            return try Tensorflow.BoostedTrees.Learner.LearnerConfig.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.BoostedTrees.Learner.LearnerConfig) throws -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder {
            return try Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasNumClasses {
                jsonMap["numClasses"] = UInt(numClasses)
            }
            if hasFeatureFractionPerTree {
                jsonMap["featureFractionPerTree"] = Float(featureFractionPerTree)
            }
            if hasFeatureFractionPerLevel {
                jsonMap["featureFractionPerLevel"] = Float(featureFractionPerLevel)
            }
            if hasRegularization {
                jsonMap["regularization"] = try regularization.encode()
            }
            if hasConstraints {
                jsonMap["constraints"] = try constraints.encode()
            }
            if hasPruningMode {
                jsonMap["pruningMode"] = pruningMode.toString()
            }
            if hasGrowingMode {
                jsonMap["growingMode"] = growingMode.toString()
            }
            if hasLearningRateTuner {
                jsonMap["learningRateTuner"] = try learningRateTuner.encode()
            }
            if hasMultiClassStrategy {
                jsonMap["multiClassStrategy"] = multiClassStrategy.toString()
            }
            if hasAveragingConfig {
                jsonMap["averagingConfig"] = try averagingConfig.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Learner.LearnerConfig {
            return try Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.BoostedTrees.Learner.LearnerConfig {
            return try Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasNumClasses {
                output += "\(indent) numClasses: \(numClasses) \n"
            }
            if hasFeatureFractionPerTree {
                output += "\(indent) featureFractionPerTree: \(featureFractionPerTree) \n"
            }
            if hasFeatureFractionPerLevel {
                output += "\(indent) featureFractionPerLevel: \(featureFractionPerLevel) \n"
            }
            if hasRegularization {
                output += "\(indent) regularization {\n"
                if let outDescRegularization = regularization {
                    output += try outDescRegularization.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasConstraints {
                output += "\(indent) constraints {\n"
                if let outDescConstraints = constraints {
                    output += try outDescConstraints.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasLearningRateTuner {
                output += "\(indent) learningRateTuner {\n"
                if let outDescLearningRateTuner = learningRateTuner {
                    output += try outDescLearningRateTuner.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if (hasPruningMode) {
                output += "\(indent) pruningMode: \(pruningMode.description)\n"
            }
            if (hasGrowingMode) {
                output += "\(indent) growingMode: \(growingMode.description)\n"
            }
            if (hasMultiClassStrategy) {
                output += "\(indent) multiClassStrategy: \(multiClassStrategy.description)\n"
            }
            if hasAveragingConfig {
                output += "\(indent) averagingConfig {\n"
                if let outDescAveragingConfig = averagingConfig {
                    output += try outDescAveragingConfig.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasNumClasses {
                    hashCode = (hashCode &* 31) &+ numClasses.hashValue
                }
                if hasFeatureFractionPerTree {
                    hashCode = (hashCode &* 31) &+ featureFractionPerTree.hashValue
                }
                if hasFeatureFractionPerLevel {
                    hashCode = (hashCode &* 31) &+ featureFractionPerLevel.hashValue
                }
                if hasRegularization {
                    if let hashValueregularization = regularization?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueregularization
                    }
                }
                if hasConstraints {
                    if let hashValueconstraints = constraints?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueconstraints
                    }
                }
                if hasLearningRateTuner {
                    if let hashValuelearningRateTuner = learningRateTuner?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuelearningRateTuner
                    }
                }
                if hasPruningMode {
                     hashCode = (hashCode &* 31) &+ pruningMode.hashValue
                }
                if hasGrowingMode {
                     hashCode = (hashCode &* 31) &+ growingMode.hashValue
                }
                if hasMultiClassStrategy {
                     hashCode = (hashCode &* 31) &+ multiClassStrategy.hashValue
                }
                if hasAveragingConfig {
                    if let hashValueaveragingConfig = averagingConfig?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueaveragingConfig
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.BoostedTrees.Learner.LearnerConfig"
        }
        override public func className() -> String {
            return "Tensorflow.BoostedTrees.Learner.LearnerConfig"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.BoostedTrees.Learner.LearnerConfig = Tensorflow.BoostedTrees.Learner.LearnerConfig()
            public func getMessage() -> Tensorflow.BoostedTrees.Learner.LearnerConfig {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Number of classes.
            public var numClasses:UInt32 {
                get {
                    return builderResult.numClasses
                }
                set (value) {
                    builderResult.hasNumClasses = true
                    builderResult.numClasses = value
                }
            }
            public var hasNumClasses:Bool {
                get {
                    return builderResult.hasNumClasses
                }
            }
            @discardableResult
            public func setNumClasses(_ value:UInt32) -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder {
                self.numClasses = value
                return self
            }
            @discardableResult
            public func clearNumClasses() -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder{
                builderResult.hasNumClasses = false
                builderResult.numClasses = UInt32(0)
                return self
            }
            public var featureFractionPerTree:Float {
                get {
                    return builderResult.featureFractionPerTree
                }
                set (value) {
                    builderResult.hasFeatureFractionPerTree = true
                    builderResult.featureFractionPerTree = value
                }
            }
            public var hasFeatureFractionPerTree:Bool {
                get {
                    return builderResult.hasFeatureFractionPerTree
                }
            }
            @discardableResult
            public func setFeatureFractionPerTree(_ value:Float) -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder {
                self.featureFractionPerTree = value
                return self
            }
            @discardableResult
            public func clearFeatureFractionPerTree() -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder{
                builderResult.hasFeatureFractionPerTree = false
                builderResult.featureFractionPerTree = Float(0)
                return self
            }
            public var featureFractionPerLevel:Float {
                get {
                    return builderResult.featureFractionPerLevel
                }
                set (value) {
                    builderResult.hasFeatureFractionPerLevel = true
                    builderResult.featureFractionPerLevel = value
                }
            }
            public var hasFeatureFractionPerLevel:Bool {
                get {
                    return builderResult.hasFeatureFractionPerLevel
                }
            }
            @discardableResult
            public func setFeatureFractionPerLevel(_ value:Float) -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder {
                self.featureFractionPerLevel = value
                return self
            }
            @discardableResult
            public func clearFeatureFractionPerLevel() -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder{
                builderResult.hasFeatureFractionPerLevel = false
                builderResult.featureFractionPerLevel = Float(0)
                return self
            }
            /// Regularization.
            public var regularization:Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig! {
                get {
                    if regularizationBuilder_ != nil {
                        builderResult.regularization = regularizationBuilder_.getMessage()
                    }
                    return builderResult.regularization
                }
                set (value) {
                    builderResult.hasRegularization = true
                    builderResult.regularization = value
                }
            }
            public var hasRegularization:Bool {
                get {
                    return builderResult.hasRegularization
                }
            }
            fileprivate var regularizationBuilder_:Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder! {
                didSet {
                    builderResult.hasRegularization = true
                }
            }
            public func getRegularizationBuilder() -> Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder {
                if regularizationBuilder_ == nil {
                    regularizationBuilder_ = Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder()
                    builderResult.regularization = regularizationBuilder_.getMessage()
                    if regularization != nil {
                        try! regularizationBuilder_.mergeFrom(other: regularization)
                    }
                }
                return regularizationBuilder_
            }
            @discardableResult
            public func setRegularization(_ value:Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig!) -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder {
                self.regularization = value
                return self
            }
            @discardableResult
            public func mergeRegularization(value:Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig) throws -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder {
                if builderResult.hasRegularization {
                    builderResult.regularization = try Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.builderWithPrototype(prototype:builderResult.regularization).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.regularization = value
                }
                builderResult.hasRegularization = true
                return self
            }
            @discardableResult
            public func clearRegularization() -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder {
                regularizationBuilder_ = nil
                builderResult.hasRegularization = false
                builderResult.regularization = nil
                return self
            }
            /// Constraints.
            public var constraints:Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig! {
                get {
                    if constraintsBuilder_ != nil {
                        builderResult.constraints = constraintsBuilder_.getMessage()
                    }
                    return builderResult.constraints
                }
                set (value) {
                    builderResult.hasConstraints = true
                    builderResult.constraints = value
                }
            }
            public var hasConstraints:Bool {
                get {
                    return builderResult.hasConstraints
                }
            }
            fileprivate var constraintsBuilder_:Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder! {
                didSet {
                    builderResult.hasConstraints = true
                }
            }
            public func getConstraintsBuilder() -> Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder {
                if constraintsBuilder_ == nil {
                    constraintsBuilder_ = Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder()
                    builderResult.constraints = constraintsBuilder_.getMessage()
                    if constraints != nil {
                        try! constraintsBuilder_.mergeFrom(other: constraints)
                    }
                }
                return constraintsBuilder_
            }
            @discardableResult
            public func setConstraints(_ value:Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig!) -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder {
                self.constraints = value
                return self
            }
            @discardableResult
            public func mergeConstraints(value:Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig) throws -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder {
                if builderResult.hasConstraints {
                    builderResult.constraints = try Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.builderWithPrototype(prototype:builderResult.constraints).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.constraints = value
                }
                builderResult.hasConstraints = true
                return self
            }
            @discardableResult
            public func clearConstraints() -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder {
                constraintsBuilder_ = nil
                builderResult.hasConstraints = false
                builderResult.constraints = nil
                return self
            }
            /// Pruning.
                public var pruningMode:Tensorflow.BoostedTrees.Learner.LearnerConfig.PruningMode {
                    get {
                        return builderResult.pruningMode
                    }
                    set (value) {
                        builderResult.hasPruningMode = true
                        builderResult.pruningMode = value
                    }
                }
                public var hasPruningMode:Bool{
                    get {
                        return builderResult.hasPruningMode
                    }
                }
            @discardableResult
                public func setPruningMode(_ value:Tensorflow.BoostedTrees.Learner.LearnerConfig.PruningMode) -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder {
                  self.pruningMode = value
                  return self
                }
            @discardableResult
                public func clearPruningMode() -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder {
                   builderResult.hasPruningMode = false
                   builderResult.pruningMode = .prePrune
                   return self
                }
            /// Growing Mode.
                public var growingMode:Tensorflow.BoostedTrees.Learner.LearnerConfig.GrowingMode {
                    get {
                        return builderResult.growingMode
                    }
                    set (value) {
                        builderResult.hasGrowingMode = true
                        builderResult.growingMode = value
                    }
                }
                public var hasGrowingMode:Bool{
                    get {
                        return builderResult.hasGrowingMode
                    }
                }
            @discardableResult
                public func setGrowingMode(_ value:Tensorflow.BoostedTrees.Learner.LearnerConfig.GrowingMode) -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder {
                  self.growingMode = value
                  return self
                }
            @discardableResult
                public func clearGrowingMode() -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder {
                   builderResult.hasGrowingMode = false
                   builderResult.growingMode = .wholeTree
                   return self
                }
            /// Learning rate.
            public var learningRateTuner:Tensorflow.BoostedTrees.Learner.LearningRateConfig! {
                get {
                    if learningRateTunerBuilder_ != nil {
                        builderResult.learningRateTuner = learningRateTunerBuilder_.getMessage()
                    }
                    return builderResult.learningRateTuner
                }
                set (value) {
                    builderResult.hasLearningRateTuner = true
                    builderResult.learningRateTuner = value
                }
            }
            public var hasLearningRateTuner:Bool {
                get {
                    return builderResult.hasLearningRateTuner
                }
            }
            fileprivate var learningRateTunerBuilder_:Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder! {
                didSet {
                    builderResult.hasLearningRateTuner = true
                }
            }
            public func getLearningRateTunerBuilder() -> Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder {
                if learningRateTunerBuilder_ == nil {
                    learningRateTunerBuilder_ = Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder()
                    builderResult.learningRateTuner = learningRateTunerBuilder_.getMessage()
                    if learningRateTuner != nil {
                        try! learningRateTunerBuilder_.mergeFrom(other: learningRateTuner)
                    }
                }
                return learningRateTunerBuilder_
            }
            @discardableResult
            public func setLearningRateTuner(_ value:Tensorflow.BoostedTrees.Learner.LearningRateConfig!) -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder {
                self.learningRateTuner = value
                return self
            }
            @discardableResult
            public func mergeLearningRateTuner(value:Tensorflow.BoostedTrees.Learner.LearningRateConfig) throws -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder {
                if builderResult.hasLearningRateTuner {
                    builderResult.learningRateTuner = try Tensorflow.BoostedTrees.Learner.LearningRateConfig.builderWithPrototype(prototype:builderResult.learningRateTuner).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.learningRateTuner = value
                }
                builderResult.hasLearningRateTuner = true
                return self
            }
            @discardableResult
            public func clearLearningRateTuner() -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder {
                learningRateTunerBuilder_ = nil
                builderResult.hasLearningRateTuner = false
                builderResult.learningRateTuner = nil
                return self
            }
            /// Multi-class strategy.
                public var multiClassStrategy:Tensorflow.BoostedTrees.Learner.LearnerConfig.MultiClassStrategy {
                    get {
                        return builderResult.multiClassStrategy
                    }
                    set (value) {
                        builderResult.hasMultiClassStrategy = true
                        builderResult.multiClassStrategy = value
                    }
                }
                public var hasMultiClassStrategy:Bool{
                    get {
                        return builderResult.hasMultiClassStrategy
                    }
                }
            @discardableResult
                public func setMultiClassStrategy(_ value:Tensorflow.BoostedTrees.Learner.LearnerConfig.MultiClassStrategy) -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder {
                  self.multiClassStrategy = value
                  return self
                }
            @discardableResult
                public func clearMultiClassStrategy() -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder {
                   builderResult.hasMultiClassStrategy = false
                   builderResult.multiClassStrategy = .treePerClass
                   return self
                }
            /// If you want to average the ensembles (for regularization), provide the
            /// config below.
            public var averagingConfig:Tensorflow.BoostedTrees.Learner.AveragingConfig! {
                get {
                    if averagingConfigBuilder_ != nil {
                        builderResult.averagingConfig = averagingConfigBuilder_.getMessage()
                    }
                    return builderResult.averagingConfig
                }
                set (value) {
                    builderResult.hasAveragingConfig = true
                    builderResult.averagingConfig = value
                }
            }
            public var hasAveragingConfig:Bool {
                get {
                    return builderResult.hasAveragingConfig
                }
            }
            fileprivate var averagingConfigBuilder_:Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder! {
                didSet {
                    builderResult.hasAveragingConfig = true
                }
            }
            public func getAveragingConfigBuilder() -> Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder {
                if averagingConfigBuilder_ == nil {
                    averagingConfigBuilder_ = Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder()
                    builderResult.averagingConfig = averagingConfigBuilder_.getMessage()
                    if averagingConfig != nil {
                        try! averagingConfigBuilder_.mergeFrom(other: averagingConfig)
                    }
                }
                return averagingConfigBuilder_
            }
            @discardableResult
            public func setAveragingConfig(_ value:Tensorflow.BoostedTrees.Learner.AveragingConfig!) -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder {
                self.averagingConfig = value
                return self
            }
            @discardableResult
            public func mergeAveragingConfig(value:Tensorflow.BoostedTrees.Learner.AveragingConfig) throws -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder {
                if builderResult.hasAveragingConfig {
                    builderResult.averagingConfig = try Tensorflow.BoostedTrees.Learner.AveragingConfig.builderWithPrototype(prototype:builderResult.averagingConfig).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.averagingConfig = value
                }
                builderResult.hasAveragingConfig = true
                return self
            }
            @discardableResult
            public func clearAveragingConfig() -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder {
                averagingConfigBuilder_ = nil
                builderResult.hasAveragingConfig = false
                builderResult.averagingConfig = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder {
                builderResult = Tensorflow.BoostedTrees.Learner.LearnerConfig()
                return self
            }
            override public func clone() throws -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder {
                return try Tensorflow.BoostedTrees.Learner.LearnerConfig.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.BoostedTrees.Learner.LearnerConfig {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.BoostedTrees.Learner.LearnerConfig {
                let returnMe:Tensorflow.BoostedTrees.Learner.LearnerConfig = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.BoostedTrees.Learner.LearnerConfig) throws -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder {
                if other == Tensorflow.BoostedTrees.Learner.LearnerConfig() {
                    return self
                }
                if other.hasNumClasses {
                    numClasses = other.numClasses
                }
                if other.hasFeatureFractionPerTree {
                    featureFractionPerTree = other.featureFractionPerTree
                }
                if other.hasFeatureFractionPerLevel {
                    featureFractionPerLevel = other.featureFractionPerLevel
                }
                if (other.hasRegularization) {
                    try mergeRegularization(value: other.regularization)
                }
                if (other.hasConstraints) {
                    try mergeConstraints(value: other.constraints)
                }
                if other.hasPruningMode {
                    pruningMode = other.pruningMode
                }
                if other.hasGrowingMode {
                    growingMode = other.growingMode
                }
                if (other.hasLearningRateTuner) {
                    try mergeLearningRateTuner(value: other.learningRateTuner)
                }
                if other.hasMultiClassStrategy {
                    multiClassStrategy = other.multiClassStrategy
                }
                if (other.hasAveragingConfig) {
                    try mergeAveragingConfig(value: other.averagingConfig)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        numClasses = try codedInputStream.readUInt32()

                    case 21:
                        featureFractionPerTree = try codedInputStream.readFloat()

                    case 29:
                        featureFractionPerLevel = try codedInputStream.readFloat()

                    case 34:
                        let subBuilder:Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder = Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder()
                        if hasRegularization {
                            try subBuilder.mergeFrom(other: regularization)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        regularization = subBuilder.buildPartial()

                    case 42:
                        let subBuilder:Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder = Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder()
                        if hasConstraints {
                            try subBuilder.mergeFrom(other: constraints)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        constraints = subBuilder.buildPartial()

                    case 50:
                        let subBuilder:Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder = Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder()
                        if hasLearningRateTuner {
                            try subBuilder.mergeFrom(other: learningRateTuner)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        learningRateTuner = subBuilder.buildPartial()

                    case 64:
                        let valueIntpruningMode = try codedInputStream.readEnum()
                        if let enumspruningMode = Tensorflow.BoostedTrees.Learner.LearnerConfig.PruningMode(rawValue:valueIntpruningMode){
                            pruningMode = enumspruningMode
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 8, value:Int64(valueIntpruningMode))
                        }

                    case 72:
                        let valueIntgrowingMode = try codedInputStream.readEnum()
                        if let enumsgrowingMode = Tensorflow.BoostedTrees.Learner.LearnerConfig.GrowingMode(rawValue:valueIntgrowingMode){
                            growingMode = enumsgrowingMode
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 9, value:Int64(valueIntgrowingMode))
                        }

                    case 80:
                        let valueIntmultiClassStrategy = try codedInputStream.readEnum()
                        if let enumsmultiClassStrategy = Tensorflow.BoostedTrees.Learner.LearnerConfig.MultiClassStrategy(rawValue:valueIntmultiClassStrategy){
                            multiClassStrategy = enumsmultiClassStrategy
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 10, value:Int64(valueIntmultiClassStrategy))
                        }

                    case 90:
                        let subBuilder:Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder = Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder()
                        if hasAveragingConfig {
                            try subBuilder.mergeFrom(other: averagingConfig)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        averagingConfig = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder {
                let resultDecodedBuilder = Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder()
                if let jsonValueNumClasses = jsonMap["numClasses"] as? UInt {
                    resultDecodedBuilder.numClasses = UInt32(jsonValueNumClasses)
                } else if let jsonValueNumClasses = jsonMap["numClasses"] as? String {
                    resultDecodedBuilder.numClasses = UInt32(jsonValueNumClasses)!
                }
                if let jsonValueFeatureFractionPerTree = jsonMap["featureFractionPerTree"] as? Float {
                    resultDecodedBuilder.featureFractionPerTree = Float(jsonValueFeatureFractionPerTree)
                } else if let jsonValueFeatureFractionPerTree = jsonMap["featureFractionPerTree"] as? String {
                    resultDecodedBuilder.featureFractionPerTree = Float(jsonValueFeatureFractionPerTree)!
                }
                if let jsonValueFeatureFractionPerLevel = jsonMap["featureFractionPerLevel"] as? Float {
                    resultDecodedBuilder.featureFractionPerLevel = Float(jsonValueFeatureFractionPerLevel)
                } else if let jsonValueFeatureFractionPerLevel = jsonMap["featureFractionPerLevel"] as? String {
                    resultDecodedBuilder.featureFractionPerLevel = Float(jsonValueFeatureFractionPerLevel)!
                }
                if let jsonValueRegularization = jsonMap["regularization"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.regularization = try Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder.decodeToBuilder(jsonMap:jsonValueRegularization).build()

                }
                if let jsonValueConstraints = jsonMap["constraints"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.constraints = try Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder.decodeToBuilder(jsonMap:jsonValueConstraints).build()

                }
                if let jsonValuePruningMode = jsonMap["pruningMode"] as? String {
                    resultDecodedBuilder.pruningMode = try Tensorflow.BoostedTrees.Learner.LearnerConfig.PruningMode.fromString(str: jsonValuePruningMode)
                }
                if let jsonValueGrowingMode = jsonMap["growingMode"] as? String {
                    resultDecodedBuilder.growingMode = try Tensorflow.BoostedTrees.Learner.LearnerConfig.GrowingMode.fromString(str: jsonValueGrowingMode)
                }
                if let jsonValueLearningRateTuner = jsonMap["learningRateTuner"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.learningRateTuner = try Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder.decodeToBuilder(jsonMap:jsonValueLearningRateTuner).build()

                }
                if let jsonValueMultiClassStrategy = jsonMap["multiClassStrategy"] as? String {
                    resultDecodedBuilder.multiClassStrategy = try Tensorflow.BoostedTrees.Learner.LearnerConfig.MultiClassStrategy.fromString(str: jsonValueMultiClassStrategy)
                }
                if let jsonValueAveragingConfig = jsonMap["averagingConfig"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.averagingConfig = try Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder.decodeToBuilder(jsonMap:jsonValueAveragingConfig).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig> {
        var mergedArray = Array<Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig? {
        return try Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig {
        return try Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.BoostedTrees.Learner.LearnerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig {
        return try Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig {
        return try Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig {
        return try Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig {
        return try Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig {
        return try Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "l1": return self.l1
        case "l2": return self.l2
        case "treeComplexity": return self.treeComplexity
        default: return nil
        }
    }
}
extension Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "l1": return self.l1
            case "l2": return self.l2
            case "treeComplexity": return self.treeComplexity
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "l1":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.l1 = newSubscriptValue
            case "l2":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.l2 = newSubscriptValue
            case "treeComplexity":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.treeComplexity = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig> {
        var mergedArray = Array<Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig? {
        return try Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig {
        return try Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.BoostedTrees.Learner.LearnerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig {
        return try Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig {
        return try Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig {
        return try Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig {
        return try Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig {
        return try Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "maxTreeDepth": return self.maxTreeDepth
        case "minNodeWeight": return self.minNodeWeight
        default: return nil
        }
    }
}
extension Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "maxTreeDepth": return self.maxTreeDepth
            case "minNodeWeight": return self.minNodeWeight
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "maxTreeDepth":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.maxTreeDepth = newSubscriptValue
            case "minNodeWeight":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.minNodeWeight = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.BoostedTrees.Learner.LearningRateConfig: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.BoostedTrees.Learner.LearningRateConfig> {
        var mergedArray = Array<Tensorflow.BoostedTrees.Learner.LearningRateConfig>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Learner.LearningRateConfig? {
        return try Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.BoostedTrees.Learner.LearningRateConfig {
        return try Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.BoostedTrees.Learner.LearnerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Learner.LearningRateConfig {
        return try Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Learner.LearningRateConfig {
        return try Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Learner.LearningRateConfig {
        return try Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Learner.LearningRateConfig {
        return try Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Learner.LearningRateConfig {
        return try Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "fixed": return self.fixed
        case "dropout": return self.dropout
        case "lineSearch": return self.lineSearch
        default: return nil
        }
    }
}
extension Tensorflow.BoostedTrees.Learner.LearningRateConfig.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "fixed": return self.fixed
            case "dropout": return self.dropout
            case "lineSearch": return self.lineSearch
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "fixed":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig else {
                    return
                }
                self.fixed = newSubscriptValue
            case "dropout":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig else {
                    return
                }
                self.dropout = newSubscriptValue
            case "lineSearch":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig else {
                    return
                }
                self.lineSearch = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig> {
        var mergedArray = Array<Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig? {
        return try Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig {
        return try Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.BoostedTrees.Learner.LearnerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig {
        return try Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig {
        return try Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig {
        return try Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig {
        return try Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig {
        return try Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "learningRate": return self.learningRate
        default: return nil
        }
    }
}
extension Tensorflow.BoostedTrees.Learner.LearningRateFixedConfig.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "learningRate": return self.learningRate
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "learningRate":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.learningRate = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig> {
        var mergedArray = Array<Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig? {
        return try Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig {
        return try Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.BoostedTrees.Learner.LearnerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig {
        return try Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig {
        return try Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig {
        return try Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig {
        return try Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig {
        return try Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "maxLearningRate": return self.maxLearningRate
        case "numSteps": return self.numSteps
        default: return nil
        }
    }
}
extension Tensorflow.BoostedTrees.Learner.LearningRateLineSearchConfig.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "maxLearningRate": return self.maxLearningRate
            case "numSteps": return self.numSteps
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "maxLearningRate":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.maxLearningRate = newSubscriptValue
            case "numSteps":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.numSteps = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.BoostedTrees.Learner.AveragingConfig: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.BoostedTrees.Learner.AveragingConfig> {
        var mergedArray = Array<Tensorflow.BoostedTrees.Learner.AveragingConfig>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Learner.AveragingConfig? {
        return try Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.BoostedTrees.Learner.AveragingConfig {
        return try Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.BoostedTrees.Learner.LearnerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Learner.AveragingConfig {
        return try Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Learner.AveragingConfig {
        return try Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Learner.AveragingConfig {
        return try Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Learner.AveragingConfig {
        return try Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Learner.AveragingConfig {
        return try Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "averageLastNTrees": return self.averageLastNTrees
        case "averageLastPercentTrees": return self.averageLastPercentTrees
        default: return nil
        }
    }
}
extension Tensorflow.BoostedTrees.Learner.AveragingConfig.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "averageLastNTrees": return self.averageLastNTrees
            case "averageLastPercentTrees": return self.averageLastPercentTrees
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "averageLastNTrees":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.averageLastNTrees = newSubscriptValue
            case "averageLastPercentTrees":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.averageLastPercentTrees = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig> {
        var mergedArray = Array<Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig? {
        return try Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig {
        return try Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.BoostedTrees.Learner.LearnerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig {
        return try Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig {
        return try Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig {
        return try Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig {
        return try Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig {
        return try Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "dropoutProbability": return self.dropoutProbability
        case "probabilityOfSkippingDropout": return self.probabilityOfSkippingDropout
        case "learningRate": return self.learningRate
        default: return nil
        }
    }
}
extension Tensorflow.BoostedTrees.Learner.LearningRateDropoutDrivenConfig.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "dropoutProbability": return self.dropoutProbability
            case "probabilityOfSkippingDropout": return self.probabilityOfSkippingDropout
            case "learningRate": return self.learningRate
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "dropoutProbability":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.dropoutProbability = newSubscriptValue
            case "probabilityOfSkippingDropout":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.probabilityOfSkippingDropout = newSubscriptValue
            case "learningRate":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.learningRate = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.BoostedTrees.Learner.LearnerConfig: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.BoostedTrees.Learner.LearnerConfig> {
        var mergedArray = Array<Tensorflow.BoostedTrees.Learner.LearnerConfig>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Learner.LearnerConfig? {
        return try Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.BoostedTrees.Learner.LearnerConfig {
        return try Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.BoostedTrees.Learner.LearnerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Learner.LearnerConfig {
        return try Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.BoostedTrees.Learner.LearnerConfig {
        return try Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Learner.LearnerConfig {
        return try Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BoostedTrees.Learner.LearnerConfig {
        return try Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BoostedTrees.Learner.LearnerConfig {
        return try Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "numClasses": return self.numClasses
        case "featureFractionPerTree": return self.featureFractionPerTree
        case "featureFractionPerLevel": return self.featureFractionPerLevel
        case "regularization": return self.regularization
        case "constraints": return self.constraints
        case "pruningMode": return self.pruningMode
        case "growingMode": return self.growingMode
        case "learningRateTuner": return self.learningRateTuner
        case "multiClassStrategy": return self.multiClassStrategy
        case "averagingConfig": return self.averagingConfig
        default: return nil
        }
    }
}
extension Tensorflow.BoostedTrees.Learner.LearnerConfig.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "numClasses": return self.numClasses
            case "featureFractionPerTree": return self.featureFractionPerTree
            case "featureFractionPerLevel": return self.featureFractionPerLevel
            case "regularization": return self.regularization
            case "constraints": return self.constraints
            case "pruningMode": return self.pruningMode
            case "growingMode": return self.growingMode
            case "learningRateTuner": return self.learningRateTuner
            case "multiClassStrategy": return self.multiClassStrategy
            case "averagingConfig": return self.averagingConfig
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "numClasses":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.numClasses = newSubscriptValue
            case "featureFractionPerTree":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.featureFractionPerTree = newSubscriptValue
            case "featureFractionPerLevel":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.featureFractionPerLevel = newSubscriptValue
            case "regularization":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.BoostedTrees.Learner.TreeRegularizationConfig else {
                    return
                }
                self.regularization = newSubscriptValue
            case "constraints":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.BoostedTrees.Learner.TreeConstraintsConfig else {
                    return
                }
                self.constraints = newSubscriptValue
            case "pruningMode":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.BoostedTrees.Learner.LearnerConfig.PruningMode else {
                    return
                }
                self.pruningMode = newSubscriptValue
            case "growingMode":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.BoostedTrees.Learner.LearnerConfig.GrowingMode else {
                    return
                }
                self.growingMode = newSubscriptValue
            case "learningRateTuner":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.BoostedTrees.Learner.LearningRateConfig else {
                    return
                }
                self.learningRateTuner = newSubscriptValue
            case "multiClassStrategy":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.BoostedTrees.Learner.LearnerConfig.MultiClassStrategy else {
                    return
                }
                self.multiClassStrategy = newSubscriptValue
            case "averagingConfig":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.BoostedTrees.Learner.AveragingConfig else {
                    return
                }
                self.averagingConfig = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

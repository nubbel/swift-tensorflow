/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "compare_test.proto"
/// Syntax "Proto2"

import Foundation
import ProtocolBuffers


public struct CompareTest { }

public extension CompareTest {
    public struct CompareTestRoot {
        public static let `default` = CompareTestRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }



    //Enum type declaration start 

    public enum Enum:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
        case a = 0
        case b = 1
        case c = 2
        public func toString() -> String {
            switch self {
            case .a: return "A"
            case .b: return "B"
            case .c: return "C"
            }
        }
        public static func fromString(str:String) throws -> CompareTest.Enum {
            switch str {
            case "A":    return .a
            case "B":    return .b
            case "C":    return .c
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .a: return ".a"
            case .b: return ".b"
            case .c: return ".c"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:Enum, rhs:Enum) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 

    final public class Small : GeneratedMessage {

        public static func == (lhs: CompareTest.Small, rhs: CompareTest.Small) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.strings == rhs.strings)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var strings:Array<String> = Array<String>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if !strings.isEmpty {
                for oneValuestrings in strings {
                    try codedOutputStream.writeString(fieldNumber: 1, value:oneValuestrings)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            var dataSizeStrings:Int32 = 0
            for oneValuestrings in strings {
                dataSizeStrings += oneValuestrings.computeStringSizeNoTag()
            }
            serialize_size += dataSizeStrings
            serialize_size += 1 * Int32(strings.count)
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> CompareTest.Small.Builder {
            return CompareTest.Small.classBuilder() as! CompareTest.Small.Builder
        }
        public func getBuilder() -> CompareTest.Small.Builder {
            return classBuilder() as! CompareTest.Small.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return CompareTest.Small.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return CompareTest.Small.Builder()
        }
        public func toBuilder() throws -> CompareTest.Small.Builder {
            return try CompareTest.Small.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:CompareTest.Small) throws -> CompareTest.Small.Builder {
            return try CompareTest.Small.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !strings.isEmpty {
                var jsonArrayStrings:Array<String> = []
                for oneValueStrings in strings {
                    jsonArrayStrings.append(oneValueStrings)
                }
                jsonMap["strings"] = jsonArrayStrings
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> CompareTest.Small {
            return try CompareTest.Small.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> CompareTest.Small {
            return try CompareTest.Small.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var stringsElementIndex:Int = 0
            for oneValueStrings in strings  {
                output += "\(indent) strings[\(stringsElementIndex)]: \(oneValueStrings)\n"
                stringsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneValueStrings in strings {
                    hashCode = (hashCode &* 31) &+ oneValueStrings.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "CompareTest.Small"
        }
        override public func className() -> String {
            return "CompareTest.Small"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:CompareTest.Small = CompareTest.Small()
            public func getMessage() -> CompareTest.Small {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var strings:Array<String> {
                get {
                    return builderResult.strings
                }
                set (array) {
                    builderResult.strings = array
                }
            }
            @discardableResult
            public func setStrings(_ value:Array<String>) -> CompareTest.Small.Builder {
                self.strings = value
                return self
            }
            @discardableResult
            public func clearStrings() -> CompareTest.Small.Builder {
                builderResult.strings.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> CompareTest.Small.Builder {
                builderResult = CompareTest.Small()
                return self
            }
            override public func clone() throws -> CompareTest.Small.Builder {
                return try CompareTest.Small.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> CompareTest.Small {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> CompareTest.Small {
                let returnMe:CompareTest.Small = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:CompareTest.Small) throws -> CompareTest.Small.Builder {
                if other == CompareTest.Small() {
                    return self
                }
                if !other.strings.isEmpty {
                    builderResult.strings += other.strings
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> CompareTest.Small.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> CompareTest.Small.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        strings += [try codedInputStream.readString()]

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> CompareTest.Small.Builder {
                let resultDecodedBuilder = CompareTest.Small.Builder()
                if let jsonValueStrings = jsonMap["strings"] as? Array<String> {
                    var jsonArrayStrings:Array<String> = []
                    for oneValueStrings in jsonValueStrings {
                        jsonArrayStrings.append(oneValueStrings)
                    }
                    resultDecodedBuilder.strings = jsonArrayStrings
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> CompareTest.Small.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try CompareTest.Small.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class Medium : GeneratedMessage {

        public static func == (lhs: CompareTest.Medium, rhs: CompareTest.Medium) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.int32S == rhs.int32S)
            fieldCheck = fieldCheck && (lhs.smalls == rhs.smalls)
            fieldCheck = fieldCheck && (lhs.groupA == rhs.groupA)
            fieldCheck = fieldCheck && (lhs.floats == rhs.floats)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        final public class GroupA : GeneratedMessage {

            public static func == (lhs: CompareTest.Medium.GroupA, rhs: CompareTest.Medium.GroupA) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.groupB == rhs.groupB)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }



            //Nested type declaration start

            final public class GroupB : GeneratedMessage {

                public static func == (lhs: CompareTest.Medium.GroupA.GroupB, rhs: CompareTest.Medium.GroupA.GroupB) -> Bool {
                    if lhs === rhs {
                        return true
                    }
                    var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                    fieldCheck = fieldCheck && (lhs.hasStrings == rhs.hasStrings) && (!lhs.hasStrings || lhs.strings == rhs.strings)
                    fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                    return fieldCheck
                }

                public fileprivate(set) var strings:String = ""
                public fileprivate(set) var hasStrings:Bool = false

                required public init() {
                    super.init()
                }
                override public func isInitialized() -> Bool {
                    if !hasStrings {
                        return false
                    }
                    return true
                }
                override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                    if hasStrings {
                        try codedOutputStream.writeString(fieldNumber: 5, value:strings)
                    }
                    try unknownFields.writeTo(codedOutputStream: codedOutputStream)
                }
                override public func serializedSize() -> Int32 {
                    var serialize_size:Int32 = memoizedSerializedSize
                    if serialize_size != -1 {
                     return serialize_size
                    }

                    serialize_size = 0
                    if hasStrings {
                        serialize_size += strings.computeStringSize(fieldNumber: 5)
                    }
                    serialize_size += unknownFields.serializedSize()
                    memoizedSerializedSize = serialize_size
                    return serialize_size
                }
                public class func getBuilder() -> CompareTest.Medium.GroupA.GroupB.Builder {
                    return CompareTest.Medium.GroupA.GroupB.classBuilder() as! CompareTest.Medium.GroupA.GroupB.Builder
                }
                public func getBuilder() -> CompareTest.Medium.GroupA.GroupB.Builder {
                    return classBuilder() as! CompareTest.Medium.GroupA.GroupB.Builder
                }
                override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                    return CompareTest.Medium.GroupA.GroupB.Builder()
                }
                override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                    return CompareTest.Medium.GroupA.GroupB.Builder()
                }
                public func toBuilder() throws -> CompareTest.Medium.GroupA.GroupB.Builder {
                    return try CompareTest.Medium.GroupA.GroupB.builderWithPrototype(prototype:self)
                }
                public class func builderWithPrototype(prototype:CompareTest.Medium.GroupA.GroupB) throws -> CompareTest.Medium.GroupA.GroupB.Builder {
                    return try CompareTest.Medium.GroupA.GroupB.Builder().mergeFrom(other:prototype)
                }
                override public func encode() throws -> Dictionary<String,Any> {
                    guard isInitialized() else {
                        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                    }

                    var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                    if hasStrings {
                        jsonMap["strings"] = strings
                    }
                    return jsonMap
                }
                override class public func decode(jsonMap:Dictionary<String,Any>) throws -> CompareTest.Medium.GroupA.GroupB {
                    return try CompareTest.Medium.GroupA.GroupB.Builder.decodeToBuilder(jsonMap:jsonMap).build()
                }
                override class public func fromJSON(data:Data) throws -> CompareTest.Medium.GroupA.GroupB {
                    return try CompareTest.Medium.GroupA.GroupB.Builder.fromJSONToBuilder(data:data).build()
                }
                override public func getDescription(indent:String) throws -> String {
                    var output = ""
                    if hasStrings {
                        output += "\(indent) strings: \(strings) \n"
                    }
                    output += unknownFields.getDescription(indent: indent)
                    return output
                }
                override public var hashValue:Int {
                    get {
                        var hashCode:Int = 7
                        if hasStrings {
                            hashCode = (hashCode &* 31) &+ strings.hashValue
                        }
                        hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                        return hashCode
                    }
                }


                //Meta information declaration start

                override public class func className() -> String {
                    return "CompareTest.Medium.GroupA.GroupB"
                }
                override public func className() -> String {
                    return "CompareTest.Medium.GroupA.GroupB"
                }
                //Meta information declaration end

                final public class Builder : GeneratedMessageBuilder {
                    fileprivate var builderResult:CompareTest.Medium.GroupA.GroupB = CompareTest.Medium.GroupA.GroupB()
                    public func getMessage() -> CompareTest.Medium.GroupA.GroupB {
                        return builderResult
                    }

                    required override public init () {
                        super.init()
                    }
                    public var strings:String {
                        get {
                            return builderResult.strings
                        }
                        set (value) {
                            builderResult.hasStrings = true
                            builderResult.strings = value
                        }
                    }
                    public var hasStrings:Bool {
                        get {
                            return builderResult.hasStrings
                        }
                    }
                    @discardableResult
                    public func setStrings(_ value:String) -> CompareTest.Medium.GroupA.GroupB.Builder {
                        self.strings = value
                        return self
                    }
                    @discardableResult
                    public func clearStrings() -> CompareTest.Medium.GroupA.GroupB.Builder{
                        builderResult.hasStrings = false
                        builderResult.strings = ""
                        return self
                    }
                    override public var internalGetResult:GeneratedMessage {
                        get {
                            return builderResult
                        }
                    }
                    @discardableResult
                    override public func clear() -> CompareTest.Medium.GroupA.GroupB.Builder {
                        builderResult = CompareTest.Medium.GroupA.GroupB()
                        return self
                    }
                    override public func clone() throws -> CompareTest.Medium.GroupA.GroupB.Builder {
                        return try CompareTest.Medium.GroupA.GroupB.builderWithPrototype(prototype:builderResult)
                    }
                    override public func build() throws -> CompareTest.Medium.GroupA.GroupB {
                        try checkInitialized()
                        return buildPartial()
                    }
                    public func buildPartial() -> CompareTest.Medium.GroupA.GroupB {
                        let returnMe:CompareTest.Medium.GroupA.GroupB = builderResult
                        return returnMe
                    }
                    @discardableResult
                    public func mergeFrom(other:CompareTest.Medium.GroupA.GroupB) throws -> CompareTest.Medium.GroupA.GroupB.Builder {
                        if other == CompareTest.Medium.GroupA.GroupB() {
                            return self
                        }
                        if other.hasStrings {
                            strings = other.strings
                        }
                        try merge(unknownField: other.unknownFields)
                        return self
                    }
                    @discardableResult
                    override public func mergeFrom(codedInputStream: CodedInputStream) throws -> CompareTest.Medium.GroupA.GroupB.Builder {
                        return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                    }
                    @discardableResult
                    override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> CompareTest.Medium.GroupA.GroupB.Builder {
                        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                        while (true) {
                            let protobufTag = try codedInputStream.readTag()
                            switch protobufTag {
                            case 0: 
                                self.unknownFields = try unknownFieldsBuilder.build()
                                return self

                            case 42:
                                strings = try codedInputStream.readString()

                            default:
                                if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                    unknownFields = try unknownFieldsBuilder.build()
                                    return self
                                }
                            }
                        }
                    }
                    class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> CompareTest.Medium.GroupA.GroupB.Builder {
                        let resultDecodedBuilder = CompareTest.Medium.GroupA.GroupB.Builder()
                        if let jsonValueStrings = jsonMap["strings"] as? String {
                            resultDecodedBuilder.strings = jsonValueStrings
                        }
                        return resultDecodedBuilder
                    }
                    override class public func fromJSONToBuilder(data:Data) throws -> CompareTest.Medium.GroupA.GroupB.Builder {
                        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        return try CompareTest.Medium.GroupA.GroupB.Builder.decodeToBuilder(jsonMap:jsDataCast)
                    }
                }

            }

            //Nested type declaration end

            public fileprivate(set) var groupB:Array<CompareTest.Medium.GroupA.GroupB>  = Array<CompareTest.Medium.GroupA.GroupB>()
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                var isInitGroupB:Bool = true
                for oneElementGroupB in groupB {
                    if !oneElementGroupB.isInitialized() {
                        isInitGroupB = false
                        break 
                    }
                }
                if !isInitGroupB {
                    return isInitGroupB
                }
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                for oneElementGroupB in groupB {
                      try codedOutputStream.writeGroup(fieldNumber: 4, value:oneElementGroupB)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                for oneElementGroupB in groupB {
                    serialize_size += oneElementGroupB.computeGroupSize(fieldNumber: 4)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> CompareTest.Medium.GroupA.Builder {
                return CompareTest.Medium.GroupA.classBuilder() as! CompareTest.Medium.GroupA.Builder
            }
            public func getBuilder() -> CompareTest.Medium.GroupA.Builder {
                return classBuilder() as! CompareTest.Medium.GroupA.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return CompareTest.Medium.GroupA.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return CompareTest.Medium.GroupA.Builder()
            }
            public func toBuilder() throws -> CompareTest.Medium.GroupA.Builder {
                return try CompareTest.Medium.GroupA.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:CompareTest.Medium.GroupA) throws -> CompareTest.Medium.GroupA.Builder {
                return try CompareTest.Medium.GroupA.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if !groupB.isEmpty {
                    var jsonArrayGroupB:Array<Dictionary<String,Any>> = []
                    for oneValueGroupB in groupB {
                        let ecodedMessageGroupB = try oneValueGroupB.encode()
                        jsonArrayGroupB.append(ecodedMessageGroupB)
                    }
                    jsonMap["groupb"] = jsonArrayGroupB
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> CompareTest.Medium.GroupA {
                return try CompareTest.Medium.GroupA.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> CompareTest.Medium.GroupA {
                return try CompareTest.Medium.GroupA.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                var groupBElementIndex:Int = 0
                for oneElementGroupB in groupB {
                    output += "\(indent) groupB[\(groupBElementIndex)] {\n"
                    output += try oneElementGroupB.getDescription(indent: "\(indent)  ")
                    output += "\(indent)}\n"
                    groupBElementIndex += 1
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    for oneElementGroupB in groupB {
                        hashCode = (hashCode &* 31) &+ oneElementGroupB.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "CompareTest.Medium.GroupA"
            }
            override public func className() -> String {
                return "CompareTest.Medium.GroupA"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:CompareTest.Medium.GroupA = CompareTest.Medium.GroupA()
                public func getMessage() -> CompareTest.Medium.GroupA {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var groupB:Array<CompareTest.Medium.GroupA.GroupB> {
                    get {
                        return builderResult.groupB
                    }
                    set (value) {
                        builderResult.groupB = value
                    }
                }
                @discardableResult
                public func setGroupB(_ value:Array<CompareTest.Medium.GroupA.GroupB>) -> CompareTest.Medium.GroupA.Builder {
                    self.groupB = value
                    return self
                }
                @discardableResult
                public func clearGroupB() -> CompareTest.Medium.GroupA.Builder {
                    builderResult.groupB.removeAll(keepingCapacity: false)
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> CompareTest.Medium.GroupA.Builder {
                    builderResult = CompareTest.Medium.GroupA()
                    return self
                }
                override public func clone() throws -> CompareTest.Medium.GroupA.Builder {
                    return try CompareTest.Medium.GroupA.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> CompareTest.Medium.GroupA {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> CompareTest.Medium.GroupA {
                    let returnMe:CompareTest.Medium.GroupA = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:CompareTest.Medium.GroupA) throws -> CompareTest.Medium.GroupA.Builder {
                    if other == CompareTest.Medium.GroupA() {
                        return self
                    }
                    if !other.groupB.isEmpty  {
                         builderResult.groupB += other.groupB
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> CompareTest.Medium.GroupA.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> CompareTest.Medium.GroupA.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 35:
                            let subBuilder = CompareTest.Medium.GroupA.GroupB.Builder()
                            try codedInputStream.readGroup(fieldNumber:4, builder:subBuilder,extensionRegistry:extensionRegistry)
                            groupB.append(subBuilder.buildPartial())

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> CompareTest.Medium.GroupA.Builder {
                    let resultDecodedBuilder = CompareTest.Medium.GroupA.Builder()
                    if let jsonValueGroupB = jsonMap["groupb"] as? Array<Dictionary<String,Any>> {
                        var jsonArrayGroupB:Array<CompareTest.Medium.GroupA.GroupB> = []
                        for oneValueGroupB in jsonValueGroupB {
                            let messageFromStringGroupB = try CompareTest.Medium.GroupA.GroupB.Builder.decodeToBuilder(jsonMap:oneValueGroupB).build()

                            jsonArrayGroupB.append(messageFromStringGroupB)
                        }
                        resultDecodedBuilder.groupB = jsonArrayGroupB
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> CompareTest.Medium.GroupA.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try CompareTest.Medium.GroupA.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        public fileprivate(set) var int32S:Array<Int32> = Array<Int32>()
        public fileprivate(set) var smalls:Array<CompareTest.Small>  = Array<CompareTest.Small>()
        public fileprivate(set) var groupA:Array<CompareTest.Medium.GroupA>  = Array<CompareTest.Medium.GroupA>()
        public fileprivate(set) var floats:Array<Float> = Array<Float>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            var isInitGroupA:Bool = true
            for oneElementGroupA in groupA {
                if !oneElementGroupA.isInitialized() {
                    isInitGroupA = false
                    break 
                }
            }
            if !isInitGroupA {
                return isInitGroupA
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if !int32S.isEmpty {
                for oneValueint32S in int32S {
                    try codedOutputStream.writeInt32(fieldNumber: 1, value:oneValueint32S)
                }
            }
            for oneElementSmalls in smalls {
                  try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementSmalls)
            }
            for oneElementGroupA in groupA {
                  try codedOutputStream.writeGroup(fieldNumber: 3, value:oneElementGroupA)
            }
            if !floats.isEmpty {
                for oneValuefloats in floats {
                    try codedOutputStream.writeFloat(fieldNumber: 6, value:oneValuefloats)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            var dataSizeInt32S:Int32 = 0
            for oneValueint32S in int32S {
                dataSizeInt32S += oneValueint32S.computeInt32SizeNoTag()
            }
            serialize_size += dataSizeInt32S
            serialize_size += 1 * Int32(int32S.count)
            for oneElementSmalls in smalls {
                serialize_size += oneElementSmalls.computeMessageSize(fieldNumber: 2)
            }
            for oneElementGroupA in groupA {
                serialize_size += oneElementGroupA.computeGroupSize(fieldNumber: 3)
            }
            var dataSizeFloats:Int32 = 0
            dataSizeFloats = 4 * Int32(floats.count)
            serialize_size += dataSizeFloats
            serialize_size += 1 * Int32(floats.count)
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> CompareTest.Medium.Builder {
            return CompareTest.Medium.classBuilder() as! CompareTest.Medium.Builder
        }
        public func getBuilder() -> CompareTest.Medium.Builder {
            return classBuilder() as! CompareTest.Medium.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return CompareTest.Medium.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return CompareTest.Medium.Builder()
        }
        public func toBuilder() throws -> CompareTest.Medium.Builder {
            return try CompareTest.Medium.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:CompareTest.Medium) throws -> CompareTest.Medium.Builder {
            return try CompareTest.Medium.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !int32S.isEmpty {
                var jsonArrayInt32S:Array<Int> = []
                for oneValueInt32S in int32S {
                    jsonArrayInt32S.append(Int(oneValueInt32S))
                }
                jsonMap["int32s"] = jsonArrayInt32S
            }
            if !smalls.isEmpty {
                var jsonArraySmalls:Array<Dictionary<String,Any>> = []
                for oneValueSmalls in smalls {
                    let ecodedMessageSmalls = try oneValueSmalls.encode()
                    jsonArraySmalls.append(ecodedMessageSmalls)
                }
                jsonMap["smalls"] = jsonArraySmalls
            }
            if !groupA.isEmpty {
                var jsonArrayGroupA:Array<Dictionary<String,Any>> = []
                for oneValueGroupA in groupA {
                    let ecodedMessageGroupA = try oneValueGroupA.encode()
                    jsonArrayGroupA.append(ecodedMessageGroupA)
                }
                jsonMap["groupa"] = jsonArrayGroupA
            }
            if !floats.isEmpty {
                var jsonArrayFloats:Array<Float> = []
                for oneValueFloats in floats {
                    jsonArrayFloats.append(Float(oneValueFloats))
                }
                jsonMap["floats"] = jsonArrayFloats
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> CompareTest.Medium {
            return try CompareTest.Medium.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> CompareTest.Medium {
            return try CompareTest.Medium.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var int32SElementIndex:Int = 0
            for oneValueInt32S in int32S  {
                output += "\(indent) int32S[\(int32SElementIndex)]: \(oneValueInt32S)\n"
                int32SElementIndex += 1
            }
            var smallsElementIndex:Int = 0
            for oneElementSmalls in smalls {
                output += "\(indent) smalls[\(smallsElementIndex)] {\n"
                output += try oneElementSmalls.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                smallsElementIndex += 1
            }
            var groupAElementIndex:Int = 0
            for oneElementGroupA in groupA {
                output += "\(indent) groupA[\(groupAElementIndex)] {\n"
                output += try oneElementGroupA.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                groupAElementIndex += 1
            }
            var floatsElementIndex:Int = 0
            for oneValueFloats in floats  {
                output += "\(indent) floats[\(floatsElementIndex)]: \(oneValueFloats)\n"
                floatsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneValueInt32S in int32S {
                    hashCode = (hashCode &* 31) &+ oneValueInt32S.hashValue
                }
                for oneElementSmalls in smalls {
                    hashCode = (hashCode &* 31) &+ oneElementSmalls.hashValue
                }
                for oneElementGroupA in groupA {
                    hashCode = (hashCode &* 31) &+ oneElementGroupA.hashValue
                }
                for oneValueFloats in floats {
                    hashCode = (hashCode &* 31) &+ oneValueFloats.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "CompareTest.Medium"
        }
        override public func className() -> String {
            return "CompareTest.Medium"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:CompareTest.Medium = CompareTest.Medium()
            public func getMessage() -> CompareTest.Medium {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var int32S:Array<Int32> {
                get {
                    return builderResult.int32S
                }
                set (array) {
                    builderResult.int32S = array
                }
            }
            @discardableResult
            public func setInt32S(_ value:Array<Int32>) -> CompareTest.Medium.Builder {
                self.int32S = value
                return self
            }
            @discardableResult
            public func clearInt32S() -> CompareTest.Medium.Builder {
                builderResult.int32S.removeAll(keepingCapacity: false)
                return self
            }
            public var smalls:Array<CompareTest.Small> {
                get {
                    return builderResult.smalls
                }
                set (value) {
                    builderResult.smalls = value
                }
            }
            @discardableResult
            public func setSmalls(_ value:Array<CompareTest.Small>) -> CompareTest.Medium.Builder {
                self.smalls = value
                return self
            }
            @discardableResult
            public func clearSmalls() -> CompareTest.Medium.Builder {
                builderResult.smalls.removeAll(keepingCapacity: false)
                return self
            }
            public var groupA:Array<CompareTest.Medium.GroupA> {
                get {
                    return builderResult.groupA
                }
                set (value) {
                    builderResult.groupA = value
                }
            }
            @discardableResult
            public func setGroupA(_ value:Array<CompareTest.Medium.GroupA>) -> CompareTest.Medium.Builder {
                self.groupA = value
                return self
            }
            @discardableResult
            public func clearGroupA() -> CompareTest.Medium.Builder {
                builderResult.groupA.removeAll(keepingCapacity: false)
                return self
            }
            public var floats:Array<Float> {
                get {
                    return builderResult.floats
                }
                set (array) {
                    builderResult.floats = array
                }
            }
            @discardableResult
            public func setFloats(_ value:Array<Float>) -> CompareTest.Medium.Builder {
                self.floats = value
                return self
            }
            @discardableResult
            public func clearFloats() -> CompareTest.Medium.Builder {
                builderResult.floats.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> CompareTest.Medium.Builder {
                builderResult = CompareTest.Medium()
                return self
            }
            override public func clone() throws -> CompareTest.Medium.Builder {
                return try CompareTest.Medium.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> CompareTest.Medium {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> CompareTest.Medium {
                let returnMe:CompareTest.Medium = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:CompareTest.Medium) throws -> CompareTest.Medium.Builder {
                if other == CompareTest.Medium() {
                    return self
                }
                if !other.int32S.isEmpty {
                    builderResult.int32S += other.int32S
                }
                if !other.smalls.isEmpty  {
                     builderResult.smalls += other.smalls
                }
                if !other.groupA.isEmpty  {
                     builderResult.groupA += other.groupA
                }
                if !other.floats.isEmpty {
                    builderResult.floats += other.floats
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> CompareTest.Medium.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> CompareTest.Medium.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        int32S += [try codedInputStream.readInt32()]

                    case 18:
                        let subBuilder = CompareTest.Small.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        smalls.append(subBuilder.buildPartial())

                    case 27:
                        let subBuilder = CompareTest.Medium.GroupA.Builder()
                        try codedInputStream.readGroup(fieldNumber:3, builder:subBuilder,extensionRegistry:extensionRegistry)
                        groupA.append(subBuilder.buildPartial())

                    case 53:
                        floats += [try codedInputStream.readFloat()]

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> CompareTest.Medium.Builder {
                let resultDecodedBuilder = CompareTest.Medium.Builder()
                if let jsonValueInt32S = jsonMap["int32s"] as? Array<Int> {
                    var jsonArrayInt32S:Array<Int32> = []
                    for oneValueInt32S in jsonValueInt32S {
                        jsonArrayInt32S.append(Int32(oneValueInt32S))
                    }
                    resultDecodedBuilder.int32S = jsonArrayInt32S
                }
                if let jsonValueSmalls = jsonMap["smalls"] as? Array<Dictionary<String,Any>> {
                    var jsonArraySmalls:Array<CompareTest.Small> = []
                    for oneValueSmalls in jsonValueSmalls {
                        let messageFromStringSmalls = try CompareTest.Small.Builder.decodeToBuilder(jsonMap:oneValueSmalls).build()

                        jsonArraySmalls.append(messageFromStringSmalls)
                    }
                    resultDecodedBuilder.smalls = jsonArraySmalls
                }
                if let jsonValueGroupA = jsonMap["groupa"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayGroupA:Array<CompareTest.Medium.GroupA> = []
                    for oneValueGroupA in jsonValueGroupA {
                        let messageFromStringGroupA = try CompareTest.Medium.GroupA.Builder.decodeToBuilder(jsonMap:oneValueGroupA).build()

                        jsonArrayGroupA.append(messageFromStringGroupA)
                    }
                    resultDecodedBuilder.groupA = jsonArrayGroupA
                }
                if let jsonValueFloats = jsonMap["floats"] as? Array<Float> {
                    var jsonArrayFloats:Array<Float> = []
                    for oneValueFloats in jsonValueFloats {
                        jsonArrayFloats.append(Float(oneValueFloats))
                    }
                    resultDecodedBuilder.floats = jsonArrayFloats
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> CompareTest.Medium.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try CompareTest.Medium.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class Large : GeneratedMessage {

        public static func == (lhs: CompareTest.Large, rhs: CompareTest.Large) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasString == rhs.hasString) && (!lhs.hasString || lhs.string == rhs.string)
            fieldCheck = fieldCheck && (lhs.hasInt64 == rhs.hasInt64) && (!lhs.hasInt64 || lhs.int64 == rhs.int64)
            fieldCheck = fieldCheck && (lhs.hasFloat == rhs.hasFloat) && (!lhs.hasFloat || lhs.float == rhs.float)
            fieldCheck = fieldCheck && (lhs.hasBool == rhs.hasBool) && (!lhs.hasBool || lhs.bool == rhs.bool)
            fieldCheck = fieldCheck && (lhs.hasEnum == rhs.hasEnum) && (!lhs.hasEnum || lhs.`enum` == rhs.`enum`)
            fieldCheck = fieldCheck && (lhs.int64S == rhs.int64S)
            fieldCheck = fieldCheck && (lhs.hasMedium == rhs.hasMedium) && (!lhs.hasMedium || lhs.medium == rhs.medium)
            fieldCheck = fieldCheck && (lhs.hasSmall == rhs.hasSmall) && (!lhs.hasSmall || lhs.small == rhs.small)
            fieldCheck = fieldCheck && (lhs.hasDouble == rhs.hasDouble) && (!lhs.hasDouble || lhs.double == rhs.double)
            fieldCheck = fieldCheck && (lhs.hasWithMap == rhs.hasWithMap) && (!lhs.hasWithMap || lhs.withMap == rhs.withMap)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var string:String = ""
        public fileprivate(set) var hasString:Bool = false

        public fileprivate(set) var int64:Int64 = Int64(0)
        public fileprivate(set) var hasInt64:Bool = false

        public fileprivate(set) var float:Float = Float(0)
        public fileprivate(set) var hasFloat:Bool = false

        public fileprivate(set) var bool:Bool = false
        public fileprivate(set) var hasBool:Bool = false

        public fileprivate(set) var `enum`:CompareTest.Enum = CompareTest.Enum.a
        public fileprivate(set) var hasEnum:Bool = false
        public fileprivate(set) var int64S:Array<Int64> = Array<Int64>()
        public fileprivate(set) var medium:CompareTest.Medium!
        public fileprivate(set) var hasMedium:Bool = false
        public fileprivate(set) var small:CompareTest.Small!
        public fileprivate(set) var hasSmall:Bool = false
        public fileprivate(set) var double:Double = Double(0)
        public fileprivate(set) var hasDouble:Bool = false

        public fileprivate(set) var withMap:CompareTest.WithMap!
        public fileprivate(set) var hasWithMap:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if hasMedium {
                if !medium.isInitialized() {
                    return false
                }
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasString {
                try codedOutputStream.writeString(fieldNumber: 1, value:string)
            }
            if hasInt64 {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:int64)
            }
            if hasFloat {
                try codedOutputStream.writeFloat(fieldNumber: 3, value:float)
            }
            if hasBool {
                try codedOutputStream.writeBool(fieldNumber: 4, value:bool)
            }
            if hasEnum {
                try codedOutputStream.writeEnum(fieldNumber: 5, value:`enum`.rawValue)
            }
            if !int64S.isEmpty {
                for oneValueint64S in int64S {
                    try codedOutputStream.writeInt64(fieldNumber: 6, value:oneValueint64S)
                }
            }
            if hasMedium {
                try codedOutputStream.writeMessage(fieldNumber: 7, value:medium)
            }
            if hasSmall {
                try codedOutputStream.writeMessage(fieldNumber: 8, value:small)
            }
            if hasDouble {
                try codedOutputStream.writeDouble(fieldNumber: 9, value:double)
            }
            if hasWithMap {
                try codedOutputStream.writeMessage(fieldNumber: 10, value:withMap)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasString {
                serialize_size += string.computeStringSize(fieldNumber: 1)
            }
            if hasInt64 {
                serialize_size += int64.computeInt64Size(fieldNumber: 2)
            }
            if hasFloat {
                serialize_size += float.computeFloatSize(fieldNumber: 3)
            }
            if hasBool {
                serialize_size += bool.computeBoolSize(fieldNumber: 4)
            }
            if (hasEnum) {
                serialize_size += `enum`.rawValue.computeEnumSize(fieldNumber: 5)
            }
            var dataSizeInt64S:Int32 = 0
            for oneValueint64S in int64S {
                dataSizeInt64S += oneValueint64S.computeInt64SizeNoTag()
            }
            serialize_size += dataSizeInt64S
            serialize_size += 1 * Int32(int64S.count)
            if hasMedium {
                if let varSizemedium = medium?.computeMessageSize(fieldNumber: 7) {
                    serialize_size += varSizemedium
                }
            }
            if hasSmall {
                if let varSizesmall = small?.computeMessageSize(fieldNumber: 8) {
                    serialize_size += varSizesmall
                }
            }
            if hasDouble {
                serialize_size += double.computeDoubleSize(fieldNumber: 9)
            }
            if hasWithMap {
                if let varSizewithMap = withMap?.computeMessageSize(fieldNumber: 10) {
                    serialize_size += varSizewithMap
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> CompareTest.Large.Builder {
            return CompareTest.Large.classBuilder() as! CompareTest.Large.Builder
        }
        public func getBuilder() -> CompareTest.Large.Builder {
            return classBuilder() as! CompareTest.Large.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return CompareTest.Large.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return CompareTest.Large.Builder()
        }
        public func toBuilder() throws -> CompareTest.Large.Builder {
            return try CompareTest.Large.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:CompareTest.Large) throws -> CompareTest.Large.Builder {
            return try CompareTest.Large.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasString {
                jsonMap["string"] = string
            }
            if hasInt64 {
                jsonMap["int64"] = "\(int64)"
            }
            if hasFloat {
                jsonMap["float"] = Float(float)
            }
            if hasBool {
                jsonMap["bool"] = bool
            }
            if hasEnum {
                jsonMap["enum"] = `enum`.toString()
            }
            if !int64S.isEmpty {
                var jsonArrayInt64S:Array<String> = []
                for oneValueInt64S in int64S {
                    jsonArrayInt64S.append("\(oneValueInt64S)")
                }
                jsonMap["int64s"] = jsonArrayInt64S
            }
            if hasMedium {
                jsonMap["medium"] = try medium.encode()
            }
            if hasSmall {
                jsonMap["small"] = try small.encode()
            }
            if hasDouble {
                jsonMap["double"] = Double(double)
            }
            if hasWithMap {
                jsonMap["withMap"] = try withMap.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> CompareTest.Large {
            return try CompareTest.Large.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> CompareTest.Large {
            return try CompareTest.Large.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasString {
                output += "\(indent) string: \(string) \n"
            }
            if hasInt64 {
                output += "\(indent) int64: \(int64) \n"
            }
            if hasFloat {
                output += "\(indent) float: \(float) \n"
            }
            if hasBool {
                output += "\(indent) bool: \(bool) \n"
            }
            if (hasEnum) {
                output += "\(indent) enum: \(`enum`.description)\n"
            }
            var int64SElementIndex:Int = 0
            for oneValueInt64S in int64S  {
                output += "\(indent) int64S[\(int64SElementIndex)]: \(oneValueInt64S)\n"
                int64SElementIndex += 1
            }
            if hasMedium {
                output += "\(indent) medium {\n"
                if let outDescMedium = medium {
                    output += try outDescMedium.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasSmall {
                output += "\(indent) small {\n"
                if let outDescSmall = small {
                    output += try outDescSmall.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasDouble {
                output += "\(indent) double: \(double) \n"
            }
            if hasWithMap {
                output += "\(indent) withMap {\n"
                if let outDescWithMap = withMap {
                    output += try outDescWithMap.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasString {
                    hashCode = (hashCode &* 31) &+ string.hashValue
                }
                if hasInt64 {
                    hashCode = (hashCode &* 31) &+ int64.hashValue
                }
                if hasFloat {
                    hashCode = (hashCode &* 31) &+ float.hashValue
                }
                if hasBool {
                    hashCode = (hashCode &* 31) &+ bool.hashValue
                }
                if hasEnum {
                     hashCode = (hashCode &* 31) &+ `enum`.hashValue
                }
                for oneValueInt64S in int64S {
                    hashCode = (hashCode &* 31) &+ oneValueInt64S.hashValue
                }
                if hasMedium {
                    if let hashValuemedium = medium?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuemedium
                    }
                }
                if hasSmall {
                    if let hashValuesmall = small?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuesmall
                    }
                }
                if hasDouble {
                    hashCode = (hashCode &* 31) &+ double.hashValue
                }
                if hasWithMap {
                    if let hashValuewithMap = withMap?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuewithMap
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "CompareTest.Large"
        }
        override public func className() -> String {
            return "CompareTest.Large"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:CompareTest.Large = CompareTest.Large()
            public func getMessage() -> CompareTest.Large {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var string:String {
                get {
                    return builderResult.string
                }
                set (value) {
                    builderResult.hasString = true
                    builderResult.string = value
                }
            }
            public var hasString:Bool {
                get {
                    return builderResult.hasString
                }
            }
            @discardableResult
            public func setString(_ value:String) -> CompareTest.Large.Builder {
                self.string = value
                return self
            }
            @discardableResult
            public func clearString() -> CompareTest.Large.Builder{
                builderResult.hasString = false
                builderResult.string = ""
                return self
            }
            public var int64:Int64 {
                get {
                    return builderResult.int64
                }
                set (value) {
                    builderResult.hasInt64 = true
                    builderResult.int64 = value
                }
            }
            public var hasInt64:Bool {
                get {
                    return builderResult.hasInt64
                }
            }
            @discardableResult
            public func setInt64(_ value:Int64) -> CompareTest.Large.Builder {
                self.int64 = value
                return self
            }
            @discardableResult
            public func clearInt64() -> CompareTest.Large.Builder{
                builderResult.hasInt64 = false
                builderResult.int64 = Int64(0)
                return self
            }
            public var float:Float {
                get {
                    return builderResult.float
                }
                set (value) {
                    builderResult.hasFloat = true
                    builderResult.float = value
                }
            }
            public var hasFloat:Bool {
                get {
                    return builderResult.hasFloat
                }
            }
            @discardableResult
            public func setFloat(_ value:Float) -> CompareTest.Large.Builder {
                self.float = value
                return self
            }
            @discardableResult
            public func clearFloat() -> CompareTest.Large.Builder{
                builderResult.hasFloat = false
                builderResult.float = Float(0)
                return self
            }
            public var bool:Bool {
                get {
                    return builderResult.bool
                }
                set (value) {
                    builderResult.hasBool = true
                    builderResult.bool = value
                }
            }
            public var hasBool:Bool {
                get {
                    return builderResult.hasBool
                }
            }
            @discardableResult
            public func setBool(_ value:Bool) -> CompareTest.Large.Builder {
                self.bool = value
                return self
            }
            @discardableResult
            public func clearBool() -> CompareTest.Large.Builder{
                builderResult.hasBool = false
                builderResult.bool = false
                return self
            }
                public var `enum`:CompareTest.Enum {
                    get {
                        return builderResult.`enum`
                    }
                    set (value) {
                        builderResult.hasEnum = true
                        builderResult.`enum` = value
                    }
                }
                public var hasEnum:Bool{
                    get {
                        return builderResult.hasEnum
                    }
                }
            @discardableResult
                public func setEnum(_ value:CompareTest.Enum) -> CompareTest.Large.Builder {
                  self.`enum` = value
                  return self
                }
            @discardableResult
                public func clearEnum() -> CompareTest.Large.Builder {
                   builderResult.hasEnum = false
                   builderResult.`enum` = .a
                   return self
                }
            public var int64S:Array<Int64> {
                get {
                    return builderResult.int64S
                }
                set (array) {
                    builderResult.int64S = array
                }
            }
            @discardableResult
            public func setInt64S(_ value:Array<Int64>) -> CompareTest.Large.Builder {
                self.int64S = value
                return self
            }
            @discardableResult
            public func clearInt64S() -> CompareTest.Large.Builder {
                builderResult.int64S.removeAll(keepingCapacity: false)
                return self
            }
            public var medium:CompareTest.Medium! {
                get {
                    if mediumBuilder_ != nil {
                        builderResult.medium = mediumBuilder_.getMessage()
                    }
                    return builderResult.medium
                }
                set (value) {
                    builderResult.hasMedium = true
                    builderResult.medium = value
                }
            }
            public var hasMedium:Bool {
                get {
                    return builderResult.hasMedium
                }
            }
            fileprivate var mediumBuilder_:CompareTest.Medium.Builder! {
                didSet {
                    builderResult.hasMedium = true
                }
            }
            public func getMediumBuilder() -> CompareTest.Medium.Builder {
                if mediumBuilder_ == nil {
                    mediumBuilder_ = CompareTest.Medium.Builder()
                    builderResult.medium = mediumBuilder_.getMessage()
                    if medium != nil {
                        try! mediumBuilder_.mergeFrom(other: medium)
                    }
                }
                return mediumBuilder_
            }
            @discardableResult
            public func setMedium(_ value:CompareTest.Medium!) -> CompareTest.Large.Builder {
                self.medium = value
                return self
            }
            @discardableResult
            public func mergeMedium(value:CompareTest.Medium) throws -> CompareTest.Large.Builder {
                if builderResult.hasMedium {
                    builderResult.medium = try CompareTest.Medium.builderWithPrototype(prototype:builderResult.medium).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.medium = value
                }
                builderResult.hasMedium = true
                return self
            }
            @discardableResult
            public func clearMedium() -> CompareTest.Large.Builder {
                mediumBuilder_ = nil
                builderResult.hasMedium = false
                builderResult.medium = nil
                return self
            }
            public var small:CompareTest.Small! {
                get {
                    if smallBuilder_ != nil {
                        builderResult.small = smallBuilder_.getMessage()
                    }
                    return builderResult.small
                }
                set (value) {
                    builderResult.hasSmall = true
                    builderResult.small = value
                }
            }
            public var hasSmall:Bool {
                get {
                    return builderResult.hasSmall
                }
            }
            fileprivate var smallBuilder_:CompareTest.Small.Builder! {
                didSet {
                    builderResult.hasSmall = true
                }
            }
            public func getSmallBuilder() -> CompareTest.Small.Builder {
                if smallBuilder_ == nil {
                    smallBuilder_ = CompareTest.Small.Builder()
                    builderResult.small = smallBuilder_.getMessage()
                    if small != nil {
                        try! smallBuilder_.mergeFrom(other: small)
                    }
                }
                return smallBuilder_
            }
            @discardableResult
            public func setSmall(_ value:CompareTest.Small!) -> CompareTest.Large.Builder {
                self.small = value
                return self
            }
            @discardableResult
            public func mergeSmall(value:CompareTest.Small) throws -> CompareTest.Large.Builder {
                if builderResult.hasSmall {
                    builderResult.small = try CompareTest.Small.builderWithPrototype(prototype:builderResult.small).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.small = value
                }
                builderResult.hasSmall = true
                return self
            }
            @discardableResult
            public func clearSmall() -> CompareTest.Large.Builder {
                smallBuilder_ = nil
                builderResult.hasSmall = false
                builderResult.small = nil
                return self
            }
            public var double:Double {
                get {
                    return builderResult.double
                }
                set (value) {
                    builderResult.hasDouble = true
                    builderResult.double = value
                }
            }
            public var hasDouble:Bool {
                get {
                    return builderResult.hasDouble
                }
            }
            @discardableResult
            public func setDouble(_ value:Double) -> CompareTest.Large.Builder {
                self.double = value
                return self
            }
            @discardableResult
            public func clearDouble() -> CompareTest.Large.Builder{
                builderResult.hasDouble = false
                builderResult.double = Double(0)
                return self
            }
            public var withMap:CompareTest.WithMap! {
                get {
                    if withMapBuilder_ != nil {
                        builderResult.withMap = withMapBuilder_.getMessage()
                    }
                    return builderResult.withMap
                }
                set (value) {
                    builderResult.hasWithMap = true
                    builderResult.withMap = value
                }
            }
            public var hasWithMap:Bool {
                get {
                    return builderResult.hasWithMap
                }
            }
            fileprivate var withMapBuilder_:CompareTest.WithMap.Builder! {
                didSet {
                    builderResult.hasWithMap = true
                }
            }
            public func getWithMapBuilder() -> CompareTest.WithMap.Builder {
                if withMapBuilder_ == nil {
                    withMapBuilder_ = CompareTest.WithMap.Builder()
                    builderResult.withMap = withMapBuilder_.getMessage()
                    if withMap != nil {
                        try! withMapBuilder_.mergeFrom(other: withMap)
                    }
                }
                return withMapBuilder_
            }
            @discardableResult
            public func setWithMap(_ value:CompareTest.WithMap!) -> CompareTest.Large.Builder {
                self.withMap = value
                return self
            }
            @discardableResult
            public func mergeWithMap(value:CompareTest.WithMap) throws -> CompareTest.Large.Builder {
                if builderResult.hasWithMap {
                    builderResult.withMap = try CompareTest.WithMap.builderWithPrototype(prototype:builderResult.withMap).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.withMap = value
                }
                builderResult.hasWithMap = true
                return self
            }
            @discardableResult
            public func clearWithMap() -> CompareTest.Large.Builder {
                withMapBuilder_ = nil
                builderResult.hasWithMap = false
                builderResult.withMap = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> CompareTest.Large.Builder {
                builderResult = CompareTest.Large()
                return self
            }
            override public func clone() throws -> CompareTest.Large.Builder {
                return try CompareTest.Large.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> CompareTest.Large {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> CompareTest.Large {
                let returnMe:CompareTest.Large = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:CompareTest.Large) throws -> CompareTest.Large.Builder {
                if other == CompareTest.Large() {
                    return self
                }
                if other.hasString {
                    string = other.string
                }
                if other.hasInt64 {
                    int64 = other.int64
                }
                if other.hasFloat {
                    float = other.float
                }
                if other.hasBool {
                    bool = other.bool
                }
                if other.hasEnum {
                    `enum` = other.`enum`
                }
                if !other.int64S.isEmpty {
                    builderResult.int64S += other.int64S
                }
                if (other.hasMedium) {
                    try mergeMedium(value: other.medium)
                }
                if (other.hasSmall) {
                    try mergeSmall(value: other.small)
                }
                if other.hasDouble {
                    double = other.double
                }
                if (other.hasWithMap) {
                    try mergeWithMap(value: other.withMap)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> CompareTest.Large.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> CompareTest.Large.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        string = try codedInputStream.readString()

                    case 16:
                        int64 = try codedInputStream.readInt64()

                    case 29:
                        float = try codedInputStream.readFloat()

                    case 32:
                        bool = try codedInputStream.readBool()

                    case 40:
                        let valueIntenum = try codedInputStream.readEnum()
                        if let enumsenum = CompareTest.Enum(rawValue:valueIntenum){
                            `enum` = enumsenum
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 5, value:Int64(valueIntenum))
                        }

                    case 48:
                        int64S += [try codedInputStream.readInt64()]

                    case 58:
                        let subBuilder:CompareTest.Medium.Builder = CompareTest.Medium.Builder()
                        if hasMedium {
                            try subBuilder.mergeFrom(other: medium)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        medium = subBuilder.buildPartial()

                    case 66:
                        let subBuilder:CompareTest.Small.Builder = CompareTest.Small.Builder()
                        if hasSmall {
                            try subBuilder.mergeFrom(other: small)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        small = subBuilder.buildPartial()

                    case 73:
                        double = try codedInputStream.readDouble()

                    case 82:
                        let subBuilder:CompareTest.WithMap.Builder = CompareTest.WithMap.Builder()
                        if hasWithMap {
                            try subBuilder.mergeFrom(other: withMap)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        withMap = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> CompareTest.Large.Builder {
                let resultDecodedBuilder = CompareTest.Large.Builder()
                if let jsonValueString = jsonMap["string"] as? String {
                    resultDecodedBuilder.string = jsonValueString
                }
                if let jsonValueInt64 = jsonMap["int64"] as? String {
                    resultDecodedBuilder.int64 = Int64(jsonValueInt64)!
                } else if let jsonValueInt64 = jsonMap["int64"] as? Int {
                    resultDecodedBuilder.int64 = Int64(jsonValueInt64)
                }
                if let jsonValueFloat = jsonMap["float"] as? Float {
                    resultDecodedBuilder.float = Float(jsonValueFloat)
                } else if let jsonValueFloat = jsonMap["float"] as? String {
                    resultDecodedBuilder.float = Float(jsonValueFloat)!
                }
                if let jsonValueBool = jsonMap["bool"] as? Bool {
                    resultDecodedBuilder.bool = jsonValueBool
                }
                if let jsonValueEnum = jsonMap["enum"] as? String {
                    resultDecodedBuilder.`enum` = try CompareTest.Enum.fromString(str: jsonValueEnum)
                }
                if let jsonValueInt64S = jsonMap["int64s"] as? Array<String> {
                    var jsonArrayInt64S:Array<Int64> = []
                    for oneValueInt64S in jsonValueInt64S {
                        jsonArrayInt64S.append(Int64(oneValueInt64S)!)
                    }
                    resultDecodedBuilder.int64S = jsonArrayInt64S
                }
                if let jsonValueMedium = jsonMap["medium"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.medium = try CompareTest.Medium.Builder.decodeToBuilder(jsonMap:jsonValueMedium).build()

                }
                if let jsonValueSmall = jsonMap["small"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.small = try CompareTest.Small.Builder.decodeToBuilder(jsonMap:jsonValueSmall).build()

                }
                if let jsonValueDouble = jsonMap["double"] as? Double {
                    resultDecodedBuilder.double = Double(jsonValueDouble)
                } else if let jsonValueDouble = jsonMap["double"] as? String {
                    resultDecodedBuilder.double = Double(jsonValueDouble)!
                }
                if let jsonValueWithMap = jsonMap["withMap"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.withMap = try CompareTest.WithMap.Builder.decodeToBuilder(jsonMap:jsonValueWithMap).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> CompareTest.Large.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try CompareTest.Large.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class Labeled : GeneratedMessage {

        public static func == (lhs: CompareTest.Labeled, rhs: CompareTest.Labeled) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasRequired == rhs.hasRequired) && (!lhs.hasRequired || lhs.`required` == rhs.`required`)
            fieldCheck = fieldCheck && (lhs.hasOptional == rhs.hasOptional) && (!lhs.hasOptional || lhs.`optional` == rhs.`optional`)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var `required`:Int32 = Int32(0)
        public fileprivate(set) var hasRequired:Bool = false

        public fileprivate(set) var `optional`:Int32 = Int32(0)
        public fileprivate(set) var hasOptional:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasRequired {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasRequired {
                try codedOutputStream.writeInt32(fieldNumber: 1, value:`required`)
            }
            if hasOptional {
                try codedOutputStream.writeInt32(fieldNumber: 2, value:`optional`)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasRequired {
                serialize_size += `required`.computeInt32Size(fieldNumber: 1)
            }
            if hasOptional {
                serialize_size += `optional`.computeInt32Size(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> CompareTest.Labeled.Builder {
            return CompareTest.Labeled.classBuilder() as! CompareTest.Labeled.Builder
        }
        public func getBuilder() -> CompareTest.Labeled.Builder {
            return classBuilder() as! CompareTest.Labeled.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return CompareTest.Labeled.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return CompareTest.Labeled.Builder()
        }
        public func toBuilder() throws -> CompareTest.Labeled.Builder {
            return try CompareTest.Labeled.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:CompareTest.Labeled) throws -> CompareTest.Labeled.Builder {
            return try CompareTest.Labeled.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasRequired {
                jsonMap["required"] = Int(required)
            }
            if hasOptional {
                jsonMap["optional"] = Int(optional)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> CompareTest.Labeled {
            return try CompareTest.Labeled.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> CompareTest.Labeled {
            return try CompareTest.Labeled.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasRequired {
                output += "\(indent) required: \(`required`) \n"
            }
            if hasOptional {
                output += "\(indent) optional: \(`optional`) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasRequired {
                    hashCode = (hashCode &* 31) &+ `required`.hashValue
                }
                if hasOptional {
                    hashCode = (hashCode &* 31) &+ `optional`.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "CompareTest.Labeled"
        }
        override public func className() -> String {
            return "CompareTest.Labeled"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:CompareTest.Labeled = CompareTest.Labeled()
            public func getMessage() -> CompareTest.Labeled {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var `required`:Int32 {
                get {
                    return builderResult.`required`
                }
                set (value) {
                    builderResult.hasRequired = true
                    builderResult.`required` = value
                }
            }
            public var hasRequired:Bool {
                get {
                    return builderResult.hasRequired
                }
            }
            @discardableResult
            public func setRequired(_ value:Int32) -> CompareTest.Labeled.Builder {
                self.`required` = value
                return self
            }
            @discardableResult
            public func clearRequired() -> CompareTest.Labeled.Builder{
                builderResult.hasRequired = false
                builderResult.`required` = Int32(0)
                return self
            }
            public var `optional`:Int32 {
                get {
                    return builderResult.`optional`
                }
                set (value) {
                    builderResult.hasOptional = true
                    builderResult.`optional` = value
                }
            }
            public var hasOptional:Bool {
                get {
                    return builderResult.hasOptional
                }
            }
            @discardableResult
            public func setOptional(_ value:Int32) -> CompareTest.Labeled.Builder {
                self.`optional` = value
                return self
            }
            @discardableResult
            public func clearOptional() -> CompareTest.Labeled.Builder{
                builderResult.hasOptional = false
                builderResult.`optional` = Int32(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> CompareTest.Labeled.Builder {
                builderResult = CompareTest.Labeled()
                return self
            }
            override public func clone() throws -> CompareTest.Labeled.Builder {
                return try CompareTest.Labeled.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> CompareTest.Labeled {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> CompareTest.Labeled {
                let returnMe:CompareTest.Labeled = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:CompareTest.Labeled) throws -> CompareTest.Labeled.Builder {
                if other == CompareTest.Labeled() {
                    return self
                }
                if other.hasRequired {
                    `required` = other.`required`
                }
                if other.hasOptional {
                    `optional` = other.`optional`
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> CompareTest.Labeled.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> CompareTest.Labeled.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        `required` = try codedInputStream.readInt32()

                    case 16:
                        `optional` = try codedInputStream.readInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> CompareTest.Labeled.Builder {
                let resultDecodedBuilder = CompareTest.Labeled.Builder()
                if let jsonValueRequired = jsonMap["required"] as? Int {
                    resultDecodedBuilder.`required` = Int32(jsonValueRequired)
                } else if let jsonValueRequired = jsonMap["required"] as? String {
                    resultDecodedBuilder.`required` = Int32(jsonValueRequired)!
                }
                if let jsonValueOptional = jsonMap["optional"] as? Int {
                    resultDecodedBuilder.`optional` = Int32(jsonValueOptional)
                } else if let jsonValueOptional = jsonMap["optional"] as? String {
                    resultDecodedBuilder.`optional` = Int32(jsonValueOptional)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> CompareTest.Labeled.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try CompareTest.Labeled.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class WithMap : GeneratedMessage {

        public static func == (lhs: CompareTest.WithMap, rhs: CompareTest.WithMap) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasValueMessage == rhs.hasValueMessage) && (!lhs.hasValueMessage || lhs.valueMessage == rhs.valueMessage)
            fieldCheck = fieldCheck && (lhs.hasValueString == rhs.hasValueString) && (!lhs.hasValueString || lhs.valueString == rhs.valueString)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        final public class ValueMessageEntry : GeneratedMessage {

            public static func == (lhs: CompareTest.WithMap.ValueMessageEntry, rhs: CompareTest.WithMap.ValueMessageEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:Int32 = Int32(0)
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:CompareTest.Small!
            public fileprivate(set) var hasValue:Bool = false
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeInt32(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeMessage(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeInt32Size(fieldNumber: 1)
                }
                if hasValue {
                    if let varSizevalue = value?.computeMessageSize(fieldNumber: 2) {
                        serialize_size += varSizevalue
                    }
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> CompareTest.WithMap.ValueMessageEntry.Builder {
                return CompareTest.WithMap.ValueMessageEntry.classBuilder() as! CompareTest.WithMap.ValueMessageEntry.Builder
            }
            public func getBuilder() -> CompareTest.WithMap.ValueMessageEntry.Builder {
                return classBuilder() as! CompareTest.WithMap.ValueMessageEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return CompareTest.WithMap.ValueMessageEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return CompareTest.WithMap.ValueMessageEntry.Builder()
            }
            public func toBuilder() throws -> CompareTest.WithMap.ValueMessageEntry.Builder {
                return try CompareTest.WithMap.ValueMessageEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:CompareTest.WithMap.ValueMessageEntry) throws -> CompareTest.WithMap.ValueMessageEntry.Builder {
                return try CompareTest.WithMap.ValueMessageEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = Int(key)
                }
                if hasValue {
                    jsonMap["value"] = try value.encode()
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> CompareTest.WithMap.ValueMessageEntry {
                return try CompareTest.WithMap.ValueMessageEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> CompareTest.WithMap.ValueMessageEntry {
                return try CompareTest.WithMap.ValueMessageEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value {\n"
                    if let outDescValue = value {
                        output += try outDescValue.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        if let hashValuevalue = value?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuevalue
                        }
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "CompareTest.WithMap.ValueMessageEntry"
            }
            override public func className() -> String {
                return "CompareTest.WithMap.ValueMessageEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:CompareTest.WithMap.ValueMessageEntry = CompareTest.WithMap.ValueMessageEntry()
                public func getMessage() -> CompareTest.WithMap.ValueMessageEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:Int32 {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:Int32) -> CompareTest.WithMap.ValueMessageEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> CompareTest.WithMap.ValueMessageEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = Int32(0)
                    return self
                }
                public var value:CompareTest.Small! {
                    get {
                        if valueBuilder_ != nil {
                            builderResult.value = valueBuilder_.getMessage()
                        }
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                fileprivate var valueBuilder_:CompareTest.Small.Builder! {
                    didSet {
                        builderResult.hasValue = true
                    }
                }
                public func getValueBuilder() -> CompareTest.Small.Builder {
                    if valueBuilder_ == nil {
                        valueBuilder_ = CompareTest.Small.Builder()
                        builderResult.value = valueBuilder_.getMessage()
                        if value != nil {
                            try! valueBuilder_.mergeFrom(other: value)
                        }
                    }
                    return valueBuilder_
                }
                @discardableResult
                public func setValue(_ value:CompareTest.Small!) -> CompareTest.WithMap.ValueMessageEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func mergeValue(value:CompareTest.Small) throws -> CompareTest.WithMap.ValueMessageEntry.Builder {
                    if builderResult.hasValue {
                        builderResult.value = try CompareTest.Small.builderWithPrototype(prototype:builderResult.value).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.value = value
                    }
                    builderResult.hasValue = true
                    return self
                }
                @discardableResult
                public func clearValue() -> CompareTest.WithMap.ValueMessageEntry.Builder {
                    valueBuilder_ = nil
                    builderResult.hasValue = false
                    builderResult.value = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> CompareTest.WithMap.ValueMessageEntry.Builder {
                    builderResult = CompareTest.WithMap.ValueMessageEntry()
                    return self
                }
                override public func clone() throws -> CompareTest.WithMap.ValueMessageEntry.Builder {
                    return try CompareTest.WithMap.ValueMessageEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> CompareTest.WithMap.ValueMessageEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> CompareTest.WithMap.ValueMessageEntry {
                    let returnMe:CompareTest.WithMap.ValueMessageEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:CompareTest.WithMap.ValueMessageEntry) throws -> CompareTest.WithMap.ValueMessageEntry.Builder {
                    if other == CompareTest.WithMap.ValueMessageEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if (other.hasValue) {
                        try mergeValue(value: other.value)
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> CompareTest.WithMap.ValueMessageEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> CompareTest.WithMap.ValueMessageEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 8:
                            key = try codedInputStream.readInt32()

                        case 18:
                            let subBuilder:CompareTest.Small.Builder = CompareTest.Small.Builder()
                            if hasValue {
                                try subBuilder.mergeFrom(other: value)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            value = subBuilder.buildPartial()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> CompareTest.WithMap.ValueMessageEntry.Builder {
                    let resultDecodedBuilder = CompareTest.WithMap.ValueMessageEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? Int {
                        resultDecodedBuilder.key = Int32(jsonValueKey)
                    } else if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = Int32(jsonValueKey)!
                    }
                    if let jsonValueValue = jsonMap["value"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.value = try CompareTest.Small.Builder.decodeToBuilder(jsonMap:jsonValueValue).build()

                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> CompareTest.WithMap.ValueMessageEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try CompareTest.WithMap.ValueMessageEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        final public class ValueStringEntry : GeneratedMessage {

            public static func == (lhs: CompareTest.WithMap.ValueStringEntry, rhs: CompareTest.WithMap.ValueStringEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:String = ""
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:String = ""
            public fileprivate(set) var hasValue:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeString(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeString(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeStringSize(fieldNumber: 1)
                }
                if hasValue {
                    serialize_size += value.computeStringSize(fieldNumber: 2)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> CompareTest.WithMap.ValueStringEntry.Builder {
                return CompareTest.WithMap.ValueStringEntry.classBuilder() as! CompareTest.WithMap.ValueStringEntry.Builder
            }
            public func getBuilder() -> CompareTest.WithMap.ValueStringEntry.Builder {
                return classBuilder() as! CompareTest.WithMap.ValueStringEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return CompareTest.WithMap.ValueStringEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return CompareTest.WithMap.ValueStringEntry.Builder()
            }
            public func toBuilder() throws -> CompareTest.WithMap.ValueStringEntry.Builder {
                return try CompareTest.WithMap.ValueStringEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:CompareTest.WithMap.ValueStringEntry) throws -> CompareTest.WithMap.ValueStringEntry.Builder {
                return try CompareTest.WithMap.ValueStringEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = key
                }
                if hasValue {
                    jsonMap["value"] = value
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> CompareTest.WithMap.ValueStringEntry {
                return try CompareTest.WithMap.ValueStringEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> CompareTest.WithMap.ValueStringEntry {
                return try CompareTest.WithMap.ValueStringEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value: \(value) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        hashCode = (hashCode &* 31) &+ value.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "CompareTest.WithMap.ValueStringEntry"
            }
            override public func className() -> String {
                return "CompareTest.WithMap.ValueStringEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:CompareTest.WithMap.ValueStringEntry = CompareTest.WithMap.ValueStringEntry()
                public func getMessage() -> CompareTest.WithMap.ValueStringEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:String {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:String) -> CompareTest.WithMap.ValueStringEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> CompareTest.WithMap.ValueStringEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = ""
                    return self
                }
                public var value:String {
                    get {
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                @discardableResult
                public func setValue(_ value:String) -> CompareTest.WithMap.ValueStringEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func clearValue() -> CompareTest.WithMap.ValueStringEntry.Builder{
                    builderResult.hasValue = false
                    builderResult.value = ""
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> CompareTest.WithMap.ValueStringEntry.Builder {
                    builderResult = CompareTest.WithMap.ValueStringEntry()
                    return self
                }
                override public func clone() throws -> CompareTest.WithMap.ValueStringEntry.Builder {
                    return try CompareTest.WithMap.ValueStringEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> CompareTest.WithMap.ValueStringEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> CompareTest.WithMap.ValueStringEntry {
                    let returnMe:CompareTest.WithMap.ValueStringEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:CompareTest.WithMap.ValueStringEntry) throws -> CompareTest.WithMap.ValueStringEntry.Builder {
                    if other == CompareTest.WithMap.ValueStringEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if other.hasValue {
                        value = other.value
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> CompareTest.WithMap.ValueStringEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> CompareTest.WithMap.ValueStringEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            key = try codedInputStream.readString()

                        case 18:
                            value = try codedInputStream.readString()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> CompareTest.WithMap.ValueStringEntry.Builder {
                    let resultDecodedBuilder = CompareTest.WithMap.ValueStringEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = jsonValueKey
                    }
                    if let jsonValueValue = jsonMap["value"] as? String {
                        resultDecodedBuilder.value = jsonValueValue
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> CompareTest.WithMap.ValueStringEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try CompareTest.WithMap.ValueStringEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        public fileprivate(set) var valueMessage:Dictionary<Int32,CompareTest.Small> = Dictionary<Int32,CompareTest.Small>()

        public fileprivate(set) var hasValueMessage:Bool = false
        public fileprivate(set) var valueString:Dictionary<String,String> = Dictionary<String,String>()

        public fileprivate(set) var hasValueString:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasValueMessage {
                for (keyValueMessage, valueValueMessage) in valueMessage {
                    let valueOfValueMessage = try! CompareTest.WithMap.ValueMessageEntry.Builder().setKey(keyValueMessage).setValue(valueValueMessage).build()
                      try codedOutputStream.writeMessage(fieldNumber: 1, value:valueOfValueMessage)
                  }
            }
            if hasValueString {
                for (keyValueString, valueValueString) in valueString {
                    let valueOfValueString = try! CompareTest.WithMap.ValueStringEntry.Builder().setKey(keyValueString).setValue(valueValueString).build()
                      try codedOutputStream.writeMessage(fieldNumber: 2, value:valueOfValueString)
                  }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasValueMessage {
                  for (keyValueMessage, valueValueMessage) in valueMessage {
                      let valueOfValueMessage = try! CompareTest.WithMap.ValueMessageEntry.Builder().setKey(keyValueMessage).setValue(valueValueMessage).build()
                serialize_size += valueOfValueMessage.computeMessageSize(fieldNumber: 1)
                }
            }
            if hasValueString {
                  for (keyValueString, valueValueString) in valueString {
                      let valueOfValueString = try! CompareTest.WithMap.ValueStringEntry.Builder().setKey(keyValueString).setValue(valueValueString).build()
                serialize_size += valueOfValueString.computeMessageSize(fieldNumber: 2)
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> CompareTest.WithMap.Builder {
            return CompareTest.WithMap.classBuilder() as! CompareTest.WithMap.Builder
        }
        public func getBuilder() -> CompareTest.WithMap.Builder {
            return classBuilder() as! CompareTest.WithMap.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return CompareTest.WithMap.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return CompareTest.WithMap.Builder()
        }
        public func toBuilder() throws -> CompareTest.WithMap.Builder {
            return try CompareTest.WithMap.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:CompareTest.WithMap) throws -> CompareTest.WithMap.Builder {
            return try CompareTest.WithMap.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasValueMessage {
                var mapValueMessage = Dictionary<String, Dictionary<String,Any>>()
                for (keyValueMessage, valueValueMessage) in valueMessage {
                    mapValueMessage["\(keyValueMessage)"] = try valueValueMessage.encode()
                }
                jsonMap["valueMessage"] = mapValueMessage
            }
            if hasValueString {
                var mapValueString = Dictionary<String, String>()
                for (keyValueString, valueValueString) in valueString {
                    mapValueString["\(keyValueString)"] = valueValueString
                }
                jsonMap["valueString"] = mapValueString
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> CompareTest.WithMap {
            return try CompareTest.WithMap.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> CompareTest.WithMap {
            return try CompareTest.WithMap.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasValueMessage {
                output += "\(indent) valueMessage: \(valueMessage) \n"
            }
            if hasValueString {
                output += "\(indent) valueString: \(valueString) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasValueMessage {
                    for (keyValueMessage, valueValueMessage) in valueMessage {
                        hashCode = (hashCode &* 31) &+ keyValueMessage.hashValue
                        hashCode = (hashCode &* 31) &+ valueValueMessage.hashValue
                    }
                }
                if hasValueString {
                    for (keyValueString, valueValueString) in valueString {
                        hashCode = (hashCode &* 31) &+ keyValueString.hashValue
                        hashCode = (hashCode &* 31) &+ valueValueString.hashValue
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "CompareTest.WithMap"
        }
        override public func className() -> String {
            return "CompareTest.WithMap"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:CompareTest.WithMap = CompareTest.WithMap()
            public func getMessage() -> CompareTest.WithMap {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var hasValueMessage:Bool {
                get {
                    return builderResult.hasValueMessage
                }
            }
            public var valueMessage:Dictionary<Int32,CompareTest.Small> {
                get {
                    return builderResult.valueMessage
                }
                set (value) {
                    builderResult.hasValueMessage = true
                    builderResult.valueMessage = value
                }
            }
            @discardableResult
            public func setValueMessage(_ value:Dictionary<Int32,CompareTest.Small>) -> CompareTest.WithMap.Builder {
                self.valueMessage = value
                return self
            }
            @discardableResult
            public func clearValueMessage() -> CompareTest.WithMap.Builder{
                builderResult.hasValueMessage = false
                builderResult.valueMessage = Dictionary<Int32,CompareTest.Small>()
                return self
            }
            public var hasValueString:Bool {
                get {
                    return builderResult.hasValueString
                }
            }
            public var valueString:Dictionary<String,String> {
                get {
                    return builderResult.valueString
                }
                set (value) {
                    builderResult.hasValueString = true
                    builderResult.valueString = value
                }
            }
            @discardableResult
            public func setValueString(_ value:Dictionary<String,String>) -> CompareTest.WithMap.Builder {
                self.valueString = value
                return self
            }
            @discardableResult
            public func clearValueString() -> CompareTest.WithMap.Builder{
                builderResult.hasValueString = false
                builderResult.valueString = Dictionary<String,String>()
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> CompareTest.WithMap.Builder {
                builderResult = CompareTest.WithMap()
                return self
            }
            override public func clone() throws -> CompareTest.WithMap.Builder {
                return try CompareTest.WithMap.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> CompareTest.WithMap {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> CompareTest.WithMap {
                let returnMe:CompareTest.WithMap = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:CompareTest.WithMap) throws -> CompareTest.WithMap.Builder {
                if other == CompareTest.WithMap() {
                    return self
                }
                if other.hasValueMessage {
                    valueMessage = other.valueMessage
                }
                if other.hasValueString {
                    valueString = other.valueString
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> CompareTest.WithMap.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> CompareTest.WithMap.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = CompareTest.WithMap.ValueMessageEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfValueMessage = subBuilder.buildPartial()
                        valueMessage[buildOfValueMessage.key] = buildOfValueMessage.value

                    case 18:
                        let subBuilder = CompareTest.WithMap.ValueStringEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfValueString = subBuilder.buildPartial()
                        valueString[buildOfValueString.key] = buildOfValueString.value

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> CompareTest.WithMap.Builder {
                let resultDecodedBuilder = CompareTest.WithMap.Builder()
                if let jsonValueValueMessage = jsonMap["valueMessage"] as? Dictionary<String, Dictionary<String,Any>> {
                    var mapValueMessage = Dictionary<Int32, CompareTest.Small>()
                    for (keyValueMessage, valueValueMessage) in jsonValueValueMessage {
                        guard let keyFromValueMessage = Int32(keyValueMessage) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapValueMessage[keyFromValueMessage] = try CompareTest.Small.Builder.decodeToBuilder(jsonMap:valueValueMessage).build()

                    }
                    resultDecodedBuilder.valueMessage = mapValueMessage
                }
                if let jsonValueValueString = jsonMap["valueString"] as? Dictionary<String, String> {
                    var mapValueString = Dictionary<String, String>()
                    for (keyValueString, valueValueString) in jsonValueValueString {
                        guard let keyFromValueString = String(keyValueString) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapValueString[keyFromValueString] = valueValueString
                    }
                    resultDecodedBuilder.valueString = mapValueString
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> CompareTest.WithMap.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try CompareTest.WithMap.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension CompareTest.Small: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<CompareTest.Small> {
        var mergedArray = Array<CompareTest.Small>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> CompareTest.Small? {
        return try CompareTest.Small.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> CompareTest.Small {
        return try CompareTest.Small.Builder().mergeFrom(data: data, extensionRegistry:CompareTest.CompareTestRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> CompareTest.Small {
        return try CompareTest.Small.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> CompareTest.Small {
        return try CompareTest.Small.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> CompareTest.Small {
        return try CompareTest.Small.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> CompareTest.Small {
        return try CompareTest.Small.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> CompareTest.Small {
        return try CompareTest.Small.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "strings": return self.strings
        default: return nil
        }
    }
}
extension CompareTest.Small.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "strings": return self.strings
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "strings":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.strings = newSubscriptValue
            default: return
            }
        }
    }
}
extension CompareTest.Medium: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<CompareTest.Medium> {
        var mergedArray = Array<CompareTest.Medium>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> CompareTest.Medium? {
        return try CompareTest.Medium.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> CompareTest.Medium {
        return try CompareTest.Medium.Builder().mergeFrom(data: data, extensionRegistry:CompareTest.CompareTestRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> CompareTest.Medium {
        return try CompareTest.Medium.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> CompareTest.Medium {
        return try CompareTest.Medium.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> CompareTest.Medium {
        return try CompareTest.Medium.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> CompareTest.Medium {
        return try CompareTest.Medium.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> CompareTest.Medium {
        return try CompareTest.Medium.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "int32S": return self.int32S
        case "smalls": return self.smalls
        case "groupA": return self.groupA
        case "floats": return self.floats
        default: return nil
        }
    }
}
extension CompareTest.Medium.GroupA: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<CompareTest.Medium.GroupA> {
        var mergedArray = Array<CompareTest.Medium.GroupA>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> CompareTest.Medium.GroupA? {
        return try CompareTest.Medium.GroupA.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> CompareTest.Medium.GroupA {
        return try CompareTest.Medium.GroupA.Builder().mergeFrom(data: data, extensionRegistry:CompareTest.CompareTestRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> CompareTest.Medium.GroupA {
        return try CompareTest.Medium.GroupA.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> CompareTest.Medium.GroupA {
        return try CompareTest.Medium.GroupA.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> CompareTest.Medium.GroupA {
        return try CompareTest.Medium.GroupA.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> CompareTest.Medium.GroupA {
        return try CompareTest.Medium.GroupA.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> CompareTest.Medium.GroupA {
        return try CompareTest.Medium.GroupA.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "groupB": return self.groupB
        default: return nil
        }
    }
}
extension CompareTest.Medium.GroupA.GroupB: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<CompareTest.Medium.GroupA.GroupB> {
        var mergedArray = Array<CompareTest.Medium.GroupA.GroupB>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> CompareTest.Medium.GroupA.GroupB? {
        return try CompareTest.Medium.GroupA.GroupB.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> CompareTest.Medium.GroupA.GroupB {
        return try CompareTest.Medium.GroupA.GroupB.Builder().mergeFrom(data: data, extensionRegistry:CompareTest.CompareTestRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> CompareTest.Medium.GroupA.GroupB {
        return try CompareTest.Medium.GroupA.GroupB.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> CompareTest.Medium.GroupA.GroupB {
        return try CompareTest.Medium.GroupA.GroupB.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> CompareTest.Medium.GroupA.GroupB {
        return try CompareTest.Medium.GroupA.GroupB.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> CompareTest.Medium.GroupA.GroupB {
        return try CompareTest.Medium.GroupA.GroupB.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> CompareTest.Medium.GroupA.GroupB {
        return try CompareTest.Medium.GroupA.GroupB.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "strings": return self.strings
        default: return nil
        }
    }
}
extension CompareTest.Medium.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "int32S": return self.int32S
            case "smalls": return self.smalls
            case "groupA": return self.groupA
            case "floats": return self.floats
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "int32S":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int32> else {
                    return
                }
                self.int32S = newSubscriptValue
            case "smalls":
                guard let newSubscriptValue = newSubscriptValue as? Array<CompareTest.Small> else {
                    return
                }
                self.smalls = newSubscriptValue
            case "groupA":
                guard let newSubscriptValue = newSubscriptValue as? Array<CompareTest.Medium.GroupA> else {
                    return
                }
                self.groupA = newSubscriptValue
            case "floats":
                guard let newSubscriptValue = newSubscriptValue as? Array<Float> else {
                    return
                }
                self.floats = newSubscriptValue
            default: return
            }
        }
    }
}
extension CompareTest.Medium.GroupA.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "groupB": return self.groupB
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "groupB":
                guard let newSubscriptValue = newSubscriptValue as? Array<CompareTest.Medium.GroupA.GroupB> else {
                    return
                }
                self.groupB = newSubscriptValue
            default: return
            }
        }
    }
}
extension CompareTest.Medium.GroupA.GroupB.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "strings": return self.strings
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "strings":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.strings = newSubscriptValue
            default: return
            }
        }
    }
}
extension CompareTest.Large: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<CompareTest.Large> {
        var mergedArray = Array<CompareTest.Large>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> CompareTest.Large? {
        return try CompareTest.Large.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> CompareTest.Large {
        return try CompareTest.Large.Builder().mergeFrom(data: data, extensionRegistry:CompareTest.CompareTestRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> CompareTest.Large {
        return try CompareTest.Large.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> CompareTest.Large {
        return try CompareTest.Large.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> CompareTest.Large {
        return try CompareTest.Large.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> CompareTest.Large {
        return try CompareTest.Large.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> CompareTest.Large {
        return try CompareTest.Large.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "string": return self.string
        case "int64": return self.int64
        case "float": return self.float
        case "bool": return self.bool
        case "`enum`": return self.`enum`
        case "int64S": return self.int64S
        case "medium": return self.medium
        case "small": return self.small
        case "double": return self.double
        case "withMap": return self.withMap
        default: return nil
        }
    }
}
extension CompareTest.Large.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "string": return self.string
            case "int64": return self.int64
            case "float": return self.float
            case "bool": return self.bool
            case "`enum`": return self.`enum`
            case "int64S": return self.int64S
            case "medium": return self.medium
            case "small": return self.small
            case "double": return self.double
            case "withMap": return self.withMap
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "string":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.string = newSubscriptValue
            case "int64":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.int64 = newSubscriptValue
            case "float":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.float = newSubscriptValue
            case "bool":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.bool = newSubscriptValue
            case "`enum`":
                guard let newSubscriptValue = newSubscriptValue as? CompareTest.Enum else {
                    return
                }
                self.`enum` = newSubscriptValue
            case "int64S":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.int64S = newSubscriptValue
            case "medium":
                guard let newSubscriptValue = newSubscriptValue as? CompareTest.Medium else {
                    return
                }
                self.medium = newSubscriptValue
            case "small":
                guard let newSubscriptValue = newSubscriptValue as? CompareTest.Small else {
                    return
                }
                self.small = newSubscriptValue
            case "double":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.double = newSubscriptValue
            case "withMap":
                guard let newSubscriptValue = newSubscriptValue as? CompareTest.WithMap else {
                    return
                }
                self.withMap = newSubscriptValue
            default: return
            }
        }
    }
}
extension CompareTest.Labeled: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<CompareTest.Labeled> {
        var mergedArray = Array<CompareTest.Labeled>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> CompareTest.Labeled? {
        return try CompareTest.Labeled.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> CompareTest.Labeled {
        return try CompareTest.Labeled.Builder().mergeFrom(data: data, extensionRegistry:CompareTest.CompareTestRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> CompareTest.Labeled {
        return try CompareTest.Labeled.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> CompareTest.Labeled {
        return try CompareTest.Labeled.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> CompareTest.Labeled {
        return try CompareTest.Labeled.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> CompareTest.Labeled {
        return try CompareTest.Labeled.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> CompareTest.Labeled {
        return try CompareTest.Labeled.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "`required`": return self.`required`
        case "`optional`": return self.`optional`
        default: return nil
        }
    }
}
extension CompareTest.Labeled.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "`required`": return self.`required`
            case "`optional`": return self.`optional`
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "`required`":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.`required` = newSubscriptValue
            case "`optional`":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.`optional` = newSubscriptValue
            default: return
            }
        }
    }
}
extension CompareTest.WithMap: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<CompareTest.WithMap> {
        var mergedArray = Array<CompareTest.WithMap>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> CompareTest.WithMap? {
        return try CompareTest.WithMap.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> CompareTest.WithMap {
        return try CompareTest.WithMap.Builder().mergeFrom(data: data, extensionRegistry:CompareTest.CompareTestRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> CompareTest.WithMap {
        return try CompareTest.WithMap.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> CompareTest.WithMap {
        return try CompareTest.WithMap.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> CompareTest.WithMap {
        return try CompareTest.WithMap.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> CompareTest.WithMap {
        return try CompareTest.WithMap.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> CompareTest.WithMap {
        return try CompareTest.WithMap.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "valueMessage": return self.valueMessage
        case "valueString": return self.valueString
        default: return nil
        }
    }
}
extension CompareTest.WithMap.ValueMessageEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<CompareTest.WithMap.ValueMessageEntry> {
        var mergedArray = Array<CompareTest.WithMap.ValueMessageEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> CompareTest.WithMap.ValueMessageEntry? {
        return try CompareTest.WithMap.ValueMessageEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> CompareTest.WithMap.ValueMessageEntry {
        return try CompareTest.WithMap.ValueMessageEntry.Builder().mergeFrom(data: data, extensionRegistry:CompareTest.CompareTestRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> CompareTest.WithMap.ValueMessageEntry {
        return try CompareTest.WithMap.ValueMessageEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> CompareTest.WithMap.ValueMessageEntry {
        return try CompareTest.WithMap.ValueMessageEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> CompareTest.WithMap.ValueMessageEntry {
        return try CompareTest.WithMap.ValueMessageEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> CompareTest.WithMap.ValueMessageEntry {
        return try CompareTest.WithMap.ValueMessageEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> CompareTest.WithMap.ValueMessageEntry {
        return try CompareTest.WithMap.ValueMessageEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension CompareTest.WithMap.ValueStringEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<CompareTest.WithMap.ValueStringEntry> {
        var mergedArray = Array<CompareTest.WithMap.ValueStringEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> CompareTest.WithMap.ValueStringEntry? {
        return try CompareTest.WithMap.ValueStringEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> CompareTest.WithMap.ValueStringEntry {
        return try CompareTest.WithMap.ValueStringEntry.Builder().mergeFrom(data: data, extensionRegistry:CompareTest.CompareTestRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> CompareTest.WithMap.ValueStringEntry {
        return try CompareTest.WithMap.ValueStringEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> CompareTest.WithMap.ValueStringEntry {
        return try CompareTest.WithMap.ValueStringEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> CompareTest.WithMap.ValueStringEntry {
        return try CompareTest.WithMap.ValueStringEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> CompareTest.WithMap.ValueStringEntry {
        return try CompareTest.WithMap.ValueStringEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> CompareTest.WithMap.ValueStringEntry {
        return try CompareTest.WithMap.ValueStringEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension CompareTest.WithMap.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "valueMessage": return self.valueMessage
            case "valueString": return self.valueString
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "valueMessage":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<Int32,CompareTest.Small> else {
                    return
                }
                self.valueMessage = newSubscriptValue
            case "valueString":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,String> else {
                    return
                }
                self.valueString = newSubscriptValue
            default: return
            }
        }
    }
}
extension CompareTest.WithMap.ValueMessageEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? CompareTest.Small else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension CompareTest.WithMap.ValueStringEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

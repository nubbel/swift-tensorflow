/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "session.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Xla { }

public extension Xla {
    public struct SessionRoot {
        public static let `default` = SessionRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Xla.XlaDataRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    /// Describes a single operation request.
    final public class OperationRequest : GeneratedMessage {

        public static func == (lhs: Xla.OperationRequest, rhs: Xla.OperationRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasOutputHandle == rhs.hasOutputHandle) && (!lhs.hasOutputHandle || lhs.outputHandle == rhs.outputHandle)
            fieldCheck = fieldCheck && (lhs.hasOutputShape == rhs.hasOutputShape) && (!lhs.hasOutputShape || lhs.outputShape == rhs.outputShape)
            fieldCheck = fieldCheck && (lhs.embeddedComputationVersions == rhs.embeddedComputationVersions)
            fieldCheck = fieldCheck && (lhs.hasRequest == rhs.hasRequest) && (!lhs.hasRequest || lhs.request == rhs.request)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var outputHandle:Xla.ComputationDataHandle!
        public fileprivate(set) var hasOutputHandle:Bool = false
        public fileprivate(set) var outputShape:Xla.Shape!
        public fileprivate(set) var hasOutputShape:Bool = false
        /// For operations which call embedded computations such as "Map", these are
        /// the version(s) that the embedded computation should be called at. A version
        /// value of a computation is the ComputationDataHandle of the root of the
        /// computation at the point in time.
        /// "Call", "Map", "Reduce", and "ReduceWindow" operations take a single
        /// embedded computation so this field will have a single value for those
        /// operations.
        /// "While" operation takes two; index 0 is the "condition" version and index 1
        /// is the "body" version.
        public fileprivate(set) var embeddedComputationVersions:Array<Int64> = Array<Int64>()
        private var embeddedComputationVersionsMemoizedSerializedSize:Int32 = -1
        public fileprivate(set) var request:Xla.OpRequest!
        public fileprivate(set) var hasRequest:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasOutputHandle {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:outputHandle)
            }
            if hasOutputShape {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:outputShape)
            }
            if !embeddedComputationVersions.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 26)
                try codedOutputStream.writeRawVarint32(value: embeddedComputationVersionsMemoizedSerializedSize)
                for oneValueembeddedComputationVersions in embeddedComputationVersions {
                    try codedOutputStream.writeInt64NoTag(value: oneValueembeddedComputationVersions)
                }
            }
            if hasRequest {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:request)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasOutputHandle {
                if let varSizeoutputHandle = outputHandle?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeoutputHandle
                }
            }
            if hasOutputShape {
                if let varSizeoutputShape = outputShape?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeoutputShape
                }
            }
            var dataSizeEmbeddedComputationVersions:Int32 = 0
            for oneValueembeddedComputationVersions in embeddedComputationVersions {
                dataSizeEmbeddedComputationVersions += oneValueembeddedComputationVersions.computeInt64SizeNoTag()
            }
            serialize_size += dataSizeEmbeddedComputationVersions
            if !embeddedComputationVersions.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeEmbeddedComputationVersions.computeInt32SizeNoTag()
            }
            embeddedComputationVersionsMemoizedSerializedSize = dataSizeEmbeddedComputationVersions
            if hasRequest {
                if let varSizerequest = request?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizerequest
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.OperationRequest.Builder {
            return Xla.OperationRequest.classBuilder() as! Xla.OperationRequest.Builder
        }
        public func getBuilder() -> Xla.OperationRequest.Builder {
            return classBuilder() as! Xla.OperationRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.OperationRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.OperationRequest.Builder()
        }
        public func toBuilder() throws -> Xla.OperationRequest.Builder {
            return try Xla.OperationRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.OperationRequest) throws -> Xla.OperationRequest.Builder {
            return try Xla.OperationRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasOutputHandle {
                jsonMap["outputHandle"] = try outputHandle.encode()
            }
            if hasOutputShape {
                jsonMap["outputShape"] = try outputShape.encode()
            }
            if !embeddedComputationVersions.isEmpty {
                var jsonArrayEmbeddedComputationVersions:Array<String> = []
                for oneValueEmbeddedComputationVersions in embeddedComputationVersions {
                    jsonArrayEmbeddedComputationVersions.append("\(oneValueEmbeddedComputationVersions)")
                }
                jsonMap["embeddedComputationVersions"] = jsonArrayEmbeddedComputationVersions
            }
            if hasRequest {
                jsonMap["request"] = try request.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.OperationRequest {
            return try Xla.OperationRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.OperationRequest {
            return try Xla.OperationRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasOutputHandle {
                output += "\(indent) outputHandle {\n"
                if let outDescOutputHandle = outputHandle {
                    output += try outDescOutputHandle.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasOutputShape {
                output += "\(indent) outputShape {\n"
                if let outDescOutputShape = outputShape {
                    output += try outDescOutputShape.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            var embeddedComputationVersionsElementIndex:Int = 0
            for oneValueEmbeddedComputationVersions in embeddedComputationVersions  {
                output += "\(indent) embeddedComputationVersions[\(embeddedComputationVersionsElementIndex)]: \(oneValueEmbeddedComputationVersions)\n"
                embeddedComputationVersionsElementIndex += 1
            }
            if hasRequest {
                output += "\(indent) request {\n"
                if let outDescRequest = request {
                    output += try outDescRequest.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasOutputHandle {
                    if let hashValueoutputHandle = outputHandle?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoutputHandle
                    }
                }
                if hasOutputShape {
                    if let hashValueoutputShape = outputShape?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoutputShape
                    }
                }
                for oneValueEmbeddedComputationVersions in embeddedComputationVersions {
                    hashCode = (hashCode &* 31) &+ oneValueEmbeddedComputationVersions.hashValue
                }
                if hasRequest {
                    if let hashValuerequest = request?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuerequest
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.OperationRequest"
        }
        override public func className() -> String {
            return "Xla.OperationRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.OperationRequest = Xla.OperationRequest()
            public func getMessage() -> Xla.OperationRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var outputHandle:Xla.ComputationDataHandle! {
                get {
                    if outputHandleBuilder_ != nil {
                        builderResult.outputHandle = outputHandleBuilder_.getMessage()
                    }
                    return builderResult.outputHandle
                }
                set (value) {
                    builderResult.hasOutputHandle = true
                    builderResult.outputHandle = value
                }
            }
            public var hasOutputHandle:Bool {
                get {
                    return builderResult.hasOutputHandle
                }
            }
            fileprivate var outputHandleBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasOutputHandle = true
                }
            }
            public func getOutputHandleBuilder() -> Xla.ComputationDataHandle.Builder {
                if outputHandleBuilder_ == nil {
                    outputHandleBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.outputHandle = outputHandleBuilder_.getMessage()
                    if outputHandle != nil {
                        try! outputHandleBuilder_.mergeFrom(other: outputHandle)
                    }
                }
                return outputHandleBuilder_
            }
            @discardableResult
            public func setOutputHandle(_ value:Xla.ComputationDataHandle!) -> Xla.OperationRequest.Builder {
                self.outputHandle = value
                return self
            }
            @discardableResult
            public func mergeOutputHandle(value:Xla.ComputationDataHandle) throws -> Xla.OperationRequest.Builder {
                if builderResult.hasOutputHandle {
                    builderResult.outputHandle = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.outputHandle).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.outputHandle = value
                }
                builderResult.hasOutputHandle = true
                return self
            }
            @discardableResult
            public func clearOutputHandle() -> Xla.OperationRequest.Builder {
                outputHandleBuilder_ = nil
                builderResult.hasOutputHandle = false
                builderResult.outputHandle = nil
                return self
            }
            public var outputShape:Xla.Shape! {
                get {
                    if outputShapeBuilder_ != nil {
                        builderResult.outputShape = outputShapeBuilder_.getMessage()
                    }
                    return builderResult.outputShape
                }
                set (value) {
                    builderResult.hasOutputShape = true
                    builderResult.outputShape = value
                }
            }
            public var hasOutputShape:Bool {
                get {
                    return builderResult.hasOutputShape
                }
            }
            fileprivate var outputShapeBuilder_:Xla.Shape.Builder! {
                didSet {
                    builderResult.hasOutputShape = true
                }
            }
            public func getOutputShapeBuilder() -> Xla.Shape.Builder {
                if outputShapeBuilder_ == nil {
                    outputShapeBuilder_ = Xla.Shape.Builder()
                    builderResult.outputShape = outputShapeBuilder_.getMessage()
                    if outputShape != nil {
                        try! outputShapeBuilder_.mergeFrom(other: outputShape)
                    }
                }
                return outputShapeBuilder_
            }
            @discardableResult
            public func setOutputShape(_ value:Xla.Shape!) -> Xla.OperationRequest.Builder {
                self.outputShape = value
                return self
            }
            @discardableResult
            public func mergeOutputShape(value:Xla.Shape) throws -> Xla.OperationRequest.Builder {
                if builderResult.hasOutputShape {
                    builderResult.outputShape = try Xla.Shape.builderWithPrototype(prototype:builderResult.outputShape).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.outputShape = value
                }
                builderResult.hasOutputShape = true
                return self
            }
            @discardableResult
            public func clearOutputShape() -> Xla.OperationRequest.Builder {
                outputShapeBuilder_ = nil
                builderResult.hasOutputShape = false
                builderResult.outputShape = nil
                return self
            }
            /// For operations which call embedded computations such as "Map", these are
            /// the version(s) that the embedded computation should be called at. A version
            /// value of a computation is the ComputationDataHandle of the root of the
            /// computation at the point in time.
            /// "Call", "Map", "Reduce", and "ReduceWindow" operations take a single
            /// embedded computation so this field will have a single value for those
            /// operations.
            /// "While" operation takes two; index 0 is the "condition" version and index 1
            /// is the "body" version.
            public var embeddedComputationVersions:Array<Int64> {
                get {
                    return builderResult.embeddedComputationVersions
                }
                set (array) {
                    builderResult.embeddedComputationVersions = array
                }
            }
            @discardableResult
            public func setEmbeddedComputationVersions(_ value:Array<Int64>) -> Xla.OperationRequest.Builder {
                self.embeddedComputationVersions = value
                return self
            }
            @discardableResult
            public func clearEmbeddedComputationVersions() -> Xla.OperationRequest.Builder {
                builderResult.embeddedComputationVersions.removeAll(keepingCapacity: false)
                return self
            }
            /// The actual request, which in itself is a tagged union of all possible
            /// operation request types.
            public var request:Xla.OpRequest! {
                get {
                    if requestBuilder_ != nil {
                        builderResult.request = requestBuilder_.getMessage()
                    }
                    return builderResult.request
                }
                set (value) {
                    builderResult.hasRequest = true
                    builderResult.request = value
                }
            }
            public var hasRequest:Bool {
                get {
                    return builderResult.hasRequest
                }
            }
            fileprivate var requestBuilder_:Xla.OpRequest.Builder! {
                didSet {
                    builderResult.hasRequest = true
                }
            }
            public func getRequestBuilder() -> Xla.OpRequest.Builder {
                if requestBuilder_ == nil {
                    requestBuilder_ = Xla.OpRequest.Builder()
                    builderResult.request = requestBuilder_.getMessage()
                    if request != nil {
                        try! requestBuilder_.mergeFrom(other: request)
                    }
                }
                return requestBuilder_
            }
            @discardableResult
            public func setRequest(_ value:Xla.OpRequest!) -> Xla.OperationRequest.Builder {
                self.request = value
                return self
            }
            @discardableResult
            public func mergeRequest(value:Xla.OpRequest) throws -> Xla.OperationRequest.Builder {
                if builderResult.hasRequest {
                    builderResult.request = try Xla.OpRequest.builderWithPrototype(prototype:builderResult.request).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.request = value
                }
                builderResult.hasRequest = true
                return self
            }
            @discardableResult
            public func clearRequest() -> Xla.OperationRequest.Builder {
                requestBuilder_ = nil
                builderResult.hasRequest = false
                builderResult.request = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.OperationRequest.Builder {
                builderResult = Xla.OperationRequest()
                return self
            }
            override public func clone() throws -> Xla.OperationRequest.Builder {
                return try Xla.OperationRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.OperationRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.OperationRequest {
                let returnMe:Xla.OperationRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.OperationRequest) throws -> Xla.OperationRequest.Builder {
                if other == Xla.OperationRequest() {
                    return self
                }
                if (other.hasOutputHandle) {
                    try mergeOutputHandle(value: other.outputHandle)
                }
                if (other.hasOutputShape) {
                    try mergeOutputShape(value: other.outputShape)
                }
                if !other.embeddedComputationVersions.isEmpty {
                    builderResult.embeddedComputationVersions += other.embeddedComputationVersions
                }
                if (other.hasRequest) {
                    try mergeRequest(value: other.request)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.OperationRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.OperationRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasOutputHandle {
                            try subBuilder.mergeFrom(other: outputHandle)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        outputHandle = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Xla.Shape.Builder = Xla.Shape.Builder()
                        if hasOutputShape {
                            try subBuilder.mergeFrom(other: outputShape)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        outputShape = subBuilder.buildPartial()

                    case 26:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.embeddedComputationVersions.append(try codedInputStream.readInt64())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 34:
                        let subBuilder:Xla.OpRequest.Builder = Xla.OpRequest.Builder()
                        if hasRequest {
                            try subBuilder.mergeFrom(other: request)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        request = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.OperationRequest.Builder {
                let resultDecodedBuilder = Xla.OperationRequest.Builder()
                if let jsonValueOutputHandle = jsonMap["outputHandle"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.outputHandle = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueOutputHandle).build()

                }
                if let jsonValueOutputShape = jsonMap["outputShape"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.outputShape = try Xla.Shape.Builder.decodeToBuilder(jsonMap:jsonValueOutputShape).build()

                }
                if let jsonValueEmbeddedComputationVersions = jsonMap["embeddedComputationVersions"] as? Array<String> {
                    var jsonArrayEmbeddedComputationVersions:Array<Int64> = []
                    for oneValueEmbeddedComputationVersions in jsonValueEmbeddedComputationVersions {
                        jsonArrayEmbeddedComputationVersions.append(Int64(oneValueEmbeddedComputationVersions)!)
                    }
                    resultDecodedBuilder.embeddedComputationVersions = jsonArrayEmbeddedComputationVersions
                }
                if let jsonValueRequest = jsonMap["request"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.request = try Xla.OpRequest.Builder.decodeToBuilder(jsonMap:jsonValueRequest).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.OperationRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.OperationRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Describes a sequence of operation requests which define an XLA
    /// computation.
    final public class SessionComputation : GeneratedMessage {

        public static func == (lhs: Xla.SessionComputation, rhs: Xla.SessionComputation) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
            fieldCheck = fieldCheck && (lhs.hasComputationHandle == rhs.hasComputationHandle) && (!lhs.hasComputationHandle || lhs.computationHandle == rhs.computationHandle)
            fieldCheck = fieldCheck && (lhs.hasRequests == rhs.hasRequests) && (!lhs.hasRequests || lhs.requests == rhs.requests)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        final public class RequestsEntry : GeneratedMessage {

            public static func == (lhs: Xla.SessionComputation.RequestsEntry, rhs: Xla.SessionComputation.RequestsEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:Int64 = Int64(0)
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:Xla.OperationRequest!
            public fileprivate(set) var hasValue:Bool = false
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeInt64(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeMessage(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeInt64Size(fieldNumber: 1)
                }
                if hasValue {
                    if let varSizevalue = value?.computeMessageSize(fieldNumber: 2) {
                        serialize_size += varSizevalue
                    }
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Xla.SessionComputation.RequestsEntry.Builder {
                return Xla.SessionComputation.RequestsEntry.classBuilder() as! Xla.SessionComputation.RequestsEntry.Builder
            }
            public func getBuilder() -> Xla.SessionComputation.RequestsEntry.Builder {
                return classBuilder() as! Xla.SessionComputation.RequestsEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Xla.SessionComputation.RequestsEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Xla.SessionComputation.RequestsEntry.Builder()
            }
            public func toBuilder() throws -> Xla.SessionComputation.RequestsEntry.Builder {
                return try Xla.SessionComputation.RequestsEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Xla.SessionComputation.RequestsEntry) throws -> Xla.SessionComputation.RequestsEntry.Builder {
                return try Xla.SessionComputation.RequestsEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = "\(key)"
                }
                if hasValue {
                    jsonMap["value"] = try value.encode()
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.SessionComputation.RequestsEntry {
                return try Xla.SessionComputation.RequestsEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Xla.SessionComputation.RequestsEntry {
                return try Xla.SessionComputation.RequestsEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value {\n"
                    if let outDescValue = value {
                        output += try outDescValue.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        if let hashValuevalue = value?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuevalue
                        }
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Xla.SessionComputation.RequestsEntry"
            }
            override public func className() -> String {
                return "Xla.SessionComputation.RequestsEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Xla.SessionComputation.RequestsEntry = Xla.SessionComputation.RequestsEntry()
                public func getMessage() -> Xla.SessionComputation.RequestsEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:Int64 {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:Int64) -> Xla.SessionComputation.RequestsEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> Xla.SessionComputation.RequestsEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = Int64(0)
                    return self
                }
                public var value:Xla.OperationRequest! {
                    get {
                        if valueBuilder_ != nil {
                            builderResult.value = valueBuilder_.getMessage()
                        }
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                fileprivate var valueBuilder_:Xla.OperationRequest.Builder! {
                    didSet {
                        builderResult.hasValue = true
                    }
                }
                public func getValueBuilder() -> Xla.OperationRequest.Builder {
                    if valueBuilder_ == nil {
                        valueBuilder_ = Xla.OperationRequest.Builder()
                        builderResult.value = valueBuilder_.getMessage()
                        if value != nil {
                            try! valueBuilder_.mergeFrom(other: value)
                        }
                    }
                    return valueBuilder_
                }
                @discardableResult
                public func setValue(_ value:Xla.OperationRequest!) -> Xla.SessionComputation.RequestsEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func mergeValue(value:Xla.OperationRequest) throws -> Xla.SessionComputation.RequestsEntry.Builder {
                    if builderResult.hasValue {
                        builderResult.value = try Xla.OperationRequest.builderWithPrototype(prototype:builderResult.value).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.value = value
                    }
                    builderResult.hasValue = true
                    return self
                }
                @discardableResult
                public func clearValue() -> Xla.SessionComputation.RequestsEntry.Builder {
                    valueBuilder_ = nil
                    builderResult.hasValue = false
                    builderResult.value = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Xla.SessionComputation.RequestsEntry.Builder {
                    builderResult = Xla.SessionComputation.RequestsEntry()
                    return self
                }
                override public func clone() throws -> Xla.SessionComputation.RequestsEntry.Builder {
                    return try Xla.SessionComputation.RequestsEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Xla.SessionComputation.RequestsEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Xla.SessionComputation.RequestsEntry {
                    let returnMe:Xla.SessionComputation.RequestsEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Xla.SessionComputation.RequestsEntry) throws -> Xla.SessionComputation.RequestsEntry.Builder {
                    if other == Xla.SessionComputation.RequestsEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if (other.hasValue) {
                        try mergeValue(value: other.value)
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.SessionComputation.RequestsEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SessionComputation.RequestsEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 8:
                            key = try codedInputStream.readInt64()

                        case 18:
                            let subBuilder:Xla.OperationRequest.Builder = Xla.OperationRequest.Builder()
                            if hasValue {
                                try subBuilder.mergeFrom(other: value)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            value = subBuilder.buildPartial()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.SessionComputation.RequestsEntry.Builder {
                    let resultDecodedBuilder = Xla.SessionComputation.RequestsEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = Int64(jsonValueKey)!
                    } else if let jsonValueKey = jsonMap["key"] as? Int {
                        resultDecodedBuilder.key = Int64(jsonValueKey)
                    }
                    if let jsonValueValue = jsonMap["value"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.value = try Xla.OperationRequest.Builder.decodeToBuilder(jsonMap:jsonValueValue).build()

                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Xla.SessionComputation.RequestsEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Xla.SessionComputation.RequestsEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        public fileprivate(set) var name:String = ""
        public fileprivate(set) var hasName:Bool = false

        public fileprivate(set) var computationHandle:Xla.ComputationHandle!
        public fileprivate(set) var hasComputationHandle:Bool = false
        /// Map from ComputationDataHandle value to operation request. The highest
        /// ComputationDataHandle value corresponds to the root of the computation.
        public fileprivate(set) var requests:Dictionary<Int64,Xla.OperationRequest> = Dictionary<Int64,Xla.OperationRequest>()

        public fileprivate(set) var hasRequests:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasName {
                try codedOutputStream.writeString(fieldNumber: 1, value:name)
            }
            if hasComputationHandle {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:computationHandle)
            }
            if hasRequests {
                for (keyRequests, valueRequests) in requests {
                    let valueOfRequests = try! Xla.SessionComputation.RequestsEntry.Builder().setKey(keyRequests).setValue(valueRequests).build()
                      try codedOutputStream.writeMessage(fieldNumber: 3, value:valueOfRequests)
                  }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasName {
                serialize_size += name.computeStringSize(fieldNumber: 1)
            }
            if hasComputationHandle {
                if let varSizecomputationHandle = computationHandle?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizecomputationHandle
                }
            }
            if hasRequests {
                  for (keyRequests, valueRequests) in requests {
                      let valueOfRequests = try! Xla.SessionComputation.RequestsEntry.Builder().setKey(keyRequests).setValue(valueRequests).build()
                serialize_size += valueOfRequests.computeMessageSize(fieldNumber: 3)
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.SessionComputation.Builder {
            return Xla.SessionComputation.classBuilder() as! Xla.SessionComputation.Builder
        }
        public func getBuilder() -> Xla.SessionComputation.Builder {
            return classBuilder() as! Xla.SessionComputation.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.SessionComputation.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.SessionComputation.Builder()
        }
        public func toBuilder() throws -> Xla.SessionComputation.Builder {
            return try Xla.SessionComputation.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.SessionComputation) throws -> Xla.SessionComputation.Builder {
            return try Xla.SessionComputation.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasName {
                jsonMap["name"] = name
            }
            if hasComputationHandle {
                jsonMap["computationHandle"] = try computationHandle.encode()
            }
            if hasRequests {
                var mapRequests = Dictionary<String, Dictionary<String,Any>>()
                for (keyRequests, valueRequests) in requests {
                    mapRequests["\(keyRequests)"] = try valueRequests.encode()
                }
                jsonMap["requests"] = mapRequests
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.SessionComputation {
            return try Xla.SessionComputation.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.SessionComputation {
            return try Xla.SessionComputation.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasName {
                output += "\(indent) name: \(name) \n"
            }
            if hasComputationHandle {
                output += "\(indent) computationHandle {\n"
                if let outDescComputationHandle = computationHandle {
                    output += try outDescComputationHandle.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasRequests {
                output += "\(indent) requests: \(requests) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasName {
                    hashCode = (hashCode &* 31) &+ name.hashValue
                }
                if hasComputationHandle {
                    if let hashValuecomputationHandle = computationHandle?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecomputationHandle
                    }
                }
                if hasRequests {
                    for (keyRequests, valueRequests) in requests {
                        hashCode = (hashCode &* 31) &+ keyRequests.hashValue
                        hashCode = (hashCode &* 31) &+ valueRequests.hashValue
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.SessionComputation"
        }
        override public func className() -> String {
            return "Xla.SessionComputation"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.SessionComputation = Xla.SessionComputation()
            public func getMessage() -> Xla.SessionComputation {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var name:String {
                get {
                    return builderResult.name
                }
                set (value) {
                    builderResult.hasName = true
                    builderResult.name = value
                }
            }
            public var hasName:Bool {
                get {
                    return builderResult.hasName
                }
            }
            @discardableResult
            public func setName(_ value:String) -> Xla.SessionComputation.Builder {
                self.name = value
                return self
            }
            @discardableResult
            public func clearName() -> Xla.SessionComputation.Builder{
                builderResult.hasName = false
                builderResult.name = ""
                return self
            }
            /// The ComputationHandle used to refer to this computation in the XLA
            /// service.
            public var computationHandle:Xla.ComputationHandle! {
                get {
                    if computationHandleBuilder_ != nil {
                        builderResult.computationHandle = computationHandleBuilder_.getMessage()
                    }
                    return builderResult.computationHandle
                }
                set (value) {
                    builderResult.hasComputationHandle = true
                    builderResult.computationHandle = value
                }
            }
            public var hasComputationHandle:Bool {
                get {
                    return builderResult.hasComputationHandle
                }
            }
            fileprivate var computationHandleBuilder_:Xla.ComputationHandle.Builder! {
                didSet {
                    builderResult.hasComputationHandle = true
                }
            }
            public func getComputationHandleBuilder() -> Xla.ComputationHandle.Builder {
                if computationHandleBuilder_ == nil {
                    computationHandleBuilder_ = Xla.ComputationHandle.Builder()
                    builderResult.computationHandle = computationHandleBuilder_.getMessage()
                    if computationHandle != nil {
                        try! computationHandleBuilder_.mergeFrom(other: computationHandle)
                    }
                }
                return computationHandleBuilder_
            }
            @discardableResult
            public func setComputationHandle(_ value:Xla.ComputationHandle!) -> Xla.SessionComputation.Builder {
                self.computationHandle = value
                return self
            }
            @discardableResult
            public func mergeComputationHandle(value:Xla.ComputationHandle) throws -> Xla.SessionComputation.Builder {
                if builderResult.hasComputationHandle {
                    builderResult.computationHandle = try Xla.ComputationHandle.builderWithPrototype(prototype:builderResult.computationHandle).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.computationHandle = value
                }
                builderResult.hasComputationHandle = true
                return self
            }
            @discardableResult
            public func clearComputationHandle() -> Xla.SessionComputation.Builder {
                computationHandleBuilder_ = nil
                builderResult.hasComputationHandle = false
                builderResult.computationHandle = nil
                return self
            }
            /// Map from ComputationDataHandle value to operation request. The highest
            /// ComputationDataHandle value corresponds to the root of the computation.
            public var hasRequests:Bool {
                get {
                    return builderResult.hasRequests
                }
            }
            public var requests:Dictionary<Int64,Xla.OperationRequest> {
                get {
                    return builderResult.requests
                }
                set (value) {
                    builderResult.hasRequests = true
                    builderResult.requests = value
                }
            }
            @discardableResult
            public func setRequests(_ value:Dictionary<Int64,Xla.OperationRequest>) -> Xla.SessionComputation.Builder {
                self.requests = value
                return self
            }
            @discardableResult
            public func clearRequests() -> Xla.SessionComputation.Builder{
                builderResult.hasRequests = false
                builderResult.requests = Dictionary<Int64,Xla.OperationRequest>()
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.SessionComputation.Builder {
                builderResult = Xla.SessionComputation()
                return self
            }
            override public func clone() throws -> Xla.SessionComputation.Builder {
                return try Xla.SessionComputation.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.SessionComputation {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.SessionComputation {
                let returnMe:Xla.SessionComputation = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.SessionComputation) throws -> Xla.SessionComputation.Builder {
                if other == Xla.SessionComputation() {
                    return self
                }
                if other.hasName {
                    name = other.name
                }
                if (other.hasComputationHandle) {
                    try mergeComputationHandle(value: other.computationHandle)
                }
                if other.hasRequests {
                    requests = other.requests
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.SessionComputation.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SessionComputation.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        name = try codedInputStream.readString()

                    case 18:
                        let subBuilder:Xla.ComputationHandle.Builder = Xla.ComputationHandle.Builder()
                        if hasComputationHandle {
                            try subBuilder.mergeFrom(other: computationHandle)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        computationHandle = subBuilder.buildPartial()

                    case 26:
                        let subBuilder = Xla.SessionComputation.RequestsEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfRequests = subBuilder.buildPartial()
                        requests[buildOfRequests.key] = buildOfRequests.value

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.SessionComputation.Builder {
                let resultDecodedBuilder = Xla.SessionComputation.Builder()
                if let jsonValueName = jsonMap["name"] as? String {
                    resultDecodedBuilder.name = jsonValueName
                }
                if let jsonValueComputationHandle = jsonMap["computationHandle"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.computationHandle = try Xla.ComputationHandle.Builder.decodeToBuilder(jsonMap:jsonValueComputationHandle).build()

                }
                if let jsonValueRequests = jsonMap["requests"] as? Dictionary<String, Dictionary<String,Any>> {
                    var mapRequests = Dictionary<Int64, Xla.OperationRequest>()
                    for (keyRequests, valueRequests) in jsonValueRequests {
                        guard let keyFromRequests = Int64(keyRequests) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapRequests[keyFromRequests] = try Xla.OperationRequest.Builder.decodeToBuilder(jsonMap:valueRequests).build()

                    }
                    resultDecodedBuilder.requests = mapRequests
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.SessionComputation.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.SessionComputation.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Describes a group of SessionComputations with an "entry point" computation
    /// that may refer to the other non-entry (AKA embedded) computations.
    /// This message is used to serialize a computation that has been built via the
    /// XLA service API, along with its dependencies, for purposes such as
    /// analysis/replay/file-storage.
    final public class SessionModule : GeneratedMessage {

        public static func == (lhs: Xla.SessionModule, rhs: Xla.SessionModule) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasEntry == rhs.hasEntry) && (!lhs.hasEntry || lhs.entry == rhs.entry)
            fieldCheck = fieldCheck && (lhs.embeddedComputations == rhs.embeddedComputations)
            fieldCheck = fieldCheck && (lhs.arguments == rhs.arguments)
            fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
            fieldCheck = fieldCheck && (lhs.hasExecutionPlatform == rhs.hasExecutionPlatform) && (!lhs.hasExecutionPlatform || lhs.executionPlatform == rhs.executionPlatform)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var entry:Xla.SessionComputation!
        public fileprivate(set) var hasEntry:Bool = false
        public fileprivate(set) var embeddedComputations:Array<Xla.SessionComputation>  = Array<Xla.SessionComputation>()
        public fileprivate(set) var arguments:Array<Xla.Literal>  = Array<Xla.Literal>()
        public fileprivate(set) var result:Xla.Literal!
        public fileprivate(set) var hasResult:Bool = false
        /// The name of the platform used to run the computation.
        public fileprivate(set) var executionPlatform:String = ""
        public fileprivate(set) var hasExecutionPlatform:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasEntry {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:entry)
            }
            for oneElementEmbeddedComputations in embeddedComputations {
                  try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementEmbeddedComputations)
            }
            for oneElementArguments in arguments {
                  try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementArguments)
            }
            if hasResult {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:result)
            }
            if hasExecutionPlatform {
                try codedOutputStream.writeString(fieldNumber: 5, value:executionPlatform)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasEntry {
                if let varSizeentry = entry?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeentry
                }
            }
            for oneElementEmbeddedComputations in embeddedComputations {
                serialize_size += oneElementEmbeddedComputations.computeMessageSize(fieldNumber: 2)
            }
            for oneElementArguments in arguments {
                serialize_size += oneElementArguments.computeMessageSize(fieldNumber: 3)
            }
            if hasResult {
                if let varSizeresult = result?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizeresult
                }
            }
            if hasExecutionPlatform {
                serialize_size += executionPlatform.computeStringSize(fieldNumber: 5)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.SessionModule.Builder {
            return Xla.SessionModule.classBuilder() as! Xla.SessionModule.Builder
        }
        public func getBuilder() -> Xla.SessionModule.Builder {
            return classBuilder() as! Xla.SessionModule.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.SessionModule.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.SessionModule.Builder()
        }
        public func toBuilder() throws -> Xla.SessionModule.Builder {
            return try Xla.SessionModule.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.SessionModule) throws -> Xla.SessionModule.Builder {
            return try Xla.SessionModule.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasEntry {
                jsonMap["entry"] = try entry.encode()
            }
            if !embeddedComputations.isEmpty {
                var jsonArrayEmbeddedComputations:Array<Dictionary<String,Any>> = []
                for oneValueEmbeddedComputations in embeddedComputations {
                    let ecodedMessageEmbeddedComputations = try oneValueEmbeddedComputations.encode()
                    jsonArrayEmbeddedComputations.append(ecodedMessageEmbeddedComputations)
                }
                jsonMap["embeddedComputations"] = jsonArrayEmbeddedComputations
            }
            if !arguments.isEmpty {
                var jsonArrayArguments:Array<Dictionary<String,Any>> = []
                for oneValueArguments in arguments {
                    let ecodedMessageArguments = try oneValueArguments.encode()
                    jsonArrayArguments.append(ecodedMessageArguments)
                }
                jsonMap["arguments"] = jsonArrayArguments
            }
            if hasResult {
                jsonMap["result"] = try result.encode()
            }
            if hasExecutionPlatform {
                jsonMap["executionPlatform"] = executionPlatform
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.SessionModule {
            return try Xla.SessionModule.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.SessionModule {
            return try Xla.SessionModule.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasEntry {
                output += "\(indent) entry {\n"
                if let outDescEntry = entry {
                    output += try outDescEntry.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            var embeddedComputationsElementIndex:Int = 0
            for oneElementEmbeddedComputations in embeddedComputations {
                output += "\(indent) embeddedComputations[\(embeddedComputationsElementIndex)] {\n"
                output += try oneElementEmbeddedComputations.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                embeddedComputationsElementIndex += 1
            }
            var argumentsElementIndex:Int = 0
            for oneElementArguments in arguments {
                output += "\(indent) arguments[\(argumentsElementIndex)] {\n"
                output += try oneElementArguments.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                argumentsElementIndex += 1
            }
            if hasResult {
                output += "\(indent) result {\n"
                if let outDescResult = result {
                    output += try outDescResult.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasExecutionPlatform {
                output += "\(indent) executionPlatform: \(executionPlatform) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasEntry {
                    if let hashValueentry = entry?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueentry
                    }
                }
                for oneElementEmbeddedComputations in embeddedComputations {
                    hashCode = (hashCode &* 31) &+ oneElementEmbeddedComputations.hashValue
                }
                for oneElementArguments in arguments {
                    hashCode = (hashCode &* 31) &+ oneElementArguments.hashValue
                }
                if hasResult {
                    if let hashValueresult = result?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueresult
                    }
                }
                if hasExecutionPlatform {
                    hashCode = (hashCode &* 31) &+ executionPlatform.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.SessionModule"
        }
        override public func className() -> String {
            return "Xla.SessionModule"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.SessionModule = Xla.SessionModule()
            public func getMessage() -> Xla.SessionModule {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The entry computation, which was requested for serialization. This may have
            /// referred to embedded computations, which are reflected below.
            public var entry:Xla.SessionComputation! {
                get {
                    if entryBuilder_ != nil {
                        builderResult.entry = entryBuilder_.getMessage()
                    }
                    return builderResult.entry
                }
                set (value) {
                    builderResult.hasEntry = true
                    builderResult.entry = value
                }
            }
            public var hasEntry:Bool {
                get {
                    return builderResult.hasEntry
                }
            }
            fileprivate var entryBuilder_:Xla.SessionComputation.Builder! {
                didSet {
                    builderResult.hasEntry = true
                }
            }
            public func getEntryBuilder() -> Xla.SessionComputation.Builder {
                if entryBuilder_ == nil {
                    entryBuilder_ = Xla.SessionComputation.Builder()
                    builderResult.entry = entryBuilder_.getMessage()
                    if entry != nil {
                        try! entryBuilder_.mergeFrom(other: entry)
                    }
                }
                return entryBuilder_
            }
            @discardableResult
            public func setEntry(_ value:Xla.SessionComputation!) -> Xla.SessionModule.Builder {
                self.entry = value
                return self
            }
            @discardableResult
            public func mergeEntry(value:Xla.SessionComputation) throws -> Xla.SessionModule.Builder {
                if builderResult.hasEntry {
                    builderResult.entry = try Xla.SessionComputation.builderWithPrototype(prototype:builderResult.entry).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.entry = value
                }
                builderResult.hasEntry = true
                return self
            }
            @discardableResult
            public func clearEntry() -> Xla.SessionModule.Builder {
                entryBuilder_ = nil
                builderResult.hasEntry = false
                builderResult.entry = nil
                return self
            }
            /// Embedded computations that are transitively referred to by the entry
            /// computation.
            public var embeddedComputations:Array<Xla.SessionComputation> {
                get {
                    return builderResult.embeddedComputations
                }
                set (value) {
                    builderResult.embeddedComputations = value
                }
            }
            @discardableResult
            public func setEmbeddedComputations(_ value:Array<Xla.SessionComputation>) -> Xla.SessionModule.Builder {
                self.embeddedComputations = value
                return self
            }
            @discardableResult
            public func clearEmbeddedComputations() -> Xla.SessionModule.Builder {
                builderResult.embeddedComputations.removeAll(keepingCapacity: false)
                return self
            }
            /// The arguments passed to the computation.
            public var arguments:Array<Xla.Literal> {
                get {
                    return builderResult.arguments
                }
                set (value) {
                    builderResult.arguments = value
                }
            }
            @discardableResult
            public func setArguments(_ value:Array<Xla.Literal>) -> Xla.SessionModule.Builder {
                self.arguments = value
                return self
            }
            @discardableResult
            public func clearArguments() -> Xla.SessionModule.Builder {
                builderResult.arguments.removeAll(keepingCapacity: false)
                return self
            }
            /// The result of the computation.
            public var result:Xla.Literal! {
                get {
                    if resultBuilder_ != nil {
                        builderResult.result = resultBuilder_.getMessage()
                    }
                    return builderResult.result
                }
                set (value) {
                    builderResult.hasResult = true
                    builderResult.result = value
                }
            }
            public var hasResult:Bool {
                get {
                    return builderResult.hasResult
                }
            }
            fileprivate var resultBuilder_:Xla.Literal.Builder! {
                didSet {
                    builderResult.hasResult = true
                }
            }
            public func getResultBuilder() -> Xla.Literal.Builder {
                if resultBuilder_ == nil {
                    resultBuilder_ = Xla.Literal.Builder()
                    builderResult.result = resultBuilder_.getMessage()
                    if result != nil {
                        try! resultBuilder_.mergeFrom(other: result)
                    }
                }
                return resultBuilder_
            }
            @discardableResult
            public func setResult(_ value:Xla.Literal!) -> Xla.SessionModule.Builder {
                self.result = value
                return self
            }
            @discardableResult
            public func mergeResult(value:Xla.Literal) throws -> Xla.SessionModule.Builder {
                if builderResult.hasResult {
                    builderResult.result = try Xla.Literal.builderWithPrototype(prototype:builderResult.result).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.result = value
                }
                builderResult.hasResult = true
                return self
            }
            @discardableResult
            public func clearResult() -> Xla.SessionModule.Builder {
                resultBuilder_ = nil
                builderResult.hasResult = false
                builderResult.result = nil
                return self
            }
            /// The name of the platform used to run the computation.
            public var executionPlatform:String {
                get {
                    return builderResult.executionPlatform
                }
                set (value) {
                    builderResult.hasExecutionPlatform = true
                    builderResult.executionPlatform = value
                }
            }
            public var hasExecutionPlatform:Bool {
                get {
                    return builderResult.hasExecutionPlatform
                }
            }
            @discardableResult
            public func setExecutionPlatform(_ value:String) -> Xla.SessionModule.Builder {
                self.executionPlatform = value
                return self
            }
            @discardableResult
            public func clearExecutionPlatform() -> Xla.SessionModule.Builder{
                builderResult.hasExecutionPlatform = false
                builderResult.executionPlatform = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.SessionModule.Builder {
                builderResult = Xla.SessionModule()
                return self
            }
            override public func clone() throws -> Xla.SessionModule.Builder {
                return try Xla.SessionModule.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.SessionModule {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.SessionModule {
                let returnMe:Xla.SessionModule = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.SessionModule) throws -> Xla.SessionModule.Builder {
                if other == Xla.SessionModule() {
                    return self
                }
                if (other.hasEntry) {
                    try mergeEntry(value: other.entry)
                }
                if !other.embeddedComputations.isEmpty  {
                     builderResult.embeddedComputations += other.embeddedComputations
                }
                if !other.arguments.isEmpty  {
                     builderResult.arguments += other.arguments
                }
                if (other.hasResult) {
                    try mergeResult(value: other.result)
                }
                if other.hasExecutionPlatform {
                    executionPlatform = other.executionPlatform
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.SessionModule.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SessionModule.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.SessionComputation.Builder = Xla.SessionComputation.Builder()
                        if hasEntry {
                            try subBuilder.mergeFrom(other: entry)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        entry = subBuilder.buildPartial()

                    case 18:
                        let subBuilder = Xla.SessionComputation.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        embeddedComputations.append(subBuilder.buildPartial())

                    case 26:
                        let subBuilder = Xla.Literal.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        arguments.append(subBuilder.buildPartial())

                    case 34:
                        let subBuilder:Xla.Literal.Builder = Xla.Literal.Builder()
                        if hasResult {
                            try subBuilder.mergeFrom(other: result)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        result = subBuilder.buildPartial()

                    case 42:
                        executionPlatform = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.SessionModule.Builder {
                let resultDecodedBuilder = Xla.SessionModule.Builder()
                if let jsonValueEntry = jsonMap["entry"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.entry = try Xla.SessionComputation.Builder.decodeToBuilder(jsonMap:jsonValueEntry).build()

                }
                if let jsonValueEmbeddedComputations = jsonMap["embeddedComputations"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayEmbeddedComputations:Array<Xla.SessionComputation> = []
                    for oneValueEmbeddedComputations in jsonValueEmbeddedComputations {
                        let messageFromStringEmbeddedComputations = try Xla.SessionComputation.Builder.decodeToBuilder(jsonMap:oneValueEmbeddedComputations).build()

                        jsonArrayEmbeddedComputations.append(messageFromStringEmbeddedComputations)
                    }
                    resultDecodedBuilder.embeddedComputations = jsonArrayEmbeddedComputations
                }
                if let jsonValueArguments = jsonMap["arguments"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayArguments:Array<Xla.Literal> = []
                    for oneValueArguments in jsonValueArguments {
                        let messageFromStringArguments = try Xla.Literal.Builder.decodeToBuilder(jsonMap:oneValueArguments).build()

                        jsonArrayArguments.append(messageFromStringArguments)
                    }
                    resultDecodedBuilder.arguments = jsonArrayArguments
                }
                if let jsonValueResult = jsonMap["result"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.result = try Xla.Literal.Builder.decodeToBuilder(jsonMap:jsonValueResult).build()

                }
                if let jsonValueExecutionPlatform = jsonMap["executionPlatform"] as? String {
                    resultDecodedBuilder.executionPlatform = jsonValueExecutionPlatform
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.SessionModule.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.SessionModule.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Xla.OperationRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.OperationRequest> {
        var mergedArray = Array<Xla.OperationRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.OperationRequest? {
        return try Xla.OperationRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.OperationRequest {
        return try Xla.OperationRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.SessionRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.OperationRequest {
        return try Xla.OperationRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.OperationRequest {
        return try Xla.OperationRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.OperationRequest {
        return try Xla.OperationRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.OperationRequest {
        return try Xla.OperationRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.OperationRequest {
        return try Xla.OperationRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "outputHandle": return self.outputHandle
        case "outputShape": return self.outputShape
        case "embeddedComputationVersions": return self.embeddedComputationVersions
        case "request": return self.request
        default: return nil
        }
    }
}
extension Xla.OperationRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "outputHandle": return self.outputHandle
            case "outputShape": return self.outputShape
            case "embeddedComputationVersions": return self.embeddedComputationVersions
            case "request": return self.request
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "outputHandle":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.outputHandle = newSubscriptValue
            case "outputShape":
                guard let newSubscriptValue = newSubscriptValue as? Xla.Shape else {
                    return
                }
                self.outputShape = newSubscriptValue
            case "embeddedComputationVersions":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.embeddedComputationVersions = newSubscriptValue
            case "request":
                guard let newSubscriptValue = newSubscriptValue as? Xla.OpRequest else {
                    return
                }
                self.request = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.SessionComputation: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.SessionComputation> {
        var mergedArray = Array<Xla.SessionComputation>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.SessionComputation? {
        return try Xla.SessionComputation.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.SessionComputation {
        return try Xla.SessionComputation.Builder().mergeFrom(data: data, extensionRegistry:Xla.SessionRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.SessionComputation {
        return try Xla.SessionComputation.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.SessionComputation {
        return try Xla.SessionComputation.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SessionComputation {
        return try Xla.SessionComputation.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.SessionComputation {
        return try Xla.SessionComputation.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SessionComputation {
        return try Xla.SessionComputation.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "name": return self.name
        case "computationHandle": return self.computationHandle
        case "requests": return self.requests
        default: return nil
        }
    }
}
extension Xla.SessionComputation.RequestsEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.SessionComputation.RequestsEntry> {
        var mergedArray = Array<Xla.SessionComputation.RequestsEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.SessionComputation.RequestsEntry? {
        return try Xla.SessionComputation.RequestsEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.SessionComputation.RequestsEntry {
        return try Xla.SessionComputation.RequestsEntry.Builder().mergeFrom(data: data, extensionRegistry:Xla.SessionRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.SessionComputation.RequestsEntry {
        return try Xla.SessionComputation.RequestsEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.SessionComputation.RequestsEntry {
        return try Xla.SessionComputation.RequestsEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SessionComputation.RequestsEntry {
        return try Xla.SessionComputation.RequestsEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.SessionComputation.RequestsEntry {
        return try Xla.SessionComputation.RequestsEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SessionComputation.RequestsEntry {
        return try Xla.SessionComputation.RequestsEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Xla.SessionComputation.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "name": return self.name
            case "computationHandle": return self.computationHandle
            case "requests": return self.requests
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "computationHandle":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationHandle else {
                    return
                }
                self.computationHandle = newSubscriptValue
            case "requests":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<Int64,Xla.OperationRequest> else {
                    return
                }
                self.requests = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.SessionComputation.RequestsEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Xla.OperationRequest else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.SessionModule: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.SessionModule> {
        var mergedArray = Array<Xla.SessionModule>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.SessionModule? {
        return try Xla.SessionModule.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.SessionModule {
        return try Xla.SessionModule.Builder().mergeFrom(data: data, extensionRegistry:Xla.SessionRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.SessionModule {
        return try Xla.SessionModule.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.SessionModule {
        return try Xla.SessionModule.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SessionModule {
        return try Xla.SessionModule.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.SessionModule {
        return try Xla.SessionModule.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SessionModule {
        return try Xla.SessionModule.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "entry": return self.entry
        case "embeddedComputations": return self.embeddedComputations
        case "arguments": return self.arguments
        case "result": return self.result
        case "executionPlatform": return self.executionPlatform
        default: return nil
        }
    }
}
extension Xla.SessionModule.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "entry": return self.entry
            case "embeddedComputations": return self.embeddedComputations
            case "arguments": return self.arguments
            case "result": return self.result
            case "executionPlatform": return self.executionPlatform
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "entry":
                guard let newSubscriptValue = newSubscriptValue as? Xla.SessionComputation else {
                    return
                }
                self.entry = newSubscriptValue
            case "embeddedComputations":
                guard let newSubscriptValue = newSubscriptValue as? Array<Xla.SessionComputation> else {
                    return
                }
                self.embeddedComputations = newSubscriptValue
            case "arguments":
                guard let newSubscriptValue = newSubscriptValue as? Array<Xla.Literal> else {
                    return
                }
                self.arguments = newSubscriptValue
            case "result":
                guard let newSubscriptValue = newSubscriptValue as? Xla.Literal else {
                    return
                }
                self.result = newSubscriptValue
            case "executionPlatform":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.executionPlatform = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

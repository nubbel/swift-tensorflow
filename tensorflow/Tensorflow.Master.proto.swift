/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "master.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { }

public extension Tensorflow {
    public struct MasterRoot {
        public static let `default` = MasterRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Tensorflow.DeviceAttributesRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.GraphRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.ConfigRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.NamedTensorRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    final public class CreateSessionRequest : GeneratedMessage {

        public static func == (lhs: Tensorflow.CreateSessionRequest, rhs: Tensorflow.CreateSessionRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasGraphDef == rhs.hasGraphDef) && (!lhs.hasGraphDef || lhs.graphDef == rhs.graphDef)
            fieldCheck = fieldCheck && (lhs.hasConfig == rhs.hasConfig) && (!lhs.hasConfig || lhs.config == rhs.config)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var graphDef:Tensorflow.GraphDef!
        public fileprivate(set) var hasGraphDef:Bool = false
        public fileprivate(set) var config:Tensorflow.ConfigProto!
        public fileprivate(set) var hasConfig:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasGraphDef {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:graphDef)
            }
            if hasConfig {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:config)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasGraphDef {
                if let varSizegraphDef = graphDef?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizegraphDef
                }
            }
            if hasConfig {
                if let varSizeconfig = config?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeconfig
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.CreateSessionRequest.Builder {
            return Tensorflow.CreateSessionRequest.classBuilder() as! Tensorflow.CreateSessionRequest.Builder
        }
        public func getBuilder() -> Tensorflow.CreateSessionRequest.Builder {
            return classBuilder() as! Tensorflow.CreateSessionRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.CreateSessionRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.CreateSessionRequest.Builder()
        }
        public func toBuilder() throws -> Tensorflow.CreateSessionRequest.Builder {
            return try Tensorflow.CreateSessionRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.CreateSessionRequest) throws -> Tensorflow.CreateSessionRequest.Builder {
            return try Tensorflow.CreateSessionRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasGraphDef {
                jsonMap["graphDef"] = try graphDef.encode()
            }
            if hasConfig {
                jsonMap["config"] = try config.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CreateSessionRequest {
            return try Tensorflow.CreateSessionRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.CreateSessionRequest {
            return try Tensorflow.CreateSessionRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasGraphDef {
                output += "\(indent) graphDef {\n"
                if let outDescGraphDef = graphDef {
                    output += try outDescGraphDef.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasConfig {
                output += "\(indent) config {\n"
                if let outDescConfig = config {
                    output += try outDescConfig.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasGraphDef {
                    if let hashValuegraphDef = graphDef?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuegraphDef
                    }
                }
                if hasConfig {
                    if let hashValueconfig = config?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueconfig
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.CreateSessionRequest"
        }
        override public func className() -> String {
            return "Tensorflow.CreateSessionRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.CreateSessionRequest = Tensorflow.CreateSessionRequest()
            public func getMessage() -> Tensorflow.CreateSessionRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The initial graph definition.
            public var graphDef:Tensorflow.GraphDef! {
                get {
                    if graphDefBuilder_ != nil {
                        builderResult.graphDef = graphDefBuilder_.getMessage()
                    }
                    return builderResult.graphDef
                }
                set (value) {
                    builderResult.hasGraphDef = true
                    builderResult.graphDef = value
                }
            }
            public var hasGraphDef:Bool {
                get {
                    return builderResult.hasGraphDef
                }
            }
            fileprivate var graphDefBuilder_:Tensorflow.GraphDef.Builder! {
                didSet {
                    builderResult.hasGraphDef = true
                }
            }
            public func getGraphDefBuilder() -> Tensorflow.GraphDef.Builder {
                if graphDefBuilder_ == nil {
                    graphDefBuilder_ = Tensorflow.GraphDef.Builder()
                    builderResult.graphDef = graphDefBuilder_.getMessage()
                    if graphDef != nil {
                        try! graphDefBuilder_.mergeFrom(other: graphDef)
                    }
                }
                return graphDefBuilder_
            }
            @discardableResult
            public func setGraphDef(_ value:Tensorflow.GraphDef!) -> Tensorflow.CreateSessionRequest.Builder {
                self.graphDef = value
                return self
            }
            @discardableResult
            public func mergeGraphDef(value:Tensorflow.GraphDef) throws -> Tensorflow.CreateSessionRequest.Builder {
                if builderResult.hasGraphDef {
                    builderResult.graphDef = try Tensorflow.GraphDef.builderWithPrototype(prototype:builderResult.graphDef).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.graphDef = value
                }
                builderResult.hasGraphDef = true
                return self
            }
            @discardableResult
            public func clearGraphDef() -> Tensorflow.CreateSessionRequest.Builder {
                graphDefBuilder_ = nil
                builderResult.hasGraphDef = false
                builderResult.graphDef = nil
                return self
            }
            /// Configuration options.
            public var config:Tensorflow.ConfigProto! {
                get {
                    if configBuilder_ != nil {
                        builderResult.config = configBuilder_.getMessage()
                    }
                    return builderResult.config
                }
                set (value) {
                    builderResult.hasConfig = true
                    builderResult.config = value
                }
            }
            public var hasConfig:Bool {
                get {
                    return builderResult.hasConfig
                }
            }
            fileprivate var configBuilder_:Tensorflow.ConfigProto.Builder! {
                didSet {
                    builderResult.hasConfig = true
                }
            }
            public func getConfigBuilder() -> Tensorflow.ConfigProto.Builder {
                if configBuilder_ == nil {
                    configBuilder_ = Tensorflow.ConfigProto.Builder()
                    builderResult.config = configBuilder_.getMessage()
                    if config != nil {
                        try! configBuilder_.mergeFrom(other: config)
                    }
                }
                return configBuilder_
            }
            @discardableResult
            public func setConfig(_ value:Tensorflow.ConfigProto!) -> Tensorflow.CreateSessionRequest.Builder {
                self.config = value
                return self
            }
            @discardableResult
            public func mergeConfig(value:Tensorflow.ConfigProto) throws -> Tensorflow.CreateSessionRequest.Builder {
                if builderResult.hasConfig {
                    builderResult.config = try Tensorflow.ConfigProto.builderWithPrototype(prototype:builderResult.config).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.config = value
                }
                builderResult.hasConfig = true
                return self
            }
            @discardableResult
            public func clearConfig() -> Tensorflow.CreateSessionRequest.Builder {
                configBuilder_ = nil
                builderResult.hasConfig = false
                builderResult.config = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.CreateSessionRequest.Builder {
                builderResult = Tensorflow.CreateSessionRequest()
                return self
            }
            override public func clone() throws -> Tensorflow.CreateSessionRequest.Builder {
                return try Tensorflow.CreateSessionRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.CreateSessionRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.CreateSessionRequest {
                let returnMe:Tensorflow.CreateSessionRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.CreateSessionRequest) throws -> Tensorflow.CreateSessionRequest.Builder {
                if other == Tensorflow.CreateSessionRequest() {
                    return self
                }
                if (other.hasGraphDef) {
                    try mergeGraphDef(value: other.graphDef)
                }
                if (other.hasConfig) {
                    try mergeConfig(value: other.config)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CreateSessionRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CreateSessionRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Tensorflow.GraphDef.Builder = Tensorflow.GraphDef.Builder()
                        if hasGraphDef {
                            try subBuilder.mergeFrom(other: graphDef)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        graphDef = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Tensorflow.ConfigProto.Builder = Tensorflow.ConfigProto.Builder()
                        if hasConfig {
                            try subBuilder.mergeFrom(other: config)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        config = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CreateSessionRequest.Builder {
                let resultDecodedBuilder = Tensorflow.CreateSessionRequest.Builder()
                if let jsonValueGraphDef = jsonMap["graphDef"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.graphDef = try Tensorflow.GraphDef.Builder.decodeToBuilder(jsonMap:jsonValueGraphDef).build()

                }
                if let jsonValueConfig = jsonMap["config"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.config = try Tensorflow.ConfigProto.Builder.decodeToBuilder(jsonMap:jsonValueConfig).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.CreateSessionRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.CreateSessionRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class CreateSessionResponse : GeneratedMessage {

        public static func == (lhs: Tensorflow.CreateSessionResponse, rhs: Tensorflow.CreateSessionResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasSessionHandle == rhs.hasSessionHandle) && (!lhs.hasSessionHandle || lhs.sessionHandle == rhs.sessionHandle)
            fieldCheck = fieldCheck && (lhs.hasGraphVersion == rhs.hasGraphVersion) && (!lhs.hasGraphVersion || lhs.graphVersion == rhs.graphVersion)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// The session handle to be used in subsequent calls for the created session.
        /// The client must arrange to call CloseSession with this returned
        /// session handle to close the session.
        public fileprivate(set) var sessionHandle:String = ""
        public fileprivate(set) var hasSessionHandle:Bool = false

        /// The initial version number for the graph, to be used in the next call
        /// to ExtendSession.
        public fileprivate(set) var graphVersion:Int64 = Int64(0)
        public fileprivate(set) var hasGraphVersion:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasSessionHandle {
                try codedOutputStream.writeString(fieldNumber: 1, value:sessionHandle)
            }
            if hasGraphVersion {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:graphVersion)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasSessionHandle {
                serialize_size += sessionHandle.computeStringSize(fieldNumber: 1)
            }
            if hasGraphVersion {
                serialize_size += graphVersion.computeInt64Size(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.CreateSessionResponse.Builder {
            return Tensorflow.CreateSessionResponse.classBuilder() as! Tensorflow.CreateSessionResponse.Builder
        }
        public func getBuilder() -> Tensorflow.CreateSessionResponse.Builder {
            return classBuilder() as! Tensorflow.CreateSessionResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.CreateSessionResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.CreateSessionResponse.Builder()
        }
        public func toBuilder() throws -> Tensorflow.CreateSessionResponse.Builder {
            return try Tensorflow.CreateSessionResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.CreateSessionResponse) throws -> Tensorflow.CreateSessionResponse.Builder {
            return try Tensorflow.CreateSessionResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasSessionHandle {
                jsonMap["sessionHandle"] = sessionHandle
            }
            if hasGraphVersion {
                jsonMap["graphVersion"] = "\(graphVersion)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CreateSessionResponse {
            return try Tensorflow.CreateSessionResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.CreateSessionResponse {
            return try Tensorflow.CreateSessionResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasSessionHandle {
                output += "\(indent) sessionHandle: \(sessionHandle) \n"
            }
            if hasGraphVersion {
                output += "\(indent) graphVersion: \(graphVersion) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasSessionHandle {
                    hashCode = (hashCode &* 31) &+ sessionHandle.hashValue
                }
                if hasGraphVersion {
                    hashCode = (hashCode &* 31) &+ graphVersion.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.CreateSessionResponse"
        }
        override public func className() -> String {
            return "Tensorflow.CreateSessionResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.CreateSessionResponse = Tensorflow.CreateSessionResponse()
            public func getMessage() -> Tensorflow.CreateSessionResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The session handle to be used in subsequent calls for the created session.
            /// The client must arrange to call CloseSession with this returned
            /// session handle to close the session.
            public var sessionHandle:String {
                get {
                    return builderResult.sessionHandle
                }
                set (value) {
                    builderResult.hasSessionHandle = true
                    builderResult.sessionHandle = value
                }
            }
            public var hasSessionHandle:Bool {
                get {
                    return builderResult.hasSessionHandle
                }
            }
            @discardableResult
            public func setSessionHandle(_ value:String) -> Tensorflow.CreateSessionResponse.Builder {
                self.sessionHandle = value
                return self
            }
            @discardableResult
            public func clearSessionHandle() -> Tensorflow.CreateSessionResponse.Builder{
                builderResult.hasSessionHandle = false
                builderResult.sessionHandle = ""
                return self
            }
            /// The initial version number for the graph, to be used in the next call
            /// to ExtendSession.
            public var graphVersion:Int64 {
                get {
                    return builderResult.graphVersion
                }
                set (value) {
                    builderResult.hasGraphVersion = true
                    builderResult.graphVersion = value
                }
            }
            public var hasGraphVersion:Bool {
                get {
                    return builderResult.hasGraphVersion
                }
            }
            @discardableResult
            public func setGraphVersion(_ value:Int64) -> Tensorflow.CreateSessionResponse.Builder {
                self.graphVersion = value
                return self
            }
            @discardableResult
            public func clearGraphVersion() -> Tensorflow.CreateSessionResponse.Builder{
                builderResult.hasGraphVersion = false
                builderResult.graphVersion = Int64(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.CreateSessionResponse.Builder {
                builderResult = Tensorflow.CreateSessionResponse()
                return self
            }
            override public func clone() throws -> Tensorflow.CreateSessionResponse.Builder {
                return try Tensorflow.CreateSessionResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.CreateSessionResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.CreateSessionResponse {
                let returnMe:Tensorflow.CreateSessionResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.CreateSessionResponse) throws -> Tensorflow.CreateSessionResponse.Builder {
                if other == Tensorflow.CreateSessionResponse() {
                    return self
                }
                if other.hasSessionHandle {
                    sessionHandle = other.sessionHandle
                }
                if other.hasGraphVersion {
                    graphVersion = other.graphVersion
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CreateSessionResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CreateSessionResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        sessionHandle = try codedInputStream.readString()

                    case 16:
                        graphVersion = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CreateSessionResponse.Builder {
                let resultDecodedBuilder = Tensorflow.CreateSessionResponse.Builder()
                if let jsonValueSessionHandle = jsonMap["sessionHandle"] as? String {
                    resultDecodedBuilder.sessionHandle = jsonValueSessionHandle
                }
                if let jsonValueGraphVersion = jsonMap["graphVersion"] as? String {
                    resultDecodedBuilder.graphVersion = Int64(jsonValueGraphVersion)!
                } else if let jsonValueGraphVersion = jsonMap["graphVersion"] as? Int {
                    resultDecodedBuilder.graphVersion = Int64(jsonValueGraphVersion)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.CreateSessionResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.CreateSessionResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ExtendSessionRequest : GeneratedMessage {

        public static func == (lhs: Tensorflow.ExtendSessionRequest, rhs: Tensorflow.ExtendSessionRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasSessionHandle == rhs.hasSessionHandle) && (!lhs.hasSessionHandle || lhs.sessionHandle == rhs.sessionHandle)
            fieldCheck = fieldCheck && (lhs.hasGraphDef == rhs.hasGraphDef) && (!lhs.hasGraphDef || lhs.graphDef == rhs.graphDef)
            fieldCheck = fieldCheck && (lhs.hasCurrentGraphVersion == rhs.hasCurrentGraphVersion) && (!lhs.hasCurrentGraphVersion || lhs.currentGraphVersion == rhs.currentGraphVersion)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// REQUIRED: session_handle must be returned by a CreateSession call
        /// to the same master service.
        public fileprivate(set) var sessionHandle:String = ""
        public fileprivate(set) var hasSessionHandle:Bool = false

        public fileprivate(set) var graphDef:Tensorflow.GraphDef!
        public fileprivate(set) var hasGraphDef:Bool = false
        /// REQUIRED: The version number of the graph to be extended. This will be
        /// tested against the current server-side version number, and the operation
        /// will fail with FAILED_PRECONDITION if they do not match.
        public fileprivate(set) var currentGraphVersion:Int64 = Int64(0)
        public fileprivate(set) var hasCurrentGraphVersion:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasSessionHandle {
                try codedOutputStream.writeString(fieldNumber: 1, value:sessionHandle)
            }
            if hasGraphDef {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:graphDef)
            }
            if hasCurrentGraphVersion {
                try codedOutputStream.writeInt64(fieldNumber: 3, value:currentGraphVersion)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasSessionHandle {
                serialize_size += sessionHandle.computeStringSize(fieldNumber: 1)
            }
            if hasGraphDef {
                if let varSizegraphDef = graphDef?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizegraphDef
                }
            }
            if hasCurrentGraphVersion {
                serialize_size += currentGraphVersion.computeInt64Size(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.ExtendSessionRequest.Builder {
            return Tensorflow.ExtendSessionRequest.classBuilder() as! Tensorflow.ExtendSessionRequest.Builder
        }
        public func getBuilder() -> Tensorflow.ExtendSessionRequest.Builder {
            return classBuilder() as! Tensorflow.ExtendSessionRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.ExtendSessionRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.ExtendSessionRequest.Builder()
        }
        public func toBuilder() throws -> Tensorflow.ExtendSessionRequest.Builder {
            return try Tensorflow.ExtendSessionRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.ExtendSessionRequest) throws -> Tensorflow.ExtendSessionRequest.Builder {
            return try Tensorflow.ExtendSessionRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasSessionHandle {
                jsonMap["sessionHandle"] = sessionHandle
            }
            if hasGraphDef {
                jsonMap["graphDef"] = try graphDef.encode()
            }
            if hasCurrentGraphVersion {
                jsonMap["currentGraphVersion"] = "\(currentGraphVersion)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.ExtendSessionRequest {
            return try Tensorflow.ExtendSessionRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.ExtendSessionRequest {
            return try Tensorflow.ExtendSessionRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasSessionHandle {
                output += "\(indent) sessionHandle: \(sessionHandle) \n"
            }
            if hasGraphDef {
                output += "\(indent) graphDef {\n"
                if let outDescGraphDef = graphDef {
                    output += try outDescGraphDef.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasCurrentGraphVersion {
                output += "\(indent) currentGraphVersion: \(currentGraphVersion) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasSessionHandle {
                    hashCode = (hashCode &* 31) &+ sessionHandle.hashValue
                }
                if hasGraphDef {
                    if let hashValuegraphDef = graphDef?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuegraphDef
                    }
                }
                if hasCurrentGraphVersion {
                    hashCode = (hashCode &* 31) &+ currentGraphVersion.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.ExtendSessionRequest"
        }
        override public func className() -> String {
            return "Tensorflow.ExtendSessionRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.ExtendSessionRequest = Tensorflow.ExtendSessionRequest()
            public func getMessage() -> Tensorflow.ExtendSessionRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// REQUIRED: session_handle must be returned by a CreateSession call
            /// to the same master service.
            public var sessionHandle:String {
                get {
                    return builderResult.sessionHandle
                }
                set (value) {
                    builderResult.hasSessionHandle = true
                    builderResult.sessionHandle = value
                }
            }
            public var hasSessionHandle:Bool {
                get {
                    return builderResult.hasSessionHandle
                }
            }
            @discardableResult
            public func setSessionHandle(_ value:String) -> Tensorflow.ExtendSessionRequest.Builder {
                self.sessionHandle = value
                return self
            }
            @discardableResult
            public func clearSessionHandle() -> Tensorflow.ExtendSessionRequest.Builder{
                builderResult.hasSessionHandle = false
                builderResult.sessionHandle = ""
                return self
            }
            /// REQUIRED: The nodes to be added to the session's graph. If any node has
            /// the same name as an existing node, the operation will fail with
            /// ILLEGAL_ARGUMENT.
            public var graphDef:Tensorflow.GraphDef! {
                get {
                    if graphDefBuilder_ != nil {
                        builderResult.graphDef = graphDefBuilder_.getMessage()
                    }
                    return builderResult.graphDef
                }
                set (value) {
                    builderResult.hasGraphDef = true
                    builderResult.graphDef = value
                }
            }
            public var hasGraphDef:Bool {
                get {
                    return builderResult.hasGraphDef
                }
            }
            fileprivate var graphDefBuilder_:Tensorflow.GraphDef.Builder! {
                didSet {
                    builderResult.hasGraphDef = true
                }
            }
            public func getGraphDefBuilder() -> Tensorflow.GraphDef.Builder {
                if graphDefBuilder_ == nil {
                    graphDefBuilder_ = Tensorflow.GraphDef.Builder()
                    builderResult.graphDef = graphDefBuilder_.getMessage()
                    if graphDef != nil {
                        try! graphDefBuilder_.mergeFrom(other: graphDef)
                    }
                }
                return graphDefBuilder_
            }
            @discardableResult
            public func setGraphDef(_ value:Tensorflow.GraphDef!) -> Tensorflow.ExtendSessionRequest.Builder {
                self.graphDef = value
                return self
            }
            @discardableResult
            public func mergeGraphDef(value:Tensorflow.GraphDef) throws -> Tensorflow.ExtendSessionRequest.Builder {
                if builderResult.hasGraphDef {
                    builderResult.graphDef = try Tensorflow.GraphDef.builderWithPrototype(prototype:builderResult.graphDef).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.graphDef = value
                }
                builderResult.hasGraphDef = true
                return self
            }
            @discardableResult
            public func clearGraphDef() -> Tensorflow.ExtendSessionRequest.Builder {
                graphDefBuilder_ = nil
                builderResult.hasGraphDef = false
                builderResult.graphDef = nil
                return self
            }
            /// REQUIRED: The version number of the graph to be extended. This will be
            /// tested against the current server-side version number, and the operation
            /// will fail with FAILED_PRECONDITION if they do not match.
            public var currentGraphVersion:Int64 {
                get {
                    return builderResult.currentGraphVersion
                }
                set (value) {
                    builderResult.hasCurrentGraphVersion = true
                    builderResult.currentGraphVersion = value
                }
            }
            public var hasCurrentGraphVersion:Bool {
                get {
                    return builderResult.hasCurrentGraphVersion
                }
            }
            @discardableResult
            public func setCurrentGraphVersion(_ value:Int64) -> Tensorflow.ExtendSessionRequest.Builder {
                self.currentGraphVersion = value
                return self
            }
            @discardableResult
            public func clearCurrentGraphVersion() -> Tensorflow.ExtendSessionRequest.Builder{
                builderResult.hasCurrentGraphVersion = false
                builderResult.currentGraphVersion = Int64(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.ExtendSessionRequest.Builder {
                builderResult = Tensorflow.ExtendSessionRequest()
                return self
            }
            override public func clone() throws -> Tensorflow.ExtendSessionRequest.Builder {
                return try Tensorflow.ExtendSessionRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.ExtendSessionRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.ExtendSessionRequest {
                let returnMe:Tensorflow.ExtendSessionRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.ExtendSessionRequest) throws -> Tensorflow.ExtendSessionRequest.Builder {
                if other == Tensorflow.ExtendSessionRequest() {
                    return self
                }
                if other.hasSessionHandle {
                    sessionHandle = other.sessionHandle
                }
                if (other.hasGraphDef) {
                    try mergeGraphDef(value: other.graphDef)
                }
                if other.hasCurrentGraphVersion {
                    currentGraphVersion = other.currentGraphVersion
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.ExtendSessionRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ExtendSessionRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        sessionHandle = try codedInputStream.readString()

                    case 18:
                        let subBuilder:Tensorflow.GraphDef.Builder = Tensorflow.GraphDef.Builder()
                        if hasGraphDef {
                            try subBuilder.mergeFrom(other: graphDef)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        graphDef = subBuilder.buildPartial()

                    case 24:
                        currentGraphVersion = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.ExtendSessionRequest.Builder {
                let resultDecodedBuilder = Tensorflow.ExtendSessionRequest.Builder()
                if let jsonValueSessionHandle = jsonMap["sessionHandle"] as? String {
                    resultDecodedBuilder.sessionHandle = jsonValueSessionHandle
                }
                if let jsonValueGraphDef = jsonMap["graphDef"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.graphDef = try Tensorflow.GraphDef.Builder.decodeToBuilder(jsonMap:jsonValueGraphDef).build()

                }
                if let jsonValueCurrentGraphVersion = jsonMap["currentGraphVersion"] as? String {
                    resultDecodedBuilder.currentGraphVersion = Int64(jsonValueCurrentGraphVersion)!
                } else if let jsonValueCurrentGraphVersion = jsonMap["currentGraphVersion"] as? Int {
                    resultDecodedBuilder.currentGraphVersion = Int64(jsonValueCurrentGraphVersion)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.ExtendSessionRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.ExtendSessionRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// TODO(mrry): Return something about the operation?
    final public class ExtendSessionResponse : GeneratedMessage {

        public static func == (lhs: Tensorflow.ExtendSessionResponse, rhs: Tensorflow.ExtendSessionResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasNewGraphVersion == rhs.hasNewGraphVersion) && (!lhs.hasNewGraphVersion || lhs.newGraphVersion == rhs.newGraphVersion)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// The new version number for the extended graph, to be used in the next call
        /// to ExtendSession.
        public fileprivate(set) var newGraphVersion:Int64 = Int64(0)
        public fileprivate(set) var hasNewGraphVersion:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasNewGraphVersion {
                try codedOutputStream.writeInt64(fieldNumber: 4, value:newGraphVersion)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasNewGraphVersion {
                serialize_size += newGraphVersion.computeInt64Size(fieldNumber: 4)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.ExtendSessionResponse.Builder {
            return Tensorflow.ExtendSessionResponse.classBuilder() as! Tensorflow.ExtendSessionResponse.Builder
        }
        public func getBuilder() -> Tensorflow.ExtendSessionResponse.Builder {
            return classBuilder() as! Tensorflow.ExtendSessionResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.ExtendSessionResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.ExtendSessionResponse.Builder()
        }
        public func toBuilder() throws -> Tensorflow.ExtendSessionResponse.Builder {
            return try Tensorflow.ExtendSessionResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.ExtendSessionResponse) throws -> Tensorflow.ExtendSessionResponse.Builder {
            return try Tensorflow.ExtendSessionResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasNewGraphVersion {
                jsonMap["newGraphVersion"] = "\(newGraphVersion)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.ExtendSessionResponse {
            return try Tensorflow.ExtendSessionResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.ExtendSessionResponse {
            return try Tensorflow.ExtendSessionResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasNewGraphVersion {
                output += "\(indent) newGraphVersion: \(newGraphVersion) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasNewGraphVersion {
                    hashCode = (hashCode &* 31) &+ newGraphVersion.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.ExtendSessionResponse"
        }
        override public func className() -> String {
            return "Tensorflow.ExtendSessionResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.ExtendSessionResponse = Tensorflow.ExtendSessionResponse()
            public func getMessage() -> Tensorflow.ExtendSessionResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The new version number for the extended graph, to be used in the next call
            /// to ExtendSession.
            public var newGraphVersion:Int64 {
                get {
                    return builderResult.newGraphVersion
                }
                set (value) {
                    builderResult.hasNewGraphVersion = true
                    builderResult.newGraphVersion = value
                }
            }
            public var hasNewGraphVersion:Bool {
                get {
                    return builderResult.hasNewGraphVersion
                }
            }
            @discardableResult
            public func setNewGraphVersion(_ value:Int64) -> Tensorflow.ExtendSessionResponse.Builder {
                self.newGraphVersion = value
                return self
            }
            @discardableResult
            public func clearNewGraphVersion() -> Tensorflow.ExtendSessionResponse.Builder{
                builderResult.hasNewGraphVersion = false
                builderResult.newGraphVersion = Int64(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.ExtendSessionResponse.Builder {
                builderResult = Tensorflow.ExtendSessionResponse()
                return self
            }
            override public func clone() throws -> Tensorflow.ExtendSessionResponse.Builder {
                return try Tensorflow.ExtendSessionResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.ExtendSessionResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.ExtendSessionResponse {
                let returnMe:Tensorflow.ExtendSessionResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.ExtendSessionResponse) throws -> Tensorflow.ExtendSessionResponse.Builder {
                if other == Tensorflow.ExtendSessionResponse() {
                    return self
                }
                if other.hasNewGraphVersion {
                    newGraphVersion = other.newGraphVersion
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.ExtendSessionResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ExtendSessionResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 32:
                        newGraphVersion = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.ExtendSessionResponse.Builder {
                let resultDecodedBuilder = Tensorflow.ExtendSessionResponse.Builder()
                if let jsonValueNewGraphVersion = jsonMap["newGraphVersion"] as? String {
                    resultDecodedBuilder.newGraphVersion = Int64(jsonValueNewGraphVersion)!
                } else if let jsonValueNewGraphVersion = jsonMap["newGraphVersion"] as? Int {
                    resultDecodedBuilder.newGraphVersion = Int64(jsonValueNewGraphVersion)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.ExtendSessionResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.ExtendSessionResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class RunStepRequest : GeneratedMessage {

        public static func == (lhs: Tensorflow.RunStepRequest, rhs: Tensorflow.RunStepRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasSessionHandle == rhs.hasSessionHandle) && (!lhs.hasSessionHandle || lhs.sessionHandle == rhs.sessionHandle)
            fieldCheck = fieldCheck && (lhs.feed == rhs.feed)
            fieldCheck = fieldCheck && (lhs.fetch == rhs.fetch)
            fieldCheck = fieldCheck && (lhs.target == rhs.target)
            fieldCheck = fieldCheck && (lhs.hasOptions == rhs.hasOptions) && (!lhs.hasOptions || lhs.options == rhs.options)
            fieldCheck = fieldCheck && (lhs.hasPartialRunHandle == rhs.hasPartialRunHandle) && (!lhs.hasPartialRunHandle || lhs.partialRunHandle == rhs.partialRunHandle)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// REQUIRED: session_handle must be returned by a CreateSession call
        /// to the same master service.
        public fileprivate(set) var sessionHandle:String = ""
        public fileprivate(set) var hasSessionHandle:Bool = false

        public fileprivate(set) var feed:Array<Tensorflow.NamedTensorProto>  = Array<Tensorflow.NamedTensorProto>()
        /// Fetches. A list of tensor names. The caller expects a tensor to
        /// be returned for each fetch[i] (see RunStepResponse.tensor). The
        /// order of specified fetches does not change the execution order.
        public fileprivate(set) var fetch:Array<String> = Array<String>()
        /// Target Nodes. A list of node names. The named nodes will be run
        /// to but their outputs will not be fetched.
        public fileprivate(set) var target:Array<String> = Array<String>()
        public fileprivate(set) var options:Tensorflow.RunOptions!
        public fileprivate(set) var hasOptions:Bool = false
        /// Partial run handle (optional). If specified, this will be a partial run
        /// execution, run up to the specified fetches.
        public fileprivate(set) var partialRunHandle:String = ""
        public fileprivate(set) var hasPartialRunHandle:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasSessionHandle {
                try codedOutputStream.writeString(fieldNumber: 1, value:sessionHandle)
            }
            for oneElementFeed in feed {
                  try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementFeed)
            }
            if !fetch.isEmpty {
                for oneValuefetch in fetch {
                    try codedOutputStream.writeString(fieldNumber: 3, value:oneValuefetch)
                }
            }
            if !target.isEmpty {
                for oneValuetarget in target {
                    try codedOutputStream.writeString(fieldNumber: 4, value:oneValuetarget)
                }
            }
            if hasOptions {
                try codedOutputStream.writeMessage(fieldNumber: 5, value:options)
            }
            if hasPartialRunHandle {
                try codedOutputStream.writeString(fieldNumber: 6, value:partialRunHandle)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasSessionHandle {
                serialize_size += sessionHandle.computeStringSize(fieldNumber: 1)
            }
            for oneElementFeed in feed {
                serialize_size += oneElementFeed.computeMessageSize(fieldNumber: 2)
            }
            var dataSizeFetch:Int32 = 0
            for oneValuefetch in fetch {
                dataSizeFetch += oneValuefetch.computeStringSizeNoTag()
            }
            serialize_size += dataSizeFetch
            serialize_size += 1 * Int32(fetch.count)
            var dataSizeTarget:Int32 = 0
            for oneValuetarget in target {
                dataSizeTarget += oneValuetarget.computeStringSizeNoTag()
            }
            serialize_size += dataSizeTarget
            serialize_size += 1 * Int32(target.count)
            if hasOptions {
                if let varSizeoptions = options?.computeMessageSize(fieldNumber: 5) {
                    serialize_size += varSizeoptions
                }
            }
            if hasPartialRunHandle {
                serialize_size += partialRunHandle.computeStringSize(fieldNumber: 6)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.RunStepRequest.Builder {
            return Tensorflow.RunStepRequest.classBuilder() as! Tensorflow.RunStepRequest.Builder
        }
        public func getBuilder() -> Tensorflow.RunStepRequest.Builder {
            return classBuilder() as! Tensorflow.RunStepRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.RunStepRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.RunStepRequest.Builder()
        }
        public func toBuilder() throws -> Tensorflow.RunStepRequest.Builder {
            return try Tensorflow.RunStepRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.RunStepRequest) throws -> Tensorflow.RunStepRequest.Builder {
            return try Tensorflow.RunStepRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasSessionHandle {
                jsonMap["sessionHandle"] = sessionHandle
            }
            if !feed.isEmpty {
                var jsonArrayFeed:Array<Dictionary<String,Any>> = []
                for oneValueFeed in feed {
                    let ecodedMessageFeed = try oneValueFeed.encode()
                    jsonArrayFeed.append(ecodedMessageFeed)
                }
                jsonMap["feed"] = jsonArrayFeed
            }
            if !fetch.isEmpty {
                var jsonArrayFetch:Array<String> = []
                for oneValueFetch in fetch {
                    jsonArrayFetch.append(oneValueFetch)
                }
                jsonMap["fetch"] = jsonArrayFetch
            }
            if !target.isEmpty {
                var jsonArrayTarget:Array<String> = []
                for oneValueTarget in target {
                    jsonArrayTarget.append(oneValueTarget)
                }
                jsonMap["target"] = jsonArrayTarget
            }
            if hasOptions {
                jsonMap["options"] = try options.encode()
            }
            if hasPartialRunHandle {
                jsonMap["partialRunHandle"] = partialRunHandle
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.RunStepRequest {
            return try Tensorflow.RunStepRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.RunStepRequest {
            return try Tensorflow.RunStepRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasSessionHandle {
                output += "\(indent) sessionHandle: \(sessionHandle) \n"
            }
            var feedElementIndex:Int = 0
            for oneElementFeed in feed {
                output += "\(indent) feed[\(feedElementIndex)] {\n"
                output += try oneElementFeed.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                feedElementIndex += 1
            }
            var fetchElementIndex:Int = 0
            for oneValueFetch in fetch  {
                output += "\(indent) fetch[\(fetchElementIndex)]: \(oneValueFetch)\n"
                fetchElementIndex += 1
            }
            var targetElementIndex:Int = 0
            for oneValueTarget in target  {
                output += "\(indent) target[\(targetElementIndex)]: \(oneValueTarget)\n"
                targetElementIndex += 1
            }
            if hasOptions {
                output += "\(indent) options {\n"
                if let outDescOptions = options {
                    output += try outDescOptions.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasPartialRunHandle {
                output += "\(indent) partialRunHandle: \(partialRunHandle) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasSessionHandle {
                    hashCode = (hashCode &* 31) &+ sessionHandle.hashValue
                }
                for oneElementFeed in feed {
                    hashCode = (hashCode &* 31) &+ oneElementFeed.hashValue
                }
                for oneValueFetch in fetch {
                    hashCode = (hashCode &* 31) &+ oneValueFetch.hashValue
                }
                for oneValueTarget in target {
                    hashCode = (hashCode &* 31) &+ oneValueTarget.hashValue
                }
                if hasOptions {
                    if let hashValueoptions = options?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoptions
                    }
                }
                if hasPartialRunHandle {
                    hashCode = (hashCode &* 31) &+ partialRunHandle.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.RunStepRequest"
        }
        override public func className() -> String {
            return "Tensorflow.RunStepRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.RunStepRequest = Tensorflow.RunStepRequest()
            public func getMessage() -> Tensorflow.RunStepRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// REQUIRED: session_handle must be returned by a CreateSession call
            /// to the same master service.
            public var sessionHandle:String {
                get {
                    return builderResult.sessionHandle
                }
                set (value) {
                    builderResult.hasSessionHandle = true
                    builderResult.sessionHandle = value
                }
            }
            public var hasSessionHandle:Bool {
                get {
                    return builderResult.hasSessionHandle
                }
            }
            @discardableResult
            public func setSessionHandle(_ value:String) -> Tensorflow.RunStepRequest.Builder {
                self.sessionHandle = value
                return self
            }
            @discardableResult
            public func clearSessionHandle() -> Tensorflow.RunStepRequest.Builder{
                builderResult.hasSessionHandle = false
                builderResult.sessionHandle = ""
                return self
            }
            /// Tensors to be fed in the step. Each feed is a named tensor.
            public var feed:Array<Tensorflow.NamedTensorProto> {
                get {
                    return builderResult.feed
                }
                set (value) {
                    builderResult.feed = value
                }
            }
            @discardableResult
            public func setFeed(_ value:Array<Tensorflow.NamedTensorProto>) -> Tensorflow.RunStepRequest.Builder {
                self.feed = value
                return self
            }
            @discardableResult
            public func clearFeed() -> Tensorflow.RunStepRequest.Builder {
                builderResult.feed.removeAll(keepingCapacity: false)
                return self
            }
            /// Fetches. A list of tensor names. The caller expects a tensor to
            /// be returned for each fetch[i] (see RunStepResponse.tensor). The
            /// order of specified fetches does not change the execution order.
            public var fetch:Array<String> {
                get {
                    return builderResult.fetch
                }
                set (array) {
                    builderResult.fetch = array
                }
            }
            @discardableResult
            public func setFetch(_ value:Array<String>) -> Tensorflow.RunStepRequest.Builder {
                self.fetch = value
                return self
            }
            @discardableResult
            public func clearFetch() -> Tensorflow.RunStepRequest.Builder {
                builderResult.fetch.removeAll(keepingCapacity: false)
                return self
            }
            /// Target Nodes. A list of node names. The named nodes will be run
            /// to but their outputs will not be fetched.
            public var target:Array<String> {
                get {
                    return builderResult.target
                }
                set (array) {
                    builderResult.target = array
                }
            }
            @discardableResult
            public func setTarget(_ value:Array<String>) -> Tensorflow.RunStepRequest.Builder {
                self.target = value
                return self
            }
            @discardableResult
            public func clearTarget() -> Tensorflow.RunStepRequest.Builder {
                builderResult.target.removeAll(keepingCapacity: false)
                return self
            }
            /// Options for the run call.
            public var options:Tensorflow.RunOptions! {
                get {
                    if optionsBuilder_ != nil {
                        builderResult.options = optionsBuilder_.getMessage()
                    }
                    return builderResult.options
                }
                set (value) {
                    builderResult.hasOptions = true
                    builderResult.options = value
                }
            }
            public var hasOptions:Bool {
                get {
                    return builderResult.hasOptions
                }
            }
            fileprivate var optionsBuilder_:Tensorflow.RunOptions.Builder! {
                didSet {
                    builderResult.hasOptions = true
                }
            }
            public func getOptionsBuilder() -> Tensorflow.RunOptions.Builder {
                if optionsBuilder_ == nil {
                    optionsBuilder_ = Tensorflow.RunOptions.Builder()
                    builderResult.options = optionsBuilder_.getMessage()
                    if options != nil {
                        try! optionsBuilder_.mergeFrom(other: options)
                    }
                }
                return optionsBuilder_
            }
            @discardableResult
            public func setOptions(_ value:Tensorflow.RunOptions!) -> Tensorflow.RunStepRequest.Builder {
                self.options = value
                return self
            }
            @discardableResult
            public func mergeOptions(value:Tensorflow.RunOptions) throws -> Tensorflow.RunStepRequest.Builder {
                if builderResult.hasOptions {
                    builderResult.options = try Tensorflow.RunOptions.builderWithPrototype(prototype:builderResult.options).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.options = value
                }
                builderResult.hasOptions = true
                return self
            }
            @discardableResult
            public func clearOptions() -> Tensorflow.RunStepRequest.Builder {
                optionsBuilder_ = nil
                builderResult.hasOptions = false
                builderResult.options = nil
                return self
            }
            /// Partial run handle (optional). If specified, this will be a partial run
            /// execution, run up to the specified fetches.
            public var partialRunHandle:String {
                get {
                    return builderResult.partialRunHandle
                }
                set (value) {
                    builderResult.hasPartialRunHandle = true
                    builderResult.partialRunHandle = value
                }
            }
            public var hasPartialRunHandle:Bool {
                get {
                    return builderResult.hasPartialRunHandle
                }
            }
            @discardableResult
            public func setPartialRunHandle(_ value:String) -> Tensorflow.RunStepRequest.Builder {
                self.partialRunHandle = value
                return self
            }
            @discardableResult
            public func clearPartialRunHandle() -> Tensorflow.RunStepRequest.Builder{
                builderResult.hasPartialRunHandle = false
                builderResult.partialRunHandle = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.RunStepRequest.Builder {
                builderResult = Tensorflow.RunStepRequest()
                return self
            }
            override public func clone() throws -> Tensorflow.RunStepRequest.Builder {
                return try Tensorflow.RunStepRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.RunStepRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.RunStepRequest {
                let returnMe:Tensorflow.RunStepRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.RunStepRequest) throws -> Tensorflow.RunStepRequest.Builder {
                if other == Tensorflow.RunStepRequest() {
                    return self
                }
                if other.hasSessionHandle {
                    sessionHandle = other.sessionHandle
                }
                if !other.feed.isEmpty  {
                     builderResult.feed += other.feed
                }
                if !other.fetch.isEmpty {
                    builderResult.fetch += other.fetch
                }
                if !other.target.isEmpty {
                    builderResult.target += other.target
                }
                if (other.hasOptions) {
                    try mergeOptions(value: other.options)
                }
                if other.hasPartialRunHandle {
                    partialRunHandle = other.partialRunHandle
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.RunStepRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RunStepRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        sessionHandle = try codedInputStream.readString()

                    case 18:
                        let subBuilder = Tensorflow.NamedTensorProto.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        feed.append(subBuilder.buildPartial())

                    case 26:
                        fetch += [try codedInputStream.readString()]

                    case 34:
                        target += [try codedInputStream.readString()]

                    case 42:
                        let subBuilder:Tensorflow.RunOptions.Builder = Tensorflow.RunOptions.Builder()
                        if hasOptions {
                            try subBuilder.mergeFrom(other: options)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        options = subBuilder.buildPartial()

                    case 50:
                        partialRunHandle = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.RunStepRequest.Builder {
                let resultDecodedBuilder = Tensorflow.RunStepRequest.Builder()
                if let jsonValueSessionHandle = jsonMap["sessionHandle"] as? String {
                    resultDecodedBuilder.sessionHandle = jsonValueSessionHandle
                }
                if let jsonValueFeed = jsonMap["feed"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayFeed:Array<Tensorflow.NamedTensorProto> = []
                    for oneValueFeed in jsonValueFeed {
                        let messageFromStringFeed = try Tensorflow.NamedTensorProto.Builder.decodeToBuilder(jsonMap:oneValueFeed).build()

                        jsonArrayFeed.append(messageFromStringFeed)
                    }
                    resultDecodedBuilder.feed = jsonArrayFeed
                }
                if let jsonValueFetch = jsonMap["fetch"] as? Array<String> {
                    var jsonArrayFetch:Array<String> = []
                    for oneValueFetch in jsonValueFetch {
                        jsonArrayFetch.append(oneValueFetch)
                    }
                    resultDecodedBuilder.fetch = jsonArrayFetch
                }
                if let jsonValueTarget = jsonMap["target"] as? Array<String> {
                    var jsonArrayTarget:Array<String> = []
                    for oneValueTarget in jsonValueTarget {
                        jsonArrayTarget.append(oneValueTarget)
                    }
                    resultDecodedBuilder.target = jsonArrayTarget
                }
                if let jsonValueOptions = jsonMap["options"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.options = try Tensorflow.RunOptions.Builder.decodeToBuilder(jsonMap:jsonValueOptions).build()

                }
                if let jsonValuePartialRunHandle = jsonMap["partialRunHandle"] as? String {
                    resultDecodedBuilder.partialRunHandle = jsonValuePartialRunHandle
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.RunStepRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.RunStepRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class RunStepResponse : GeneratedMessage {

        public static func == (lhs: Tensorflow.RunStepResponse, rhs: Tensorflow.RunStepResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.tensor == rhs.tensor)
            fieldCheck = fieldCheck && (lhs.hasMetadata == rhs.hasMetadata) && (!lhs.hasMetadata || lhs.metadata == rhs.metadata)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var tensor:Array<Tensorflow.NamedTensorProto>  = Array<Tensorflow.NamedTensorProto>()
        public fileprivate(set) var metadata:Tensorflow.RunMetadata!
        public fileprivate(set) var hasMetadata:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementTensor in tensor {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementTensor)
            }
            if hasMetadata {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:metadata)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementTensor in tensor {
                serialize_size += oneElementTensor.computeMessageSize(fieldNumber: 1)
            }
            if hasMetadata {
                if let varSizemetadata = metadata?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizemetadata
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.RunStepResponse.Builder {
            return Tensorflow.RunStepResponse.classBuilder() as! Tensorflow.RunStepResponse.Builder
        }
        public func getBuilder() -> Tensorflow.RunStepResponse.Builder {
            return classBuilder() as! Tensorflow.RunStepResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.RunStepResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.RunStepResponse.Builder()
        }
        public func toBuilder() throws -> Tensorflow.RunStepResponse.Builder {
            return try Tensorflow.RunStepResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.RunStepResponse) throws -> Tensorflow.RunStepResponse.Builder {
            return try Tensorflow.RunStepResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !tensor.isEmpty {
                var jsonArrayTensor:Array<Dictionary<String,Any>> = []
                for oneValueTensor in tensor {
                    let ecodedMessageTensor = try oneValueTensor.encode()
                    jsonArrayTensor.append(ecodedMessageTensor)
                }
                jsonMap["tensor"] = jsonArrayTensor
            }
            if hasMetadata {
                jsonMap["metadata"] = try metadata.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.RunStepResponse {
            return try Tensorflow.RunStepResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.RunStepResponse {
            return try Tensorflow.RunStepResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var tensorElementIndex:Int = 0
            for oneElementTensor in tensor {
                output += "\(indent) tensor[\(tensorElementIndex)] {\n"
                output += try oneElementTensor.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                tensorElementIndex += 1
            }
            if hasMetadata {
                output += "\(indent) metadata {\n"
                if let outDescMetadata = metadata {
                    output += try outDescMetadata.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementTensor in tensor {
                    hashCode = (hashCode &* 31) &+ oneElementTensor.hashValue
                }
                if hasMetadata {
                    if let hashValuemetadata = metadata?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuemetadata
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.RunStepResponse"
        }
        override public func className() -> String {
            return "Tensorflow.RunStepResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.RunStepResponse = Tensorflow.RunStepResponse()
            public func getMessage() -> Tensorflow.RunStepResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// NOTE: The order of the returned tensors may or may not match
            /// the fetch order specified in RunStepRequest.
            public var tensor:Array<Tensorflow.NamedTensorProto> {
                get {
                    return builderResult.tensor
                }
                set (value) {
                    builderResult.tensor = value
                }
            }
            @discardableResult
            public func setTensor(_ value:Array<Tensorflow.NamedTensorProto>) -> Tensorflow.RunStepResponse.Builder {
                self.tensor = value
                return self
            }
            @discardableResult
            public func clearTensor() -> Tensorflow.RunStepResponse.Builder {
                builderResult.tensor.removeAll(keepingCapacity: false)
                return self
            }
            /// Returned metadata if requested in the options.
            public var metadata:Tensorflow.RunMetadata! {
                get {
                    if metadataBuilder_ != nil {
                        builderResult.metadata = metadataBuilder_.getMessage()
                    }
                    return builderResult.metadata
                }
                set (value) {
                    builderResult.hasMetadata = true
                    builderResult.metadata = value
                }
            }
            public var hasMetadata:Bool {
                get {
                    return builderResult.hasMetadata
                }
            }
            fileprivate var metadataBuilder_:Tensorflow.RunMetadata.Builder! {
                didSet {
                    builderResult.hasMetadata = true
                }
            }
            public func getMetadataBuilder() -> Tensorflow.RunMetadata.Builder {
                if metadataBuilder_ == nil {
                    metadataBuilder_ = Tensorflow.RunMetadata.Builder()
                    builderResult.metadata = metadataBuilder_.getMessage()
                    if metadata != nil {
                        try! metadataBuilder_.mergeFrom(other: metadata)
                    }
                }
                return metadataBuilder_
            }
            @discardableResult
            public func setMetadata(_ value:Tensorflow.RunMetadata!) -> Tensorflow.RunStepResponse.Builder {
                self.metadata = value
                return self
            }
            @discardableResult
            public func mergeMetadata(value:Tensorflow.RunMetadata) throws -> Tensorflow.RunStepResponse.Builder {
                if builderResult.hasMetadata {
                    builderResult.metadata = try Tensorflow.RunMetadata.builderWithPrototype(prototype:builderResult.metadata).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.metadata = value
                }
                builderResult.hasMetadata = true
                return self
            }
            @discardableResult
            public func clearMetadata() -> Tensorflow.RunStepResponse.Builder {
                metadataBuilder_ = nil
                builderResult.hasMetadata = false
                builderResult.metadata = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.RunStepResponse.Builder {
                builderResult = Tensorflow.RunStepResponse()
                return self
            }
            override public func clone() throws -> Tensorflow.RunStepResponse.Builder {
                return try Tensorflow.RunStepResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.RunStepResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.RunStepResponse {
                let returnMe:Tensorflow.RunStepResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.RunStepResponse) throws -> Tensorflow.RunStepResponse.Builder {
                if other == Tensorflow.RunStepResponse() {
                    return self
                }
                if !other.tensor.isEmpty  {
                     builderResult.tensor += other.tensor
                }
                if (other.hasMetadata) {
                    try mergeMetadata(value: other.metadata)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.RunStepResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RunStepResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Tensorflow.NamedTensorProto.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        tensor.append(subBuilder.buildPartial())

                    case 18:
                        let subBuilder:Tensorflow.RunMetadata.Builder = Tensorflow.RunMetadata.Builder()
                        if hasMetadata {
                            try subBuilder.mergeFrom(other: metadata)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        metadata = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.RunStepResponse.Builder {
                let resultDecodedBuilder = Tensorflow.RunStepResponse.Builder()
                if let jsonValueTensor = jsonMap["tensor"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayTensor:Array<Tensorflow.NamedTensorProto> = []
                    for oneValueTensor in jsonValueTensor {
                        let messageFromStringTensor = try Tensorflow.NamedTensorProto.Builder.decodeToBuilder(jsonMap:oneValueTensor).build()

                        jsonArrayTensor.append(messageFromStringTensor)
                    }
                    resultDecodedBuilder.tensor = jsonArrayTensor
                }
                if let jsonValueMetadata = jsonMap["metadata"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.metadata = try Tensorflow.RunMetadata.Builder.decodeToBuilder(jsonMap:jsonValueMetadata).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.RunStepResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.RunStepResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class PartialRunSetupRequest : GeneratedMessage {

        public static func == (lhs: Tensorflow.PartialRunSetupRequest, rhs: Tensorflow.PartialRunSetupRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasSessionHandle == rhs.hasSessionHandle) && (!lhs.hasSessionHandle || lhs.sessionHandle == rhs.sessionHandle)
            fieldCheck = fieldCheck && (lhs.feed == rhs.feed)
            fieldCheck = fieldCheck && (lhs.fetch == rhs.fetch)
            fieldCheck = fieldCheck && (lhs.target == rhs.target)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// REQUIRED: session_handle must be returned by a CreateSession call
        /// to the same master service.
        public fileprivate(set) var sessionHandle:String = ""
        public fileprivate(set) var hasSessionHandle:Bool = false

        /// Tensors to be fed in future steps.
        public fileprivate(set) var feed:Array<String> = Array<String>()
        /// Fetches. A list of tensor names. The caller expects a tensor to be returned
        /// for each fetch[i] (see RunStepResponse.tensor), for corresponding partial
        /// RunStepRequests. The order of specified fetches does not change the
        /// execution order.
        public fileprivate(set) var fetch:Array<String> = Array<String>()
        /// Target Nodes. A list of node names. The named nodes will be run in future
        /// steps, but their outputs will not be fetched.
        public fileprivate(set) var target:Array<String> = Array<String>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasSessionHandle {
                try codedOutputStream.writeString(fieldNumber: 1, value:sessionHandle)
            }
            if !feed.isEmpty {
                for oneValuefeed in feed {
                    try codedOutputStream.writeString(fieldNumber: 2, value:oneValuefeed)
                }
            }
            if !fetch.isEmpty {
                for oneValuefetch in fetch {
                    try codedOutputStream.writeString(fieldNumber: 3, value:oneValuefetch)
                }
            }
            if !target.isEmpty {
                for oneValuetarget in target {
                    try codedOutputStream.writeString(fieldNumber: 4, value:oneValuetarget)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasSessionHandle {
                serialize_size += sessionHandle.computeStringSize(fieldNumber: 1)
            }
            var dataSizeFeed:Int32 = 0
            for oneValuefeed in feed {
                dataSizeFeed += oneValuefeed.computeStringSizeNoTag()
            }
            serialize_size += dataSizeFeed
            serialize_size += 1 * Int32(feed.count)
            var dataSizeFetch:Int32 = 0
            for oneValuefetch in fetch {
                dataSizeFetch += oneValuefetch.computeStringSizeNoTag()
            }
            serialize_size += dataSizeFetch
            serialize_size += 1 * Int32(fetch.count)
            var dataSizeTarget:Int32 = 0
            for oneValuetarget in target {
                dataSizeTarget += oneValuetarget.computeStringSizeNoTag()
            }
            serialize_size += dataSizeTarget
            serialize_size += 1 * Int32(target.count)
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.PartialRunSetupRequest.Builder {
            return Tensorflow.PartialRunSetupRequest.classBuilder() as! Tensorflow.PartialRunSetupRequest.Builder
        }
        public func getBuilder() -> Tensorflow.PartialRunSetupRequest.Builder {
            return classBuilder() as! Tensorflow.PartialRunSetupRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.PartialRunSetupRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.PartialRunSetupRequest.Builder()
        }
        public func toBuilder() throws -> Tensorflow.PartialRunSetupRequest.Builder {
            return try Tensorflow.PartialRunSetupRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.PartialRunSetupRequest) throws -> Tensorflow.PartialRunSetupRequest.Builder {
            return try Tensorflow.PartialRunSetupRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasSessionHandle {
                jsonMap["sessionHandle"] = sessionHandle
            }
            if !feed.isEmpty {
                var jsonArrayFeed:Array<String> = []
                for oneValueFeed in feed {
                    jsonArrayFeed.append(oneValueFeed)
                }
                jsonMap["feed"] = jsonArrayFeed
            }
            if !fetch.isEmpty {
                var jsonArrayFetch:Array<String> = []
                for oneValueFetch in fetch {
                    jsonArrayFetch.append(oneValueFetch)
                }
                jsonMap["fetch"] = jsonArrayFetch
            }
            if !target.isEmpty {
                var jsonArrayTarget:Array<String> = []
                for oneValueTarget in target {
                    jsonArrayTarget.append(oneValueTarget)
                }
                jsonMap["target"] = jsonArrayTarget
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.PartialRunSetupRequest {
            return try Tensorflow.PartialRunSetupRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.PartialRunSetupRequest {
            return try Tensorflow.PartialRunSetupRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasSessionHandle {
                output += "\(indent) sessionHandle: \(sessionHandle) \n"
            }
            var feedElementIndex:Int = 0
            for oneValueFeed in feed  {
                output += "\(indent) feed[\(feedElementIndex)]: \(oneValueFeed)\n"
                feedElementIndex += 1
            }
            var fetchElementIndex:Int = 0
            for oneValueFetch in fetch  {
                output += "\(indent) fetch[\(fetchElementIndex)]: \(oneValueFetch)\n"
                fetchElementIndex += 1
            }
            var targetElementIndex:Int = 0
            for oneValueTarget in target  {
                output += "\(indent) target[\(targetElementIndex)]: \(oneValueTarget)\n"
                targetElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasSessionHandle {
                    hashCode = (hashCode &* 31) &+ sessionHandle.hashValue
                }
                for oneValueFeed in feed {
                    hashCode = (hashCode &* 31) &+ oneValueFeed.hashValue
                }
                for oneValueFetch in fetch {
                    hashCode = (hashCode &* 31) &+ oneValueFetch.hashValue
                }
                for oneValueTarget in target {
                    hashCode = (hashCode &* 31) &+ oneValueTarget.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.PartialRunSetupRequest"
        }
        override public func className() -> String {
            return "Tensorflow.PartialRunSetupRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.PartialRunSetupRequest = Tensorflow.PartialRunSetupRequest()
            public func getMessage() -> Tensorflow.PartialRunSetupRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// REQUIRED: session_handle must be returned by a CreateSession call
            /// to the same master service.
            public var sessionHandle:String {
                get {
                    return builderResult.sessionHandle
                }
                set (value) {
                    builderResult.hasSessionHandle = true
                    builderResult.sessionHandle = value
                }
            }
            public var hasSessionHandle:Bool {
                get {
                    return builderResult.hasSessionHandle
                }
            }
            @discardableResult
            public func setSessionHandle(_ value:String) -> Tensorflow.PartialRunSetupRequest.Builder {
                self.sessionHandle = value
                return self
            }
            @discardableResult
            public func clearSessionHandle() -> Tensorflow.PartialRunSetupRequest.Builder{
                builderResult.hasSessionHandle = false
                builderResult.sessionHandle = ""
                return self
            }
            /// Tensors to be fed in future steps.
            public var feed:Array<String> {
                get {
                    return builderResult.feed
                }
                set (array) {
                    builderResult.feed = array
                }
            }
            @discardableResult
            public func setFeed(_ value:Array<String>) -> Tensorflow.PartialRunSetupRequest.Builder {
                self.feed = value
                return self
            }
            @discardableResult
            public func clearFeed() -> Tensorflow.PartialRunSetupRequest.Builder {
                builderResult.feed.removeAll(keepingCapacity: false)
                return self
            }
            /// Fetches. A list of tensor names. The caller expects a tensor to be returned
            /// for each fetch[i] (see RunStepResponse.tensor), for corresponding partial
            /// RunStepRequests. The order of specified fetches does not change the
            /// execution order.
            public var fetch:Array<String> {
                get {
                    return builderResult.fetch
                }
                set (array) {
                    builderResult.fetch = array
                }
            }
            @discardableResult
            public func setFetch(_ value:Array<String>) -> Tensorflow.PartialRunSetupRequest.Builder {
                self.fetch = value
                return self
            }
            @discardableResult
            public func clearFetch() -> Tensorflow.PartialRunSetupRequest.Builder {
                builderResult.fetch.removeAll(keepingCapacity: false)
                return self
            }
            /// Target Nodes. A list of node names. The named nodes will be run in future
            /// steps, but their outputs will not be fetched.
            public var target:Array<String> {
                get {
                    return builderResult.target
                }
                set (array) {
                    builderResult.target = array
                }
            }
            @discardableResult
            public func setTarget(_ value:Array<String>) -> Tensorflow.PartialRunSetupRequest.Builder {
                self.target = value
                return self
            }
            @discardableResult
            public func clearTarget() -> Tensorflow.PartialRunSetupRequest.Builder {
                builderResult.target.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.PartialRunSetupRequest.Builder {
                builderResult = Tensorflow.PartialRunSetupRequest()
                return self
            }
            override public func clone() throws -> Tensorflow.PartialRunSetupRequest.Builder {
                return try Tensorflow.PartialRunSetupRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.PartialRunSetupRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.PartialRunSetupRequest {
                let returnMe:Tensorflow.PartialRunSetupRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.PartialRunSetupRequest) throws -> Tensorflow.PartialRunSetupRequest.Builder {
                if other == Tensorflow.PartialRunSetupRequest() {
                    return self
                }
                if other.hasSessionHandle {
                    sessionHandle = other.sessionHandle
                }
                if !other.feed.isEmpty {
                    builderResult.feed += other.feed
                }
                if !other.fetch.isEmpty {
                    builderResult.fetch += other.fetch
                }
                if !other.target.isEmpty {
                    builderResult.target += other.target
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.PartialRunSetupRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.PartialRunSetupRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        sessionHandle = try codedInputStream.readString()

                    case 18:
                        feed += [try codedInputStream.readString()]

                    case 26:
                        fetch += [try codedInputStream.readString()]

                    case 34:
                        target += [try codedInputStream.readString()]

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.PartialRunSetupRequest.Builder {
                let resultDecodedBuilder = Tensorflow.PartialRunSetupRequest.Builder()
                if let jsonValueSessionHandle = jsonMap["sessionHandle"] as? String {
                    resultDecodedBuilder.sessionHandle = jsonValueSessionHandle
                }
                if let jsonValueFeed = jsonMap["feed"] as? Array<String> {
                    var jsonArrayFeed:Array<String> = []
                    for oneValueFeed in jsonValueFeed {
                        jsonArrayFeed.append(oneValueFeed)
                    }
                    resultDecodedBuilder.feed = jsonArrayFeed
                }
                if let jsonValueFetch = jsonMap["fetch"] as? Array<String> {
                    var jsonArrayFetch:Array<String> = []
                    for oneValueFetch in jsonValueFetch {
                        jsonArrayFetch.append(oneValueFetch)
                    }
                    resultDecodedBuilder.fetch = jsonArrayFetch
                }
                if let jsonValueTarget = jsonMap["target"] as? Array<String> {
                    var jsonArrayTarget:Array<String> = []
                    for oneValueTarget in jsonValueTarget {
                        jsonArrayTarget.append(oneValueTarget)
                    }
                    resultDecodedBuilder.target = jsonArrayTarget
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.PartialRunSetupRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.PartialRunSetupRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class PartialRunSetupResponse : GeneratedMessage {

        public static func == (lhs: Tensorflow.PartialRunSetupResponse, rhs: Tensorflow.PartialRunSetupResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasPartialRunHandle == rhs.hasPartialRunHandle) && (!lhs.hasPartialRunHandle || lhs.partialRunHandle == rhs.partialRunHandle)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// The unique handle corresponding to the ongoing partial run call setup by
        /// the invocation to PartialRunSetup. This handle may be passed to
        /// RunStepRequest to send and receive tensors for this partial run.
        public fileprivate(set) var partialRunHandle:String = ""
        public fileprivate(set) var hasPartialRunHandle:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasPartialRunHandle {
                try codedOutputStream.writeString(fieldNumber: 1, value:partialRunHandle)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasPartialRunHandle {
                serialize_size += partialRunHandle.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.PartialRunSetupResponse.Builder {
            return Tensorflow.PartialRunSetupResponse.classBuilder() as! Tensorflow.PartialRunSetupResponse.Builder
        }
        public func getBuilder() -> Tensorflow.PartialRunSetupResponse.Builder {
            return classBuilder() as! Tensorflow.PartialRunSetupResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.PartialRunSetupResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.PartialRunSetupResponse.Builder()
        }
        public func toBuilder() throws -> Tensorflow.PartialRunSetupResponse.Builder {
            return try Tensorflow.PartialRunSetupResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.PartialRunSetupResponse) throws -> Tensorflow.PartialRunSetupResponse.Builder {
            return try Tensorflow.PartialRunSetupResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasPartialRunHandle {
                jsonMap["partialRunHandle"] = partialRunHandle
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.PartialRunSetupResponse {
            return try Tensorflow.PartialRunSetupResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.PartialRunSetupResponse {
            return try Tensorflow.PartialRunSetupResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasPartialRunHandle {
                output += "\(indent) partialRunHandle: \(partialRunHandle) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasPartialRunHandle {
                    hashCode = (hashCode &* 31) &+ partialRunHandle.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.PartialRunSetupResponse"
        }
        override public func className() -> String {
            return "Tensorflow.PartialRunSetupResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.PartialRunSetupResponse = Tensorflow.PartialRunSetupResponse()
            public func getMessage() -> Tensorflow.PartialRunSetupResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The unique handle corresponding to the ongoing partial run call setup by
            /// the invocation to PartialRunSetup. This handle may be passed to
            /// RunStepRequest to send and receive tensors for this partial run.
            public var partialRunHandle:String {
                get {
                    return builderResult.partialRunHandle
                }
                set (value) {
                    builderResult.hasPartialRunHandle = true
                    builderResult.partialRunHandle = value
                }
            }
            public var hasPartialRunHandle:Bool {
                get {
                    return builderResult.hasPartialRunHandle
                }
            }
            @discardableResult
            public func setPartialRunHandle(_ value:String) -> Tensorflow.PartialRunSetupResponse.Builder {
                self.partialRunHandle = value
                return self
            }
            @discardableResult
            public func clearPartialRunHandle() -> Tensorflow.PartialRunSetupResponse.Builder{
                builderResult.hasPartialRunHandle = false
                builderResult.partialRunHandle = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.PartialRunSetupResponse.Builder {
                builderResult = Tensorflow.PartialRunSetupResponse()
                return self
            }
            override public func clone() throws -> Tensorflow.PartialRunSetupResponse.Builder {
                return try Tensorflow.PartialRunSetupResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.PartialRunSetupResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.PartialRunSetupResponse {
                let returnMe:Tensorflow.PartialRunSetupResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.PartialRunSetupResponse) throws -> Tensorflow.PartialRunSetupResponse.Builder {
                if other == Tensorflow.PartialRunSetupResponse() {
                    return self
                }
                if other.hasPartialRunHandle {
                    partialRunHandle = other.partialRunHandle
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.PartialRunSetupResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.PartialRunSetupResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        partialRunHandle = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.PartialRunSetupResponse.Builder {
                let resultDecodedBuilder = Tensorflow.PartialRunSetupResponse.Builder()
                if let jsonValuePartialRunHandle = jsonMap["partialRunHandle"] as? String {
                    resultDecodedBuilder.partialRunHandle = jsonValuePartialRunHandle
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.PartialRunSetupResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.PartialRunSetupResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class CloseSessionRequest : GeneratedMessage {

        public static func == (lhs: Tensorflow.CloseSessionRequest, rhs: Tensorflow.CloseSessionRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasSessionHandle == rhs.hasSessionHandle) && (!lhs.hasSessionHandle || lhs.sessionHandle == rhs.sessionHandle)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// REQUIRED: session_handle must be returned by a CreateSession call
        /// to the same master service.
        public fileprivate(set) var sessionHandle:String = ""
        public fileprivate(set) var hasSessionHandle:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasSessionHandle {
                try codedOutputStream.writeString(fieldNumber: 1, value:sessionHandle)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasSessionHandle {
                serialize_size += sessionHandle.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.CloseSessionRequest.Builder {
            return Tensorflow.CloseSessionRequest.classBuilder() as! Tensorflow.CloseSessionRequest.Builder
        }
        public func getBuilder() -> Tensorflow.CloseSessionRequest.Builder {
            return classBuilder() as! Tensorflow.CloseSessionRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.CloseSessionRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.CloseSessionRequest.Builder()
        }
        public func toBuilder() throws -> Tensorflow.CloseSessionRequest.Builder {
            return try Tensorflow.CloseSessionRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.CloseSessionRequest) throws -> Tensorflow.CloseSessionRequest.Builder {
            return try Tensorflow.CloseSessionRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasSessionHandle {
                jsonMap["sessionHandle"] = sessionHandle
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CloseSessionRequest {
            return try Tensorflow.CloseSessionRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.CloseSessionRequest {
            return try Tensorflow.CloseSessionRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasSessionHandle {
                output += "\(indent) sessionHandle: \(sessionHandle) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasSessionHandle {
                    hashCode = (hashCode &* 31) &+ sessionHandle.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.CloseSessionRequest"
        }
        override public func className() -> String {
            return "Tensorflow.CloseSessionRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.CloseSessionRequest = Tensorflow.CloseSessionRequest()
            public func getMessage() -> Tensorflow.CloseSessionRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// REQUIRED: session_handle must be returned by a CreateSession call
            /// to the same master service.
            public var sessionHandle:String {
                get {
                    return builderResult.sessionHandle
                }
                set (value) {
                    builderResult.hasSessionHandle = true
                    builderResult.sessionHandle = value
                }
            }
            public var hasSessionHandle:Bool {
                get {
                    return builderResult.hasSessionHandle
                }
            }
            @discardableResult
            public func setSessionHandle(_ value:String) -> Tensorflow.CloseSessionRequest.Builder {
                self.sessionHandle = value
                return self
            }
            @discardableResult
            public func clearSessionHandle() -> Tensorflow.CloseSessionRequest.Builder{
                builderResult.hasSessionHandle = false
                builderResult.sessionHandle = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.CloseSessionRequest.Builder {
                builderResult = Tensorflow.CloseSessionRequest()
                return self
            }
            override public func clone() throws -> Tensorflow.CloseSessionRequest.Builder {
                return try Tensorflow.CloseSessionRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.CloseSessionRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.CloseSessionRequest {
                let returnMe:Tensorflow.CloseSessionRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.CloseSessionRequest) throws -> Tensorflow.CloseSessionRequest.Builder {
                if other == Tensorflow.CloseSessionRequest() {
                    return self
                }
                if other.hasSessionHandle {
                    sessionHandle = other.sessionHandle
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CloseSessionRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CloseSessionRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        sessionHandle = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CloseSessionRequest.Builder {
                let resultDecodedBuilder = Tensorflow.CloseSessionRequest.Builder()
                if let jsonValueSessionHandle = jsonMap["sessionHandle"] as? String {
                    resultDecodedBuilder.sessionHandle = jsonValueSessionHandle
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.CloseSessionRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.CloseSessionRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class CloseSessionResponse : GeneratedMessage {

        public static func == (lhs: Tensorflow.CloseSessionResponse, rhs: Tensorflow.CloseSessionResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.CloseSessionResponse.Builder {
            return Tensorflow.CloseSessionResponse.classBuilder() as! Tensorflow.CloseSessionResponse.Builder
        }
        public func getBuilder() -> Tensorflow.CloseSessionResponse.Builder {
            return classBuilder() as! Tensorflow.CloseSessionResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.CloseSessionResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.CloseSessionResponse.Builder()
        }
        public func toBuilder() throws -> Tensorflow.CloseSessionResponse.Builder {
            return try Tensorflow.CloseSessionResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.CloseSessionResponse) throws -> Tensorflow.CloseSessionResponse.Builder {
            return try Tensorflow.CloseSessionResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CloseSessionResponse {
            return try Tensorflow.CloseSessionResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.CloseSessionResponse {
            return try Tensorflow.CloseSessionResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.CloseSessionResponse"
        }
        override public func className() -> String {
            return "Tensorflow.CloseSessionResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.CloseSessionResponse = Tensorflow.CloseSessionResponse()
            public func getMessage() -> Tensorflow.CloseSessionResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.CloseSessionResponse.Builder {
                builderResult = Tensorflow.CloseSessionResponse()
                return self
            }
            override public func clone() throws -> Tensorflow.CloseSessionResponse.Builder {
                return try Tensorflow.CloseSessionResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.CloseSessionResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.CloseSessionResponse {
                let returnMe:Tensorflow.CloseSessionResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.CloseSessionResponse) throws -> Tensorflow.CloseSessionResponse.Builder {
                if other == Tensorflow.CloseSessionResponse() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CloseSessionResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CloseSessionResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CloseSessionResponse.Builder {
                let resultDecodedBuilder = Tensorflow.CloseSessionResponse.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.CloseSessionResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.CloseSessionResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Reset() allows misbehaving or slow sessions to be aborted and closed, and
    /// causes their resources eventually to be released.  Reset() does not wait
    /// for the computations in old sessions to cease; it merely starts the
    /// process of tearing them down.  However, if a new session is started after
    /// a Reset(), the new session is isolated from changes that old sessions
    /// (started prior to the Reset()) may continue to make to resources, provided
    /// all those resources are in containers listed in "containers".
    /// Old sessions may continue to have side-effects on resources not in
    /// containers listed in "containers", and thus may affect future
    /// sessions' results in ways that are hard to predict.  Thus, if well-defined
    /// behaviour is desired, is it recommended that all containers be listed in
    /// "containers".  Similarly, if a device_filter is specified, results may be
    /// hard to predict.
    final public class ResetRequest : GeneratedMessage {

        public static func == (lhs: Tensorflow.ResetRequest, rhs: Tensorflow.ResetRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.container == rhs.container)
            fieldCheck = fieldCheck && (lhs.deviceFilters == rhs.deviceFilters)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// A list of container names, which may be empty.
        /// If 'container' is not empty, releases resoures in the given
        /// containers in all devices.
        /// If 'container' is empty, releases resources in the default
        /// container in all devices.
        public fileprivate(set) var container:Array<String> = Array<String>()
        /// When any filters are present, only devices that match the filters
        /// will be reset. Each filter can be partially specified,
        /// e.g. "/job:ps" "/job:worker/replica:3", etc.
        public fileprivate(set) var deviceFilters:Array<String> = Array<String>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if !container.isEmpty {
                for oneValuecontainer in container {
                    try codedOutputStream.writeString(fieldNumber: 1, value:oneValuecontainer)
                }
            }
            if !deviceFilters.isEmpty {
                for oneValuedeviceFilters in deviceFilters {
                    try codedOutputStream.writeString(fieldNumber: 2, value:oneValuedeviceFilters)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            var dataSizeContainer:Int32 = 0
            for oneValuecontainer in container {
                dataSizeContainer += oneValuecontainer.computeStringSizeNoTag()
            }
            serialize_size += dataSizeContainer
            serialize_size += 1 * Int32(container.count)
            var dataSizeDeviceFilters:Int32 = 0
            for oneValuedeviceFilters in deviceFilters {
                dataSizeDeviceFilters += oneValuedeviceFilters.computeStringSizeNoTag()
            }
            serialize_size += dataSizeDeviceFilters
            serialize_size += 1 * Int32(deviceFilters.count)
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.ResetRequest.Builder {
            return Tensorflow.ResetRequest.classBuilder() as! Tensorflow.ResetRequest.Builder
        }
        public func getBuilder() -> Tensorflow.ResetRequest.Builder {
            return classBuilder() as! Tensorflow.ResetRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.ResetRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.ResetRequest.Builder()
        }
        public func toBuilder() throws -> Tensorflow.ResetRequest.Builder {
            return try Tensorflow.ResetRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.ResetRequest) throws -> Tensorflow.ResetRequest.Builder {
            return try Tensorflow.ResetRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !container.isEmpty {
                var jsonArrayContainer:Array<String> = []
                for oneValueContainer in container {
                    jsonArrayContainer.append(oneValueContainer)
                }
                jsonMap["container"] = jsonArrayContainer
            }
            if !deviceFilters.isEmpty {
                var jsonArrayDeviceFilters:Array<String> = []
                for oneValueDeviceFilters in deviceFilters {
                    jsonArrayDeviceFilters.append(oneValueDeviceFilters)
                }
                jsonMap["deviceFilters"] = jsonArrayDeviceFilters
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.ResetRequest {
            return try Tensorflow.ResetRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.ResetRequest {
            return try Tensorflow.ResetRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var containerElementIndex:Int = 0
            for oneValueContainer in container  {
                output += "\(indent) container[\(containerElementIndex)]: \(oneValueContainer)\n"
                containerElementIndex += 1
            }
            var deviceFiltersElementIndex:Int = 0
            for oneValueDeviceFilters in deviceFilters  {
                output += "\(indent) deviceFilters[\(deviceFiltersElementIndex)]: \(oneValueDeviceFilters)\n"
                deviceFiltersElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneValueContainer in container {
                    hashCode = (hashCode &* 31) &+ oneValueContainer.hashValue
                }
                for oneValueDeviceFilters in deviceFilters {
                    hashCode = (hashCode &* 31) &+ oneValueDeviceFilters.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.ResetRequest"
        }
        override public func className() -> String {
            return "Tensorflow.ResetRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.ResetRequest = Tensorflow.ResetRequest()
            public func getMessage() -> Tensorflow.ResetRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// A list of container names, which may be empty.
            /// If 'container' is not empty, releases resoures in the given
            /// containers in all devices.
            /// If 'container' is empty, releases resources in the default
            /// container in all devices.
            public var container:Array<String> {
                get {
                    return builderResult.container
                }
                set (array) {
                    builderResult.container = array
                }
            }
            @discardableResult
            public func setContainer(_ value:Array<String>) -> Tensorflow.ResetRequest.Builder {
                self.container = value
                return self
            }
            @discardableResult
            public func clearContainer() -> Tensorflow.ResetRequest.Builder {
                builderResult.container.removeAll(keepingCapacity: false)
                return self
            }
            /// When any filters are present, only devices that match the filters
            /// will be reset. Each filter can be partially specified,
            /// e.g. "/job:ps" "/job:worker/replica:3", etc.
            public var deviceFilters:Array<String> {
                get {
                    return builderResult.deviceFilters
                }
                set (array) {
                    builderResult.deviceFilters = array
                }
            }
            @discardableResult
            public func setDeviceFilters(_ value:Array<String>) -> Tensorflow.ResetRequest.Builder {
                self.deviceFilters = value
                return self
            }
            @discardableResult
            public func clearDeviceFilters() -> Tensorflow.ResetRequest.Builder {
                builderResult.deviceFilters.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.ResetRequest.Builder {
                builderResult = Tensorflow.ResetRequest()
                return self
            }
            override public func clone() throws -> Tensorflow.ResetRequest.Builder {
                return try Tensorflow.ResetRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.ResetRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.ResetRequest {
                let returnMe:Tensorflow.ResetRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.ResetRequest) throws -> Tensorflow.ResetRequest.Builder {
                if other == Tensorflow.ResetRequest() {
                    return self
                }
                if !other.container.isEmpty {
                    builderResult.container += other.container
                }
                if !other.deviceFilters.isEmpty {
                    builderResult.deviceFilters += other.deviceFilters
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.ResetRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ResetRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        container += [try codedInputStream.readString()]

                    case 18:
                        deviceFilters += [try codedInputStream.readString()]

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.ResetRequest.Builder {
                let resultDecodedBuilder = Tensorflow.ResetRequest.Builder()
                if let jsonValueContainer = jsonMap["container"] as? Array<String> {
                    var jsonArrayContainer:Array<String> = []
                    for oneValueContainer in jsonValueContainer {
                        jsonArrayContainer.append(oneValueContainer)
                    }
                    resultDecodedBuilder.container = jsonArrayContainer
                }
                if let jsonValueDeviceFilters = jsonMap["deviceFilters"] as? Array<String> {
                    var jsonArrayDeviceFilters:Array<String> = []
                    for oneValueDeviceFilters in jsonValueDeviceFilters {
                        jsonArrayDeviceFilters.append(oneValueDeviceFilters)
                    }
                    resultDecodedBuilder.deviceFilters = jsonArrayDeviceFilters
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.ResetRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.ResetRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ResetResponse : GeneratedMessage {

        public static func == (lhs: Tensorflow.ResetResponse, rhs: Tensorflow.ResetResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.ResetResponse.Builder {
            return Tensorflow.ResetResponse.classBuilder() as! Tensorflow.ResetResponse.Builder
        }
        public func getBuilder() -> Tensorflow.ResetResponse.Builder {
            return classBuilder() as! Tensorflow.ResetResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.ResetResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.ResetResponse.Builder()
        }
        public func toBuilder() throws -> Tensorflow.ResetResponse.Builder {
            return try Tensorflow.ResetResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.ResetResponse) throws -> Tensorflow.ResetResponse.Builder {
            return try Tensorflow.ResetResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.ResetResponse {
            return try Tensorflow.ResetResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.ResetResponse {
            return try Tensorflow.ResetResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.ResetResponse"
        }
        override public func className() -> String {
            return "Tensorflow.ResetResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.ResetResponse = Tensorflow.ResetResponse()
            public func getMessage() -> Tensorflow.ResetResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.ResetResponse.Builder {
                builderResult = Tensorflow.ResetResponse()
                return self
            }
            override public func clone() throws -> Tensorflow.ResetResponse.Builder {
                return try Tensorflow.ResetResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.ResetResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.ResetResponse {
                let returnMe:Tensorflow.ResetResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.ResetResponse) throws -> Tensorflow.ResetResponse.Builder {
                if other == Tensorflow.ResetResponse() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.ResetResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ResetResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.ResetResponse.Builder {
                let resultDecodedBuilder = Tensorflow.ResetResponse.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.ResetResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.ResetResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ListDevicesRequest : GeneratedMessage {

        public static func == (lhs: Tensorflow.ListDevicesRequest, rhs: Tensorflow.ListDevicesRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.ListDevicesRequest.Builder {
            return Tensorflow.ListDevicesRequest.classBuilder() as! Tensorflow.ListDevicesRequest.Builder
        }
        public func getBuilder() -> Tensorflow.ListDevicesRequest.Builder {
            return classBuilder() as! Tensorflow.ListDevicesRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.ListDevicesRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.ListDevicesRequest.Builder()
        }
        public func toBuilder() throws -> Tensorflow.ListDevicesRequest.Builder {
            return try Tensorflow.ListDevicesRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.ListDevicesRequest) throws -> Tensorflow.ListDevicesRequest.Builder {
            return try Tensorflow.ListDevicesRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.ListDevicesRequest {
            return try Tensorflow.ListDevicesRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.ListDevicesRequest {
            return try Tensorflow.ListDevicesRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.ListDevicesRequest"
        }
        override public func className() -> String {
            return "Tensorflow.ListDevicesRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.ListDevicesRequest = Tensorflow.ListDevicesRequest()
            public func getMessage() -> Tensorflow.ListDevicesRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.ListDevicesRequest.Builder {
                builderResult = Tensorflow.ListDevicesRequest()
                return self
            }
            override public func clone() throws -> Tensorflow.ListDevicesRequest.Builder {
                return try Tensorflow.ListDevicesRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.ListDevicesRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.ListDevicesRequest {
                let returnMe:Tensorflow.ListDevicesRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.ListDevicesRequest) throws -> Tensorflow.ListDevicesRequest.Builder {
                if other == Tensorflow.ListDevicesRequest() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.ListDevicesRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ListDevicesRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.ListDevicesRequest.Builder {
                let resultDecodedBuilder = Tensorflow.ListDevicesRequest.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.ListDevicesRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.ListDevicesRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ListDevicesResponse : GeneratedMessage {

        public static func == (lhs: Tensorflow.ListDevicesResponse, rhs: Tensorflow.ListDevicesResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.localDevice == rhs.localDevice)
            fieldCheck = fieldCheck && (lhs.remoteDevice == rhs.remoteDevice)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var localDevice:Array<Tensorflow.DeviceAttributes>  = Array<Tensorflow.DeviceAttributes>()
        public fileprivate(set) var remoteDevice:Array<Tensorflow.DeviceAttributes>  = Array<Tensorflow.DeviceAttributes>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementLocalDevice in localDevice {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementLocalDevice)
            }
            for oneElementRemoteDevice in remoteDevice {
                  try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementRemoteDevice)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementLocalDevice in localDevice {
                serialize_size += oneElementLocalDevice.computeMessageSize(fieldNumber: 1)
            }
            for oneElementRemoteDevice in remoteDevice {
                serialize_size += oneElementRemoteDevice.computeMessageSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.ListDevicesResponse.Builder {
            return Tensorflow.ListDevicesResponse.classBuilder() as! Tensorflow.ListDevicesResponse.Builder
        }
        public func getBuilder() -> Tensorflow.ListDevicesResponse.Builder {
            return classBuilder() as! Tensorflow.ListDevicesResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.ListDevicesResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.ListDevicesResponse.Builder()
        }
        public func toBuilder() throws -> Tensorflow.ListDevicesResponse.Builder {
            return try Tensorflow.ListDevicesResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.ListDevicesResponse) throws -> Tensorflow.ListDevicesResponse.Builder {
            return try Tensorflow.ListDevicesResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !localDevice.isEmpty {
                var jsonArrayLocalDevice:Array<Dictionary<String,Any>> = []
                for oneValueLocalDevice in localDevice {
                    let ecodedMessageLocalDevice = try oneValueLocalDevice.encode()
                    jsonArrayLocalDevice.append(ecodedMessageLocalDevice)
                }
                jsonMap["localDevice"] = jsonArrayLocalDevice
            }
            if !remoteDevice.isEmpty {
                var jsonArrayRemoteDevice:Array<Dictionary<String,Any>> = []
                for oneValueRemoteDevice in remoteDevice {
                    let ecodedMessageRemoteDevice = try oneValueRemoteDevice.encode()
                    jsonArrayRemoteDevice.append(ecodedMessageRemoteDevice)
                }
                jsonMap["remoteDevice"] = jsonArrayRemoteDevice
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.ListDevicesResponse {
            return try Tensorflow.ListDevicesResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.ListDevicesResponse {
            return try Tensorflow.ListDevicesResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var localDeviceElementIndex:Int = 0
            for oneElementLocalDevice in localDevice {
                output += "\(indent) localDevice[\(localDeviceElementIndex)] {\n"
                output += try oneElementLocalDevice.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                localDeviceElementIndex += 1
            }
            var remoteDeviceElementIndex:Int = 0
            for oneElementRemoteDevice in remoteDevice {
                output += "\(indent) remoteDevice[\(remoteDeviceElementIndex)] {\n"
                output += try oneElementRemoteDevice.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                remoteDeviceElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementLocalDevice in localDevice {
                    hashCode = (hashCode &* 31) &+ oneElementLocalDevice.hashValue
                }
                for oneElementRemoteDevice in remoteDevice {
                    hashCode = (hashCode &* 31) &+ oneElementRemoteDevice.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.ListDevicesResponse"
        }
        override public func className() -> String {
            return "Tensorflow.ListDevicesResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.ListDevicesResponse = Tensorflow.ListDevicesResponse()
            public func getMessage() -> Tensorflow.ListDevicesResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var localDevice:Array<Tensorflow.DeviceAttributes> {
                get {
                    return builderResult.localDevice
                }
                set (value) {
                    builderResult.localDevice = value
                }
            }
            @discardableResult
            public func setLocalDevice(_ value:Array<Tensorflow.DeviceAttributes>) -> Tensorflow.ListDevicesResponse.Builder {
                self.localDevice = value
                return self
            }
            @discardableResult
            public func clearLocalDevice() -> Tensorflow.ListDevicesResponse.Builder {
                builderResult.localDevice.removeAll(keepingCapacity: false)
                return self
            }
            public var remoteDevice:Array<Tensorflow.DeviceAttributes> {
                get {
                    return builderResult.remoteDevice
                }
                set (value) {
                    builderResult.remoteDevice = value
                }
            }
            @discardableResult
            public func setRemoteDevice(_ value:Array<Tensorflow.DeviceAttributes>) -> Tensorflow.ListDevicesResponse.Builder {
                self.remoteDevice = value
                return self
            }
            @discardableResult
            public func clearRemoteDevice() -> Tensorflow.ListDevicesResponse.Builder {
                builderResult.remoteDevice.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.ListDevicesResponse.Builder {
                builderResult = Tensorflow.ListDevicesResponse()
                return self
            }
            override public func clone() throws -> Tensorflow.ListDevicesResponse.Builder {
                return try Tensorflow.ListDevicesResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.ListDevicesResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.ListDevicesResponse {
                let returnMe:Tensorflow.ListDevicesResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.ListDevicesResponse) throws -> Tensorflow.ListDevicesResponse.Builder {
                if other == Tensorflow.ListDevicesResponse() {
                    return self
                }
                if !other.localDevice.isEmpty  {
                     builderResult.localDevice += other.localDevice
                }
                if !other.remoteDevice.isEmpty  {
                     builderResult.remoteDevice += other.remoteDevice
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.ListDevicesResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ListDevicesResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Tensorflow.DeviceAttributes.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        localDevice.append(subBuilder.buildPartial())

                    case 18:
                        let subBuilder = Tensorflow.DeviceAttributes.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        remoteDevice.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.ListDevicesResponse.Builder {
                let resultDecodedBuilder = Tensorflow.ListDevicesResponse.Builder()
                if let jsonValueLocalDevice = jsonMap["localDevice"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayLocalDevice:Array<Tensorflow.DeviceAttributes> = []
                    for oneValueLocalDevice in jsonValueLocalDevice {
                        let messageFromStringLocalDevice = try Tensorflow.DeviceAttributes.Builder.decodeToBuilder(jsonMap:oneValueLocalDevice).build()

                        jsonArrayLocalDevice.append(messageFromStringLocalDevice)
                    }
                    resultDecodedBuilder.localDevice = jsonArrayLocalDevice
                }
                if let jsonValueRemoteDevice = jsonMap["remoteDevice"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayRemoteDevice:Array<Tensorflow.DeviceAttributes> = []
                    for oneValueRemoteDevice in jsonValueRemoteDevice {
                        let messageFromStringRemoteDevice = try Tensorflow.DeviceAttributes.Builder.decodeToBuilder(jsonMap:oneValueRemoteDevice).build()

                        jsonArrayRemoteDevice.append(messageFromStringRemoteDevice)
                    }
                    resultDecodedBuilder.remoteDevice = jsonArrayRemoteDevice
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.ListDevicesResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.ListDevicesResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.CreateSessionRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.CreateSessionRequest> {
        var mergedArray = Array<Tensorflow.CreateSessionRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.CreateSessionRequest? {
        return try Tensorflow.CreateSessionRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.CreateSessionRequest {
        return try Tensorflow.CreateSessionRequest.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.MasterRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CreateSessionRequest {
        return try Tensorflow.CreateSessionRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.CreateSessionRequest {
        return try Tensorflow.CreateSessionRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CreateSessionRequest {
        return try Tensorflow.CreateSessionRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CreateSessionRequest {
        return try Tensorflow.CreateSessionRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CreateSessionRequest {
        return try Tensorflow.CreateSessionRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "graphDef": return self.graphDef
        case "config": return self.config
        default: return nil
        }
    }
}
extension Tensorflow.CreateSessionRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "graphDef": return self.graphDef
            case "config": return self.config
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "graphDef":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.GraphDef else {
                    return
                }
                self.graphDef = newSubscriptValue
            case "config":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.ConfigProto else {
                    return
                }
                self.config = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.CreateSessionResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.CreateSessionResponse> {
        var mergedArray = Array<Tensorflow.CreateSessionResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.CreateSessionResponse? {
        return try Tensorflow.CreateSessionResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.CreateSessionResponse {
        return try Tensorflow.CreateSessionResponse.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.MasterRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CreateSessionResponse {
        return try Tensorflow.CreateSessionResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.CreateSessionResponse {
        return try Tensorflow.CreateSessionResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CreateSessionResponse {
        return try Tensorflow.CreateSessionResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CreateSessionResponse {
        return try Tensorflow.CreateSessionResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CreateSessionResponse {
        return try Tensorflow.CreateSessionResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "sessionHandle": return self.sessionHandle
        case "graphVersion": return self.graphVersion
        default: return nil
        }
    }
}
extension Tensorflow.CreateSessionResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "sessionHandle": return self.sessionHandle
            case "graphVersion": return self.graphVersion
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "sessionHandle":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.sessionHandle = newSubscriptValue
            case "graphVersion":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.graphVersion = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.ExtendSessionRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.ExtendSessionRequest> {
        var mergedArray = Array<Tensorflow.ExtendSessionRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.ExtendSessionRequest? {
        return try Tensorflow.ExtendSessionRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.ExtendSessionRequest {
        return try Tensorflow.ExtendSessionRequest.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.MasterRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ExtendSessionRequest {
        return try Tensorflow.ExtendSessionRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.ExtendSessionRequest {
        return try Tensorflow.ExtendSessionRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ExtendSessionRequest {
        return try Tensorflow.ExtendSessionRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.ExtendSessionRequest {
        return try Tensorflow.ExtendSessionRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ExtendSessionRequest {
        return try Tensorflow.ExtendSessionRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "sessionHandle": return self.sessionHandle
        case "graphDef": return self.graphDef
        case "currentGraphVersion": return self.currentGraphVersion
        default: return nil
        }
    }
}
extension Tensorflow.ExtendSessionRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "sessionHandle": return self.sessionHandle
            case "graphDef": return self.graphDef
            case "currentGraphVersion": return self.currentGraphVersion
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "sessionHandle":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.sessionHandle = newSubscriptValue
            case "graphDef":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.GraphDef else {
                    return
                }
                self.graphDef = newSubscriptValue
            case "currentGraphVersion":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.currentGraphVersion = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.ExtendSessionResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.ExtendSessionResponse> {
        var mergedArray = Array<Tensorflow.ExtendSessionResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.ExtendSessionResponse? {
        return try Tensorflow.ExtendSessionResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.ExtendSessionResponse {
        return try Tensorflow.ExtendSessionResponse.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.MasterRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ExtendSessionResponse {
        return try Tensorflow.ExtendSessionResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.ExtendSessionResponse {
        return try Tensorflow.ExtendSessionResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ExtendSessionResponse {
        return try Tensorflow.ExtendSessionResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.ExtendSessionResponse {
        return try Tensorflow.ExtendSessionResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ExtendSessionResponse {
        return try Tensorflow.ExtendSessionResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "newGraphVersion": return self.newGraphVersion
        default: return nil
        }
    }
}
extension Tensorflow.ExtendSessionResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "newGraphVersion": return self.newGraphVersion
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "newGraphVersion":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.newGraphVersion = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.RunStepRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.RunStepRequest> {
        var mergedArray = Array<Tensorflow.RunStepRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.RunStepRequest? {
        return try Tensorflow.RunStepRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.RunStepRequest {
        return try Tensorflow.RunStepRequest.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.MasterRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RunStepRequest {
        return try Tensorflow.RunStepRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.RunStepRequest {
        return try Tensorflow.RunStepRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RunStepRequest {
        return try Tensorflow.RunStepRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.RunStepRequest {
        return try Tensorflow.RunStepRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RunStepRequest {
        return try Tensorflow.RunStepRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "sessionHandle": return self.sessionHandle
        case "feed": return self.feed
        case "fetch": return self.fetch
        case "target": return self.target
        case "options": return self.options
        case "partialRunHandle": return self.partialRunHandle
        default: return nil
        }
    }
}
extension Tensorflow.RunStepRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "sessionHandle": return self.sessionHandle
            case "feed": return self.feed
            case "fetch": return self.fetch
            case "target": return self.target
            case "options": return self.options
            case "partialRunHandle": return self.partialRunHandle
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "sessionHandle":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.sessionHandle = newSubscriptValue
            case "feed":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.NamedTensorProto> else {
                    return
                }
                self.feed = newSubscriptValue
            case "fetch":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.fetch = newSubscriptValue
            case "target":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.target = newSubscriptValue
            case "options":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.RunOptions else {
                    return
                }
                self.options = newSubscriptValue
            case "partialRunHandle":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.partialRunHandle = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.RunStepResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.RunStepResponse> {
        var mergedArray = Array<Tensorflow.RunStepResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.RunStepResponse? {
        return try Tensorflow.RunStepResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.RunStepResponse {
        return try Tensorflow.RunStepResponse.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.MasterRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RunStepResponse {
        return try Tensorflow.RunStepResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.RunStepResponse {
        return try Tensorflow.RunStepResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RunStepResponse {
        return try Tensorflow.RunStepResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.RunStepResponse {
        return try Tensorflow.RunStepResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RunStepResponse {
        return try Tensorflow.RunStepResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "tensor": return self.tensor
        case "metadata": return self.metadata
        default: return nil
        }
    }
}
extension Tensorflow.RunStepResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "tensor": return self.tensor
            case "metadata": return self.metadata
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "tensor":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.NamedTensorProto> else {
                    return
                }
                self.tensor = newSubscriptValue
            case "metadata":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.RunMetadata else {
                    return
                }
                self.metadata = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.PartialRunSetupRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.PartialRunSetupRequest> {
        var mergedArray = Array<Tensorflow.PartialRunSetupRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.PartialRunSetupRequest? {
        return try Tensorflow.PartialRunSetupRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.PartialRunSetupRequest {
        return try Tensorflow.PartialRunSetupRequest.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.MasterRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.PartialRunSetupRequest {
        return try Tensorflow.PartialRunSetupRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.PartialRunSetupRequest {
        return try Tensorflow.PartialRunSetupRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.PartialRunSetupRequest {
        return try Tensorflow.PartialRunSetupRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.PartialRunSetupRequest {
        return try Tensorflow.PartialRunSetupRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.PartialRunSetupRequest {
        return try Tensorflow.PartialRunSetupRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "sessionHandle": return self.sessionHandle
        case "feed": return self.feed
        case "fetch": return self.fetch
        case "target": return self.target
        default: return nil
        }
    }
}
extension Tensorflow.PartialRunSetupRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "sessionHandle": return self.sessionHandle
            case "feed": return self.feed
            case "fetch": return self.fetch
            case "target": return self.target
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "sessionHandle":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.sessionHandle = newSubscriptValue
            case "feed":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.feed = newSubscriptValue
            case "fetch":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.fetch = newSubscriptValue
            case "target":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.target = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.PartialRunSetupResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.PartialRunSetupResponse> {
        var mergedArray = Array<Tensorflow.PartialRunSetupResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.PartialRunSetupResponse? {
        return try Tensorflow.PartialRunSetupResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.PartialRunSetupResponse {
        return try Tensorflow.PartialRunSetupResponse.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.MasterRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.PartialRunSetupResponse {
        return try Tensorflow.PartialRunSetupResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.PartialRunSetupResponse {
        return try Tensorflow.PartialRunSetupResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.PartialRunSetupResponse {
        return try Tensorflow.PartialRunSetupResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.PartialRunSetupResponse {
        return try Tensorflow.PartialRunSetupResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.PartialRunSetupResponse {
        return try Tensorflow.PartialRunSetupResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "partialRunHandle": return self.partialRunHandle
        default: return nil
        }
    }
}
extension Tensorflow.PartialRunSetupResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "partialRunHandle": return self.partialRunHandle
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "partialRunHandle":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.partialRunHandle = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.CloseSessionRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.CloseSessionRequest> {
        var mergedArray = Array<Tensorflow.CloseSessionRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.CloseSessionRequest? {
        return try Tensorflow.CloseSessionRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.CloseSessionRequest {
        return try Tensorflow.CloseSessionRequest.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.MasterRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CloseSessionRequest {
        return try Tensorflow.CloseSessionRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.CloseSessionRequest {
        return try Tensorflow.CloseSessionRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CloseSessionRequest {
        return try Tensorflow.CloseSessionRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CloseSessionRequest {
        return try Tensorflow.CloseSessionRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CloseSessionRequest {
        return try Tensorflow.CloseSessionRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "sessionHandle": return self.sessionHandle
        default: return nil
        }
    }
}
extension Tensorflow.CloseSessionRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "sessionHandle": return self.sessionHandle
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "sessionHandle":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.sessionHandle = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.CloseSessionResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.CloseSessionResponse> {
        var mergedArray = Array<Tensorflow.CloseSessionResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.CloseSessionResponse? {
        return try Tensorflow.CloseSessionResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.CloseSessionResponse {
        return try Tensorflow.CloseSessionResponse.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.MasterRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CloseSessionResponse {
        return try Tensorflow.CloseSessionResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.CloseSessionResponse {
        return try Tensorflow.CloseSessionResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CloseSessionResponse {
        return try Tensorflow.CloseSessionResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CloseSessionResponse {
        return try Tensorflow.CloseSessionResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CloseSessionResponse {
        return try Tensorflow.CloseSessionResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Tensorflow.CloseSessionResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Tensorflow.ResetRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.ResetRequest> {
        var mergedArray = Array<Tensorflow.ResetRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.ResetRequest? {
        return try Tensorflow.ResetRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.ResetRequest {
        return try Tensorflow.ResetRequest.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.MasterRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ResetRequest {
        return try Tensorflow.ResetRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.ResetRequest {
        return try Tensorflow.ResetRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ResetRequest {
        return try Tensorflow.ResetRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.ResetRequest {
        return try Tensorflow.ResetRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ResetRequest {
        return try Tensorflow.ResetRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "container": return self.container
        case "deviceFilters": return self.deviceFilters
        default: return nil
        }
    }
}
extension Tensorflow.ResetRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "container": return self.container
            case "deviceFilters": return self.deviceFilters
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "container":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.container = newSubscriptValue
            case "deviceFilters":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.deviceFilters = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.ResetResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.ResetResponse> {
        var mergedArray = Array<Tensorflow.ResetResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.ResetResponse? {
        return try Tensorflow.ResetResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.ResetResponse {
        return try Tensorflow.ResetResponse.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.MasterRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ResetResponse {
        return try Tensorflow.ResetResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.ResetResponse {
        return try Tensorflow.ResetResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ResetResponse {
        return try Tensorflow.ResetResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.ResetResponse {
        return try Tensorflow.ResetResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ResetResponse {
        return try Tensorflow.ResetResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Tensorflow.ResetResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Tensorflow.ListDevicesRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.ListDevicesRequest> {
        var mergedArray = Array<Tensorflow.ListDevicesRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.ListDevicesRequest? {
        return try Tensorflow.ListDevicesRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.ListDevicesRequest {
        return try Tensorflow.ListDevicesRequest.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.MasterRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ListDevicesRequest {
        return try Tensorflow.ListDevicesRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.ListDevicesRequest {
        return try Tensorflow.ListDevicesRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ListDevicesRequest {
        return try Tensorflow.ListDevicesRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.ListDevicesRequest {
        return try Tensorflow.ListDevicesRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ListDevicesRequest {
        return try Tensorflow.ListDevicesRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Tensorflow.ListDevicesRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Tensorflow.ListDevicesResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.ListDevicesResponse> {
        var mergedArray = Array<Tensorflow.ListDevicesResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.ListDevicesResponse? {
        return try Tensorflow.ListDevicesResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.ListDevicesResponse {
        return try Tensorflow.ListDevicesResponse.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.MasterRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ListDevicesResponse {
        return try Tensorflow.ListDevicesResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.ListDevicesResponse {
        return try Tensorflow.ListDevicesResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ListDevicesResponse {
        return try Tensorflow.ListDevicesResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.ListDevicesResponse {
        return try Tensorflow.ListDevicesResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ListDevicesResponse {
        return try Tensorflow.ListDevicesResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "localDevice": return self.localDevice
        case "remoteDevice": return self.remoteDevice
        default: return nil
        }
    }
}
extension Tensorflow.ListDevicesResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "localDevice": return self.localDevice
            case "remoteDevice": return self.remoteDevice
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "localDevice":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.DeviceAttributes> else {
                    return
                }
                self.localDevice = newSubscriptValue
            case "remoteDevice":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.DeviceAttributes> else {
                    return
                }
                self.remoteDevice = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

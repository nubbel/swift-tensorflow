/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "xla.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Xla { }

public extension Xla {
    public struct XlaRoot {
        public static let `default` = XlaRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Xla.XlaDataRoot.default.registerAllExtensions(registry: extensionRegistry)
            Xla.SessionRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    /// These settings control how XLA compiles and/or runs code.  Not all settings
    /// will have an effect on every platform.
    /// When adding new fields, keep in mind that boolean fields default to false.
    final public class ExecutionOptions : GeneratedMessage {

        public static func == (lhs: Xla.ExecutionOptions, rhs: Xla.ExecutionOptions) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasDisableFastMath == rhs.hasDisableFastMath) && (!lhs.hasDisableFastMath || lhs.disableFastMath == rhs.disableFastMath)
            fieldCheck = fieldCheck && (lhs.hasShapeWithOutputLayout == rhs.hasShapeWithOutputLayout) && (!lhs.hasShapeWithOutputLayout || lhs.shapeWithOutputLayout == rhs.shapeWithOutputLayout)
            fieldCheck = fieldCheck && (lhs.hasSeed == rhs.hasSeed) && (!lhs.hasSeed || lhs.seed == rhs.seed)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// When false, "unsafe" mathematical optimizations are enabled.  These
        /// transformations include but are not limited to:
        ///  - Reducing the precision of operations (e.g. using an approximate sin
        ///    function, or transforming x/y into x * (1/y)).
        ///  - Assuming that operations never produce or consume NaN or +/- Inf.
        ///  - Assuming that +0 and -0 are indistinguishable.
        public fileprivate(set) var disableFastMath:Bool = false
        public fileprivate(set) var hasDisableFastMath:Bool = false

        public fileprivate(set) var shapeWithOutputLayout:Xla.Shape!
        public fileprivate(set) var hasShapeWithOutputLayout:Bool = false
        /// Used to seed random-number generators used in this computation.  If this is
        /// 0, we generate a seed ourselves.
        /// TODO(b/32083678): Changing the seed unnecessarily forces a recompilation.
        public fileprivate(set) var seed:UInt64 = UInt64(0)
        public fileprivate(set) var hasSeed:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasDisableFastMath {
                try codedOutputStream.writeBool(fieldNumber: 1, value:disableFastMath)
            }
            if hasShapeWithOutputLayout {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:shapeWithOutputLayout)
            }
            if hasSeed {
                try codedOutputStream.writeUInt64(fieldNumber: 3, value:seed)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasDisableFastMath {
                serialize_size += disableFastMath.computeBoolSize(fieldNumber: 1)
            }
            if hasShapeWithOutputLayout {
                if let varSizeshapeWithOutputLayout = shapeWithOutputLayout?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeshapeWithOutputLayout
                }
            }
            if hasSeed {
                serialize_size += seed.computeUInt64Size(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.ExecutionOptions.Builder {
            return Xla.ExecutionOptions.classBuilder() as! Xla.ExecutionOptions.Builder
        }
        public func getBuilder() -> Xla.ExecutionOptions.Builder {
            return classBuilder() as! Xla.ExecutionOptions.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ExecutionOptions.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ExecutionOptions.Builder()
        }
        public func toBuilder() throws -> Xla.ExecutionOptions.Builder {
            return try Xla.ExecutionOptions.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.ExecutionOptions) throws -> Xla.ExecutionOptions.Builder {
            return try Xla.ExecutionOptions.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasDisableFastMath {
                jsonMap["disableFastMath"] = disableFastMath
            }
            if hasShapeWithOutputLayout {
                jsonMap["shapeWithOutputLayout"] = try shapeWithOutputLayout.encode()
            }
            if hasSeed {
                jsonMap["seed"] = "\(seed)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.ExecutionOptions {
            return try Xla.ExecutionOptions.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.ExecutionOptions {
            return try Xla.ExecutionOptions.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasDisableFastMath {
                output += "\(indent) disableFastMath: \(disableFastMath) \n"
            }
            if hasShapeWithOutputLayout {
                output += "\(indent) shapeWithOutputLayout {\n"
                if let outDescShapeWithOutputLayout = shapeWithOutputLayout {
                    output += try outDescShapeWithOutputLayout.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasSeed {
                output += "\(indent) seed: \(seed) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasDisableFastMath {
                    hashCode = (hashCode &* 31) &+ disableFastMath.hashValue
                }
                if hasShapeWithOutputLayout {
                    if let hashValueshapeWithOutputLayout = shapeWithOutputLayout?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueshapeWithOutputLayout
                    }
                }
                if hasSeed {
                    hashCode = (hashCode &* 31) &+ seed.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.ExecutionOptions"
        }
        override public func className() -> String {
            return "Xla.ExecutionOptions"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.ExecutionOptions = Xla.ExecutionOptions()
            public func getMessage() -> Xla.ExecutionOptions {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// When false, "unsafe" mathematical optimizations are enabled.  These
            /// transformations include but are not limited to:
            ///  - Reducing the precision of operations (e.g. using an approximate sin
            ///    function, or transforming x/y into x * (1/y)).
            ///  - Assuming that operations never produce or consume NaN or +/- Inf.
            ///  - Assuming that +0 and -0 are indistinguishable.
            public var disableFastMath:Bool {
                get {
                    return builderResult.disableFastMath
                }
                set (value) {
                    builderResult.hasDisableFastMath = true
                    builderResult.disableFastMath = value
                }
            }
            public var hasDisableFastMath:Bool {
                get {
                    return builderResult.hasDisableFastMath
                }
            }
            @discardableResult
            public func setDisableFastMath(_ value:Bool) -> Xla.ExecutionOptions.Builder {
                self.disableFastMath = value
                return self
            }
            @discardableResult
            public func clearDisableFastMath() -> Xla.ExecutionOptions.Builder{
                builderResult.hasDisableFastMath = false
                builderResult.disableFastMath = false
                return self
            }
            /// This optional field's layout is used as a hint when storing the output of
            /// this computation.  Subsequent transfers of this output array to the client
            /// may be faster when using this layout.
            /// We use a Shape here to accommodate computations that return a tuple.
            public var shapeWithOutputLayout:Xla.Shape! {
                get {
                    if shapeWithOutputLayoutBuilder_ != nil {
                        builderResult.shapeWithOutputLayout = shapeWithOutputLayoutBuilder_.getMessage()
                    }
                    return builderResult.shapeWithOutputLayout
                }
                set (value) {
                    builderResult.hasShapeWithOutputLayout = true
                    builderResult.shapeWithOutputLayout = value
                }
            }
            public var hasShapeWithOutputLayout:Bool {
                get {
                    return builderResult.hasShapeWithOutputLayout
                }
            }
            fileprivate var shapeWithOutputLayoutBuilder_:Xla.Shape.Builder! {
                didSet {
                    builderResult.hasShapeWithOutputLayout = true
                }
            }
            public func getShapeWithOutputLayoutBuilder() -> Xla.Shape.Builder {
                if shapeWithOutputLayoutBuilder_ == nil {
                    shapeWithOutputLayoutBuilder_ = Xla.Shape.Builder()
                    builderResult.shapeWithOutputLayout = shapeWithOutputLayoutBuilder_.getMessage()
                    if shapeWithOutputLayout != nil {
                        try! shapeWithOutputLayoutBuilder_.mergeFrom(other: shapeWithOutputLayout)
                    }
                }
                return shapeWithOutputLayoutBuilder_
            }
            @discardableResult
            public func setShapeWithOutputLayout(_ value:Xla.Shape!) -> Xla.ExecutionOptions.Builder {
                self.shapeWithOutputLayout = value
                return self
            }
            @discardableResult
            public func mergeShapeWithOutputLayout(value:Xla.Shape) throws -> Xla.ExecutionOptions.Builder {
                if builderResult.hasShapeWithOutputLayout {
                    builderResult.shapeWithOutputLayout = try Xla.Shape.builderWithPrototype(prototype:builderResult.shapeWithOutputLayout).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.shapeWithOutputLayout = value
                }
                builderResult.hasShapeWithOutputLayout = true
                return self
            }
            @discardableResult
            public func clearShapeWithOutputLayout() -> Xla.ExecutionOptions.Builder {
                shapeWithOutputLayoutBuilder_ = nil
                builderResult.hasShapeWithOutputLayout = false
                builderResult.shapeWithOutputLayout = nil
                return self
            }
            /// Used to seed random-number generators used in this computation.  If this is
            /// 0, we generate a seed ourselves.
            /// TODO(b/32083678): Changing the seed unnecessarily forces a recompilation.
            public var seed:UInt64 {
                get {
                    return builderResult.seed
                }
                set (value) {
                    builderResult.hasSeed = true
                    builderResult.seed = value
                }
            }
            public var hasSeed:Bool {
                get {
                    return builderResult.hasSeed
                }
            }
            @discardableResult
            public func setSeed(_ value:UInt64) -> Xla.ExecutionOptions.Builder {
                self.seed = value
                return self
            }
            @discardableResult
            public func clearSeed() -> Xla.ExecutionOptions.Builder{
                builderResult.hasSeed = false
                builderResult.seed = UInt64(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.ExecutionOptions.Builder {
                builderResult = Xla.ExecutionOptions()
                return self
            }
            override public func clone() throws -> Xla.ExecutionOptions.Builder {
                return try Xla.ExecutionOptions.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.ExecutionOptions {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.ExecutionOptions {
                let returnMe:Xla.ExecutionOptions = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.ExecutionOptions) throws -> Xla.ExecutionOptions.Builder {
                if other == Xla.ExecutionOptions() {
                    return self
                }
                if other.hasDisableFastMath {
                    disableFastMath = other.disableFastMath
                }
                if (other.hasShapeWithOutputLayout) {
                    try mergeShapeWithOutputLayout(value: other.shapeWithOutputLayout)
                }
                if other.hasSeed {
                    seed = other.seed
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.ExecutionOptions.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecutionOptions.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        disableFastMath = try codedInputStream.readBool()

                    case 18:
                        let subBuilder:Xla.Shape.Builder = Xla.Shape.Builder()
                        if hasShapeWithOutputLayout {
                            try subBuilder.mergeFrom(other: shapeWithOutputLayout)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        shapeWithOutputLayout = subBuilder.buildPartial()

                    case 24:
                        seed = try codedInputStream.readUInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.ExecutionOptions.Builder {
                let resultDecodedBuilder = Xla.ExecutionOptions.Builder()
                if let jsonValueDisableFastMath = jsonMap["disableFastMath"] as? Bool {
                    resultDecodedBuilder.disableFastMath = jsonValueDisableFastMath
                }
                if let jsonValueShapeWithOutputLayout = jsonMap["shapeWithOutputLayout"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.shapeWithOutputLayout = try Xla.Shape.Builder.decodeToBuilder(jsonMap:jsonValueShapeWithOutputLayout).build()

                }
                if let jsonValueSeed = jsonMap["seed"] as? String {
                    resultDecodedBuilder.seed = UInt64(jsonValueSeed)!
                } else if let jsonValueSeed = jsonMap["seed"] as? UInt {
                    resultDecodedBuilder.seed = UInt64(jsonValueSeed)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.ExecutionOptions.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.ExecutionOptions.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class SnapshotComputationRequest : GeneratedMessage {

        public static func == (lhs: Xla.SnapshotComputationRequest, rhs: Xla.SnapshotComputationRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasComputation == rhs.hasComputation) && (!lhs.hasComputation || lhs.computation == rhs.computation)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var computation:Xla.ComputationHandle!
        public fileprivate(set) var hasComputation:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasComputation {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:computation)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasComputation {
                if let varSizecomputation = computation?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizecomputation
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.SnapshotComputationRequest.Builder {
            return Xla.SnapshotComputationRequest.classBuilder() as! Xla.SnapshotComputationRequest.Builder
        }
        public func getBuilder() -> Xla.SnapshotComputationRequest.Builder {
            return classBuilder() as! Xla.SnapshotComputationRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.SnapshotComputationRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.SnapshotComputationRequest.Builder()
        }
        public func toBuilder() throws -> Xla.SnapshotComputationRequest.Builder {
            return try Xla.SnapshotComputationRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.SnapshotComputationRequest) throws -> Xla.SnapshotComputationRequest.Builder {
            return try Xla.SnapshotComputationRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasComputation {
                jsonMap["computation"] = try computation.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.SnapshotComputationRequest {
            return try Xla.SnapshotComputationRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.SnapshotComputationRequest {
            return try Xla.SnapshotComputationRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasComputation {
                output += "\(indent) computation {\n"
                if let outDescComputation = computation {
                    output += try outDescComputation.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasComputation {
                    if let hashValuecomputation = computation?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecomputation
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.SnapshotComputationRequest"
        }
        override public func className() -> String {
            return "Xla.SnapshotComputationRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.SnapshotComputationRequest = Xla.SnapshotComputationRequest()
            public func getMessage() -> Xla.SnapshotComputationRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var computation:Xla.ComputationHandle! {
                get {
                    if computationBuilder_ != nil {
                        builderResult.computation = computationBuilder_.getMessage()
                    }
                    return builderResult.computation
                }
                set (value) {
                    builderResult.hasComputation = true
                    builderResult.computation = value
                }
            }
            public var hasComputation:Bool {
                get {
                    return builderResult.hasComputation
                }
            }
            fileprivate var computationBuilder_:Xla.ComputationHandle.Builder! {
                didSet {
                    builderResult.hasComputation = true
                }
            }
            public func getComputationBuilder() -> Xla.ComputationHandle.Builder {
                if computationBuilder_ == nil {
                    computationBuilder_ = Xla.ComputationHandle.Builder()
                    builderResult.computation = computationBuilder_.getMessage()
                    if computation != nil {
                        try! computationBuilder_.mergeFrom(other: computation)
                    }
                }
                return computationBuilder_
            }
            @discardableResult
            public func setComputation(_ value:Xla.ComputationHandle!) -> Xla.SnapshotComputationRequest.Builder {
                self.computation = value
                return self
            }
            @discardableResult
            public func mergeComputation(value:Xla.ComputationHandle) throws -> Xla.SnapshotComputationRequest.Builder {
                if builderResult.hasComputation {
                    builderResult.computation = try Xla.ComputationHandle.builderWithPrototype(prototype:builderResult.computation).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.computation = value
                }
                builderResult.hasComputation = true
                return self
            }
            @discardableResult
            public func clearComputation() -> Xla.SnapshotComputationRequest.Builder {
                computationBuilder_ = nil
                builderResult.hasComputation = false
                builderResult.computation = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.SnapshotComputationRequest.Builder {
                builderResult = Xla.SnapshotComputationRequest()
                return self
            }
            override public func clone() throws -> Xla.SnapshotComputationRequest.Builder {
                return try Xla.SnapshotComputationRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.SnapshotComputationRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.SnapshotComputationRequest {
                let returnMe:Xla.SnapshotComputationRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.SnapshotComputationRequest) throws -> Xla.SnapshotComputationRequest.Builder {
                if other == Xla.SnapshotComputationRequest() {
                    return self
                }
                if (other.hasComputation) {
                    try mergeComputation(value: other.computation)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.SnapshotComputationRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SnapshotComputationRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.ComputationHandle.Builder = Xla.ComputationHandle.Builder()
                        if hasComputation {
                            try subBuilder.mergeFrom(other: computation)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        computation = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.SnapshotComputationRequest.Builder {
                let resultDecodedBuilder = Xla.SnapshotComputationRequest.Builder()
                if let jsonValueComputation = jsonMap["computation"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.computation = try Xla.ComputationHandle.Builder.decodeToBuilder(jsonMap:jsonValueComputation).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.SnapshotComputationRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.SnapshotComputationRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class SnapshotComputationResponse : GeneratedMessage {

        public static func == (lhs: Xla.SnapshotComputationResponse, rhs: Xla.SnapshotComputationResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasModule == rhs.hasModule) && (!lhs.hasModule || lhs.module == rhs.module)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var module:Xla.SessionModule!
        public fileprivate(set) var hasModule:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasModule {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:module)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasModule {
                if let varSizemodule = module?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizemodule
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.SnapshotComputationResponse.Builder {
            return Xla.SnapshotComputationResponse.classBuilder() as! Xla.SnapshotComputationResponse.Builder
        }
        public func getBuilder() -> Xla.SnapshotComputationResponse.Builder {
            return classBuilder() as! Xla.SnapshotComputationResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.SnapshotComputationResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.SnapshotComputationResponse.Builder()
        }
        public func toBuilder() throws -> Xla.SnapshotComputationResponse.Builder {
            return try Xla.SnapshotComputationResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.SnapshotComputationResponse) throws -> Xla.SnapshotComputationResponse.Builder {
            return try Xla.SnapshotComputationResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasModule {
                jsonMap["module"] = try module.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.SnapshotComputationResponse {
            return try Xla.SnapshotComputationResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.SnapshotComputationResponse {
            return try Xla.SnapshotComputationResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasModule {
                output += "\(indent) module {\n"
                if let outDescModule = module {
                    output += try outDescModule.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasModule {
                    if let hashValuemodule = module?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuemodule
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.SnapshotComputationResponse"
        }
        override public func className() -> String {
            return "Xla.SnapshotComputationResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.SnapshotComputationResponse = Xla.SnapshotComputationResponse()
            public func getMessage() -> Xla.SnapshotComputationResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var module:Xla.SessionModule! {
                get {
                    if moduleBuilder_ != nil {
                        builderResult.module = moduleBuilder_.getMessage()
                    }
                    return builderResult.module
                }
                set (value) {
                    builderResult.hasModule = true
                    builderResult.module = value
                }
            }
            public var hasModule:Bool {
                get {
                    return builderResult.hasModule
                }
            }
            fileprivate var moduleBuilder_:Xla.SessionModule.Builder! {
                didSet {
                    builderResult.hasModule = true
                }
            }
            public func getModuleBuilder() -> Xla.SessionModule.Builder {
                if moduleBuilder_ == nil {
                    moduleBuilder_ = Xla.SessionModule.Builder()
                    builderResult.module = moduleBuilder_.getMessage()
                    if module != nil {
                        try! moduleBuilder_.mergeFrom(other: module)
                    }
                }
                return moduleBuilder_
            }
            @discardableResult
            public func setModule(_ value:Xla.SessionModule!) -> Xla.SnapshotComputationResponse.Builder {
                self.module = value
                return self
            }
            @discardableResult
            public func mergeModule(value:Xla.SessionModule) throws -> Xla.SnapshotComputationResponse.Builder {
                if builderResult.hasModule {
                    builderResult.module = try Xla.SessionModule.builderWithPrototype(prototype:builderResult.module).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.module = value
                }
                builderResult.hasModule = true
                return self
            }
            @discardableResult
            public func clearModule() -> Xla.SnapshotComputationResponse.Builder {
                moduleBuilder_ = nil
                builderResult.hasModule = false
                builderResult.module = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.SnapshotComputationResponse.Builder {
                builderResult = Xla.SnapshotComputationResponse()
                return self
            }
            override public func clone() throws -> Xla.SnapshotComputationResponse.Builder {
                return try Xla.SnapshotComputationResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.SnapshotComputationResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.SnapshotComputationResponse {
                let returnMe:Xla.SnapshotComputationResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.SnapshotComputationResponse) throws -> Xla.SnapshotComputationResponse.Builder {
                if other == Xla.SnapshotComputationResponse() {
                    return self
                }
                if (other.hasModule) {
                    try mergeModule(value: other.module)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.SnapshotComputationResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SnapshotComputationResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.SessionModule.Builder = Xla.SessionModule.Builder()
                        if hasModule {
                            try subBuilder.mergeFrom(other: module)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        module = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.SnapshotComputationResponse.Builder {
                let resultDecodedBuilder = Xla.SnapshotComputationResponse.Builder()
                if let jsonValueModule = jsonMap["module"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.module = try Xla.SessionModule.Builder.decodeToBuilder(jsonMap:jsonValueModule).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.SnapshotComputationResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.SnapshotComputationResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class LoadComputationSnapshotRequest : GeneratedMessage {

        public static func == (lhs: Xla.LoadComputationSnapshotRequest, rhs: Xla.LoadComputationSnapshotRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasModule == rhs.hasModule) && (!lhs.hasModule || lhs.module == rhs.module)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var module:Xla.SessionModule!
        public fileprivate(set) var hasModule:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasModule {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:module)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasModule {
                if let varSizemodule = module?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizemodule
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.LoadComputationSnapshotRequest.Builder {
            return Xla.LoadComputationSnapshotRequest.classBuilder() as! Xla.LoadComputationSnapshotRequest.Builder
        }
        public func getBuilder() -> Xla.LoadComputationSnapshotRequest.Builder {
            return classBuilder() as! Xla.LoadComputationSnapshotRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.LoadComputationSnapshotRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.LoadComputationSnapshotRequest.Builder()
        }
        public func toBuilder() throws -> Xla.LoadComputationSnapshotRequest.Builder {
            return try Xla.LoadComputationSnapshotRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.LoadComputationSnapshotRequest) throws -> Xla.LoadComputationSnapshotRequest.Builder {
            return try Xla.LoadComputationSnapshotRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasModule {
                jsonMap["module"] = try module.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.LoadComputationSnapshotRequest {
            return try Xla.LoadComputationSnapshotRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.LoadComputationSnapshotRequest {
            return try Xla.LoadComputationSnapshotRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasModule {
                output += "\(indent) module {\n"
                if let outDescModule = module {
                    output += try outDescModule.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasModule {
                    if let hashValuemodule = module?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuemodule
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.LoadComputationSnapshotRequest"
        }
        override public func className() -> String {
            return "Xla.LoadComputationSnapshotRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.LoadComputationSnapshotRequest = Xla.LoadComputationSnapshotRequest()
            public func getMessage() -> Xla.LoadComputationSnapshotRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var module:Xla.SessionModule! {
                get {
                    if moduleBuilder_ != nil {
                        builderResult.module = moduleBuilder_.getMessage()
                    }
                    return builderResult.module
                }
                set (value) {
                    builderResult.hasModule = true
                    builderResult.module = value
                }
            }
            public var hasModule:Bool {
                get {
                    return builderResult.hasModule
                }
            }
            fileprivate var moduleBuilder_:Xla.SessionModule.Builder! {
                didSet {
                    builderResult.hasModule = true
                }
            }
            public func getModuleBuilder() -> Xla.SessionModule.Builder {
                if moduleBuilder_ == nil {
                    moduleBuilder_ = Xla.SessionModule.Builder()
                    builderResult.module = moduleBuilder_.getMessage()
                    if module != nil {
                        try! moduleBuilder_.mergeFrom(other: module)
                    }
                }
                return moduleBuilder_
            }
            @discardableResult
            public func setModule(_ value:Xla.SessionModule!) -> Xla.LoadComputationSnapshotRequest.Builder {
                self.module = value
                return self
            }
            @discardableResult
            public func mergeModule(value:Xla.SessionModule) throws -> Xla.LoadComputationSnapshotRequest.Builder {
                if builderResult.hasModule {
                    builderResult.module = try Xla.SessionModule.builderWithPrototype(prototype:builderResult.module).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.module = value
                }
                builderResult.hasModule = true
                return self
            }
            @discardableResult
            public func clearModule() -> Xla.LoadComputationSnapshotRequest.Builder {
                moduleBuilder_ = nil
                builderResult.hasModule = false
                builderResult.module = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.LoadComputationSnapshotRequest.Builder {
                builderResult = Xla.LoadComputationSnapshotRequest()
                return self
            }
            override public func clone() throws -> Xla.LoadComputationSnapshotRequest.Builder {
                return try Xla.LoadComputationSnapshotRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.LoadComputationSnapshotRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.LoadComputationSnapshotRequest {
                let returnMe:Xla.LoadComputationSnapshotRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.LoadComputationSnapshotRequest) throws -> Xla.LoadComputationSnapshotRequest.Builder {
                if other == Xla.LoadComputationSnapshotRequest() {
                    return self
                }
                if (other.hasModule) {
                    try mergeModule(value: other.module)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.LoadComputationSnapshotRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.LoadComputationSnapshotRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.SessionModule.Builder = Xla.SessionModule.Builder()
                        if hasModule {
                            try subBuilder.mergeFrom(other: module)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        module = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.LoadComputationSnapshotRequest.Builder {
                let resultDecodedBuilder = Xla.LoadComputationSnapshotRequest.Builder()
                if let jsonValueModule = jsonMap["module"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.module = try Xla.SessionModule.Builder.decodeToBuilder(jsonMap:jsonValueModule).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.LoadComputationSnapshotRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.LoadComputationSnapshotRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class LoadComputationSnapshotResponse : GeneratedMessage {

        public static func == (lhs: Xla.LoadComputationSnapshotResponse, rhs: Xla.LoadComputationSnapshotResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasComputation == rhs.hasComputation) && (!lhs.hasComputation || lhs.computation == rhs.computation)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var computation:Xla.ComputationHandle!
        public fileprivate(set) var hasComputation:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasComputation {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:computation)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasComputation {
                if let varSizecomputation = computation?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizecomputation
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.LoadComputationSnapshotResponse.Builder {
            return Xla.LoadComputationSnapshotResponse.classBuilder() as! Xla.LoadComputationSnapshotResponse.Builder
        }
        public func getBuilder() -> Xla.LoadComputationSnapshotResponse.Builder {
            return classBuilder() as! Xla.LoadComputationSnapshotResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.LoadComputationSnapshotResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.LoadComputationSnapshotResponse.Builder()
        }
        public func toBuilder() throws -> Xla.LoadComputationSnapshotResponse.Builder {
            return try Xla.LoadComputationSnapshotResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.LoadComputationSnapshotResponse) throws -> Xla.LoadComputationSnapshotResponse.Builder {
            return try Xla.LoadComputationSnapshotResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasComputation {
                jsonMap["computation"] = try computation.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.LoadComputationSnapshotResponse {
            return try Xla.LoadComputationSnapshotResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.LoadComputationSnapshotResponse {
            return try Xla.LoadComputationSnapshotResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasComputation {
                output += "\(indent) computation {\n"
                if let outDescComputation = computation {
                    output += try outDescComputation.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasComputation {
                    if let hashValuecomputation = computation?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecomputation
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.LoadComputationSnapshotResponse"
        }
        override public func className() -> String {
            return "Xla.LoadComputationSnapshotResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.LoadComputationSnapshotResponse = Xla.LoadComputationSnapshotResponse()
            public func getMessage() -> Xla.LoadComputationSnapshotResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var computation:Xla.ComputationHandle! {
                get {
                    if computationBuilder_ != nil {
                        builderResult.computation = computationBuilder_.getMessage()
                    }
                    return builderResult.computation
                }
                set (value) {
                    builderResult.hasComputation = true
                    builderResult.computation = value
                }
            }
            public var hasComputation:Bool {
                get {
                    return builderResult.hasComputation
                }
            }
            fileprivate var computationBuilder_:Xla.ComputationHandle.Builder! {
                didSet {
                    builderResult.hasComputation = true
                }
            }
            public func getComputationBuilder() -> Xla.ComputationHandle.Builder {
                if computationBuilder_ == nil {
                    computationBuilder_ = Xla.ComputationHandle.Builder()
                    builderResult.computation = computationBuilder_.getMessage()
                    if computation != nil {
                        try! computationBuilder_.mergeFrom(other: computation)
                    }
                }
                return computationBuilder_
            }
            @discardableResult
            public func setComputation(_ value:Xla.ComputationHandle!) -> Xla.LoadComputationSnapshotResponse.Builder {
                self.computation = value
                return self
            }
            @discardableResult
            public func mergeComputation(value:Xla.ComputationHandle) throws -> Xla.LoadComputationSnapshotResponse.Builder {
                if builderResult.hasComputation {
                    builderResult.computation = try Xla.ComputationHandle.builderWithPrototype(prototype:builderResult.computation).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.computation = value
                }
                builderResult.hasComputation = true
                return self
            }
            @discardableResult
            public func clearComputation() -> Xla.LoadComputationSnapshotResponse.Builder {
                computationBuilder_ = nil
                builderResult.hasComputation = false
                builderResult.computation = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.LoadComputationSnapshotResponse.Builder {
                builderResult = Xla.LoadComputationSnapshotResponse()
                return self
            }
            override public func clone() throws -> Xla.LoadComputationSnapshotResponse.Builder {
                return try Xla.LoadComputationSnapshotResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.LoadComputationSnapshotResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.LoadComputationSnapshotResponse {
                let returnMe:Xla.LoadComputationSnapshotResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.LoadComputationSnapshotResponse) throws -> Xla.LoadComputationSnapshotResponse.Builder {
                if other == Xla.LoadComputationSnapshotResponse() {
                    return self
                }
                if (other.hasComputation) {
                    try mergeComputation(value: other.computation)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.LoadComputationSnapshotResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.LoadComputationSnapshotResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.ComputationHandle.Builder = Xla.ComputationHandle.Builder()
                        if hasComputation {
                            try subBuilder.mergeFrom(other: computation)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        computation = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.LoadComputationSnapshotResponse.Builder {
                let resultDecodedBuilder = Xla.LoadComputationSnapshotResponse.Builder()
                if let jsonValueComputation = jsonMap["computation"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.computation = try Xla.ComputationHandle.Builder.decodeToBuilder(jsonMap:jsonValueComputation).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.LoadComputationSnapshotResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.LoadComputationSnapshotResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class GetDeviceHandlesRequest : GeneratedMessage {

        public static func == (lhs: Xla.GetDeviceHandlesRequest, rhs: Xla.GetDeviceHandlesRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasDeviceCount == rhs.hasDeviceCount) && (!lhs.hasDeviceCount || lhs.deviceCount == rhs.deviceCount)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var deviceCount:Int64 = Int64(0)
        public fileprivate(set) var hasDeviceCount:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasDeviceCount {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:deviceCount)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasDeviceCount {
                serialize_size += deviceCount.computeInt64Size(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.GetDeviceHandlesRequest.Builder {
            return Xla.GetDeviceHandlesRequest.classBuilder() as! Xla.GetDeviceHandlesRequest.Builder
        }
        public func getBuilder() -> Xla.GetDeviceHandlesRequest.Builder {
            return classBuilder() as! Xla.GetDeviceHandlesRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.GetDeviceHandlesRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.GetDeviceHandlesRequest.Builder()
        }
        public func toBuilder() throws -> Xla.GetDeviceHandlesRequest.Builder {
            return try Xla.GetDeviceHandlesRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.GetDeviceHandlesRequest) throws -> Xla.GetDeviceHandlesRequest.Builder {
            return try Xla.GetDeviceHandlesRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasDeviceCount {
                jsonMap["deviceCount"] = "\(deviceCount)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.GetDeviceHandlesRequest {
            return try Xla.GetDeviceHandlesRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.GetDeviceHandlesRequest {
            return try Xla.GetDeviceHandlesRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasDeviceCount {
                output += "\(indent) deviceCount: \(deviceCount) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasDeviceCount {
                    hashCode = (hashCode &* 31) &+ deviceCount.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.GetDeviceHandlesRequest"
        }
        override public func className() -> String {
            return "Xla.GetDeviceHandlesRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.GetDeviceHandlesRequest = Xla.GetDeviceHandlesRequest()
            public func getMessage() -> Xla.GetDeviceHandlesRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var deviceCount:Int64 {
                get {
                    return builderResult.deviceCount
                }
                set (value) {
                    builderResult.hasDeviceCount = true
                    builderResult.deviceCount = value
                }
            }
            public var hasDeviceCount:Bool {
                get {
                    return builderResult.hasDeviceCount
                }
            }
            @discardableResult
            public func setDeviceCount(_ value:Int64) -> Xla.GetDeviceHandlesRequest.Builder {
                self.deviceCount = value
                return self
            }
            @discardableResult
            public func clearDeviceCount() -> Xla.GetDeviceHandlesRequest.Builder{
                builderResult.hasDeviceCount = false
                builderResult.deviceCount = Int64(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.GetDeviceHandlesRequest.Builder {
                builderResult = Xla.GetDeviceHandlesRequest()
                return self
            }
            override public func clone() throws -> Xla.GetDeviceHandlesRequest.Builder {
                return try Xla.GetDeviceHandlesRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.GetDeviceHandlesRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.GetDeviceHandlesRequest {
                let returnMe:Xla.GetDeviceHandlesRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.GetDeviceHandlesRequest) throws -> Xla.GetDeviceHandlesRequest.Builder {
                if other == Xla.GetDeviceHandlesRequest() {
                    return self
                }
                if other.hasDeviceCount {
                    deviceCount = other.deviceCount
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.GetDeviceHandlesRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.GetDeviceHandlesRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        deviceCount = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.GetDeviceHandlesRequest.Builder {
                let resultDecodedBuilder = Xla.GetDeviceHandlesRequest.Builder()
                if let jsonValueDeviceCount = jsonMap["deviceCount"] as? String {
                    resultDecodedBuilder.deviceCount = Int64(jsonValueDeviceCount)!
                } else if let jsonValueDeviceCount = jsonMap["deviceCount"] as? Int {
                    resultDecodedBuilder.deviceCount = Int64(jsonValueDeviceCount)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.GetDeviceHandlesRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.GetDeviceHandlesRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class GetDeviceHandlesResponse : GeneratedMessage {

        public static func == (lhs: Xla.GetDeviceHandlesResponse, rhs: Xla.GetDeviceHandlesResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.deviceHandles == rhs.deviceHandles)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var deviceHandles:Array<Xla.DeviceHandle>  = Array<Xla.DeviceHandle>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementDeviceHandles in deviceHandles {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementDeviceHandles)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementDeviceHandles in deviceHandles {
                serialize_size += oneElementDeviceHandles.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.GetDeviceHandlesResponse.Builder {
            return Xla.GetDeviceHandlesResponse.classBuilder() as! Xla.GetDeviceHandlesResponse.Builder
        }
        public func getBuilder() -> Xla.GetDeviceHandlesResponse.Builder {
            return classBuilder() as! Xla.GetDeviceHandlesResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.GetDeviceHandlesResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.GetDeviceHandlesResponse.Builder()
        }
        public func toBuilder() throws -> Xla.GetDeviceHandlesResponse.Builder {
            return try Xla.GetDeviceHandlesResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.GetDeviceHandlesResponse) throws -> Xla.GetDeviceHandlesResponse.Builder {
            return try Xla.GetDeviceHandlesResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !deviceHandles.isEmpty {
                var jsonArrayDeviceHandles:Array<Dictionary<String,Any>> = []
                for oneValueDeviceHandles in deviceHandles {
                    let ecodedMessageDeviceHandles = try oneValueDeviceHandles.encode()
                    jsonArrayDeviceHandles.append(ecodedMessageDeviceHandles)
                }
                jsonMap["deviceHandles"] = jsonArrayDeviceHandles
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.GetDeviceHandlesResponse {
            return try Xla.GetDeviceHandlesResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.GetDeviceHandlesResponse {
            return try Xla.GetDeviceHandlesResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var deviceHandlesElementIndex:Int = 0
            for oneElementDeviceHandles in deviceHandles {
                output += "\(indent) deviceHandles[\(deviceHandlesElementIndex)] {\n"
                output += try oneElementDeviceHandles.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                deviceHandlesElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementDeviceHandles in deviceHandles {
                    hashCode = (hashCode &* 31) &+ oneElementDeviceHandles.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.GetDeviceHandlesResponse"
        }
        override public func className() -> String {
            return "Xla.GetDeviceHandlesResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.GetDeviceHandlesResponse = Xla.GetDeviceHandlesResponse()
            public func getMessage() -> Xla.GetDeviceHandlesResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var deviceHandles:Array<Xla.DeviceHandle> {
                get {
                    return builderResult.deviceHandles
                }
                set (value) {
                    builderResult.deviceHandles = value
                }
            }
            @discardableResult
            public func setDeviceHandles(_ value:Array<Xla.DeviceHandle>) -> Xla.GetDeviceHandlesResponse.Builder {
                self.deviceHandles = value
                return self
            }
            @discardableResult
            public func clearDeviceHandles() -> Xla.GetDeviceHandlesResponse.Builder {
                builderResult.deviceHandles.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.GetDeviceHandlesResponse.Builder {
                builderResult = Xla.GetDeviceHandlesResponse()
                return self
            }
            override public func clone() throws -> Xla.GetDeviceHandlesResponse.Builder {
                return try Xla.GetDeviceHandlesResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.GetDeviceHandlesResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.GetDeviceHandlesResponse {
                let returnMe:Xla.GetDeviceHandlesResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.GetDeviceHandlesResponse) throws -> Xla.GetDeviceHandlesResponse.Builder {
                if other == Xla.GetDeviceHandlesResponse() {
                    return self
                }
                if !other.deviceHandles.isEmpty  {
                     builderResult.deviceHandles += other.deviceHandles
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.GetDeviceHandlesResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.GetDeviceHandlesResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Xla.DeviceHandle.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        deviceHandles.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.GetDeviceHandlesResponse.Builder {
                let resultDecodedBuilder = Xla.GetDeviceHandlesResponse.Builder()
                if let jsonValueDeviceHandles = jsonMap["deviceHandles"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayDeviceHandles:Array<Xla.DeviceHandle> = []
                    for oneValueDeviceHandles in jsonValueDeviceHandles {
                        let messageFromStringDeviceHandles = try Xla.DeviceHandle.Builder.decodeToBuilder(jsonMap:oneValueDeviceHandles).build()

                        jsonArrayDeviceHandles.append(messageFromStringDeviceHandles)
                    }
                    resultDecodedBuilder.deviceHandles = jsonArrayDeviceHandles
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.GetDeviceHandlesResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.GetDeviceHandlesResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class TransferToClientRequest : GeneratedMessage {

        public static func == (lhs: Xla.TransferToClientRequest, rhs: Xla.TransferToClientRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasData == rhs.hasData) && (!lhs.hasData || lhs.data == rhs.data)
            fieldCheck = fieldCheck && (lhs.hasShapeWithLayout == rhs.hasShapeWithLayout) && (!lhs.hasShapeWithLayout || lhs.shapeWithLayout == rhs.shapeWithLayout)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var data:Xla.GlobalDataHandle!
        public fileprivate(set) var hasData:Bool = false
        public fileprivate(set) var shapeWithLayout:Xla.Shape!
        public fileprivate(set) var hasShapeWithLayout:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasData {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:data)
            }
            if hasShapeWithLayout {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:shapeWithLayout)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasData {
                if let varSizedata = data?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizedata
                }
            }
            if hasShapeWithLayout {
                if let varSizeshapeWithLayout = shapeWithLayout?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeshapeWithLayout
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.TransferToClientRequest.Builder {
            return Xla.TransferToClientRequest.classBuilder() as! Xla.TransferToClientRequest.Builder
        }
        public func getBuilder() -> Xla.TransferToClientRequest.Builder {
            return classBuilder() as! Xla.TransferToClientRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.TransferToClientRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.TransferToClientRequest.Builder()
        }
        public func toBuilder() throws -> Xla.TransferToClientRequest.Builder {
            return try Xla.TransferToClientRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.TransferToClientRequest) throws -> Xla.TransferToClientRequest.Builder {
            return try Xla.TransferToClientRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasData {
                jsonMap["data"] = try data.encode()
            }
            if hasShapeWithLayout {
                jsonMap["shapeWithLayout"] = try shapeWithLayout.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.TransferToClientRequest {
            return try Xla.TransferToClientRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.TransferToClientRequest {
            return try Xla.TransferToClientRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasData {
                output += "\(indent) data {\n"
                if let outDescData = data {
                    output += try outDescData.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasShapeWithLayout {
                output += "\(indent) shapeWithLayout {\n"
                if let outDescShapeWithLayout = shapeWithLayout {
                    output += try outDescShapeWithLayout.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasData {
                    if let hashValuedata = data?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuedata
                    }
                }
                if hasShapeWithLayout {
                    if let hashValueshapeWithLayout = shapeWithLayout?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueshapeWithLayout
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.TransferToClientRequest"
        }
        override public func className() -> String {
            return "Xla.TransferToClientRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.TransferToClientRequest = Xla.TransferToClientRequest()
            public func getMessage() -> Xla.TransferToClientRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var data:Xla.GlobalDataHandle! {
                get {
                    if dataBuilder_ != nil {
                        builderResult.data = dataBuilder_.getMessage()
                    }
                    return builderResult.data
                }
                set (value) {
                    builderResult.hasData = true
                    builderResult.data = value
                }
            }
            public var hasData:Bool {
                get {
                    return builderResult.hasData
                }
            }
            fileprivate var dataBuilder_:Xla.GlobalDataHandle.Builder! {
                didSet {
                    builderResult.hasData = true
                }
            }
            public func getDataBuilder() -> Xla.GlobalDataHandle.Builder {
                if dataBuilder_ == nil {
                    dataBuilder_ = Xla.GlobalDataHandle.Builder()
                    builderResult.data = dataBuilder_.getMessage()
                    if data != nil {
                        try! dataBuilder_.mergeFrom(other: data)
                    }
                }
                return dataBuilder_
            }
            @discardableResult
            public func setData(_ value:Xla.GlobalDataHandle!) -> Xla.TransferToClientRequest.Builder {
                self.data = value
                return self
            }
            @discardableResult
            public func mergeData(value:Xla.GlobalDataHandle) throws -> Xla.TransferToClientRequest.Builder {
                if builderResult.hasData {
                    builderResult.data = try Xla.GlobalDataHandle.builderWithPrototype(prototype:builderResult.data).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.data = value
                }
                builderResult.hasData = true
                return self
            }
            @discardableResult
            public func clearData() -> Xla.TransferToClientRequest.Builder {
                dataBuilder_ = nil
                builderResult.hasData = false
                builderResult.data = nil
                return self
            }
            /// This optional field directs the service to return the literal in this
            /// layout. A shape is used to hold the layout to accommodate tuples.
            public var shapeWithLayout:Xla.Shape! {
                get {
                    if shapeWithLayoutBuilder_ != nil {
                        builderResult.shapeWithLayout = shapeWithLayoutBuilder_.getMessage()
                    }
                    return builderResult.shapeWithLayout
                }
                set (value) {
                    builderResult.hasShapeWithLayout = true
                    builderResult.shapeWithLayout = value
                }
            }
            public var hasShapeWithLayout:Bool {
                get {
                    return builderResult.hasShapeWithLayout
                }
            }
            fileprivate var shapeWithLayoutBuilder_:Xla.Shape.Builder! {
                didSet {
                    builderResult.hasShapeWithLayout = true
                }
            }
            public func getShapeWithLayoutBuilder() -> Xla.Shape.Builder {
                if shapeWithLayoutBuilder_ == nil {
                    shapeWithLayoutBuilder_ = Xla.Shape.Builder()
                    builderResult.shapeWithLayout = shapeWithLayoutBuilder_.getMessage()
                    if shapeWithLayout != nil {
                        try! shapeWithLayoutBuilder_.mergeFrom(other: shapeWithLayout)
                    }
                }
                return shapeWithLayoutBuilder_
            }
            @discardableResult
            public func setShapeWithLayout(_ value:Xla.Shape!) -> Xla.TransferToClientRequest.Builder {
                self.shapeWithLayout = value
                return self
            }
            @discardableResult
            public func mergeShapeWithLayout(value:Xla.Shape) throws -> Xla.TransferToClientRequest.Builder {
                if builderResult.hasShapeWithLayout {
                    builderResult.shapeWithLayout = try Xla.Shape.builderWithPrototype(prototype:builderResult.shapeWithLayout).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.shapeWithLayout = value
                }
                builderResult.hasShapeWithLayout = true
                return self
            }
            @discardableResult
            public func clearShapeWithLayout() -> Xla.TransferToClientRequest.Builder {
                shapeWithLayoutBuilder_ = nil
                builderResult.hasShapeWithLayout = false
                builderResult.shapeWithLayout = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.TransferToClientRequest.Builder {
                builderResult = Xla.TransferToClientRequest()
                return self
            }
            override public func clone() throws -> Xla.TransferToClientRequest.Builder {
                return try Xla.TransferToClientRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.TransferToClientRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.TransferToClientRequest {
                let returnMe:Xla.TransferToClientRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.TransferToClientRequest) throws -> Xla.TransferToClientRequest.Builder {
                if other == Xla.TransferToClientRequest() {
                    return self
                }
                if (other.hasData) {
                    try mergeData(value: other.data)
                }
                if (other.hasShapeWithLayout) {
                    try mergeShapeWithLayout(value: other.shapeWithLayout)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.TransferToClientRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToClientRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.GlobalDataHandle.Builder = Xla.GlobalDataHandle.Builder()
                        if hasData {
                            try subBuilder.mergeFrom(other: data)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        data = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Xla.Shape.Builder = Xla.Shape.Builder()
                        if hasShapeWithLayout {
                            try subBuilder.mergeFrom(other: shapeWithLayout)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        shapeWithLayout = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.TransferToClientRequest.Builder {
                let resultDecodedBuilder = Xla.TransferToClientRequest.Builder()
                if let jsonValueData = jsonMap["data"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.data = try Xla.GlobalDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueData).build()

                }
                if let jsonValueShapeWithLayout = jsonMap["shapeWithLayout"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.shapeWithLayout = try Xla.Shape.Builder.decodeToBuilder(jsonMap:jsonValueShapeWithLayout).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.TransferToClientRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.TransferToClientRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class TransferToClientResponse : GeneratedMessage {

        public static func == (lhs: Xla.TransferToClientResponse, rhs: Xla.TransferToClientResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasLiteral == rhs.hasLiteral) && (!lhs.hasLiteral || lhs.literal == rhs.literal)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var literal:Xla.Literal!
        public fileprivate(set) var hasLiteral:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasLiteral {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:literal)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasLiteral {
                if let varSizeliteral = literal?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeliteral
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.TransferToClientResponse.Builder {
            return Xla.TransferToClientResponse.classBuilder() as! Xla.TransferToClientResponse.Builder
        }
        public func getBuilder() -> Xla.TransferToClientResponse.Builder {
            return classBuilder() as! Xla.TransferToClientResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.TransferToClientResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.TransferToClientResponse.Builder()
        }
        public func toBuilder() throws -> Xla.TransferToClientResponse.Builder {
            return try Xla.TransferToClientResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.TransferToClientResponse) throws -> Xla.TransferToClientResponse.Builder {
            return try Xla.TransferToClientResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasLiteral {
                jsonMap["literal"] = try literal.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.TransferToClientResponse {
            return try Xla.TransferToClientResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.TransferToClientResponse {
            return try Xla.TransferToClientResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasLiteral {
                output += "\(indent) literal {\n"
                if let outDescLiteral = literal {
                    output += try outDescLiteral.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasLiteral {
                    if let hashValueliteral = literal?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueliteral
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.TransferToClientResponse"
        }
        override public func className() -> String {
            return "Xla.TransferToClientResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.TransferToClientResponse = Xla.TransferToClientResponse()
            public func getMessage() -> Xla.TransferToClientResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var literal:Xla.Literal! {
                get {
                    if literalBuilder_ != nil {
                        builderResult.literal = literalBuilder_.getMessage()
                    }
                    return builderResult.literal
                }
                set (value) {
                    builderResult.hasLiteral = true
                    builderResult.literal = value
                }
            }
            public var hasLiteral:Bool {
                get {
                    return builderResult.hasLiteral
                }
            }
            fileprivate var literalBuilder_:Xla.Literal.Builder! {
                didSet {
                    builderResult.hasLiteral = true
                }
            }
            public func getLiteralBuilder() -> Xla.Literal.Builder {
                if literalBuilder_ == nil {
                    literalBuilder_ = Xla.Literal.Builder()
                    builderResult.literal = literalBuilder_.getMessage()
                    if literal != nil {
                        try! literalBuilder_.mergeFrom(other: literal)
                    }
                }
                return literalBuilder_
            }
            @discardableResult
            public func setLiteral(_ value:Xla.Literal!) -> Xla.TransferToClientResponse.Builder {
                self.literal = value
                return self
            }
            @discardableResult
            public func mergeLiteral(value:Xla.Literal) throws -> Xla.TransferToClientResponse.Builder {
                if builderResult.hasLiteral {
                    builderResult.literal = try Xla.Literal.builderWithPrototype(prototype:builderResult.literal).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.literal = value
                }
                builderResult.hasLiteral = true
                return self
            }
            @discardableResult
            public func clearLiteral() -> Xla.TransferToClientResponse.Builder {
                literalBuilder_ = nil
                builderResult.hasLiteral = false
                builderResult.literal = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.TransferToClientResponse.Builder {
                builderResult = Xla.TransferToClientResponse()
                return self
            }
            override public func clone() throws -> Xla.TransferToClientResponse.Builder {
                return try Xla.TransferToClientResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.TransferToClientResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.TransferToClientResponse {
                let returnMe:Xla.TransferToClientResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.TransferToClientResponse) throws -> Xla.TransferToClientResponse.Builder {
                if other == Xla.TransferToClientResponse() {
                    return self
                }
                if (other.hasLiteral) {
                    try mergeLiteral(value: other.literal)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.TransferToClientResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToClientResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.Literal.Builder = Xla.Literal.Builder()
                        if hasLiteral {
                            try subBuilder.mergeFrom(other: literal)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        literal = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.TransferToClientResponse.Builder {
                let resultDecodedBuilder = Xla.TransferToClientResponse.Builder()
                if let jsonValueLiteral = jsonMap["literal"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.literal = try Xla.Literal.Builder.decodeToBuilder(jsonMap:jsonValueLiteral).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.TransferToClientResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.TransferToClientResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class TransferToServerRequest : GeneratedMessage {

        public static func == (lhs: Xla.TransferToServerRequest, rhs: Xla.TransferToServerRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasLiteral == rhs.hasLiteral) && (!lhs.hasLiteral || lhs.literal == rhs.literal)
            fieldCheck = fieldCheck && (lhs.hasDeviceHandle == rhs.hasDeviceHandle) && (!lhs.hasDeviceHandle || lhs.deviceHandle == rhs.deviceHandle)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var literal:Xla.Literal!
        public fileprivate(set) var hasLiteral:Bool = false
        public fileprivate(set) var deviceHandle:Xla.DeviceHandle!
        public fileprivate(set) var hasDeviceHandle:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasLiteral {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:literal)
            }
            if hasDeviceHandle {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:deviceHandle)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasLiteral {
                if let varSizeliteral = literal?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeliteral
                }
            }
            if hasDeviceHandle {
                if let varSizedeviceHandle = deviceHandle?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizedeviceHandle
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.TransferToServerRequest.Builder {
            return Xla.TransferToServerRequest.classBuilder() as! Xla.TransferToServerRequest.Builder
        }
        public func getBuilder() -> Xla.TransferToServerRequest.Builder {
            return classBuilder() as! Xla.TransferToServerRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.TransferToServerRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.TransferToServerRequest.Builder()
        }
        public func toBuilder() throws -> Xla.TransferToServerRequest.Builder {
            return try Xla.TransferToServerRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.TransferToServerRequest) throws -> Xla.TransferToServerRequest.Builder {
            return try Xla.TransferToServerRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasLiteral {
                jsonMap["literal"] = try literal.encode()
            }
            if hasDeviceHandle {
                jsonMap["deviceHandle"] = try deviceHandle.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.TransferToServerRequest {
            return try Xla.TransferToServerRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.TransferToServerRequest {
            return try Xla.TransferToServerRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasLiteral {
                output += "\(indent) literal {\n"
                if let outDescLiteral = literal {
                    output += try outDescLiteral.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasDeviceHandle {
                output += "\(indent) deviceHandle {\n"
                if let outDescDeviceHandle = deviceHandle {
                    output += try outDescDeviceHandle.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasLiteral {
                    if let hashValueliteral = literal?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueliteral
                    }
                }
                if hasDeviceHandle {
                    if let hashValuedeviceHandle = deviceHandle?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuedeviceHandle
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.TransferToServerRequest"
        }
        override public func className() -> String {
            return "Xla.TransferToServerRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.TransferToServerRequest = Xla.TransferToServerRequest()
            public func getMessage() -> Xla.TransferToServerRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var literal:Xla.Literal! {
                get {
                    if literalBuilder_ != nil {
                        builderResult.literal = literalBuilder_.getMessage()
                    }
                    return builderResult.literal
                }
                set (value) {
                    builderResult.hasLiteral = true
                    builderResult.literal = value
                }
            }
            public var hasLiteral:Bool {
                get {
                    return builderResult.hasLiteral
                }
            }
            fileprivate var literalBuilder_:Xla.Literal.Builder! {
                didSet {
                    builderResult.hasLiteral = true
                }
            }
            public func getLiteralBuilder() -> Xla.Literal.Builder {
                if literalBuilder_ == nil {
                    literalBuilder_ = Xla.Literal.Builder()
                    builderResult.literal = literalBuilder_.getMessage()
                    if literal != nil {
                        try! literalBuilder_.mergeFrom(other: literal)
                    }
                }
                return literalBuilder_
            }
            @discardableResult
            public func setLiteral(_ value:Xla.Literal!) -> Xla.TransferToServerRequest.Builder {
                self.literal = value
                return self
            }
            @discardableResult
            public func mergeLiteral(value:Xla.Literal) throws -> Xla.TransferToServerRequest.Builder {
                if builderResult.hasLiteral {
                    builderResult.literal = try Xla.Literal.builderWithPrototype(prototype:builderResult.literal).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.literal = value
                }
                builderResult.hasLiteral = true
                return self
            }
            @discardableResult
            public func clearLiteral() -> Xla.TransferToServerRequest.Builder {
                literalBuilder_ = nil
                builderResult.hasLiteral = false
                builderResult.literal = nil
                return self
            }
            public var deviceHandle:Xla.DeviceHandle! {
                get {
                    if deviceHandleBuilder_ != nil {
                        builderResult.deviceHandle = deviceHandleBuilder_.getMessage()
                    }
                    return builderResult.deviceHandle
                }
                set (value) {
                    builderResult.hasDeviceHandle = true
                    builderResult.deviceHandle = value
                }
            }
            public var hasDeviceHandle:Bool {
                get {
                    return builderResult.hasDeviceHandle
                }
            }
            fileprivate var deviceHandleBuilder_:Xla.DeviceHandle.Builder! {
                didSet {
                    builderResult.hasDeviceHandle = true
                }
            }
            public func getDeviceHandleBuilder() -> Xla.DeviceHandle.Builder {
                if deviceHandleBuilder_ == nil {
                    deviceHandleBuilder_ = Xla.DeviceHandle.Builder()
                    builderResult.deviceHandle = deviceHandleBuilder_.getMessage()
                    if deviceHandle != nil {
                        try! deviceHandleBuilder_.mergeFrom(other: deviceHandle)
                    }
                }
                return deviceHandleBuilder_
            }
            @discardableResult
            public func setDeviceHandle(_ value:Xla.DeviceHandle!) -> Xla.TransferToServerRequest.Builder {
                self.deviceHandle = value
                return self
            }
            @discardableResult
            public func mergeDeviceHandle(value:Xla.DeviceHandle) throws -> Xla.TransferToServerRequest.Builder {
                if builderResult.hasDeviceHandle {
                    builderResult.deviceHandle = try Xla.DeviceHandle.builderWithPrototype(prototype:builderResult.deviceHandle).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.deviceHandle = value
                }
                builderResult.hasDeviceHandle = true
                return self
            }
            @discardableResult
            public func clearDeviceHandle() -> Xla.TransferToServerRequest.Builder {
                deviceHandleBuilder_ = nil
                builderResult.hasDeviceHandle = false
                builderResult.deviceHandle = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.TransferToServerRequest.Builder {
                builderResult = Xla.TransferToServerRequest()
                return self
            }
            override public func clone() throws -> Xla.TransferToServerRequest.Builder {
                return try Xla.TransferToServerRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.TransferToServerRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.TransferToServerRequest {
                let returnMe:Xla.TransferToServerRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.TransferToServerRequest) throws -> Xla.TransferToServerRequest.Builder {
                if other == Xla.TransferToServerRequest() {
                    return self
                }
                if (other.hasLiteral) {
                    try mergeLiteral(value: other.literal)
                }
                if (other.hasDeviceHandle) {
                    try mergeDeviceHandle(value: other.deviceHandle)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.TransferToServerRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToServerRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.Literal.Builder = Xla.Literal.Builder()
                        if hasLiteral {
                            try subBuilder.mergeFrom(other: literal)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        literal = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Xla.DeviceHandle.Builder = Xla.DeviceHandle.Builder()
                        if hasDeviceHandle {
                            try subBuilder.mergeFrom(other: deviceHandle)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        deviceHandle = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.TransferToServerRequest.Builder {
                let resultDecodedBuilder = Xla.TransferToServerRequest.Builder()
                if let jsonValueLiteral = jsonMap["literal"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.literal = try Xla.Literal.Builder.decodeToBuilder(jsonMap:jsonValueLiteral).build()

                }
                if let jsonValueDeviceHandle = jsonMap["deviceHandle"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.deviceHandle = try Xla.DeviceHandle.Builder.decodeToBuilder(jsonMap:jsonValueDeviceHandle).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.TransferToServerRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.TransferToServerRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class TransferToServerResponse : GeneratedMessage {

        public static func == (lhs: Xla.TransferToServerResponse, rhs: Xla.TransferToServerResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasData == rhs.hasData) && (!lhs.hasData || lhs.data == rhs.data)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var data:Xla.GlobalDataHandle!
        public fileprivate(set) var hasData:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasData {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:data)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasData {
                if let varSizedata = data?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizedata
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.TransferToServerResponse.Builder {
            return Xla.TransferToServerResponse.classBuilder() as! Xla.TransferToServerResponse.Builder
        }
        public func getBuilder() -> Xla.TransferToServerResponse.Builder {
            return classBuilder() as! Xla.TransferToServerResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.TransferToServerResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.TransferToServerResponse.Builder()
        }
        public func toBuilder() throws -> Xla.TransferToServerResponse.Builder {
            return try Xla.TransferToServerResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.TransferToServerResponse) throws -> Xla.TransferToServerResponse.Builder {
            return try Xla.TransferToServerResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasData {
                jsonMap["data"] = try data.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.TransferToServerResponse {
            return try Xla.TransferToServerResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.TransferToServerResponse {
            return try Xla.TransferToServerResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasData {
                output += "\(indent) data {\n"
                if let outDescData = data {
                    output += try outDescData.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasData {
                    if let hashValuedata = data?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuedata
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.TransferToServerResponse"
        }
        override public func className() -> String {
            return "Xla.TransferToServerResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.TransferToServerResponse = Xla.TransferToServerResponse()
            public func getMessage() -> Xla.TransferToServerResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var data:Xla.GlobalDataHandle! {
                get {
                    if dataBuilder_ != nil {
                        builderResult.data = dataBuilder_.getMessage()
                    }
                    return builderResult.data
                }
                set (value) {
                    builderResult.hasData = true
                    builderResult.data = value
                }
            }
            public var hasData:Bool {
                get {
                    return builderResult.hasData
                }
            }
            fileprivate var dataBuilder_:Xla.GlobalDataHandle.Builder! {
                didSet {
                    builderResult.hasData = true
                }
            }
            public func getDataBuilder() -> Xla.GlobalDataHandle.Builder {
                if dataBuilder_ == nil {
                    dataBuilder_ = Xla.GlobalDataHandle.Builder()
                    builderResult.data = dataBuilder_.getMessage()
                    if data != nil {
                        try! dataBuilder_.mergeFrom(other: data)
                    }
                }
                return dataBuilder_
            }
            @discardableResult
            public func setData(_ value:Xla.GlobalDataHandle!) -> Xla.TransferToServerResponse.Builder {
                self.data = value
                return self
            }
            @discardableResult
            public func mergeData(value:Xla.GlobalDataHandle) throws -> Xla.TransferToServerResponse.Builder {
                if builderResult.hasData {
                    builderResult.data = try Xla.GlobalDataHandle.builderWithPrototype(prototype:builderResult.data).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.data = value
                }
                builderResult.hasData = true
                return self
            }
            @discardableResult
            public func clearData() -> Xla.TransferToServerResponse.Builder {
                dataBuilder_ = nil
                builderResult.hasData = false
                builderResult.data = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.TransferToServerResponse.Builder {
                builderResult = Xla.TransferToServerResponse()
                return self
            }
            override public func clone() throws -> Xla.TransferToServerResponse.Builder {
                return try Xla.TransferToServerResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.TransferToServerResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.TransferToServerResponse {
                let returnMe:Xla.TransferToServerResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.TransferToServerResponse) throws -> Xla.TransferToServerResponse.Builder {
                if other == Xla.TransferToServerResponse() {
                    return self
                }
                if (other.hasData) {
                    try mergeData(value: other.data)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.TransferToServerResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToServerResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.GlobalDataHandle.Builder = Xla.GlobalDataHandle.Builder()
                        if hasData {
                            try subBuilder.mergeFrom(other: data)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        data = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.TransferToServerResponse.Builder {
                let resultDecodedBuilder = Xla.TransferToServerResponse.Builder()
                if let jsonValueData = jsonMap["data"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.data = try Xla.GlobalDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueData).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.TransferToServerResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.TransferToServerResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class TransferToServerInProcessRequest : GeneratedMessage {

        public static func == (lhs: Xla.TransferToServerInProcessRequest, rhs: Xla.TransferToServerInProcessRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasBuffer == rhs.hasBuffer) && (!lhs.hasBuffer || lhs.buffer == rhs.buffer)
            fieldCheck = fieldCheck && (lhs.hasShape == rhs.hasShape) && (!lhs.hasShape || lhs.shape == rhs.shape)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var buffer:UInt64 = UInt64(0)
        public fileprivate(set) var hasBuffer:Bool = false

        public fileprivate(set) var shape:Xla.Shape!
        public fileprivate(set) var hasShape:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasBuffer {
                try codedOutputStream.writeUInt64(fieldNumber: 1, value:buffer)
            }
            if hasShape {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:shape)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasBuffer {
                serialize_size += buffer.computeUInt64Size(fieldNumber: 1)
            }
            if hasShape {
                if let varSizeshape = shape?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeshape
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.TransferToServerInProcessRequest.Builder {
            return Xla.TransferToServerInProcessRequest.classBuilder() as! Xla.TransferToServerInProcessRequest.Builder
        }
        public func getBuilder() -> Xla.TransferToServerInProcessRequest.Builder {
            return classBuilder() as! Xla.TransferToServerInProcessRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.TransferToServerInProcessRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.TransferToServerInProcessRequest.Builder()
        }
        public func toBuilder() throws -> Xla.TransferToServerInProcessRequest.Builder {
            return try Xla.TransferToServerInProcessRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.TransferToServerInProcessRequest) throws -> Xla.TransferToServerInProcessRequest.Builder {
            return try Xla.TransferToServerInProcessRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasBuffer {
                jsonMap["buffer"] = "\(buffer)"
            }
            if hasShape {
                jsonMap["shape"] = try shape.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.TransferToServerInProcessRequest {
            return try Xla.TransferToServerInProcessRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.TransferToServerInProcessRequest {
            return try Xla.TransferToServerInProcessRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasBuffer {
                output += "\(indent) buffer: \(buffer) \n"
            }
            if hasShape {
                output += "\(indent) shape {\n"
                if let outDescShape = shape {
                    output += try outDescShape.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasBuffer {
                    hashCode = (hashCode &* 31) &+ buffer.hashValue
                }
                if hasShape {
                    if let hashValueshape = shape?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueshape
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.TransferToServerInProcessRequest"
        }
        override public func className() -> String {
            return "Xla.TransferToServerInProcessRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.TransferToServerInProcessRequest = Xla.TransferToServerInProcessRequest()
            public func getMessage() -> Xla.TransferToServerInProcessRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var buffer:UInt64 {
                get {
                    return builderResult.buffer
                }
                set (value) {
                    builderResult.hasBuffer = true
                    builderResult.buffer = value
                }
            }
            public var hasBuffer:Bool {
                get {
                    return builderResult.hasBuffer
                }
            }
            @discardableResult
            public func setBuffer(_ value:UInt64) -> Xla.TransferToServerInProcessRequest.Builder {
                self.buffer = value
                return self
            }
            @discardableResult
            public func clearBuffer() -> Xla.TransferToServerInProcessRequest.Builder{
                builderResult.hasBuffer = false
                builderResult.buffer = UInt64(0)
                return self
            }
            public var shape:Xla.Shape! {
                get {
                    if shapeBuilder_ != nil {
                        builderResult.shape = shapeBuilder_.getMessage()
                    }
                    return builderResult.shape
                }
                set (value) {
                    builderResult.hasShape = true
                    builderResult.shape = value
                }
            }
            public var hasShape:Bool {
                get {
                    return builderResult.hasShape
                }
            }
            fileprivate var shapeBuilder_:Xla.Shape.Builder! {
                didSet {
                    builderResult.hasShape = true
                }
            }
            public func getShapeBuilder() -> Xla.Shape.Builder {
                if shapeBuilder_ == nil {
                    shapeBuilder_ = Xla.Shape.Builder()
                    builderResult.shape = shapeBuilder_.getMessage()
                    if shape != nil {
                        try! shapeBuilder_.mergeFrom(other: shape)
                    }
                }
                return shapeBuilder_
            }
            @discardableResult
            public func setShape(_ value:Xla.Shape!) -> Xla.TransferToServerInProcessRequest.Builder {
                self.shape = value
                return self
            }
            @discardableResult
            public func mergeShape(value:Xla.Shape) throws -> Xla.TransferToServerInProcessRequest.Builder {
                if builderResult.hasShape {
                    builderResult.shape = try Xla.Shape.builderWithPrototype(prototype:builderResult.shape).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.shape = value
                }
                builderResult.hasShape = true
                return self
            }
            @discardableResult
            public func clearShape() -> Xla.TransferToServerInProcessRequest.Builder {
                shapeBuilder_ = nil
                builderResult.hasShape = false
                builderResult.shape = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.TransferToServerInProcessRequest.Builder {
                builderResult = Xla.TransferToServerInProcessRequest()
                return self
            }
            override public func clone() throws -> Xla.TransferToServerInProcessRequest.Builder {
                return try Xla.TransferToServerInProcessRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.TransferToServerInProcessRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.TransferToServerInProcessRequest {
                let returnMe:Xla.TransferToServerInProcessRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.TransferToServerInProcessRequest) throws -> Xla.TransferToServerInProcessRequest.Builder {
                if other == Xla.TransferToServerInProcessRequest() {
                    return self
                }
                if other.hasBuffer {
                    buffer = other.buffer
                }
                if (other.hasShape) {
                    try mergeShape(value: other.shape)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.TransferToServerInProcessRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToServerInProcessRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        buffer = try codedInputStream.readUInt64()

                    case 18:
                        let subBuilder:Xla.Shape.Builder = Xla.Shape.Builder()
                        if hasShape {
                            try subBuilder.mergeFrom(other: shape)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        shape = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.TransferToServerInProcessRequest.Builder {
                let resultDecodedBuilder = Xla.TransferToServerInProcessRequest.Builder()
                if let jsonValueBuffer = jsonMap["buffer"] as? String {
                    resultDecodedBuilder.buffer = UInt64(jsonValueBuffer)!
                } else if let jsonValueBuffer = jsonMap["buffer"] as? UInt {
                    resultDecodedBuilder.buffer = UInt64(jsonValueBuffer)
                }
                if let jsonValueShape = jsonMap["shape"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.shape = try Xla.Shape.Builder.decodeToBuilder(jsonMap:jsonValueShape).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.TransferToServerInProcessRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.TransferToServerInProcessRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class TransferToServerInProcessResponse : GeneratedMessage {

        public static func == (lhs: Xla.TransferToServerInProcessResponse, rhs: Xla.TransferToServerInProcessResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasData == rhs.hasData) && (!lhs.hasData || lhs.data == rhs.data)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var data:Xla.GlobalDataHandle!
        public fileprivate(set) var hasData:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasData {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:data)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasData {
                if let varSizedata = data?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizedata
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.TransferToServerInProcessResponse.Builder {
            return Xla.TransferToServerInProcessResponse.classBuilder() as! Xla.TransferToServerInProcessResponse.Builder
        }
        public func getBuilder() -> Xla.TransferToServerInProcessResponse.Builder {
            return classBuilder() as! Xla.TransferToServerInProcessResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.TransferToServerInProcessResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.TransferToServerInProcessResponse.Builder()
        }
        public func toBuilder() throws -> Xla.TransferToServerInProcessResponse.Builder {
            return try Xla.TransferToServerInProcessResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.TransferToServerInProcessResponse) throws -> Xla.TransferToServerInProcessResponse.Builder {
            return try Xla.TransferToServerInProcessResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasData {
                jsonMap["data"] = try data.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.TransferToServerInProcessResponse {
            return try Xla.TransferToServerInProcessResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.TransferToServerInProcessResponse {
            return try Xla.TransferToServerInProcessResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasData {
                output += "\(indent) data {\n"
                if let outDescData = data {
                    output += try outDescData.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasData {
                    if let hashValuedata = data?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuedata
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.TransferToServerInProcessResponse"
        }
        override public func className() -> String {
            return "Xla.TransferToServerInProcessResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.TransferToServerInProcessResponse = Xla.TransferToServerInProcessResponse()
            public func getMessage() -> Xla.TransferToServerInProcessResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var data:Xla.GlobalDataHandle! {
                get {
                    if dataBuilder_ != nil {
                        builderResult.data = dataBuilder_.getMessage()
                    }
                    return builderResult.data
                }
                set (value) {
                    builderResult.hasData = true
                    builderResult.data = value
                }
            }
            public var hasData:Bool {
                get {
                    return builderResult.hasData
                }
            }
            fileprivate var dataBuilder_:Xla.GlobalDataHandle.Builder! {
                didSet {
                    builderResult.hasData = true
                }
            }
            public func getDataBuilder() -> Xla.GlobalDataHandle.Builder {
                if dataBuilder_ == nil {
                    dataBuilder_ = Xla.GlobalDataHandle.Builder()
                    builderResult.data = dataBuilder_.getMessage()
                    if data != nil {
                        try! dataBuilder_.mergeFrom(other: data)
                    }
                }
                return dataBuilder_
            }
            @discardableResult
            public func setData(_ value:Xla.GlobalDataHandle!) -> Xla.TransferToServerInProcessResponse.Builder {
                self.data = value
                return self
            }
            @discardableResult
            public func mergeData(value:Xla.GlobalDataHandle) throws -> Xla.TransferToServerInProcessResponse.Builder {
                if builderResult.hasData {
                    builderResult.data = try Xla.GlobalDataHandle.builderWithPrototype(prototype:builderResult.data).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.data = value
                }
                builderResult.hasData = true
                return self
            }
            @discardableResult
            public func clearData() -> Xla.TransferToServerInProcessResponse.Builder {
                dataBuilder_ = nil
                builderResult.hasData = false
                builderResult.data = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.TransferToServerInProcessResponse.Builder {
                builderResult = Xla.TransferToServerInProcessResponse()
                return self
            }
            override public func clone() throws -> Xla.TransferToServerInProcessResponse.Builder {
                return try Xla.TransferToServerInProcessResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.TransferToServerInProcessResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.TransferToServerInProcessResponse {
                let returnMe:Xla.TransferToServerInProcessResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.TransferToServerInProcessResponse) throws -> Xla.TransferToServerInProcessResponse.Builder {
                if other == Xla.TransferToServerInProcessResponse() {
                    return self
                }
                if (other.hasData) {
                    try mergeData(value: other.data)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.TransferToServerInProcessResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToServerInProcessResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.GlobalDataHandle.Builder = Xla.GlobalDataHandle.Builder()
                        if hasData {
                            try subBuilder.mergeFrom(other: data)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        data = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.TransferToServerInProcessResponse.Builder {
                let resultDecodedBuilder = Xla.TransferToServerInProcessResponse.Builder()
                if let jsonValueData = jsonMap["data"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.data = try Xla.GlobalDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueData).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.TransferToServerInProcessResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.TransferToServerInProcessResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class TransferToClientInProcessRequest : GeneratedMessage {

        public static func == (lhs: Xla.TransferToClientInProcessRequest, rhs: Xla.TransferToClientInProcessRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasData == rhs.hasData) && (!lhs.hasData || lhs.data == rhs.data)
            fieldCheck = fieldCheck && (lhs.hasBuffer == rhs.hasBuffer) && (!lhs.hasBuffer || lhs.buffer == rhs.buffer)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var data:Xla.GlobalDataHandle!
        public fileprivate(set) var hasData:Bool = false
        public fileprivate(set) var buffer:UInt64 = UInt64(0)
        public fileprivate(set) var hasBuffer:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasData {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:data)
            }
            if hasBuffer {
                try codedOutputStream.writeUInt64(fieldNumber: 2, value:buffer)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasData {
                if let varSizedata = data?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizedata
                }
            }
            if hasBuffer {
                serialize_size += buffer.computeUInt64Size(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.TransferToClientInProcessRequest.Builder {
            return Xla.TransferToClientInProcessRequest.classBuilder() as! Xla.TransferToClientInProcessRequest.Builder
        }
        public func getBuilder() -> Xla.TransferToClientInProcessRequest.Builder {
            return classBuilder() as! Xla.TransferToClientInProcessRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.TransferToClientInProcessRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.TransferToClientInProcessRequest.Builder()
        }
        public func toBuilder() throws -> Xla.TransferToClientInProcessRequest.Builder {
            return try Xla.TransferToClientInProcessRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.TransferToClientInProcessRequest) throws -> Xla.TransferToClientInProcessRequest.Builder {
            return try Xla.TransferToClientInProcessRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasData {
                jsonMap["data"] = try data.encode()
            }
            if hasBuffer {
                jsonMap["buffer"] = "\(buffer)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.TransferToClientInProcessRequest {
            return try Xla.TransferToClientInProcessRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.TransferToClientInProcessRequest {
            return try Xla.TransferToClientInProcessRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasData {
                output += "\(indent) data {\n"
                if let outDescData = data {
                    output += try outDescData.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasBuffer {
                output += "\(indent) buffer: \(buffer) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasData {
                    if let hashValuedata = data?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuedata
                    }
                }
                if hasBuffer {
                    hashCode = (hashCode &* 31) &+ buffer.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.TransferToClientInProcessRequest"
        }
        override public func className() -> String {
            return "Xla.TransferToClientInProcessRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.TransferToClientInProcessRequest = Xla.TransferToClientInProcessRequest()
            public func getMessage() -> Xla.TransferToClientInProcessRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var data:Xla.GlobalDataHandle! {
                get {
                    if dataBuilder_ != nil {
                        builderResult.data = dataBuilder_.getMessage()
                    }
                    return builderResult.data
                }
                set (value) {
                    builderResult.hasData = true
                    builderResult.data = value
                }
            }
            public var hasData:Bool {
                get {
                    return builderResult.hasData
                }
            }
            fileprivate var dataBuilder_:Xla.GlobalDataHandle.Builder! {
                didSet {
                    builderResult.hasData = true
                }
            }
            public func getDataBuilder() -> Xla.GlobalDataHandle.Builder {
                if dataBuilder_ == nil {
                    dataBuilder_ = Xla.GlobalDataHandle.Builder()
                    builderResult.data = dataBuilder_.getMessage()
                    if data != nil {
                        try! dataBuilder_.mergeFrom(other: data)
                    }
                }
                return dataBuilder_
            }
            @discardableResult
            public func setData(_ value:Xla.GlobalDataHandle!) -> Xla.TransferToClientInProcessRequest.Builder {
                self.data = value
                return self
            }
            @discardableResult
            public func mergeData(value:Xla.GlobalDataHandle) throws -> Xla.TransferToClientInProcessRequest.Builder {
                if builderResult.hasData {
                    builderResult.data = try Xla.GlobalDataHandle.builderWithPrototype(prototype:builderResult.data).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.data = value
                }
                builderResult.hasData = true
                return self
            }
            @discardableResult
            public func clearData() -> Xla.TransferToClientInProcessRequest.Builder {
                dataBuilder_ = nil
                builderResult.hasData = false
                builderResult.data = nil
                return self
            }
            public var buffer:UInt64 {
                get {
                    return builderResult.buffer
                }
                set (value) {
                    builderResult.hasBuffer = true
                    builderResult.buffer = value
                }
            }
            public var hasBuffer:Bool {
                get {
                    return builderResult.hasBuffer
                }
            }
            @discardableResult
            public func setBuffer(_ value:UInt64) -> Xla.TransferToClientInProcessRequest.Builder {
                self.buffer = value
                return self
            }
            @discardableResult
            public func clearBuffer() -> Xla.TransferToClientInProcessRequest.Builder{
                builderResult.hasBuffer = false
                builderResult.buffer = UInt64(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.TransferToClientInProcessRequest.Builder {
                builderResult = Xla.TransferToClientInProcessRequest()
                return self
            }
            override public func clone() throws -> Xla.TransferToClientInProcessRequest.Builder {
                return try Xla.TransferToClientInProcessRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.TransferToClientInProcessRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.TransferToClientInProcessRequest {
                let returnMe:Xla.TransferToClientInProcessRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.TransferToClientInProcessRequest) throws -> Xla.TransferToClientInProcessRequest.Builder {
                if other == Xla.TransferToClientInProcessRequest() {
                    return self
                }
                if (other.hasData) {
                    try mergeData(value: other.data)
                }
                if other.hasBuffer {
                    buffer = other.buffer
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.TransferToClientInProcessRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToClientInProcessRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.GlobalDataHandle.Builder = Xla.GlobalDataHandle.Builder()
                        if hasData {
                            try subBuilder.mergeFrom(other: data)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        data = subBuilder.buildPartial()

                    case 16:
                        buffer = try codedInputStream.readUInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.TransferToClientInProcessRequest.Builder {
                let resultDecodedBuilder = Xla.TransferToClientInProcessRequest.Builder()
                if let jsonValueData = jsonMap["data"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.data = try Xla.GlobalDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueData).build()

                }
                if let jsonValueBuffer = jsonMap["buffer"] as? String {
                    resultDecodedBuilder.buffer = UInt64(jsonValueBuffer)!
                } else if let jsonValueBuffer = jsonMap["buffer"] as? UInt {
                    resultDecodedBuilder.buffer = UInt64(jsonValueBuffer)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.TransferToClientInProcessRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.TransferToClientInProcessRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class TransferToClientInProcessResponse : GeneratedMessage {

        public static func == (lhs: Xla.TransferToClientInProcessResponse, rhs: Xla.TransferToClientInProcessResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.TransferToClientInProcessResponse.Builder {
            return Xla.TransferToClientInProcessResponse.classBuilder() as! Xla.TransferToClientInProcessResponse.Builder
        }
        public func getBuilder() -> Xla.TransferToClientInProcessResponse.Builder {
            return classBuilder() as! Xla.TransferToClientInProcessResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.TransferToClientInProcessResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.TransferToClientInProcessResponse.Builder()
        }
        public func toBuilder() throws -> Xla.TransferToClientInProcessResponse.Builder {
            return try Xla.TransferToClientInProcessResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.TransferToClientInProcessResponse) throws -> Xla.TransferToClientInProcessResponse.Builder {
            return try Xla.TransferToClientInProcessResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.TransferToClientInProcessResponse {
            return try Xla.TransferToClientInProcessResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.TransferToClientInProcessResponse {
            return try Xla.TransferToClientInProcessResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.TransferToClientInProcessResponse"
        }
        override public func className() -> String {
            return "Xla.TransferToClientInProcessResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.TransferToClientInProcessResponse = Xla.TransferToClientInProcessResponse()
            public func getMessage() -> Xla.TransferToClientInProcessResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.TransferToClientInProcessResponse.Builder {
                builderResult = Xla.TransferToClientInProcessResponse()
                return self
            }
            override public func clone() throws -> Xla.TransferToClientInProcessResponse.Builder {
                return try Xla.TransferToClientInProcessResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.TransferToClientInProcessResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.TransferToClientInProcessResponse {
                let returnMe:Xla.TransferToClientInProcessResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.TransferToClientInProcessResponse) throws -> Xla.TransferToClientInProcessResponse.Builder {
                if other == Xla.TransferToClientInProcessResponse() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.TransferToClientInProcessResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToClientInProcessResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.TransferToClientInProcessResponse.Builder {
                let resultDecodedBuilder = Xla.TransferToClientInProcessResponse.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.TransferToClientInProcessResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.TransferToClientInProcessResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class TransferToInfeedRequest : GeneratedMessage {

        public static func == (lhs: Xla.TransferToInfeedRequest, rhs: Xla.TransferToInfeedRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasLiteral == rhs.hasLiteral) && (!lhs.hasLiteral || lhs.literal == rhs.literal)
            fieldCheck = fieldCheck && (lhs.hasReplicaId == rhs.hasReplicaId) && (!lhs.hasReplicaId || lhs.replicaId == rhs.replicaId)
            fieldCheck = fieldCheck && (lhs.hasDeviceHandle == rhs.hasDeviceHandle) && (!lhs.hasDeviceHandle || lhs.deviceHandle == rhs.deviceHandle)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var literal:Xla.Literal!
        public fileprivate(set) var hasLiteral:Bool = false
        public fileprivate(set) var replicaId:Int64 = Int64(0)
        public fileprivate(set) var hasReplicaId:Bool = false

        public fileprivate(set) var deviceHandle:Xla.DeviceHandle!
        public fileprivate(set) var hasDeviceHandle:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasLiteral {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:literal)
            }
            if hasReplicaId {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:replicaId)
            }
            if hasDeviceHandle {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:deviceHandle)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasLiteral {
                if let varSizeliteral = literal?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeliteral
                }
            }
            if hasReplicaId {
                serialize_size += replicaId.computeInt64Size(fieldNumber: 2)
            }
            if hasDeviceHandle {
                if let varSizedeviceHandle = deviceHandle?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizedeviceHandle
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.TransferToInfeedRequest.Builder {
            return Xla.TransferToInfeedRequest.classBuilder() as! Xla.TransferToInfeedRequest.Builder
        }
        public func getBuilder() -> Xla.TransferToInfeedRequest.Builder {
            return classBuilder() as! Xla.TransferToInfeedRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.TransferToInfeedRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.TransferToInfeedRequest.Builder()
        }
        public func toBuilder() throws -> Xla.TransferToInfeedRequest.Builder {
            return try Xla.TransferToInfeedRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.TransferToInfeedRequest) throws -> Xla.TransferToInfeedRequest.Builder {
            return try Xla.TransferToInfeedRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasLiteral {
                jsonMap["literal"] = try literal.encode()
            }
            if hasReplicaId {
                jsonMap["replicaId"] = "\(replicaId)"
            }
            if hasDeviceHandle {
                jsonMap["deviceHandle"] = try deviceHandle.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.TransferToInfeedRequest {
            return try Xla.TransferToInfeedRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.TransferToInfeedRequest {
            return try Xla.TransferToInfeedRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasLiteral {
                output += "\(indent) literal {\n"
                if let outDescLiteral = literal {
                    output += try outDescLiteral.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasReplicaId {
                output += "\(indent) replicaId: \(replicaId) \n"
            }
            if hasDeviceHandle {
                output += "\(indent) deviceHandle {\n"
                if let outDescDeviceHandle = deviceHandle {
                    output += try outDescDeviceHandle.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasLiteral {
                    if let hashValueliteral = literal?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueliteral
                    }
                }
                if hasReplicaId {
                    hashCode = (hashCode &* 31) &+ replicaId.hashValue
                }
                if hasDeviceHandle {
                    if let hashValuedeviceHandle = deviceHandle?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuedeviceHandle
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.TransferToInfeedRequest"
        }
        override public func className() -> String {
            return "Xla.TransferToInfeedRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.TransferToInfeedRequest = Xla.TransferToInfeedRequest()
            public func getMessage() -> Xla.TransferToInfeedRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var literal:Xla.Literal! {
                get {
                    if literalBuilder_ != nil {
                        builderResult.literal = literalBuilder_.getMessage()
                    }
                    return builderResult.literal
                }
                set (value) {
                    builderResult.hasLiteral = true
                    builderResult.literal = value
                }
            }
            public var hasLiteral:Bool {
                get {
                    return builderResult.hasLiteral
                }
            }
            fileprivate var literalBuilder_:Xla.Literal.Builder! {
                didSet {
                    builderResult.hasLiteral = true
                }
            }
            public func getLiteralBuilder() -> Xla.Literal.Builder {
                if literalBuilder_ == nil {
                    literalBuilder_ = Xla.Literal.Builder()
                    builderResult.literal = literalBuilder_.getMessage()
                    if literal != nil {
                        try! literalBuilder_.mergeFrom(other: literal)
                    }
                }
                return literalBuilder_
            }
            @discardableResult
            public func setLiteral(_ value:Xla.Literal!) -> Xla.TransferToInfeedRequest.Builder {
                self.literal = value
                return self
            }
            @discardableResult
            public func mergeLiteral(value:Xla.Literal) throws -> Xla.TransferToInfeedRequest.Builder {
                if builderResult.hasLiteral {
                    builderResult.literal = try Xla.Literal.builderWithPrototype(prototype:builderResult.literal).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.literal = value
                }
                builderResult.hasLiteral = true
                return self
            }
            @discardableResult
            public func clearLiteral() -> Xla.TransferToInfeedRequest.Builder {
                literalBuilder_ = nil
                builderResult.hasLiteral = false
                builderResult.literal = nil
                return self
            }
            public var replicaId:Int64 {
                get {
                    return builderResult.replicaId
                }
                set (value) {
                    builderResult.hasReplicaId = true
                    builderResult.replicaId = value
                }
            }
            public var hasReplicaId:Bool {
                get {
                    return builderResult.hasReplicaId
                }
            }
            @discardableResult
            public func setReplicaId(_ value:Int64) -> Xla.TransferToInfeedRequest.Builder {
                self.replicaId = value
                return self
            }
            @discardableResult
            public func clearReplicaId() -> Xla.TransferToInfeedRequest.Builder{
                builderResult.hasReplicaId = false
                builderResult.replicaId = Int64(0)
                return self
            }
            public var deviceHandle:Xla.DeviceHandle! {
                get {
                    if deviceHandleBuilder_ != nil {
                        builderResult.deviceHandle = deviceHandleBuilder_.getMessage()
                    }
                    return builderResult.deviceHandle
                }
                set (value) {
                    builderResult.hasDeviceHandle = true
                    builderResult.deviceHandle = value
                }
            }
            public var hasDeviceHandle:Bool {
                get {
                    return builderResult.hasDeviceHandle
                }
            }
            fileprivate var deviceHandleBuilder_:Xla.DeviceHandle.Builder! {
                didSet {
                    builderResult.hasDeviceHandle = true
                }
            }
            public func getDeviceHandleBuilder() -> Xla.DeviceHandle.Builder {
                if deviceHandleBuilder_ == nil {
                    deviceHandleBuilder_ = Xla.DeviceHandle.Builder()
                    builderResult.deviceHandle = deviceHandleBuilder_.getMessage()
                    if deviceHandle != nil {
                        try! deviceHandleBuilder_.mergeFrom(other: deviceHandle)
                    }
                }
                return deviceHandleBuilder_
            }
            @discardableResult
            public func setDeviceHandle(_ value:Xla.DeviceHandle!) -> Xla.TransferToInfeedRequest.Builder {
                self.deviceHandle = value
                return self
            }
            @discardableResult
            public func mergeDeviceHandle(value:Xla.DeviceHandle) throws -> Xla.TransferToInfeedRequest.Builder {
                if builderResult.hasDeviceHandle {
                    builderResult.deviceHandle = try Xla.DeviceHandle.builderWithPrototype(prototype:builderResult.deviceHandle).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.deviceHandle = value
                }
                builderResult.hasDeviceHandle = true
                return self
            }
            @discardableResult
            public func clearDeviceHandle() -> Xla.TransferToInfeedRequest.Builder {
                deviceHandleBuilder_ = nil
                builderResult.hasDeviceHandle = false
                builderResult.deviceHandle = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.TransferToInfeedRequest.Builder {
                builderResult = Xla.TransferToInfeedRequest()
                return self
            }
            override public func clone() throws -> Xla.TransferToInfeedRequest.Builder {
                return try Xla.TransferToInfeedRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.TransferToInfeedRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.TransferToInfeedRequest {
                let returnMe:Xla.TransferToInfeedRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.TransferToInfeedRequest) throws -> Xla.TransferToInfeedRequest.Builder {
                if other == Xla.TransferToInfeedRequest() {
                    return self
                }
                if (other.hasLiteral) {
                    try mergeLiteral(value: other.literal)
                }
                if other.hasReplicaId {
                    replicaId = other.replicaId
                }
                if (other.hasDeviceHandle) {
                    try mergeDeviceHandle(value: other.deviceHandle)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.TransferToInfeedRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToInfeedRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.Literal.Builder = Xla.Literal.Builder()
                        if hasLiteral {
                            try subBuilder.mergeFrom(other: literal)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        literal = subBuilder.buildPartial()

                    case 16:
                        replicaId = try codedInputStream.readInt64()

                    case 26:
                        let subBuilder:Xla.DeviceHandle.Builder = Xla.DeviceHandle.Builder()
                        if hasDeviceHandle {
                            try subBuilder.mergeFrom(other: deviceHandle)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        deviceHandle = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.TransferToInfeedRequest.Builder {
                let resultDecodedBuilder = Xla.TransferToInfeedRequest.Builder()
                if let jsonValueLiteral = jsonMap["literal"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.literal = try Xla.Literal.Builder.decodeToBuilder(jsonMap:jsonValueLiteral).build()

                }
                if let jsonValueReplicaId = jsonMap["replicaId"] as? String {
                    resultDecodedBuilder.replicaId = Int64(jsonValueReplicaId)!
                } else if let jsonValueReplicaId = jsonMap["replicaId"] as? Int {
                    resultDecodedBuilder.replicaId = Int64(jsonValueReplicaId)
                }
                if let jsonValueDeviceHandle = jsonMap["deviceHandle"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.deviceHandle = try Xla.DeviceHandle.Builder.decodeToBuilder(jsonMap:jsonValueDeviceHandle).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.TransferToInfeedRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.TransferToInfeedRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class TransferToInfeedResponse : GeneratedMessage {

        public static func == (lhs: Xla.TransferToInfeedResponse, rhs: Xla.TransferToInfeedResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.TransferToInfeedResponse.Builder {
            return Xla.TransferToInfeedResponse.classBuilder() as! Xla.TransferToInfeedResponse.Builder
        }
        public func getBuilder() -> Xla.TransferToInfeedResponse.Builder {
            return classBuilder() as! Xla.TransferToInfeedResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.TransferToInfeedResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.TransferToInfeedResponse.Builder()
        }
        public func toBuilder() throws -> Xla.TransferToInfeedResponse.Builder {
            return try Xla.TransferToInfeedResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.TransferToInfeedResponse) throws -> Xla.TransferToInfeedResponse.Builder {
            return try Xla.TransferToInfeedResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.TransferToInfeedResponse {
            return try Xla.TransferToInfeedResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.TransferToInfeedResponse {
            return try Xla.TransferToInfeedResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.TransferToInfeedResponse"
        }
        override public func className() -> String {
            return "Xla.TransferToInfeedResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.TransferToInfeedResponse = Xla.TransferToInfeedResponse()
            public func getMessage() -> Xla.TransferToInfeedResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.TransferToInfeedResponse.Builder {
                builderResult = Xla.TransferToInfeedResponse()
                return self
            }
            override public func clone() throws -> Xla.TransferToInfeedResponse.Builder {
                return try Xla.TransferToInfeedResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.TransferToInfeedResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.TransferToInfeedResponse {
                let returnMe:Xla.TransferToInfeedResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.TransferToInfeedResponse) throws -> Xla.TransferToInfeedResponse.Builder {
                if other == Xla.TransferToInfeedResponse() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.TransferToInfeedResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToInfeedResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.TransferToInfeedResponse.Builder {
                let resultDecodedBuilder = Xla.TransferToInfeedResponse.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.TransferToInfeedResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.TransferToInfeedResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class TransferFromOutfeedRequest : GeneratedMessage {

        public static func == (lhs: Xla.TransferFromOutfeedRequest, rhs: Xla.TransferFromOutfeedRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasShapeWithLayout == rhs.hasShapeWithLayout) && (!lhs.hasShapeWithLayout || lhs.shapeWithLayout == rhs.shapeWithLayout)
            fieldCheck = fieldCheck && (lhs.hasReplicaId == rhs.hasReplicaId) && (!lhs.hasReplicaId || lhs.replicaId == rhs.replicaId)
            fieldCheck = fieldCheck && (lhs.hasDeviceHandle == rhs.hasDeviceHandle) && (!lhs.hasDeviceHandle || lhs.deviceHandle == rhs.deviceHandle)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var shapeWithLayout:Xla.Shape!
        public fileprivate(set) var hasShapeWithLayout:Bool = false
        public fileprivate(set) var replicaId:Int64 = Int64(0)
        public fileprivate(set) var hasReplicaId:Bool = false

        public fileprivate(set) var deviceHandle:Xla.DeviceHandle!
        public fileprivate(set) var hasDeviceHandle:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasShapeWithLayout {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:shapeWithLayout)
            }
            if hasReplicaId {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:replicaId)
            }
            if hasDeviceHandle {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:deviceHandle)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasShapeWithLayout {
                if let varSizeshapeWithLayout = shapeWithLayout?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeshapeWithLayout
                }
            }
            if hasReplicaId {
                serialize_size += replicaId.computeInt64Size(fieldNumber: 2)
            }
            if hasDeviceHandle {
                if let varSizedeviceHandle = deviceHandle?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizedeviceHandle
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.TransferFromOutfeedRequest.Builder {
            return Xla.TransferFromOutfeedRequest.classBuilder() as! Xla.TransferFromOutfeedRequest.Builder
        }
        public func getBuilder() -> Xla.TransferFromOutfeedRequest.Builder {
            return classBuilder() as! Xla.TransferFromOutfeedRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.TransferFromOutfeedRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.TransferFromOutfeedRequest.Builder()
        }
        public func toBuilder() throws -> Xla.TransferFromOutfeedRequest.Builder {
            return try Xla.TransferFromOutfeedRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.TransferFromOutfeedRequest) throws -> Xla.TransferFromOutfeedRequest.Builder {
            return try Xla.TransferFromOutfeedRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasShapeWithLayout {
                jsonMap["shapeWithLayout"] = try shapeWithLayout.encode()
            }
            if hasReplicaId {
                jsonMap["replicaId"] = "\(replicaId)"
            }
            if hasDeviceHandle {
                jsonMap["deviceHandle"] = try deviceHandle.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.TransferFromOutfeedRequest {
            return try Xla.TransferFromOutfeedRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.TransferFromOutfeedRequest {
            return try Xla.TransferFromOutfeedRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasShapeWithLayout {
                output += "\(indent) shapeWithLayout {\n"
                if let outDescShapeWithLayout = shapeWithLayout {
                    output += try outDescShapeWithLayout.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasReplicaId {
                output += "\(indent) replicaId: \(replicaId) \n"
            }
            if hasDeviceHandle {
                output += "\(indent) deviceHandle {\n"
                if let outDescDeviceHandle = deviceHandle {
                    output += try outDescDeviceHandle.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasShapeWithLayout {
                    if let hashValueshapeWithLayout = shapeWithLayout?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueshapeWithLayout
                    }
                }
                if hasReplicaId {
                    hashCode = (hashCode &* 31) &+ replicaId.hashValue
                }
                if hasDeviceHandle {
                    if let hashValuedeviceHandle = deviceHandle?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuedeviceHandle
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.TransferFromOutfeedRequest"
        }
        override public func className() -> String {
            return "Xla.TransferFromOutfeedRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.TransferFromOutfeedRequest = Xla.TransferFromOutfeedRequest()
            public func getMessage() -> Xla.TransferFromOutfeedRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// This optional field directs the service to return the literal in this
            /// layout. A shape is used to hold the layout to accommodate tuples.
            public var shapeWithLayout:Xla.Shape! {
                get {
                    if shapeWithLayoutBuilder_ != nil {
                        builderResult.shapeWithLayout = shapeWithLayoutBuilder_.getMessage()
                    }
                    return builderResult.shapeWithLayout
                }
                set (value) {
                    builderResult.hasShapeWithLayout = true
                    builderResult.shapeWithLayout = value
                }
            }
            public var hasShapeWithLayout:Bool {
                get {
                    return builderResult.hasShapeWithLayout
                }
            }
            fileprivate var shapeWithLayoutBuilder_:Xla.Shape.Builder! {
                didSet {
                    builderResult.hasShapeWithLayout = true
                }
            }
            public func getShapeWithLayoutBuilder() -> Xla.Shape.Builder {
                if shapeWithLayoutBuilder_ == nil {
                    shapeWithLayoutBuilder_ = Xla.Shape.Builder()
                    builderResult.shapeWithLayout = shapeWithLayoutBuilder_.getMessage()
                    if shapeWithLayout != nil {
                        try! shapeWithLayoutBuilder_.mergeFrom(other: shapeWithLayout)
                    }
                }
                return shapeWithLayoutBuilder_
            }
            @discardableResult
            public func setShapeWithLayout(_ value:Xla.Shape!) -> Xla.TransferFromOutfeedRequest.Builder {
                self.shapeWithLayout = value
                return self
            }
            @discardableResult
            public func mergeShapeWithLayout(value:Xla.Shape) throws -> Xla.TransferFromOutfeedRequest.Builder {
                if builderResult.hasShapeWithLayout {
                    builderResult.shapeWithLayout = try Xla.Shape.builderWithPrototype(prototype:builderResult.shapeWithLayout).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.shapeWithLayout = value
                }
                builderResult.hasShapeWithLayout = true
                return self
            }
            @discardableResult
            public func clearShapeWithLayout() -> Xla.TransferFromOutfeedRequest.Builder {
                shapeWithLayoutBuilder_ = nil
                builderResult.hasShapeWithLayout = false
                builderResult.shapeWithLayout = nil
                return self
            }
            public var replicaId:Int64 {
                get {
                    return builderResult.replicaId
                }
                set (value) {
                    builderResult.hasReplicaId = true
                    builderResult.replicaId = value
                }
            }
            public var hasReplicaId:Bool {
                get {
                    return builderResult.hasReplicaId
                }
            }
            @discardableResult
            public func setReplicaId(_ value:Int64) -> Xla.TransferFromOutfeedRequest.Builder {
                self.replicaId = value
                return self
            }
            @discardableResult
            public func clearReplicaId() -> Xla.TransferFromOutfeedRequest.Builder{
                builderResult.hasReplicaId = false
                builderResult.replicaId = Int64(0)
                return self
            }
            public var deviceHandle:Xla.DeviceHandle! {
                get {
                    if deviceHandleBuilder_ != nil {
                        builderResult.deviceHandle = deviceHandleBuilder_.getMessage()
                    }
                    return builderResult.deviceHandle
                }
                set (value) {
                    builderResult.hasDeviceHandle = true
                    builderResult.deviceHandle = value
                }
            }
            public var hasDeviceHandle:Bool {
                get {
                    return builderResult.hasDeviceHandle
                }
            }
            fileprivate var deviceHandleBuilder_:Xla.DeviceHandle.Builder! {
                didSet {
                    builderResult.hasDeviceHandle = true
                }
            }
            public func getDeviceHandleBuilder() -> Xla.DeviceHandle.Builder {
                if deviceHandleBuilder_ == nil {
                    deviceHandleBuilder_ = Xla.DeviceHandle.Builder()
                    builderResult.deviceHandle = deviceHandleBuilder_.getMessage()
                    if deviceHandle != nil {
                        try! deviceHandleBuilder_.mergeFrom(other: deviceHandle)
                    }
                }
                return deviceHandleBuilder_
            }
            @discardableResult
            public func setDeviceHandle(_ value:Xla.DeviceHandle!) -> Xla.TransferFromOutfeedRequest.Builder {
                self.deviceHandle = value
                return self
            }
            @discardableResult
            public func mergeDeviceHandle(value:Xla.DeviceHandle) throws -> Xla.TransferFromOutfeedRequest.Builder {
                if builderResult.hasDeviceHandle {
                    builderResult.deviceHandle = try Xla.DeviceHandle.builderWithPrototype(prototype:builderResult.deviceHandle).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.deviceHandle = value
                }
                builderResult.hasDeviceHandle = true
                return self
            }
            @discardableResult
            public func clearDeviceHandle() -> Xla.TransferFromOutfeedRequest.Builder {
                deviceHandleBuilder_ = nil
                builderResult.hasDeviceHandle = false
                builderResult.deviceHandle = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.TransferFromOutfeedRequest.Builder {
                builderResult = Xla.TransferFromOutfeedRequest()
                return self
            }
            override public func clone() throws -> Xla.TransferFromOutfeedRequest.Builder {
                return try Xla.TransferFromOutfeedRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.TransferFromOutfeedRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.TransferFromOutfeedRequest {
                let returnMe:Xla.TransferFromOutfeedRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.TransferFromOutfeedRequest) throws -> Xla.TransferFromOutfeedRequest.Builder {
                if other == Xla.TransferFromOutfeedRequest() {
                    return self
                }
                if (other.hasShapeWithLayout) {
                    try mergeShapeWithLayout(value: other.shapeWithLayout)
                }
                if other.hasReplicaId {
                    replicaId = other.replicaId
                }
                if (other.hasDeviceHandle) {
                    try mergeDeviceHandle(value: other.deviceHandle)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.TransferFromOutfeedRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferFromOutfeedRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.Shape.Builder = Xla.Shape.Builder()
                        if hasShapeWithLayout {
                            try subBuilder.mergeFrom(other: shapeWithLayout)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        shapeWithLayout = subBuilder.buildPartial()

                    case 16:
                        replicaId = try codedInputStream.readInt64()

                    case 26:
                        let subBuilder:Xla.DeviceHandle.Builder = Xla.DeviceHandle.Builder()
                        if hasDeviceHandle {
                            try subBuilder.mergeFrom(other: deviceHandle)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        deviceHandle = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.TransferFromOutfeedRequest.Builder {
                let resultDecodedBuilder = Xla.TransferFromOutfeedRequest.Builder()
                if let jsonValueShapeWithLayout = jsonMap["shapeWithLayout"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.shapeWithLayout = try Xla.Shape.Builder.decodeToBuilder(jsonMap:jsonValueShapeWithLayout).build()

                }
                if let jsonValueReplicaId = jsonMap["replicaId"] as? String {
                    resultDecodedBuilder.replicaId = Int64(jsonValueReplicaId)!
                } else if let jsonValueReplicaId = jsonMap["replicaId"] as? Int {
                    resultDecodedBuilder.replicaId = Int64(jsonValueReplicaId)
                }
                if let jsonValueDeviceHandle = jsonMap["deviceHandle"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.deviceHandle = try Xla.DeviceHandle.Builder.decodeToBuilder(jsonMap:jsonValueDeviceHandle).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.TransferFromOutfeedRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.TransferFromOutfeedRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class TransferFromOutfeedResponse : GeneratedMessage {

        public static func == (lhs: Xla.TransferFromOutfeedResponse, rhs: Xla.TransferFromOutfeedResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasLiteral == rhs.hasLiteral) && (!lhs.hasLiteral || lhs.literal == rhs.literal)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var literal:Xla.Literal!
        public fileprivate(set) var hasLiteral:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasLiteral {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:literal)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasLiteral {
                if let varSizeliteral = literal?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeliteral
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.TransferFromOutfeedResponse.Builder {
            return Xla.TransferFromOutfeedResponse.classBuilder() as! Xla.TransferFromOutfeedResponse.Builder
        }
        public func getBuilder() -> Xla.TransferFromOutfeedResponse.Builder {
            return classBuilder() as! Xla.TransferFromOutfeedResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.TransferFromOutfeedResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.TransferFromOutfeedResponse.Builder()
        }
        public func toBuilder() throws -> Xla.TransferFromOutfeedResponse.Builder {
            return try Xla.TransferFromOutfeedResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.TransferFromOutfeedResponse) throws -> Xla.TransferFromOutfeedResponse.Builder {
            return try Xla.TransferFromOutfeedResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasLiteral {
                jsonMap["literal"] = try literal.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.TransferFromOutfeedResponse {
            return try Xla.TransferFromOutfeedResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.TransferFromOutfeedResponse {
            return try Xla.TransferFromOutfeedResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasLiteral {
                output += "\(indent) literal {\n"
                if let outDescLiteral = literal {
                    output += try outDescLiteral.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasLiteral {
                    if let hashValueliteral = literal?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueliteral
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.TransferFromOutfeedResponse"
        }
        override public func className() -> String {
            return "Xla.TransferFromOutfeedResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.TransferFromOutfeedResponse = Xla.TransferFromOutfeedResponse()
            public func getMessage() -> Xla.TransferFromOutfeedResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var literal:Xla.Literal! {
                get {
                    if literalBuilder_ != nil {
                        builderResult.literal = literalBuilder_.getMessage()
                    }
                    return builderResult.literal
                }
                set (value) {
                    builderResult.hasLiteral = true
                    builderResult.literal = value
                }
            }
            public var hasLiteral:Bool {
                get {
                    return builderResult.hasLiteral
                }
            }
            fileprivate var literalBuilder_:Xla.Literal.Builder! {
                didSet {
                    builderResult.hasLiteral = true
                }
            }
            public func getLiteralBuilder() -> Xla.Literal.Builder {
                if literalBuilder_ == nil {
                    literalBuilder_ = Xla.Literal.Builder()
                    builderResult.literal = literalBuilder_.getMessage()
                    if literal != nil {
                        try! literalBuilder_.mergeFrom(other: literal)
                    }
                }
                return literalBuilder_
            }
            @discardableResult
            public func setLiteral(_ value:Xla.Literal!) -> Xla.TransferFromOutfeedResponse.Builder {
                self.literal = value
                return self
            }
            @discardableResult
            public func mergeLiteral(value:Xla.Literal) throws -> Xla.TransferFromOutfeedResponse.Builder {
                if builderResult.hasLiteral {
                    builderResult.literal = try Xla.Literal.builderWithPrototype(prototype:builderResult.literal).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.literal = value
                }
                builderResult.hasLiteral = true
                return self
            }
            @discardableResult
            public func clearLiteral() -> Xla.TransferFromOutfeedResponse.Builder {
                literalBuilder_ = nil
                builderResult.hasLiteral = false
                builderResult.literal = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.TransferFromOutfeedResponse.Builder {
                builderResult = Xla.TransferFromOutfeedResponse()
                return self
            }
            override public func clone() throws -> Xla.TransferFromOutfeedResponse.Builder {
                return try Xla.TransferFromOutfeedResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.TransferFromOutfeedResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.TransferFromOutfeedResponse {
                let returnMe:Xla.TransferFromOutfeedResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.TransferFromOutfeedResponse) throws -> Xla.TransferFromOutfeedResponse.Builder {
                if other == Xla.TransferFromOutfeedResponse() {
                    return self
                }
                if (other.hasLiteral) {
                    try mergeLiteral(value: other.literal)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.TransferFromOutfeedResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferFromOutfeedResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.Literal.Builder = Xla.Literal.Builder()
                        if hasLiteral {
                            try subBuilder.mergeFrom(other: literal)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        literal = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.TransferFromOutfeedResponse.Builder {
                let resultDecodedBuilder = Xla.TransferFromOutfeedResponse.Builder()
                if let jsonValueLiteral = jsonMap["literal"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.literal = try Xla.Literal.Builder.decodeToBuilder(jsonMap:jsonValueLiteral).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.TransferFromOutfeedResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.TransferFromOutfeedResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ResetDeviceRequest : GeneratedMessage {

        public static func == (lhs: Xla.ResetDeviceRequest, rhs: Xla.ResetDeviceRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasDeviceHandle == rhs.hasDeviceHandle) && (!lhs.hasDeviceHandle || lhs.deviceHandle == rhs.deviceHandle)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var deviceHandle:Xla.DeviceHandle!
        public fileprivate(set) var hasDeviceHandle:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasDeviceHandle {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:deviceHandle)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasDeviceHandle {
                if let varSizedeviceHandle = deviceHandle?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizedeviceHandle
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.ResetDeviceRequest.Builder {
            return Xla.ResetDeviceRequest.classBuilder() as! Xla.ResetDeviceRequest.Builder
        }
        public func getBuilder() -> Xla.ResetDeviceRequest.Builder {
            return classBuilder() as! Xla.ResetDeviceRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ResetDeviceRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ResetDeviceRequest.Builder()
        }
        public func toBuilder() throws -> Xla.ResetDeviceRequest.Builder {
            return try Xla.ResetDeviceRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.ResetDeviceRequest) throws -> Xla.ResetDeviceRequest.Builder {
            return try Xla.ResetDeviceRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasDeviceHandle {
                jsonMap["deviceHandle"] = try deviceHandle.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.ResetDeviceRequest {
            return try Xla.ResetDeviceRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.ResetDeviceRequest {
            return try Xla.ResetDeviceRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasDeviceHandle {
                output += "\(indent) deviceHandle {\n"
                if let outDescDeviceHandle = deviceHandle {
                    output += try outDescDeviceHandle.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasDeviceHandle {
                    if let hashValuedeviceHandle = deviceHandle?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuedeviceHandle
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.ResetDeviceRequest"
        }
        override public func className() -> String {
            return "Xla.ResetDeviceRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.ResetDeviceRequest = Xla.ResetDeviceRequest()
            public func getMessage() -> Xla.ResetDeviceRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var deviceHandle:Xla.DeviceHandle! {
                get {
                    if deviceHandleBuilder_ != nil {
                        builderResult.deviceHandle = deviceHandleBuilder_.getMessage()
                    }
                    return builderResult.deviceHandle
                }
                set (value) {
                    builderResult.hasDeviceHandle = true
                    builderResult.deviceHandle = value
                }
            }
            public var hasDeviceHandle:Bool {
                get {
                    return builderResult.hasDeviceHandle
                }
            }
            fileprivate var deviceHandleBuilder_:Xla.DeviceHandle.Builder! {
                didSet {
                    builderResult.hasDeviceHandle = true
                }
            }
            public func getDeviceHandleBuilder() -> Xla.DeviceHandle.Builder {
                if deviceHandleBuilder_ == nil {
                    deviceHandleBuilder_ = Xla.DeviceHandle.Builder()
                    builderResult.deviceHandle = deviceHandleBuilder_.getMessage()
                    if deviceHandle != nil {
                        try! deviceHandleBuilder_.mergeFrom(other: deviceHandle)
                    }
                }
                return deviceHandleBuilder_
            }
            @discardableResult
            public func setDeviceHandle(_ value:Xla.DeviceHandle!) -> Xla.ResetDeviceRequest.Builder {
                self.deviceHandle = value
                return self
            }
            @discardableResult
            public func mergeDeviceHandle(value:Xla.DeviceHandle) throws -> Xla.ResetDeviceRequest.Builder {
                if builderResult.hasDeviceHandle {
                    builderResult.deviceHandle = try Xla.DeviceHandle.builderWithPrototype(prototype:builderResult.deviceHandle).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.deviceHandle = value
                }
                builderResult.hasDeviceHandle = true
                return self
            }
            @discardableResult
            public func clearDeviceHandle() -> Xla.ResetDeviceRequest.Builder {
                deviceHandleBuilder_ = nil
                builderResult.hasDeviceHandle = false
                builderResult.deviceHandle = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.ResetDeviceRequest.Builder {
                builderResult = Xla.ResetDeviceRequest()
                return self
            }
            override public func clone() throws -> Xla.ResetDeviceRequest.Builder {
                return try Xla.ResetDeviceRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.ResetDeviceRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.ResetDeviceRequest {
                let returnMe:Xla.ResetDeviceRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.ResetDeviceRequest) throws -> Xla.ResetDeviceRequest.Builder {
                if other == Xla.ResetDeviceRequest() {
                    return self
                }
                if (other.hasDeviceHandle) {
                    try mergeDeviceHandle(value: other.deviceHandle)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.ResetDeviceRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ResetDeviceRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.DeviceHandle.Builder = Xla.DeviceHandle.Builder()
                        if hasDeviceHandle {
                            try subBuilder.mergeFrom(other: deviceHandle)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        deviceHandle = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.ResetDeviceRequest.Builder {
                let resultDecodedBuilder = Xla.ResetDeviceRequest.Builder()
                if let jsonValueDeviceHandle = jsonMap["deviceHandle"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.deviceHandle = try Xla.DeviceHandle.Builder.decodeToBuilder(jsonMap:jsonValueDeviceHandle).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.ResetDeviceRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.ResetDeviceRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ResetDeviceResponse : GeneratedMessage {

        public static func == (lhs: Xla.ResetDeviceResponse, rhs: Xla.ResetDeviceResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.ResetDeviceResponse.Builder {
            return Xla.ResetDeviceResponse.classBuilder() as! Xla.ResetDeviceResponse.Builder
        }
        public func getBuilder() -> Xla.ResetDeviceResponse.Builder {
            return classBuilder() as! Xla.ResetDeviceResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ResetDeviceResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ResetDeviceResponse.Builder()
        }
        public func toBuilder() throws -> Xla.ResetDeviceResponse.Builder {
            return try Xla.ResetDeviceResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.ResetDeviceResponse) throws -> Xla.ResetDeviceResponse.Builder {
            return try Xla.ResetDeviceResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.ResetDeviceResponse {
            return try Xla.ResetDeviceResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.ResetDeviceResponse {
            return try Xla.ResetDeviceResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.ResetDeviceResponse"
        }
        override public func className() -> String {
            return "Xla.ResetDeviceResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.ResetDeviceResponse = Xla.ResetDeviceResponse()
            public func getMessage() -> Xla.ResetDeviceResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.ResetDeviceResponse.Builder {
                builderResult = Xla.ResetDeviceResponse()
                return self
            }
            override public func clone() throws -> Xla.ResetDeviceResponse.Builder {
                return try Xla.ResetDeviceResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.ResetDeviceResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.ResetDeviceResponse {
                let returnMe:Xla.ResetDeviceResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.ResetDeviceResponse) throws -> Xla.ResetDeviceResponse.Builder {
                if other == Xla.ResetDeviceResponse() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.ResetDeviceResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ResetDeviceResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.ResetDeviceResponse.Builder {
                let resultDecodedBuilder = Xla.ResetDeviceResponse.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.ResetDeviceResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.ResetDeviceResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ComputationStatsRequest : GeneratedMessage {

        public static func == (lhs: Xla.ComputationStatsRequest, rhs: Xla.ComputationStatsRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasComputation == rhs.hasComputation) && (!lhs.hasComputation || lhs.computation == rhs.computation)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var computation:Xla.ComputationHandle!
        public fileprivate(set) var hasComputation:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasComputation {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:computation)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasComputation {
                if let varSizecomputation = computation?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizecomputation
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.ComputationStatsRequest.Builder {
            return Xla.ComputationStatsRequest.classBuilder() as! Xla.ComputationStatsRequest.Builder
        }
        public func getBuilder() -> Xla.ComputationStatsRequest.Builder {
            return classBuilder() as! Xla.ComputationStatsRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ComputationStatsRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ComputationStatsRequest.Builder()
        }
        public func toBuilder() throws -> Xla.ComputationStatsRequest.Builder {
            return try Xla.ComputationStatsRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.ComputationStatsRequest) throws -> Xla.ComputationStatsRequest.Builder {
            return try Xla.ComputationStatsRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasComputation {
                jsonMap["computation"] = try computation.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.ComputationStatsRequest {
            return try Xla.ComputationStatsRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.ComputationStatsRequest {
            return try Xla.ComputationStatsRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasComputation {
                output += "\(indent) computation {\n"
                if let outDescComputation = computation {
                    output += try outDescComputation.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasComputation {
                    if let hashValuecomputation = computation?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecomputation
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.ComputationStatsRequest"
        }
        override public func className() -> String {
            return "Xla.ComputationStatsRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.ComputationStatsRequest = Xla.ComputationStatsRequest()
            public func getMessage() -> Xla.ComputationStatsRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var computation:Xla.ComputationHandle! {
                get {
                    if computationBuilder_ != nil {
                        builderResult.computation = computationBuilder_.getMessage()
                    }
                    return builderResult.computation
                }
                set (value) {
                    builderResult.hasComputation = true
                    builderResult.computation = value
                }
            }
            public var hasComputation:Bool {
                get {
                    return builderResult.hasComputation
                }
            }
            fileprivate var computationBuilder_:Xla.ComputationHandle.Builder! {
                didSet {
                    builderResult.hasComputation = true
                }
            }
            public func getComputationBuilder() -> Xla.ComputationHandle.Builder {
                if computationBuilder_ == nil {
                    computationBuilder_ = Xla.ComputationHandle.Builder()
                    builderResult.computation = computationBuilder_.getMessage()
                    if computation != nil {
                        try! computationBuilder_.mergeFrom(other: computation)
                    }
                }
                return computationBuilder_
            }
            @discardableResult
            public func setComputation(_ value:Xla.ComputationHandle!) -> Xla.ComputationStatsRequest.Builder {
                self.computation = value
                return self
            }
            @discardableResult
            public func mergeComputation(value:Xla.ComputationHandle) throws -> Xla.ComputationStatsRequest.Builder {
                if builderResult.hasComputation {
                    builderResult.computation = try Xla.ComputationHandle.builderWithPrototype(prototype:builderResult.computation).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.computation = value
                }
                builderResult.hasComputation = true
                return self
            }
            @discardableResult
            public func clearComputation() -> Xla.ComputationStatsRequest.Builder {
                computationBuilder_ = nil
                builderResult.hasComputation = false
                builderResult.computation = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.ComputationStatsRequest.Builder {
                builderResult = Xla.ComputationStatsRequest()
                return self
            }
            override public func clone() throws -> Xla.ComputationStatsRequest.Builder {
                return try Xla.ComputationStatsRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.ComputationStatsRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.ComputationStatsRequest {
                let returnMe:Xla.ComputationStatsRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.ComputationStatsRequest) throws -> Xla.ComputationStatsRequest.Builder {
                if other == Xla.ComputationStatsRequest() {
                    return self
                }
                if (other.hasComputation) {
                    try mergeComputation(value: other.computation)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.ComputationStatsRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputationStatsRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.ComputationHandle.Builder = Xla.ComputationHandle.Builder()
                        if hasComputation {
                            try subBuilder.mergeFrom(other: computation)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        computation = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.ComputationStatsRequest.Builder {
                let resultDecodedBuilder = Xla.ComputationStatsRequest.Builder()
                if let jsonValueComputation = jsonMap["computation"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.computation = try Xla.ComputationHandle.Builder.decodeToBuilder(jsonMap:jsonValueComputation).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.ComputationStatsRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.ComputationStatsRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ComputationStatsResponse : GeneratedMessage {

        public static func == (lhs: Xla.ComputationStatsResponse, rhs: Xla.ComputationStatsResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasStats == rhs.hasStats) && (!lhs.hasStats || lhs.stats == rhs.stats)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var stats:Xla.ComputationStats!
        public fileprivate(set) var hasStats:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasStats {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:stats)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasStats {
                if let varSizestats = stats?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizestats
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.ComputationStatsResponse.Builder {
            return Xla.ComputationStatsResponse.classBuilder() as! Xla.ComputationStatsResponse.Builder
        }
        public func getBuilder() -> Xla.ComputationStatsResponse.Builder {
            return classBuilder() as! Xla.ComputationStatsResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ComputationStatsResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ComputationStatsResponse.Builder()
        }
        public func toBuilder() throws -> Xla.ComputationStatsResponse.Builder {
            return try Xla.ComputationStatsResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.ComputationStatsResponse) throws -> Xla.ComputationStatsResponse.Builder {
            return try Xla.ComputationStatsResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasStats {
                jsonMap["stats"] = try stats.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.ComputationStatsResponse {
            return try Xla.ComputationStatsResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.ComputationStatsResponse {
            return try Xla.ComputationStatsResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasStats {
                output += "\(indent) stats {\n"
                if let outDescStats = stats {
                    output += try outDescStats.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasStats {
                    if let hashValuestats = stats?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuestats
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.ComputationStatsResponse"
        }
        override public func className() -> String {
            return "Xla.ComputationStatsResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.ComputationStatsResponse = Xla.ComputationStatsResponse()
            public func getMessage() -> Xla.ComputationStatsResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var stats:Xla.ComputationStats! {
                get {
                    if statsBuilder_ != nil {
                        builderResult.stats = statsBuilder_.getMessage()
                    }
                    return builderResult.stats
                }
                set (value) {
                    builderResult.hasStats = true
                    builderResult.stats = value
                }
            }
            public var hasStats:Bool {
                get {
                    return builderResult.hasStats
                }
            }
            fileprivate var statsBuilder_:Xla.ComputationStats.Builder! {
                didSet {
                    builderResult.hasStats = true
                }
            }
            public func getStatsBuilder() -> Xla.ComputationStats.Builder {
                if statsBuilder_ == nil {
                    statsBuilder_ = Xla.ComputationStats.Builder()
                    builderResult.stats = statsBuilder_.getMessage()
                    if stats != nil {
                        try! statsBuilder_.mergeFrom(other: stats)
                    }
                }
                return statsBuilder_
            }
            @discardableResult
            public func setStats(_ value:Xla.ComputationStats!) -> Xla.ComputationStatsResponse.Builder {
                self.stats = value
                return self
            }
            @discardableResult
            public func mergeStats(value:Xla.ComputationStats) throws -> Xla.ComputationStatsResponse.Builder {
                if builderResult.hasStats {
                    builderResult.stats = try Xla.ComputationStats.builderWithPrototype(prototype:builderResult.stats).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.stats = value
                }
                builderResult.hasStats = true
                return self
            }
            @discardableResult
            public func clearStats() -> Xla.ComputationStatsResponse.Builder {
                statsBuilder_ = nil
                builderResult.hasStats = false
                builderResult.stats = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.ComputationStatsResponse.Builder {
                builderResult = Xla.ComputationStatsResponse()
                return self
            }
            override public func clone() throws -> Xla.ComputationStatsResponse.Builder {
                return try Xla.ComputationStatsResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.ComputationStatsResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.ComputationStatsResponse {
                let returnMe:Xla.ComputationStatsResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.ComputationStatsResponse) throws -> Xla.ComputationStatsResponse.Builder {
                if other == Xla.ComputationStatsResponse() {
                    return self
                }
                if (other.hasStats) {
                    try mergeStats(value: other.stats)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.ComputationStatsResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputationStatsResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.ComputationStats.Builder = Xla.ComputationStats.Builder()
                        if hasStats {
                            try subBuilder.mergeFrom(other: stats)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        stats = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.ComputationStatsResponse.Builder {
                let resultDecodedBuilder = Xla.ComputationStatsResponse.Builder()
                if let jsonValueStats = jsonMap["stats"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.stats = try Xla.ComputationStats.Builder.decodeToBuilder(jsonMap:jsonValueStats).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.ComputationStatsResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.ComputationStatsResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ComputationRequest : GeneratedMessage {

        public static func == (lhs: Xla.ComputationRequest, rhs: Xla.ComputationRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var name:String = ""
        public fileprivate(set) var hasName:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasName {
                try codedOutputStream.writeString(fieldNumber: 1, value:name)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasName {
                serialize_size += name.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.ComputationRequest.Builder {
            return Xla.ComputationRequest.classBuilder() as! Xla.ComputationRequest.Builder
        }
        public func getBuilder() -> Xla.ComputationRequest.Builder {
            return classBuilder() as! Xla.ComputationRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ComputationRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ComputationRequest.Builder()
        }
        public func toBuilder() throws -> Xla.ComputationRequest.Builder {
            return try Xla.ComputationRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.ComputationRequest) throws -> Xla.ComputationRequest.Builder {
            return try Xla.ComputationRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasName {
                jsonMap["name"] = name
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.ComputationRequest {
            return try Xla.ComputationRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.ComputationRequest {
            return try Xla.ComputationRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasName {
                output += "\(indent) name: \(name) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasName {
                    hashCode = (hashCode &* 31) &+ name.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.ComputationRequest"
        }
        override public func className() -> String {
            return "Xla.ComputationRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.ComputationRequest = Xla.ComputationRequest()
            public func getMessage() -> Xla.ComputationRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var name:String {
                get {
                    return builderResult.name
                }
                set (value) {
                    builderResult.hasName = true
                    builderResult.name = value
                }
            }
            public var hasName:Bool {
                get {
                    return builderResult.hasName
                }
            }
            @discardableResult
            public func setName(_ value:String) -> Xla.ComputationRequest.Builder {
                self.name = value
                return self
            }
            @discardableResult
            public func clearName() -> Xla.ComputationRequest.Builder{
                builderResult.hasName = false
                builderResult.name = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.ComputationRequest.Builder {
                builderResult = Xla.ComputationRequest()
                return self
            }
            override public func clone() throws -> Xla.ComputationRequest.Builder {
                return try Xla.ComputationRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.ComputationRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.ComputationRequest {
                let returnMe:Xla.ComputationRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.ComputationRequest) throws -> Xla.ComputationRequest.Builder {
                if other == Xla.ComputationRequest() {
                    return self
                }
                if other.hasName {
                    name = other.name
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.ComputationRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputationRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        name = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.ComputationRequest.Builder {
                let resultDecodedBuilder = Xla.ComputationRequest.Builder()
                if let jsonValueName = jsonMap["name"] as? String {
                    resultDecodedBuilder.name = jsonValueName
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.ComputationRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.ComputationRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ComputationResponse : GeneratedMessage {

        public static func == (lhs: Xla.ComputationResponse, rhs: Xla.ComputationResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasComputation == rhs.hasComputation) && (!lhs.hasComputation || lhs.computation == rhs.computation)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var computation:Xla.ComputationHandle!
        public fileprivate(set) var hasComputation:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasComputation {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:computation)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasComputation {
                if let varSizecomputation = computation?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizecomputation
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.ComputationResponse.Builder {
            return Xla.ComputationResponse.classBuilder() as! Xla.ComputationResponse.Builder
        }
        public func getBuilder() -> Xla.ComputationResponse.Builder {
            return classBuilder() as! Xla.ComputationResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ComputationResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ComputationResponse.Builder()
        }
        public func toBuilder() throws -> Xla.ComputationResponse.Builder {
            return try Xla.ComputationResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.ComputationResponse) throws -> Xla.ComputationResponse.Builder {
            return try Xla.ComputationResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasComputation {
                jsonMap["computation"] = try computation.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.ComputationResponse {
            return try Xla.ComputationResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.ComputationResponse {
            return try Xla.ComputationResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasComputation {
                output += "\(indent) computation {\n"
                if let outDescComputation = computation {
                    output += try outDescComputation.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasComputation {
                    if let hashValuecomputation = computation?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecomputation
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.ComputationResponse"
        }
        override public func className() -> String {
            return "Xla.ComputationResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.ComputationResponse = Xla.ComputationResponse()
            public func getMessage() -> Xla.ComputationResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var computation:Xla.ComputationHandle! {
                get {
                    if computationBuilder_ != nil {
                        builderResult.computation = computationBuilder_.getMessage()
                    }
                    return builderResult.computation
                }
                set (value) {
                    builderResult.hasComputation = true
                    builderResult.computation = value
                }
            }
            public var hasComputation:Bool {
                get {
                    return builderResult.hasComputation
                }
            }
            fileprivate var computationBuilder_:Xla.ComputationHandle.Builder! {
                didSet {
                    builderResult.hasComputation = true
                }
            }
            public func getComputationBuilder() -> Xla.ComputationHandle.Builder {
                if computationBuilder_ == nil {
                    computationBuilder_ = Xla.ComputationHandle.Builder()
                    builderResult.computation = computationBuilder_.getMessage()
                    if computation != nil {
                        try! computationBuilder_.mergeFrom(other: computation)
                    }
                }
                return computationBuilder_
            }
            @discardableResult
            public func setComputation(_ value:Xla.ComputationHandle!) -> Xla.ComputationResponse.Builder {
                self.computation = value
                return self
            }
            @discardableResult
            public func mergeComputation(value:Xla.ComputationHandle) throws -> Xla.ComputationResponse.Builder {
                if builderResult.hasComputation {
                    builderResult.computation = try Xla.ComputationHandle.builderWithPrototype(prototype:builderResult.computation).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.computation = value
                }
                builderResult.hasComputation = true
                return self
            }
            @discardableResult
            public func clearComputation() -> Xla.ComputationResponse.Builder {
                computationBuilder_ = nil
                builderResult.hasComputation = false
                builderResult.computation = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.ComputationResponse.Builder {
                builderResult = Xla.ComputationResponse()
                return self
            }
            override public func clone() throws -> Xla.ComputationResponse.Builder {
                return try Xla.ComputationResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.ComputationResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.ComputationResponse {
                let returnMe:Xla.ComputationResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.ComputationResponse) throws -> Xla.ComputationResponse.Builder {
                if other == Xla.ComputationResponse() {
                    return self
                }
                if (other.hasComputation) {
                    try mergeComputation(value: other.computation)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.ComputationResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputationResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.ComputationHandle.Builder = Xla.ComputationHandle.Builder()
                        if hasComputation {
                            try subBuilder.mergeFrom(other: computation)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        computation = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.ComputationResponse.Builder {
                let resultDecodedBuilder = Xla.ComputationResponse.Builder()
                if let jsonValueComputation = jsonMap["computation"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.computation = try Xla.ComputationHandle.Builder.decodeToBuilder(jsonMap:jsonValueComputation).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.ComputationResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.ComputationResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class CreateChannelHandleRequest : GeneratedMessage {

        public static func == (lhs: Xla.CreateChannelHandleRequest, rhs: Xla.CreateChannelHandleRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.CreateChannelHandleRequest.Builder {
            return Xla.CreateChannelHandleRequest.classBuilder() as! Xla.CreateChannelHandleRequest.Builder
        }
        public func getBuilder() -> Xla.CreateChannelHandleRequest.Builder {
            return classBuilder() as! Xla.CreateChannelHandleRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.CreateChannelHandleRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.CreateChannelHandleRequest.Builder()
        }
        public func toBuilder() throws -> Xla.CreateChannelHandleRequest.Builder {
            return try Xla.CreateChannelHandleRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.CreateChannelHandleRequest) throws -> Xla.CreateChannelHandleRequest.Builder {
            return try Xla.CreateChannelHandleRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.CreateChannelHandleRequest {
            return try Xla.CreateChannelHandleRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.CreateChannelHandleRequest {
            return try Xla.CreateChannelHandleRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.CreateChannelHandleRequest"
        }
        override public func className() -> String {
            return "Xla.CreateChannelHandleRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.CreateChannelHandleRequest = Xla.CreateChannelHandleRequest()
            public func getMessage() -> Xla.CreateChannelHandleRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.CreateChannelHandleRequest.Builder {
                builderResult = Xla.CreateChannelHandleRequest()
                return self
            }
            override public func clone() throws -> Xla.CreateChannelHandleRequest.Builder {
                return try Xla.CreateChannelHandleRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.CreateChannelHandleRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.CreateChannelHandleRequest {
                let returnMe:Xla.CreateChannelHandleRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.CreateChannelHandleRequest) throws -> Xla.CreateChannelHandleRequest.Builder {
                if other == Xla.CreateChannelHandleRequest() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.CreateChannelHandleRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.CreateChannelHandleRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.CreateChannelHandleRequest.Builder {
                let resultDecodedBuilder = Xla.CreateChannelHandleRequest.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.CreateChannelHandleRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.CreateChannelHandleRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class CreateChannelHandleResponse : GeneratedMessage {

        public static func == (lhs: Xla.CreateChannelHandleResponse, rhs: Xla.CreateChannelHandleResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasChannel == rhs.hasChannel) && (!lhs.hasChannel || lhs.channel == rhs.channel)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var channel:Xla.ChannelHandle!
        public fileprivate(set) var hasChannel:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasChannel {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:channel)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasChannel {
                if let varSizechannel = channel?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizechannel
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.CreateChannelHandleResponse.Builder {
            return Xla.CreateChannelHandleResponse.classBuilder() as! Xla.CreateChannelHandleResponse.Builder
        }
        public func getBuilder() -> Xla.CreateChannelHandleResponse.Builder {
            return classBuilder() as! Xla.CreateChannelHandleResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.CreateChannelHandleResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.CreateChannelHandleResponse.Builder()
        }
        public func toBuilder() throws -> Xla.CreateChannelHandleResponse.Builder {
            return try Xla.CreateChannelHandleResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.CreateChannelHandleResponse) throws -> Xla.CreateChannelHandleResponse.Builder {
            return try Xla.CreateChannelHandleResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasChannel {
                jsonMap["channel"] = try channel.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.CreateChannelHandleResponse {
            return try Xla.CreateChannelHandleResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.CreateChannelHandleResponse {
            return try Xla.CreateChannelHandleResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasChannel {
                output += "\(indent) channel {\n"
                if let outDescChannel = channel {
                    output += try outDescChannel.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasChannel {
                    if let hashValuechannel = channel?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuechannel
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.CreateChannelHandleResponse"
        }
        override public func className() -> String {
            return "Xla.CreateChannelHandleResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.CreateChannelHandleResponse = Xla.CreateChannelHandleResponse()
            public func getMessage() -> Xla.CreateChannelHandleResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var channel:Xla.ChannelHandle! {
                get {
                    if channelBuilder_ != nil {
                        builderResult.channel = channelBuilder_.getMessage()
                    }
                    return builderResult.channel
                }
                set (value) {
                    builderResult.hasChannel = true
                    builderResult.channel = value
                }
            }
            public var hasChannel:Bool {
                get {
                    return builderResult.hasChannel
                }
            }
            fileprivate var channelBuilder_:Xla.ChannelHandle.Builder! {
                didSet {
                    builderResult.hasChannel = true
                }
            }
            public func getChannelBuilder() -> Xla.ChannelHandle.Builder {
                if channelBuilder_ == nil {
                    channelBuilder_ = Xla.ChannelHandle.Builder()
                    builderResult.channel = channelBuilder_.getMessage()
                    if channel != nil {
                        try! channelBuilder_.mergeFrom(other: channel)
                    }
                }
                return channelBuilder_
            }
            @discardableResult
            public func setChannel(_ value:Xla.ChannelHandle!) -> Xla.CreateChannelHandleResponse.Builder {
                self.channel = value
                return self
            }
            @discardableResult
            public func mergeChannel(value:Xla.ChannelHandle) throws -> Xla.CreateChannelHandleResponse.Builder {
                if builderResult.hasChannel {
                    builderResult.channel = try Xla.ChannelHandle.builderWithPrototype(prototype:builderResult.channel).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.channel = value
                }
                builderResult.hasChannel = true
                return self
            }
            @discardableResult
            public func clearChannel() -> Xla.CreateChannelHandleResponse.Builder {
                channelBuilder_ = nil
                builderResult.hasChannel = false
                builderResult.channel = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.CreateChannelHandleResponse.Builder {
                builderResult = Xla.CreateChannelHandleResponse()
                return self
            }
            override public func clone() throws -> Xla.CreateChannelHandleResponse.Builder {
                return try Xla.CreateChannelHandleResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.CreateChannelHandleResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.CreateChannelHandleResponse {
                let returnMe:Xla.CreateChannelHandleResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.CreateChannelHandleResponse) throws -> Xla.CreateChannelHandleResponse.Builder {
                if other == Xla.CreateChannelHandleResponse() {
                    return self
                }
                if (other.hasChannel) {
                    try mergeChannel(value: other.channel)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.CreateChannelHandleResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.CreateChannelHandleResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.ChannelHandle.Builder = Xla.ChannelHandle.Builder()
                        if hasChannel {
                            try subBuilder.mergeFrom(other: channel)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        channel = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.CreateChannelHandleResponse.Builder {
                let resultDecodedBuilder = Xla.CreateChannelHandleResponse.Builder()
                if let jsonValueChannel = jsonMap["channel"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.channel = try Xla.ChannelHandle.Builder.decodeToBuilder(jsonMap:jsonValueChannel).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.CreateChannelHandleResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.CreateChannelHandleResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class UnregisterRequest : GeneratedMessage {

        public static func == (lhs: Xla.UnregisterRequest, rhs: Xla.UnregisterRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasData == rhs.hasData) && (!lhs.hasData || lhs.data == rhs.data)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var data:Xla.GlobalDataHandle!
        public fileprivate(set) var hasData:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasData {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:data)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasData {
                if let varSizedata = data?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizedata
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.UnregisterRequest.Builder {
            return Xla.UnregisterRequest.classBuilder() as! Xla.UnregisterRequest.Builder
        }
        public func getBuilder() -> Xla.UnregisterRequest.Builder {
            return classBuilder() as! Xla.UnregisterRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.UnregisterRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.UnregisterRequest.Builder()
        }
        public func toBuilder() throws -> Xla.UnregisterRequest.Builder {
            return try Xla.UnregisterRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.UnregisterRequest) throws -> Xla.UnregisterRequest.Builder {
            return try Xla.UnregisterRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasData {
                jsonMap["data"] = try data.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.UnregisterRequest {
            return try Xla.UnregisterRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.UnregisterRequest {
            return try Xla.UnregisterRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasData {
                output += "\(indent) data {\n"
                if let outDescData = data {
                    output += try outDescData.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasData {
                    if let hashValuedata = data?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuedata
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.UnregisterRequest"
        }
        override public func className() -> String {
            return "Xla.UnregisterRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.UnregisterRequest = Xla.UnregisterRequest()
            public func getMessage() -> Xla.UnregisterRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var data:Xla.GlobalDataHandle! {
                get {
                    if dataBuilder_ != nil {
                        builderResult.data = dataBuilder_.getMessage()
                    }
                    return builderResult.data
                }
                set (value) {
                    builderResult.hasData = true
                    builderResult.data = value
                }
            }
            public var hasData:Bool {
                get {
                    return builderResult.hasData
                }
            }
            fileprivate var dataBuilder_:Xla.GlobalDataHandle.Builder! {
                didSet {
                    builderResult.hasData = true
                }
            }
            public func getDataBuilder() -> Xla.GlobalDataHandle.Builder {
                if dataBuilder_ == nil {
                    dataBuilder_ = Xla.GlobalDataHandle.Builder()
                    builderResult.data = dataBuilder_.getMessage()
                    if data != nil {
                        try! dataBuilder_.mergeFrom(other: data)
                    }
                }
                return dataBuilder_
            }
            @discardableResult
            public func setData(_ value:Xla.GlobalDataHandle!) -> Xla.UnregisterRequest.Builder {
                self.data = value
                return self
            }
            @discardableResult
            public func mergeData(value:Xla.GlobalDataHandle) throws -> Xla.UnregisterRequest.Builder {
                if builderResult.hasData {
                    builderResult.data = try Xla.GlobalDataHandle.builderWithPrototype(prototype:builderResult.data).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.data = value
                }
                builderResult.hasData = true
                return self
            }
            @discardableResult
            public func clearData() -> Xla.UnregisterRequest.Builder {
                dataBuilder_ = nil
                builderResult.hasData = false
                builderResult.data = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.UnregisterRequest.Builder {
                builderResult = Xla.UnregisterRequest()
                return self
            }
            override public func clone() throws -> Xla.UnregisterRequest.Builder {
                return try Xla.UnregisterRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.UnregisterRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.UnregisterRequest {
                let returnMe:Xla.UnregisterRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.UnregisterRequest) throws -> Xla.UnregisterRequest.Builder {
                if other == Xla.UnregisterRequest() {
                    return self
                }
                if (other.hasData) {
                    try mergeData(value: other.data)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.UnregisterRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.UnregisterRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.GlobalDataHandle.Builder = Xla.GlobalDataHandle.Builder()
                        if hasData {
                            try subBuilder.mergeFrom(other: data)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        data = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.UnregisterRequest.Builder {
                let resultDecodedBuilder = Xla.UnregisterRequest.Builder()
                if let jsonValueData = jsonMap["data"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.data = try Xla.GlobalDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueData).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.UnregisterRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.UnregisterRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class UnregisterResponse : GeneratedMessage {

        public static func == (lhs: Xla.UnregisterResponse, rhs: Xla.UnregisterResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.UnregisterResponse.Builder {
            return Xla.UnregisterResponse.classBuilder() as! Xla.UnregisterResponse.Builder
        }
        public func getBuilder() -> Xla.UnregisterResponse.Builder {
            return classBuilder() as! Xla.UnregisterResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.UnregisterResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.UnregisterResponse.Builder()
        }
        public func toBuilder() throws -> Xla.UnregisterResponse.Builder {
            return try Xla.UnregisterResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.UnregisterResponse) throws -> Xla.UnregisterResponse.Builder {
            return try Xla.UnregisterResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.UnregisterResponse {
            return try Xla.UnregisterResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.UnregisterResponse {
            return try Xla.UnregisterResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.UnregisterResponse"
        }
        override public func className() -> String {
            return "Xla.UnregisterResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.UnregisterResponse = Xla.UnregisterResponse()
            public func getMessage() -> Xla.UnregisterResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.UnregisterResponse.Builder {
                builderResult = Xla.UnregisterResponse()
                return self
            }
            override public func clone() throws -> Xla.UnregisterResponse.Builder {
                return try Xla.UnregisterResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.UnregisterResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.UnregisterResponse {
                let returnMe:Xla.UnregisterResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.UnregisterResponse) throws -> Xla.UnregisterResponse.Builder {
                if other == Xla.UnregisterResponse() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.UnregisterResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.UnregisterResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.UnregisterResponse.Builder {
                let resultDecodedBuilder = Xla.UnregisterResponse.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.UnregisterResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.UnregisterResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class SetReturnValueRequest : GeneratedMessage {

        public static func == (lhs: Xla.SetReturnValueRequest, rhs: Xla.SetReturnValueRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasComputation == rhs.hasComputation) && (!lhs.hasComputation || lhs.computation == rhs.computation)
            fieldCheck = fieldCheck && (lhs.hasOperand == rhs.hasOperand) && (!lhs.hasOperand || lhs.operand == rhs.operand)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var computation:Xla.ComputationHandle!
        public fileprivate(set) var hasComputation:Bool = false
        public fileprivate(set) var operand:Xla.ComputationDataHandle!
        public fileprivate(set) var hasOperand:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasComputation {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:computation)
            }
            if hasOperand {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:operand)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasComputation {
                if let varSizecomputation = computation?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizecomputation
                }
            }
            if hasOperand {
                if let varSizeoperand = operand?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeoperand
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.SetReturnValueRequest.Builder {
            return Xla.SetReturnValueRequest.classBuilder() as! Xla.SetReturnValueRequest.Builder
        }
        public func getBuilder() -> Xla.SetReturnValueRequest.Builder {
            return classBuilder() as! Xla.SetReturnValueRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.SetReturnValueRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.SetReturnValueRequest.Builder()
        }
        public func toBuilder() throws -> Xla.SetReturnValueRequest.Builder {
            return try Xla.SetReturnValueRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.SetReturnValueRequest) throws -> Xla.SetReturnValueRequest.Builder {
            return try Xla.SetReturnValueRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasComputation {
                jsonMap["computation"] = try computation.encode()
            }
            if hasOperand {
                jsonMap["operand"] = try operand.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.SetReturnValueRequest {
            return try Xla.SetReturnValueRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.SetReturnValueRequest {
            return try Xla.SetReturnValueRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasComputation {
                output += "\(indent) computation {\n"
                if let outDescComputation = computation {
                    output += try outDescComputation.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasOperand {
                output += "\(indent) operand {\n"
                if let outDescOperand = operand {
                    output += try outDescOperand.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasComputation {
                    if let hashValuecomputation = computation?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecomputation
                    }
                }
                if hasOperand {
                    if let hashValueoperand = operand?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoperand
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.SetReturnValueRequest"
        }
        override public func className() -> String {
            return "Xla.SetReturnValueRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.SetReturnValueRequest = Xla.SetReturnValueRequest()
            public func getMessage() -> Xla.SetReturnValueRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var computation:Xla.ComputationHandle! {
                get {
                    if computationBuilder_ != nil {
                        builderResult.computation = computationBuilder_.getMessage()
                    }
                    return builderResult.computation
                }
                set (value) {
                    builderResult.hasComputation = true
                    builderResult.computation = value
                }
            }
            public var hasComputation:Bool {
                get {
                    return builderResult.hasComputation
                }
            }
            fileprivate var computationBuilder_:Xla.ComputationHandle.Builder! {
                didSet {
                    builderResult.hasComputation = true
                }
            }
            public func getComputationBuilder() -> Xla.ComputationHandle.Builder {
                if computationBuilder_ == nil {
                    computationBuilder_ = Xla.ComputationHandle.Builder()
                    builderResult.computation = computationBuilder_.getMessage()
                    if computation != nil {
                        try! computationBuilder_.mergeFrom(other: computation)
                    }
                }
                return computationBuilder_
            }
            @discardableResult
            public func setComputation(_ value:Xla.ComputationHandle!) -> Xla.SetReturnValueRequest.Builder {
                self.computation = value
                return self
            }
            @discardableResult
            public func mergeComputation(value:Xla.ComputationHandle) throws -> Xla.SetReturnValueRequest.Builder {
                if builderResult.hasComputation {
                    builderResult.computation = try Xla.ComputationHandle.builderWithPrototype(prototype:builderResult.computation).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.computation = value
                }
                builderResult.hasComputation = true
                return self
            }
            @discardableResult
            public func clearComputation() -> Xla.SetReturnValueRequest.Builder {
                computationBuilder_ = nil
                builderResult.hasComputation = false
                builderResult.computation = nil
                return self
            }
            public var operand:Xla.ComputationDataHandle! {
                get {
                    if operandBuilder_ != nil {
                        builderResult.operand = operandBuilder_.getMessage()
                    }
                    return builderResult.operand
                }
                set (value) {
                    builderResult.hasOperand = true
                    builderResult.operand = value
                }
            }
            public var hasOperand:Bool {
                get {
                    return builderResult.hasOperand
                }
            }
            fileprivate var operandBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasOperand = true
                }
            }
            public func getOperandBuilder() -> Xla.ComputationDataHandle.Builder {
                if operandBuilder_ == nil {
                    operandBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.operand = operandBuilder_.getMessage()
                    if operand != nil {
                        try! operandBuilder_.mergeFrom(other: operand)
                    }
                }
                return operandBuilder_
            }
            @discardableResult
            public func setOperand(_ value:Xla.ComputationDataHandle!) -> Xla.SetReturnValueRequest.Builder {
                self.operand = value
                return self
            }
            @discardableResult
            public func mergeOperand(value:Xla.ComputationDataHandle) throws -> Xla.SetReturnValueRequest.Builder {
                if builderResult.hasOperand {
                    builderResult.operand = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.operand).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.operand = value
                }
                builderResult.hasOperand = true
                return self
            }
            @discardableResult
            public func clearOperand() -> Xla.SetReturnValueRequest.Builder {
                operandBuilder_ = nil
                builderResult.hasOperand = false
                builderResult.operand = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.SetReturnValueRequest.Builder {
                builderResult = Xla.SetReturnValueRequest()
                return self
            }
            override public func clone() throws -> Xla.SetReturnValueRequest.Builder {
                return try Xla.SetReturnValueRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.SetReturnValueRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.SetReturnValueRequest {
                let returnMe:Xla.SetReturnValueRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.SetReturnValueRequest) throws -> Xla.SetReturnValueRequest.Builder {
                if other == Xla.SetReturnValueRequest() {
                    return self
                }
                if (other.hasComputation) {
                    try mergeComputation(value: other.computation)
                }
                if (other.hasOperand) {
                    try mergeOperand(value: other.operand)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.SetReturnValueRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SetReturnValueRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.ComputationHandle.Builder = Xla.ComputationHandle.Builder()
                        if hasComputation {
                            try subBuilder.mergeFrom(other: computation)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        computation = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasOperand {
                            try subBuilder.mergeFrom(other: operand)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        operand = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.SetReturnValueRequest.Builder {
                let resultDecodedBuilder = Xla.SetReturnValueRequest.Builder()
                if let jsonValueComputation = jsonMap["computation"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.computation = try Xla.ComputationHandle.Builder.decodeToBuilder(jsonMap:jsonValueComputation).build()

                }
                if let jsonValueOperand = jsonMap["operand"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.operand = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueOperand).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.SetReturnValueRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.SetReturnValueRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class SetReturnValueResponse : GeneratedMessage {

        public static func == (lhs: Xla.SetReturnValueResponse, rhs: Xla.SetReturnValueResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.SetReturnValueResponse.Builder {
            return Xla.SetReturnValueResponse.classBuilder() as! Xla.SetReturnValueResponse.Builder
        }
        public func getBuilder() -> Xla.SetReturnValueResponse.Builder {
            return classBuilder() as! Xla.SetReturnValueResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.SetReturnValueResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.SetReturnValueResponse.Builder()
        }
        public func toBuilder() throws -> Xla.SetReturnValueResponse.Builder {
            return try Xla.SetReturnValueResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.SetReturnValueResponse) throws -> Xla.SetReturnValueResponse.Builder {
            return try Xla.SetReturnValueResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.SetReturnValueResponse {
            return try Xla.SetReturnValueResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.SetReturnValueResponse {
            return try Xla.SetReturnValueResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.SetReturnValueResponse"
        }
        override public func className() -> String {
            return "Xla.SetReturnValueResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.SetReturnValueResponse = Xla.SetReturnValueResponse()
            public func getMessage() -> Xla.SetReturnValueResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.SetReturnValueResponse.Builder {
                builderResult = Xla.SetReturnValueResponse()
                return self
            }
            override public func clone() throws -> Xla.SetReturnValueResponse.Builder {
                return try Xla.SetReturnValueResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.SetReturnValueResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.SetReturnValueResponse {
                let returnMe:Xla.SetReturnValueResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.SetReturnValueResponse) throws -> Xla.SetReturnValueResponse.Builder {
                if other == Xla.SetReturnValueResponse() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.SetReturnValueResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SetReturnValueResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.SetReturnValueResponse.Builder {
                let resultDecodedBuilder = Xla.SetReturnValueResponse.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.SetReturnValueResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.SetReturnValueResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ExecuteRequest : GeneratedMessage {

        public static func == (lhs: Xla.ExecuteRequest, rhs: Xla.ExecuteRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasComputation == rhs.hasComputation) && (!lhs.hasComputation || lhs.computation == rhs.computation)
            fieldCheck = fieldCheck && (lhs.arguments == rhs.arguments)
            fieldCheck = fieldCheck && (lhs.hasDeviceHandle == rhs.hasDeviceHandle) && (!lhs.hasDeviceHandle || lhs.deviceHandle == rhs.deviceHandle)
            fieldCheck = fieldCheck && (lhs.hasExecutionOptions == rhs.hasExecutionOptions) && (!lhs.hasExecutionOptions || lhs.executionOptions == rhs.executionOptions)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var computation:Xla.ComputationHandle!
        public fileprivate(set) var hasComputation:Bool = false
        public fileprivate(set) var arguments:Array<Xla.GlobalDataHandle>  = Array<Xla.GlobalDataHandle>()
        public fileprivate(set) var deviceHandle:Xla.DeviceHandle!
        public fileprivate(set) var hasDeviceHandle:Bool = false
        public fileprivate(set) var executionOptions:Xla.ExecutionOptions!
        public fileprivate(set) var hasExecutionOptions:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasComputation {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:computation)
            }
            for oneElementArguments in arguments {
                  try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementArguments)
            }
            if hasDeviceHandle {
                try codedOutputStream.writeMessage(fieldNumber: 5, value:deviceHandle)
            }
            if hasExecutionOptions {
                try codedOutputStream.writeMessage(fieldNumber: 6, value:executionOptions)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasComputation {
                if let varSizecomputation = computation?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizecomputation
                }
            }
            for oneElementArguments in arguments {
                serialize_size += oneElementArguments.computeMessageSize(fieldNumber: 2)
            }
            if hasDeviceHandle {
                if let varSizedeviceHandle = deviceHandle?.computeMessageSize(fieldNumber: 5) {
                    serialize_size += varSizedeviceHandle
                }
            }
            if hasExecutionOptions {
                if let varSizeexecutionOptions = executionOptions?.computeMessageSize(fieldNumber: 6) {
                    serialize_size += varSizeexecutionOptions
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.ExecuteRequest.Builder {
            return Xla.ExecuteRequest.classBuilder() as! Xla.ExecuteRequest.Builder
        }
        public func getBuilder() -> Xla.ExecuteRequest.Builder {
            return classBuilder() as! Xla.ExecuteRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ExecuteRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ExecuteRequest.Builder()
        }
        public func toBuilder() throws -> Xla.ExecuteRequest.Builder {
            return try Xla.ExecuteRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.ExecuteRequest) throws -> Xla.ExecuteRequest.Builder {
            return try Xla.ExecuteRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasComputation {
                jsonMap["computation"] = try computation.encode()
            }
            if !arguments.isEmpty {
                var jsonArrayArguments:Array<Dictionary<String,Any>> = []
                for oneValueArguments in arguments {
                    let ecodedMessageArguments = try oneValueArguments.encode()
                    jsonArrayArguments.append(ecodedMessageArguments)
                }
                jsonMap["arguments"] = jsonArrayArguments
            }
            if hasDeviceHandle {
                jsonMap["deviceHandle"] = try deviceHandle.encode()
            }
            if hasExecutionOptions {
                jsonMap["executionOptions"] = try executionOptions.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.ExecuteRequest {
            return try Xla.ExecuteRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.ExecuteRequest {
            return try Xla.ExecuteRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasComputation {
                output += "\(indent) computation {\n"
                if let outDescComputation = computation {
                    output += try outDescComputation.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            var argumentsElementIndex:Int = 0
            for oneElementArguments in arguments {
                output += "\(indent) arguments[\(argumentsElementIndex)] {\n"
                output += try oneElementArguments.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                argumentsElementIndex += 1
            }
            if hasDeviceHandle {
                output += "\(indent) deviceHandle {\n"
                if let outDescDeviceHandle = deviceHandle {
                    output += try outDescDeviceHandle.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasExecutionOptions {
                output += "\(indent) executionOptions {\n"
                if let outDescExecutionOptions = executionOptions {
                    output += try outDescExecutionOptions.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasComputation {
                    if let hashValuecomputation = computation?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecomputation
                    }
                }
                for oneElementArguments in arguments {
                    hashCode = (hashCode &* 31) &+ oneElementArguments.hashValue
                }
                if hasDeviceHandle {
                    if let hashValuedeviceHandle = deviceHandle?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuedeviceHandle
                    }
                }
                if hasExecutionOptions {
                    if let hashValueexecutionOptions = executionOptions?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueexecutionOptions
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.ExecuteRequest"
        }
        override public func className() -> String {
            return "Xla.ExecuteRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.ExecuteRequest = Xla.ExecuteRequest()
            public func getMessage() -> Xla.ExecuteRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var computation:Xla.ComputationHandle! {
                get {
                    if computationBuilder_ != nil {
                        builderResult.computation = computationBuilder_.getMessage()
                    }
                    return builderResult.computation
                }
                set (value) {
                    builderResult.hasComputation = true
                    builderResult.computation = value
                }
            }
            public var hasComputation:Bool {
                get {
                    return builderResult.hasComputation
                }
            }
            fileprivate var computationBuilder_:Xla.ComputationHandle.Builder! {
                didSet {
                    builderResult.hasComputation = true
                }
            }
            public func getComputationBuilder() -> Xla.ComputationHandle.Builder {
                if computationBuilder_ == nil {
                    computationBuilder_ = Xla.ComputationHandle.Builder()
                    builderResult.computation = computationBuilder_.getMessage()
                    if computation != nil {
                        try! computationBuilder_.mergeFrom(other: computation)
                    }
                }
                return computationBuilder_
            }
            @discardableResult
            public func setComputation(_ value:Xla.ComputationHandle!) -> Xla.ExecuteRequest.Builder {
                self.computation = value
                return self
            }
            @discardableResult
            public func mergeComputation(value:Xla.ComputationHandle) throws -> Xla.ExecuteRequest.Builder {
                if builderResult.hasComputation {
                    builderResult.computation = try Xla.ComputationHandle.builderWithPrototype(prototype:builderResult.computation).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.computation = value
                }
                builderResult.hasComputation = true
                return self
            }
            @discardableResult
            public func clearComputation() -> Xla.ExecuteRequest.Builder {
                computationBuilder_ = nil
                builderResult.hasComputation = false
                builderResult.computation = nil
                return self
            }
            public var arguments:Array<Xla.GlobalDataHandle> {
                get {
                    return builderResult.arguments
                }
                set (value) {
                    builderResult.arguments = value
                }
            }
            @discardableResult
            public func setArguments(_ value:Array<Xla.GlobalDataHandle>) -> Xla.ExecuteRequest.Builder {
                self.arguments = value
                return self
            }
            @discardableResult
            public func clearArguments() -> Xla.ExecuteRequest.Builder {
                builderResult.arguments.removeAll(keepingCapacity: false)
                return self
            }
            /// This optional field specifies a particular device to run the computation.
            /// If not provided, the default device will be chosen.
            public var deviceHandle:Xla.DeviceHandle! {
                get {
                    if deviceHandleBuilder_ != nil {
                        builderResult.deviceHandle = deviceHandleBuilder_.getMessage()
                    }
                    return builderResult.deviceHandle
                }
                set (value) {
                    builderResult.hasDeviceHandle = true
                    builderResult.deviceHandle = value
                }
            }
            public var hasDeviceHandle:Bool {
                get {
                    return builderResult.hasDeviceHandle
                }
            }
            fileprivate var deviceHandleBuilder_:Xla.DeviceHandle.Builder! {
                didSet {
                    builderResult.hasDeviceHandle = true
                }
            }
            public func getDeviceHandleBuilder() -> Xla.DeviceHandle.Builder {
                if deviceHandleBuilder_ == nil {
                    deviceHandleBuilder_ = Xla.DeviceHandle.Builder()
                    builderResult.deviceHandle = deviceHandleBuilder_.getMessage()
                    if deviceHandle != nil {
                        try! deviceHandleBuilder_.mergeFrom(other: deviceHandle)
                    }
                }
                return deviceHandleBuilder_
            }
            @discardableResult
            public func setDeviceHandle(_ value:Xla.DeviceHandle!) -> Xla.ExecuteRequest.Builder {
                self.deviceHandle = value
                return self
            }
            @discardableResult
            public func mergeDeviceHandle(value:Xla.DeviceHandle) throws -> Xla.ExecuteRequest.Builder {
                if builderResult.hasDeviceHandle {
                    builderResult.deviceHandle = try Xla.DeviceHandle.builderWithPrototype(prototype:builderResult.deviceHandle).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.deviceHandle = value
                }
                builderResult.hasDeviceHandle = true
                return self
            }
            @discardableResult
            public func clearDeviceHandle() -> Xla.ExecuteRequest.Builder {
                deviceHandleBuilder_ = nil
                builderResult.hasDeviceHandle = false
                builderResult.deviceHandle = nil
                return self
            }
            /// Options that affect how XLA compiles and runs code to service this request.
            public var executionOptions:Xla.ExecutionOptions! {
                get {
                    if executionOptionsBuilder_ != nil {
                        builderResult.executionOptions = executionOptionsBuilder_.getMessage()
                    }
                    return builderResult.executionOptions
                }
                set (value) {
                    builderResult.hasExecutionOptions = true
                    builderResult.executionOptions = value
                }
            }
            public var hasExecutionOptions:Bool {
                get {
                    return builderResult.hasExecutionOptions
                }
            }
            fileprivate var executionOptionsBuilder_:Xla.ExecutionOptions.Builder! {
                didSet {
                    builderResult.hasExecutionOptions = true
                }
            }
            public func getExecutionOptionsBuilder() -> Xla.ExecutionOptions.Builder {
                if executionOptionsBuilder_ == nil {
                    executionOptionsBuilder_ = Xla.ExecutionOptions.Builder()
                    builderResult.executionOptions = executionOptionsBuilder_.getMessage()
                    if executionOptions != nil {
                        try! executionOptionsBuilder_.mergeFrom(other: executionOptions)
                    }
                }
                return executionOptionsBuilder_
            }
            @discardableResult
            public func setExecutionOptions(_ value:Xla.ExecutionOptions!) -> Xla.ExecuteRequest.Builder {
                self.executionOptions = value
                return self
            }
            @discardableResult
            public func mergeExecutionOptions(value:Xla.ExecutionOptions) throws -> Xla.ExecuteRequest.Builder {
                if builderResult.hasExecutionOptions {
                    builderResult.executionOptions = try Xla.ExecutionOptions.builderWithPrototype(prototype:builderResult.executionOptions).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.executionOptions = value
                }
                builderResult.hasExecutionOptions = true
                return self
            }
            @discardableResult
            public func clearExecutionOptions() -> Xla.ExecuteRequest.Builder {
                executionOptionsBuilder_ = nil
                builderResult.hasExecutionOptions = false
                builderResult.executionOptions = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.ExecuteRequest.Builder {
                builderResult = Xla.ExecuteRequest()
                return self
            }
            override public func clone() throws -> Xla.ExecuteRequest.Builder {
                return try Xla.ExecuteRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.ExecuteRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.ExecuteRequest {
                let returnMe:Xla.ExecuteRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.ExecuteRequest) throws -> Xla.ExecuteRequest.Builder {
                if other == Xla.ExecuteRequest() {
                    return self
                }
                if (other.hasComputation) {
                    try mergeComputation(value: other.computation)
                }
                if !other.arguments.isEmpty  {
                     builderResult.arguments += other.arguments
                }
                if (other.hasDeviceHandle) {
                    try mergeDeviceHandle(value: other.deviceHandle)
                }
                if (other.hasExecutionOptions) {
                    try mergeExecutionOptions(value: other.executionOptions)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.ExecuteRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecuteRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.ComputationHandle.Builder = Xla.ComputationHandle.Builder()
                        if hasComputation {
                            try subBuilder.mergeFrom(other: computation)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        computation = subBuilder.buildPartial()

                    case 18:
                        let subBuilder = Xla.GlobalDataHandle.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        arguments.append(subBuilder.buildPartial())

                    case 42:
                        let subBuilder:Xla.DeviceHandle.Builder = Xla.DeviceHandle.Builder()
                        if hasDeviceHandle {
                            try subBuilder.mergeFrom(other: deviceHandle)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        deviceHandle = subBuilder.buildPartial()

                    case 50:
                        let subBuilder:Xla.ExecutionOptions.Builder = Xla.ExecutionOptions.Builder()
                        if hasExecutionOptions {
                            try subBuilder.mergeFrom(other: executionOptions)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        executionOptions = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.ExecuteRequest.Builder {
                let resultDecodedBuilder = Xla.ExecuteRequest.Builder()
                if let jsonValueComputation = jsonMap["computation"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.computation = try Xla.ComputationHandle.Builder.decodeToBuilder(jsonMap:jsonValueComputation).build()

                }
                if let jsonValueArguments = jsonMap["arguments"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayArguments:Array<Xla.GlobalDataHandle> = []
                    for oneValueArguments in jsonValueArguments {
                        let messageFromStringArguments = try Xla.GlobalDataHandle.Builder.decodeToBuilder(jsonMap:oneValueArguments).build()

                        jsonArrayArguments.append(messageFromStringArguments)
                    }
                    resultDecodedBuilder.arguments = jsonArrayArguments
                }
                if let jsonValueDeviceHandle = jsonMap["deviceHandle"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.deviceHandle = try Xla.DeviceHandle.Builder.decodeToBuilder(jsonMap:jsonValueDeviceHandle).build()

                }
                if let jsonValueExecutionOptions = jsonMap["executionOptions"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.executionOptions = try Xla.ExecutionOptions.Builder.decodeToBuilder(jsonMap:jsonValueExecutionOptions).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.ExecuteRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.ExecuteRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ExecuteParallelRequest : GeneratedMessage {

        public static func == (lhs: Xla.ExecuteParallelRequest, rhs: Xla.ExecuteParallelRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.requests == rhs.requests)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var requests:Array<Xla.ExecuteRequest>  = Array<Xla.ExecuteRequest>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementRequests in requests {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementRequests)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementRequests in requests {
                serialize_size += oneElementRequests.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.ExecuteParallelRequest.Builder {
            return Xla.ExecuteParallelRequest.classBuilder() as! Xla.ExecuteParallelRequest.Builder
        }
        public func getBuilder() -> Xla.ExecuteParallelRequest.Builder {
            return classBuilder() as! Xla.ExecuteParallelRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ExecuteParallelRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ExecuteParallelRequest.Builder()
        }
        public func toBuilder() throws -> Xla.ExecuteParallelRequest.Builder {
            return try Xla.ExecuteParallelRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.ExecuteParallelRequest) throws -> Xla.ExecuteParallelRequest.Builder {
            return try Xla.ExecuteParallelRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !requests.isEmpty {
                var jsonArrayRequests:Array<Dictionary<String,Any>> = []
                for oneValueRequests in requests {
                    let ecodedMessageRequests = try oneValueRequests.encode()
                    jsonArrayRequests.append(ecodedMessageRequests)
                }
                jsonMap["requests"] = jsonArrayRequests
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.ExecuteParallelRequest {
            return try Xla.ExecuteParallelRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.ExecuteParallelRequest {
            return try Xla.ExecuteParallelRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var requestsElementIndex:Int = 0
            for oneElementRequests in requests {
                output += "\(indent) requests[\(requestsElementIndex)] {\n"
                output += try oneElementRequests.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                requestsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementRequests in requests {
                    hashCode = (hashCode &* 31) &+ oneElementRequests.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.ExecuteParallelRequest"
        }
        override public func className() -> String {
            return "Xla.ExecuteParallelRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.ExecuteParallelRequest = Xla.ExecuteParallelRequest()
            public func getMessage() -> Xla.ExecuteParallelRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var requests:Array<Xla.ExecuteRequest> {
                get {
                    return builderResult.requests
                }
                set (value) {
                    builderResult.requests = value
                }
            }
            @discardableResult
            public func setRequests(_ value:Array<Xla.ExecuteRequest>) -> Xla.ExecuteParallelRequest.Builder {
                self.requests = value
                return self
            }
            @discardableResult
            public func clearRequests() -> Xla.ExecuteParallelRequest.Builder {
                builderResult.requests.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.ExecuteParallelRequest.Builder {
                builderResult = Xla.ExecuteParallelRequest()
                return self
            }
            override public func clone() throws -> Xla.ExecuteParallelRequest.Builder {
                return try Xla.ExecuteParallelRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.ExecuteParallelRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.ExecuteParallelRequest {
                let returnMe:Xla.ExecuteParallelRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.ExecuteParallelRequest) throws -> Xla.ExecuteParallelRequest.Builder {
                if other == Xla.ExecuteParallelRequest() {
                    return self
                }
                if !other.requests.isEmpty  {
                     builderResult.requests += other.requests
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.ExecuteParallelRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecuteParallelRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Xla.ExecuteRequest.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        requests.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.ExecuteParallelRequest.Builder {
                let resultDecodedBuilder = Xla.ExecuteParallelRequest.Builder()
                if let jsonValueRequests = jsonMap["requests"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayRequests:Array<Xla.ExecuteRequest> = []
                    for oneValueRequests in jsonValueRequests {
                        let messageFromStringRequests = try Xla.ExecuteRequest.Builder.decodeToBuilder(jsonMap:oneValueRequests).build()

                        jsonArrayRequests.append(messageFromStringRequests)
                    }
                    resultDecodedBuilder.requests = jsonArrayRequests
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.ExecuteParallelRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.ExecuteParallelRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ExecuteResponse : GeneratedMessage {

        public static func == (lhs: Xla.ExecuteResponse, rhs: Xla.ExecuteResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasOutput == rhs.hasOutput) && (!lhs.hasOutput || lhs.output == rhs.output)
            fieldCheck = fieldCheck && (lhs.hasProfile == rhs.hasProfile) && (!lhs.hasProfile || lhs.profile == rhs.profile)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var output:Xla.GlobalDataHandle!
        public fileprivate(set) var hasOutput:Bool = false
        public fileprivate(set) var profile:Xla.ExecutionProfile!
        public fileprivate(set) var hasProfile:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasOutput {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:output)
            }
            if hasProfile {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:profile)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasOutput {
                if let varSizeoutput = output?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeoutput
                }
            }
            if hasProfile {
                if let varSizeprofile = profile?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeprofile
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.ExecuteResponse.Builder {
            return Xla.ExecuteResponse.classBuilder() as! Xla.ExecuteResponse.Builder
        }
        public func getBuilder() -> Xla.ExecuteResponse.Builder {
            return classBuilder() as! Xla.ExecuteResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ExecuteResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ExecuteResponse.Builder()
        }
        public func toBuilder() throws -> Xla.ExecuteResponse.Builder {
            return try Xla.ExecuteResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.ExecuteResponse) throws -> Xla.ExecuteResponse.Builder {
            return try Xla.ExecuteResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasOutput {
                jsonMap["output"] = try output.encode()
            }
            if hasProfile {
                jsonMap["profile"] = try profile.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.ExecuteResponse {
            return try Xla.ExecuteResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.ExecuteResponse {
            return try Xla.ExecuteResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasOutput {
                output += "\(indent) output {\n"
                if let outDescOutput = output {
                    output += try outDescOutput.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasProfile {
                output += "\(indent) profile {\n"
                if let outDescProfile = profile {
                    output += try outDescProfile.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasOutput {
                    if let hashValueoutput = output?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoutput
                    }
                }
                if hasProfile {
                    if let hashValueprofile = profile?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueprofile
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.ExecuteResponse"
        }
        override public func className() -> String {
            return "Xla.ExecuteResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.ExecuteResponse = Xla.ExecuteResponse()
            public func getMessage() -> Xla.ExecuteResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var output:Xla.GlobalDataHandle! {
                get {
                    if outputBuilder_ != nil {
                        builderResult.output = outputBuilder_.getMessage()
                    }
                    return builderResult.output
                }
                set (value) {
                    builderResult.hasOutput = true
                    builderResult.output = value
                }
            }
            public var hasOutput:Bool {
                get {
                    return builderResult.hasOutput
                }
            }
            fileprivate var outputBuilder_:Xla.GlobalDataHandle.Builder! {
                didSet {
                    builderResult.hasOutput = true
                }
            }
            public func getOutputBuilder() -> Xla.GlobalDataHandle.Builder {
                if outputBuilder_ == nil {
                    outputBuilder_ = Xla.GlobalDataHandle.Builder()
                    builderResult.output = outputBuilder_.getMessage()
                    if output != nil {
                        try! outputBuilder_.mergeFrom(other: output)
                    }
                }
                return outputBuilder_
            }
            @discardableResult
            public func setOutput(_ value:Xla.GlobalDataHandle!) -> Xla.ExecuteResponse.Builder {
                self.output = value
                return self
            }
            @discardableResult
            public func mergeOutput(value:Xla.GlobalDataHandle) throws -> Xla.ExecuteResponse.Builder {
                if builderResult.hasOutput {
                    builderResult.output = try Xla.GlobalDataHandle.builderWithPrototype(prototype:builderResult.output).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.output = value
                }
                builderResult.hasOutput = true
                return self
            }
            @discardableResult
            public func clearOutput() -> Xla.ExecuteResponse.Builder {
                outputBuilder_ = nil
                builderResult.hasOutput = false
                builderResult.output = nil
                return self
            }
            public var profile:Xla.ExecutionProfile! {
                get {
                    if profileBuilder_ != nil {
                        builderResult.profile = profileBuilder_.getMessage()
                    }
                    return builderResult.profile
                }
                set (value) {
                    builderResult.hasProfile = true
                    builderResult.profile = value
                }
            }
            public var hasProfile:Bool {
                get {
                    return builderResult.hasProfile
                }
            }
            fileprivate var profileBuilder_:Xla.ExecutionProfile.Builder! {
                didSet {
                    builderResult.hasProfile = true
                }
            }
            public func getProfileBuilder() -> Xla.ExecutionProfile.Builder {
                if profileBuilder_ == nil {
                    profileBuilder_ = Xla.ExecutionProfile.Builder()
                    builderResult.profile = profileBuilder_.getMessage()
                    if profile != nil {
                        try! profileBuilder_.mergeFrom(other: profile)
                    }
                }
                return profileBuilder_
            }
            @discardableResult
            public func setProfile(_ value:Xla.ExecutionProfile!) -> Xla.ExecuteResponse.Builder {
                self.profile = value
                return self
            }
            @discardableResult
            public func mergeProfile(value:Xla.ExecutionProfile) throws -> Xla.ExecuteResponse.Builder {
                if builderResult.hasProfile {
                    builderResult.profile = try Xla.ExecutionProfile.builderWithPrototype(prototype:builderResult.profile).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.profile = value
                }
                builderResult.hasProfile = true
                return self
            }
            @discardableResult
            public func clearProfile() -> Xla.ExecuteResponse.Builder {
                profileBuilder_ = nil
                builderResult.hasProfile = false
                builderResult.profile = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.ExecuteResponse.Builder {
                builderResult = Xla.ExecuteResponse()
                return self
            }
            override public func clone() throws -> Xla.ExecuteResponse.Builder {
                return try Xla.ExecuteResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.ExecuteResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.ExecuteResponse {
                let returnMe:Xla.ExecuteResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.ExecuteResponse) throws -> Xla.ExecuteResponse.Builder {
                if other == Xla.ExecuteResponse() {
                    return self
                }
                if (other.hasOutput) {
                    try mergeOutput(value: other.output)
                }
                if (other.hasProfile) {
                    try mergeProfile(value: other.profile)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.ExecuteResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecuteResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.GlobalDataHandle.Builder = Xla.GlobalDataHandle.Builder()
                        if hasOutput {
                            try subBuilder.mergeFrom(other: output)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        output = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Xla.ExecutionProfile.Builder = Xla.ExecutionProfile.Builder()
                        if hasProfile {
                            try subBuilder.mergeFrom(other: profile)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        profile = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.ExecuteResponse.Builder {
                let resultDecodedBuilder = Xla.ExecuteResponse.Builder()
                if let jsonValueOutput = jsonMap["output"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.output = try Xla.GlobalDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueOutput).build()

                }
                if let jsonValueProfile = jsonMap["profile"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.profile = try Xla.ExecutionProfile.Builder.decodeToBuilder(jsonMap:jsonValueProfile).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.ExecuteResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.ExecuteResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ExecuteParallelResponse : GeneratedMessage {

        public static func == (lhs: Xla.ExecuteParallelResponse, rhs: Xla.ExecuteParallelResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.responses == rhs.responses)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var responses:Array<Xla.ExecuteResponse>  = Array<Xla.ExecuteResponse>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementResponses in responses {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementResponses)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementResponses in responses {
                serialize_size += oneElementResponses.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.ExecuteParallelResponse.Builder {
            return Xla.ExecuteParallelResponse.classBuilder() as! Xla.ExecuteParallelResponse.Builder
        }
        public func getBuilder() -> Xla.ExecuteParallelResponse.Builder {
            return classBuilder() as! Xla.ExecuteParallelResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ExecuteParallelResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ExecuteParallelResponse.Builder()
        }
        public func toBuilder() throws -> Xla.ExecuteParallelResponse.Builder {
            return try Xla.ExecuteParallelResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.ExecuteParallelResponse) throws -> Xla.ExecuteParallelResponse.Builder {
            return try Xla.ExecuteParallelResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !responses.isEmpty {
                var jsonArrayResponses:Array<Dictionary<String,Any>> = []
                for oneValueResponses in responses {
                    let ecodedMessageResponses = try oneValueResponses.encode()
                    jsonArrayResponses.append(ecodedMessageResponses)
                }
                jsonMap["responses"] = jsonArrayResponses
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.ExecuteParallelResponse {
            return try Xla.ExecuteParallelResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.ExecuteParallelResponse {
            return try Xla.ExecuteParallelResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var responsesElementIndex:Int = 0
            for oneElementResponses in responses {
                output += "\(indent) responses[\(responsesElementIndex)] {\n"
                output += try oneElementResponses.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                responsesElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementResponses in responses {
                    hashCode = (hashCode &* 31) &+ oneElementResponses.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.ExecuteParallelResponse"
        }
        override public func className() -> String {
            return "Xla.ExecuteParallelResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.ExecuteParallelResponse = Xla.ExecuteParallelResponse()
            public func getMessage() -> Xla.ExecuteParallelResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var responses:Array<Xla.ExecuteResponse> {
                get {
                    return builderResult.responses
                }
                set (value) {
                    builderResult.responses = value
                }
            }
            @discardableResult
            public func setResponses(_ value:Array<Xla.ExecuteResponse>) -> Xla.ExecuteParallelResponse.Builder {
                self.responses = value
                return self
            }
            @discardableResult
            public func clearResponses() -> Xla.ExecuteParallelResponse.Builder {
                builderResult.responses.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.ExecuteParallelResponse.Builder {
                builderResult = Xla.ExecuteParallelResponse()
                return self
            }
            override public func clone() throws -> Xla.ExecuteParallelResponse.Builder {
                return try Xla.ExecuteParallelResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.ExecuteParallelResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.ExecuteParallelResponse {
                let returnMe:Xla.ExecuteParallelResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.ExecuteParallelResponse) throws -> Xla.ExecuteParallelResponse.Builder {
                if other == Xla.ExecuteParallelResponse() {
                    return self
                }
                if !other.responses.isEmpty  {
                     builderResult.responses += other.responses
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.ExecuteParallelResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecuteParallelResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Xla.ExecuteResponse.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        responses.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.ExecuteParallelResponse.Builder {
                let resultDecodedBuilder = Xla.ExecuteParallelResponse.Builder()
                if let jsonValueResponses = jsonMap["responses"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayResponses:Array<Xla.ExecuteResponse> = []
                    for oneValueResponses in jsonValueResponses {
                        let messageFromStringResponses = try Xla.ExecuteResponse.Builder.decodeToBuilder(jsonMap:oneValueResponses).build()

                        jsonArrayResponses.append(messageFromStringResponses)
                    }
                    resultDecodedBuilder.responses = jsonArrayResponses
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.ExecuteParallelResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.ExecuteParallelResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ExecuteAsyncRequest : GeneratedMessage {

        public static func == (lhs: Xla.ExecuteAsyncRequest, rhs: Xla.ExecuteAsyncRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasComputation == rhs.hasComputation) && (!lhs.hasComputation || lhs.computation == rhs.computation)
            fieldCheck = fieldCheck && (lhs.arguments == rhs.arguments)
            fieldCheck = fieldCheck && (lhs.hasExecutionOptions == rhs.hasExecutionOptions) && (!lhs.hasExecutionOptions || lhs.executionOptions == rhs.executionOptions)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var computation:Xla.ComputationHandle!
        public fileprivate(set) var hasComputation:Bool = false
        public fileprivate(set) var arguments:Array<Xla.GlobalDataHandle>  = Array<Xla.GlobalDataHandle>()
        public fileprivate(set) var executionOptions:Xla.ExecutionOptions!
        public fileprivate(set) var hasExecutionOptions:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasComputation {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:computation)
            }
            for oneElementArguments in arguments {
                  try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementArguments)
            }
            if hasExecutionOptions {
                try codedOutputStream.writeMessage(fieldNumber: 6, value:executionOptions)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasComputation {
                if let varSizecomputation = computation?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizecomputation
                }
            }
            for oneElementArguments in arguments {
                serialize_size += oneElementArguments.computeMessageSize(fieldNumber: 2)
            }
            if hasExecutionOptions {
                if let varSizeexecutionOptions = executionOptions?.computeMessageSize(fieldNumber: 6) {
                    serialize_size += varSizeexecutionOptions
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.ExecuteAsyncRequest.Builder {
            return Xla.ExecuteAsyncRequest.classBuilder() as! Xla.ExecuteAsyncRequest.Builder
        }
        public func getBuilder() -> Xla.ExecuteAsyncRequest.Builder {
            return classBuilder() as! Xla.ExecuteAsyncRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ExecuteAsyncRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ExecuteAsyncRequest.Builder()
        }
        public func toBuilder() throws -> Xla.ExecuteAsyncRequest.Builder {
            return try Xla.ExecuteAsyncRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.ExecuteAsyncRequest) throws -> Xla.ExecuteAsyncRequest.Builder {
            return try Xla.ExecuteAsyncRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasComputation {
                jsonMap["computation"] = try computation.encode()
            }
            if !arguments.isEmpty {
                var jsonArrayArguments:Array<Dictionary<String,Any>> = []
                for oneValueArguments in arguments {
                    let ecodedMessageArguments = try oneValueArguments.encode()
                    jsonArrayArguments.append(ecodedMessageArguments)
                }
                jsonMap["arguments"] = jsonArrayArguments
            }
            if hasExecutionOptions {
                jsonMap["executionOptions"] = try executionOptions.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.ExecuteAsyncRequest {
            return try Xla.ExecuteAsyncRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.ExecuteAsyncRequest {
            return try Xla.ExecuteAsyncRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasComputation {
                output += "\(indent) computation {\n"
                if let outDescComputation = computation {
                    output += try outDescComputation.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            var argumentsElementIndex:Int = 0
            for oneElementArguments in arguments {
                output += "\(indent) arguments[\(argumentsElementIndex)] {\n"
                output += try oneElementArguments.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                argumentsElementIndex += 1
            }
            if hasExecutionOptions {
                output += "\(indent) executionOptions {\n"
                if let outDescExecutionOptions = executionOptions {
                    output += try outDescExecutionOptions.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasComputation {
                    if let hashValuecomputation = computation?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecomputation
                    }
                }
                for oneElementArguments in arguments {
                    hashCode = (hashCode &* 31) &+ oneElementArguments.hashValue
                }
                if hasExecutionOptions {
                    if let hashValueexecutionOptions = executionOptions?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueexecutionOptions
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.ExecuteAsyncRequest"
        }
        override public func className() -> String {
            return "Xla.ExecuteAsyncRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.ExecuteAsyncRequest = Xla.ExecuteAsyncRequest()
            public func getMessage() -> Xla.ExecuteAsyncRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var computation:Xla.ComputationHandle! {
                get {
                    if computationBuilder_ != nil {
                        builderResult.computation = computationBuilder_.getMessage()
                    }
                    return builderResult.computation
                }
                set (value) {
                    builderResult.hasComputation = true
                    builderResult.computation = value
                }
            }
            public var hasComputation:Bool {
                get {
                    return builderResult.hasComputation
                }
            }
            fileprivate var computationBuilder_:Xla.ComputationHandle.Builder! {
                didSet {
                    builderResult.hasComputation = true
                }
            }
            public func getComputationBuilder() -> Xla.ComputationHandle.Builder {
                if computationBuilder_ == nil {
                    computationBuilder_ = Xla.ComputationHandle.Builder()
                    builderResult.computation = computationBuilder_.getMessage()
                    if computation != nil {
                        try! computationBuilder_.mergeFrom(other: computation)
                    }
                }
                return computationBuilder_
            }
            @discardableResult
            public func setComputation(_ value:Xla.ComputationHandle!) -> Xla.ExecuteAsyncRequest.Builder {
                self.computation = value
                return self
            }
            @discardableResult
            public func mergeComputation(value:Xla.ComputationHandle) throws -> Xla.ExecuteAsyncRequest.Builder {
                if builderResult.hasComputation {
                    builderResult.computation = try Xla.ComputationHandle.builderWithPrototype(prototype:builderResult.computation).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.computation = value
                }
                builderResult.hasComputation = true
                return self
            }
            @discardableResult
            public func clearComputation() -> Xla.ExecuteAsyncRequest.Builder {
                computationBuilder_ = nil
                builderResult.hasComputation = false
                builderResult.computation = nil
                return self
            }
            public var arguments:Array<Xla.GlobalDataHandle> {
                get {
                    return builderResult.arguments
                }
                set (value) {
                    builderResult.arguments = value
                }
            }
            @discardableResult
            public func setArguments(_ value:Array<Xla.GlobalDataHandle>) -> Xla.ExecuteAsyncRequest.Builder {
                self.arguments = value
                return self
            }
            @discardableResult
            public func clearArguments() -> Xla.ExecuteAsyncRequest.Builder {
                builderResult.arguments.removeAll(keepingCapacity: false)
                return self
            }
            /// Options that affect how XLA compiles and runs code to service this request.
            public var executionOptions:Xla.ExecutionOptions! {
                get {
                    if executionOptionsBuilder_ != nil {
                        builderResult.executionOptions = executionOptionsBuilder_.getMessage()
                    }
                    return builderResult.executionOptions
                }
                set (value) {
                    builderResult.hasExecutionOptions = true
                    builderResult.executionOptions = value
                }
            }
            public var hasExecutionOptions:Bool {
                get {
                    return builderResult.hasExecutionOptions
                }
            }
            fileprivate var executionOptionsBuilder_:Xla.ExecutionOptions.Builder! {
                didSet {
                    builderResult.hasExecutionOptions = true
                }
            }
            public func getExecutionOptionsBuilder() -> Xla.ExecutionOptions.Builder {
                if executionOptionsBuilder_ == nil {
                    executionOptionsBuilder_ = Xla.ExecutionOptions.Builder()
                    builderResult.executionOptions = executionOptionsBuilder_.getMessage()
                    if executionOptions != nil {
                        try! executionOptionsBuilder_.mergeFrom(other: executionOptions)
                    }
                }
                return executionOptionsBuilder_
            }
            @discardableResult
            public func setExecutionOptions(_ value:Xla.ExecutionOptions!) -> Xla.ExecuteAsyncRequest.Builder {
                self.executionOptions = value
                return self
            }
            @discardableResult
            public func mergeExecutionOptions(value:Xla.ExecutionOptions) throws -> Xla.ExecuteAsyncRequest.Builder {
                if builderResult.hasExecutionOptions {
                    builderResult.executionOptions = try Xla.ExecutionOptions.builderWithPrototype(prototype:builderResult.executionOptions).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.executionOptions = value
                }
                builderResult.hasExecutionOptions = true
                return self
            }
            @discardableResult
            public func clearExecutionOptions() -> Xla.ExecuteAsyncRequest.Builder {
                executionOptionsBuilder_ = nil
                builderResult.hasExecutionOptions = false
                builderResult.executionOptions = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.ExecuteAsyncRequest.Builder {
                builderResult = Xla.ExecuteAsyncRequest()
                return self
            }
            override public func clone() throws -> Xla.ExecuteAsyncRequest.Builder {
                return try Xla.ExecuteAsyncRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.ExecuteAsyncRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.ExecuteAsyncRequest {
                let returnMe:Xla.ExecuteAsyncRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.ExecuteAsyncRequest) throws -> Xla.ExecuteAsyncRequest.Builder {
                if other == Xla.ExecuteAsyncRequest() {
                    return self
                }
                if (other.hasComputation) {
                    try mergeComputation(value: other.computation)
                }
                if !other.arguments.isEmpty  {
                     builderResult.arguments += other.arguments
                }
                if (other.hasExecutionOptions) {
                    try mergeExecutionOptions(value: other.executionOptions)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.ExecuteAsyncRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecuteAsyncRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.ComputationHandle.Builder = Xla.ComputationHandle.Builder()
                        if hasComputation {
                            try subBuilder.mergeFrom(other: computation)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        computation = subBuilder.buildPartial()

                    case 18:
                        let subBuilder = Xla.GlobalDataHandle.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        arguments.append(subBuilder.buildPartial())

                    case 50:
                        let subBuilder:Xla.ExecutionOptions.Builder = Xla.ExecutionOptions.Builder()
                        if hasExecutionOptions {
                            try subBuilder.mergeFrom(other: executionOptions)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        executionOptions = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.ExecuteAsyncRequest.Builder {
                let resultDecodedBuilder = Xla.ExecuteAsyncRequest.Builder()
                if let jsonValueComputation = jsonMap["computation"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.computation = try Xla.ComputationHandle.Builder.decodeToBuilder(jsonMap:jsonValueComputation).build()

                }
                if let jsonValueArguments = jsonMap["arguments"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayArguments:Array<Xla.GlobalDataHandle> = []
                    for oneValueArguments in jsonValueArguments {
                        let messageFromStringArguments = try Xla.GlobalDataHandle.Builder.decodeToBuilder(jsonMap:oneValueArguments).build()

                        jsonArrayArguments.append(messageFromStringArguments)
                    }
                    resultDecodedBuilder.arguments = jsonArrayArguments
                }
                if let jsonValueExecutionOptions = jsonMap["executionOptions"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.executionOptions = try Xla.ExecutionOptions.Builder.decodeToBuilder(jsonMap:jsonValueExecutionOptions).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.ExecuteAsyncRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.ExecuteAsyncRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ExecuteAsyncResponse : GeneratedMessage {

        public static func == (lhs: Xla.ExecuteAsyncResponse, rhs: Xla.ExecuteAsyncResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasExecution == rhs.hasExecution) && (!lhs.hasExecution || lhs.execution == rhs.execution)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var execution:Xla.ExecutionHandle!
        public fileprivate(set) var hasExecution:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasExecution {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:execution)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasExecution {
                if let varSizeexecution = execution?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeexecution
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.ExecuteAsyncResponse.Builder {
            return Xla.ExecuteAsyncResponse.classBuilder() as! Xla.ExecuteAsyncResponse.Builder
        }
        public func getBuilder() -> Xla.ExecuteAsyncResponse.Builder {
            return classBuilder() as! Xla.ExecuteAsyncResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ExecuteAsyncResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ExecuteAsyncResponse.Builder()
        }
        public func toBuilder() throws -> Xla.ExecuteAsyncResponse.Builder {
            return try Xla.ExecuteAsyncResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.ExecuteAsyncResponse) throws -> Xla.ExecuteAsyncResponse.Builder {
            return try Xla.ExecuteAsyncResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasExecution {
                jsonMap["execution"] = try execution.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.ExecuteAsyncResponse {
            return try Xla.ExecuteAsyncResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.ExecuteAsyncResponse {
            return try Xla.ExecuteAsyncResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasExecution {
                output += "\(indent) execution {\n"
                if let outDescExecution = execution {
                    output += try outDescExecution.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasExecution {
                    if let hashValueexecution = execution?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueexecution
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.ExecuteAsyncResponse"
        }
        override public func className() -> String {
            return "Xla.ExecuteAsyncResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.ExecuteAsyncResponse = Xla.ExecuteAsyncResponse()
            public func getMessage() -> Xla.ExecuteAsyncResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// A handle to the execution launched asynchronously.
            public var execution:Xla.ExecutionHandle! {
                get {
                    if executionBuilder_ != nil {
                        builderResult.execution = executionBuilder_.getMessage()
                    }
                    return builderResult.execution
                }
                set (value) {
                    builderResult.hasExecution = true
                    builderResult.execution = value
                }
            }
            public var hasExecution:Bool {
                get {
                    return builderResult.hasExecution
                }
            }
            fileprivate var executionBuilder_:Xla.ExecutionHandle.Builder! {
                didSet {
                    builderResult.hasExecution = true
                }
            }
            public func getExecutionBuilder() -> Xla.ExecutionHandle.Builder {
                if executionBuilder_ == nil {
                    executionBuilder_ = Xla.ExecutionHandle.Builder()
                    builderResult.execution = executionBuilder_.getMessage()
                    if execution != nil {
                        try! executionBuilder_.mergeFrom(other: execution)
                    }
                }
                return executionBuilder_
            }
            @discardableResult
            public func setExecution(_ value:Xla.ExecutionHandle!) -> Xla.ExecuteAsyncResponse.Builder {
                self.execution = value
                return self
            }
            @discardableResult
            public func mergeExecution(value:Xla.ExecutionHandle) throws -> Xla.ExecuteAsyncResponse.Builder {
                if builderResult.hasExecution {
                    builderResult.execution = try Xla.ExecutionHandle.builderWithPrototype(prototype:builderResult.execution).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.execution = value
                }
                builderResult.hasExecution = true
                return self
            }
            @discardableResult
            public func clearExecution() -> Xla.ExecuteAsyncResponse.Builder {
                executionBuilder_ = nil
                builderResult.hasExecution = false
                builderResult.execution = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.ExecuteAsyncResponse.Builder {
                builderResult = Xla.ExecuteAsyncResponse()
                return self
            }
            override public func clone() throws -> Xla.ExecuteAsyncResponse.Builder {
                return try Xla.ExecuteAsyncResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.ExecuteAsyncResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.ExecuteAsyncResponse {
                let returnMe:Xla.ExecuteAsyncResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.ExecuteAsyncResponse) throws -> Xla.ExecuteAsyncResponse.Builder {
                if other == Xla.ExecuteAsyncResponse() {
                    return self
                }
                if (other.hasExecution) {
                    try mergeExecution(value: other.execution)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.ExecuteAsyncResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecuteAsyncResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.ExecutionHandle.Builder = Xla.ExecutionHandle.Builder()
                        if hasExecution {
                            try subBuilder.mergeFrom(other: execution)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        execution = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.ExecuteAsyncResponse.Builder {
                let resultDecodedBuilder = Xla.ExecuteAsyncResponse.Builder()
                if let jsonValueExecution = jsonMap["execution"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.execution = try Xla.ExecutionHandle.Builder.decodeToBuilder(jsonMap:jsonValueExecution).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.ExecuteAsyncResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.ExecuteAsyncResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class WaitForExecutionRequest : GeneratedMessage {

        public static func == (lhs: Xla.WaitForExecutionRequest, rhs: Xla.WaitForExecutionRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasExecution == rhs.hasExecution) && (!lhs.hasExecution || lhs.execution == rhs.execution)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var execution:Xla.ExecutionHandle!
        public fileprivate(set) var hasExecution:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasExecution {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:execution)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasExecution {
                if let varSizeexecution = execution?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeexecution
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.WaitForExecutionRequest.Builder {
            return Xla.WaitForExecutionRequest.classBuilder() as! Xla.WaitForExecutionRequest.Builder
        }
        public func getBuilder() -> Xla.WaitForExecutionRequest.Builder {
            return classBuilder() as! Xla.WaitForExecutionRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.WaitForExecutionRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.WaitForExecutionRequest.Builder()
        }
        public func toBuilder() throws -> Xla.WaitForExecutionRequest.Builder {
            return try Xla.WaitForExecutionRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.WaitForExecutionRequest) throws -> Xla.WaitForExecutionRequest.Builder {
            return try Xla.WaitForExecutionRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasExecution {
                jsonMap["execution"] = try execution.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.WaitForExecutionRequest {
            return try Xla.WaitForExecutionRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.WaitForExecutionRequest {
            return try Xla.WaitForExecutionRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasExecution {
                output += "\(indent) execution {\n"
                if let outDescExecution = execution {
                    output += try outDescExecution.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasExecution {
                    if let hashValueexecution = execution?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueexecution
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.WaitForExecutionRequest"
        }
        override public func className() -> String {
            return "Xla.WaitForExecutionRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.WaitForExecutionRequest = Xla.WaitForExecutionRequest()
            public func getMessage() -> Xla.WaitForExecutionRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var execution:Xla.ExecutionHandle! {
                get {
                    if executionBuilder_ != nil {
                        builderResult.execution = executionBuilder_.getMessage()
                    }
                    return builderResult.execution
                }
                set (value) {
                    builderResult.hasExecution = true
                    builderResult.execution = value
                }
            }
            public var hasExecution:Bool {
                get {
                    return builderResult.hasExecution
                }
            }
            fileprivate var executionBuilder_:Xla.ExecutionHandle.Builder! {
                didSet {
                    builderResult.hasExecution = true
                }
            }
            public func getExecutionBuilder() -> Xla.ExecutionHandle.Builder {
                if executionBuilder_ == nil {
                    executionBuilder_ = Xla.ExecutionHandle.Builder()
                    builderResult.execution = executionBuilder_.getMessage()
                    if execution != nil {
                        try! executionBuilder_.mergeFrom(other: execution)
                    }
                }
                return executionBuilder_
            }
            @discardableResult
            public func setExecution(_ value:Xla.ExecutionHandle!) -> Xla.WaitForExecutionRequest.Builder {
                self.execution = value
                return self
            }
            @discardableResult
            public func mergeExecution(value:Xla.ExecutionHandle) throws -> Xla.WaitForExecutionRequest.Builder {
                if builderResult.hasExecution {
                    builderResult.execution = try Xla.ExecutionHandle.builderWithPrototype(prototype:builderResult.execution).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.execution = value
                }
                builderResult.hasExecution = true
                return self
            }
            @discardableResult
            public func clearExecution() -> Xla.WaitForExecutionRequest.Builder {
                executionBuilder_ = nil
                builderResult.hasExecution = false
                builderResult.execution = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.WaitForExecutionRequest.Builder {
                builderResult = Xla.WaitForExecutionRequest()
                return self
            }
            override public func clone() throws -> Xla.WaitForExecutionRequest.Builder {
                return try Xla.WaitForExecutionRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.WaitForExecutionRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.WaitForExecutionRequest {
                let returnMe:Xla.WaitForExecutionRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.WaitForExecutionRequest) throws -> Xla.WaitForExecutionRequest.Builder {
                if other == Xla.WaitForExecutionRequest() {
                    return self
                }
                if (other.hasExecution) {
                    try mergeExecution(value: other.execution)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.WaitForExecutionRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.WaitForExecutionRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.ExecutionHandle.Builder = Xla.ExecutionHandle.Builder()
                        if hasExecution {
                            try subBuilder.mergeFrom(other: execution)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        execution = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.WaitForExecutionRequest.Builder {
                let resultDecodedBuilder = Xla.WaitForExecutionRequest.Builder()
                if let jsonValueExecution = jsonMap["execution"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.execution = try Xla.ExecutionHandle.Builder.decodeToBuilder(jsonMap:jsonValueExecution).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.WaitForExecutionRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.WaitForExecutionRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class WaitForExecutionResponse : GeneratedMessage {

        public static func == (lhs: Xla.WaitForExecutionResponse, rhs: Xla.WaitForExecutionResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasOutput == rhs.hasOutput) && (!lhs.hasOutput || lhs.output == rhs.output)
            fieldCheck = fieldCheck && (lhs.hasProfile == rhs.hasProfile) && (!lhs.hasProfile || lhs.profile == rhs.profile)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var output:Xla.GlobalDataHandle!
        public fileprivate(set) var hasOutput:Bool = false
        public fileprivate(set) var profile:Xla.ExecutionProfile!
        public fileprivate(set) var hasProfile:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasOutput {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:output)
            }
            if hasProfile {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:profile)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasOutput {
                if let varSizeoutput = output?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeoutput
                }
            }
            if hasProfile {
                if let varSizeprofile = profile?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeprofile
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.WaitForExecutionResponse.Builder {
            return Xla.WaitForExecutionResponse.classBuilder() as! Xla.WaitForExecutionResponse.Builder
        }
        public func getBuilder() -> Xla.WaitForExecutionResponse.Builder {
            return classBuilder() as! Xla.WaitForExecutionResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.WaitForExecutionResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.WaitForExecutionResponse.Builder()
        }
        public func toBuilder() throws -> Xla.WaitForExecutionResponse.Builder {
            return try Xla.WaitForExecutionResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.WaitForExecutionResponse) throws -> Xla.WaitForExecutionResponse.Builder {
            return try Xla.WaitForExecutionResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasOutput {
                jsonMap["output"] = try output.encode()
            }
            if hasProfile {
                jsonMap["profile"] = try profile.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.WaitForExecutionResponse {
            return try Xla.WaitForExecutionResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.WaitForExecutionResponse {
            return try Xla.WaitForExecutionResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasOutput {
                output += "\(indent) output {\n"
                if let outDescOutput = output {
                    output += try outDescOutput.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasProfile {
                output += "\(indent) profile {\n"
                if let outDescProfile = profile {
                    output += try outDescProfile.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasOutput {
                    if let hashValueoutput = output?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoutput
                    }
                }
                if hasProfile {
                    if let hashValueprofile = profile?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueprofile
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.WaitForExecutionResponse"
        }
        override public func className() -> String {
            return "Xla.WaitForExecutionResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.WaitForExecutionResponse = Xla.WaitForExecutionResponse()
            public func getMessage() -> Xla.WaitForExecutionResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var output:Xla.GlobalDataHandle! {
                get {
                    if outputBuilder_ != nil {
                        builderResult.output = outputBuilder_.getMessage()
                    }
                    return builderResult.output
                }
                set (value) {
                    builderResult.hasOutput = true
                    builderResult.output = value
                }
            }
            public var hasOutput:Bool {
                get {
                    return builderResult.hasOutput
                }
            }
            fileprivate var outputBuilder_:Xla.GlobalDataHandle.Builder! {
                didSet {
                    builderResult.hasOutput = true
                }
            }
            public func getOutputBuilder() -> Xla.GlobalDataHandle.Builder {
                if outputBuilder_ == nil {
                    outputBuilder_ = Xla.GlobalDataHandle.Builder()
                    builderResult.output = outputBuilder_.getMessage()
                    if output != nil {
                        try! outputBuilder_.mergeFrom(other: output)
                    }
                }
                return outputBuilder_
            }
            @discardableResult
            public func setOutput(_ value:Xla.GlobalDataHandle!) -> Xla.WaitForExecutionResponse.Builder {
                self.output = value
                return self
            }
            @discardableResult
            public func mergeOutput(value:Xla.GlobalDataHandle) throws -> Xla.WaitForExecutionResponse.Builder {
                if builderResult.hasOutput {
                    builderResult.output = try Xla.GlobalDataHandle.builderWithPrototype(prototype:builderResult.output).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.output = value
                }
                builderResult.hasOutput = true
                return self
            }
            @discardableResult
            public func clearOutput() -> Xla.WaitForExecutionResponse.Builder {
                outputBuilder_ = nil
                builderResult.hasOutput = false
                builderResult.output = nil
                return self
            }
            public var profile:Xla.ExecutionProfile! {
                get {
                    if profileBuilder_ != nil {
                        builderResult.profile = profileBuilder_.getMessage()
                    }
                    return builderResult.profile
                }
                set (value) {
                    builderResult.hasProfile = true
                    builderResult.profile = value
                }
            }
            public var hasProfile:Bool {
                get {
                    return builderResult.hasProfile
                }
            }
            fileprivate var profileBuilder_:Xla.ExecutionProfile.Builder! {
                didSet {
                    builderResult.hasProfile = true
                }
            }
            public func getProfileBuilder() -> Xla.ExecutionProfile.Builder {
                if profileBuilder_ == nil {
                    profileBuilder_ = Xla.ExecutionProfile.Builder()
                    builderResult.profile = profileBuilder_.getMessage()
                    if profile != nil {
                        try! profileBuilder_.mergeFrom(other: profile)
                    }
                }
                return profileBuilder_
            }
            @discardableResult
            public func setProfile(_ value:Xla.ExecutionProfile!) -> Xla.WaitForExecutionResponse.Builder {
                self.profile = value
                return self
            }
            @discardableResult
            public func mergeProfile(value:Xla.ExecutionProfile) throws -> Xla.WaitForExecutionResponse.Builder {
                if builderResult.hasProfile {
                    builderResult.profile = try Xla.ExecutionProfile.builderWithPrototype(prototype:builderResult.profile).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.profile = value
                }
                builderResult.hasProfile = true
                return self
            }
            @discardableResult
            public func clearProfile() -> Xla.WaitForExecutionResponse.Builder {
                profileBuilder_ = nil
                builderResult.hasProfile = false
                builderResult.profile = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.WaitForExecutionResponse.Builder {
                builderResult = Xla.WaitForExecutionResponse()
                return self
            }
            override public func clone() throws -> Xla.WaitForExecutionResponse.Builder {
                return try Xla.WaitForExecutionResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.WaitForExecutionResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.WaitForExecutionResponse {
                let returnMe:Xla.WaitForExecutionResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.WaitForExecutionResponse) throws -> Xla.WaitForExecutionResponse.Builder {
                if other == Xla.WaitForExecutionResponse() {
                    return self
                }
                if (other.hasOutput) {
                    try mergeOutput(value: other.output)
                }
                if (other.hasProfile) {
                    try mergeProfile(value: other.profile)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.WaitForExecutionResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.WaitForExecutionResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.GlobalDataHandle.Builder = Xla.GlobalDataHandle.Builder()
                        if hasOutput {
                            try subBuilder.mergeFrom(other: output)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        output = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Xla.ExecutionProfile.Builder = Xla.ExecutionProfile.Builder()
                        if hasProfile {
                            try subBuilder.mergeFrom(other: profile)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        profile = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.WaitForExecutionResponse.Builder {
                let resultDecodedBuilder = Xla.WaitForExecutionResponse.Builder()
                if let jsonValueOutput = jsonMap["output"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.output = try Xla.GlobalDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueOutput).build()

                }
                if let jsonValueProfile = jsonMap["profile"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.profile = try Xla.ExecutionProfile.Builder.decodeToBuilder(jsonMap:jsonValueProfile).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.WaitForExecutionResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.WaitForExecutionResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class IsConstantRequest : GeneratedMessage {

        public static func == (lhs: Xla.IsConstantRequest, rhs: Xla.IsConstantRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasComputation == rhs.hasComputation) && (!lhs.hasComputation || lhs.computation == rhs.computation)
            fieldCheck = fieldCheck && (lhs.hasOperand == rhs.hasOperand) && (!lhs.hasOperand || lhs.operand == rhs.operand)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var computation:Xla.ComputationHandle!
        public fileprivate(set) var hasComputation:Bool = false
        public fileprivate(set) var operand:Xla.ComputationDataHandle!
        public fileprivate(set) var hasOperand:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasComputation {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:computation)
            }
            if hasOperand {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:operand)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasComputation {
                if let varSizecomputation = computation?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizecomputation
                }
            }
            if hasOperand {
                if let varSizeoperand = operand?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeoperand
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.IsConstantRequest.Builder {
            return Xla.IsConstantRequest.classBuilder() as! Xla.IsConstantRequest.Builder
        }
        public func getBuilder() -> Xla.IsConstantRequest.Builder {
            return classBuilder() as! Xla.IsConstantRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.IsConstantRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.IsConstantRequest.Builder()
        }
        public func toBuilder() throws -> Xla.IsConstantRequest.Builder {
            return try Xla.IsConstantRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.IsConstantRequest) throws -> Xla.IsConstantRequest.Builder {
            return try Xla.IsConstantRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasComputation {
                jsonMap["computation"] = try computation.encode()
            }
            if hasOperand {
                jsonMap["operand"] = try operand.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.IsConstantRequest {
            return try Xla.IsConstantRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.IsConstantRequest {
            return try Xla.IsConstantRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasComputation {
                output += "\(indent) computation {\n"
                if let outDescComputation = computation {
                    output += try outDescComputation.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasOperand {
                output += "\(indent) operand {\n"
                if let outDescOperand = operand {
                    output += try outDescOperand.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasComputation {
                    if let hashValuecomputation = computation?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecomputation
                    }
                }
                if hasOperand {
                    if let hashValueoperand = operand?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoperand
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.IsConstantRequest"
        }
        override public func className() -> String {
            return "Xla.IsConstantRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.IsConstantRequest = Xla.IsConstantRequest()
            public func getMessage() -> Xla.IsConstantRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var computation:Xla.ComputationHandle! {
                get {
                    if computationBuilder_ != nil {
                        builderResult.computation = computationBuilder_.getMessage()
                    }
                    return builderResult.computation
                }
                set (value) {
                    builderResult.hasComputation = true
                    builderResult.computation = value
                }
            }
            public var hasComputation:Bool {
                get {
                    return builderResult.hasComputation
                }
            }
            fileprivate var computationBuilder_:Xla.ComputationHandle.Builder! {
                didSet {
                    builderResult.hasComputation = true
                }
            }
            public func getComputationBuilder() -> Xla.ComputationHandle.Builder {
                if computationBuilder_ == nil {
                    computationBuilder_ = Xla.ComputationHandle.Builder()
                    builderResult.computation = computationBuilder_.getMessage()
                    if computation != nil {
                        try! computationBuilder_.mergeFrom(other: computation)
                    }
                }
                return computationBuilder_
            }
            @discardableResult
            public func setComputation(_ value:Xla.ComputationHandle!) -> Xla.IsConstantRequest.Builder {
                self.computation = value
                return self
            }
            @discardableResult
            public func mergeComputation(value:Xla.ComputationHandle) throws -> Xla.IsConstantRequest.Builder {
                if builderResult.hasComputation {
                    builderResult.computation = try Xla.ComputationHandle.builderWithPrototype(prototype:builderResult.computation).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.computation = value
                }
                builderResult.hasComputation = true
                return self
            }
            @discardableResult
            public func clearComputation() -> Xla.IsConstantRequest.Builder {
                computationBuilder_ = nil
                builderResult.hasComputation = false
                builderResult.computation = nil
                return self
            }
            public var operand:Xla.ComputationDataHandle! {
                get {
                    if operandBuilder_ != nil {
                        builderResult.operand = operandBuilder_.getMessage()
                    }
                    return builderResult.operand
                }
                set (value) {
                    builderResult.hasOperand = true
                    builderResult.operand = value
                }
            }
            public var hasOperand:Bool {
                get {
                    return builderResult.hasOperand
                }
            }
            fileprivate var operandBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasOperand = true
                }
            }
            public func getOperandBuilder() -> Xla.ComputationDataHandle.Builder {
                if operandBuilder_ == nil {
                    operandBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.operand = operandBuilder_.getMessage()
                    if operand != nil {
                        try! operandBuilder_.mergeFrom(other: operand)
                    }
                }
                return operandBuilder_
            }
            @discardableResult
            public func setOperand(_ value:Xla.ComputationDataHandle!) -> Xla.IsConstantRequest.Builder {
                self.operand = value
                return self
            }
            @discardableResult
            public func mergeOperand(value:Xla.ComputationDataHandle) throws -> Xla.IsConstantRequest.Builder {
                if builderResult.hasOperand {
                    builderResult.operand = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.operand).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.operand = value
                }
                builderResult.hasOperand = true
                return self
            }
            @discardableResult
            public func clearOperand() -> Xla.IsConstantRequest.Builder {
                operandBuilder_ = nil
                builderResult.hasOperand = false
                builderResult.operand = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.IsConstantRequest.Builder {
                builderResult = Xla.IsConstantRequest()
                return self
            }
            override public func clone() throws -> Xla.IsConstantRequest.Builder {
                return try Xla.IsConstantRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.IsConstantRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.IsConstantRequest {
                let returnMe:Xla.IsConstantRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.IsConstantRequest) throws -> Xla.IsConstantRequest.Builder {
                if other == Xla.IsConstantRequest() {
                    return self
                }
                if (other.hasComputation) {
                    try mergeComputation(value: other.computation)
                }
                if (other.hasOperand) {
                    try mergeOperand(value: other.operand)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.IsConstantRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.IsConstantRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.ComputationHandle.Builder = Xla.ComputationHandle.Builder()
                        if hasComputation {
                            try subBuilder.mergeFrom(other: computation)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        computation = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasOperand {
                            try subBuilder.mergeFrom(other: operand)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        operand = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.IsConstantRequest.Builder {
                let resultDecodedBuilder = Xla.IsConstantRequest.Builder()
                if let jsonValueComputation = jsonMap["computation"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.computation = try Xla.ComputationHandle.Builder.decodeToBuilder(jsonMap:jsonValueComputation).build()

                }
                if let jsonValueOperand = jsonMap["operand"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.operand = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueOperand).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.IsConstantRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.IsConstantRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class IsConstantResponse : GeneratedMessage {

        public static func == (lhs: Xla.IsConstantResponse, rhs: Xla.IsConstantResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasIsConstant == rhs.hasIsConstant) && (!lhs.hasIsConstant || lhs.isConstant == rhs.isConstant)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var isConstant:Bool = false
        public fileprivate(set) var hasIsConstant:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasIsConstant {
                try codedOutputStream.writeBool(fieldNumber: 1, value:isConstant)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasIsConstant {
                serialize_size += isConstant.computeBoolSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.IsConstantResponse.Builder {
            return Xla.IsConstantResponse.classBuilder() as! Xla.IsConstantResponse.Builder
        }
        public func getBuilder() -> Xla.IsConstantResponse.Builder {
            return classBuilder() as! Xla.IsConstantResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.IsConstantResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.IsConstantResponse.Builder()
        }
        public func toBuilder() throws -> Xla.IsConstantResponse.Builder {
            return try Xla.IsConstantResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.IsConstantResponse) throws -> Xla.IsConstantResponse.Builder {
            return try Xla.IsConstantResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasIsConstant {
                jsonMap["isConstant"] = isConstant
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.IsConstantResponse {
            return try Xla.IsConstantResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.IsConstantResponse {
            return try Xla.IsConstantResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasIsConstant {
                output += "\(indent) isConstant: \(isConstant) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasIsConstant {
                    hashCode = (hashCode &* 31) &+ isConstant.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.IsConstantResponse"
        }
        override public func className() -> String {
            return "Xla.IsConstantResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.IsConstantResponse = Xla.IsConstantResponse()
            public func getMessage() -> Xla.IsConstantResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var isConstant:Bool {
                get {
                    return builderResult.isConstant
                }
                set (value) {
                    builderResult.hasIsConstant = true
                    builderResult.isConstant = value
                }
            }
            public var hasIsConstant:Bool {
                get {
                    return builderResult.hasIsConstant
                }
            }
            @discardableResult
            public func setIsConstant(_ value:Bool) -> Xla.IsConstantResponse.Builder {
                self.isConstant = value
                return self
            }
            @discardableResult
            public func clearIsConstant() -> Xla.IsConstantResponse.Builder{
                builderResult.hasIsConstant = false
                builderResult.isConstant = false
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.IsConstantResponse.Builder {
                builderResult = Xla.IsConstantResponse()
                return self
            }
            override public func clone() throws -> Xla.IsConstantResponse.Builder {
                return try Xla.IsConstantResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.IsConstantResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.IsConstantResponse {
                let returnMe:Xla.IsConstantResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.IsConstantResponse) throws -> Xla.IsConstantResponse.Builder {
                if other == Xla.IsConstantResponse() {
                    return self
                }
                if other.hasIsConstant {
                    isConstant = other.isConstant
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.IsConstantResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.IsConstantResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        isConstant = try codedInputStream.readBool()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.IsConstantResponse.Builder {
                let resultDecodedBuilder = Xla.IsConstantResponse.Builder()
                if let jsonValueIsConstant = jsonMap["isConstant"] as? Bool {
                    resultDecodedBuilder.isConstant = jsonValueIsConstant
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.IsConstantResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.IsConstantResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ComputeConstantRequest : GeneratedMessage {

        public static func == (lhs: Xla.ComputeConstantRequest, rhs: Xla.ComputeConstantRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasComputation == rhs.hasComputation) && (!lhs.hasComputation || lhs.computation == rhs.computation)
            fieldCheck = fieldCheck && (lhs.hasOperand == rhs.hasOperand) && (!lhs.hasOperand || lhs.operand == rhs.operand)
            fieldCheck = fieldCheck && (lhs.hasOutputLayout == rhs.hasOutputLayout) && (!lhs.hasOutputLayout || lhs.outputLayout == rhs.outputLayout)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var computation:Xla.ComputationHandle!
        public fileprivate(set) var hasComputation:Bool = false
        public fileprivate(set) var operand:Xla.ComputationDataHandle!
        public fileprivate(set) var hasOperand:Bool = false
        public fileprivate(set) var outputLayout:Xla.Layout!
        public fileprivate(set) var hasOutputLayout:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasComputation {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:computation)
            }
            if hasOperand {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:operand)
            }
            if hasOutputLayout {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:outputLayout)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasComputation {
                if let varSizecomputation = computation?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizecomputation
                }
            }
            if hasOperand {
                if let varSizeoperand = operand?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeoperand
                }
            }
            if hasOutputLayout {
                if let varSizeoutputLayout = outputLayout?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizeoutputLayout
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.ComputeConstantRequest.Builder {
            return Xla.ComputeConstantRequest.classBuilder() as! Xla.ComputeConstantRequest.Builder
        }
        public func getBuilder() -> Xla.ComputeConstantRequest.Builder {
            return classBuilder() as! Xla.ComputeConstantRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ComputeConstantRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ComputeConstantRequest.Builder()
        }
        public func toBuilder() throws -> Xla.ComputeConstantRequest.Builder {
            return try Xla.ComputeConstantRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.ComputeConstantRequest) throws -> Xla.ComputeConstantRequest.Builder {
            return try Xla.ComputeConstantRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasComputation {
                jsonMap["computation"] = try computation.encode()
            }
            if hasOperand {
                jsonMap["operand"] = try operand.encode()
            }
            if hasOutputLayout {
                jsonMap["outputLayout"] = try outputLayout.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.ComputeConstantRequest {
            return try Xla.ComputeConstantRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.ComputeConstantRequest {
            return try Xla.ComputeConstantRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasComputation {
                output += "\(indent) computation {\n"
                if let outDescComputation = computation {
                    output += try outDescComputation.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasOperand {
                output += "\(indent) operand {\n"
                if let outDescOperand = operand {
                    output += try outDescOperand.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasOutputLayout {
                output += "\(indent) outputLayout {\n"
                if let outDescOutputLayout = outputLayout {
                    output += try outDescOutputLayout.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasComputation {
                    if let hashValuecomputation = computation?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecomputation
                    }
                }
                if hasOperand {
                    if let hashValueoperand = operand?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoperand
                    }
                }
                if hasOutputLayout {
                    if let hashValueoutputLayout = outputLayout?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoutputLayout
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.ComputeConstantRequest"
        }
        override public func className() -> String {
            return "Xla.ComputeConstantRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.ComputeConstantRequest = Xla.ComputeConstantRequest()
            public func getMessage() -> Xla.ComputeConstantRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var computation:Xla.ComputationHandle! {
                get {
                    if computationBuilder_ != nil {
                        builderResult.computation = computationBuilder_.getMessage()
                    }
                    return builderResult.computation
                }
                set (value) {
                    builderResult.hasComputation = true
                    builderResult.computation = value
                }
            }
            public var hasComputation:Bool {
                get {
                    return builderResult.hasComputation
                }
            }
            fileprivate var computationBuilder_:Xla.ComputationHandle.Builder! {
                didSet {
                    builderResult.hasComputation = true
                }
            }
            public func getComputationBuilder() -> Xla.ComputationHandle.Builder {
                if computationBuilder_ == nil {
                    computationBuilder_ = Xla.ComputationHandle.Builder()
                    builderResult.computation = computationBuilder_.getMessage()
                    if computation != nil {
                        try! computationBuilder_.mergeFrom(other: computation)
                    }
                }
                return computationBuilder_
            }
            @discardableResult
            public func setComputation(_ value:Xla.ComputationHandle!) -> Xla.ComputeConstantRequest.Builder {
                self.computation = value
                return self
            }
            @discardableResult
            public func mergeComputation(value:Xla.ComputationHandle) throws -> Xla.ComputeConstantRequest.Builder {
                if builderResult.hasComputation {
                    builderResult.computation = try Xla.ComputationHandle.builderWithPrototype(prototype:builderResult.computation).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.computation = value
                }
                builderResult.hasComputation = true
                return self
            }
            @discardableResult
            public func clearComputation() -> Xla.ComputeConstantRequest.Builder {
                computationBuilder_ = nil
                builderResult.hasComputation = false
                builderResult.computation = nil
                return self
            }
            public var operand:Xla.ComputationDataHandle! {
                get {
                    if operandBuilder_ != nil {
                        builderResult.operand = operandBuilder_.getMessage()
                    }
                    return builderResult.operand
                }
                set (value) {
                    builderResult.hasOperand = true
                    builderResult.operand = value
                }
            }
            public var hasOperand:Bool {
                get {
                    return builderResult.hasOperand
                }
            }
            fileprivate var operandBuilder_:Xla.ComputationDataHandle.Builder! {
                didSet {
                    builderResult.hasOperand = true
                }
            }
            public func getOperandBuilder() -> Xla.ComputationDataHandle.Builder {
                if operandBuilder_ == nil {
                    operandBuilder_ = Xla.ComputationDataHandle.Builder()
                    builderResult.operand = operandBuilder_.getMessage()
                    if operand != nil {
                        try! operandBuilder_.mergeFrom(other: operand)
                    }
                }
                return operandBuilder_
            }
            @discardableResult
            public func setOperand(_ value:Xla.ComputationDataHandle!) -> Xla.ComputeConstantRequest.Builder {
                self.operand = value
                return self
            }
            @discardableResult
            public func mergeOperand(value:Xla.ComputationDataHandle) throws -> Xla.ComputeConstantRequest.Builder {
                if builderResult.hasOperand {
                    builderResult.operand = try Xla.ComputationDataHandle.builderWithPrototype(prototype:builderResult.operand).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.operand = value
                }
                builderResult.hasOperand = true
                return self
            }
            @discardableResult
            public func clearOperand() -> Xla.ComputeConstantRequest.Builder {
                operandBuilder_ = nil
                builderResult.hasOperand = false
                builderResult.operand = nil
                return self
            }
            public var outputLayout:Xla.Layout! {
                get {
                    if outputLayoutBuilder_ != nil {
                        builderResult.outputLayout = outputLayoutBuilder_.getMessage()
                    }
                    return builderResult.outputLayout
                }
                set (value) {
                    builderResult.hasOutputLayout = true
                    builderResult.outputLayout = value
                }
            }
            public var hasOutputLayout:Bool {
                get {
                    return builderResult.hasOutputLayout
                }
            }
            fileprivate var outputLayoutBuilder_:Xla.Layout.Builder! {
                didSet {
                    builderResult.hasOutputLayout = true
                }
            }
            public func getOutputLayoutBuilder() -> Xla.Layout.Builder {
                if outputLayoutBuilder_ == nil {
                    outputLayoutBuilder_ = Xla.Layout.Builder()
                    builderResult.outputLayout = outputLayoutBuilder_.getMessage()
                    if outputLayout != nil {
                        try! outputLayoutBuilder_.mergeFrom(other: outputLayout)
                    }
                }
                return outputLayoutBuilder_
            }
            @discardableResult
            public func setOutputLayout(_ value:Xla.Layout!) -> Xla.ComputeConstantRequest.Builder {
                self.outputLayout = value
                return self
            }
            @discardableResult
            public func mergeOutputLayout(value:Xla.Layout) throws -> Xla.ComputeConstantRequest.Builder {
                if builderResult.hasOutputLayout {
                    builderResult.outputLayout = try Xla.Layout.builderWithPrototype(prototype:builderResult.outputLayout).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.outputLayout = value
                }
                builderResult.hasOutputLayout = true
                return self
            }
            @discardableResult
            public func clearOutputLayout() -> Xla.ComputeConstantRequest.Builder {
                outputLayoutBuilder_ = nil
                builderResult.hasOutputLayout = false
                builderResult.outputLayout = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.ComputeConstantRequest.Builder {
                builderResult = Xla.ComputeConstantRequest()
                return self
            }
            override public func clone() throws -> Xla.ComputeConstantRequest.Builder {
                return try Xla.ComputeConstantRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.ComputeConstantRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.ComputeConstantRequest {
                let returnMe:Xla.ComputeConstantRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.ComputeConstantRequest) throws -> Xla.ComputeConstantRequest.Builder {
                if other == Xla.ComputeConstantRequest() {
                    return self
                }
                if (other.hasComputation) {
                    try mergeComputation(value: other.computation)
                }
                if (other.hasOperand) {
                    try mergeOperand(value: other.operand)
                }
                if (other.hasOutputLayout) {
                    try mergeOutputLayout(value: other.outputLayout)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.ComputeConstantRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputeConstantRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.ComputationHandle.Builder = Xla.ComputationHandle.Builder()
                        if hasComputation {
                            try subBuilder.mergeFrom(other: computation)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        computation = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Xla.ComputationDataHandle.Builder = Xla.ComputationDataHandle.Builder()
                        if hasOperand {
                            try subBuilder.mergeFrom(other: operand)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        operand = subBuilder.buildPartial()

                    case 26:
                        let subBuilder:Xla.Layout.Builder = Xla.Layout.Builder()
                        if hasOutputLayout {
                            try subBuilder.mergeFrom(other: outputLayout)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        outputLayout = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.ComputeConstantRequest.Builder {
                let resultDecodedBuilder = Xla.ComputeConstantRequest.Builder()
                if let jsonValueComputation = jsonMap["computation"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.computation = try Xla.ComputationHandle.Builder.decodeToBuilder(jsonMap:jsonValueComputation).build()

                }
                if let jsonValueOperand = jsonMap["operand"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.operand = try Xla.ComputationDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueOperand).build()

                }
                if let jsonValueOutputLayout = jsonMap["outputLayout"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.outputLayout = try Xla.Layout.Builder.decodeToBuilder(jsonMap:jsonValueOutputLayout).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.ComputeConstantRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.ComputeConstantRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ComputeConstantResponse : GeneratedMessage {

        public static func == (lhs: Xla.ComputeConstantResponse, rhs: Xla.ComputeConstantResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasOutput == rhs.hasOutput) && (!lhs.hasOutput || lhs.output == rhs.output)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var output:Xla.GlobalDataHandle!
        public fileprivate(set) var hasOutput:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasOutput {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:output)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasOutput {
                if let varSizeoutput = output?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeoutput
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.ComputeConstantResponse.Builder {
            return Xla.ComputeConstantResponse.classBuilder() as! Xla.ComputeConstantResponse.Builder
        }
        public func getBuilder() -> Xla.ComputeConstantResponse.Builder {
            return classBuilder() as! Xla.ComputeConstantResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ComputeConstantResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.ComputeConstantResponse.Builder()
        }
        public func toBuilder() throws -> Xla.ComputeConstantResponse.Builder {
            return try Xla.ComputeConstantResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.ComputeConstantResponse) throws -> Xla.ComputeConstantResponse.Builder {
            return try Xla.ComputeConstantResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasOutput {
                jsonMap["output"] = try output.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.ComputeConstantResponse {
            return try Xla.ComputeConstantResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.ComputeConstantResponse {
            return try Xla.ComputeConstantResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasOutput {
                output += "\(indent) output {\n"
                if let outDescOutput = output {
                    output += try outDescOutput.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasOutput {
                    if let hashValueoutput = output?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoutput
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.ComputeConstantResponse"
        }
        override public func className() -> String {
            return "Xla.ComputeConstantResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.ComputeConstantResponse = Xla.ComputeConstantResponse()
            public func getMessage() -> Xla.ComputeConstantResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var output:Xla.GlobalDataHandle! {
                get {
                    if outputBuilder_ != nil {
                        builderResult.output = outputBuilder_.getMessage()
                    }
                    return builderResult.output
                }
                set (value) {
                    builderResult.hasOutput = true
                    builderResult.output = value
                }
            }
            public var hasOutput:Bool {
                get {
                    return builderResult.hasOutput
                }
            }
            fileprivate var outputBuilder_:Xla.GlobalDataHandle.Builder! {
                didSet {
                    builderResult.hasOutput = true
                }
            }
            public func getOutputBuilder() -> Xla.GlobalDataHandle.Builder {
                if outputBuilder_ == nil {
                    outputBuilder_ = Xla.GlobalDataHandle.Builder()
                    builderResult.output = outputBuilder_.getMessage()
                    if output != nil {
                        try! outputBuilder_.mergeFrom(other: output)
                    }
                }
                return outputBuilder_
            }
            @discardableResult
            public func setOutput(_ value:Xla.GlobalDataHandle!) -> Xla.ComputeConstantResponse.Builder {
                self.output = value
                return self
            }
            @discardableResult
            public func mergeOutput(value:Xla.GlobalDataHandle) throws -> Xla.ComputeConstantResponse.Builder {
                if builderResult.hasOutput {
                    builderResult.output = try Xla.GlobalDataHandle.builderWithPrototype(prototype:builderResult.output).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.output = value
                }
                builderResult.hasOutput = true
                return self
            }
            @discardableResult
            public func clearOutput() -> Xla.ComputeConstantResponse.Builder {
                outputBuilder_ = nil
                builderResult.hasOutput = false
                builderResult.output = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.ComputeConstantResponse.Builder {
                builderResult = Xla.ComputeConstantResponse()
                return self
            }
            override public func clone() throws -> Xla.ComputeConstantResponse.Builder {
                return try Xla.ComputeConstantResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.ComputeConstantResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.ComputeConstantResponse {
                let returnMe:Xla.ComputeConstantResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.ComputeConstantResponse) throws -> Xla.ComputeConstantResponse.Builder {
                if other == Xla.ComputeConstantResponse() {
                    return self
                }
                if (other.hasOutput) {
                    try mergeOutput(value: other.output)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.ComputeConstantResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputeConstantResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.GlobalDataHandle.Builder = Xla.GlobalDataHandle.Builder()
                        if hasOutput {
                            try subBuilder.mergeFrom(other: output)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        output = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.ComputeConstantResponse.Builder {
                let resultDecodedBuilder = Xla.ComputeConstantResponse.Builder()
                if let jsonValueOutput = jsonMap["output"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.output = try Xla.GlobalDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueOutput).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.ComputeConstantResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.ComputeConstantResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class DeconstructTupleRequest : GeneratedMessage {

        public static func == (lhs: Xla.DeconstructTupleRequest, rhs: Xla.DeconstructTupleRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasTupleHandle == rhs.hasTupleHandle) && (!lhs.hasTupleHandle || lhs.tupleHandle == rhs.tupleHandle)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var tupleHandle:Xla.GlobalDataHandle!
        public fileprivate(set) var hasTupleHandle:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasTupleHandle {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:tupleHandle)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasTupleHandle {
                if let varSizetupleHandle = tupleHandle?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizetupleHandle
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.DeconstructTupleRequest.Builder {
            return Xla.DeconstructTupleRequest.classBuilder() as! Xla.DeconstructTupleRequest.Builder
        }
        public func getBuilder() -> Xla.DeconstructTupleRequest.Builder {
            return classBuilder() as! Xla.DeconstructTupleRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.DeconstructTupleRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.DeconstructTupleRequest.Builder()
        }
        public func toBuilder() throws -> Xla.DeconstructTupleRequest.Builder {
            return try Xla.DeconstructTupleRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.DeconstructTupleRequest) throws -> Xla.DeconstructTupleRequest.Builder {
            return try Xla.DeconstructTupleRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasTupleHandle {
                jsonMap["tupleHandle"] = try tupleHandle.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.DeconstructTupleRequest {
            return try Xla.DeconstructTupleRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.DeconstructTupleRequest {
            return try Xla.DeconstructTupleRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasTupleHandle {
                output += "\(indent) tupleHandle {\n"
                if let outDescTupleHandle = tupleHandle {
                    output += try outDescTupleHandle.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasTupleHandle {
                    if let hashValuetupleHandle = tupleHandle?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuetupleHandle
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.DeconstructTupleRequest"
        }
        override public func className() -> String {
            return "Xla.DeconstructTupleRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.DeconstructTupleRequest = Xla.DeconstructTupleRequest()
            public func getMessage() -> Xla.DeconstructTupleRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var tupleHandle:Xla.GlobalDataHandle! {
                get {
                    if tupleHandleBuilder_ != nil {
                        builderResult.tupleHandle = tupleHandleBuilder_.getMessage()
                    }
                    return builderResult.tupleHandle
                }
                set (value) {
                    builderResult.hasTupleHandle = true
                    builderResult.tupleHandle = value
                }
            }
            public var hasTupleHandle:Bool {
                get {
                    return builderResult.hasTupleHandle
                }
            }
            fileprivate var tupleHandleBuilder_:Xla.GlobalDataHandle.Builder! {
                didSet {
                    builderResult.hasTupleHandle = true
                }
            }
            public func getTupleHandleBuilder() -> Xla.GlobalDataHandle.Builder {
                if tupleHandleBuilder_ == nil {
                    tupleHandleBuilder_ = Xla.GlobalDataHandle.Builder()
                    builderResult.tupleHandle = tupleHandleBuilder_.getMessage()
                    if tupleHandle != nil {
                        try! tupleHandleBuilder_.mergeFrom(other: tupleHandle)
                    }
                }
                return tupleHandleBuilder_
            }
            @discardableResult
            public func setTupleHandle(_ value:Xla.GlobalDataHandle!) -> Xla.DeconstructTupleRequest.Builder {
                self.tupleHandle = value
                return self
            }
            @discardableResult
            public func mergeTupleHandle(value:Xla.GlobalDataHandle) throws -> Xla.DeconstructTupleRequest.Builder {
                if builderResult.hasTupleHandle {
                    builderResult.tupleHandle = try Xla.GlobalDataHandle.builderWithPrototype(prototype:builderResult.tupleHandle).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.tupleHandle = value
                }
                builderResult.hasTupleHandle = true
                return self
            }
            @discardableResult
            public func clearTupleHandle() -> Xla.DeconstructTupleRequest.Builder {
                tupleHandleBuilder_ = nil
                builderResult.hasTupleHandle = false
                builderResult.tupleHandle = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.DeconstructTupleRequest.Builder {
                builderResult = Xla.DeconstructTupleRequest()
                return self
            }
            override public func clone() throws -> Xla.DeconstructTupleRequest.Builder {
                return try Xla.DeconstructTupleRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.DeconstructTupleRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.DeconstructTupleRequest {
                let returnMe:Xla.DeconstructTupleRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.DeconstructTupleRequest) throws -> Xla.DeconstructTupleRequest.Builder {
                if other == Xla.DeconstructTupleRequest() {
                    return self
                }
                if (other.hasTupleHandle) {
                    try mergeTupleHandle(value: other.tupleHandle)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.DeconstructTupleRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.DeconstructTupleRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 18:
                        let subBuilder:Xla.GlobalDataHandle.Builder = Xla.GlobalDataHandle.Builder()
                        if hasTupleHandle {
                            try subBuilder.mergeFrom(other: tupleHandle)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        tupleHandle = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.DeconstructTupleRequest.Builder {
                let resultDecodedBuilder = Xla.DeconstructTupleRequest.Builder()
                if let jsonValueTupleHandle = jsonMap["tupleHandle"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.tupleHandle = try Xla.GlobalDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueTupleHandle).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.DeconstructTupleRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.DeconstructTupleRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class DeconstructTupleResponse : GeneratedMessage {

        public static func == (lhs: Xla.DeconstructTupleResponse, rhs: Xla.DeconstructTupleResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.elementHandles == rhs.elementHandles)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var elementHandles:Array<Xla.GlobalDataHandle>  = Array<Xla.GlobalDataHandle>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementElementHandles in elementHandles {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementElementHandles)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementElementHandles in elementHandles {
                serialize_size += oneElementElementHandles.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.DeconstructTupleResponse.Builder {
            return Xla.DeconstructTupleResponse.classBuilder() as! Xla.DeconstructTupleResponse.Builder
        }
        public func getBuilder() -> Xla.DeconstructTupleResponse.Builder {
            return classBuilder() as! Xla.DeconstructTupleResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.DeconstructTupleResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.DeconstructTupleResponse.Builder()
        }
        public func toBuilder() throws -> Xla.DeconstructTupleResponse.Builder {
            return try Xla.DeconstructTupleResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.DeconstructTupleResponse) throws -> Xla.DeconstructTupleResponse.Builder {
            return try Xla.DeconstructTupleResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !elementHandles.isEmpty {
                var jsonArrayElementHandles:Array<Dictionary<String,Any>> = []
                for oneValueElementHandles in elementHandles {
                    let ecodedMessageElementHandles = try oneValueElementHandles.encode()
                    jsonArrayElementHandles.append(ecodedMessageElementHandles)
                }
                jsonMap["elementHandles"] = jsonArrayElementHandles
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.DeconstructTupleResponse {
            return try Xla.DeconstructTupleResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.DeconstructTupleResponse {
            return try Xla.DeconstructTupleResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var elementHandlesElementIndex:Int = 0
            for oneElementElementHandles in elementHandles {
                output += "\(indent) elementHandles[\(elementHandlesElementIndex)] {\n"
                output += try oneElementElementHandles.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                elementHandlesElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementElementHandles in elementHandles {
                    hashCode = (hashCode &* 31) &+ oneElementElementHandles.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.DeconstructTupleResponse"
        }
        override public func className() -> String {
            return "Xla.DeconstructTupleResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.DeconstructTupleResponse = Xla.DeconstructTupleResponse()
            public func getMessage() -> Xla.DeconstructTupleResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var elementHandles:Array<Xla.GlobalDataHandle> {
                get {
                    return builderResult.elementHandles
                }
                set (value) {
                    builderResult.elementHandles = value
                }
            }
            @discardableResult
            public func setElementHandles(_ value:Array<Xla.GlobalDataHandle>) -> Xla.DeconstructTupleResponse.Builder {
                self.elementHandles = value
                return self
            }
            @discardableResult
            public func clearElementHandles() -> Xla.DeconstructTupleResponse.Builder {
                builderResult.elementHandles.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.DeconstructTupleResponse.Builder {
                builderResult = Xla.DeconstructTupleResponse()
                return self
            }
            override public func clone() throws -> Xla.DeconstructTupleResponse.Builder {
                return try Xla.DeconstructTupleResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.DeconstructTupleResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.DeconstructTupleResponse {
                let returnMe:Xla.DeconstructTupleResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.DeconstructTupleResponse) throws -> Xla.DeconstructTupleResponse.Builder {
                if other == Xla.DeconstructTupleResponse() {
                    return self
                }
                if !other.elementHandles.isEmpty  {
                     builderResult.elementHandles += other.elementHandles
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.DeconstructTupleResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.DeconstructTupleResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Xla.GlobalDataHandle.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        elementHandles.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.DeconstructTupleResponse.Builder {
                let resultDecodedBuilder = Xla.DeconstructTupleResponse.Builder()
                if let jsonValueElementHandles = jsonMap["elementHandles"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayElementHandles:Array<Xla.GlobalDataHandle> = []
                    for oneValueElementHandles in jsonValueElementHandles {
                        let messageFromStringElementHandles = try Xla.GlobalDataHandle.Builder.decodeToBuilder(jsonMap:oneValueElementHandles).build()

                        jsonArrayElementHandles.append(messageFromStringElementHandles)
                    }
                    resultDecodedBuilder.elementHandles = jsonArrayElementHandles
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.DeconstructTupleResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.DeconstructTupleResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class LoadDataRequest : GeneratedMessage {

        public static func == (lhs: Xla.LoadDataRequest, rhs: Xla.LoadDataRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasColumnioTabletPath == rhs.hasColumnioTabletPath) && (!lhs.hasColumnioTabletPath || lhs.columnioTabletPath == rhs.columnioTabletPath)
            fieldCheck = fieldCheck && (lhs.hasColumnioField == rhs.hasColumnioField) && (!lhs.hasColumnioField || lhs.columnioField == rhs.columnioField)
            fieldCheck = fieldCheck && (lhs.hasElementShape == rhs.hasElementShape) && (!lhs.hasElementShape || lhs.elementShape == rhs.elementShape)
            fieldCheck = fieldCheck && (lhs.hasOffset == rhs.hasOffset) && (!lhs.hasOffset || lhs.offset == rhs.offset)
            fieldCheck = fieldCheck && (lhs.hasLimit == rhs.hasLimit) && (!lhs.hasLimit || lhs.limit == rhs.limit)
            fieldCheck = fieldCheck && (lhs.hasZip == rhs.hasZip) && (!lhs.hasZip || lhs.zip == rhs.zip)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Describes the path of the ColumnIO tablet to load.
        public fileprivate(set) var columnioTabletPath:String = ""
        public fileprivate(set) var hasColumnioTabletPath:Bool = false

        /// Describes the field to load within the ColumnIO tablet.
        public fileprivate(set) var columnioField:String = ""
        public fileprivate(set) var hasColumnioField:Bool = false

        public fileprivate(set) var elementShape:Xla.Shape!
        public fileprivate(set) var hasElementShape:Bool = false
        /// Warning: ColumnIO does not support random-access, so use offset with
        /// caution in performance-critical scenarios.
        public fileprivate(set) var offset:Int64 = Int64(0)
        public fileprivate(set) var hasOffset:Bool = false

        /// Maximum number of elements (with shape element_shape) to load.
        public fileprivate(set) var limit:Int64 = Int64(0)
        public fileprivate(set) var hasLimit:Bool = false

        /// If more than one item is requested (via limit > 1), then this request
        /// attribute zips together the produced vectors.
        public fileprivate(set) var zip:Bool = false
        public fileprivate(set) var hasZip:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasColumnioTabletPath {
                try codedOutputStream.writeString(fieldNumber: 1, value:columnioTabletPath)
            }
            if hasColumnioField {
                try codedOutputStream.writeString(fieldNumber: 2, value:columnioField)
            }
            if hasElementShape {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:elementShape)
            }
            if hasOffset {
                try codedOutputStream.writeInt64(fieldNumber: 4, value:offset)
            }
            if hasLimit {
                try codedOutputStream.writeInt64(fieldNumber: 5, value:limit)
            }
            if hasZip {
                try codedOutputStream.writeBool(fieldNumber: 6, value:zip)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasColumnioTabletPath {
                serialize_size += columnioTabletPath.computeStringSize(fieldNumber: 1)
            }
            if hasColumnioField {
                serialize_size += columnioField.computeStringSize(fieldNumber: 2)
            }
            if hasElementShape {
                if let varSizeelementShape = elementShape?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizeelementShape
                }
            }
            if hasOffset {
                serialize_size += offset.computeInt64Size(fieldNumber: 4)
            }
            if hasLimit {
                serialize_size += limit.computeInt64Size(fieldNumber: 5)
            }
            if hasZip {
                serialize_size += zip.computeBoolSize(fieldNumber: 6)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.LoadDataRequest.Builder {
            return Xla.LoadDataRequest.classBuilder() as! Xla.LoadDataRequest.Builder
        }
        public func getBuilder() -> Xla.LoadDataRequest.Builder {
            return classBuilder() as! Xla.LoadDataRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.LoadDataRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.LoadDataRequest.Builder()
        }
        public func toBuilder() throws -> Xla.LoadDataRequest.Builder {
            return try Xla.LoadDataRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.LoadDataRequest) throws -> Xla.LoadDataRequest.Builder {
            return try Xla.LoadDataRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasColumnioTabletPath {
                jsonMap["columnioTabletPath"] = columnioTabletPath
            }
            if hasColumnioField {
                jsonMap["columnioField"] = columnioField
            }
            if hasElementShape {
                jsonMap["elementShape"] = try elementShape.encode()
            }
            if hasOffset {
                jsonMap["offset"] = "\(offset)"
            }
            if hasLimit {
                jsonMap["limit"] = "\(limit)"
            }
            if hasZip {
                jsonMap["zip"] = zip
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.LoadDataRequest {
            return try Xla.LoadDataRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.LoadDataRequest {
            return try Xla.LoadDataRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasColumnioTabletPath {
                output += "\(indent) columnioTabletPath: \(columnioTabletPath) \n"
            }
            if hasColumnioField {
                output += "\(indent) columnioField: \(columnioField) \n"
            }
            if hasElementShape {
                output += "\(indent) elementShape {\n"
                if let outDescElementShape = elementShape {
                    output += try outDescElementShape.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasOffset {
                output += "\(indent) offset: \(offset) \n"
            }
            if hasLimit {
                output += "\(indent) limit: \(limit) \n"
            }
            if hasZip {
                output += "\(indent) zip: \(zip) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasColumnioTabletPath {
                    hashCode = (hashCode &* 31) &+ columnioTabletPath.hashValue
                }
                if hasColumnioField {
                    hashCode = (hashCode &* 31) &+ columnioField.hashValue
                }
                if hasElementShape {
                    if let hashValueelementShape = elementShape?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueelementShape
                    }
                }
                if hasOffset {
                    hashCode = (hashCode &* 31) &+ offset.hashValue
                }
                if hasLimit {
                    hashCode = (hashCode &* 31) &+ limit.hashValue
                }
                if hasZip {
                    hashCode = (hashCode &* 31) &+ zip.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.LoadDataRequest"
        }
        override public func className() -> String {
            return "Xla.LoadDataRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.LoadDataRequest = Xla.LoadDataRequest()
            public func getMessage() -> Xla.LoadDataRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Describes the path of the ColumnIO tablet to load.
            public var columnioTabletPath:String {
                get {
                    return builderResult.columnioTabletPath
                }
                set (value) {
                    builderResult.hasColumnioTabletPath = true
                    builderResult.columnioTabletPath = value
                }
            }
            public var hasColumnioTabletPath:Bool {
                get {
                    return builderResult.hasColumnioTabletPath
                }
            }
            @discardableResult
            public func setColumnioTabletPath(_ value:String) -> Xla.LoadDataRequest.Builder {
                self.columnioTabletPath = value
                return self
            }
            @discardableResult
            public func clearColumnioTabletPath() -> Xla.LoadDataRequest.Builder{
                builderResult.hasColumnioTabletPath = false
                builderResult.columnioTabletPath = ""
                return self
            }
            /// Describes the field to load within the ColumnIO tablet.
            public var columnioField:String {
                get {
                    return builderResult.columnioField
                }
                set (value) {
                    builderResult.hasColumnioField = true
                    builderResult.columnioField = value
                }
            }
            public var hasColumnioField:Bool {
                get {
                    return builderResult.hasColumnioField
                }
            }
            @discardableResult
            public func setColumnioField(_ value:String) -> Xla.LoadDataRequest.Builder {
                self.columnioField = value
                return self
            }
            @discardableResult
            public func clearColumnioField() -> Xla.LoadDataRequest.Builder{
                builderResult.hasColumnioField = false
                builderResult.columnioField = ""
                return self
            }
            /// Individual element shape, excluding rows.
            public var elementShape:Xla.Shape! {
                get {
                    if elementShapeBuilder_ != nil {
                        builderResult.elementShape = elementShapeBuilder_.getMessage()
                    }
                    return builderResult.elementShape
                }
                set (value) {
                    builderResult.hasElementShape = true
                    builderResult.elementShape = value
                }
            }
            public var hasElementShape:Bool {
                get {
                    return builderResult.hasElementShape
                }
            }
            fileprivate var elementShapeBuilder_:Xla.Shape.Builder! {
                didSet {
                    builderResult.hasElementShape = true
                }
            }
            public func getElementShapeBuilder() -> Xla.Shape.Builder {
                if elementShapeBuilder_ == nil {
                    elementShapeBuilder_ = Xla.Shape.Builder()
                    builderResult.elementShape = elementShapeBuilder_.getMessage()
                    if elementShape != nil {
                        try! elementShapeBuilder_.mergeFrom(other: elementShape)
                    }
                }
                return elementShapeBuilder_
            }
            @discardableResult
            public func setElementShape(_ value:Xla.Shape!) -> Xla.LoadDataRequest.Builder {
                self.elementShape = value
                return self
            }
            @discardableResult
            public func mergeElementShape(value:Xla.Shape) throws -> Xla.LoadDataRequest.Builder {
                if builderResult.hasElementShape {
                    builderResult.elementShape = try Xla.Shape.builderWithPrototype(prototype:builderResult.elementShape).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.elementShape = value
                }
                builderResult.hasElementShape = true
                return self
            }
            @discardableResult
            public func clearElementShape() -> Xla.LoadDataRequest.Builder {
                elementShapeBuilder_ = nil
                builderResult.hasElementShape = false
                builderResult.elementShape = nil
                return self
            }
            /// Warning: ColumnIO does not support random-access, so use offset with
            /// caution in performance-critical scenarios.
            public var offset:Int64 {
                get {
                    return builderResult.offset
                }
                set (value) {
                    builderResult.hasOffset = true
                    builderResult.offset = value
                }
            }
            public var hasOffset:Bool {
                get {
                    return builderResult.hasOffset
                }
            }
            @discardableResult
            public func setOffset(_ value:Int64) -> Xla.LoadDataRequest.Builder {
                self.offset = value
                return self
            }
            @discardableResult
            public func clearOffset() -> Xla.LoadDataRequest.Builder{
                builderResult.hasOffset = false
                builderResult.offset = Int64(0)
                return self
            }
            /// Maximum number of elements (with shape element_shape) to load.
            public var limit:Int64 {
                get {
                    return builderResult.limit
                }
                set (value) {
                    builderResult.hasLimit = true
                    builderResult.limit = value
                }
            }
            public var hasLimit:Bool {
                get {
                    return builderResult.hasLimit
                }
            }
            @discardableResult
            public func setLimit(_ value:Int64) -> Xla.LoadDataRequest.Builder {
                self.limit = value
                return self
            }
            @discardableResult
            public func clearLimit() -> Xla.LoadDataRequest.Builder{
                builderResult.hasLimit = false
                builderResult.limit = Int64(0)
                return self
            }
            /// If more than one item is requested (via limit > 1), then this request
            /// attribute zips together the produced vectors.
            public var zip:Bool {
                get {
                    return builderResult.zip
                }
                set (value) {
                    builderResult.hasZip = true
                    builderResult.zip = value
                }
            }
            public var hasZip:Bool {
                get {
                    return builderResult.hasZip
                }
            }
            @discardableResult
            public func setZip(_ value:Bool) -> Xla.LoadDataRequest.Builder {
                self.zip = value
                return self
            }
            @discardableResult
            public func clearZip() -> Xla.LoadDataRequest.Builder{
                builderResult.hasZip = false
                builderResult.zip = false
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.LoadDataRequest.Builder {
                builderResult = Xla.LoadDataRequest()
                return self
            }
            override public func clone() throws -> Xla.LoadDataRequest.Builder {
                return try Xla.LoadDataRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.LoadDataRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.LoadDataRequest {
                let returnMe:Xla.LoadDataRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.LoadDataRequest) throws -> Xla.LoadDataRequest.Builder {
                if other == Xla.LoadDataRequest() {
                    return self
                }
                if other.hasColumnioTabletPath {
                    columnioTabletPath = other.columnioTabletPath
                }
                if other.hasColumnioField {
                    columnioField = other.columnioField
                }
                if (other.hasElementShape) {
                    try mergeElementShape(value: other.elementShape)
                }
                if other.hasOffset {
                    offset = other.offset
                }
                if other.hasLimit {
                    limit = other.limit
                }
                if other.hasZip {
                    zip = other.zip
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.LoadDataRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.LoadDataRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        columnioTabletPath = try codedInputStream.readString()

                    case 18:
                        columnioField = try codedInputStream.readString()

                    case 26:
                        let subBuilder:Xla.Shape.Builder = Xla.Shape.Builder()
                        if hasElementShape {
                            try subBuilder.mergeFrom(other: elementShape)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        elementShape = subBuilder.buildPartial()

                    case 32:
                        offset = try codedInputStream.readInt64()

                    case 40:
                        limit = try codedInputStream.readInt64()

                    case 48:
                        zip = try codedInputStream.readBool()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.LoadDataRequest.Builder {
                let resultDecodedBuilder = Xla.LoadDataRequest.Builder()
                if let jsonValueColumnioTabletPath = jsonMap["columnioTabletPath"] as? String {
                    resultDecodedBuilder.columnioTabletPath = jsonValueColumnioTabletPath
                }
                if let jsonValueColumnioField = jsonMap["columnioField"] as? String {
                    resultDecodedBuilder.columnioField = jsonValueColumnioField
                }
                if let jsonValueElementShape = jsonMap["elementShape"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.elementShape = try Xla.Shape.Builder.decodeToBuilder(jsonMap:jsonValueElementShape).build()

                }
                if let jsonValueOffset = jsonMap["offset"] as? String {
                    resultDecodedBuilder.offset = Int64(jsonValueOffset)!
                } else if let jsonValueOffset = jsonMap["offset"] as? Int {
                    resultDecodedBuilder.offset = Int64(jsonValueOffset)
                }
                if let jsonValueLimit = jsonMap["limit"] as? String {
                    resultDecodedBuilder.limit = Int64(jsonValueLimit)!
                } else if let jsonValueLimit = jsonMap["limit"] as? Int {
                    resultDecodedBuilder.limit = Int64(jsonValueLimit)
                }
                if let jsonValueZip = jsonMap["zip"] as? Bool {
                    resultDecodedBuilder.zip = jsonValueZip
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.LoadDataRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.LoadDataRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class LoadDataResponse : GeneratedMessage {

        public static func == (lhs: Xla.LoadDataResponse, rhs: Xla.LoadDataResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasData == rhs.hasData) && (!lhs.hasData || lhs.data == rhs.data)
            fieldCheck = fieldCheck && (lhs.hasDataShape == rhs.hasDataShape) && (!lhs.hasDataShape || lhs.dataShape == rhs.dataShape)
            fieldCheck = fieldCheck && (lhs.hasAvailableRows == rhs.hasAvailableRows) && (!lhs.hasAvailableRows || lhs.availableRows == rhs.availableRows)
            fieldCheck = fieldCheck && (lhs.hasRowsLoaded == rhs.hasRowsLoaded) && (!lhs.hasRowsLoaded || lhs.rowsLoaded == rhs.rowsLoaded)
            fieldCheck = fieldCheck && (lhs.hasNanoseconds == rhs.hasNanoseconds) && (!lhs.hasNanoseconds || lhs.nanoseconds == rhs.nanoseconds)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var data:Xla.GlobalDataHandle!
        public fileprivate(set) var hasData:Bool = false
        public fileprivate(set) var dataShape:Xla.Shape!
        public fileprivate(set) var hasDataShape:Bool = false
        public fileprivate(set) var availableRows:Int64 = Int64(0)
        public fileprivate(set) var hasAvailableRows:Bool = false

        public fileprivate(set) var rowsLoaded:Int64 = Int64(0)
        public fileprivate(set) var hasRowsLoaded:Bool = false

        public fileprivate(set) var nanoseconds:Int64 = Int64(0)
        public fileprivate(set) var hasNanoseconds:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasData {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:data)
            }
            if hasDataShape {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:dataShape)
            }
            if hasAvailableRows {
                try codedOutputStream.writeInt64(fieldNumber: 3, value:availableRows)
            }
            if hasRowsLoaded {
                try codedOutputStream.writeInt64(fieldNumber: 4, value:rowsLoaded)
            }
            if hasNanoseconds {
                try codedOutputStream.writeInt64(fieldNumber: 5, value:nanoseconds)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasData {
                if let varSizedata = data?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizedata
                }
            }
            if hasDataShape {
                if let varSizedataShape = dataShape?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizedataShape
                }
            }
            if hasAvailableRows {
                serialize_size += availableRows.computeInt64Size(fieldNumber: 3)
            }
            if hasRowsLoaded {
                serialize_size += rowsLoaded.computeInt64Size(fieldNumber: 4)
            }
            if hasNanoseconds {
                serialize_size += nanoseconds.computeInt64Size(fieldNumber: 5)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.LoadDataResponse.Builder {
            return Xla.LoadDataResponse.classBuilder() as! Xla.LoadDataResponse.Builder
        }
        public func getBuilder() -> Xla.LoadDataResponse.Builder {
            return classBuilder() as! Xla.LoadDataResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.LoadDataResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.LoadDataResponse.Builder()
        }
        public func toBuilder() throws -> Xla.LoadDataResponse.Builder {
            return try Xla.LoadDataResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.LoadDataResponse) throws -> Xla.LoadDataResponse.Builder {
            return try Xla.LoadDataResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasData {
                jsonMap["data"] = try data.encode()
            }
            if hasDataShape {
                jsonMap["dataShape"] = try dataShape.encode()
            }
            if hasAvailableRows {
                jsonMap["availableRows"] = "\(availableRows)"
            }
            if hasRowsLoaded {
                jsonMap["rowsLoaded"] = "\(rowsLoaded)"
            }
            if hasNanoseconds {
                jsonMap["nanoseconds"] = "\(nanoseconds)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.LoadDataResponse {
            return try Xla.LoadDataResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.LoadDataResponse {
            return try Xla.LoadDataResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasData {
                output += "\(indent) data {\n"
                if let outDescData = data {
                    output += try outDescData.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasDataShape {
                output += "\(indent) dataShape {\n"
                if let outDescDataShape = dataShape {
                    output += try outDescDataShape.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasAvailableRows {
                output += "\(indent) availableRows: \(availableRows) \n"
            }
            if hasRowsLoaded {
                output += "\(indent) rowsLoaded: \(rowsLoaded) \n"
            }
            if hasNanoseconds {
                output += "\(indent) nanoseconds: \(nanoseconds) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasData {
                    if let hashValuedata = data?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuedata
                    }
                }
                if hasDataShape {
                    if let hashValuedataShape = dataShape?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuedataShape
                    }
                }
                if hasAvailableRows {
                    hashCode = (hashCode &* 31) &+ availableRows.hashValue
                }
                if hasRowsLoaded {
                    hashCode = (hashCode &* 31) &+ rowsLoaded.hashValue
                }
                if hasNanoseconds {
                    hashCode = (hashCode &* 31) &+ nanoseconds.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.LoadDataResponse"
        }
        override public func className() -> String {
            return "Xla.LoadDataResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.LoadDataResponse = Xla.LoadDataResponse()
            public func getMessage() -> Xla.LoadDataResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var data:Xla.GlobalDataHandle! {
                get {
                    if dataBuilder_ != nil {
                        builderResult.data = dataBuilder_.getMessage()
                    }
                    return builderResult.data
                }
                set (value) {
                    builderResult.hasData = true
                    builderResult.data = value
                }
            }
            public var hasData:Bool {
                get {
                    return builderResult.hasData
                }
            }
            fileprivate var dataBuilder_:Xla.GlobalDataHandle.Builder! {
                didSet {
                    builderResult.hasData = true
                }
            }
            public func getDataBuilder() -> Xla.GlobalDataHandle.Builder {
                if dataBuilder_ == nil {
                    dataBuilder_ = Xla.GlobalDataHandle.Builder()
                    builderResult.data = dataBuilder_.getMessage()
                    if data != nil {
                        try! dataBuilder_.mergeFrom(other: data)
                    }
                }
                return dataBuilder_
            }
            @discardableResult
            public func setData(_ value:Xla.GlobalDataHandle!) -> Xla.LoadDataResponse.Builder {
                self.data = value
                return self
            }
            @discardableResult
            public func mergeData(value:Xla.GlobalDataHandle) throws -> Xla.LoadDataResponse.Builder {
                if builderResult.hasData {
                    builderResult.data = try Xla.GlobalDataHandle.builderWithPrototype(prototype:builderResult.data).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.data = value
                }
                builderResult.hasData = true
                return self
            }
            @discardableResult
            public func clearData() -> Xla.LoadDataResponse.Builder {
                dataBuilder_ = nil
                builderResult.hasData = false
                builderResult.data = nil
                return self
            }
            public var dataShape:Xla.Shape! {
                get {
                    if dataShapeBuilder_ != nil {
                        builderResult.dataShape = dataShapeBuilder_.getMessage()
                    }
                    return builderResult.dataShape
                }
                set (value) {
                    builderResult.hasDataShape = true
                    builderResult.dataShape = value
                }
            }
            public var hasDataShape:Bool {
                get {
                    return builderResult.hasDataShape
                }
            }
            fileprivate var dataShapeBuilder_:Xla.Shape.Builder! {
                didSet {
                    builderResult.hasDataShape = true
                }
            }
            public func getDataShapeBuilder() -> Xla.Shape.Builder {
                if dataShapeBuilder_ == nil {
                    dataShapeBuilder_ = Xla.Shape.Builder()
                    builderResult.dataShape = dataShapeBuilder_.getMessage()
                    if dataShape != nil {
                        try! dataShapeBuilder_.mergeFrom(other: dataShape)
                    }
                }
                return dataShapeBuilder_
            }
            @discardableResult
            public func setDataShape(_ value:Xla.Shape!) -> Xla.LoadDataResponse.Builder {
                self.dataShape = value
                return self
            }
            @discardableResult
            public func mergeDataShape(value:Xla.Shape) throws -> Xla.LoadDataResponse.Builder {
                if builderResult.hasDataShape {
                    builderResult.dataShape = try Xla.Shape.builderWithPrototype(prototype:builderResult.dataShape).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.dataShape = value
                }
                builderResult.hasDataShape = true
                return self
            }
            @discardableResult
            public func clearDataShape() -> Xla.LoadDataResponse.Builder {
                dataShapeBuilder_ = nil
                builderResult.hasDataShape = false
                builderResult.dataShape = nil
                return self
            }
            public var availableRows:Int64 {
                get {
                    return builderResult.availableRows
                }
                set (value) {
                    builderResult.hasAvailableRows = true
                    builderResult.availableRows = value
                }
            }
            public var hasAvailableRows:Bool {
                get {
                    return builderResult.hasAvailableRows
                }
            }
            @discardableResult
            public func setAvailableRows(_ value:Int64) -> Xla.LoadDataResponse.Builder {
                self.availableRows = value
                return self
            }
            @discardableResult
            public func clearAvailableRows() -> Xla.LoadDataResponse.Builder{
                builderResult.hasAvailableRows = false
                builderResult.availableRows = Int64(0)
                return self
            }
            public var rowsLoaded:Int64 {
                get {
                    return builderResult.rowsLoaded
                }
                set (value) {
                    builderResult.hasRowsLoaded = true
                    builderResult.rowsLoaded = value
                }
            }
            public var hasRowsLoaded:Bool {
                get {
                    return builderResult.hasRowsLoaded
                }
            }
            @discardableResult
            public func setRowsLoaded(_ value:Int64) -> Xla.LoadDataResponse.Builder {
                self.rowsLoaded = value
                return self
            }
            @discardableResult
            public func clearRowsLoaded() -> Xla.LoadDataResponse.Builder{
                builderResult.hasRowsLoaded = false
                builderResult.rowsLoaded = Int64(0)
                return self
            }
            public var nanoseconds:Int64 {
                get {
                    return builderResult.nanoseconds
                }
                set (value) {
                    builderResult.hasNanoseconds = true
                    builderResult.nanoseconds = value
                }
            }
            public var hasNanoseconds:Bool {
                get {
                    return builderResult.hasNanoseconds
                }
            }
            @discardableResult
            public func setNanoseconds(_ value:Int64) -> Xla.LoadDataResponse.Builder {
                self.nanoseconds = value
                return self
            }
            @discardableResult
            public func clearNanoseconds() -> Xla.LoadDataResponse.Builder{
                builderResult.hasNanoseconds = false
                builderResult.nanoseconds = Int64(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.LoadDataResponse.Builder {
                builderResult = Xla.LoadDataResponse()
                return self
            }
            override public func clone() throws -> Xla.LoadDataResponse.Builder {
                return try Xla.LoadDataResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.LoadDataResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.LoadDataResponse {
                let returnMe:Xla.LoadDataResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.LoadDataResponse) throws -> Xla.LoadDataResponse.Builder {
                if other == Xla.LoadDataResponse() {
                    return self
                }
                if (other.hasData) {
                    try mergeData(value: other.data)
                }
                if (other.hasDataShape) {
                    try mergeDataShape(value: other.dataShape)
                }
                if other.hasAvailableRows {
                    availableRows = other.availableRows
                }
                if other.hasRowsLoaded {
                    rowsLoaded = other.rowsLoaded
                }
                if other.hasNanoseconds {
                    nanoseconds = other.nanoseconds
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.LoadDataResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.LoadDataResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.GlobalDataHandle.Builder = Xla.GlobalDataHandle.Builder()
                        if hasData {
                            try subBuilder.mergeFrom(other: data)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        data = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Xla.Shape.Builder = Xla.Shape.Builder()
                        if hasDataShape {
                            try subBuilder.mergeFrom(other: dataShape)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        dataShape = subBuilder.buildPartial()

                    case 24:
                        availableRows = try codedInputStream.readInt64()

                    case 32:
                        rowsLoaded = try codedInputStream.readInt64()

                    case 40:
                        nanoseconds = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.LoadDataResponse.Builder {
                let resultDecodedBuilder = Xla.LoadDataResponse.Builder()
                if let jsonValueData = jsonMap["data"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.data = try Xla.GlobalDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueData).build()

                }
                if let jsonValueDataShape = jsonMap["dataShape"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.dataShape = try Xla.Shape.Builder.decodeToBuilder(jsonMap:jsonValueDataShape).build()

                }
                if let jsonValueAvailableRows = jsonMap["availableRows"] as? String {
                    resultDecodedBuilder.availableRows = Int64(jsonValueAvailableRows)!
                } else if let jsonValueAvailableRows = jsonMap["availableRows"] as? Int {
                    resultDecodedBuilder.availableRows = Int64(jsonValueAvailableRows)
                }
                if let jsonValueRowsLoaded = jsonMap["rowsLoaded"] as? String {
                    resultDecodedBuilder.rowsLoaded = Int64(jsonValueRowsLoaded)!
                } else if let jsonValueRowsLoaded = jsonMap["rowsLoaded"] as? Int {
                    resultDecodedBuilder.rowsLoaded = Int64(jsonValueRowsLoaded)
                }
                if let jsonValueNanoseconds = jsonMap["nanoseconds"] as? String {
                    resultDecodedBuilder.nanoseconds = Int64(jsonValueNanoseconds)!
                } else if let jsonValueNanoseconds = jsonMap["nanoseconds"] as? Int {
                    resultDecodedBuilder.nanoseconds = Int64(jsonValueNanoseconds)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.LoadDataResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.LoadDataResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class SpecializeRequest : GeneratedMessage {

        public static func == (lhs: Xla.SpecializeRequest, rhs: Xla.SpecializeRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasComputation == rhs.hasComputation) && (!lhs.hasComputation || lhs.computation == rhs.computation)
            fieldCheck = fieldCheck && (lhs.arguments == rhs.arguments)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var computation:Xla.ComputationHandle!
        public fileprivate(set) var hasComputation:Bool = false
        public fileprivate(set) var arguments:Array<Xla.GlobalDataHandle>  = Array<Xla.GlobalDataHandle>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasComputation {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:computation)
            }
            for oneElementArguments in arguments {
                  try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementArguments)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasComputation {
                if let varSizecomputation = computation?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizecomputation
                }
            }
            for oneElementArguments in arguments {
                serialize_size += oneElementArguments.computeMessageSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.SpecializeRequest.Builder {
            return Xla.SpecializeRequest.classBuilder() as! Xla.SpecializeRequest.Builder
        }
        public func getBuilder() -> Xla.SpecializeRequest.Builder {
            return classBuilder() as! Xla.SpecializeRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.SpecializeRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.SpecializeRequest.Builder()
        }
        public func toBuilder() throws -> Xla.SpecializeRequest.Builder {
            return try Xla.SpecializeRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.SpecializeRequest) throws -> Xla.SpecializeRequest.Builder {
            return try Xla.SpecializeRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasComputation {
                jsonMap["computation"] = try computation.encode()
            }
            if !arguments.isEmpty {
                var jsonArrayArguments:Array<Dictionary<String,Any>> = []
                for oneValueArguments in arguments {
                    let ecodedMessageArguments = try oneValueArguments.encode()
                    jsonArrayArguments.append(ecodedMessageArguments)
                }
                jsonMap["arguments"] = jsonArrayArguments
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.SpecializeRequest {
            return try Xla.SpecializeRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.SpecializeRequest {
            return try Xla.SpecializeRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasComputation {
                output += "\(indent) computation {\n"
                if let outDescComputation = computation {
                    output += try outDescComputation.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            var argumentsElementIndex:Int = 0
            for oneElementArguments in arguments {
                output += "\(indent) arguments[\(argumentsElementIndex)] {\n"
                output += try oneElementArguments.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                argumentsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasComputation {
                    if let hashValuecomputation = computation?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecomputation
                    }
                }
                for oneElementArguments in arguments {
                    hashCode = (hashCode &* 31) &+ oneElementArguments.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.SpecializeRequest"
        }
        override public func className() -> String {
            return "Xla.SpecializeRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.SpecializeRequest = Xla.SpecializeRequest()
            public func getMessage() -> Xla.SpecializeRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var computation:Xla.ComputationHandle! {
                get {
                    if computationBuilder_ != nil {
                        builderResult.computation = computationBuilder_.getMessage()
                    }
                    return builderResult.computation
                }
                set (value) {
                    builderResult.hasComputation = true
                    builderResult.computation = value
                }
            }
            public var hasComputation:Bool {
                get {
                    return builderResult.hasComputation
                }
            }
            fileprivate var computationBuilder_:Xla.ComputationHandle.Builder! {
                didSet {
                    builderResult.hasComputation = true
                }
            }
            public func getComputationBuilder() -> Xla.ComputationHandle.Builder {
                if computationBuilder_ == nil {
                    computationBuilder_ = Xla.ComputationHandle.Builder()
                    builderResult.computation = computationBuilder_.getMessage()
                    if computation != nil {
                        try! computationBuilder_.mergeFrom(other: computation)
                    }
                }
                return computationBuilder_
            }
            @discardableResult
            public func setComputation(_ value:Xla.ComputationHandle!) -> Xla.SpecializeRequest.Builder {
                self.computation = value
                return self
            }
            @discardableResult
            public func mergeComputation(value:Xla.ComputationHandle) throws -> Xla.SpecializeRequest.Builder {
                if builderResult.hasComputation {
                    builderResult.computation = try Xla.ComputationHandle.builderWithPrototype(prototype:builderResult.computation).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.computation = value
                }
                builderResult.hasComputation = true
                return self
            }
            @discardableResult
            public func clearComputation() -> Xla.SpecializeRequest.Builder {
                computationBuilder_ = nil
                builderResult.hasComputation = false
                builderResult.computation = nil
                return self
            }
            public var arguments:Array<Xla.GlobalDataHandle> {
                get {
                    return builderResult.arguments
                }
                set (value) {
                    builderResult.arguments = value
                }
            }
            @discardableResult
            public func setArguments(_ value:Array<Xla.GlobalDataHandle>) -> Xla.SpecializeRequest.Builder {
                self.arguments = value
                return self
            }
            @discardableResult
            public func clearArguments() -> Xla.SpecializeRequest.Builder {
                builderResult.arguments.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.SpecializeRequest.Builder {
                builderResult = Xla.SpecializeRequest()
                return self
            }
            override public func clone() throws -> Xla.SpecializeRequest.Builder {
                return try Xla.SpecializeRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.SpecializeRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.SpecializeRequest {
                let returnMe:Xla.SpecializeRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.SpecializeRequest) throws -> Xla.SpecializeRequest.Builder {
                if other == Xla.SpecializeRequest() {
                    return self
                }
                if (other.hasComputation) {
                    try mergeComputation(value: other.computation)
                }
                if !other.arguments.isEmpty  {
                     builderResult.arguments += other.arguments
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.SpecializeRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SpecializeRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.ComputationHandle.Builder = Xla.ComputationHandle.Builder()
                        if hasComputation {
                            try subBuilder.mergeFrom(other: computation)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        computation = subBuilder.buildPartial()

                    case 18:
                        let subBuilder = Xla.GlobalDataHandle.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        arguments.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.SpecializeRequest.Builder {
                let resultDecodedBuilder = Xla.SpecializeRequest.Builder()
                if let jsonValueComputation = jsonMap["computation"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.computation = try Xla.ComputationHandle.Builder.decodeToBuilder(jsonMap:jsonValueComputation).build()

                }
                if let jsonValueArguments = jsonMap["arguments"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayArguments:Array<Xla.GlobalDataHandle> = []
                    for oneValueArguments in jsonValueArguments {
                        let messageFromStringArguments = try Xla.GlobalDataHandle.Builder.decodeToBuilder(jsonMap:oneValueArguments).build()

                        jsonArrayArguments.append(messageFromStringArguments)
                    }
                    resultDecodedBuilder.arguments = jsonArrayArguments
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.SpecializeRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.SpecializeRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class SpecializeResponse : GeneratedMessage {

        public static func == (lhs: Xla.SpecializeResponse, rhs: Xla.SpecializeResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.SpecializeResponse.Builder {
            return Xla.SpecializeResponse.classBuilder() as! Xla.SpecializeResponse.Builder
        }
        public func getBuilder() -> Xla.SpecializeResponse.Builder {
            return classBuilder() as! Xla.SpecializeResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.SpecializeResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.SpecializeResponse.Builder()
        }
        public func toBuilder() throws -> Xla.SpecializeResponse.Builder {
            return try Xla.SpecializeResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.SpecializeResponse) throws -> Xla.SpecializeResponse.Builder {
            return try Xla.SpecializeResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.SpecializeResponse {
            return try Xla.SpecializeResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.SpecializeResponse {
            return try Xla.SpecializeResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.SpecializeResponse"
        }
        override public func className() -> String {
            return "Xla.SpecializeResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.SpecializeResponse = Xla.SpecializeResponse()
            public func getMessage() -> Xla.SpecializeResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.SpecializeResponse.Builder {
                builderResult = Xla.SpecializeResponse()
                return self
            }
            override public func clone() throws -> Xla.SpecializeResponse.Builder {
                return try Xla.SpecializeResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.SpecializeResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.SpecializeResponse {
                let returnMe:Xla.SpecializeResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.SpecializeResponse) throws -> Xla.SpecializeResponse.Builder {
                if other == Xla.SpecializeResponse() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.SpecializeResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SpecializeResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.SpecializeResponse.Builder {
                let resultDecodedBuilder = Xla.SpecializeResponse.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.SpecializeResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.SpecializeResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class GetShapeRequest : GeneratedMessage {

        public static func == (lhs: Xla.GetShapeRequest, rhs: Xla.GetShapeRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasData == rhs.hasData) && (!lhs.hasData || lhs.data == rhs.data)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var data:Xla.GlobalDataHandle!
        public fileprivate(set) var hasData:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasData {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:data)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasData {
                if let varSizedata = data?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizedata
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.GetShapeRequest.Builder {
            return Xla.GetShapeRequest.classBuilder() as! Xla.GetShapeRequest.Builder
        }
        public func getBuilder() -> Xla.GetShapeRequest.Builder {
            return classBuilder() as! Xla.GetShapeRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.GetShapeRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.GetShapeRequest.Builder()
        }
        public func toBuilder() throws -> Xla.GetShapeRequest.Builder {
            return try Xla.GetShapeRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.GetShapeRequest) throws -> Xla.GetShapeRequest.Builder {
            return try Xla.GetShapeRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasData {
                jsonMap["data"] = try data.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.GetShapeRequest {
            return try Xla.GetShapeRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.GetShapeRequest {
            return try Xla.GetShapeRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasData {
                output += "\(indent) data {\n"
                if let outDescData = data {
                    output += try outDescData.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasData {
                    if let hashValuedata = data?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuedata
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.GetShapeRequest"
        }
        override public func className() -> String {
            return "Xla.GetShapeRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.GetShapeRequest = Xla.GetShapeRequest()
            public func getMessage() -> Xla.GetShapeRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var data:Xla.GlobalDataHandle! {
                get {
                    if dataBuilder_ != nil {
                        builderResult.data = dataBuilder_.getMessage()
                    }
                    return builderResult.data
                }
                set (value) {
                    builderResult.hasData = true
                    builderResult.data = value
                }
            }
            public var hasData:Bool {
                get {
                    return builderResult.hasData
                }
            }
            fileprivate var dataBuilder_:Xla.GlobalDataHandle.Builder! {
                didSet {
                    builderResult.hasData = true
                }
            }
            public func getDataBuilder() -> Xla.GlobalDataHandle.Builder {
                if dataBuilder_ == nil {
                    dataBuilder_ = Xla.GlobalDataHandle.Builder()
                    builderResult.data = dataBuilder_.getMessage()
                    if data != nil {
                        try! dataBuilder_.mergeFrom(other: data)
                    }
                }
                return dataBuilder_
            }
            @discardableResult
            public func setData(_ value:Xla.GlobalDataHandle!) -> Xla.GetShapeRequest.Builder {
                self.data = value
                return self
            }
            @discardableResult
            public func mergeData(value:Xla.GlobalDataHandle) throws -> Xla.GetShapeRequest.Builder {
                if builderResult.hasData {
                    builderResult.data = try Xla.GlobalDataHandle.builderWithPrototype(prototype:builderResult.data).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.data = value
                }
                builderResult.hasData = true
                return self
            }
            @discardableResult
            public func clearData() -> Xla.GetShapeRequest.Builder {
                dataBuilder_ = nil
                builderResult.hasData = false
                builderResult.data = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.GetShapeRequest.Builder {
                builderResult = Xla.GetShapeRequest()
                return self
            }
            override public func clone() throws -> Xla.GetShapeRequest.Builder {
                return try Xla.GetShapeRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.GetShapeRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.GetShapeRequest {
                let returnMe:Xla.GetShapeRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.GetShapeRequest) throws -> Xla.GetShapeRequest.Builder {
                if other == Xla.GetShapeRequest() {
                    return self
                }
                if (other.hasData) {
                    try mergeData(value: other.data)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.GetShapeRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.GetShapeRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.GlobalDataHandle.Builder = Xla.GlobalDataHandle.Builder()
                        if hasData {
                            try subBuilder.mergeFrom(other: data)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        data = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.GetShapeRequest.Builder {
                let resultDecodedBuilder = Xla.GetShapeRequest.Builder()
                if let jsonValueData = jsonMap["data"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.data = try Xla.GlobalDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueData).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.GetShapeRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.GetShapeRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class GetShapeResponse : GeneratedMessage {

        public static func == (lhs: Xla.GetShapeResponse, rhs: Xla.GetShapeResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasShape == rhs.hasShape) && (!lhs.hasShape || lhs.shape == rhs.shape)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var shape:Xla.Shape!
        public fileprivate(set) var hasShape:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasShape {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:shape)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasShape {
                if let varSizeshape = shape?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeshape
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.GetShapeResponse.Builder {
            return Xla.GetShapeResponse.classBuilder() as! Xla.GetShapeResponse.Builder
        }
        public func getBuilder() -> Xla.GetShapeResponse.Builder {
            return classBuilder() as! Xla.GetShapeResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.GetShapeResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.GetShapeResponse.Builder()
        }
        public func toBuilder() throws -> Xla.GetShapeResponse.Builder {
            return try Xla.GetShapeResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.GetShapeResponse) throws -> Xla.GetShapeResponse.Builder {
            return try Xla.GetShapeResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasShape {
                jsonMap["shape"] = try shape.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.GetShapeResponse {
            return try Xla.GetShapeResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.GetShapeResponse {
            return try Xla.GetShapeResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasShape {
                output += "\(indent) shape {\n"
                if let outDescShape = shape {
                    output += try outDescShape.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasShape {
                    if let hashValueshape = shape?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueshape
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.GetShapeResponse"
        }
        override public func className() -> String {
            return "Xla.GetShapeResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.GetShapeResponse = Xla.GetShapeResponse()
            public func getMessage() -> Xla.GetShapeResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var shape:Xla.Shape! {
                get {
                    if shapeBuilder_ != nil {
                        builderResult.shape = shapeBuilder_.getMessage()
                    }
                    return builderResult.shape
                }
                set (value) {
                    builderResult.hasShape = true
                    builderResult.shape = value
                }
            }
            public var hasShape:Bool {
                get {
                    return builderResult.hasShape
                }
            }
            fileprivate var shapeBuilder_:Xla.Shape.Builder! {
                didSet {
                    builderResult.hasShape = true
                }
            }
            public func getShapeBuilder() -> Xla.Shape.Builder {
                if shapeBuilder_ == nil {
                    shapeBuilder_ = Xla.Shape.Builder()
                    builderResult.shape = shapeBuilder_.getMessage()
                    if shape != nil {
                        try! shapeBuilder_.mergeFrom(other: shape)
                    }
                }
                return shapeBuilder_
            }
            @discardableResult
            public func setShape(_ value:Xla.Shape!) -> Xla.GetShapeResponse.Builder {
                self.shape = value
                return self
            }
            @discardableResult
            public func mergeShape(value:Xla.Shape) throws -> Xla.GetShapeResponse.Builder {
                if builderResult.hasShape {
                    builderResult.shape = try Xla.Shape.builderWithPrototype(prototype:builderResult.shape).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.shape = value
                }
                builderResult.hasShape = true
                return self
            }
            @discardableResult
            public func clearShape() -> Xla.GetShapeResponse.Builder {
                shapeBuilder_ = nil
                builderResult.hasShape = false
                builderResult.shape = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.GetShapeResponse.Builder {
                builderResult = Xla.GetShapeResponse()
                return self
            }
            override public func clone() throws -> Xla.GetShapeResponse.Builder {
                return try Xla.GetShapeResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.GetShapeResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.GetShapeResponse {
                let returnMe:Xla.GetShapeResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.GetShapeResponse) throws -> Xla.GetShapeResponse.Builder {
                if other == Xla.GetShapeResponse() {
                    return self
                }
                if (other.hasShape) {
                    try mergeShape(value: other.shape)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.GetShapeResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.GetShapeResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.Shape.Builder = Xla.Shape.Builder()
                        if hasShape {
                            try subBuilder.mergeFrom(other: shape)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        shape = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.GetShapeResponse.Builder {
                let resultDecodedBuilder = Xla.GetShapeResponse.Builder()
                if let jsonValueShape = jsonMap["shape"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.shape = try Xla.Shape.Builder.decodeToBuilder(jsonMap:jsonValueShape).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.GetShapeResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.GetShapeResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class GetComputationShapeRequest : GeneratedMessage {

        public static func == (lhs: Xla.GetComputationShapeRequest, rhs: Xla.GetComputationShapeRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasComputation == rhs.hasComputation) && (!lhs.hasComputation || lhs.computation == rhs.computation)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var computation:Xla.ComputationHandle!
        public fileprivate(set) var hasComputation:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasComputation {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:computation)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasComputation {
                if let varSizecomputation = computation?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizecomputation
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.GetComputationShapeRequest.Builder {
            return Xla.GetComputationShapeRequest.classBuilder() as! Xla.GetComputationShapeRequest.Builder
        }
        public func getBuilder() -> Xla.GetComputationShapeRequest.Builder {
            return classBuilder() as! Xla.GetComputationShapeRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.GetComputationShapeRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.GetComputationShapeRequest.Builder()
        }
        public func toBuilder() throws -> Xla.GetComputationShapeRequest.Builder {
            return try Xla.GetComputationShapeRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.GetComputationShapeRequest) throws -> Xla.GetComputationShapeRequest.Builder {
            return try Xla.GetComputationShapeRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasComputation {
                jsonMap["computation"] = try computation.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.GetComputationShapeRequest {
            return try Xla.GetComputationShapeRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.GetComputationShapeRequest {
            return try Xla.GetComputationShapeRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasComputation {
                output += "\(indent) computation {\n"
                if let outDescComputation = computation {
                    output += try outDescComputation.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasComputation {
                    if let hashValuecomputation = computation?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecomputation
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.GetComputationShapeRequest"
        }
        override public func className() -> String {
            return "Xla.GetComputationShapeRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.GetComputationShapeRequest = Xla.GetComputationShapeRequest()
            public func getMessage() -> Xla.GetComputationShapeRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var computation:Xla.ComputationHandle! {
                get {
                    if computationBuilder_ != nil {
                        builderResult.computation = computationBuilder_.getMessage()
                    }
                    return builderResult.computation
                }
                set (value) {
                    builderResult.hasComputation = true
                    builderResult.computation = value
                }
            }
            public var hasComputation:Bool {
                get {
                    return builderResult.hasComputation
                }
            }
            fileprivate var computationBuilder_:Xla.ComputationHandle.Builder! {
                didSet {
                    builderResult.hasComputation = true
                }
            }
            public func getComputationBuilder() -> Xla.ComputationHandle.Builder {
                if computationBuilder_ == nil {
                    computationBuilder_ = Xla.ComputationHandle.Builder()
                    builderResult.computation = computationBuilder_.getMessage()
                    if computation != nil {
                        try! computationBuilder_.mergeFrom(other: computation)
                    }
                }
                return computationBuilder_
            }
            @discardableResult
            public func setComputation(_ value:Xla.ComputationHandle!) -> Xla.GetComputationShapeRequest.Builder {
                self.computation = value
                return self
            }
            @discardableResult
            public func mergeComputation(value:Xla.ComputationHandle) throws -> Xla.GetComputationShapeRequest.Builder {
                if builderResult.hasComputation {
                    builderResult.computation = try Xla.ComputationHandle.builderWithPrototype(prototype:builderResult.computation).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.computation = value
                }
                builderResult.hasComputation = true
                return self
            }
            @discardableResult
            public func clearComputation() -> Xla.GetComputationShapeRequest.Builder {
                computationBuilder_ = nil
                builderResult.hasComputation = false
                builderResult.computation = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.GetComputationShapeRequest.Builder {
                builderResult = Xla.GetComputationShapeRequest()
                return self
            }
            override public func clone() throws -> Xla.GetComputationShapeRequest.Builder {
                return try Xla.GetComputationShapeRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.GetComputationShapeRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.GetComputationShapeRequest {
                let returnMe:Xla.GetComputationShapeRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.GetComputationShapeRequest) throws -> Xla.GetComputationShapeRequest.Builder {
                if other == Xla.GetComputationShapeRequest() {
                    return self
                }
                if (other.hasComputation) {
                    try mergeComputation(value: other.computation)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.GetComputationShapeRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.GetComputationShapeRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.ComputationHandle.Builder = Xla.ComputationHandle.Builder()
                        if hasComputation {
                            try subBuilder.mergeFrom(other: computation)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        computation = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.GetComputationShapeRequest.Builder {
                let resultDecodedBuilder = Xla.GetComputationShapeRequest.Builder()
                if let jsonValueComputation = jsonMap["computation"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.computation = try Xla.ComputationHandle.Builder.decodeToBuilder(jsonMap:jsonValueComputation).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.GetComputationShapeRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.GetComputationShapeRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class GetComputationShapeResponse : GeneratedMessage {

        public static func == (lhs: Xla.GetComputationShapeResponse, rhs: Xla.GetComputationShapeResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasProgramShape == rhs.hasProgramShape) && (!lhs.hasProgramShape || lhs.programShape == rhs.programShape)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var programShape:Xla.ProgramShape!
        public fileprivate(set) var hasProgramShape:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasProgramShape {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:programShape)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasProgramShape {
                if let varSizeprogramShape = programShape?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeprogramShape
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.GetComputationShapeResponse.Builder {
            return Xla.GetComputationShapeResponse.classBuilder() as! Xla.GetComputationShapeResponse.Builder
        }
        public func getBuilder() -> Xla.GetComputationShapeResponse.Builder {
            return classBuilder() as! Xla.GetComputationShapeResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.GetComputationShapeResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.GetComputationShapeResponse.Builder()
        }
        public func toBuilder() throws -> Xla.GetComputationShapeResponse.Builder {
            return try Xla.GetComputationShapeResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.GetComputationShapeResponse) throws -> Xla.GetComputationShapeResponse.Builder {
            return try Xla.GetComputationShapeResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasProgramShape {
                jsonMap["programShape"] = try programShape.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.GetComputationShapeResponse {
            return try Xla.GetComputationShapeResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.GetComputationShapeResponse {
            return try Xla.GetComputationShapeResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasProgramShape {
                output += "\(indent) programShape {\n"
                if let outDescProgramShape = programShape {
                    output += try outDescProgramShape.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasProgramShape {
                    if let hashValueprogramShape = programShape?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueprogramShape
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.GetComputationShapeResponse"
        }
        override public func className() -> String {
            return "Xla.GetComputationShapeResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.GetComputationShapeResponse = Xla.GetComputationShapeResponse()
            public func getMessage() -> Xla.GetComputationShapeResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var programShape:Xla.ProgramShape! {
                get {
                    if programShapeBuilder_ != nil {
                        builderResult.programShape = programShapeBuilder_.getMessage()
                    }
                    return builderResult.programShape
                }
                set (value) {
                    builderResult.hasProgramShape = true
                    builderResult.programShape = value
                }
            }
            public var hasProgramShape:Bool {
                get {
                    return builderResult.hasProgramShape
                }
            }
            fileprivate var programShapeBuilder_:Xla.ProgramShape.Builder! {
                didSet {
                    builderResult.hasProgramShape = true
                }
            }
            public func getProgramShapeBuilder() -> Xla.ProgramShape.Builder {
                if programShapeBuilder_ == nil {
                    programShapeBuilder_ = Xla.ProgramShape.Builder()
                    builderResult.programShape = programShapeBuilder_.getMessage()
                    if programShape != nil {
                        try! programShapeBuilder_.mergeFrom(other: programShape)
                    }
                }
                return programShapeBuilder_
            }
            @discardableResult
            public func setProgramShape(_ value:Xla.ProgramShape!) -> Xla.GetComputationShapeResponse.Builder {
                self.programShape = value
                return self
            }
            @discardableResult
            public func mergeProgramShape(value:Xla.ProgramShape) throws -> Xla.GetComputationShapeResponse.Builder {
                if builderResult.hasProgramShape {
                    builderResult.programShape = try Xla.ProgramShape.builderWithPrototype(prototype:builderResult.programShape).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.programShape = value
                }
                builderResult.hasProgramShape = true
                return self
            }
            @discardableResult
            public func clearProgramShape() -> Xla.GetComputationShapeResponse.Builder {
                programShapeBuilder_ = nil
                builderResult.hasProgramShape = false
                builderResult.programShape = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.GetComputationShapeResponse.Builder {
                builderResult = Xla.GetComputationShapeResponse()
                return self
            }
            override public func clone() throws -> Xla.GetComputationShapeResponse.Builder {
                return try Xla.GetComputationShapeResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.GetComputationShapeResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.GetComputationShapeResponse {
                let returnMe:Xla.GetComputationShapeResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.GetComputationShapeResponse) throws -> Xla.GetComputationShapeResponse.Builder {
                if other == Xla.GetComputationShapeResponse() {
                    return self
                }
                if (other.hasProgramShape) {
                    try mergeProgramShape(value: other.programShape)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.GetComputationShapeResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.GetComputationShapeResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.ProgramShape.Builder = Xla.ProgramShape.Builder()
                        if hasProgramShape {
                            try subBuilder.mergeFrom(other: programShape)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        programShape = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.GetComputationShapeResponse.Builder {
                let resultDecodedBuilder = Xla.GetComputationShapeResponse.Builder()
                if let jsonValueProgramShape = jsonMap["programShape"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.programShape = try Xla.ProgramShape.Builder.decodeToBuilder(jsonMap:jsonValueProgramShape).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.GetComputationShapeResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.GetComputationShapeResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class UnpackRequest : GeneratedMessage {

        public static func == (lhs: Xla.UnpackRequest, rhs: Xla.UnpackRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasData == rhs.hasData) && (!lhs.hasData || lhs.data == rhs.data)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var data:Xla.GlobalDataHandle!
        public fileprivate(set) var hasData:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasData {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:data)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasData {
                if let varSizedata = data?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizedata
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.UnpackRequest.Builder {
            return Xla.UnpackRequest.classBuilder() as! Xla.UnpackRequest.Builder
        }
        public func getBuilder() -> Xla.UnpackRequest.Builder {
            return classBuilder() as! Xla.UnpackRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.UnpackRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.UnpackRequest.Builder()
        }
        public func toBuilder() throws -> Xla.UnpackRequest.Builder {
            return try Xla.UnpackRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.UnpackRequest) throws -> Xla.UnpackRequest.Builder {
            return try Xla.UnpackRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasData {
                jsonMap["data"] = try data.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.UnpackRequest {
            return try Xla.UnpackRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.UnpackRequest {
            return try Xla.UnpackRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasData {
                output += "\(indent) data {\n"
                if let outDescData = data {
                    output += try outDescData.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasData {
                    if let hashValuedata = data?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuedata
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.UnpackRequest"
        }
        override public func className() -> String {
            return "Xla.UnpackRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.UnpackRequest = Xla.UnpackRequest()
            public func getMessage() -> Xla.UnpackRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var data:Xla.GlobalDataHandle! {
                get {
                    if dataBuilder_ != nil {
                        builderResult.data = dataBuilder_.getMessage()
                    }
                    return builderResult.data
                }
                set (value) {
                    builderResult.hasData = true
                    builderResult.data = value
                }
            }
            public var hasData:Bool {
                get {
                    return builderResult.hasData
                }
            }
            fileprivate var dataBuilder_:Xla.GlobalDataHandle.Builder! {
                didSet {
                    builderResult.hasData = true
                }
            }
            public func getDataBuilder() -> Xla.GlobalDataHandle.Builder {
                if dataBuilder_ == nil {
                    dataBuilder_ = Xla.GlobalDataHandle.Builder()
                    builderResult.data = dataBuilder_.getMessage()
                    if data != nil {
                        try! dataBuilder_.mergeFrom(other: data)
                    }
                }
                return dataBuilder_
            }
            @discardableResult
            public func setData(_ value:Xla.GlobalDataHandle!) -> Xla.UnpackRequest.Builder {
                self.data = value
                return self
            }
            @discardableResult
            public func mergeData(value:Xla.GlobalDataHandle) throws -> Xla.UnpackRequest.Builder {
                if builderResult.hasData {
                    builderResult.data = try Xla.GlobalDataHandle.builderWithPrototype(prototype:builderResult.data).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.data = value
                }
                builderResult.hasData = true
                return self
            }
            @discardableResult
            public func clearData() -> Xla.UnpackRequest.Builder {
                dataBuilder_ = nil
                builderResult.hasData = false
                builderResult.data = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.UnpackRequest.Builder {
                builderResult = Xla.UnpackRequest()
                return self
            }
            override public func clone() throws -> Xla.UnpackRequest.Builder {
                return try Xla.UnpackRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.UnpackRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.UnpackRequest {
                let returnMe:Xla.UnpackRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.UnpackRequest) throws -> Xla.UnpackRequest.Builder {
                if other == Xla.UnpackRequest() {
                    return self
                }
                if (other.hasData) {
                    try mergeData(value: other.data)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.UnpackRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.UnpackRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Xla.GlobalDataHandle.Builder = Xla.GlobalDataHandle.Builder()
                        if hasData {
                            try subBuilder.mergeFrom(other: data)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        data = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.UnpackRequest.Builder {
                let resultDecodedBuilder = Xla.UnpackRequest.Builder()
                if let jsonValueData = jsonMap["data"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.data = try Xla.GlobalDataHandle.Builder.decodeToBuilder(jsonMap:jsonValueData).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.UnpackRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.UnpackRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class UnpackResponse : GeneratedMessage {

        public static func == (lhs: Xla.UnpackResponse, rhs: Xla.UnpackResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.tiedData == rhs.tiedData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var tiedData:Array<Xla.GlobalDataHandle>  = Array<Xla.GlobalDataHandle>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementTiedData in tiedData {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementTiedData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementTiedData in tiedData {
                serialize_size += oneElementTiedData.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Xla.UnpackResponse.Builder {
            return Xla.UnpackResponse.classBuilder() as! Xla.UnpackResponse.Builder
        }
        public func getBuilder() -> Xla.UnpackResponse.Builder {
            return classBuilder() as! Xla.UnpackResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.UnpackResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Xla.UnpackResponse.Builder()
        }
        public func toBuilder() throws -> Xla.UnpackResponse.Builder {
            return try Xla.UnpackResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Xla.UnpackResponse) throws -> Xla.UnpackResponse.Builder {
            return try Xla.UnpackResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !tiedData.isEmpty {
                var jsonArrayTiedData:Array<Dictionary<String,Any>> = []
                for oneValueTiedData in tiedData {
                    let ecodedMessageTiedData = try oneValueTiedData.encode()
                    jsonArrayTiedData.append(ecodedMessageTiedData)
                }
                jsonMap["tiedData"] = jsonArrayTiedData
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Xla.UnpackResponse {
            return try Xla.UnpackResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Xla.UnpackResponse {
            return try Xla.UnpackResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var tiedDataElementIndex:Int = 0
            for oneElementTiedData in tiedData {
                output += "\(indent) tiedData[\(tiedDataElementIndex)] {\n"
                output += try oneElementTiedData.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                tiedDataElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementTiedData in tiedData {
                    hashCode = (hashCode &* 31) &+ oneElementTiedData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Xla.UnpackResponse"
        }
        override public func className() -> String {
            return "Xla.UnpackResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Xla.UnpackResponse = Xla.UnpackResponse()
            public func getMessage() -> Xla.UnpackResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var tiedData:Array<Xla.GlobalDataHandle> {
                get {
                    return builderResult.tiedData
                }
                set (value) {
                    builderResult.tiedData = value
                }
            }
            @discardableResult
            public func setTiedData(_ value:Array<Xla.GlobalDataHandle>) -> Xla.UnpackResponse.Builder {
                self.tiedData = value
                return self
            }
            @discardableResult
            public func clearTiedData() -> Xla.UnpackResponse.Builder {
                builderResult.tiedData.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Xla.UnpackResponse.Builder {
                builderResult = Xla.UnpackResponse()
                return self
            }
            override public func clone() throws -> Xla.UnpackResponse.Builder {
                return try Xla.UnpackResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Xla.UnpackResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Xla.UnpackResponse {
                let returnMe:Xla.UnpackResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Xla.UnpackResponse) throws -> Xla.UnpackResponse.Builder {
                if other == Xla.UnpackResponse() {
                    return self
                }
                if !other.tiedData.isEmpty  {
                     builderResult.tiedData += other.tiedData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Xla.UnpackResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.UnpackResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Xla.GlobalDataHandle.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        tiedData.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Xla.UnpackResponse.Builder {
                let resultDecodedBuilder = Xla.UnpackResponse.Builder()
                if let jsonValueTiedData = jsonMap["tiedData"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayTiedData:Array<Xla.GlobalDataHandle> = []
                    for oneValueTiedData in jsonValueTiedData {
                        let messageFromStringTiedData = try Xla.GlobalDataHandle.Builder.decodeToBuilder(jsonMap:oneValueTiedData).build()

                        jsonArrayTiedData.append(messageFromStringTiedData)
                    }
                    resultDecodedBuilder.tiedData = jsonArrayTiedData
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Xla.UnpackResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Xla.UnpackResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Xla.ExecutionOptions: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.ExecutionOptions> {
        var mergedArray = Array<Xla.ExecutionOptions>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.ExecutionOptions? {
        return try Xla.ExecutionOptions.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.ExecutionOptions {
        return try Xla.ExecutionOptions.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecutionOptions {
        return try Xla.ExecutionOptions.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.ExecutionOptions {
        return try Xla.ExecutionOptions.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecutionOptions {
        return try Xla.ExecutionOptions.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.ExecutionOptions {
        return try Xla.ExecutionOptions.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecutionOptions {
        return try Xla.ExecutionOptions.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "disableFastMath": return self.disableFastMath
        case "shapeWithOutputLayout": return self.shapeWithOutputLayout
        case "seed": return self.seed
        default: return nil
        }
    }
}
extension Xla.ExecutionOptions.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "disableFastMath": return self.disableFastMath
            case "shapeWithOutputLayout": return self.shapeWithOutputLayout
            case "seed": return self.seed
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "disableFastMath":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.disableFastMath = newSubscriptValue
            case "shapeWithOutputLayout":
                guard let newSubscriptValue = newSubscriptValue as? Xla.Shape else {
                    return
                }
                self.shapeWithOutputLayout = newSubscriptValue
            case "seed":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.seed = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.SnapshotComputationRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.SnapshotComputationRequest> {
        var mergedArray = Array<Xla.SnapshotComputationRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.SnapshotComputationRequest? {
        return try Xla.SnapshotComputationRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.SnapshotComputationRequest {
        return try Xla.SnapshotComputationRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.SnapshotComputationRequest {
        return try Xla.SnapshotComputationRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.SnapshotComputationRequest {
        return try Xla.SnapshotComputationRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SnapshotComputationRequest {
        return try Xla.SnapshotComputationRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.SnapshotComputationRequest {
        return try Xla.SnapshotComputationRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SnapshotComputationRequest {
        return try Xla.SnapshotComputationRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "computation": return self.computation
        default: return nil
        }
    }
}
extension Xla.SnapshotComputationRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "computation": return self.computation
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "computation":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationHandle else {
                    return
                }
                self.computation = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.SnapshotComputationResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.SnapshotComputationResponse> {
        var mergedArray = Array<Xla.SnapshotComputationResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.SnapshotComputationResponse? {
        return try Xla.SnapshotComputationResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.SnapshotComputationResponse {
        return try Xla.SnapshotComputationResponse.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.SnapshotComputationResponse {
        return try Xla.SnapshotComputationResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.SnapshotComputationResponse {
        return try Xla.SnapshotComputationResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SnapshotComputationResponse {
        return try Xla.SnapshotComputationResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.SnapshotComputationResponse {
        return try Xla.SnapshotComputationResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SnapshotComputationResponse {
        return try Xla.SnapshotComputationResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "module": return self.module
        default: return nil
        }
    }
}
extension Xla.SnapshotComputationResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "module": return self.module
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "module":
                guard let newSubscriptValue = newSubscriptValue as? Xla.SessionModule else {
                    return
                }
                self.module = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.LoadComputationSnapshotRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.LoadComputationSnapshotRequest> {
        var mergedArray = Array<Xla.LoadComputationSnapshotRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.LoadComputationSnapshotRequest? {
        return try Xla.LoadComputationSnapshotRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.LoadComputationSnapshotRequest {
        return try Xla.LoadComputationSnapshotRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.LoadComputationSnapshotRequest {
        return try Xla.LoadComputationSnapshotRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.LoadComputationSnapshotRequest {
        return try Xla.LoadComputationSnapshotRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.LoadComputationSnapshotRequest {
        return try Xla.LoadComputationSnapshotRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.LoadComputationSnapshotRequest {
        return try Xla.LoadComputationSnapshotRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.LoadComputationSnapshotRequest {
        return try Xla.LoadComputationSnapshotRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "module": return self.module
        default: return nil
        }
    }
}
extension Xla.LoadComputationSnapshotRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "module": return self.module
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "module":
                guard let newSubscriptValue = newSubscriptValue as? Xla.SessionModule else {
                    return
                }
                self.module = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.LoadComputationSnapshotResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.LoadComputationSnapshotResponse> {
        var mergedArray = Array<Xla.LoadComputationSnapshotResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.LoadComputationSnapshotResponse? {
        return try Xla.LoadComputationSnapshotResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.LoadComputationSnapshotResponse {
        return try Xla.LoadComputationSnapshotResponse.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.LoadComputationSnapshotResponse {
        return try Xla.LoadComputationSnapshotResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.LoadComputationSnapshotResponse {
        return try Xla.LoadComputationSnapshotResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.LoadComputationSnapshotResponse {
        return try Xla.LoadComputationSnapshotResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.LoadComputationSnapshotResponse {
        return try Xla.LoadComputationSnapshotResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.LoadComputationSnapshotResponse {
        return try Xla.LoadComputationSnapshotResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "computation": return self.computation
        default: return nil
        }
    }
}
extension Xla.LoadComputationSnapshotResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "computation": return self.computation
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "computation":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationHandle else {
                    return
                }
                self.computation = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.GetDeviceHandlesRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.GetDeviceHandlesRequest> {
        var mergedArray = Array<Xla.GetDeviceHandlesRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.GetDeviceHandlesRequest? {
        return try Xla.GetDeviceHandlesRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.GetDeviceHandlesRequest {
        return try Xla.GetDeviceHandlesRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.GetDeviceHandlesRequest {
        return try Xla.GetDeviceHandlesRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.GetDeviceHandlesRequest {
        return try Xla.GetDeviceHandlesRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.GetDeviceHandlesRequest {
        return try Xla.GetDeviceHandlesRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.GetDeviceHandlesRequest {
        return try Xla.GetDeviceHandlesRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.GetDeviceHandlesRequest {
        return try Xla.GetDeviceHandlesRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "deviceCount": return self.deviceCount
        default: return nil
        }
    }
}
extension Xla.GetDeviceHandlesRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "deviceCount": return self.deviceCount
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "deviceCount":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.deviceCount = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.GetDeviceHandlesResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.GetDeviceHandlesResponse> {
        var mergedArray = Array<Xla.GetDeviceHandlesResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.GetDeviceHandlesResponse? {
        return try Xla.GetDeviceHandlesResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.GetDeviceHandlesResponse {
        return try Xla.GetDeviceHandlesResponse.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.GetDeviceHandlesResponse {
        return try Xla.GetDeviceHandlesResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.GetDeviceHandlesResponse {
        return try Xla.GetDeviceHandlesResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.GetDeviceHandlesResponse {
        return try Xla.GetDeviceHandlesResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.GetDeviceHandlesResponse {
        return try Xla.GetDeviceHandlesResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.GetDeviceHandlesResponse {
        return try Xla.GetDeviceHandlesResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "deviceHandles": return self.deviceHandles
        default: return nil
        }
    }
}
extension Xla.GetDeviceHandlesResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "deviceHandles": return self.deviceHandles
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "deviceHandles":
                guard let newSubscriptValue = newSubscriptValue as? Array<Xla.DeviceHandle> else {
                    return
                }
                self.deviceHandles = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.TransferToClientRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.TransferToClientRequest> {
        var mergedArray = Array<Xla.TransferToClientRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.TransferToClientRequest? {
        return try Xla.TransferToClientRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.TransferToClientRequest {
        return try Xla.TransferToClientRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToClientRequest {
        return try Xla.TransferToClientRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.TransferToClientRequest {
        return try Xla.TransferToClientRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToClientRequest {
        return try Xla.TransferToClientRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.TransferToClientRequest {
        return try Xla.TransferToClientRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToClientRequest {
        return try Xla.TransferToClientRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "data": return self.data
        case "shapeWithLayout": return self.shapeWithLayout
        default: return nil
        }
    }
}
extension Xla.TransferToClientRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "data": return self.data
            case "shapeWithLayout": return self.shapeWithLayout
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "data":
                guard let newSubscriptValue = newSubscriptValue as? Xla.GlobalDataHandle else {
                    return
                }
                self.data = newSubscriptValue
            case "shapeWithLayout":
                guard let newSubscriptValue = newSubscriptValue as? Xla.Shape else {
                    return
                }
                self.shapeWithLayout = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.TransferToClientResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.TransferToClientResponse> {
        var mergedArray = Array<Xla.TransferToClientResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.TransferToClientResponse? {
        return try Xla.TransferToClientResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.TransferToClientResponse {
        return try Xla.TransferToClientResponse.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToClientResponse {
        return try Xla.TransferToClientResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.TransferToClientResponse {
        return try Xla.TransferToClientResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToClientResponse {
        return try Xla.TransferToClientResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.TransferToClientResponse {
        return try Xla.TransferToClientResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToClientResponse {
        return try Xla.TransferToClientResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "literal": return self.literal
        default: return nil
        }
    }
}
extension Xla.TransferToClientResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "literal": return self.literal
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "literal":
                guard let newSubscriptValue = newSubscriptValue as? Xla.Literal else {
                    return
                }
                self.literal = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.TransferToServerRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.TransferToServerRequest> {
        var mergedArray = Array<Xla.TransferToServerRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.TransferToServerRequest? {
        return try Xla.TransferToServerRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.TransferToServerRequest {
        return try Xla.TransferToServerRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToServerRequest {
        return try Xla.TransferToServerRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.TransferToServerRequest {
        return try Xla.TransferToServerRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToServerRequest {
        return try Xla.TransferToServerRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.TransferToServerRequest {
        return try Xla.TransferToServerRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToServerRequest {
        return try Xla.TransferToServerRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "literal": return self.literal
        case "deviceHandle": return self.deviceHandle
        default: return nil
        }
    }
}
extension Xla.TransferToServerRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "literal": return self.literal
            case "deviceHandle": return self.deviceHandle
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "literal":
                guard let newSubscriptValue = newSubscriptValue as? Xla.Literal else {
                    return
                }
                self.literal = newSubscriptValue
            case "deviceHandle":
                guard let newSubscriptValue = newSubscriptValue as? Xla.DeviceHandle else {
                    return
                }
                self.deviceHandle = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.TransferToServerResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.TransferToServerResponse> {
        var mergedArray = Array<Xla.TransferToServerResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.TransferToServerResponse? {
        return try Xla.TransferToServerResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.TransferToServerResponse {
        return try Xla.TransferToServerResponse.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToServerResponse {
        return try Xla.TransferToServerResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.TransferToServerResponse {
        return try Xla.TransferToServerResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToServerResponse {
        return try Xla.TransferToServerResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.TransferToServerResponse {
        return try Xla.TransferToServerResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToServerResponse {
        return try Xla.TransferToServerResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "data": return self.data
        default: return nil
        }
    }
}
extension Xla.TransferToServerResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "data": return self.data
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "data":
                guard let newSubscriptValue = newSubscriptValue as? Xla.GlobalDataHandle else {
                    return
                }
                self.data = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.TransferToServerInProcessRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.TransferToServerInProcessRequest> {
        var mergedArray = Array<Xla.TransferToServerInProcessRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.TransferToServerInProcessRequest? {
        return try Xla.TransferToServerInProcessRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.TransferToServerInProcessRequest {
        return try Xla.TransferToServerInProcessRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToServerInProcessRequest {
        return try Xla.TransferToServerInProcessRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.TransferToServerInProcessRequest {
        return try Xla.TransferToServerInProcessRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToServerInProcessRequest {
        return try Xla.TransferToServerInProcessRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.TransferToServerInProcessRequest {
        return try Xla.TransferToServerInProcessRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToServerInProcessRequest {
        return try Xla.TransferToServerInProcessRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "buffer": return self.buffer
        case "shape": return self.shape
        default: return nil
        }
    }
}
extension Xla.TransferToServerInProcessRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "buffer": return self.buffer
            case "shape": return self.shape
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "buffer":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.buffer = newSubscriptValue
            case "shape":
                guard let newSubscriptValue = newSubscriptValue as? Xla.Shape else {
                    return
                }
                self.shape = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.TransferToServerInProcessResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.TransferToServerInProcessResponse> {
        var mergedArray = Array<Xla.TransferToServerInProcessResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.TransferToServerInProcessResponse? {
        return try Xla.TransferToServerInProcessResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.TransferToServerInProcessResponse {
        return try Xla.TransferToServerInProcessResponse.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToServerInProcessResponse {
        return try Xla.TransferToServerInProcessResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.TransferToServerInProcessResponse {
        return try Xla.TransferToServerInProcessResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToServerInProcessResponse {
        return try Xla.TransferToServerInProcessResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.TransferToServerInProcessResponse {
        return try Xla.TransferToServerInProcessResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToServerInProcessResponse {
        return try Xla.TransferToServerInProcessResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "data": return self.data
        default: return nil
        }
    }
}
extension Xla.TransferToServerInProcessResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "data": return self.data
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "data":
                guard let newSubscriptValue = newSubscriptValue as? Xla.GlobalDataHandle else {
                    return
                }
                self.data = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.TransferToClientInProcessRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.TransferToClientInProcessRequest> {
        var mergedArray = Array<Xla.TransferToClientInProcessRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.TransferToClientInProcessRequest? {
        return try Xla.TransferToClientInProcessRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.TransferToClientInProcessRequest {
        return try Xla.TransferToClientInProcessRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToClientInProcessRequest {
        return try Xla.TransferToClientInProcessRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.TransferToClientInProcessRequest {
        return try Xla.TransferToClientInProcessRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToClientInProcessRequest {
        return try Xla.TransferToClientInProcessRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.TransferToClientInProcessRequest {
        return try Xla.TransferToClientInProcessRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToClientInProcessRequest {
        return try Xla.TransferToClientInProcessRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "data": return self.data
        case "buffer": return self.buffer
        default: return nil
        }
    }
}
extension Xla.TransferToClientInProcessRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "data": return self.data
            case "buffer": return self.buffer
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "data":
                guard let newSubscriptValue = newSubscriptValue as? Xla.GlobalDataHandle else {
                    return
                }
                self.data = newSubscriptValue
            case "buffer":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.buffer = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.TransferToClientInProcessResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.TransferToClientInProcessResponse> {
        var mergedArray = Array<Xla.TransferToClientInProcessResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.TransferToClientInProcessResponse? {
        return try Xla.TransferToClientInProcessResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.TransferToClientInProcessResponse {
        return try Xla.TransferToClientInProcessResponse.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToClientInProcessResponse {
        return try Xla.TransferToClientInProcessResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.TransferToClientInProcessResponse {
        return try Xla.TransferToClientInProcessResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToClientInProcessResponse {
        return try Xla.TransferToClientInProcessResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.TransferToClientInProcessResponse {
        return try Xla.TransferToClientInProcessResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToClientInProcessResponse {
        return try Xla.TransferToClientInProcessResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Xla.TransferToClientInProcessResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Xla.TransferToInfeedRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.TransferToInfeedRequest> {
        var mergedArray = Array<Xla.TransferToInfeedRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.TransferToInfeedRequest? {
        return try Xla.TransferToInfeedRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.TransferToInfeedRequest {
        return try Xla.TransferToInfeedRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToInfeedRequest {
        return try Xla.TransferToInfeedRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.TransferToInfeedRequest {
        return try Xla.TransferToInfeedRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToInfeedRequest {
        return try Xla.TransferToInfeedRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.TransferToInfeedRequest {
        return try Xla.TransferToInfeedRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToInfeedRequest {
        return try Xla.TransferToInfeedRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "literal": return self.literal
        case "replicaId": return self.replicaId
        case "deviceHandle": return self.deviceHandle
        default: return nil
        }
    }
}
extension Xla.TransferToInfeedRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "literal": return self.literal
            case "replicaId": return self.replicaId
            case "deviceHandle": return self.deviceHandle
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "literal":
                guard let newSubscriptValue = newSubscriptValue as? Xla.Literal else {
                    return
                }
                self.literal = newSubscriptValue
            case "replicaId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.replicaId = newSubscriptValue
            case "deviceHandle":
                guard let newSubscriptValue = newSubscriptValue as? Xla.DeviceHandle else {
                    return
                }
                self.deviceHandle = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.TransferToInfeedResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.TransferToInfeedResponse> {
        var mergedArray = Array<Xla.TransferToInfeedResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.TransferToInfeedResponse? {
        return try Xla.TransferToInfeedResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.TransferToInfeedResponse {
        return try Xla.TransferToInfeedResponse.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToInfeedResponse {
        return try Xla.TransferToInfeedResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.TransferToInfeedResponse {
        return try Xla.TransferToInfeedResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToInfeedResponse {
        return try Xla.TransferToInfeedResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.TransferToInfeedResponse {
        return try Xla.TransferToInfeedResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferToInfeedResponse {
        return try Xla.TransferToInfeedResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Xla.TransferToInfeedResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Xla.TransferFromOutfeedRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.TransferFromOutfeedRequest> {
        var mergedArray = Array<Xla.TransferFromOutfeedRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.TransferFromOutfeedRequest? {
        return try Xla.TransferFromOutfeedRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.TransferFromOutfeedRequest {
        return try Xla.TransferFromOutfeedRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferFromOutfeedRequest {
        return try Xla.TransferFromOutfeedRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.TransferFromOutfeedRequest {
        return try Xla.TransferFromOutfeedRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferFromOutfeedRequest {
        return try Xla.TransferFromOutfeedRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.TransferFromOutfeedRequest {
        return try Xla.TransferFromOutfeedRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferFromOutfeedRequest {
        return try Xla.TransferFromOutfeedRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "shapeWithLayout": return self.shapeWithLayout
        case "replicaId": return self.replicaId
        case "deviceHandle": return self.deviceHandle
        default: return nil
        }
    }
}
extension Xla.TransferFromOutfeedRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "shapeWithLayout": return self.shapeWithLayout
            case "replicaId": return self.replicaId
            case "deviceHandle": return self.deviceHandle
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "shapeWithLayout":
                guard let newSubscriptValue = newSubscriptValue as? Xla.Shape else {
                    return
                }
                self.shapeWithLayout = newSubscriptValue
            case "replicaId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.replicaId = newSubscriptValue
            case "deviceHandle":
                guard let newSubscriptValue = newSubscriptValue as? Xla.DeviceHandle else {
                    return
                }
                self.deviceHandle = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.TransferFromOutfeedResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.TransferFromOutfeedResponse> {
        var mergedArray = Array<Xla.TransferFromOutfeedResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.TransferFromOutfeedResponse? {
        return try Xla.TransferFromOutfeedResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.TransferFromOutfeedResponse {
        return try Xla.TransferFromOutfeedResponse.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferFromOutfeedResponse {
        return try Xla.TransferFromOutfeedResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.TransferFromOutfeedResponse {
        return try Xla.TransferFromOutfeedResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferFromOutfeedResponse {
        return try Xla.TransferFromOutfeedResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.TransferFromOutfeedResponse {
        return try Xla.TransferFromOutfeedResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.TransferFromOutfeedResponse {
        return try Xla.TransferFromOutfeedResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "literal": return self.literal
        default: return nil
        }
    }
}
extension Xla.TransferFromOutfeedResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "literal": return self.literal
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "literal":
                guard let newSubscriptValue = newSubscriptValue as? Xla.Literal else {
                    return
                }
                self.literal = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.ResetDeviceRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.ResetDeviceRequest> {
        var mergedArray = Array<Xla.ResetDeviceRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.ResetDeviceRequest? {
        return try Xla.ResetDeviceRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.ResetDeviceRequest {
        return try Xla.ResetDeviceRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.ResetDeviceRequest {
        return try Xla.ResetDeviceRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.ResetDeviceRequest {
        return try Xla.ResetDeviceRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ResetDeviceRequest {
        return try Xla.ResetDeviceRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.ResetDeviceRequest {
        return try Xla.ResetDeviceRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ResetDeviceRequest {
        return try Xla.ResetDeviceRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "deviceHandle": return self.deviceHandle
        default: return nil
        }
    }
}
extension Xla.ResetDeviceRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "deviceHandle": return self.deviceHandle
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "deviceHandle":
                guard let newSubscriptValue = newSubscriptValue as? Xla.DeviceHandle else {
                    return
                }
                self.deviceHandle = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.ResetDeviceResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.ResetDeviceResponse> {
        var mergedArray = Array<Xla.ResetDeviceResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.ResetDeviceResponse? {
        return try Xla.ResetDeviceResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.ResetDeviceResponse {
        return try Xla.ResetDeviceResponse.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.ResetDeviceResponse {
        return try Xla.ResetDeviceResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.ResetDeviceResponse {
        return try Xla.ResetDeviceResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ResetDeviceResponse {
        return try Xla.ResetDeviceResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.ResetDeviceResponse {
        return try Xla.ResetDeviceResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ResetDeviceResponse {
        return try Xla.ResetDeviceResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Xla.ResetDeviceResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Xla.ComputationStatsRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.ComputationStatsRequest> {
        var mergedArray = Array<Xla.ComputationStatsRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.ComputationStatsRequest? {
        return try Xla.ComputationStatsRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.ComputationStatsRequest {
        return try Xla.ComputationStatsRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputationStatsRequest {
        return try Xla.ComputationStatsRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.ComputationStatsRequest {
        return try Xla.ComputationStatsRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputationStatsRequest {
        return try Xla.ComputationStatsRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.ComputationStatsRequest {
        return try Xla.ComputationStatsRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputationStatsRequest {
        return try Xla.ComputationStatsRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "computation": return self.computation
        default: return nil
        }
    }
}
extension Xla.ComputationStatsRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "computation": return self.computation
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "computation":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationHandle else {
                    return
                }
                self.computation = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.ComputationStatsResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.ComputationStatsResponse> {
        var mergedArray = Array<Xla.ComputationStatsResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.ComputationStatsResponse? {
        return try Xla.ComputationStatsResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.ComputationStatsResponse {
        return try Xla.ComputationStatsResponse.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputationStatsResponse {
        return try Xla.ComputationStatsResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.ComputationStatsResponse {
        return try Xla.ComputationStatsResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputationStatsResponse {
        return try Xla.ComputationStatsResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.ComputationStatsResponse {
        return try Xla.ComputationStatsResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputationStatsResponse {
        return try Xla.ComputationStatsResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "stats": return self.stats
        default: return nil
        }
    }
}
extension Xla.ComputationStatsResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "stats": return self.stats
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "stats":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationStats else {
                    return
                }
                self.stats = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.ComputationRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.ComputationRequest> {
        var mergedArray = Array<Xla.ComputationRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.ComputationRequest? {
        return try Xla.ComputationRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.ComputationRequest {
        return try Xla.ComputationRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputationRequest {
        return try Xla.ComputationRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.ComputationRequest {
        return try Xla.ComputationRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputationRequest {
        return try Xla.ComputationRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.ComputationRequest {
        return try Xla.ComputationRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputationRequest {
        return try Xla.ComputationRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "name": return self.name
        default: return nil
        }
    }
}
extension Xla.ComputationRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "name": return self.name
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.ComputationResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.ComputationResponse> {
        var mergedArray = Array<Xla.ComputationResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.ComputationResponse? {
        return try Xla.ComputationResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.ComputationResponse {
        return try Xla.ComputationResponse.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputationResponse {
        return try Xla.ComputationResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.ComputationResponse {
        return try Xla.ComputationResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputationResponse {
        return try Xla.ComputationResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.ComputationResponse {
        return try Xla.ComputationResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputationResponse {
        return try Xla.ComputationResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "computation": return self.computation
        default: return nil
        }
    }
}
extension Xla.ComputationResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "computation": return self.computation
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "computation":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationHandle else {
                    return
                }
                self.computation = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.CreateChannelHandleRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.CreateChannelHandleRequest> {
        var mergedArray = Array<Xla.CreateChannelHandleRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.CreateChannelHandleRequest? {
        return try Xla.CreateChannelHandleRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.CreateChannelHandleRequest {
        return try Xla.CreateChannelHandleRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.CreateChannelHandleRequest {
        return try Xla.CreateChannelHandleRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.CreateChannelHandleRequest {
        return try Xla.CreateChannelHandleRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.CreateChannelHandleRequest {
        return try Xla.CreateChannelHandleRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.CreateChannelHandleRequest {
        return try Xla.CreateChannelHandleRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.CreateChannelHandleRequest {
        return try Xla.CreateChannelHandleRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Xla.CreateChannelHandleRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Xla.CreateChannelHandleResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.CreateChannelHandleResponse> {
        var mergedArray = Array<Xla.CreateChannelHandleResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.CreateChannelHandleResponse? {
        return try Xla.CreateChannelHandleResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.CreateChannelHandleResponse {
        return try Xla.CreateChannelHandleResponse.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.CreateChannelHandleResponse {
        return try Xla.CreateChannelHandleResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.CreateChannelHandleResponse {
        return try Xla.CreateChannelHandleResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.CreateChannelHandleResponse {
        return try Xla.CreateChannelHandleResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.CreateChannelHandleResponse {
        return try Xla.CreateChannelHandleResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.CreateChannelHandleResponse {
        return try Xla.CreateChannelHandleResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "channel": return self.channel
        default: return nil
        }
    }
}
extension Xla.CreateChannelHandleResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "channel": return self.channel
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "channel":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ChannelHandle else {
                    return
                }
                self.channel = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.UnregisterRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.UnregisterRequest> {
        var mergedArray = Array<Xla.UnregisterRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.UnregisterRequest? {
        return try Xla.UnregisterRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.UnregisterRequest {
        return try Xla.UnregisterRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.UnregisterRequest {
        return try Xla.UnregisterRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.UnregisterRequest {
        return try Xla.UnregisterRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.UnregisterRequest {
        return try Xla.UnregisterRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.UnregisterRequest {
        return try Xla.UnregisterRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.UnregisterRequest {
        return try Xla.UnregisterRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "data": return self.data
        default: return nil
        }
    }
}
extension Xla.UnregisterRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "data": return self.data
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "data":
                guard let newSubscriptValue = newSubscriptValue as? Xla.GlobalDataHandle else {
                    return
                }
                self.data = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.UnregisterResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.UnregisterResponse> {
        var mergedArray = Array<Xla.UnregisterResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.UnregisterResponse? {
        return try Xla.UnregisterResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.UnregisterResponse {
        return try Xla.UnregisterResponse.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.UnregisterResponse {
        return try Xla.UnregisterResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.UnregisterResponse {
        return try Xla.UnregisterResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.UnregisterResponse {
        return try Xla.UnregisterResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.UnregisterResponse {
        return try Xla.UnregisterResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.UnregisterResponse {
        return try Xla.UnregisterResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Xla.UnregisterResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Xla.SetReturnValueRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.SetReturnValueRequest> {
        var mergedArray = Array<Xla.SetReturnValueRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.SetReturnValueRequest? {
        return try Xla.SetReturnValueRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.SetReturnValueRequest {
        return try Xla.SetReturnValueRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.SetReturnValueRequest {
        return try Xla.SetReturnValueRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.SetReturnValueRequest {
        return try Xla.SetReturnValueRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SetReturnValueRequest {
        return try Xla.SetReturnValueRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.SetReturnValueRequest {
        return try Xla.SetReturnValueRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SetReturnValueRequest {
        return try Xla.SetReturnValueRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "computation": return self.computation
        case "operand": return self.operand
        default: return nil
        }
    }
}
extension Xla.SetReturnValueRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "computation": return self.computation
            case "operand": return self.operand
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "computation":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationHandle else {
                    return
                }
                self.computation = newSubscriptValue
            case "operand":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.operand = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.SetReturnValueResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.SetReturnValueResponse> {
        var mergedArray = Array<Xla.SetReturnValueResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.SetReturnValueResponse? {
        return try Xla.SetReturnValueResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.SetReturnValueResponse {
        return try Xla.SetReturnValueResponse.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.SetReturnValueResponse {
        return try Xla.SetReturnValueResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.SetReturnValueResponse {
        return try Xla.SetReturnValueResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SetReturnValueResponse {
        return try Xla.SetReturnValueResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.SetReturnValueResponse {
        return try Xla.SetReturnValueResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SetReturnValueResponse {
        return try Xla.SetReturnValueResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Xla.SetReturnValueResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Xla.ExecuteRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.ExecuteRequest> {
        var mergedArray = Array<Xla.ExecuteRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.ExecuteRequest? {
        return try Xla.ExecuteRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.ExecuteRequest {
        return try Xla.ExecuteRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecuteRequest {
        return try Xla.ExecuteRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.ExecuteRequest {
        return try Xla.ExecuteRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecuteRequest {
        return try Xla.ExecuteRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.ExecuteRequest {
        return try Xla.ExecuteRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecuteRequest {
        return try Xla.ExecuteRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "computation": return self.computation
        case "arguments": return self.arguments
        case "deviceHandle": return self.deviceHandle
        case "executionOptions": return self.executionOptions
        default: return nil
        }
    }
}
extension Xla.ExecuteRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "computation": return self.computation
            case "arguments": return self.arguments
            case "deviceHandle": return self.deviceHandle
            case "executionOptions": return self.executionOptions
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "computation":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationHandle else {
                    return
                }
                self.computation = newSubscriptValue
            case "arguments":
                guard let newSubscriptValue = newSubscriptValue as? Array<Xla.GlobalDataHandle> else {
                    return
                }
                self.arguments = newSubscriptValue
            case "deviceHandle":
                guard let newSubscriptValue = newSubscriptValue as? Xla.DeviceHandle else {
                    return
                }
                self.deviceHandle = newSubscriptValue
            case "executionOptions":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ExecutionOptions else {
                    return
                }
                self.executionOptions = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.ExecuteParallelRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.ExecuteParallelRequest> {
        var mergedArray = Array<Xla.ExecuteParallelRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.ExecuteParallelRequest? {
        return try Xla.ExecuteParallelRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.ExecuteParallelRequest {
        return try Xla.ExecuteParallelRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecuteParallelRequest {
        return try Xla.ExecuteParallelRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.ExecuteParallelRequest {
        return try Xla.ExecuteParallelRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecuteParallelRequest {
        return try Xla.ExecuteParallelRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.ExecuteParallelRequest {
        return try Xla.ExecuteParallelRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecuteParallelRequest {
        return try Xla.ExecuteParallelRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "requests": return self.requests
        default: return nil
        }
    }
}
extension Xla.ExecuteParallelRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "requests": return self.requests
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "requests":
                guard let newSubscriptValue = newSubscriptValue as? Array<Xla.ExecuteRequest> else {
                    return
                }
                self.requests = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.ExecuteResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.ExecuteResponse> {
        var mergedArray = Array<Xla.ExecuteResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.ExecuteResponse? {
        return try Xla.ExecuteResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.ExecuteResponse {
        return try Xla.ExecuteResponse.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecuteResponse {
        return try Xla.ExecuteResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.ExecuteResponse {
        return try Xla.ExecuteResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecuteResponse {
        return try Xla.ExecuteResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.ExecuteResponse {
        return try Xla.ExecuteResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecuteResponse {
        return try Xla.ExecuteResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "output": return self.output
        case "profile": return self.profile
        default: return nil
        }
    }
}
extension Xla.ExecuteResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "output": return self.output
            case "profile": return self.profile
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "output":
                guard let newSubscriptValue = newSubscriptValue as? Xla.GlobalDataHandle else {
                    return
                }
                self.output = newSubscriptValue
            case "profile":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ExecutionProfile else {
                    return
                }
                self.profile = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.ExecuteParallelResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.ExecuteParallelResponse> {
        var mergedArray = Array<Xla.ExecuteParallelResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.ExecuteParallelResponse? {
        return try Xla.ExecuteParallelResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.ExecuteParallelResponse {
        return try Xla.ExecuteParallelResponse.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecuteParallelResponse {
        return try Xla.ExecuteParallelResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.ExecuteParallelResponse {
        return try Xla.ExecuteParallelResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecuteParallelResponse {
        return try Xla.ExecuteParallelResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.ExecuteParallelResponse {
        return try Xla.ExecuteParallelResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecuteParallelResponse {
        return try Xla.ExecuteParallelResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "responses": return self.responses
        default: return nil
        }
    }
}
extension Xla.ExecuteParallelResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "responses": return self.responses
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "responses":
                guard let newSubscriptValue = newSubscriptValue as? Array<Xla.ExecuteResponse> else {
                    return
                }
                self.responses = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.ExecuteAsyncRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.ExecuteAsyncRequest> {
        var mergedArray = Array<Xla.ExecuteAsyncRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.ExecuteAsyncRequest? {
        return try Xla.ExecuteAsyncRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.ExecuteAsyncRequest {
        return try Xla.ExecuteAsyncRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecuteAsyncRequest {
        return try Xla.ExecuteAsyncRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.ExecuteAsyncRequest {
        return try Xla.ExecuteAsyncRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecuteAsyncRequest {
        return try Xla.ExecuteAsyncRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.ExecuteAsyncRequest {
        return try Xla.ExecuteAsyncRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecuteAsyncRequest {
        return try Xla.ExecuteAsyncRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "computation": return self.computation
        case "arguments": return self.arguments
        case "executionOptions": return self.executionOptions
        default: return nil
        }
    }
}
extension Xla.ExecuteAsyncRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "computation": return self.computation
            case "arguments": return self.arguments
            case "executionOptions": return self.executionOptions
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "computation":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationHandle else {
                    return
                }
                self.computation = newSubscriptValue
            case "arguments":
                guard let newSubscriptValue = newSubscriptValue as? Array<Xla.GlobalDataHandle> else {
                    return
                }
                self.arguments = newSubscriptValue
            case "executionOptions":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ExecutionOptions else {
                    return
                }
                self.executionOptions = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.ExecuteAsyncResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.ExecuteAsyncResponse> {
        var mergedArray = Array<Xla.ExecuteAsyncResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.ExecuteAsyncResponse? {
        return try Xla.ExecuteAsyncResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.ExecuteAsyncResponse {
        return try Xla.ExecuteAsyncResponse.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecuteAsyncResponse {
        return try Xla.ExecuteAsyncResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.ExecuteAsyncResponse {
        return try Xla.ExecuteAsyncResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecuteAsyncResponse {
        return try Xla.ExecuteAsyncResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.ExecuteAsyncResponse {
        return try Xla.ExecuteAsyncResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ExecuteAsyncResponse {
        return try Xla.ExecuteAsyncResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "execution": return self.execution
        default: return nil
        }
    }
}
extension Xla.ExecuteAsyncResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "execution": return self.execution
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "execution":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ExecutionHandle else {
                    return
                }
                self.execution = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.WaitForExecutionRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.WaitForExecutionRequest> {
        var mergedArray = Array<Xla.WaitForExecutionRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.WaitForExecutionRequest? {
        return try Xla.WaitForExecutionRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.WaitForExecutionRequest {
        return try Xla.WaitForExecutionRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.WaitForExecutionRequest {
        return try Xla.WaitForExecutionRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.WaitForExecutionRequest {
        return try Xla.WaitForExecutionRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.WaitForExecutionRequest {
        return try Xla.WaitForExecutionRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.WaitForExecutionRequest {
        return try Xla.WaitForExecutionRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.WaitForExecutionRequest {
        return try Xla.WaitForExecutionRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "execution": return self.execution
        default: return nil
        }
    }
}
extension Xla.WaitForExecutionRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "execution": return self.execution
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "execution":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ExecutionHandle else {
                    return
                }
                self.execution = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.WaitForExecutionResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.WaitForExecutionResponse> {
        var mergedArray = Array<Xla.WaitForExecutionResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.WaitForExecutionResponse? {
        return try Xla.WaitForExecutionResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.WaitForExecutionResponse {
        return try Xla.WaitForExecutionResponse.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.WaitForExecutionResponse {
        return try Xla.WaitForExecutionResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.WaitForExecutionResponse {
        return try Xla.WaitForExecutionResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.WaitForExecutionResponse {
        return try Xla.WaitForExecutionResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.WaitForExecutionResponse {
        return try Xla.WaitForExecutionResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.WaitForExecutionResponse {
        return try Xla.WaitForExecutionResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "output": return self.output
        case "profile": return self.profile
        default: return nil
        }
    }
}
extension Xla.WaitForExecutionResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "output": return self.output
            case "profile": return self.profile
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "output":
                guard let newSubscriptValue = newSubscriptValue as? Xla.GlobalDataHandle else {
                    return
                }
                self.output = newSubscriptValue
            case "profile":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ExecutionProfile else {
                    return
                }
                self.profile = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.IsConstantRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.IsConstantRequest> {
        var mergedArray = Array<Xla.IsConstantRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.IsConstantRequest? {
        return try Xla.IsConstantRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.IsConstantRequest {
        return try Xla.IsConstantRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.IsConstantRequest {
        return try Xla.IsConstantRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.IsConstantRequest {
        return try Xla.IsConstantRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.IsConstantRequest {
        return try Xla.IsConstantRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.IsConstantRequest {
        return try Xla.IsConstantRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.IsConstantRequest {
        return try Xla.IsConstantRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "computation": return self.computation
        case "operand": return self.operand
        default: return nil
        }
    }
}
extension Xla.IsConstantRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "computation": return self.computation
            case "operand": return self.operand
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "computation":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationHandle else {
                    return
                }
                self.computation = newSubscriptValue
            case "operand":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.operand = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.IsConstantResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.IsConstantResponse> {
        var mergedArray = Array<Xla.IsConstantResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.IsConstantResponse? {
        return try Xla.IsConstantResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.IsConstantResponse {
        return try Xla.IsConstantResponse.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.IsConstantResponse {
        return try Xla.IsConstantResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.IsConstantResponse {
        return try Xla.IsConstantResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.IsConstantResponse {
        return try Xla.IsConstantResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.IsConstantResponse {
        return try Xla.IsConstantResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.IsConstantResponse {
        return try Xla.IsConstantResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "isConstant": return self.isConstant
        default: return nil
        }
    }
}
extension Xla.IsConstantResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "isConstant": return self.isConstant
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "isConstant":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.isConstant = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.ComputeConstantRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.ComputeConstantRequest> {
        var mergedArray = Array<Xla.ComputeConstantRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.ComputeConstantRequest? {
        return try Xla.ComputeConstantRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.ComputeConstantRequest {
        return try Xla.ComputeConstantRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputeConstantRequest {
        return try Xla.ComputeConstantRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.ComputeConstantRequest {
        return try Xla.ComputeConstantRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputeConstantRequest {
        return try Xla.ComputeConstantRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.ComputeConstantRequest {
        return try Xla.ComputeConstantRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputeConstantRequest {
        return try Xla.ComputeConstantRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "computation": return self.computation
        case "operand": return self.operand
        case "outputLayout": return self.outputLayout
        default: return nil
        }
    }
}
extension Xla.ComputeConstantRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "computation": return self.computation
            case "operand": return self.operand
            case "outputLayout": return self.outputLayout
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "computation":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationHandle else {
                    return
                }
                self.computation = newSubscriptValue
            case "operand":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationDataHandle else {
                    return
                }
                self.operand = newSubscriptValue
            case "outputLayout":
                guard let newSubscriptValue = newSubscriptValue as? Xla.Layout else {
                    return
                }
                self.outputLayout = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.ComputeConstantResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.ComputeConstantResponse> {
        var mergedArray = Array<Xla.ComputeConstantResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.ComputeConstantResponse? {
        return try Xla.ComputeConstantResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.ComputeConstantResponse {
        return try Xla.ComputeConstantResponse.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputeConstantResponse {
        return try Xla.ComputeConstantResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.ComputeConstantResponse {
        return try Xla.ComputeConstantResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputeConstantResponse {
        return try Xla.ComputeConstantResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.ComputeConstantResponse {
        return try Xla.ComputeConstantResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.ComputeConstantResponse {
        return try Xla.ComputeConstantResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "output": return self.output
        default: return nil
        }
    }
}
extension Xla.ComputeConstantResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "output": return self.output
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "output":
                guard let newSubscriptValue = newSubscriptValue as? Xla.GlobalDataHandle else {
                    return
                }
                self.output = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.DeconstructTupleRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.DeconstructTupleRequest> {
        var mergedArray = Array<Xla.DeconstructTupleRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.DeconstructTupleRequest? {
        return try Xla.DeconstructTupleRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.DeconstructTupleRequest {
        return try Xla.DeconstructTupleRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.DeconstructTupleRequest {
        return try Xla.DeconstructTupleRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.DeconstructTupleRequest {
        return try Xla.DeconstructTupleRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.DeconstructTupleRequest {
        return try Xla.DeconstructTupleRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.DeconstructTupleRequest {
        return try Xla.DeconstructTupleRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.DeconstructTupleRequest {
        return try Xla.DeconstructTupleRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "tupleHandle": return self.tupleHandle
        default: return nil
        }
    }
}
extension Xla.DeconstructTupleRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "tupleHandle": return self.tupleHandle
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "tupleHandle":
                guard let newSubscriptValue = newSubscriptValue as? Xla.GlobalDataHandle else {
                    return
                }
                self.tupleHandle = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.DeconstructTupleResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.DeconstructTupleResponse> {
        var mergedArray = Array<Xla.DeconstructTupleResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.DeconstructTupleResponse? {
        return try Xla.DeconstructTupleResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.DeconstructTupleResponse {
        return try Xla.DeconstructTupleResponse.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.DeconstructTupleResponse {
        return try Xla.DeconstructTupleResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.DeconstructTupleResponse {
        return try Xla.DeconstructTupleResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.DeconstructTupleResponse {
        return try Xla.DeconstructTupleResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.DeconstructTupleResponse {
        return try Xla.DeconstructTupleResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.DeconstructTupleResponse {
        return try Xla.DeconstructTupleResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "elementHandles": return self.elementHandles
        default: return nil
        }
    }
}
extension Xla.DeconstructTupleResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "elementHandles": return self.elementHandles
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "elementHandles":
                guard let newSubscriptValue = newSubscriptValue as? Array<Xla.GlobalDataHandle> else {
                    return
                }
                self.elementHandles = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.LoadDataRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.LoadDataRequest> {
        var mergedArray = Array<Xla.LoadDataRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.LoadDataRequest? {
        return try Xla.LoadDataRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.LoadDataRequest {
        return try Xla.LoadDataRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.LoadDataRequest {
        return try Xla.LoadDataRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.LoadDataRequest {
        return try Xla.LoadDataRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.LoadDataRequest {
        return try Xla.LoadDataRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.LoadDataRequest {
        return try Xla.LoadDataRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.LoadDataRequest {
        return try Xla.LoadDataRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "columnioTabletPath": return self.columnioTabletPath
        case "columnioField": return self.columnioField
        case "elementShape": return self.elementShape
        case "offset": return self.offset
        case "limit": return self.limit
        case "zip": return self.zip
        default: return nil
        }
    }
}
extension Xla.LoadDataRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "columnioTabletPath": return self.columnioTabletPath
            case "columnioField": return self.columnioField
            case "elementShape": return self.elementShape
            case "offset": return self.offset
            case "limit": return self.limit
            case "zip": return self.zip
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "columnioTabletPath":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.columnioTabletPath = newSubscriptValue
            case "columnioField":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.columnioField = newSubscriptValue
            case "elementShape":
                guard let newSubscriptValue = newSubscriptValue as? Xla.Shape else {
                    return
                }
                self.elementShape = newSubscriptValue
            case "offset":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.offset = newSubscriptValue
            case "limit":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.limit = newSubscriptValue
            case "zip":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.zip = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.LoadDataResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.LoadDataResponse> {
        var mergedArray = Array<Xla.LoadDataResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.LoadDataResponse? {
        return try Xla.LoadDataResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.LoadDataResponse {
        return try Xla.LoadDataResponse.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.LoadDataResponse {
        return try Xla.LoadDataResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.LoadDataResponse {
        return try Xla.LoadDataResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.LoadDataResponse {
        return try Xla.LoadDataResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.LoadDataResponse {
        return try Xla.LoadDataResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.LoadDataResponse {
        return try Xla.LoadDataResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "data": return self.data
        case "dataShape": return self.dataShape
        case "availableRows": return self.availableRows
        case "rowsLoaded": return self.rowsLoaded
        case "nanoseconds": return self.nanoseconds
        default: return nil
        }
    }
}
extension Xla.LoadDataResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "data": return self.data
            case "dataShape": return self.dataShape
            case "availableRows": return self.availableRows
            case "rowsLoaded": return self.rowsLoaded
            case "nanoseconds": return self.nanoseconds
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "data":
                guard let newSubscriptValue = newSubscriptValue as? Xla.GlobalDataHandle else {
                    return
                }
                self.data = newSubscriptValue
            case "dataShape":
                guard let newSubscriptValue = newSubscriptValue as? Xla.Shape else {
                    return
                }
                self.dataShape = newSubscriptValue
            case "availableRows":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.availableRows = newSubscriptValue
            case "rowsLoaded":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.rowsLoaded = newSubscriptValue
            case "nanoseconds":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.nanoseconds = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.SpecializeRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.SpecializeRequest> {
        var mergedArray = Array<Xla.SpecializeRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.SpecializeRequest? {
        return try Xla.SpecializeRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.SpecializeRequest {
        return try Xla.SpecializeRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.SpecializeRequest {
        return try Xla.SpecializeRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.SpecializeRequest {
        return try Xla.SpecializeRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SpecializeRequest {
        return try Xla.SpecializeRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.SpecializeRequest {
        return try Xla.SpecializeRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SpecializeRequest {
        return try Xla.SpecializeRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "computation": return self.computation
        case "arguments": return self.arguments
        default: return nil
        }
    }
}
extension Xla.SpecializeRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "computation": return self.computation
            case "arguments": return self.arguments
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "computation":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationHandle else {
                    return
                }
                self.computation = newSubscriptValue
            case "arguments":
                guard let newSubscriptValue = newSubscriptValue as? Array<Xla.GlobalDataHandle> else {
                    return
                }
                self.arguments = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.SpecializeResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.SpecializeResponse> {
        var mergedArray = Array<Xla.SpecializeResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.SpecializeResponse? {
        return try Xla.SpecializeResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.SpecializeResponse {
        return try Xla.SpecializeResponse.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.SpecializeResponse {
        return try Xla.SpecializeResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.SpecializeResponse {
        return try Xla.SpecializeResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SpecializeResponse {
        return try Xla.SpecializeResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.SpecializeResponse {
        return try Xla.SpecializeResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.SpecializeResponse {
        return try Xla.SpecializeResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Xla.SpecializeResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Xla.GetShapeRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.GetShapeRequest> {
        var mergedArray = Array<Xla.GetShapeRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.GetShapeRequest? {
        return try Xla.GetShapeRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.GetShapeRequest {
        return try Xla.GetShapeRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.GetShapeRequest {
        return try Xla.GetShapeRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.GetShapeRequest {
        return try Xla.GetShapeRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.GetShapeRequest {
        return try Xla.GetShapeRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.GetShapeRequest {
        return try Xla.GetShapeRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.GetShapeRequest {
        return try Xla.GetShapeRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "data": return self.data
        default: return nil
        }
    }
}
extension Xla.GetShapeRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "data": return self.data
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "data":
                guard let newSubscriptValue = newSubscriptValue as? Xla.GlobalDataHandle else {
                    return
                }
                self.data = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.GetShapeResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.GetShapeResponse> {
        var mergedArray = Array<Xla.GetShapeResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.GetShapeResponse? {
        return try Xla.GetShapeResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.GetShapeResponse {
        return try Xla.GetShapeResponse.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.GetShapeResponse {
        return try Xla.GetShapeResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.GetShapeResponse {
        return try Xla.GetShapeResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.GetShapeResponse {
        return try Xla.GetShapeResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.GetShapeResponse {
        return try Xla.GetShapeResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.GetShapeResponse {
        return try Xla.GetShapeResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "shape": return self.shape
        default: return nil
        }
    }
}
extension Xla.GetShapeResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "shape": return self.shape
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "shape":
                guard let newSubscriptValue = newSubscriptValue as? Xla.Shape else {
                    return
                }
                self.shape = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.GetComputationShapeRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.GetComputationShapeRequest> {
        var mergedArray = Array<Xla.GetComputationShapeRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.GetComputationShapeRequest? {
        return try Xla.GetComputationShapeRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.GetComputationShapeRequest {
        return try Xla.GetComputationShapeRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.GetComputationShapeRequest {
        return try Xla.GetComputationShapeRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.GetComputationShapeRequest {
        return try Xla.GetComputationShapeRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.GetComputationShapeRequest {
        return try Xla.GetComputationShapeRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.GetComputationShapeRequest {
        return try Xla.GetComputationShapeRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.GetComputationShapeRequest {
        return try Xla.GetComputationShapeRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "computation": return self.computation
        default: return nil
        }
    }
}
extension Xla.GetComputationShapeRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "computation": return self.computation
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "computation":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ComputationHandle else {
                    return
                }
                self.computation = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.GetComputationShapeResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.GetComputationShapeResponse> {
        var mergedArray = Array<Xla.GetComputationShapeResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.GetComputationShapeResponse? {
        return try Xla.GetComputationShapeResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.GetComputationShapeResponse {
        return try Xla.GetComputationShapeResponse.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.GetComputationShapeResponse {
        return try Xla.GetComputationShapeResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.GetComputationShapeResponse {
        return try Xla.GetComputationShapeResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.GetComputationShapeResponse {
        return try Xla.GetComputationShapeResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.GetComputationShapeResponse {
        return try Xla.GetComputationShapeResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.GetComputationShapeResponse {
        return try Xla.GetComputationShapeResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "programShape": return self.programShape
        default: return nil
        }
    }
}
extension Xla.GetComputationShapeResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "programShape": return self.programShape
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "programShape":
                guard let newSubscriptValue = newSubscriptValue as? Xla.ProgramShape else {
                    return
                }
                self.programShape = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.UnpackRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.UnpackRequest> {
        var mergedArray = Array<Xla.UnpackRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.UnpackRequest? {
        return try Xla.UnpackRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.UnpackRequest {
        return try Xla.UnpackRequest.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.UnpackRequest {
        return try Xla.UnpackRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.UnpackRequest {
        return try Xla.UnpackRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.UnpackRequest {
        return try Xla.UnpackRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.UnpackRequest {
        return try Xla.UnpackRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.UnpackRequest {
        return try Xla.UnpackRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "data": return self.data
        default: return nil
        }
    }
}
extension Xla.UnpackRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "data": return self.data
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "data":
                guard let newSubscriptValue = newSubscriptValue as? Xla.GlobalDataHandle else {
                    return
                }
                self.data = newSubscriptValue
            default: return
            }
        }
    }
}
extension Xla.UnpackResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Xla.UnpackResponse> {
        var mergedArray = Array<Xla.UnpackResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Xla.UnpackResponse? {
        return try Xla.UnpackResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Xla.UnpackResponse {
        return try Xla.UnpackResponse.Builder().mergeFrom(data: data, extensionRegistry:Xla.XlaRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Xla.UnpackResponse {
        return try Xla.UnpackResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Xla.UnpackResponse {
        return try Xla.UnpackResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.UnpackResponse {
        return try Xla.UnpackResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Xla.UnpackResponse {
        return try Xla.UnpackResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Xla.UnpackResponse {
        return try Xla.UnpackResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "tiedData": return self.tiedData
        default: return nil
        }
    }
}
extension Xla.UnpackResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "tiedData": return self.tiedData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "tiedData":
                guard let newSubscriptValue = newSubscriptValue as? Array<Xla.GlobalDataHandle> else {
                    return
                }
                self.tiedData = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

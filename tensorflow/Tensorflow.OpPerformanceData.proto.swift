/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "op_performance_data.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { }

public extension Tensorflow {
    public struct OpPerformanceDataRoot {
        public static let `default` = OpPerformanceDataRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Tensorflow.TensorRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.TensorShapeRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.TypesRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.AttrValueRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    /// Description of an operation as well as the parameters expected to impact its
    /// performance.
    final public class OpInfo : GeneratedMessage {

        public static func == (lhs: Tensorflow.OpInfo, rhs: Tensorflow.OpInfo) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasOp == rhs.hasOp) && (!lhs.hasOp || lhs.op == rhs.op)
            fieldCheck = fieldCheck && (lhs.hasAttr == rhs.hasAttr) && (!lhs.hasAttr || lhs.attr == rhs.attr)
            fieldCheck = fieldCheck && (lhs.inputs == rhs.inputs)
            fieldCheck = fieldCheck && (lhs.hasDevice == rhs.hasDevice) && (!lhs.hasDevice || lhs.device == rhs.device)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        final public class AttrEntry : GeneratedMessage {

            public static func == (lhs: Tensorflow.OpInfo.AttrEntry, rhs: Tensorflow.OpInfo.AttrEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:String = ""
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:Tensorflow.AttrValue!
            public fileprivate(set) var hasValue:Bool = false
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeString(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeMessage(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeStringSize(fieldNumber: 1)
                }
                if hasValue {
                    if let varSizevalue = value?.computeMessageSize(fieldNumber: 2) {
                        serialize_size += varSizevalue
                    }
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.OpInfo.AttrEntry.Builder {
                return Tensorflow.OpInfo.AttrEntry.classBuilder() as! Tensorflow.OpInfo.AttrEntry.Builder
            }
            public func getBuilder() -> Tensorflow.OpInfo.AttrEntry.Builder {
                return classBuilder() as! Tensorflow.OpInfo.AttrEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.OpInfo.AttrEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.OpInfo.AttrEntry.Builder()
            }
            public func toBuilder() throws -> Tensorflow.OpInfo.AttrEntry.Builder {
                return try Tensorflow.OpInfo.AttrEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.OpInfo.AttrEntry) throws -> Tensorflow.OpInfo.AttrEntry.Builder {
                return try Tensorflow.OpInfo.AttrEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = key
                }
                if hasValue {
                    jsonMap["value"] = try value.encode()
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OpInfo.AttrEntry {
                return try Tensorflow.OpInfo.AttrEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.OpInfo.AttrEntry {
                return try Tensorflow.OpInfo.AttrEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value {\n"
                    if let outDescValue = value {
                        output += try outDescValue.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        if let hashValuevalue = value?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuevalue
                        }
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.OpInfo.AttrEntry"
            }
            override public func className() -> String {
                return "Tensorflow.OpInfo.AttrEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.OpInfo.AttrEntry = Tensorflow.OpInfo.AttrEntry()
                public func getMessage() -> Tensorflow.OpInfo.AttrEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:String {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:String) -> Tensorflow.OpInfo.AttrEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> Tensorflow.OpInfo.AttrEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = ""
                    return self
                }
                public var value:Tensorflow.AttrValue! {
                    get {
                        if valueBuilder_ != nil {
                            builderResult.value = valueBuilder_.getMessage()
                        }
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                fileprivate var valueBuilder_:Tensorflow.AttrValue.Builder! {
                    didSet {
                        builderResult.hasValue = true
                    }
                }
                public func getValueBuilder() -> Tensorflow.AttrValue.Builder {
                    if valueBuilder_ == nil {
                        valueBuilder_ = Tensorflow.AttrValue.Builder()
                        builderResult.value = valueBuilder_.getMessage()
                        if value != nil {
                            try! valueBuilder_.mergeFrom(other: value)
                        }
                    }
                    return valueBuilder_
                }
                @discardableResult
                public func setValue(_ value:Tensorflow.AttrValue!) -> Tensorflow.OpInfo.AttrEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func mergeValue(value:Tensorflow.AttrValue) throws -> Tensorflow.OpInfo.AttrEntry.Builder {
                    if builderResult.hasValue {
                        builderResult.value = try Tensorflow.AttrValue.builderWithPrototype(prototype:builderResult.value).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.value = value
                    }
                    builderResult.hasValue = true
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.OpInfo.AttrEntry.Builder {
                    valueBuilder_ = nil
                    builderResult.hasValue = false
                    builderResult.value = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.OpInfo.AttrEntry.Builder {
                    builderResult = Tensorflow.OpInfo.AttrEntry()
                    return self
                }
                override public func clone() throws -> Tensorflow.OpInfo.AttrEntry.Builder {
                    return try Tensorflow.OpInfo.AttrEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.OpInfo.AttrEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.OpInfo.AttrEntry {
                    let returnMe:Tensorflow.OpInfo.AttrEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.OpInfo.AttrEntry) throws -> Tensorflow.OpInfo.AttrEntry.Builder {
                    if other == Tensorflow.OpInfo.AttrEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if (other.hasValue) {
                        try mergeValue(value: other.value)
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OpInfo.AttrEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpInfo.AttrEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            key = try codedInputStream.readString()

                        case 18:
                            let subBuilder:Tensorflow.AttrValue.Builder = Tensorflow.AttrValue.Builder()
                            if hasValue {
                                try subBuilder.mergeFrom(other: value)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            value = subBuilder.buildPartial()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OpInfo.AttrEntry.Builder {
                    let resultDecodedBuilder = Tensorflow.OpInfo.AttrEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = jsonValueKey
                    }
                    if let jsonValueValue = jsonMap["value"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.value = try Tensorflow.AttrValue.Builder.decodeToBuilder(jsonMap:jsonValueValue).build()

                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.OpInfo.AttrEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.OpInfo.AttrEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        /// Input types, shapes and values if known.
        final public class TensorProperties : GeneratedMessage {

            public static func == (lhs: Tensorflow.OpInfo.TensorProperties, rhs: Tensorflow.OpInfo.TensorProperties) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasDtype == rhs.hasDtype) && (!lhs.hasDtype || lhs.dtype == rhs.dtype)
                fieldCheck = fieldCheck && (lhs.hasShape == rhs.hasShape) && (!lhs.hasShape || lhs.shape == rhs.shape)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var dtype:Tensorflow.DataType = Tensorflow.DataType.dtInvalid
            public fileprivate(set) var hasDtype:Bool = false
            public fileprivate(set) var shape:Tensorflow.TensorShapeProto!
            public fileprivate(set) var hasShape:Bool = false
            public fileprivate(set) var value:Tensorflow.TensorProto!
            public fileprivate(set) var hasValue:Bool = false
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasDtype {
                    try codedOutputStream.writeEnum(fieldNumber: 1, value:dtype.rawValue)
                }
                if hasShape {
                    try codedOutputStream.writeMessage(fieldNumber: 2, value:shape)
                }
                if hasValue {
                    try codedOutputStream.writeMessage(fieldNumber: 3, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if (hasDtype) {
                    serialize_size += dtype.rawValue.computeEnumSize(fieldNumber: 1)
                }
                if hasShape {
                    if let varSizeshape = shape?.computeMessageSize(fieldNumber: 2) {
                        serialize_size += varSizeshape
                    }
                }
                if hasValue {
                    if let varSizevalue = value?.computeMessageSize(fieldNumber: 3) {
                        serialize_size += varSizevalue
                    }
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.OpInfo.TensorProperties.Builder {
                return Tensorflow.OpInfo.TensorProperties.classBuilder() as! Tensorflow.OpInfo.TensorProperties.Builder
            }
            public func getBuilder() -> Tensorflow.OpInfo.TensorProperties.Builder {
                return classBuilder() as! Tensorflow.OpInfo.TensorProperties.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.OpInfo.TensorProperties.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.OpInfo.TensorProperties.Builder()
            }
            public func toBuilder() throws -> Tensorflow.OpInfo.TensorProperties.Builder {
                return try Tensorflow.OpInfo.TensorProperties.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.OpInfo.TensorProperties) throws -> Tensorflow.OpInfo.TensorProperties.Builder {
                return try Tensorflow.OpInfo.TensorProperties.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasDtype {
                    jsonMap["dtype"] = dtype.toString()
                }
                if hasShape {
                    jsonMap["shape"] = try shape.encode()
                }
                if hasValue {
                    jsonMap["value"] = try value.encode()
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OpInfo.TensorProperties {
                return try Tensorflow.OpInfo.TensorProperties.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.OpInfo.TensorProperties {
                return try Tensorflow.OpInfo.TensorProperties.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if (hasDtype) {
                    output += "\(indent) dtype: \(dtype.description)\n"
                }
                if hasShape {
                    output += "\(indent) shape {\n"
                    if let outDescShape = shape {
                        output += try outDescShape.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                if hasValue {
                    output += "\(indent) value {\n"
                    if let outDescValue = value {
                        output += try outDescValue.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasDtype {
                         hashCode = (hashCode &* 31) &+ dtype.hashValue
                    }
                    if hasShape {
                        if let hashValueshape = shape?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValueshape
                        }
                    }
                    if hasValue {
                        if let hashValuevalue = value?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuevalue
                        }
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.OpInfo.TensorProperties"
            }
            override public func className() -> String {
                return "Tensorflow.OpInfo.TensorProperties"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.OpInfo.TensorProperties = Tensorflow.OpInfo.TensorProperties()
                public func getMessage() -> Tensorflow.OpInfo.TensorProperties {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                    public var dtype:Tensorflow.DataType {
                        get {
                            return builderResult.dtype
                        }
                        set (value) {
                            builderResult.hasDtype = true
                            builderResult.dtype = value
                        }
                    }
                    public var hasDtype:Bool{
                        get {
                            return builderResult.hasDtype
                        }
                    }
                @discardableResult
                    public func setDtype(_ value:Tensorflow.DataType) -> Tensorflow.OpInfo.TensorProperties.Builder {
                      self.dtype = value
                      return self
                    }
                @discardableResult
                    public func clearDtype() -> Tensorflow.OpInfo.TensorProperties.Builder {
                       builderResult.hasDtype = false
                       builderResult.dtype = .dtInvalid
                       return self
                    }
                public var shape:Tensorflow.TensorShapeProto! {
                    get {
                        if shapeBuilder_ != nil {
                            builderResult.shape = shapeBuilder_.getMessage()
                        }
                        return builderResult.shape
                    }
                    set (value) {
                        builderResult.hasShape = true
                        builderResult.shape = value
                    }
                }
                public var hasShape:Bool {
                    get {
                        return builderResult.hasShape
                    }
                }
                fileprivate var shapeBuilder_:Tensorflow.TensorShapeProto.Builder! {
                    didSet {
                        builderResult.hasShape = true
                    }
                }
                public func getShapeBuilder() -> Tensorflow.TensorShapeProto.Builder {
                    if shapeBuilder_ == nil {
                        shapeBuilder_ = Tensorflow.TensorShapeProto.Builder()
                        builderResult.shape = shapeBuilder_.getMessage()
                        if shape != nil {
                            try! shapeBuilder_.mergeFrom(other: shape)
                        }
                    }
                    return shapeBuilder_
                }
                @discardableResult
                public func setShape(_ value:Tensorflow.TensorShapeProto!) -> Tensorflow.OpInfo.TensorProperties.Builder {
                    self.shape = value
                    return self
                }
                @discardableResult
                public func mergeShape(value:Tensorflow.TensorShapeProto) throws -> Tensorflow.OpInfo.TensorProperties.Builder {
                    if builderResult.hasShape {
                        builderResult.shape = try Tensorflow.TensorShapeProto.builderWithPrototype(prototype:builderResult.shape).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.shape = value
                    }
                    builderResult.hasShape = true
                    return self
                }
                @discardableResult
                public func clearShape() -> Tensorflow.OpInfo.TensorProperties.Builder {
                    shapeBuilder_ = nil
                    builderResult.hasShape = false
                    builderResult.shape = nil
                    return self
                }
                public var value:Tensorflow.TensorProto! {
                    get {
                        if valueBuilder_ != nil {
                            builderResult.value = valueBuilder_.getMessage()
                        }
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                fileprivate var valueBuilder_:Tensorflow.TensorProto.Builder! {
                    didSet {
                        builderResult.hasValue = true
                    }
                }
                public func getValueBuilder() -> Tensorflow.TensorProto.Builder {
                    if valueBuilder_ == nil {
                        valueBuilder_ = Tensorflow.TensorProto.Builder()
                        builderResult.value = valueBuilder_.getMessage()
                        if value != nil {
                            try! valueBuilder_.mergeFrom(other: value)
                        }
                    }
                    return valueBuilder_
                }
                @discardableResult
                public func setValue(_ value:Tensorflow.TensorProto!) -> Tensorflow.OpInfo.TensorProperties.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func mergeValue(value:Tensorflow.TensorProto) throws -> Tensorflow.OpInfo.TensorProperties.Builder {
                    if builderResult.hasValue {
                        builderResult.value = try Tensorflow.TensorProto.builderWithPrototype(prototype:builderResult.value).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.value = value
                    }
                    builderResult.hasValue = true
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.OpInfo.TensorProperties.Builder {
                    valueBuilder_ = nil
                    builderResult.hasValue = false
                    builderResult.value = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.OpInfo.TensorProperties.Builder {
                    builderResult = Tensorflow.OpInfo.TensorProperties()
                    return self
                }
                override public func clone() throws -> Tensorflow.OpInfo.TensorProperties.Builder {
                    return try Tensorflow.OpInfo.TensorProperties.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.OpInfo.TensorProperties {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.OpInfo.TensorProperties {
                    let returnMe:Tensorflow.OpInfo.TensorProperties = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.OpInfo.TensorProperties) throws -> Tensorflow.OpInfo.TensorProperties.Builder {
                    if other == Tensorflow.OpInfo.TensorProperties() {
                        return self
                    }
                    if other.hasDtype {
                        dtype = other.dtype
                    }
                    if (other.hasShape) {
                        try mergeShape(value: other.shape)
                    }
                    if (other.hasValue) {
                        try mergeValue(value: other.value)
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OpInfo.TensorProperties.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpInfo.TensorProperties.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 8:
                            let valueIntdtype = try codedInputStream.readEnum()
                            if let enumsdtype = Tensorflow.DataType(rawValue:valueIntdtype){
                                dtype = enumsdtype
                            } else {
                                try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntdtype))
                            }

                        case 18:
                            let subBuilder:Tensorflow.TensorShapeProto.Builder = Tensorflow.TensorShapeProto.Builder()
                            if hasShape {
                                try subBuilder.mergeFrom(other: shape)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            shape = subBuilder.buildPartial()

                        case 26:
                            let subBuilder:Tensorflow.TensorProto.Builder = Tensorflow.TensorProto.Builder()
                            if hasValue {
                                try subBuilder.mergeFrom(other: value)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            value = subBuilder.buildPartial()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OpInfo.TensorProperties.Builder {
                    let resultDecodedBuilder = Tensorflow.OpInfo.TensorProperties.Builder()
                    if let jsonValueDtype = jsonMap["dtype"] as? String {
                        resultDecodedBuilder.dtype = try Tensorflow.DataType.fromString(str: jsonValueDtype)
                    }
                    if let jsonValueShape = jsonMap["shape"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.shape = try Tensorflow.TensorShapeProto.Builder.decodeToBuilder(jsonMap:jsonValueShape).build()

                    }
                    if let jsonValueValue = jsonMap["value"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.value = try Tensorflow.TensorProto.Builder.decodeToBuilder(jsonMap:jsonValueValue).build()

                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.OpInfo.TensorProperties.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.OpInfo.TensorProperties.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        /// Device on which the operation is run.
        final public class DeviceProperties : GeneratedMessage {

            public static func == (lhs: Tensorflow.OpInfo.DeviceProperties, rhs: Tensorflow.OpInfo.DeviceProperties) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasType == rhs.hasType) && (!lhs.hasType || lhs.type == rhs.type)
                fieldCheck = fieldCheck && (lhs.hasVendor == rhs.hasVendor) && (!lhs.hasVendor || lhs.vendor == rhs.vendor)
                fieldCheck = fieldCheck && (lhs.hasModel == rhs.hasModel) && (!lhs.hasModel || lhs.model == rhs.model)
                fieldCheck = fieldCheck && (lhs.hasFrequency == rhs.hasFrequency) && (!lhs.hasFrequency || lhs.frequency == rhs.frequency)
                fieldCheck = fieldCheck && (lhs.hasNumCores == rhs.hasNumCores) && (!lhs.hasNumCores || lhs.numCores == rhs.numCores)
                fieldCheck = fieldCheck && (lhs.hasEnvironment == rhs.hasEnvironment) && (!lhs.hasEnvironment || lhs.environment == rhs.environment)
                fieldCheck = fieldCheck && (lhs.hasNumRegisters == rhs.hasNumRegisters) && (!lhs.hasNumRegisters || lhs.numRegisters == rhs.numRegisters)
                fieldCheck = fieldCheck && (lhs.hasL1CacheSize == rhs.hasL1CacheSize) && (!lhs.hasL1CacheSize || lhs.l1CacheSize == rhs.l1CacheSize)
                fieldCheck = fieldCheck && (lhs.hasL2CacheSize == rhs.hasL2CacheSize) && (!lhs.hasL2CacheSize || lhs.l2CacheSize == rhs.l2CacheSize)
                fieldCheck = fieldCheck && (lhs.hasL3CacheSize == rhs.hasL3CacheSize) && (!lhs.hasL3CacheSize || lhs.l3CacheSize == rhs.l3CacheSize)
                fieldCheck = fieldCheck && (lhs.hasSharedMemorySizePerMultiprocessor == rhs.hasSharedMemorySizePerMultiprocessor) && (!lhs.hasSharedMemorySizePerMultiprocessor || lhs.sharedMemorySizePerMultiprocessor == rhs.sharedMemorySizePerMultiprocessor)
                fieldCheck = fieldCheck && (lhs.hasMemorySize == rhs.hasMemorySize) && (!lhs.hasMemorySize || lhs.memorySize == rhs.memorySize)
                fieldCheck = fieldCheck && (lhs.hasBandwidth == rhs.hasBandwidth) && (!lhs.hasBandwidth || lhs.bandwidth == rhs.bandwidth)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }



            //Nested type declaration start

            final public class EnvironmentEntry : GeneratedMessage {

                public static func == (lhs: Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry, rhs: Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry) -> Bool {
                    if lhs === rhs {
                        return true
                    }
                    var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                    fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                    fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                    fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                    return fieldCheck
                }

                public fileprivate(set) var key:String = ""
                public fileprivate(set) var hasKey:Bool = false

                public fileprivate(set) var value:String = ""
                public fileprivate(set) var hasValue:Bool = false

                required public init() {
                    super.init()
                }
                override public func isInitialized() -> Bool {
                    return true
                }
                override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                    if hasKey {
                        try codedOutputStream.writeString(fieldNumber: 1, value:key)
                    }
                    if hasValue {
                        try codedOutputStream.writeString(fieldNumber: 2, value:value)
                    }
                    try unknownFields.writeTo(codedOutputStream: codedOutputStream)
                }
                override public func serializedSize() -> Int32 {
                    var serialize_size:Int32 = memoizedSerializedSize
                    if serialize_size != -1 {
                     return serialize_size
                    }

                    serialize_size = 0
                    if hasKey {
                        serialize_size += key.computeStringSize(fieldNumber: 1)
                    }
                    if hasValue {
                        serialize_size += value.computeStringSize(fieldNumber: 2)
                    }
                    serialize_size += unknownFields.serializedSize()
                    memoizedSerializedSize = serialize_size
                    return serialize_size
                }
                public class func getBuilder() -> Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder {
                    return Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.classBuilder() as! Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder
                }
                public func getBuilder() -> Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder {
                    return classBuilder() as! Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder
                }
                override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                    return Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder()
                }
                override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                    return Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder()
                }
                public func toBuilder() throws -> Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder {
                    return try Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.builderWithPrototype(prototype:self)
                }
                public class func builderWithPrototype(prototype:Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry) throws -> Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder {
                    return try Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder().mergeFrom(other:prototype)
                }
                override public func encode() throws -> Dictionary<String,Any> {
                    guard isInitialized() else {
                        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                    }

                    var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                    if hasKey {
                        jsonMap["key"] = key
                    }
                    if hasValue {
                        jsonMap["value"] = value
                    }
                    return jsonMap
                }
                override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry {
                    return try Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
                }
                override class public func fromJSON(data:Data) throws -> Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry {
                    return try Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder.fromJSONToBuilder(data:data).build()
                }
                override public func getDescription(indent:String) throws -> String {
                    var output = ""
                    if hasKey {
                        output += "\(indent) key: \(key) \n"
                    }
                    if hasValue {
                        output += "\(indent) value: \(value) \n"
                    }
                    output += unknownFields.getDescription(indent: indent)
                    return output
                }
                override public var hashValue:Int {
                    get {
                        var hashCode:Int = 7
                        if hasKey {
                            hashCode = (hashCode &* 31) &+ key.hashValue
                        }
                        if hasValue {
                            hashCode = (hashCode &* 31) &+ value.hashValue
                        }
                        hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                        return hashCode
                    }
                }


                //Meta information declaration start

                override public class func className() -> String {
                    return "Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry"
                }
                override public func className() -> String {
                    return "Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry"
                }
                //Meta information declaration end

                final public class Builder : GeneratedMessageBuilder {
                    fileprivate var builderResult:Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry = Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry()
                    public func getMessage() -> Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry {
                        return builderResult
                    }

                    required override public init () {
                        super.init()
                    }
                    public var key:String {
                        get {
                            return builderResult.key
                        }
                        set (value) {
                            builderResult.hasKey = true
                            builderResult.key = value
                        }
                    }
                    public var hasKey:Bool {
                        get {
                            return builderResult.hasKey
                        }
                    }
                    @discardableResult
                    public func setKey(_ value:String) -> Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder {
                        self.key = value
                        return self
                    }
                    @discardableResult
                    public func clearKey() -> Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder{
                        builderResult.hasKey = false
                        builderResult.key = ""
                        return self
                    }
                    public var value:String {
                        get {
                            return builderResult.value
                        }
                        set (value) {
                            builderResult.hasValue = true
                            builderResult.value = value
                        }
                    }
                    public var hasValue:Bool {
                        get {
                            return builderResult.hasValue
                        }
                    }
                    @discardableResult
                    public func setValue(_ value:String) -> Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder {
                        self.value = value
                        return self
                    }
                    @discardableResult
                    public func clearValue() -> Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder{
                        builderResult.hasValue = false
                        builderResult.value = ""
                        return self
                    }
                    override public var internalGetResult:GeneratedMessage {
                        get {
                            return builderResult
                        }
                    }
                    @discardableResult
                    override public func clear() -> Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder {
                        builderResult = Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry()
                        return self
                    }
                    override public func clone() throws -> Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder {
                        return try Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.builderWithPrototype(prototype:builderResult)
                    }
                    override public func build() throws -> Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry {
                        try checkInitialized()
                        return buildPartial()
                    }
                    public func buildPartial() -> Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry {
                        let returnMe:Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry = builderResult
                        return returnMe
                    }
                    @discardableResult
                    public func mergeFrom(other:Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry) throws -> Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder {
                        if other == Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry() {
                            return self
                        }
                        if other.hasKey {
                            key = other.key
                        }
                        if other.hasValue {
                            value = other.value
                        }
                        try merge(unknownField: other.unknownFields)
                        return self
                    }
                    @discardableResult
                    override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder {
                        return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                    }
                    @discardableResult
                    override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder {
                        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                        while (true) {
                            let protobufTag = try codedInputStream.readTag()
                            switch protobufTag {
                            case 0: 
                                self.unknownFields = try unknownFieldsBuilder.build()
                                return self

                            case 10:
                                key = try codedInputStream.readString()

                            case 18:
                                value = try codedInputStream.readString()

                            default:
                                if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                    unknownFields = try unknownFieldsBuilder.build()
                                    return self
                                }
                            }
                        }
                    }
                    class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder {
                        let resultDecodedBuilder = Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder()
                        if let jsonValueKey = jsonMap["key"] as? String {
                            resultDecodedBuilder.key = jsonValueKey
                        }
                        if let jsonValueValue = jsonMap["value"] as? String {
                            resultDecodedBuilder.value = jsonValueValue
                        }
                        return resultDecodedBuilder
                    }
                    override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder {
                        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        return try Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                    }
                }

            }

            //Nested type declaration end

            /// Device type (CPU, GPU, ...)
            public fileprivate(set) var type:String = ""
            public fileprivate(set) var hasType:Bool = false

            /// Vendor (Intel, nvidia, ...)
            public fileprivate(set) var vendor:String = ""
            public fileprivate(set) var hasVendor:Bool = false

            /// Model (Haswell, K40, ...)
            public fileprivate(set) var model:String = ""
            public fileprivate(set) var hasModel:Bool = false

            /// Core Frequency in Mhz
            public fileprivate(set) var frequency:Int64 = Int64(0)
            public fileprivate(set) var hasFrequency:Bool = false

            /// Number of cores
            public fileprivate(set) var numCores:Int64 = Int64(0)
            public fileprivate(set) var hasNumCores:Bool = false

            /// Version of the tools and libraries used with this device (e.g. gcc 4.9,
            /// cudnn 5.1)
            public fileprivate(set) var environment:Dictionary<String,String> = Dictionary<String,String>()

            public fileprivate(set) var hasEnvironment:Bool = false
            /// Number of registers per core.
            public fileprivate(set) var numRegisters:Int64 = Int64(0)
            public fileprivate(set) var hasNumRegisters:Bool = false

            /// L1 cache size in bytes
            public fileprivate(set) var l1CacheSize:Int64 = Int64(0)
            public fileprivate(set) var hasL1CacheSize:Bool = false

            /// L2 cache size in bytes
            public fileprivate(set) var l2CacheSize:Int64 = Int64(0)
            public fileprivate(set) var hasL2CacheSize:Bool = false

            /// L3 cache size in bytes
            public fileprivate(set) var l3CacheSize:Int64 = Int64(0)
            public fileprivate(set) var hasL3CacheSize:Bool = false

            /// Shared memory size per multiprocessor in bytes. This field is
            /// applicable to GPUs only.
            public fileprivate(set) var sharedMemorySizePerMultiprocessor:Int64 = Int64(0)
            public fileprivate(set) var hasSharedMemorySizePerMultiprocessor:Bool = false

            /// Memory size in bytes
            public fileprivate(set) var memorySize:Int64 = Int64(0)
            public fileprivate(set) var hasMemorySize:Bool = false

            /// Memory bandwidth in KB/s
            public fileprivate(set) var bandwidth:Int64 = Int64(0)
            public fileprivate(set) var hasBandwidth:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasType {
                    try codedOutputStream.writeString(fieldNumber: 1, value:type)
                }
                if hasVendor {
                    try codedOutputStream.writeString(fieldNumber: 2, value:vendor)
                }
                if hasModel {
                    try codedOutputStream.writeString(fieldNumber: 3, value:model)
                }
                if hasFrequency {
                    try codedOutputStream.writeInt64(fieldNumber: 4, value:frequency)
                }
                if hasNumCores {
                    try codedOutputStream.writeInt64(fieldNumber: 5, value:numCores)
                }
                if hasEnvironment {
                    for (keyEnvironment, valueEnvironment) in environment {
                        let valueOfEnvironment = try! Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder().setKey(keyEnvironment).setValue(valueEnvironment).build()
                          try codedOutputStream.writeMessage(fieldNumber: 6, value:valueOfEnvironment)
                      }
                }
                if hasNumRegisters {
                    try codedOutputStream.writeInt64(fieldNumber: 7, value:numRegisters)
                }
                if hasL1CacheSize {
                    try codedOutputStream.writeInt64(fieldNumber: 8, value:l1CacheSize)
                }
                if hasL2CacheSize {
                    try codedOutputStream.writeInt64(fieldNumber: 9, value:l2CacheSize)
                }
                if hasL3CacheSize {
                    try codedOutputStream.writeInt64(fieldNumber: 10, value:l3CacheSize)
                }
                if hasSharedMemorySizePerMultiprocessor {
                    try codedOutputStream.writeInt64(fieldNumber: 11, value:sharedMemorySizePerMultiprocessor)
                }
                if hasMemorySize {
                    try codedOutputStream.writeInt64(fieldNumber: 12, value:memorySize)
                }
                if hasBandwidth {
                    try codedOutputStream.writeInt64(fieldNumber: 13, value:bandwidth)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasType {
                    serialize_size += type.computeStringSize(fieldNumber: 1)
                }
                if hasVendor {
                    serialize_size += vendor.computeStringSize(fieldNumber: 2)
                }
                if hasModel {
                    serialize_size += model.computeStringSize(fieldNumber: 3)
                }
                if hasFrequency {
                    serialize_size += frequency.computeInt64Size(fieldNumber: 4)
                }
                if hasNumCores {
                    serialize_size += numCores.computeInt64Size(fieldNumber: 5)
                }
                if hasEnvironment {
                      for (keyEnvironment, valueEnvironment) in environment {
                          let valueOfEnvironment = try! Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder().setKey(keyEnvironment).setValue(valueEnvironment).build()
                    serialize_size += valueOfEnvironment.computeMessageSize(fieldNumber: 6)
                    }
                }
                if hasNumRegisters {
                    serialize_size += numRegisters.computeInt64Size(fieldNumber: 7)
                }
                if hasL1CacheSize {
                    serialize_size += l1CacheSize.computeInt64Size(fieldNumber: 8)
                }
                if hasL2CacheSize {
                    serialize_size += l2CacheSize.computeInt64Size(fieldNumber: 9)
                }
                if hasL3CacheSize {
                    serialize_size += l3CacheSize.computeInt64Size(fieldNumber: 10)
                }
                if hasSharedMemorySizePerMultiprocessor {
                    serialize_size += sharedMemorySizePerMultiprocessor.computeInt64Size(fieldNumber: 11)
                }
                if hasMemorySize {
                    serialize_size += memorySize.computeInt64Size(fieldNumber: 12)
                }
                if hasBandwidth {
                    serialize_size += bandwidth.computeInt64Size(fieldNumber: 13)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.OpInfo.DeviceProperties.Builder {
                return Tensorflow.OpInfo.DeviceProperties.classBuilder() as! Tensorflow.OpInfo.DeviceProperties.Builder
            }
            public func getBuilder() -> Tensorflow.OpInfo.DeviceProperties.Builder {
                return classBuilder() as! Tensorflow.OpInfo.DeviceProperties.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.OpInfo.DeviceProperties.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.OpInfo.DeviceProperties.Builder()
            }
            public func toBuilder() throws -> Tensorflow.OpInfo.DeviceProperties.Builder {
                return try Tensorflow.OpInfo.DeviceProperties.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.OpInfo.DeviceProperties) throws -> Tensorflow.OpInfo.DeviceProperties.Builder {
                return try Tensorflow.OpInfo.DeviceProperties.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasType {
                    jsonMap["type"] = type
                }
                if hasVendor {
                    jsonMap["vendor"] = vendor
                }
                if hasModel {
                    jsonMap["model"] = model
                }
                if hasFrequency {
                    jsonMap["frequency"] = "\(frequency)"
                }
                if hasNumCores {
                    jsonMap["numCores"] = "\(numCores)"
                }
                if hasEnvironment {
                    var mapEnvironment = Dictionary<String, String>()
                    for (keyEnvironment, valueEnvironment) in environment {
                        mapEnvironment["\(keyEnvironment)"] = valueEnvironment
                    }
                    jsonMap["environment"] = mapEnvironment
                }
                if hasNumRegisters {
                    jsonMap["numRegisters"] = "\(numRegisters)"
                }
                if hasL1CacheSize {
                    jsonMap["l1CacheSize"] = "\(l1CacheSize)"
                }
                if hasL2CacheSize {
                    jsonMap["l2CacheSize"] = "\(l2CacheSize)"
                }
                if hasL3CacheSize {
                    jsonMap["l3CacheSize"] = "\(l3CacheSize)"
                }
                if hasSharedMemorySizePerMultiprocessor {
                    jsonMap["sharedMemorySizePerMultiprocessor"] = "\(sharedMemorySizePerMultiprocessor)"
                }
                if hasMemorySize {
                    jsonMap["memorySize"] = "\(memorySize)"
                }
                if hasBandwidth {
                    jsonMap["bandwidth"] = "\(bandwidth)"
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OpInfo.DeviceProperties {
                return try Tensorflow.OpInfo.DeviceProperties.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.OpInfo.DeviceProperties {
                return try Tensorflow.OpInfo.DeviceProperties.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasType {
                    output += "\(indent) type: \(type) \n"
                }
                if hasVendor {
                    output += "\(indent) vendor: \(vendor) \n"
                }
                if hasModel {
                    output += "\(indent) model: \(model) \n"
                }
                if hasFrequency {
                    output += "\(indent) frequency: \(frequency) \n"
                }
                if hasNumCores {
                    output += "\(indent) numCores: \(numCores) \n"
                }
                if hasEnvironment {
                    output += "\(indent) environment: \(environment) \n"
                }
                if hasNumRegisters {
                    output += "\(indent) numRegisters: \(numRegisters) \n"
                }
                if hasL1CacheSize {
                    output += "\(indent) l1CacheSize: \(l1CacheSize) \n"
                }
                if hasL2CacheSize {
                    output += "\(indent) l2CacheSize: \(l2CacheSize) \n"
                }
                if hasL3CacheSize {
                    output += "\(indent) l3CacheSize: \(l3CacheSize) \n"
                }
                if hasSharedMemorySizePerMultiprocessor {
                    output += "\(indent) sharedMemorySizePerMultiprocessor: \(sharedMemorySizePerMultiprocessor) \n"
                }
                if hasMemorySize {
                    output += "\(indent) memorySize: \(memorySize) \n"
                }
                if hasBandwidth {
                    output += "\(indent) bandwidth: \(bandwidth) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasType {
                        hashCode = (hashCode &* 31) &+ type.hashValue
                    }
                    if hasVendor {
                        hashCode = (hashCode &* 31) &+ vendor.hashValue
                    }
                    if hasModel {
                        hashCode = (hashCode &* 31) &+ model.hashValue
                    }
                    if hasFrequency {
                        hashCode = (hashCode &* 31) &+ frequency.hashValue
                    }
                    if hasNumCores {
                        hashCode = (hashCode &* 31) &+ numCores.hashValue
                    }
                    if hasEnvironment {
                        for (keyEnvironment, valueEnvironment) in environment {
                            hashCode = (hashCode &* 31) &+ keyEnvironment.hashValue
                            hashCode = (hashCode &* 31) &+ valueEnvironment.hashValue
                        }
                    }
                    if hasNumRegisters {
                        hashCode = (hashCode &* 31) &+ numRegisters.hashValue
                    }
                    if hasL1CacheSize {
                        hashCode = (hashCode &* 31) &+ l1CacheSize.hashValue
                    }
                    if hasL2CacheSize {
                        hashCode = (hashCode &* 31) &+ l2CacheSize.hashValue
                    }
                    if hasL3CacheSize {
                        hashCode = (hashCode &* 31) &+ l3CacheSize.hashValue
                    }
                    if hasSharedMemorySizePerMultiprocessor {
                        hashCode = (hashCode &* 31) &+ sharedMemorySizePerMultiprocessor.hashValue
                    }
                    if hasMemorySize {
                        hashCode = (hashCode &* 31) &+ memorySize.hashValue
                    }
                    if hasBandwidth {
                        hashCode = (hashCode &* 31) &+ bandwidth.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.OpInfo.DeviceProperties"
            }
            override public func className() -> String {
                return "Tensorflow.OpInfo.DeviceProperties"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.OpInfo.DeviceProperties = Tensorflow.OpInfo.DeviceProperties()
                public func getMessage() -> Tensorflow.OpInfo.DeviceProperties {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                /// Device type (CPU, GPU, ...)
                public var type:String {
                    get {
                        return builderResult.type
                    }
                    set (value) {
                        builderResult.hasType = true
                        builderResult.type = value
                    }
                }
                public var hasType:Bool {
                    get {
                        return builderResult.hasType
                    }
                }
                @discardableResult
                public func setType(_ value:String) -> Tensorflow.OpInfo.DeviceProperties.Builder {
                    self.type = value
                    return self
                }
                @discardableResult
                public func clearType() -> Tensorflow.OpInfo.DeviceProperties.Builder{
                    builderResult.hasType = false
                    builderResult.type = ""
                    return self
                }
                /// Vendor (Intel, nvidia, ...)
                public var vendor:String {
                    get {
                        return builderResult.vendor
                    }
                    set (value) {
                        builderResult.hasVendor = true
                        builderResult.vendor = value
                    }
                }
                public var hasVendor:Bool {
                    get {
                        return builderResult.hasVendor
                    }
                }
                @discardableResult
                public func setVendor(_ value:String) -> Tensorflow.OpInfo.DeviceProperties.Builder {
                    self.vendor = value
                    return self
                }
                @discardableResult
                public func clearVendor() -> Tensorflow.OpInfo.DeviceProperties.Builder{
                    builderResult.hasVendor = false
                    builderResult.vendor = ""
                    return self
                }
                /// Model (Haswell, K40, ...)
                public var model:String {
                    get {
                        return builderResult.model
                    }
                    set (value) {
                        builderResult.hasModel = true
                        builderResult.model = value
                    }
                }
                public var hasModel:Bool {
                    get {
                        return builderResult.hasModel
                    }
                }
                @discardableResult
                public func setModel(_ value:String) -> Tensorflow.OpInfo.DeviceProperties.Builder {
                    self.model = value
                    return self
                }
                @discardableResult
                public func clearModel() -> Tensorflow.OpInfo.DeviceProperties.Builder{
                    builderResult.hasModel = false
                    builderResult.model = ""
                    return self
                }
                /// Core Frequency in Mhz
                public var frequency:Int64 {
                    get {
                        return builderResult.frequency
                    }
                    set (value) {
                        builderResult.hasFrequency = true
                        builderResult.frequency = value
                    }
                }
                public var hasFrequency:Bool {
                    get {
                        return builderResult.hasFrequency
                    }
                }
                @discardableResult
                public func setFrequency(_ value:Int64) -> Tensorflow.OpInfo.DeviceProperties.Builder {
                    self.frequency = value
                    return self
                }
                @discardableResult
                public func clearFrequency() -> Tensorflow.OpInfo.DeviceProperties.Builder{
                    builderResult.hasFrequency = false
                    builderResult.frequency = Int64(0)
                    return self
                }
                /// Number of cores
                public var numCores:Int64 {
                    get {
                        return builderResult.numCores
                    }
                    set (value) {
                        builderResult.hasNumCores = true
                        builderResult.numCores = value
                    }
                }
                public var hasNumCores:Bool {
                    get {
                        return builderResult.hasNumCores
                    }
                }
                @discardableResult
                public func setNumCores(_ value:Int64) -> Tensorflow.OpInfo.DeviceProperties.Builder {
                    self.numCores = value
                    return self
                }
                @discardableResult
                public func clearNumCores() -> Tensorflow.OpInfo.DeviceProperties.Builder{
                    builderResult.hasNumCores = false
                    builderResult.numCores = Int64(0)
                    return self
                }
                /// Version of the tools and libraries used with this device (e.g. gcc 4.9,
                /// cudnn 5.1)
                public var hasEnvironment:Bool {
                    get {
                        return builderResult.hasEnvironment
                    }
                }
                public var environment:Dictionary<String,String> {
                    get {
                        return builderResult.environment
                    }
                    set (value) {
                        builderResult.hasEnvironment = true
                        builderResult.environment = value
                    }
                }
                @discardableResult
                public func setEnvironment(_ value:Dictionary<String,String>) -> Tensorflow.OpInfo.DeviceProperties.Builder {
                    self.environment = value
                    return self
                }
                @discardableResult
                public func clearEnvironment() -> Tensorflow.OpInfo.DeviceProperties.Builder{
                    builderResult.hasEnvironment = false
                    builderResult.environment = Dictionary<String,String>()
                    return self
                }
                /// Number of registers per core.
                public var numRegisters:Int64 {
                    get {
                        return builderResult.numRegisters
                    }
                    set (value) {
                        builderResult.hasNumRegisters = true
                        builderResult.numRegisters = value
                    }
                }
                public var hasNumRegisters:Bool {
                    get {
                        return builderResult.hasNumRegisters
                    }
                }
                @discardableResult
                public func setNumRegisters(_ value:Int64) -> Tensorflow.OpInfo.DeviceProperties.Builder {
                    self.numRegisters = value
                    return self
                }
                @discardableResult
                public func clearNumRegisters() -> Tensorflow.OpInfo.DeviceProperties.Builder{
                    builderResult.hasNumRegisters = false
                    builderResult.numRegisters = Int64(0)
                    return self
                }
                /// L1 cache size in bytes
                public var l1CacheSize:Int64 {
                    get {
                        return builderResult.l1CacheSize
                    }
                    set (value) {
                        builderResult.hasL1CacheSize = true
                        builderResult.l1CacheSize = value
                    }
                }
                public var hasL1CacheSize:Bool {
                    get {
                        return builderResult.hasL1CacheSize
                    }
                }
                @discardableResult
                public func setL1CacheSize(_ value:Int64) -> Tensorflow.OpInfo.DeviceProperties.Builder {
                    self.l1CacheSize = value
                    return self
                }
                @discardableResult
                public func clearL1CacheSize() -> Tensorflow.OpInfo.DeviceProperties.Builder{
                    builderResult.hasL1CacheSize = false
                    builderResult.l1CacheSize = Int64(0)
                    return self
                }
                /// L2 cache size in bytes
                public var l2CacheSize:Int64 {
                    get {
                        return builderResult.l2CacheSize
                    }
                    set (value) {
                        builderResult.hasL2CacheSize = true
                        builderResult.l2CacheSize = value
                    }
                }
                public var hasL2CacheSize:Bool {
                    get {
                        return builderResult.hasL2CacheSize
                    }
                }
                @discardableResult
                public func setL2CacheSize(_ value:Int64) -> Tensorflow.OpInfo.DeviceProperties.Builder {
                    self.l2CacheSize = value
                    return self
                }
                @discardableResult
                public func clearL2CacheSize() -> Tensorflow.OpInfo.DeviceProperties.Builder{
                    builderResult.hasL2CacheSize = false
                    builderResult.l2CacheSize = Int64(0)
                    return self
                }
                /// L3 cache size in bytes
                public var l3CacheSize:Int64 {
                    get {
                        return builderResult.l3CacheSize
                    }
                    set (value) {
                        builderResult.hasL3CacheSize = true
                        builderResult.l3CacheSize = value
                    }
                }
                public var hasL3CacheSize:Bool {
                    get {
                        return builderResult.hasL3CacheSize
                    }
                }
                @discardableResult
                public func setL3CacheSize(_ value:Int64) -> Tensorflow.OpInfo.DeviceProperties.Builder {
                    self.l3CacheSize = value
                    return self
                }
                @discardableResult
                public func clearL3CacheSize() -> Tensorflow.OpInfo.DeviceProperties.Builder{
                    builderResult.hasL3CacheSize = false
                    builderResult.l3CacheSize = Int64(0)
                    return self
                }
                /// Shared memory size per multiprocessor in bytes. This field is
                /// applicable to GPUs only.
                public var sharedMemorySizePerMultiprocessor:Int64 {
                    get {
                        return builderResult.sharedMemorySizePerMultiprocessor
                    }
                    set (value) {
                        builderResult.hasSharedMemorySizePerMultiprocessor = true
                        builderResult.sharedMemorySizePerMultiprocessor = value
                    }
                }
                public var hasSharedMemorySizePerMultiprocessor:Bool {
                    get {
                        return builderResult.hasSharedMemorySizePerMultiprocessor
                    }
                }
                @discardableResult
                public func setSharedMemorySizePerMultiprocessor(_ value:Int64) -> Tensorflow.OpInfo.DeviceProperties.Builder {
                    self.sharedMemorySizePerMultiprocessor = value
                    return self
                }
                @discardableResult
                public func clearSharedMemorySizePerMultiprocessor() -> Tensorflow.OpInfo.DeviceProperties.Builder{
                    builderResult.hasSharedMemorySizePerMultiprocessor = false
                    builderResult.sharedMemorySizePerMultiprocessor = Int64(0)
                    return self
                }
                /// Memory size in bytes
                public var memorySize:Int64 {
                    get {
                        return builderResult.memorySize
                    }
                    set (value) {
                        builderResult.hasMemorySize = true
                        builderResult.memorySize = value
                    }
                }
                public var hasMemorySize:Bool {
                    get {
                        return builderResult.hasMemorySize
                    }
                }
                @discardableResult
                public func setMemorySize(_ value:Int64) -> Tensorflow.OpInfo.DeviceProperties.Builder {
                    self.memorySize = value
                    return self
                }
                @discardableResult
                public func clearMemorySize() -> Tensorflow.OpInfo.DeviceProperties.Builder{
                    builderResult.hasMemorySize = false
                    builderResult.memorySize = Int64(0)
                    return self
                }
                /// Memory bandwidth in KB/s
                public var bandwidth:Int64 {
                    get {
                        return builderResult.bandwidth
                    }
                    set (value) {
                        builderResult.hasBandwidth = true
                        builderResult.bandwidth = value
                    }
                }
                public var hasBandwidth:Bool {
                    get {
                        return builderResult.hasBandwidth
                    }
                }
                @discardableResult
                public func setBandwidth(_ value:Int64) -> Tensorflow.OpInfo.DeviceProperties.Builder {
                    self.bandwidth = value
                    return self
                }
                @discardableResult
                public func clearBandwidth() -> Tensorflow.OpInfo.DeviceProperties.Builder{
                    builderResult.hasBandwidth = false
                    builderResult.bandwidth = Int64(0)
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.OpInfo.DeviceProperties.Builder {
                    builderResult = Tensorflow.OpInfo.DeviceProperties()
                    return self
                }
                override public func clone() throws -> Tensorflow.OpInfo.DeviceProperties.Builder {
                    return try Tensorflow.OpInfo.DeviceProperties.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.OpInfo.DeviceProperties {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.OpInfo.DeviceProperties {
                    let returnMe:Tensorflow.OpInfo.DeviceProperties = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.OpInfo.DeviceProperties) throws -> Tensorflow.OpInfo.DeviceProperties.Builder {
                    if other == Tensorflow.OpInfo.DeviceProperties() {
                        return self
                    }
                    if other.hasType {
                        type = other.type
                    }
                    if other.hasVendor {
                        vendor = other.vendor
                    }
                    if other.hasModel {
                        model = other.model
                    }
                    if other.hasFrequency {
                        frequency = other.frequency
                    }
                    if other.hasNumCores {
                        numCores = other.numCores
                    }
                    if other.hasEnvironment {
                        environment = other.environment
                    }
                    if other.hasNumRegisters {
                        numRegisters = other.numRegisters
                    }
                    if other.hasL1CacheSize {
                        l1CacheSize = other.l1CacheSize
                    }
                    if other.hasL2CacheSize {
                        l2CacheSize = other.l2CacheSize
                    }
                    if other.hasL3CacheSize {
                        l3CacheSize = other.l3CacheSize
                    }
                    if other.hasSharedMemorySizePerMultiprocessor {
                        sharedMemorySizePerMultiprocessor = other.sharedMemorySizePerMultiprocessor
                    }
                    if other.hasMemorySize {
                        memorySize = other.memorySize
                    }
                    if other.hasBandwidth {
                        bandwidth = other.bandwidth
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OpInfo.DeviceProperties.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpInfo.DeviceProperties.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            type = try codedInputStream.readString()

                        case 18:
                            vendor = try codedInputStream.readString()

                        case 26:
                            model = try codedInputStream.readString()

                        case 32:
                            frequency = try codedInputStream.readInt64()

                        case 40:
                            numCores = try codedInputStream.readInt64()

                        case 50:
                            let subBuilder = Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder()
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            let buildOfEnvironment = subBuilder.buildPartial()
                            environment[buildOfEnvironment.key] = buildOfEnvironment.value

                        case 56:
                            numRegisters = try codedInputStream.readInt64()

                        case 64:
                            l1CacheSize = try codedInputStream.readInt64()

                        case 72:
                            l2CacheSize = try codedInputStream.readInt64()

                        case 80:
                            l3CacheSize = try codedInputStream.readInt64()

                        case 88:
                            sharedMemorySizePerMultiprocessor = try codedInputStream.readInt64()

                        case 96:
                            memorySize = try codedInputStream.readInt64()

                        case 104:
                            bandwidth = try codedInputStream.readInt64()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OpInfo.DeviceProperties.Builder {
                    let resultDecodedBuilder = Tensorflow.OpInfo.DeviceProperties.Builder()
                    if let jsonValueType = jsonMap["type"] as? String {
                        resultDecodedBuilder.type = jsonValueType
                    }
                    if let jsonValueVendor = jsonMap["vendor"] as? String {
                        resultDecodedBuilder.vendor = jsonValueVendor
                    }
                    if let jsonValueModel = jsonMap["model"] as? String {
                        resultDecodedBuilder.model = jsonValueModel
                    }
                    if let jsonValueFrequency = jsonMap["frequency"] as? String {
                        resultDecodedBuilder.frequency = Int64(jsonValueFrequency)!
                    } else if let jsonValueFrequency = jsonMap["frequency"] as? Int {
                        resultDecodedBuilder.frequency = Int64(jsonValueFrequency)
                    }
                    if let jsonValueNumCores = jsonMap["numCores"] as? String {
                        resultDecodedBuilder.numCores = Int64(jsonValueNumCores)!
                    } else if let jsonValueNumCores = jsonMap["numCores"] as? Int {
                        resultDecodedBuilder.numCores = Int64(jsonValueNumCores)
                    }
                    if let jsonValueEnvironment = jsonMap["environment"] as? Dictionary<String, String> {
                        var mapEnvironment = Dictionary<String, String>()
                        for (keyEnvironment, valueEnvironment) in jsonValueEnvironment {
                            guard let keyFromEnvironment = String(keyEnvironment) else {
                                throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                            }
                            mapEnvironment[keyFromEnvironment] = valueEnvironment
                        }
                        resultDecodedBuilder.environment = mapEnvironment
                    }
                    if let jsonValueNumRegisters = jsonMap["numRegisters"] as? String {
                        resultDecodedBuilder.numRegisters = Int64(jsonValueNumRegisters)!
                    } else if let jsonValueNumRegisters = jsonMap["numRegisters"] as? Int {
                        resultDecodedBuilder.numRegisters = Int64(jsonValueNumRegisters)
                    }
                    if let jsonValueL1CacheSize = jsonMap["l1CacheSize"] as? String {
                        resultDecodedBuilder.l1CacheSize = Int64(jsonValueL1CacheSize)!
                    } else if let jsonValueL1CacheSize = jsonMap["l1CacheSize"] as? Int {
                        resultDecodedBuilder.l1CacheSize = Int64(jsonValueL1CacheSize)
                    }
                    if let jsonValueL2CacheSize = jsonMap["l2CacheSize"] as? String {
                        resultDecodedBuilder.l2CacheSize = Int64(jsonValueL2CacheSize)!
                    } else if let jsonValueL2CacheSize = jsonMap["l2CacheSize"] as? Int {
                        resultDecodedBuilder.l2CacheSize = Int64(jsonValueL2CacheSize)
                    }
                    if let jsonValueL3CacheSize = jsonMap["l3CacheSize"] as? String {
                        resultDecodedBuilder.l3CacheSize = Int64(jsonValueL3CacheSize)!
                    } else if let jsonValueL3CacheSize = jsonMap["l3CacheSize"] as? Int {
                        resultDecodedBuilder.l3CacheSize = Int64(jsonValueL3CacheSize)
                    }
                    if let jsonValueSharedMemorySizePerMultiprocessor = jsonMap["sharedMemorySizePerMultiprocessor"] as? String {
                        resultDecodedBuilder.sharedMemorySizePerMultiprocessor = Int64(jsonValueSharedMemorySizePerMultiprocessor)!
                    } else if let jsonValueSharedMemorySizePerMultiprocessor = jsonMap["sharedMemorySizePerMultiprocessor"] as? Int {
                        resultDecodedBuilder.sharedMemorySizePerMultiprocessor = Int64(jsonValueSharedMemorySizePerMultiprocessor)
                    }
                    if let jsonValueMemorySize = jsonMap["memorySize"] as? String {
                        resultDecodedBuilder.memorySize = Int64(jsonValueMemorySize)!
                    } else if let jsonValueMemorySize = jsonMap["memorySize"] as? Int {
                        resultDecodedBuilder.memorySize = Int64(jsonValueMemorySize)
                    }
                    if let jsonValueBandwidth = jsonMap["bandwidth"] as? String {
                        resultDecodedBuilder.bandwidth = Int64(jsonValueBandwidth)!
                    } else if let jsonValueBandwidth = jsonMap["bandwidth"] as? Int {
                        resultDecodedBuilder.bandwidth = Int64(jsonValueBandwidth)
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.OpInfo.DeviceProperties.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.OpInfo.DeviceProperties.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        /// The operation name.  There may be custom parameters in attrs.
        public fileprivate(set) var op:String = ""
        public fileprivate(set) var hasOp:Bool = false

        /// Custom parameters impacting the behavior of the op.
        public fileprivate(set) var attr:Dictionary<String,Tensorflow.AttrValue> = Dictionary<String,Tensorflow.AttrValue>()

        public fileprivate(set) var hasAttr:Bool = false
        public fileprivate(set) var inputs:Array<Tensorflow.OpInfo.TensorProperties>  = Array<Tensorflow.OpInfo.TensorProperties>()
        public fileprivate(set) var device:Tensorflow.OpInfo.DeviceProperties!
        public fileprivate(set) var hasDevice:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasOp {
                try codedOutputStream.writeString(fieldNumber: 1, value:op)
            }
            if hasAttr {
                for (keyAttr, valueAttr) in attr {
                    let valueOfAttr = try! Tensorflow.OpInfo.AttrEntry.Builder().setKey(keyAttr).setValue(valueAttr).build()
                      try codedOutputStream.writeMessage(fieldNumber: 2, value:valueOfAttr)
                  }
            }
            for oneElementInputs in inputs {
                  try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementInputs)
            }
            if hasDevice {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:device)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasOp {
                serialize_size += op.computeStringSize(fieldNumber: 1)
            }
            if hasAttr {
                  for (keyAttr, valueAttr) in attr {
                      let valueOfAttr = try! Tensorflow.OpInfo.AttrEntry.Builder().setKey(keyAttr).setValue(valueAttr).build()
                serialize_size += valueOfAttr.computeMessageSize(fieldNumber: 2)
                }
            }
            for oneElementInputs in inputs {
                serialize_size += oneElementInputs.computeMessageSize(fieldNumber: 3)
            }
            if hasDevice {
                if let varSizedevice = device?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizedevice
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.OpInfo.Builder {
            return Tensorflow.OpInfo.classBuilder() as! Tensorflow.OpInfo.Builder
        }
        public func getBuilder() -> Tensorflow.OpInfo.Builder {
            return classBuilder() as! Tensorflow.OpInfo.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.OpInfo.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.OpInfo.Builder()
        }
        public func toBuilder() throws -> Tensorflow.OpInfo.Builder {
            return try Tensorflow.OpInfo.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.OpInfo) throws -> Tensorflow.OpInfo.Builder {
            return try Tensorflow.OpInfo.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasOp {
                jsonMap["op"] = op
            }
            if hasAttr {
                var mapAttr = Dictionary<String, Dictionary<String,Any>>()
                for (keyAttr, valueAttr) in attr {
                    mapAttr["\(keyAttr)"] = try valueAttr.encode()
                }
                jsonMap["attr"] = mapAttr
            }
            if !inputs.isEmpty {
                var jsonArrayInputs:Array<Dictionary<String,Any>> = []
                for oneValueInputs in inputs {
                    let ecodedMessageInputs = try oneValueInputs.encode()
                    jsonArrayInputs.append(ecodedMessageInputs)
                }
                jsonMap["inputs"] = jsonArrayInputs
            }
            if hasDevice {
                jsonMap["device"] = try device.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OpInfo {
            return try Tensorflow.OpInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.OpInfo {
            return try Tensorflow.OpInfo.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasOp {
                output += "\(indent) op: \(op) \n"
            }
            if hasAttr {
                output += "\(indent) attr: \(attr) \n"
            }
            var inputsElementIndex:Int = 0
            for oneElementInputs in inputs {
                output += "\(indent) inputs[\(inputsElementIndex)] {\n"
                output += try oneElementInputs.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                inputsElementIndex += 1
            }
            if hasDevice {
                output += "\(indent) device {\n"
                if let outDescDevice = device {
                    output += try outDescDevice.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasOp {
                    hashCode = (hashCode &* 31) &+ op.hashValue
                }
                if hasAttr {
                    for (keyAttr, valueAttr) in attr {
                        hashCode = (hashCode &* 31) &+ keyAttr.hashValue
                        hashCode = (hashCode &* 31) &+ valueAttr.hashValue
                    }
                }
                for oneElementInputs in inputs {
                    hashCode = (hashCode &* 31) &+ oneElementInputs.hashValue
                }
                if hasDevice {
                    if let hashValuedevice = device?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuedevice
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.OpInfo"
        }
        override public func className() -> String {
            return "Tensorflow.OpInfo"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.OpInfo = Tensorflow.OpInfo()
            public func getMessage() -> Tensorflow.OpInfo {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The operation name.  There may be custom parameters in attrs.
            public var op:String {
                get {
                    return builderResult.op
                }
                set (value) {
                    builderResult.hasOp = true
                    builderResult.op = value
                }
            }
            public var hasOp:Bool {
                get {
                    return builderResult.hasOp
                }
            }
            @discardableResult
            public func setOp(_ value:String) -> Tensorflow.OpInfo.Builder {
                self.op = value
                return self
            }
            @discardableResult
            public func clearOp() -> Tensorflow.OpInfo.Builder{
                builderResult.hasOp = false
                builderResult.op = ""
                return self
            }
            /// Custom parameters impacting the behavior of the op.
            public var hasAttr:Bool {
                get {
                    return builderResult.hasAttr
                }
            }
            public var attr:Dictionary<String,Tensorflow.AttrValue> {
                get {
                    return builderResult.attr
                }
                set (value) {
                    builderResult.hasAttr = true
                    builderResult.attr = value
                }
            }
            @discardableResult
            public func setAttr(_ value:Dictionary<String,Tensorflow.AttrValue>) -> Tensorflow.OpInfo.Builder {
                self.attr = value
                return self
            }
            @discardableResult
            public func clearAttr() -> Tensorflow.OpInfo.Builder{
                builderResult.hasAttr = false
                builderResult.attr = Dictionary<String,Tensorflow.AttrValue>()
                return self
            }
            public var inputs:Array<Tensorflow.OpInfo.TensorProperties> {
                get {
                    return builderResult.inputs
                }
                set (value) {
                    builderResult.inputs = value
                }
            }
            @discardableResult
            public func setInputs(_ value:Array<Tensorflow.OpInfo.TensorProperties>) -> Tensorflow.OpInfo.Builder {
                self.inputs = value
                return self
            }
            @discardableResult
            public func clearInputs() -> Tensorflow.OpInfo.Builder {
                builderResult.inputs.removeAll(keepingCapacity: false)
                return self
            }
            public var device:Tensorflow.OpInfo.DeviceProperties! {
                get {
                    if deviceBuilder_ != nil {
                        builderResult.device = deviceBuilder_.getMessage()
                    }
                    return builderResult.device
                }
                set (value) {
                    builderResult.hasDevice = true
                    builderResult.device = value
                }
            }
            public var hasDevice:Bool {
                get {
                    return builderResult.hasDevice
                }
            }
            fileprivate var deviceBuilder_:Tensorflow.OpInfo.DeviceProperties.Builder! {
                didSet {
                    builderResult.hasDevice = true
                }
            }
            public func getDeviceBuilder() -> Tensorflow.OpInfo.DeviceProperties.Builder {
                if deviceBuilder_ == nil {
                    deviceBuilder_ = Tensorflow.OpInfo.DeviceProperties.Builder()
                    builderResult.device = deviceBuilder_.getMessage()
                    if device != nil {
                        try! deviceBuilder_.mergeFrom(other: device)
                    }
                }
                return deviceBuilder_
            }
            @discardableResult
            public func setDevice(_ value:Tensorflow.OpInfo.DeviceProperties!) -> Tensorflow.OpInfo.Builder {
                self.device = value
                return self
            }
            @discardableResult
            public func mergeDevice(value:Tensorflow.OpInfo.DeviceProperties) throws -> Tensorflow.OpInfo.Builder {
                if builderResult.hasDevice {
                    builderResult.device = try Tensorflow.OpInfo.DeviceProperties.builderWithPrototype(prototype:builderResult.device).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.device = value
                }
                builderResult.hasDevice = true
                return self
            }
            @discardableResult
            public func clearDevice() -> Tensorflow.OpInfo.Builder {
                deviceBuilder_ = nil
                builderResult.hasDevice = false
                builderResult.device = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.OpInfo.Builder {
                builderResult = Tensorflow.OpInfo()
                return self
            }
            override public func clone() throws -> Tensorflow.OpInfo.Builder {
                return try Tensorflow.OpInfo.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.OpInfo {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.OpInfo {
                let returnMe:Tensorflow.OpInfo = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.OpInfo) throws -> Tensorflow.OpInfo.Builder {
                if other == Tensorflow.OpInfo() {
                    return self
                }
                if other.hasOp {
                    op = other.op
                }
                if other.hasAttr {
                    attr = other.attr
                }
                if !other.inputs.isEmpty  {
                     builderResult.inputs += other.inputs
                }
                if (other.hasDevice) {
                    try mergeDevice(value: other.device)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OpInfo.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpInfo.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        op = try codedInputStream.readString()

                    case 18:
                        let subBuilder = Tensorflow.OpInfo.AttrEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfAttr = subBuilder.buildPartial()
                        attr[buildOfAttr.key] = buildOfAttr.value

                    case 26:
                        let subBuilder = Tensorflow.OpInfo.TensorProperties.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        inputs.append(subBuilder.buildPartial())

                    case 34:
                        let subBuilder:Tensorflow.OpInfo.DeviceProperties.Builder = Tensorflow.OpInfo.DeviceProperties.Builder()
                        if hasDevice {
                            try subBuilder.mergeFrom(other: device)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        device = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OpInfo.Builder {
                let resultDecodedBuilder = Tensorflow.OpInfo.Builder()
                if let jsonValueOp = jsonMap["op"] as? String {
                    resultDecodedBuilder.op = jsonValueOp
                }
                if let jsonValueAttr = jsonMap["attr"] as? Dictionary<String, Dictionary<String,Any>> {
                    var mapAttr = Dictionary<String, Tensorflow.AttrValue>()
                    for (keyAttr, valueAttr) in jsonValueAttr {
                        guard let keyFromAttr = String(keyAttr) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapAttr[keyFromAttr] = try Tensorflow.AttrValue.Builder.decodeToBuilder(jsonMap:valueAttr).build()

                    }
                    resultDecodedBuilder.attr = mapAttr
                }
                if let jsonValueInputs = jsonMap["inputs"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayInputs:Array<Tensorflow.OpInfo.TensorProperties> = []
                    for oneValueInputs in jsonValueInputs {
                        let messageFromStringInputs = try Tensorflow.OpInfo.TensorProperties.Builder.decodeToBuilder(jsonMap:oneValueInputs).build()

                        jsonArrayInputs.append(messageFromStringInputs)
                    }
                    resultDecodedBuilder.inputs = jsonArrayInputs
                }
                if let jsonValueDevice = jsonMap["device"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.device = try Tensorflow.OpInfo.DeviceProperties.Builder.decodeToBuilder(jsonMap:jsonValueDevice).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.OpInfo.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.OpInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Performance data for tensorflow operations
    final public class OpPerformance : GeneratedMessage {

        public static func == (lhs: Tensorflow.OpPerformance, rhs: Tensorflow.OpPerformance) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasOp == rhs.hasOp) && (!lhs.hasOp || lhs.op == rhs.op)
            fieldCheck = fieldCheck && (lhs.hasTemporaryMemorySize == rhs.hasTemporaryMemorySize) && (!lhs.hasTemporaryMemorySize || lhs.temporaryMemorySize == rhs.temporaryMemorySize)
            fieldCheck = fieldCheck && (lhs.hasComputeCost == rhs.hasComputeCost) && (!lhs.hasComputeCost || lhs.computeCost == rhs.computeCost)
            fieldCheck = fieldCheck && (lhs.hasComputeEfficiency == rhs.hasComputeEfficiency) && (!lhs.hasComputeEfficiency || lhs.computeEfficiency == rhs.computeEfficiency)
            fieldCheck = fieldCheck && (lhs.hasNode == rhs.hasNode) && (!lhs.hasNode || lhs.node == rhs.node)
            fieldCheck = fieldCheck && (lhs.hasComputeTime == rhs.hasComputeTime) && (!lhs.hasComputeTime || lhs.computeTime == rhs.computeTime)
            fieldCheck = fieldCheck && (lhs.hasMemoryTime == rhs.hasMemoryTime) && (!lhs.hasMemoryTime || lhs.memoryTime == rhs.memoryTime)
            fieldCheck = fieldCheck && (lhs.hasMemoryEfficiency == rhs.hasMemoryEfficiency) && (!lhs.hasMemoryEfficiency || lhs.memoryEfficiency == rhs.memoryEfficiency)
            fieldCheck = fieldCheck && (lhs.hasOpMemory == rhs.hasOpMemory) && (!lhs.hasOpMemory || lhs.opMemory == rhs.opMemory)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        /// Memory usage data for a tensorflow operation.
        final public class OpMemory : GeneratedMessage {

            public static func == (lhs: Tensorflow.OpPerformance.OpMemory, rhs: Tensorflow.OpPerformance.OpMemory) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.outputMemory == rhs.outputMemory)
                fieldCheck = fieldCheck && (lhs.hasHostTempMemory == rhs.hasHostTempMemory) && (!lhs.hasHostTempMemory || lhs.hostTempMemory == rhs.hostTempMemory)
                fieldCheck = fieldCheck && (lhs.hasDeviceTempMemory == rhs.hasDeviceTempMemory) && (!lhs.hasDeviceTempMemory || lhs.deviceTempMemory == rhs.deviceTempMemory)
                fieldCheck = fieldCheck && (lhs.hasHostPersistentMemory == rhs.hasHostPersistentMemory) && (!lhs.hasHostPersistentMemory || lhs.hostPersistentMemory == rhs.hostPersistentMemory)
                fieldCheck = fieldCheck && (lhs.hasDevicePersistentMemory == rhs.hasDevicePersistentMemory) && (!lhs.hasDevicePersistentMemory || lhs.devicePersistentMemory == rhs.devicePersistentMemory)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            /// The output information may have memory usage and output shapes.
            public fileprivate(set) var outputMemory:Array<Int64> = Array<Int64>()
            private var outputMemoryMemoizedSerializedSize:Int32 = -1
            /// Temporary memory allocated by this node.
            public fileprivate(set) var hostTempMemory:Int64 = Int64(0)
            public fileprivate(set) var hasHostTempMemory:Bool = false

            public fileprivate(set) var deviceTempMemory:Int64 = Int64(0)
            public fileprivate(set) var hasDeviceTempMemory:Bool = false

            /// The persisted_memory doesn't include outputs.
            public fileprivate(set) var hostPersistentMemory:Int64 = Int64(0)
            public fileprivate(set) var hasHostPersistentMemory:Bool = false

            public fileprivate(set) var devicePersistentMemory:Int64 = Int64(0)
            public fileprivate(set) var hasDevicePersistentMemory:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if !outputMemory.isEmpty {
                    try codedOutputStream.writeRawVarint32(value: 10)
                    try codedOutputStream.writeRawVarint32(value: outputMemoryMemoizedSerializedSize)
                    for oneValueoutputMemory in outputMemory {
                        try codedOutputStream.writeInt64NoTag(value: oneValueoutputMemory)
                    }
                }
                if hasHostTempMemory {
                    try codedOutputStream.writeInt64(fieldNumber: 2, value:hostTempMemory)
                }
                if hasDeviceTempMemory {
                    try codedOutputStream.writeInt64(fieldNumber: 3, value:deviceTempMemory)
                }
                if hasHostPersistentMemory {
                    try codedOutputStream.writeInt64(fieldNumber: 4, value:hostPersistentMemory)
                }
                if hasDevicePersistentMemory {
                    try codedOutputStream.writeInt64(fieldNumber: 5, value:devicePersistentMemory)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                var dataSizeOutputMemory:Int32 = 0
                for oneValueoutputMemory in outputMemory {
                    dataSizeOutputMemory += oneValueoutputMemory.computeInt64SizeNoTag()
                }
                serialize_size += dataSizeOutputMemory
                if !outputMemory.isEmpty {
                    serialize_size += 1
                    serialize_size += dataSizeOutputMemory.computeInt32SizeNoTag()
                }
                outputMemoryMemoizedSerializedSize = dataSizeOutputMemory
                if hasHostTempMemory {
                    serialize_size += hostTempMemory.computeInt64Size(fieldNumber: 2)
                }
                if hasDeviceTempMemory {
                    serialize_size += deviceTempMemory.computeInt64Size(fieldNumber: 3)
                }
                if hasHostPersistentMemory {
                    serialize_size += hostPersistentMemory.computeInt64Size(fieldNumber: 4)
                }
                if hasDevicePersistentMemory {
                    serialize_size += devicePersistentMemory.computeInt64Size(fieldNumber: 5)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.OpPerformance.OpMemory.Builder {
                return Tensorflow.OpPerformance.OpMemory.classBuilder() as! Tensorflow.OpPerformance.OpMemory.Builder
            }
            public func getBuilder() -> Tensorflow.OpPerformance.OpMemory.Builder {
                return classBuilder() as! Tensorflow.OpPerformance.OpMemory.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.OpPerformance.OpMemory.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.OpPerformance.OpMemory.Builder()
            }
            public func toBuilder() throws -> Tensorflow.OpPerformance.OpMemory.Builder {
                return try Tensorflow.OpPerformance.OpMemory.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.OpPerformance.OpMemory) throws -> Tensorflow.OpPerformance.OpMemory.Builder {
                return try Tensorflow.OpPerformance.OpMemory.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if !outputMemory.isEmpty {
                    var jsonArrayOutputMemory:Array<String> = []
                    for oneValueOutputMemory in outputMemory {
                        jsonArrayOutputMemory.append("\(oneValueOutputMemory)")
                    }
                    jsonMap["outputMemory"] = jsonArrayOutputMemory
                }
                if hasHostTempMemory {
                    jsonMap["hostTempMemory"] = "\(hostTempMemory)"
                }
                if hasDeviceTempMemory {
                    jsonMap["deviceTempMemory"] = "\(deviceTempMemory)"
                }
                if hasHostPersistentMemory {
                    jsonMap["hostPersistentMemory"] = "\(hostPersistentMemory)"
                }
                if hasDevicePersistentMemory {
                    jsonMap["devicePersistentMemory"] = "\(devicePersistentMemory)"
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OpPerformance.OpMemory {
                return try Tensorflow.OpPerformance.OpMemory.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.OpPerformance.OpMemory {
                return try Tensorflow.OpPerformance.OpMemory.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                var outputMemoryElementIndex:Int = 0
                for oneValueOutputMemory in outputMemory  {
                    output += "\(indent) outputMemory[\(outputMemoryElementIndex)]: \(oneValueOutputMemory)\n"
                    outputMemoryElementIndex += 1
                }
                if hasHostTempMemory {
                    output += "\(indent) hostTempMemory: \(hostTempMemory) \n"
                }
                if hasDeviceTempMemory {
                    output += "\(indent) deviceTempMemory: \(deviceTempMemory) \n"
                }
                if hasHostPersistentMemory {
                    output += "\(indent) hostPersistentMemory: \(hostPersistentMemory) \n"
                }
                if hasDevicePersistentMemory {
                    output += "\(indent) devicePersistentMemory: \(devicePersistentMemory) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    for oneValueOutputMemory in outputMemory {
                        hashCode = (hashCode &* 31) &+ oneValueOutputMemory.hashValue
                    }
                    if hasHostTempMemory {
                        hashCode = (hashCode &* 31) &+ hostTempMemory.hashValue
                    }
                    if hasDeviceTempMemory {
                        hashCode = (hashCode &* 31) &+ deviceTempMemory.hashValue
                    }
                    if hasHostPersistentMemory {
                        hashCode = (hashCode &* 31) &+ hostPersistentMemory.hashValue
                    }
                    if hasDevicePersistentMemory {
                        hashCode = (hashCode &* 31) &+ devicePersistentMemory.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.OpPerformance.OpMemory"
            }
            override public func className() -> String {
                return "Tensorflow.OpPerformance.OpMemory"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.OpPerformance.OpMemory = Tensorflow.OpPerformance.OpMemory()
                public func getMessage() -> Tensorflow.OpPerformance.OpMemory {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                /// The output information may have memory usage and output shapes.
                public var outputMemory:Array<Int64> {
                    get {
                        return builderResult.outputMemory
                    }
                    set (array) {
                        builderResult.outputMemory = array
                    }
                }
                @discardableResult
                public func setOutputMemory(_ value:Array<Int64>) -> Tensorflow.OpPerformance.OpMemory.Builder {
                    self.outputMemory = value
                    return self
                }
                @discardableResult
                public func clearOutputMemory() -> Tensorflow.OpPerformance.OpMemory.Builder {
                    builderResult.outputMemory.removeAll(keepingCapacity: false)
                    return self
                }
                /// Temporary memory allocated by this node.
                public var hostTempMemory:Int64 {
                    get {
                        return builderResult.hostTempMemory
                    }
                    set (value) {
                        builderResult.hasHostTempMemory = true
                        builderResult.hostTempMemory = value
                    }
                }
                public var hasHostTempMemory:Bool {
                    get {
                        return builderResult.hasHostTempMemory
                    }
                }
                @discardableResult
                public func setHostTempMemory(_ value:Int64) -> Tensorflow.OpPerformance.OpMemory.Builder {
                    self.hostTempMemory = value
                    return self
                }
                @discardableResult
                public func clearHostTempMemory() -> Tensorflow.OpPerformance.OpMemory.Builder{
                    builderResult.hasHostTempMemory = false
                    builderResult.hostTempMemory = Int64(0)
                    return self
                }
                public var deviceTempMemory:Int64 {
                    get {
                        return builderResult.deviceTempMemory
                    }
                    set (value) {
                        builderResult.hasDeviceTempMemory = true
                        builderResult.deviceTempMemory = value
                    }
                }
                public var hasDeviceTempMemory:Bool {
                    get {
                        return builderResult.hasDeviceTempMemory
                    }
                }
                @discardableResult
                public func setDeviceTempMemory(_ value:Int64) -> Tensorflow.OpPerformance.OpMemory.Builder {
                    self.deviceTempMemory = value
                    return self
                }
                @discardableResult
                public func clearDeviceTempMemory() -> Tensorflow.OpPerformance.OpMemory.Builder{
                    builderResult.hasDeviceTempMemory = false
                    builderResult.deviceTempMemory = Int64(0)
                    return self
                }
                /// The persisted_memory doesn't include outputs.
                public var hostPersistentMemory:Int64 {
                    get {
                        return builderResult.hostPersistentMemory
                    }
                    set (value) {
                        builderResult.hasHostPersistentMemory = true
                        builderResult.hostPersistentMemory = value
                    }
                }
                public var hasHostPersistentMemory:Bool {
                    get {
                        return builderResult.hasHostPersistentMemory
                    }
                }
                @discardableResult
                public func setHostPersistentMemory(_ value:Int64) -> Tensorflow.OpPerformance.OpMemory.Builder {
                    self.hostPersistentMemory = value
                    return self
                }
                @discardableResult
                public func clearHostPersistentMemory() -> Tensorflow.OpPerformance.OpMemory.Builder{
                    builderResult.hasHostPersistentMemory = false
                    builderResult.hostPersistentMemory = Int64(0)
                    return self
                }
                public var devicePersistentMemory:Int64 {
                    get {
                        return builderResult.devicePersistentMemory
                    }
                    set (value) {
                        builderResult.hasDevicePersistentMemory = true
                        builderResult.devicePersistentMemory = value
                    }
                }
                public var hasDevicePersistentMemory:Bool {
                    get {
                        return builderResult.hasDevicePersistentMemory
                    }
                }
                @discardableResult
                public func setDevicePersistentMemory(_ value:Int64) -> Tensorflow.OpPerformance.OpMemory.Builder {
                    self.devicePersistentMemory = value
                    return self
                }
                @discardableResult
                public func clearDevicePersistentMemory() -> Tensorflow.OpPerformance.OpMemory.Builder{
                    builderResult.hasDevicePersistentMemory = false
                    builderResult.devicePersistentMemory = Int64(0)
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.OpPerformance.OpMemory.Builder {
                    builderResult = Tensorflow.OpPerformance.OpMemory()
                    return self
                }
                override public func clone() throws -> Tensorflow.OpPerformance.OpMemory.Builder {
                    return try Tensorflow.OpPerformance.OpMemory.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.OpPerformance.OpMemory {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.OpPerformance.OpMemory {
                    let returnMe:Tensorflow.OpPerformance.OpMemory = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.OpPerformance.OpMemory) throws -> Tensorflow.OpPerformance.OpMemory.Builder {
                    if other == Tensorflow.OpPerformance.OpMemory() {
                        return self
                    }
                    if !other.outputMemory.isEmpty {
                        builderResult.outputMemory += other.outputMemory
                    }
                    if other.hasHostTempMemory {
                        hostTempMemory = other.hostTempMemory
                    }
                    if other.hasDeviceTempMemory {
                        deviceTempMemory = other.deviceTempMemory
                    }
                    if other.hasHostPersistentMemory {
                        hostPersistentMemory = other.hostPersistentMemory
                    }
                    if other.hasDevicePersistentMemory {
                        devicePersistentMemory = other.devicePersistentMemory
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OpPerformance.OpMemory.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpPerformance.OpMemory.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            let length = Int(try codedInputStream.readRawVarint32())
                            let limit = try codedInputStream.pushLimit(byteLimit: length)
                            while (codedInputStream.bytesUntilLimit() > 0) {
                                builderResult.outputMemory.append(try codedInputStream.readInt64())
                            }
                            codedInputStream.popLimit(oldLimit: limit)

                        case 16:
                            hostTempMemory = try codedInputStream.readInt64()

                        case 24:
                            deviceTempMemory = try codedInputStream.readInt64()

                        case 32:
                            hostPersistentMemory = try codedInputStream.readInt64()

                        case 40:
                            devicePersistentMemory = try codedInputStream.readInt64()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OpPerformance.OpMemory.Builder {
                    let resultDecodedBuilder = Tensorflow.OpPerformance.OpMemory.Builder()
                    if let jsonValueOutputMemory = jsonMap["outputMemory"] as? Array<String> {
                        var jsonArrayOutputMemory:Array<Int64> = []
                        for oneValueOutputMemory in jsonValueOutputMemory {
                            jsonArrayOutputMemory.append(Int64(oneValueOutputMemory)!)
                        }
                        resultDecodedBuilder.outputMemory = jsonArrayOutputMemory
                    }
                    if let jsonValueHostTempMemory = jsonMap["hostTempMemory"] as? String {
                        resultDecodedBuilder.hostTempMemory = Int64(jsonValueHostTempMemory)!
                    } else if let jsonValueHostTempMemory = jsonMap["hostTempMemory"] as? Int {
                        resultDecodedBuilder.hostTempMemory = Int64(jsonValueHostTempMemory)
                    }
                    if let jsonValueDeviceTempMemory = jsonMap["deviceTempMemory"] as? String {
                        resultDecodedBuilder.deviceTempMemory = Int64(jsonValueDeviceTempMemory)!
                    } else if let jsonValueDeviceTempMemory = jsonMap["deviceTempMemory"] as? Int {
                        resultDecodedBuilder.deviceTempMemory = Int64(jsonValueDeviceTempMemory)
                    }
                    if let jsonValueHostPersistentMemory = jsonMap["hostPersistentMemory"] as? String {
                        resultDecodedBuilder.hostPersistentMemory = Int64(jsonValueHostPersistentMemory)!
                    } else if let jsonValueHostPersistentMemory = jsonMap["hostPersistentMemory"] as? Int {
                        resultDecodedBuilder.hostPersistentMemory = Int64(jsonValueHostPersistentMemory)
                    }
                    if let jsonValueDevicePersistentMemory = jsonMap["devicePersistentMemory"] as? String {
                        resultDecodedBuilder.devicePersistentMemory = Int64(jsonValueDevicePersistentMemory)!
                    } else if let jsonValueDevicePersistentMemory = jsonMap["devicePersistentMemory"] as? Int {
                        resultDecodedBuilder.devicePersistentMemory = Int64(jsonValueDevicePersistentMemory)
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.OpPerformance.OpMemory.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.OpPerformance.OpMemory.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        public fileprivate(set) var op:Tensorflow.OpInfo!
        public fileprivate(set) var hasOp:Bool = false
        /// The node name (optional). Makes it easier to associate the performance data
        /// with a specific graph node.
        public fileprivate(set) var node:String = ""
        public fileprivate(set) var hasNode:Bool = false

        /// Temporary memory used by this node (in bytes).
        public fileprivate(set) var temporaryMemorySize:Int64 = Int64(0)
        public fileprivate(set) var hasTemporaryMemorySize:Bool = false

        /// Time it takes to run the op (in nanoseconds).
        public fileprivate(set) var computeCost:Int64 = Int64(0)
        public fileprivate(set) var hasComputeCost:Bool = false

        /// Analytical compute cost (in nanoseconds).
        public fileprivate(set) var computeTime:Int64 = Int64(0)
        public fileprivate(set) var hasComputeTime:Bool = false

        /// Analytical memory access cost (in nanoseconds).
        public fileprivate(set) var memoryTime:Int64 = Int64(0)
        public fileprivate(set) var hasMemoryTime:Bool = false

        /// Percentage of theoretical compute performance.
        public fileprivate(set) var computeEfficiency:Double = Double(0)
        public fileprivate(set) var hasComputeEfficiency:Bool = false

        /// Percentage of theoretical memory performance.
        public fileprivate(set) var memoryEfficiency:Double = Double(0)
        public fileprivate(set) var hasMemoryEfficiency:Bool = false

        public fileprivate(set) var opMemory:Tensorflow.OpPerformance.OpMemory!
        public fileprivate(set) var hasOpMemory:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasOp {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:op)
            }
            if hasTemporaryMemorySize {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:temporaryMemorySize)
            }
            if hasComputeCost {
                try codedOutputStream.writeInt64(fieldNumber: 3, value:computeCost)
            }
            if hasComputeEfficiency {
                try codedOutputStream.writeDouble(fieldNumber: 4, value:computeEfficiency)
            }
            if hasNode {
                try codedOutputStream.writeString(fieldNumber: 5, value:node)
            }
            if hasComputeTime {
                try codedOutputStream.writeInt64(fieldNumber: 6, value:computeTime)
            }
            if hasMemoryTime {
                try codedOutputStream.writeInt64(fieldNumber: 7, value:memoryTime)
            }
            if hasMemoryEfficiency {
                try codedOutputStream.writeDouble(fieldNumber: 8, value:memoryEfficiency)
            }
            if hasOpMemory {
                try codedOutputStream.writeMessage(fieldNumber: 9, value:opMemory)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasOp {
                if let varSizeop = op?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeop
                }
            }
            if hasTemporaryMemorySize {
                serialize_size += temporaryMemorySize.computeInt64Size(fieldNumber: 2)
            }
            if hasComputeCost {
                serialize_size += computeCost.computeInt64Size(fieldNumber: 3)
            }
            if hasComputeEfficiency {
                serialize_size += computeEfficiency.computeDoubleSize(fieldNumber: 4)
            }
            if hasNode {
                serialize_size += node.computeStringSize(fieldNumber: 5)
            }
            if hasComputeTime {
                serialize_size += computeTime.computeInt64Size(fieldNumber: 6)
            }
            if hasMemoryTime {
                serialize_size += memoryTime.computeInt64Size(fieldNumber: 7)
            }
            if hasMemoryEfficiency {
                serialize_size += memoryEfficiency.computeDoubleSize(fieldNumber: 8)
            }
            if hasOpMemory {
                if let varSizeopMemory = opMemory?.computeMessageSize(fieldNumber: 9) {
                    serialize_size += varSizeopMemory
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.OpPerformance.Builder {
            return Tensorflow.OpPerformance.classBuilder() as! Tensorflow.OpPerformance.Builder
        }
        public func getBuilder() -> Tensorflow.OpPerformance.Builder {
            return classBuilder() as! Tensorflow.OpPerformance.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.OpPerformance.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.OpPerformance.Builder()
        }
        public func toBuilder() throws -> Tensorflow.OpPerformance.Builder {
            return try Tensorflow.OpPerformance.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.OpPerformance) throws -> Tensorflow.OpPerformance.Builder {
            return try Tensorflow.OpPerformance.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasOp {
                jsonMap["op"] = try op.encode()
            }
            if hasNode {
                jsonMap["node"] = node
            }
            if hasTemporaryMemorySize {
                jsonMap["temporaryMemorySize"] = "\(temporaryMemorySize)"
            }
            if hasComputeCost {
                jsonMap["computeCost"] = "\(computeCost)"
            }
            if hasComputeTime {
                jsonMap["computeTime"] = "\(computeTime)"
            }
            if hasMemoryTime {
                jsonMap["memoryTime"] = "\(memoryTime)"
            }
            if hasComputeEfficiency {
                jsonMap["computeEfficiency"] = Double(computeEfficiency)
            }
            if hasMemoryEfficiency {
                jsonMap["memoryEfficiency"] = Double(memoryEfficiency)
            }
            if hasOpMemory {
                jsonMap["opMemory"] = try opMemory.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OpPerformance {
            return try Tensorflow.OpPerformance.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.OpPerformance {
            return try Tensorflow.OpPerformance.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasOp {
                output += "\(indent) op {\n"
                if let outDescOp = op {
                    output += try outDescOp.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasTemporaryMemorySize {
                output += "\(indent) temporaryMemorySize: \(temporaryMemorySize) \n"
            }
            if hasComputeCost {
                output += "\(indent) computeCost: \(computeCost) \n"
            }
            if hasComputeEfficiency {
                output += "\(indent) computeEfficiency: \(computeEfficiency) \n"
            }
            if hasNode {
                output += "\(indent) node: \(node) \n"
            }
            if hasComputeTime {
                output += "\(indent) computeTime: \(computeTime) \n"
            }
            if hasMemoryTime {
                output += "\(indent) memoryTime: \(memoryTime) \n"
            }
            if hasMemoryEfficiency {
                output += "\(indent) memoryEfficiency: \(memoryEfficiency) \n"
            }
            if hasOpMemory {
                output += "\(indent) opMemory {\n"
                if let outDescOpMemory = opMemory {
                    output += try outDescOpMemory.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasOp {
                    if let hashValueop = op?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueop
                    }
                }
                if hasTemporaryMemorySize {
                    hashCode = (hashCode &* 31) &+ temporaryMemorySize.hashValue
                }
                if hasComputeCost {
                    hashCode = (hashCode &* 31) &+ computeCost.hashValue
                }
                if hasComputeEfficiency {
                    hashCode = (hashCode &* 31) &+ computeEfficiency.hashValue
                }
                if hasNode {
                    hashCode = (hashCode &* 31) &+ node.hashValue
                }
                if hasComputeTime {
                    hashCode = (hashCode &* 31) &+ computeTime.hashValue
                }
                if hasMemoryTime {
                    hashCode = (hashCode &* 31) &+ memoryTime.hashValue
                }
                if hasMemoryEfficiency {
                    hashCode = (hashCode &* 31) &+ memoryEfficiency.hashValue
                }
                if hasOpMemory {
                    if let hashValueopMemory = opMemory?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueopMemory
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.OpPerformance"
        }
        override public func className() -> String {
            return "Tensorflow.OpPerformance"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.OpPerformance = Tensorflow.OpPerformance()
            public func getMessage() -> Tensorflow.OpPerformance {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The op
            public var op:Tensorflow.OpInfo! {
                get {
                    if opBuilder_ != nil {
                        builderResult.op = opBuilder_.getMessage()
                    }
                    return builderResult.op
                }
                set (value) {
                    builderResult.hasOp = true
                    builderResult.op = value
                }
            }
            public var hasOp:Bool {
                get {
                    return builderResult.hasOp
                }
            }
            fileprivate var opBuilder_:Tensorflow.OpInfo.Builder! {
                didSet {
                    builderResult.hasOp = true
                }
            }
            public func getOpBuilder() -> Tensorflow.OpInfo.Builder {
                if opBuilder_ == nil {
                    opBuilder_ = Tensorflow.OpInfo.Builder()
                    builderResult.op = opBuilder_.getMessage()
                    if op != nil {
                        try! opBuilder_.mergeFrom(other: op)
                    }
                }
                return opBuilder_
            }
            @discardableResult
            public func setOp(_ value:Tensorflow.OpInfo!) -> Tensorflow.OpPerformance.Builder {
                self.op = value
                return self
            }
            @discardableResult
            public func mergeOp(value:Tensorflow.OpInfo) throws -> Tensorflow.OpPerformance.Builder {
                if builderResult.hasOp {
                    builderResult.op = try Tensorflow.OpInfo.builderWithPrototype(prototype:builderResult.op).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.op = value
                }
                builderResult.hasOp = true
                return self
            }
            @discardableResult
            public func clearOp() -> Tensorflow.OpPerformance.Builder {
                opBuilder_ = nil
                builderResult.hasOp = false
                builderResult.op = nil
                return self
            }
            /// The node name (optional). Makes it easier to associate the performance data
            /// with a specific graph node.
            public var node:String {
                get {
                    return builderResult.node
                }
                set (value) {
                    builderResult.hasNode = true
                    builderResult.node = value
                }
            }
            public var hasNode:Bool {
                get {
                    return builderResult.hasNode
                }
            }
            @discardableResult
            public func setNode(_ value:String) -> Tensorflow.OpPerformance.Builder {
                self.node = value
                return self
            }
            @discardableResult
            public func clearNode() -> Tensorflow.OpPerformance.Builder{
                builderResult.hasNode = false
                builderResult.node = ""
                return self
            }
            /// Temporary memory used by this node (in bytes).
            public var temporaryMemorySize:Int64 {
                get {
                    return builderResult.temporaryMemorySize
                }
                set (value) {
                    builderResult.hasTemporaryMemorySize = true
                    builderResult.temporaryMemorySize = value
                }
            }
            public var hasTemporaryMemorySize:Bool {
                get {
                    return builderResult.hasTemporaryMemorySize
                }
            }
            @discardableResult
            public func setTemporaryMemorySize(_ value:Int64) -> Tensorflow.OpPerformance.Builder {
                self.temporaryMemorySize = value
                return self
            }
            @discardableResult
            public func clearTemporaryMemorySize() -> Tensorflow.OpPerformance.Builder{
                builderResult.hasTemporaryMemorySize = false
                builderResult.temporaryMemorySize = Int64(0)
                return self
            }
            /// Time it takes to run the op (in nanoseconds).
            public var computeCost:Int64 {
                get {
                    return builderResult.computeCost
                }
                set (value) {
                    builderResult.hasComputeCost = true
                    builderResult.computeCost = value
                }
            }
            public var hasComputeCost:Bool {
                get {
                    return builderResult.hasComputeCost
                }
            }
            @discardableResult
            public func setComputeCost(_ value:Int64) -> Tensorflow.OpPerformance.Builder {
                self.computeCost = value
                return self
            }
            @discardableResult
            public func clearComputeCost() -> Tensorflow.OpPerformance.Builder{
                builderResult.hasComputeCost = false
                builderResult.computeCost = Int64(0)
                return self
            }
            /// Analytical compute cost (in nanoseconds).
            public var computeTime:Int64 {
                get {
                    return builderResult.computeTime
                }
                set (value) {
                    builderResult.hasComputeTime = true
                    builderResult.computeTime = value
                }
            }
            public var hasComputeTime:Bool {
                get {
                    return builderResult.hasComputeTime
                }
            }
            @discardableResult
            public func setComputeTime(_ value:Int64) -> Tensorflow.OpPerformance.Builder {
                self.computeTime = value
                return self
            }
            @discardableResult
            public func clearComputeTime() -> Tensorflow.OpPerformance.Builder{
                builderResult.hasComputeTime = false
                builderResult.computeTime = Int64(0)
                return self
            }
            /// Analytical memory access cost (in nanoseconds).
            public var memoryTime:Int64 {
                get {
                    return builderResult.memoryTime
                }
                set (value) {
                    builderResult.hasMemoryTime = true
                    builderResult.memoryTime = value
                }
            }
            public var hasMemoryTime:Bool {
                get {
                    return builderResult.hasMemoryTime
                }
            }
            @discardableResult
            public func setMemoryTime(_ value:Int64) -> Tensorflow.OpPerformance.Builder {
                self.memoryTime = value
                return self
            }
            @discardableResult
            public func clearMemoryTime() -> Tensorflow.OpPerformance.Builder{
                builderResult.hasMemoryTime = false
                builderResult.memoryTime = Int64(0)
                return self
            }
            /// Percentage of theoretical compute performance.
            public var computeEfficiency:Double {
                get {
                    return builderResult.computeEfficiency
                }
                set (value) {
                    builderResult.hasComputeEfficiency = true
                    builderResult.computeEfficiency = value
                }
            }
            public var hasComputeEfficiency:Bool {
                get {
                    return builderResult.hasComputeEfficiency
                }
            }
            @discardableResult
            public func setComputeEfficiency(_ value:Double) -> Tensorflow.OpPerformance.Builder {
                self.computeEfficiency = value
                return self
            }
            @discardableResult
            public func clearComputeEfficiency() -> Tensorflow.OpPerformance.Builder{
                builderResult.hasComputeEfficiency = false
                builderResult.computeEfficiency = Double(0)
                return self
            }
            /// Percentage of theoretical memory performance.
            public var memoryEfficiency:Double {
                get {
                    return builderResult.memoryEfficiency
                }
                set (value) {
                    builderResult.hasMemoryEfficiency = true
                    builderResult.memoryEfficiency = value
                }
            }
            public var hasMemoryEfficiency:Bool {
                get {
                    return builderResult.hasMemoryEfficiency
                }
            }
            @discardableResult
            public func setMemoryEfficiency(_ value:Double) -> Tensorflow.OpPerformance.Builder {
                self.memoryEfficiency = value
                return self
            }
            @discardableResult
            public func clearMemoryEfficiency() -> Tensorflow.OpPerformance.Builder{
                builderResult.hasMemoryEfficiency = false
                builderResult.memoryEfficiency = Double(0)
                return self
            }
            public var opMemory:Tensorflow.OpPerformance.OpMemory! {
                get {
                    if opMemoryBuilder_ != nil {
                        builderResult.opMemory = opMemoryBuilder_.getMessage()
                    }
                    return builderResult.opMemory
                }
                set (value) {
                    builderResult.hasOpMemory = true
                    builderResult.opMemory = value
                }
            }
            public var hasOpMemory:Bool {
                get {
                    return builderResult.hasOpMemory
                }
            }
            fileprivate var opMemoryBuilder_:Tensorflow.OpPerformance.OpMemory.Builder! {
                didSet {
                    builderResult.hasOpMemory = true
                }
            }
            public func getOpMemoryBuilder() -> Tensorflow.OpPerformance.OpMemory.Builder {
                if opMemoryBuilder_ == nil {
                    opMemoryBuilder_ = Tensorflow.OpPerformance.OpMemory.Builder()
                    builderResult.opMemory = opMemoryBuilder_.getMessage()
                    if opMemory != nil {
                        try! opMemoryBuilder_.mergeFrom(other: opMemory)
                    }
                }
                return opMemoryBuilder_
            }
            @discardableResult
            public func setOpMemory(_ value:Tensorflow.OpPerformance.OpMemory!) -> Tensorflow.OpPerformance.Builder {
                self.opMemory = value
                return self
            }
            @discardableResult
            public func mergeOpMemory(value:Tensorflow.OpPerformance.OpMemory) throws -> Tensorflow.OpPerformance.Builder {
                if builderResult.hasOpMemory {
                    builderResult.opMemory = try Tensorflow.OpPerformance.OpMemory.builderWithPrototype(prototype:builderResult.opMemory).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.opMemory = value
                }
                builderResult.hasOpMemory = true
                return self
            }
            @discardableResult
            public func clearOpMemory() -> Tensorflow.OpPerformance.Builder {
                opMemoryBuilder_ = nil
                builderResult.hasOpMemory = false
                builderResult.opMemory = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.OpPerformance.Builder {
                builderResult = Tensorflow.OpPerformance()
                return self
            }
            override public func clone() throws -> Tensorflow.OpPerformance.Builder {
                return try Tensorflow.OpPerformance.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.OpPerformance {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.OpPerformance {
                let returnMe:Tensorflow.OpPerformance = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.OpPerformance) throws -> Tensorflow.OpPerformance.Builder {
                if other == Tensorflow.OpPerformance() {
                    return self
                }
                if (other.hasOp) {
                    try mergeOp(value: other.op)
                }
                if other.hasNode {
                    node = other.node
                }
                if other.hasTemporaryMemorySize {
                    temporaryMemorySize = other.temporaryMemorySize
                }
                if other.hasComputeCost {
                    computeCost = other.computeCost
                }
                if other.hasComputeTime {
                    computeTime = other.computeTime
                }
                if other.hasMemoryTime {
                    memoryTime = other.memoryTime
                }
                if other.hasComputeEfficiency {
                    computeEfficiency = other.computeEfficiency
                }
                if other.hasMemoryEfficiency {
                    memoryEfficiency = other.memoryEfficiency
                }
                if (other.hasOpMemory) {
                    try mergeOpMemory(value: other.opMemory)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OpPerformance.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpPerformance.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Tensorflow.OpInfo.Builder = Tensorflow.OpInfo.Builder()
                        if hasOp {
                            try subBuilder.mergeFrom(other: op)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        op = subBuilder.buildPartial()

                    case 16:
                        temporaryMemorySize = try codedInputStream.readInt64()

                    case 24:
                        computeCost = try codedInputStream.readInt64()

                    case 33:
                        computeEfficiency = try codedInputStream.readDouble()

                    case 42:
                        node = try codedInputStream.readString()

                    case 48:
                        computeTime = try codedInputStream.readInt64()

                    case 56:
                        memoryTime = try codedInputStream.readInt64()

                    case 65:
                        memoryEfficiency = try codedInputStream.readDouble()

                    case 74:
                        let subBuilder:Tensorflow.OpPerformance.OpMemory.Builder = Tensorflow.OpPerformance.OpMemory.Builder()
                        if hasOpMemory {
                            try subBuilder.mergeFrom(other: opMemory)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        opMemory = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OpPerformance.Builder {
                let resultDecodedBuilder = Tensorflow.OpPerformance.Builder()
                if let jsonValueOp = jsonMap["op"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.op = try Tensorflow.OpInfo.Builder.decodeToBuilder(jsonMap:jsonValueOp).build()

                }
                if let jsonValueNode = jsonMap["node"] as? String {
                    resultDecodedBuilder.node = jsonValueNode
                }
                if let jsonValueTemporaryMemorySize = jsonMap["temporaryMemorySize"] as? String {
                    resultDecodedBuilder.temporaryMemorySize = Int64(jsonValueTemporaryMemorySize)!
                } else if let jsonValueTemporaryMemorySize = jsonMap["temporaryMemorySize"] as? Int {
                    resultDecodedBuilder.temporaryMemorySize = Int64(jsonValueTemporaryMemorySize)
                }
                if let jsonValueComputeCost = jsonMap["computeCost"] as? String {
                    resultDecodedBuilder.computeCost = Int64(jsonValueComputeCost)!
                } else if let jsonValueComputeCost = jsonMap["computeCost"] as? Int {
                    resultDecodedBuilder.computeCost = Int64(jsonValueComputeCost)
                }
                if let jsonValueComputeTime = jsonMap["computeTime"] as? String {
                    resultDecodedBuilder.computeTime = Int64(jsonValueComputeTime)!
                } else if let jsonValueComputeTime = jsonMap["computeTime"] as? Int {
                    resultDecodedBuilder.computeTime = Int64(jsonValueComputeTime)
                }
                if let jsonValueMemoryTime = jsonMap["memoryTime"] as? String {
                    resultDecodedBuilder.memoryTime = Int64(jsonValueMemoryTime)!
                } else if let jsonValueMemoryTime = jsonMap["memoryTime"] as? Int {
                    resultDecodedBuilder.memoryTime = Int64(jsonValueMemoryTime)
                }
                if let jsonValueComputeEfficiency = jsonMap["computeEfficiency"] as? Double {
                    resultDecodedBuilder.computeEfficiency = Double(jsonValueComputeEfficiency)
                } else if let jsonValueComputeEfficiency = jsonMap["computeEfficiency"] as? String {
                    resultDecodedBuilder.computeEfficiency = Double(jsonValueComputeEfficiency)!
                }
                if let jsonValueMemoryEfficiency = jsonMap["memoryEfficiency"] as? Double {
                    resultDecodedBuilder.memoryEfficiency = Double(jsonValueMemoryEfficiency)
                } else if let jsonValueMemoryEfficiency = jsonMap["memoryEfficiency"] as? String {
                    resultDecodedBuilder.memoryEfficiency = Double(jsonValueMemoryEfficiency)!
                }
                if let jsonValueOpMemory = jsonMap["opMemory"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.opMemory = try Tensorflow.OpPerformance.OpMemory.Builder.decodeToBuilder(jsonMap:jsonValueOpMemory).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.OpPerformance.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.OpPerformance.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// A collection of OpPerformance data points.
    final public class OpPerformanceList : GeneratedMessage {

        public static func == (lhs: Tensorflow.OpPerformanceList, rhs: Tensorflow.OpPerformanceList) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.opPerformance == rhs.opPerformance)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var opPerformance:Array<Tensorflow.OpPerformance>  = Array<Tensorflow.OpPerformance>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementOpPerformance in opPerformance {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementOpPerformance)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementOpPerformance in opPerformance {
                serialize_size += oneElementOpPerformance.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.OpPerformanceList.Builder {
            return Tensorflow.OpPerformanceList.classBuilder() as! Tensorflow.OpPerformanceList.Builder
        }
        public func getBuilder() -> Tensorflow.OpPerformanceList.Builder {
            return classBuilder() as! Tensorflow.OpPerformanceList.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.OpPerformanceList.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.OpPerformanceList.Builder()
        }
        public func toBuilder() throws -> Tensorflow.OpPerformanceList.Builder {
            return try Tensorflow.OpPerformanceList.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.OpPerformanceList) throws -> Tensorflow.OpPerformanceList.Builder {
            return try Tensorflow.OpPerformanceList.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !opPerformance.isEmpty {
                var jsonArrayOpPerformance:Array<Dictionary<String,Any>> = []
                for oneValueOpPerformance in opPerformance {
                    let ecodedMessageOpPerformance = try oneValueOpPerformance.encode()
                    jsonArrayOpPerformance.append(ecodedMessageOpPerformance)
                }
                jsonMap["opPerformance"] = jsonArrayOpPerformance
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OpPerformanceList {
            return try Tensorflow.OpPerformanceList.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.OpPerformanceList {
            return try Tensorflow.OpPerformanceList.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var opPerformanceElementIndex:Int = 0
            for oneElementOpPerformance in opPerformance {
                output += "\(indent) opPerformance[\(opPerformanceElementIndex)] {\n"
                output += try oneElementOpPerformance.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                opPerformanceElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementOpPerformance in opPerformance {
                    hashCode = (hashCode &* 31) &+ oneElementOpPerformance.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.OpPerformanceList"
        }
        override public func className() -> String {
            return "Tensorflow.OpPerformanceList"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.OpPerformanceList = Tensorflow.OpPerformanceList()
            public func getMessage() -> Tensorflow.OpPerformanceList {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var opPerformance:Array<Tensorflow.OpPerformance> {
                get {
                    return builderResult.opPerformance
                }
                set (value) {
                    builderResult.opPerformance = value
                }
            }
            @discardableResult
            public func setOpPerformance(_ value:Array<Tensorflow.OpPerformance>) -> Tensorflow.OpPerformanceList.Builder {
                self.opPerformance = value
                return self
            }
            @discardableResult
            public func clearOpPerformance() -> Tensorflow.OpPerformanceList.Builder {
                builderResult.opPerformance.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.OpPerformanceList.Builder {
                builderResult = Tensorflow.OpPerformanceList()
                return self
            }
            override public func clone() throws -> Tensorflow.OpPerformanceList.Builder {
                return try Tensorflow.OpPerformanceList.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.OpPerformanceList {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.OpPerformanceList {
                let returnMe:Tensorflow.OpPerformanceList = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.OpPerformanceList) throws -> Tensorflow.OpPerformanceList.Builder {
                if other == Tensorflow.OpPerformanceList() {
                    return self
                }
                if !other.opPerformance.isEmpty  {
                     builderResult.opPerformance += other.opPerformance
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OpPerformanceList.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpPerformanceList.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Tensorflow.OpPerformance.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        opPerformance.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OpPerformanceList.Builder {
                let resultDecodedBuilder = Tensorflow.OpPerformanceList.Builder()
                if let jsonValueOpPerformance = jsonMap["opPerformance"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayOpPerformance:Array<Tensorflow.OpPerformance> = []
                    for oneValueOpPerformance in jsonValueOpPerformance {
                        let messageFromStringOpPerformance = try Tensorflow.OpPerformance.Builder.decodeToBuilder(jsonMap:oneValueOpPerformance).build()

                        jsonArrayOpPerformance.append(messageFromStringOpPerformance)
                    }
                    resultDecodedBuilder.opPerformance = jsonArrayOpPerformance
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.OpPerformanceList.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.OpPerformanceList.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.OpInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.OpInfo> {
        var mergedArray = Array<Tensorflow.OpInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.OpInfo? {
        return try Tensorflow.OpInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.OpInfo {
        return try Tensorflow.OpInfo.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.OpPerformanceDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpInfo {
        return try Tensorflow.OpInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.OpInfo {
        return try Tensorflow.OpInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpInfo {
        return try Tensorflow.OpInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OpInfo {
        return try Tensorflow.OpInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpInfo {
        return try Tensorflow.OpInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "op": return self.op
        case "attr": return self.attr
        case "inputs": return self.inputs
        case "device": return self.device
        default: return nil
        }
    }
}
extension Tensorflow.OpInfo.AttrEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.OpInfo.AttrEntry> {
        var mergedArray = Array<Tensorflow.OpInfo.AttrEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.OpInfo.AttrEntry? {
        return try Tensorflow.OpInfo.AttrEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.OpInfo.AttrEntry {
        return try Tensorflow.OpInfo.AttrEntry.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.OpPerformanceDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpInfo.AttrEntry {
        return try Tensorflow.OpInfo.AttrEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.OpInfo.AttrEntry {
        return try Tensorflow.OpInfo.AttrEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpInfo.AttrEntry {
        return try Tensorflow.OpInfo.AttrEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OpInfo.AttrEntry {
        return try Tensorflow.OpInfo.AttrEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpInfo.AttrEntry {
        return try Tensorflow.OpInfo.AttrEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.OpInfo.TensorProperties: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.OpInfo.TensorProperties> {
        var mergedArray = Array<Tensorflow.OpInfo.TensorProperties>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.OpInfo.TensorProperties? {
        return try Tensorflow.OpInfo.TensorProperties.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.OpInfo.TensorProperties {
        return try Tensorflow.OpInfo.TensorProperties.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.OpPerformanceDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpInfo.TensorProperties {
        return try Tensorflow.OpInfo.TensorProperties.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.OpInfo.TensorProperties {
        return try Tensorflow.OpInfo.TensorProperties.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpInfo.TensorProperties {
        return try Tensorflow.OpInfo.TensorProperties.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OpInfo.TensorProperties {
        return try Tensorflow.OpInfo.TensorProperties.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpInfo.TensorProperties {
        return try Tensorflow.OpInfo.TensorProperties.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "dtype": return self.dtype
        case "shape": return self.shape
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.OpInfo.DeviceProperties: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.OpInfo.DeviceProperties> {
        var mergedArray = Array<Tensorflow.OpInfo.DeviceProperties>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.OpInfo.DeviceProperties? {
        return try Tensorflow.OpInfo.DeviceProperties.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.OpInfo.DeviceProperties {
        return try Tensorflow.OpInfo.DeviceProperties.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.OpPerformanceDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpInfo.DeviceProperties {
        return try Tensorflow.OpInfo.DeviceProperties.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.OpInfo.DeviceProperties {
        return try Tensorflow.OpInfo.DeviceProperties.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpInfo.DeviceProperties {
        return try Tensorflow.OpInfo.DeviceProperties.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OpInfo.DeviceProperties {
        return try Tensorflow.OpInfo.DeviceProperties.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpInfo.DeviceProperties {
        return try Tensorflow.OpInfo.DeviceProperties.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "type": return self.type
        case "vendor": return self.vendor
        case "model": return self.model
        case "frequency": return self.frequency
        case "numCores": return self.numCores
        case "environment": return self.environment
        case "numRegisters": return self.numRegisters
        case "l1CacheSize": return self.l1CacheSize
        case "l2CacheSize": return self.l2CacheSize
        case "l3CacheSize": return self.l3CacheSize
        case "sharedMemorySizePerMultiprocessor": return self.sharedMemorySizePerMultiprocessor
        case "memorySize": return self.memorySize
        case "bandwidth": return self.bandwidth
        default: return nil
        }
    }
}
extension Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry> {
        var mergedArray = Array<Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry? {
        return try Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry {
        return try Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.OpPerformanceDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry {
        return try Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry {
        return try Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry {
        return try Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry {
        return try Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry {
        return try Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.OpInfo.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "op": return self.op
            case "attr": return self.attr
            case "inputs": return self.inputs
            case "device": return self.device
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "op":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.op = newSubscriptValue
            case "attr":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,Tensorflow.AttrValue> else {
                    return
                }
                self.attr = newSubscriptValue
            case "inputs":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.OpInfo.TensorProperties> else {
                    return
                }
                self.inputs = newSubscriptValue
            case "device":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.OpInfo.DeviceProperties else {
                    return
                }
                self.device = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.OpInfo.AttrEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.AttrValue else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.OpInfo.TensorProperties.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "dtype": return self.dtype
            case "shape": return self.shape
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "dtype":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.DataType else {
                    return
                }
                self.dtype = newSubscriptValue
            case "shape":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.TensorShapeProto else {
                    return
                }
                self.shape = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.TensorProto else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.OpInfo.DeviceProperties.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "type": return self.type
            case "vendor": return self.vendor
            case "model": return self.model
            case "frequency": return self.frequency
            case "numCores": return self.numCores
            case "environment": return self.environment
            case "numRegisters": return self.numRegisters
            case "l1CacheSize": return self.l1CacheSize
            case "l2CacheSize": return self.l2CacheSize
            case "l3CacheSize": return self.l3CacheSize
            case "sharedMemorySizePerMultiprocessor": return self.sharedMemorySizePerMultiprocessor
            case "memorySize": return self.memorySize
            case "bandwidth": return self.bandwidth
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "type":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.type = newSubscriptValue
            case "vendor":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.vendor = newSubscriptValue
            case "model":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.model = newSubscriptValue
            case "frequency":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.frequency = newSubscriptValue
            case "numCores":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.numCores = newSubscriptValue
            case "environment":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,String> else {
                    return
                }
                self.environment = newSubscriptValue
            case "numRegisters":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.numRegisters = newSubscriptValue
            case "l1CacheSize":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.l1CacheSize = newSubscriptValue
            case "l2CacheSize":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.l2CacheSize = newSubscriptValue
            case "l3CacheSize":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.l3CacheSize = newSubscriptValue
            case "sharedMemorySizePerMultiprocessor":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.sharedMemorySizePerMultiprocessor = newSubscriptValue
            case "memorySize":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.memorySize = newSubscriptValue
            case "bandwidth":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.bandwidth = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.OpInfo.DeviceProperties.EnvironmentEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.OpPerformance: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.OpPerformance> {
        var mergedArray = Array<Tensorflow.OpPerformance>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.OpPerformance? {
        return try Tensorflow.OpPerformance.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.OpPerformance {
        return try Tensorflow.OpPerformance.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.OpPerformanceDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpPerformance {
        return try Tensorflow.OpPerformance.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.OpPerformance {
        return try Tensorflow.OpPerformance.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpPerformance {
        return try Tensorflow.OpPerformance.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OpPerformance {
        return try Tensorflow.OpPerformance.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpPerformance {
        return try Tensorflow.OpPerformance.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "op": return self.op
        case "node": return self.node
        case "temporaryMemorySize": return self.temporaryMemorySize
        case "computeCost": return self.computeCost
        case "computeTime": return self.computeTime
        case "memoryTime": return self.memoryTime
        case "computeEfficiency": return self.computeEfficiency
        case "memoryEfficiency": return self.memoryEfficiency
        case "opMemory": return self.opMemory
        default: return nil
        }
    }
}
extension Tensorflow.OpPerformance.OpMemory: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.OpPerformance.OpMemory> {
        var mergedArray = Array<Tensorflow.OpPerformance.OpMemory>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.OpPerformance.OpMemory? {
        return try Tensorflow.OpPerformance.OpMemory.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.OpPerformance.OpMemory {
        return try Tensorflow.OpPerformance.OpMemory.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.OpPerformanceDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpPerformance.OpMemory {
        return try Tensorflow.OpPerformance.OpMemory.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.OpPerformance.OpMemory {
        return try Tensorflow.OpPerformance.OpMemory.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpPerformance.OpMemory {
        return try Tensorflow.OpPerformance.OpMemory.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OpPerformance.OpMemory {
        return try Tensorflow.OpPerformance.OpMemory.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpPerformance.OpMemory {
        return try Tensorflow.OpPerformance.OpMemory.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "outputMemory": return self.outputMemory
        case "hostTempMemory": return self.hostTempMemory
        case "deviceTempMemory": return self.deviceTempMemory
        case "hostPersistentMemory": return self.hostPersistentMemory
        case "devicePersistentMemory": return self.devicePersistentMemory
        default: return nil
        }
    }
}
extension Tensorflow.OpPerformance.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "op": return self.op
            case "node": return self.node
            case "temporaryMemorySize": return self.temporaryMemorySize
            case "computeCost": return self.computeCost
            case "computeTime": return self.computeTime
            case "memoryTime": return self.memoryTime
            case "computeEfficiency": return self.computeEfficiency
            case "memoryEfficiency": return self.memoryEfficiency
            case "opMemory": return self.opMemory
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "op":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.OpInfo else {
                    return
                }
                self.op = newSubscriptValue
            case "node":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.node = newSubscriptValue
            case "temporaryMemorySize":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.temporaryMemorySize = newSubscriptValue
            case "computeCost":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.computeCost = newSubscriptValue
            case "computeTime":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.computeTime = newSubscriptValue
            case "memoryTime":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.memoryTime = newSubscriptValue
            case "computeEfficiency":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.computeEfficiency = newSubscriptValue
            case "memoryEfficiency":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.memoryEfficiency = newSubscriptValue
            case "opMemory":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.OpPerformance.OpMemory else {
                    return
                }
                self.opMemory = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.OpPerformance.OpMemory.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "outputMemory": return self.outputMemory
            case "hostTempMemory": return self.hostTempMemory
            case "deviceTempMemory": return self.deviceTempMemory
            case "hostPersistentMemory": return self.hostPersistentMemory
            case "devicePersistentMemory": return self.devicePersistentMemory
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "outputMemory":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.outputMemory = newSubscriptValue
            case "hostTempMemory":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.hostTempMemory = newSubscriptValue
            case "deviceTempMemory":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.deviceTempMemory = newSubscriptValue
            case "hostPersistentMemory":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.hostPersistentMemory = newSubscriptValue
            case "devicePersistentMemory":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.devicePersistentMemory = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.OpPerformanceList: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.OpPerformanceList> {
        var mergedArray = Array<Tensorflow.OpPerformanceList>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.OpPerformanceList? {
        return try Tensorflow.OpPerformanceList.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.OpPerformanceList {
        return try Tensorflow.OpPerformanceList.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.OpPerformanceDataRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpPerformanceList {
        return try Tensorflow.OpPerformanceList.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.OpPerformanceList {
        return try Tensorflow.OpPerformanceList.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpPerformanceList {
        return try Tensorflow.OpPerformanceList.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OpPerformanceList {
        return try Tensorflow.OpPerformanceList.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpPerformanceList {
        return try Tensorflow.OpPerformanceList.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "opPerformance": return self.opPerformance
        default: return nil
        }
    }
}
extension Tensorflow.OpPerformanceList.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "opPerformance": return self.opPerformance
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "opPerformance":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.OpPerformance> else {
                    return
                }
                self.opPerformance = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

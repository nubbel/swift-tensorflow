/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "op_gen_overrides.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { }

public extension Tensorflow {
    public struct OpGenOverridesRoot {
        public static let `default` = OpGenOverridesRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Tensorflow.AttrValueRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    /// Used to override the default API & behavior in the generated code
    /// for client languages, from what you would get from the OpDef alone.
    /// This is so we can evolve the API while remaining backwards
    /// compatible when interpretting old graphs.  Overrides go in an
    /// "op_gen_overrides.pbtxt" file with a text-format OpGenOverrides
    /// message.  Right now these only apply to the C++ API.
    /// TODO(josh11b): In the future there will be a common set of overrides
    /// and per-client-language overrides.
    /// WARNING: Be *very* careful using these features -- these overrides
    /// can change the semantics of existing code.  These changes may need
    /// to wait until a major release of TensorFlow to avoid breaking our
    /// compatibility promises.
    final public class OpGenOverride : GeneratedMessage {

        public static func == (lhs: Tensorflow.OpGenOverride, rhs: Tensorflow.OpGenOverride) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
            fieldCheck = fieldCheck && (lhs.hasSkip == rhs.hasSkip) && (!lhs.hasSkip || lhs.skip == rhs.skip)
            fieldCheck = fieldCheck && (lhs.hasHide == rhs.hasHide) && (!lhs.hasHide || lhs.hide == rhs.hide)
            fieldCheck = fieldCheck && (lhs.hasRenameTo == rhs.hasRenameTo) && (!lhs.hasRenameTo || lhs.renameTo == rhs.renameTo)
            fieldCheck = fieldCheck && (lhs.alias == rhs.alias)
            fieldCheck = fieldCheck && (lhs.attrDefault == rhs.attrDefault)
            fieldCheck = fieldCheck && (lhs.attrRename == rhs.attrRename)
            fieldCheck = fieldCheck && (lhs.inputRename == rhs.inputRename)
            fieldCheck = fieldCheck && (lhs.outputRename == rhs.outputRename)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        /// Map the name of an attr to a new default value to use.  This
        /// default will be used when creating new graphs, as opposed to the
        /// default in the OpDef, which will be used when interpreting old
        /// GraphDefs.  If this attr is also renamed (using attr_rename
        /// below), use the original name of the attr.
        final public class AttrDefault : GeneratedMessage {

            public static func == (lhs: Tensorflow.OpGenOverride.AttrDefault, rhs: Tensorflow.OpGenOverride.AttrDefault) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var name:String = ""
            public fileprivate(set) var hasName:Bool = false

            public fileprivate(set) var value:Tensorflow.AttrValue!
            public fileprivate(set) var hasValue:Bool = false
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasName {
                    try codedOutputStream.writeString(fieldNumber: 1, value:name)
                }
                if hasValue {
                    try codedOutputStream.writeMessage(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasName {
                    serialize_size += name.computeStringSize(fieldNumber: 1)
                }
                if hasValue {
                    if let varSizevalue = value?.computeMessageSize(fieldNumber: 2) {
                        serialize_size += varSizevalue
                    }
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.OpGenOverride.AttrDefault.Builder {
                return Tensorflow.OpGenOverride.AttrDefault.classBuilder() as! Tensorflow.OpGenOverride.AttrDefault.Builder
            }
            public func getBuilder() -> Tensorflow.OpGenOverride.AttrDefault.Builder {
                return classBuilder() as! Tensorflow.OpGenOverride.AttrDefault.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.OpGenOverride.AttrDefault.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.OpGenOverride.AttrDefault.Builder()
            }
            public func toBuilder() throws -> Tensorflow.OpGenOverride.AttrDefault.Builder {
                return try Tensorflow.OpGenOverride.AttrDefault.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.OpGenOverride.AttrDefault) throws -> Tensorflow.OpGenOverride.AttrDefault.Builder {
                return try Tensorflow.OpGenOverride.AttrDefault.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasName {
                    jsonMap["name"] = name
                }
                if hasValue {
                    jsonMap["value"] = try value.encode()
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OpGenOverride.AttrDefault {
                return try Tensorflow.OpGenOverride.AttrDefault.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.OpGenOverride.AttrDefault {
                return try Tensorflow.OpGenOverride.AttrDefault.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasName {
                    output += "\(indent) name: \(name) \n"
                }
                if hasValue {
                    output += "\(indent) value {\n"
                    if let outDescValue = value {
                        output += try outDescValue.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasName {
                        hashCode = (hashCode &* 31) &+ name.hashValue
                    }
                    if hasValue {
                        if let hashValuevalue = value?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuevalue
                        }
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.OpGenOverride.AttrDefault"
            }
            override public func className() -> String {
                return "Tensorflow.OpGenOverride.AttrDefault"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.OpGenOverride.AttrDefault = Tensorflow.OpGenOverride.AttrDefault()
                public func getMessage() -> Tensorflow.OpGenOverride.AttrDefault {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var name:String {
                    get {
                        return builderResult.name
                    }
                    set (value) {
                        builderResult.hasName = true
                        builderResult.name = value
                    }
                }
                public var hasName:Bool {
                    get {
                        return builderResult.hasName
                    }
                }
                @discardableResult
                public func setName(_ value:String) -> Tensorflow.OpGenOverride.AttrDefault.Builder {
                    self.name = value
                    return self
                }
                @discardableResult
                public func clearName() -> Tensorflow.OpGenOverride.AttrDefault.Builder{
                    builderResult.hasName = false
                    builderResult.name = ""
                    return self
                }
                public var value:Tensorflow.AttrValue! {
                    get {
                        if valueBuilder_ != nil {
                            builderResult.value = valueBuilder_.getMessage()
                        }
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                fileprivate var valueBuilder_:Tensorflow.AttrValue.Builder! {
                    didSet {
                        builderResult.hasValue = true
                    }
                }
                public func getValueBuilder() -> Tensorflow.AttrValue.Builder {
                    if valueBuilder_ == nil {
                        valueBuilder_ = Tensorflow.AttrValue.Builder()
                        builderResult.value = valueBuilder_.getMessage()
                        if value != nil {
                            try! valueBuilder_.mergeFrom(other: value)
                        }
                    }
                    return valueBuilder_
                }
                @discardableResult
                public func setValue(_ value:Tensorflow.AttrValue!) -> Tensorflow.OpGenOverride.AttrDefault.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func mergeValue(value:Tensorflow.AttrValue) throws -> Tensorflow.OpGenOverride.AttrDefault.Builder {
                    if builderResult.hasValue {
                        builderResult.value = try Tensorflow.AttrValue.builderWithPrototype(prototype:builderResult.value).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.value = value
                    }
                    builderResult.hasValue = true
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.OpGenOverride.AttrDefault.Builder {
                    valueBuilder_ = nil
                    builderResult.hasValue = false
                    builderResult.value = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.OpGenOverride.AttrDefault.Builder {
                    builderResult = Tensorflow.OpGenOverride.AttrDefault()
                    return self
                }
                override public func clone() throws -> Tensorflow.OpGenOverride.AttrDefault.Builder {
                    return try Tensorflow.OpGenOverride.AttrDefault.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.OpGenOverride.AttrDefault {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.OpGenOverride.AttrDefault {
                    let returnMe:Tensorflow.OpGenOverride.AttrDefault = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.OpGenOverride.AttrDefault) throws -> Tensorflow.OpGenOverride.AttrDefault.Builder {
                    if other == Tensorflow.OpGenOverride.AttrDefault() {
                        return self
                    }
                    if other.hasName {
                        name = other.name
                    }
                    if (other.hasValue) {
                        try mergeValue(value: other.value)
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OpGenOverride.AttrDefault.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpGenOverride.AttrDefault.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            name = try codedInputStream.readString()

                        case 18:
                            let subBuilder:Tensorflow.AttrValue.Builder = Tensorflow.AttrValue.Builder()
                            if hasValue {
                                try subBuilder.mergeFrom(other: value)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            value = subBuilder.buildPartial()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OpGenOverride.AttrDefault.Builder {
                    let resultDecodedBuilder = Tensorflow.OpGenOverride.AttrDefault.Builder()
                    if let jsonValueName = jsonMap["name"] as? String {
                        resultDecodedBuilder.name = jsonValueName
                    }
                    if let jsonValueValue = jsonMap["value"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.value = try Tensorflow.AttrValue.Builder.decodeToBuilder(jsonMap:jsonValueValue).build()

                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.OpGenOverride.AttrDefault.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.OpGenOverride.AttrDefault.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        /// Change the name used to access attrs/inputs/outputs in the API
        /// from what is used in the GraphDef.  Note that these names in
        /// `backticks` will also be replaced in the docs.
        final public class Rename : GeneratedMessage {

            public static func == (lhs: Tensorflow.OpGenOverride.Rename, rhs: Tensorflow.OpGenOverride.Rename) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasFrom == rhs.hasFrom) && (!lhs.hasFrom || lhs.from == rhs.from)
                fieldCheck = fieldCheck && (lhs.hasTo == rhs.hasTo) && (!lhs.hasTo || lhs.to == rhs.to)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var from:String = ""
            public fileprivate(set) var hasFrom:Bool = false

            public fileprivate(set) var to:String = ""
            public fileprivate(set) var hasTo:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasFrom {
                    try codedOutputStream.writeString(fieldNumber: 1, value:from)
                }
                if hasTo {
                    try codedOutputStream.writeString(fieldNumber: 2, value:to)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasFrom {
                    serialize_size += from.computeStringSize(fieldNumber: 1)
                }
                if hasTo {
                    serialize_size += to.computeStringSize(fieldNumber: 2)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.OpGenOverride.Rename.Builder {
                return Tensorflow.OpGenOverride.Rename.classBuilder() as! Tensorflow.OpGenOverride.Rename.Builder
            }
            public func getBuilder() -> Tensorflow.OpGenOverride.Rename.Builder {
                return classBuilder() as! Tensorflow.OpGenOverride.Rename.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.OpGenOverride.Rename.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.OpGenOverride.Rename.Builder()
            }
            public func toBuilder() throws -> Tensorflow.OpGenOverride.Rename.Builder {
                return try Tensorflow.OpGenOverride.Rename.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.OpGenOverride.Rename) throws -> Tensorflow.OpGenOverride.Rename.Builder {
                return try Tensorflow.OpGenOverride.Rename.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasFrom {
                    jsonMap["from"] = from
                }
                if hasTo {
                    jsonMap["to"] = to
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OpGenOverride.Rename {
                return try Tensorflow.OpGenOverride.Rename.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.OpGenOverride.Rename {
                return try Tensorflow.OpGenOverride.Rename.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasFrom {
                    output += "\(indent) from: \(from) \n"
                }
                if hasTo {
                    output += "\(indent) to: \(to) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasFrom {
                        hashCode = (hashCode &* 31) &+ from.hashValue
                    }
                    if hasTo {
                        hashCode = (hashCode &* 31) &+ to.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.OpGenOverride.Rename"
            }
            override public func className() -> String {
                return "Tensorflow.OpGenOverride.Rename"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.OpGenOverride.Rename = Tensorflow.OpGenOverride.Rename()
                public func getMessage() -> Tensorflow.OpGenOverride.Rename {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var from:String {
                    get {
                        return builderResult.from
                    }
                    set (value) {
                        builderResult.hasFrom = true
                        builderResult.from = value
                    }
                }
                public var hasFrom:Bool {
                    get {
                        return builderResult.hasFrom
                    }
                }
                @discardableResult
                public func setFrom(_ value:String) -> Tensorflow.OpGenOverride.Rename.Builder {
                    self.from = value
                    return self
                }
                @discardableResult
                public func clearFrom() -> Tensorflow.OpGenOverride.Rename.Builder{
                    builderResult.hasFrom = false
                    builderResult.from = ""
                    return self
                }
                public var to:String {
                    get {
                        return builderResult.to
                    }
                    set (value) {
                        builderResult.hasTo = true
                        builderResult.to = value
                    }
                }
                public var hasTo:Bool {
                    get {
                        return builderResult.hasTo
                    }
                }
                @discardableResult
                public func setTo(_ value:String) -> Tensorflow.OpGenOverride.Rename.Builder {
                    self.to = value
                    return self
                }
                @discardableResult
                public func clearTo() -> Tensorflow.OpGenOverride.Rename.Builder{
                    builderResult.hasTo = false
                    builderResult.to = ""
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.OpGenOverride.Rename.Builder {
                    builderResult = Tensorflow.OpGenOverride.Rename()
                    return self
                }
                override public func clone() throws -> Tensorflow.OpGenOverride.Rename.Builder {
                    return try Tensorflow.OpGenOverride.Rename.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.OpGenOverride.Rename {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.OpGenOverride.Rename {
                    let returnMe:Tensorflow.OpGenOverride.Rename = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.OpGenOverride.Rename) throws -> Tensorflow.OpGenOverride.Rename.Builder {
                    if other == Tensorflow.OpGenOverride.Rename() {
                        return self
                    }
                    if other.hasFrom {
                        from = other.from
                    }
                    if other.hasTo {
                        to = other.to
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OpGenOverride.Rename.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpGenOverride.Rename.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            from = try codedInputStream.readString()

                        case 18:
                            to = try codedInputStream.readString()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OpGenOverride.Rename.Builder {
                    let resultDecodedBuilder = Tensorflow.OpGenOverride.Rename.Builder()
                    if let jsonValueFrom = jsonMap["from"] as? String {
                        resultDecodedBuilder.from = jsonValueFrom
                    }
                    if let jsonValueTo = jsonMap["to"] as? String {
                        resultDecodedBuilder.to = jsonValueTo
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.OpGenOverride.Rename.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.OpGenOverride.Rename.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        /// Name of the op to apply overrides to.
        public fileprivate(set) var name:String = ""
        public fileprivate(set) var hasName:Bool = false

        /// Do not include this op in the generated API.
        /// If `skip` is true, all other overrides are ignored for this op.
        public fileprivate(set) var skip:Bool = false
        public fileprivate(set) var hasSkip:Bool = false

        /// Hide this op by putting it into an internal namespace (or whatever
        /// is appropriate in the target language).
        public fileprivate(set) var hide:Bool = false
        public fileprivate(set) var hasHide:Bool = false

        /// Use a different name in the API than the op's name. Note that
        /// the op's name in `backticks` will also be replaced in the docs.
        public fileprivate(set) var renameTo:String = ""
        public fileprivate(set) var hasRenameTo:Bool = false

        /// Create *additional* API endpoints with different names (contrast
        /// with rename_to, which affects the original name).
        public fileprivate(set) var alias:Array<String> = Array<String>()
        public fileprivate(set) var attrDefault:Array<Tensorflow.OpGenOverride.AttrDefault>  = Array<Tensorflow.OpGenOverride.AttrDefault>()
        public fileprivate(set) var attrRename:Array<Tensorflow.OpGenOverride.Rename>  = Array<Tensorflow.OpGenOverride.Rename>()
        public fileprivate(set) var inputRename:Array<Tensorflow.OpGenOverride.Rename>  = Array<Tensorflow.OpGenOverride.Rename>()
        public fileprivate(set) var outputRename:Array<Tensorflow.OpGenOverride.Rename>  = Array<Tensorflow.OpGenOverride.Rename>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasName {
                try codedOutputStream.writeString(fieldNumber: 1, value:name)
            }
            if hasSkip {
                try codedOutputStream.writeBool(fieldNumber: 2, value:skip)
            }
            if hasHide {
                try codedOutputStream.writeBool(fieldNumber: 3, value:hide)
            }
            if hasRenameTo {
                try codedOutputStream.writeString(fieldNumber: 4, value:renameTo)
            }
            if !alias.isEmpty {
                for oneValuealias in alias {
                    try codedOutputStream.writeString(fieldNumber: 5, value:oneValuealias)
                }
            }
            for oneElementAttrDefault in attrDefault {
                  try codedOutputStream.writeMessage(fieldNumber: 6, value:oneElementAttrDefault)
            }
            for oneElementAttrRename in attrRename {
                  try codedOutputStream.writeMessage(fieldNumber: 7, value:oneElementAttrRename)
            }
            for oneElementInputRename in inputRename {
                  try codedOutputStream.writeMessage(fieldNumber: 8, value:oneElementInputRename)
            }
            for oneElementOutputRename in outputRename {
                  try codedOutputStream.writeMessage(fieldNumber: 9, value:oneElementOutputRename)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasName {
                serialize_size += name.computeStringSize(fieldNumber: 1)
            }
            if hasSkip {
                serialize_size += skip.computeBoolSize(fieldNumber: 2)
            }
            if hasHide {
                serialize_size += hide.computeBoolSize(fieldNumber: 3)
            }
            if hasRenameTo {
                serialize_size += renameTo.computeStringSize(fieldNumber: 4)
            }
            var dataSizeAlias:Int32 = 0
            for oneValuealias in alias {
                dataSizeAlias += oneValuealias.computeStringSizeNoTag()
            }
            serialize_size += dataSizeAlias
            serialize_size += 1 * Int32(alias.count)
            for oneElementAttrDefault in attrDefault {
                serialize_size += oneElementAttrDefault.computeMessageSize(fieldNumber: 6)
            }
            for oneElementAttrRename in attrRename {
                serialize_size += oneElementAttrRename.computeMessageSize(fieldNumber: 7)
            }
            for oneElementInputRename in inputRename {
                serialize_size += oneElementInputRename.computeMessageSize(fieldNumber: 8)
            }
            for oneElementOutputRename in outputRename {
                serialize_size += oneElementOutputRename.computeMessageSize(fieldNumber: 9)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.OpGenOverride.Builder {
            return Tensorflow.OpGenOverride.classBuilder() as! Tensorflow.OpGenOverride.Builder
        }
        public func getBuilder() -> Tensorflow.OpGenOverride.Builder {
            return classBuilder() as! Tensorflow.OpGenOverride.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.OpGenOverride.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.OpGenOverride.Builder()
        }
        public func toBuilder() throws -> Tensorflow.OpGenOverride.Builder {
            return try Tensorflow.OpGenOverride.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.OpGenOverride) throws -> Tensorflow.OpGenOverride.Builder {
            return try Tensorflow.OpGenOverride.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasName {
                jsonMap["name"] = name
            }
            if hasSkip {
                jsonMap["skip"] = skip
            }
            if hasHide {
                jsonMap["hide"] = hide
            }
            if hasRenameTo {
                jsonMap["renameTo"] = renameTo
            }
            if !alias.isEmpty {
                var jsonArrayAlias:Array<String> = []
                for oneValueAlias in alias {
                    jsonArrayAlias.append(oneValueAlias)
                }
                jsonMap["alias"] = jsonArrayAlias
            }
            if !attrDefault.isEmpty {
                var jsonArrayAttrDefault:Array<Dictionary<String,Any>> = []
                for oneValueAttrDefault in attrDefault {
                    let ecodedMessageAttrDefault = try oneValueAttrDefault.encode()
                    jsonArrayAttrDefault.append(ecodedMessageAttrDefault)
                }
                jsonMap["attrDefault"] = jsonArrayAttrDefault
            }
            if !attrRename.isEmpty {
                var jsonArrayAttrRename:Array<Dictionary<String,Any>> = []
                for oneValueAttrRename in attrRename {
                    let ecodedMessageAttrRename = try oneValueAttrRename.encode()
                    jsonArrayAttrRename.append(ecodedMessageAttrRename)
                }
                jsonMap["attrRename"] = jsonArrayAttrRename
            }
            if !inputRename.isEmpty {
                var jsonArrayInputRename:Array<Dictionary<String,Any>> = []
                for oneValueInputRename in inputRename {
                    let ecodedMessageInputRename = try oneValueInputRename.encode()
                    jsonArrayInputRename.append(ecodedMessageInputRename)
                }
                jsonMap["inputRename"] = jsonArrayInputRename
            }
            if !outputRename.isEmpty {
                var jsonArrayOutputRename:Array<Dictionary<String,Any>> = []
                for oneValueOutputRename in outputRename {
                    let ecodedMessageOutputRename = try oneValueOutputRename.encode()
                    jsonArrayOutputRename.append(ecodedMessageOutputRename)
                }
                jsonMap["outputRename"] = jsonArrayOutputRename
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OpGenOverride {
            return try Tensorflow.OpGenOverride.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.OpGenOverride {
            return try Tensorflow.OpGenOverride.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasName {
                output += "\(indent) name: \(name) \n"
            }
            if hasSkip {
                output += "\(indent) skip: \(skip) \n"
            }
            if hasHide {
                output += "\(indent) hide: \(hide) \n"
            }
            if hasRenameTo {
                output += "\(indent) renameTo: \(renameTo) \n"
            }
            var aliasElementIndex:Int = 0
            for oneValueAlias in alias  {
                output += "\(indent) alias[\(aliasElementIndex)]: \(oneValueAlias)\n"
                aliasElementIndex += 1
            }
            var attrDefaultElementIndex:Int = 0
            for oneElementAttrDefault in attrDefault {
                output += "\(indent) attrDefault[\(attrDefaultElementIndex)] {\n"
                output += try oneElementAttrDefault.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                attrDefaultElementIndex += 1
            }
            var attrRenameElementIndex:Int = 0
            for oneElementAttrRename in attrRename {
                output += "\(indent) attrRename[\(attrRenameElementIndex)] {\n"
                output += try oneElementAttrRename.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                attrRenameElementIndex += 1
            }
            var inputRenameElementIndex:Int = 0
            for oneElementInputRename in inputRename {
                output += "\(indent) inputRename[\(inputRenameElementIndex)] {\n"
                output += try oneElementInputRename.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                inputRenameElementIndex += 1
            }
            var outputRenameElementIndex:Int = 0
            for oneElementOutputRename in outputRename {
                output += "\(indent) outputRename[\(outputRenameElementIndex)] {\n"
                output += try oneElementOutputRename.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                outputRenameElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasName {
                    hashCode = (hashCode &* 31) &+ name.hashValue
                }
                if hasSkip {
                    hashCode = (hashCode &* 31) &+ skip.hashValue
                }
                if hasHide {
                    hashCode = (hashCode &* 31) &+ hide.hashValue
                }
                if hasRenameTo {
                    hashCode = (hashCode &* 31) &+ renameTo.hashValue
                }
                for oneValueAlias in alias {
                    hashCode = (hashCode &* 31) &+ oneValueAlias.hashValue
                }
                for oneElementAttrDefault in attrDefault {
                    hashCode = (hashCode &* 31) &+ oneElementAttrDefault.hashValue
                }
                for oneElementAttrRename in attrRename {
                    hashCode = (hashCode &* 31) &+ oneElementAttrRename.hashValue
                }
                for oneElementInputRename in inputRename {
                    hashCode = (hashCode &* 31) &+ oneElementInputRename.hashValue
                }
                for oneElementOutputRename in outputRename {
                    hashCode = (hashCode &* 31) &+ oneElementOutputRename.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.OpGenOverride"
        }
        override public func className() -> String {
            return "Tensorflow.OpGenOverride"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.OpGenOverride = Tensorflow.OpGenOverride()
            public func getMessage() -> Tensorflow.OpGenOverride {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Name of the op to apply overrides to.
            public var name:String {
                get {
                    return builderResult.name
                }
                set (value) {
                    builderResult.hasName = true
                    builderResult.name = value
                }
            }
            public var hasName:Bool {
                get {
                    return builderResult.hasName
                }
            }
            @discardableResult
            public func setName(_ value:String) -> Tensorflow.OpGenOverride.Builder {
                self.name = value
                return self
            }
            @discardableResult
            public func clearName() -> Tensorflow.OpGenOverride.Builder{
                builderResult.hasName = false
                builderResult.name = ""
                return self
            }
            /// Do not include this op in the generated API.
            /// If `skip` is true, all other overrides are ignored for this op.
            public var skip:Bool {
                get {
                    return builderResult.skip
                }
                set (value) {
                    builderResult.hasSkip = true
                    builderResult.skip = value
                }
            }
            public var hasSkip:Bool {
                get {
                    return builderResult.hasSkip
                }
            }
            @discardableResult
            public func setSkip(_ value:Bool) -> Tensorflow.OpGenOverride.Builder {
                self.skip = value
                return self
            }
            @discardableResult
            public func clearSkip() -> Tensorflow.OpGenOverride.Builder{
                builderResult.hasSkip = false
                builderResult.skip = false
                return self
            }
            /// Hide this op by putting it into an internal namespace (or whatever
            /// is appropriate in the target language).
            public var hide:Bool {
                get {
                    return builderResult.hide
                }
                set (value) {
                    builderResult.hasHide = true
                    builderResult.hide = value
                }
            }
            public var hasHide:Bool {
                get {
                    return builderResult.hasHide
                }
            }
            @discardableResult
            public func setHide(_ value:Bool) -> Tensorflow.OpGenOverride.Builder {
                self.hide = value
                return self
            }
            @discardableResult
            public func clearHide() -> Tensorflow.OpGenOverride.Builder{
                builderResult.hasHide = false
                builderResult.hide = false
                return self
            }
            /// Use a different name in the API than the op's name. Note that
            /// the op's name in `backticks` will also be replaced in the docs.
            public var renameTo:String {
                get {
                    return builderResult.renameTo
                }
                set (value) {
                    builderResult.hasRenameTo = true
                    builderResult.renameTo = value
                }
            }
            public var hasRenameTo:Bool {
                get {
                    return builderResult.hasRenameTo
                }
            }
            @discardableResult
            public func setRenameTo(_ value:String) -> Tensorflow.OpGenOverride.Builder {
                self.renameTo = value
                return self
            }
            @discardableResult
            public func clearRenameTo() -> Tensorflow.OpGenOverride.Builder{
                builderResult.hasRenameTo = false
                builderResult.renameTo = ""
                return self
            }
            /// Create *additional* API endpoints with different names (contrast
            /// with rename_to, which affects the original name).
            public var alias:Array<String> {
                get {
                    return builderResult.alias
                }
                set (array) {
                    builderResult.alias = array
                }
            }
            @discardableResult
            public func setAlias(_ value:Array<String>) -> Tensorflow.OpGenOverride.Builder {
                self.alias = value
                return self
            }
            @discardableResult
            public func clearAlias() -> Tensorflow.OpGenOverride.Builder {
                builderResult.alias.removeAll(keepingCapacity: false)
                return self
            }
            public var attrDefault:Array<Tensorflow.OpGenOverride.AttrDefault> {
                get {
                    return builderResult.attrDefault
                }
                set (value) {
                    builderResult.attrDefault = value
                }
            }
            @discardableResult
            public func setAttrDefault(_ value:Array<Tensorflow.OpGenOverride.AttrDefault>) -> Tensorflow.OpGenOverride.Builder {
                self.attrDefault = value
                return self
            }
            @discardableResult
            public func clearAttrDefault() -> Tensorflow.OpGenOverride.Builder {
                builderResult.attrDefault.removeAll(keepingCapacity: false)
                return self
            }
            public var attrRename:Array<Tensorflow.OpGenOverride.Rename> {
                get {
                    return builderResult.attrRename
                }
                set (value) {
                    builderResult.attrRename = value
                }
            }
            @discardableResult
            public func setAttrRename(_ value:Array<Tensorflow.OpGenOverride.Rename>) -> Tensorflow.OpGenOverride.Builder {
                self.attrRename = value
                return self
            }
            @discardableResult
            public func clearAttrRename() -> Tensorflow.OpGenOverride.Builder {
                builderResult.attrRename.removeAll(keepingCapacity: false)
                return self
            }
            public var inputRename:Array<Tensorflow.OpGenOverride.Rename> {
                get {
                    return builderResult.inputRename
                }
                set (value) {
                    builderResult.inputRename = value
                }
            }
            @discardableResult
            public func setInputRename(_ value:Array<Tensorflow.OpGenOverride.Rename>) -> Tensorflow.OpGenOverride.Builder {
                self.inputRename = value
                return self
            }
            @discardableResult
            public func clearInputRename() -> Tensorflow.OpGenOverride.Builder {
                builderResult.inputRename.removeAll(keepingCapacity: false)
                return self
            }
            public var outputRename:Array<Tensorflow.OpGenOverride.Rename> {
                get {
                    return builderResult.outputRename
                }
                set (value) {
                    builderResult.outputRename = value
                }
            }
            @discardableResult
            public func setOutputRename(_ value:Array<Tensorflow.OpGenOverride.Rename>) -> Tensorflow.OpGenOverride.Builder {
                self.outputRename = value
                return self
            }
            @discardableResult
            public func clearOutputRename() -> Tensorflow.OpGenOverride.Builder {
                builderResult.outputRename.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.OpGenOverride.Builder {
                builderResult = Tensorflow.OpGenOverride()
                return self
            }
            override public func clone() throws -> Tensorflow.OpGenOverride.Builder {
                return try Tensorflow.OpGenOverride.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.OpGenOverride {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.OpGenOverride {
                let returnMe:Tensorflow.OpGenOverride = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.OpGenOverride) throws -> Tensorflow.OpGenOverride.Builder {
                if other == Tensorflow.OpGenOverride() {
                    return self
                }
                if other.hasName {
                    name = other.name
                }
                if other.hasSkip {
                    skip = other.skip
                }
                if other.hasHide {
                    hide = other.hide
                }
                if other.hasRenameTo {
                    renameTo = other.renameTo
                }
                if !other.alias.isEmpty {
                    builderResult.alias += other.alias
                }
                if !other.attrDefault.isEmpty  {
                     builderResult.attrDefault += other.attrDefault
                }
                if !other.attrRename.isEmpty  {
                     builderResult.attrRename += other.attrRename
                }
                if !other.inputRename.isEmpty  {
                     builderResult.inputRename += other.inputRename
                }
                if !other.outputRename.isEmpty  {
                     builderResult.outputRename += other.outputRename
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OpGenOverride.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpGenOverride.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        name = try codedInputStream.readString()

                    case 16:
                        skip = try codedInputStream.readBool()

                    case 24:
                        hide = try codedInputStream.readBool()

                    case 34:
                        renameTo = try codedInputStream.readString()

                    case 42:
                        alias += [try codedInputStream.readString()]

                    case 50:
                        let subBuilder = Tensorflow.OpGenOverride.AttrDefault.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        attrDefault.append(subBuilder.buildPartial())

                    case 58:
                        let subBuilder = Tensorflow.OpGenOverride.Rename.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        attrRename.append(subBuilder.buildPartial())

                    case 66:
                        let subBuilder = Tensorflow.OpGenOverride.Rename.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        inputRename.append(subBuilder.buildPartial())

                    case 74:
                        let subBuilder = Tensorflow.OpGenOverride.Rename.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        outputRename.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OpGenOverride.Builder {
                let resultDecodedBuilder = Tensorflow.OpGenOverride.Builder()
                if let jsonValueName = jsonMap["name"] as? String {
                    resultDecodedBuilder.name = jsonValueName
                }
                if let jsonValueSkip = jsonMap["skip"] as? Bool {
                    resultDecodedBuilder.skip = jsonValueSkip
                }
                if let jsonValueHide = jsonMap["hide"] as? Bool {
                    resultDecodedBuilder.hide = jsonValueHide
                }
                if let jsonValueRenameTo = jsonMap["renameTo"] as? String {
                    resultDecodedBuilder.renameTo = jsonValueRenameTo
                }
                if let jsonValueAlias = jsonMap["alias"] as? Array<String> {
                    var jsonArrayAlias:Array<String> = []
                    for oneValueAlias in jsonValueAlias {
                        jsonArrayAlias.append(oneValueAlias)
                    }
                    resultDecodedBuilder.alias = jsonArrayAlias
                }
                if let jsonValueAttrDefault = jsonMap["attrDefault"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayAttrDefault:Array<Tensorflow.OpGenOverride.AttrDefault> = []
                    for oneValueAttrDefault in jsonValueAttrDefault {
                        let messageFromStringAttrDefault = try Tensorflow.OpGenOverride.AttrDefault.Builder.decodeToBuilder(jsonMap:oneValueAttrDefault).build()

                        jsonArrayAttrDefault.append(messageFromStringAttrDefault)
                    }
                    resultDecodedBuilder.attrDefault = jsonArrayAttrDefault
                }
                if let jsonValueAttrRename = jsonMap["attrRename"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayAttrRename:Array<Tensorflow.OpGenOverride.Rename> = []
                    for oneValueAttrRename in jsonValueAttrRename {
                        let messageFromStringAttrRename = try Tensorflow.OpGenOverride.Rename.Builder.decodeToBuilder(jsonMap:oneValueAttrRename).build()

                        jsonArrayAttrRename.append(messageFromStringAttrRename)
                    }
                    resultDecodedBuilder.attrRename = jsonArrayAttrRename
                }
                if let jsonValueInputRename = jsonMap["inputRename"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayInputRename:Array<Tensorflow.OpGenOverride.Rename> = []
                    for oneValueInputRename in jsonValueInputRename {
                        let messageFromStringInputRename = try Tensorflow.OpGenOverride.Rename.Builder.decodeToBuilder(jsonMap:oneValueInputRename).build()

                        jsonArrayInputRename.append(messageFromStringInputRename)
                    }
                    resultDecodedBuilder.inputRename = jsonArrayInputRename
                }
                if let jsonValueOutputRename = jsonMap["outputRename"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayOutputRename:Array<Tensorflow.OpGenOverride.Rename> = []
                    for oneValueOutputRename in jsonValueOutputRename {
                        let messageFromStringOutputRename = try Tensorflow.OpGenOverride.Rename.Builder.decodeToBuilder(jsonMap:oneValueOutputRename).build()

                        jsonArrayOutputRename.append(messageFromStringOutputRename)
                    }
                    resultDecodedBuilder.outputRename = jsonArrayOutputRename
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.OpGenOverride.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.OpGenOverride.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class OpGenOverrides : GeneratedMessage {

        public static func == (lhs: Tensorflow.OpGenOverrides, rhs: Tensorflow.OpGenOverrides) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.op == rhs.op)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var op:Array<Tensorflow.OpGenOverride>  = Array<Tensorflow.OpGenOverride>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementOp in op {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementOp)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementOp in op {
                serialize_size += oneElementOp.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.OpGenOverrides.Builder {
            return Tensorflow.OpGenOverrides.classBuilder() as! Tensorflow.OpGenOverrides.Builder
        }
        public func getBuilder() -> Tensorflow.OpGenOverrides.Builder {
            return classBuilder() as! Tensorflow.OpGenOverrides.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.OpGenOverrides.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.OpGenOverrides.Builder()
        }
        public func toBuilder() throws -> Tensorflow.OpGenOverrides.Builder {
            return try Tensorflow.OpGenOverrides.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.OpGenOverrides) throws -> Tensorflow.OpGenOverrides.Builder {
            return try Tensorflow.OpGenOverrides.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !op.isEmpty {
                var jsonArrayOp:Array<Dictionary<String,Any>> = []
                for oneValueOp in op {
                    let ecodedMessageOp = try oneValueOp.encode()
                    jsonArrayOp.append(ecodedMessageOp)
                }
                jsonMap["op"] = jsonArrayOp
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OpGenOverrides {
            return try Tensorflow.OpGenOverrides.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.OpGenOverrides {
            return try Tensorflow.OpGenOverrides.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var opElementIndex:Int = 0
            for oneElementOp in op {
                output += "\(indent) op[\(opElementIndex)] {\n"
                output += try oneElementOp.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                opElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementOp in op {
                    hashCode = (hashCode &* 31) &+ oneElementOp.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.OpGenOverrides"
        }
        override public func className() -> String {
            return "Tensorflow.OpGenOverrides"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.OpGenOverrides = Tensorflow.OpGenOverrides()
            public func getMessage() -> Tensorflow.OpGenOverrides {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var op:Array<Tensorflow.OpGenOverride> {
                get {
                    return builderResult.op
                }
                set (value) {
                    builderResult.op = value
                }
            }
            @discardableResult
            public func setOp(_ value:Array<Tensorflow.OpGenOverride>) -> Tensorflow.OpGenOverrides.Builder {
                self.op = value
                return self
            }
            @discardableResult
            public func clearOp() -> Tensorflow.OpGenOverrides.Builder {
                builderResult.op.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.OpGenOverrides.Builder {
                builderResult = Tensorflow.OpGenOverrides()
                return self
            }
            override public func clone() throws -> Tensorflow.OpGenOverrides.Builder {
                return try Tensorflow.OpGenOverrides.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.OpGenOverrides {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.OpGenOverrides {
                let returnMe:Tensorflow.OpGenOverrides = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.OpGenOverrides) throws -> Tensorflow.OpGenOverrides.Builder {
                if other == Tensorflow.OpGenOverrides() {
                    return self
                }
                if !other.op.isEmpty  {
                     builderResult.op += other.op
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OpGenOverrides.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpGenOverrides.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Tensorflow.OpGenOverride.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        op.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OpGenOverrides.Builder {
                let resultDecodedBuilder = Tensorflow.OpGenOverrides.Builder()
                if let jsonValueOp = jsonMap["op"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayOp:Array<Tensorflow.OpGenOverride> = []
                    for oneValueOp in jsonValueOp {
                        let messageFromStringOp = try Tensorflow.OpGenOverride.Builder.decodeToBuilder(jsonMap:oneValueOp).build()

                        jsonArrayOp.append(messageFromStringOp)
                    }
                    resultDecodedBuilder.op = jsonArrayOp
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.OpGenOverrides.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.OpGenOverrides.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.OpGenOverride: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.OpGenOverride> {
        var mergedArray = Array<Tensorflow.OpGenOverride>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.OpGenOverride? {
        return try Tensorflow.OpGenOverride.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.OpGenOverride {
        return try Tensorflow.OpGenOverride.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.OpGenOverridesRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpGenOverride {
        return try Tensorflow.OpGenOverride.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.OpGenOverride {
        return try Tensorflow.OpGenOverride.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpGenOverride {
        return try Tensorflow.OpGenOverride.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OpGenOverride {
        return try Tensorflow.OpGenOverride.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpGenOverride {
        return try Tensorflow.OpGenOverride.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "name": return self.name
        case "skip": return self.skip
        case "hide": return self.hide
        case "renameTo": return self.renameTo
        case "alias": return self.alias
        case "attrDefault": return self.attrDefault
        case "attrRename": return self.attrRename
        case "inputRename": return self.inputRename
        case "outputRename": return self.outputRename
        default: return nil
        }
    }
}
extension Tensorflow.OpGenOverride.AttrDefault: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.OpGenOverride.AttrDefault> {
        var mergedArray = Array<Tensorflow.OpGenOverride.AttrDefault>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.OpGenOverride.AttrDefault? {
        return try Tensorflow.OpGenOverride.AttrDefault.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.OpGenOverride.AttrDefault {
        return try Tensorflow.OpGenOverride.AttrDefault.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.OpGenOverridesRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpGenOverride.AttrDefault {
        return try Tensorflow.OpGenOverride.AttrDefault.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.OpGenOverride.AttrDefault {
        return try Tensorflow.OpGenOverride.AttrDefault.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpGenOverride.AttrDefault {
        return try Tensorflow.OpGenOverride.AttrDefault.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OpGenOverride.AttrDefault {
        return try Tensorflow.OpGenOverride.AttrDefault.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpGenOverride.AttrDefault {
        return try Tensorflow.OpGenOverride.AttrDefault.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "name": return self.name
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.OpGenOverride.Rename: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.OpGenOverride.Rename> {
        var mergedArray = Array<Tensorflow.OpGenOverride.Rename>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.OpGenOverride.Rename? {
        return try Tensorflow.OpGenOverride.Rename.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.OpGenOverride.Rename {
        return try Tensorflow.OpGenOverride.Rename.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.OpGenOverridesRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpGenOverride.Rename {
        return try Tensorflow.OpGenOverride.Rename.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.OpGenOverride.Rename {
        return try Tensorflow.OpGenOverride.Rename.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpGenOverride.Rename {
        return try Tensorflow.OpGenOverride.Rename.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OpGenOverride.Rename {
        return try Tensorflow.OpGenOverride.Rename.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpGenOverride.Rename {
        return try Tensorflow.OpGenOverride.Rename.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "from": return self.from
        case "to": return self.to
        default: return nil
        }
    }
}
extension Tensorflow.OpGenOverride.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "name": return self.name
            case "skip": return self.skip
            case "hide": return self.hide
            case "renameTo": return self.renameTo
            case "alias": return self.alias
            case "attrDefault": return self.attrDefault
            case "attrRename": return self.attrRename
            case "inputRename": return self.inputRename
            case "outputRename": return self.outputRename
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "skip":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.skip = newSubscriptValue
            case "hide":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.hide = newSubscriptValue
            case "renameTo":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.renameTo = newSubscriptValue
            case "alias":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.alias = newSubscriptValue
            case "attrDefault":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.OpGenOverride.AttrDefault> else {
                    return
                }
                self.attrDefault = newSubscriptValue
            case "attrRename":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.OpGenOverride.Rename> else {
                    return
                }
                self.attrRename = newSubscriptValue
            case "inputRename":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.OpGenOverride.Rename> else {
                    return
                }
                self.inputRename = newSubscriptValue
            case "outputRename":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.OpGenOverride.Rename> else {
                    return
                }
                self.outputRename = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.OpGenOverride.AttrDefault.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "name": return self.name
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.AttrValue else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.OpGenOverride.Rename.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "from": return self.from
            case "to": return self.to
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "from":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.from = newSubscriptValue
            case "to":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.to = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.OpGenOverrides: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.OpGenOverrides> {
        var mergedArray = Array<Tensorflow.OpGenOverrides>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.OpGenOverrides? {
        return try Tensorflow.OpGenOverrides.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.OpGenOverrides {
        return try Tensorflow.OpGenOverrides.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.OpGenOverridesRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpGenOverrides {
        return try Tensorflow.OpGenOverrides.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.OpGenOverrides {
        return try Tensorflow.OpGenOverrides.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpGenOverrides {
        return try Tensorflow.OpGenOverrides.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OpGenOverrides {
        return try Tensorflow.OpGenOverrides.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpGenOverrides {
        return try Tensorflow.OpGenOverrides.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "op": return self.op
        default: return nil
        }
    }
}
extension Tensorflow.OpGenOverrides.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "op": return self.op
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "op":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.OpGenOverride> else {
                    return
                }
                self.op = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

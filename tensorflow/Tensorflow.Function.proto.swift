/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "function.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { }

public extension Tensorflow {
    public struct FunctionRoot {
        public static let `default` = FunctionRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Tensorflow.AttrValueRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.NodeDefRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.OpDefRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    /// A library is a set of named functions.
    final public class FunctionDefLibrary : GeneratedMessage {

        public static func == (lhs: Tensorflow.FunctionDefLibrary, rhs: Tensorflow.FunctionDefLibrary) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.function == rhs.function)
            fieldCheck = fieldCheck && (lhs.gradient == rhs.gradient)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var function:Array<Tensorflow.FunctionDef>  = Array<Tensorflow.FunctionDef>()
        public fileprivate(set) var gradient:Array<Tensorflow.GradientDef>  = Array<Tensorflow.GradientDef>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementFunction in function {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementFunction)
            }
            for oneElementGradient in gradient {
                  try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementGradient)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementFunction in function {
                serialize_size += oneElementFunction.computeMessageSize(fieldNumber: 1)
            }
            for oneElementGradient in gradient {
                serialize_size += oneElementGradient.computeMessageSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.FunctionDefLibrary.Builder {
            return Tensorflow.FunctionDefLibrary.classBuilder() as! Tensorflow.FunctionDefLibrary.Builder
        }
        public func getBuilder() -> Tensorflow.FunctionDefLibrary.Builder {
            return classBuilder() as! Tensorflow.FunctionDefLibrary.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.FunctionDefLibrary.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.FunctionDefLibrary.Builder()
        }
        public func toBuilder() throws -> Tensorflow.FunctionDefLibrary.Builder {
            return try Tensorflow.FunctionDefLibrary.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.FunctionDefLibrary) throws -> Tensorflow.FunctionDefLibrary.Builder {
            return try Tensorflow.FunctionDefLibrary.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !function.isEmpty {
                var jsonArrayFunction:Array<Dictionary<String,Any>> = []
                for oneValueFunction in function {
                    let ecodedMessageFunction = try oneValueFunction.encode()
                    jsonArrayFunction.append(ecodedMessageFunction)
                }
                jsonMap["function"] = jsonArrayFunction
            }
            if !gradient.isEmpty {
                var jsonArrayGradient:Array<Dictionary<String,Any>> = []
                for oneValueGradient in gradient {
                    let ecodedMessageGradient = try oneValueGradient.encode()
                    jsonArrayGradient.append(ecodedMessageGradient)
                }
                jsonMap["gradient"] = jsonArrayGradient
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.FunctionDefLibrary {
            return try Tensorflow.FunctionDefLibrary.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.FunctionDefLibrary {
            return try Tensorflow.FunctionDefLibrary.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var functionElementIndex:Int = 0
            for oneElementFunction in function {
                output += "\(indent) function[\(functionElementIndex)] {\n"
                output += try oneElementFunction.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                functionElementIndex += 1
            }
            var gradientElementIndex:Int = 0
            for oneElementGradient in gradient {
                output += "\(indent) gradient[\(gradientElementIndex)] {\n"
                output += try oneElementGradient.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                gradientElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementFunction in function {
                    hashCode = (hashCode &* 31) &+ oneElementFunction.hashValue
                }
                for oneElementGradient in gradient {
                    hashCode = (hashCode &* 31) &+ oneElementGradient.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.FunctionDefLibrary"
        }
        override public func className() -> String {
            return "Tensorflow.FunctionDefLibrary"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.FunctionDefLibrary = Tensorflow.FunctionDefLibrary()
            public func getMessage() -> Tensorflow.FunctionDefLibrary {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var function:Array<Tensorflow.FunctionDef> {
                get {
                    return builderResult.function
                }
                set (value) {
                    builderResult.function = value
                }
            }
            @discardableResult
            public func setFunction(_ value:Array<Tensorflow.FunctionDef>) -> Tensorflow.FunctionDefLibrary.Builder {
                self.function = value
                return self
            }
            @discardableResult
            public func clearFunction() -> Tensorflow.FunctionDefLibrary.Builder {
                builderResult.function.removeAll(keepingCapacity: false)
                return self
            }
            public var gradient:Array<Tensorflow.GradientDef> {
                get {
                    return builderResult.gradient
                }
                set (value) {
                    builderResult.gradient = value
                }
            }
            @discardableResult
            public func setGradient(_ value:Array<Tensorflow.GradientDef>) -> Tensorflow.FunctionDefLibrary.Builder {
                self.gradient = value
                return self
            }
            @discardableResult
            public func clearGradient() -> Tensorflow.FunctionDefLibrary.Builder {
                builderResult.gradient.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.FunctionDefLibrary.Builder {
                builderResult = Tensorflow.FunctionDefLibrary()
                return self
            }
            override public func clone() throws -> Tensorflow.FunctionDefLibrary.Builder {
                return try Tensorflow.FunctionDefLibrary.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.FunctionDefLibrary {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.FunctionDefLibrary {
                let returnMe:Tensorflow.FunctionDefLibrary = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.FunctionDefLibrary) throws -> Tensorflow.FunctionDefLibrary.Builder {
                if other == Tensorflow.FunctionDefLibrary() {
                    return self
                }
                if !other.function.isEmpty  {
                     builderResult.function += other.function
                }
                if !other.gradient.isEmpty  {
                     builderResult.gradient += other.gradient
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.FunctionDefLibrary.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FunctionDefLibrary.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Tensorflow.FunctionDef.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        function.append(subBuilder.buildPartial())

                    case 18:
                        let subBuilder = Tensorflow.GradientDef.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        gradient.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.FunctionDefLibrary.Builder {
                let resultDecodedBuilder = Tensorflow.FunctionDefLibrary.Builder()
                if let jsonValueFunction = jsonMap["function"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayFunction:Array<Tensorflow.FunctionDef> = []
                    for oneValueFunction in jsonValueFunction {
                        let messageFromStringFunction = try Tensorflow.FunctionDef.Builder.decodeToBuilder(jsonMap:oneValueFunction).build()

                        jsonArrayFunction.append(messageFromStringFunction)
                    }
                    resultDecodedBuilder.function = jsonArrayFunction
                }
                if let jsonValueGradient = jsonMap["gradient"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayGradient:Array<Tensorflow.GradientDef> = []
                    for oneValueGradient in jsonValueGradient {
                        let messageFromStringGradient = try Tensorflow.GradientDef.Builder.decodeToBuilder(jsonMap:oneValueGradient).build()

                        jsonArrayGradient.append(messageFromStringGradient)
                    }
                    resultDecodedBuilder.gradient = jsonArrayGradient
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.FunctionDefLibrary.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.FunctionDefLibrary.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// A function can be instantiated when the runtime can bind every attr
    /// with a value. When a GraphDef has a call to a function, it must
    /// have binding for every attr defined in the signature.
    /// TODO(zhifengc):
    ///   * device spec, etc.
    final public class FunctionDef : GeneratedMessage {

        public static func == (lhs: Tensorflow.FunctionDef, rhs: Tensorflow.FunctionDef) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasSignature == rhs.hasSignature) && (!lhs.hasSignature || lhs.signature == rhs.signature)
            fieldCheck = fieldCheck && (lhs.nodeDef == rhs.nodeDef)
            fieldCheck = fieldCheck && (lhs.hasRet == rhs.hasRet) && (!lhs.hasRet || lhs.ret == rhs.ret)
            fieldCheck = fieldCheck && (lhs.hasAttr == rhs.hasAttr) && (!lhs.hasAttr || lhs.attr == rhs.attr)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        final public class AttrEntry : GeneratedMessage {

            public static func == (lhs: Tensorflow.FunctionDef.AttrEntry, rhs: Tensorflow.FunctionDef.AttrEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:String = ""
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:Tensorflow.AttrValue!
            public fileprivate(set) var hasValue:Bool = false
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeString(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeMessage(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeStringSize(fieldNumber: 1)
                }
                if hasValue {
                    if let varSizevalue = value?.computeMessageSize(fieldNumber: 2) {
                        serialize_size += varSizevalue
                    }
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.FunctionDef.AttrEntry.Builder {
                return Tensorflow.FunctionDef.AttrEntry.classBuilder() as! Tensorflow.FunctionDef.AttrEntry.Builder
            }
            public func getBuilder() -> Tensorflow.FunctionDef.AttrEntry.Builder {
                return classBuilder() as! Tensorflow.FunctionDef.AttrEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.FunctionDef.AttrEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.FunctionDef.AttrEntry.Builder()
            }
            public func toBuilder() throws -> Tensorflow.FunctionDef.AttrEntry.Builder {
                return try Tensorflow.FunctionDef.AttrEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.FunctionDef.AttrEntry) throws -> Tensorflow.FunctionDef.AttrEntry.Builder {
                return try Tensorflow.FunctionDef.AttrEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = key
                }
                if hasValue {
                    jsonMap["value"] = try value.encode()
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.FunctionDef.AttrEntry {
                return try Tensorflow.FunctionDef.AttrEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.FunctionDef.AttrEntry {
                return try Tensorflow.FunctionDef.AttrEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value {\n"
                    if let outDescValue = value {
                        output += try outDescValue.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        if let hashValuevalue = value?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuevalue
                        }
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.FunctionDef.AttrEntry"
            }
            override public func className() -> String {
                return "Tensorflow.FunctionDef.AttrEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.FunctionDef.AttrEntry = Tensorflow.FunctionDef.AttrEntry()
                public func getMessage() -> Tensorflow.FunctionDef.AttrEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:String {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:String) -> Tensorflow.FunctionDef.AttrEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> Tensorflow.FunctionDef.AttrEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = ""
                    return self
                }
                public var value:Tensorflow.AttrValue! {
                    get {
                        if valueBuilder_ != nil {
                            builderResult.value = valueBuilder_.getMessage()
                        }
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                fileprivate var valueBuilder_:Tensorflow.AttrValue.Builder! {
                    didSet {
                        builderResult.hasValue = true
                    }
                }
                public func getValueBuilder() -> Tensorflow.AttrValue.Builder {
                    if valueBuilder_ == nil {
                        valueBuilder_ = Tensorflow.AttrValue.Builder()
                        builderResult.value = valueBuilder_.getMessage()
                        if value != nil {
                            try! valueBuilder_.mergeFrom(other: value)
                        }
                    }
                    return valueBuilder_
                }
                @discardableResult
                public func setValue(_ value:Tensorflow.AttrValue!) -> Tensorflow.FunctionDef.AttrEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func mergeValue(value:Tensorflow.AttrValue) throws -> Tensorflow.FunctionDef.AttrEntry.Builder {
                    if builderResult.hasValue {
                        builderResult.value = try Tensorflow.AttrValue.builderWithPrototype(prototype:builderResult.value).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.value = value
                    }
                    builderResult.hasValue = true
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.FunctionDef.AttrEntry.Builder {
                    valueBuilder_ = nil
                    builderResult.hasValue = false
                    builderResult.value = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.FunctionDef.AttrEntry.Builder {
                    builderResult = Tensorflow.FunctionDef.AttrEntry()
                    return self
                }
                override public func clone() throws -> Tensorflow.FunctionDef.AttrEntry.Builder {
                    return try Tensorflow.FunctionDef.AttrEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.FunctionDef.AttrEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.FunctionDef.AttrEntry {
                    let returnMe:Tensorflow.FunctionDef.AttrEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.FunctionDef.AttrEntry) throws -> Tensorflow.FunctionDef.AttrEntry.Builder {
                    if other == Tensorflow.FunctionDef.AttrEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if (other.hasValue) {
                        try mergeValue(value: other.value)
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.FunctionDef.AttrEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FunctionDef.AttrEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            key = try codedInputStream.readString()

                        case 18:
                            let subBuilder:Tensorflow.AttrValue.Builder = Tensorflow.AttrValue.Builder()
                            if hasValue {
                                try subBuilder.mergeFrom(other: value)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            value = subBuilder.buildPartial()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.FunctionDef.AttrEntry.Builder {
                    let resultDecodedBuilder = Tensorflow.FunctionDef.AttrEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = jsonValueKey
                    }
                    if let jsonValueValue = jsonMap["value"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.value = try Tensorflow.AttrValue.Builder.decodeToBuilder(jsonMap:jsonValueValue).build()

                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.FunctionDef.AttrEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.FunctionDef.AttrEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        final public class RetEntry : GeneratedMessage {

            public static func == (lhs: Tensorflow.FunctionDef.RetEntry, rhs: Tensorflow.FunctionDef.RetEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:String = ""
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:String = ""
            public fileprivate(set) var hasValue:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeString(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeString(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeStringSize(fieldNumber: 1)
                }
                if hasValue {
                    serialize_size += value.computeStringSize(fieldNumber: 2)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.FunctionDef.RetEntry.Builder {
                return Tensorflow.FunctionDef.RetEntry.classBuilder() as! Tensorflow.FunctionDef.RetEntry.Builder
            }
            public func getBuilder() -> Tensorflow.FunctionDef.RetEntry.Builder {
                return classBuilder() as! Tensorflow.FunctionDef.RetEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.FunctionDef.RetEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.FunctionDef.RetEntry.Builder()
            }
            public func toBuilder() throws -> Tensorflow.FunctionDef.RetEntry.Builder {
                return try Tensorflow.FunctionDef.RetEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.FunctionDef.RetEntry) throws -> Tensorflow.FunctionDef.RetEntry.Builder {
                return try Tensorflow.FunctionDef.RetEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = key
                }
                if hasValue {
                    jsonMap["value"] = value
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.FunctionDef.RetEntry {
                return try Tensorflow.FunctionDef.RetEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.FunctionDef.RetEntry {
                return try Tensorflow.FunctionDef.RetEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value: \(value) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        hashCode = (hashCode &* 31) &+ value.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.FunctionDef.RetEntry"
            }
            override public func className() -> String {
                return "Tensorflow.FunctionDef.RetEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.FunctionDef.RetEntry = Tensorflow.FunctionDef.RetEntry()
                public func getMessage() -> Tensorflow.FunctionDef.RetEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:String {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:String) -> Tensorflow.FunctionDef.RetEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> Tensorflow.FunctionDef.RetEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = ""
                    return self
                }
                public var value:String {
                    get {
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                @discardableResult
                public func setValue(_ value:String) -> Tensorflow.FunctionDef.RetEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.FunctionDef.RetEntry.Builder{
                    builderResult.hasValue = false
                    builderResult.value = ""
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.FunctionDef.RetEntry.Builder {
                    builderResult = Tensorflow.FunctionDef.RetEntry()
                    return self
                }
                override public func clone() throws -> Tensorflow.FunctionDef.RetEntry.Builder {
                    return try Tensorflow.FunctionDef.RetEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.FunctionDef.RetEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.FunctionDef.RetEntry {
                    let returnMe:Tensorflow.FunctionDef.RetEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.FunctionDef.RetEntry) throws -> Tensorflow.FunctionDef.RetEntry.Builder {
                    if other == Tensorflow.FunctionDef.RetEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if other.hasValue {
                        value = other.value
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.FunctionDef.RetEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FunctionDef.RetEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            key = try codedInputStream.readString()

                        case 18:
                            value = try codedInputStream.readString()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.FunctionDef.RetEntry.Builder {
                    let resultDecodedBuilder = Tensorflow.FunctionDef.RetEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = jsonValueKey
                    }
                    if let jsonValueValue = jsonMap["value"] as? String {
                        resultDecodedBuilder.value = jsonValueValue
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.FunctionDef.RetEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.FunctionDef.RetEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        public fileprivate(set) var signature:Tensorflow.OpDef!
        public fileprivate(set) var hasSignature:Bool = false
        /// Attributes specific to this function definition.
        public fileprivate(set) var attr:Dictionary<String,Tensorflow.AttrValue> = Dictionary<String,Tensorflow.AttrValue>()

        public fileprivate(set) var hasAttr:Bool = false
        public fileprivate(set) var nodeDef:Array<Tensorflow.NodeDef>  = Array<Tensorflow.NodeDef>()
        /// A mapping from the output arg names from `signature` to the
        /// outputs from `node_def` that should be returned by the function.
        public fileprivate(set) var ret:Dictionary<String,String> = Dictionary<String,String>()

        public fileprivate(set) var hasRet:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasSignature {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:signature)
            }
            for oneElementNodeDef in nodeDef {
                  try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementNodeDef)
            }
            if hasRet {
                for (keyRet, valueRet) in ret {
                    let valueOfRet = try! Tensorflow.FunctionDef.RetEntry.Builder().setKey(keyRet).setValue(valueRet).build()
                      try codedOutputStream.writeMessage(fieldNumber: 4, value:valueOfRet)
                  }
            }
            if hasAttr {
                for (keyAttr, valueAttr) in attr {
                    let valueOfAttr = try! Tensorflow.FunctionDef.AttrEntry.Builder().setKey(keyAttr).setValue(valueAttr).build()
                      try codedOutputStream.writeMessage(fieldNumber: 5, value:valueOfAttr)
                  }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasSignature {
                if let varSizesignature = signature?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizesignature
                }
            }
            for oneElementNodeDef in nodeDef {
                serialize_size += oneElementNodeDef.computeMessageSize(fieldNumber: 3)
            }
            if hasRet {
                  for (keyRet, valueRet) in ret {
                      let valueOfRet = try! Tensorflow.FunctionDef.RetEntry.Builder().setKey(keyRet).setValue(valueRet).build()
                serialize_size += valueOfRet.computeMessageSize(fieldNumber: 4)
                }
            }
            if hasAttr {
                  for (keyAttr, valueAttr) in attr {
                      let valueOfAttr = try! Tensorflow.FunctionDef.AttrEntry.Builder().setKey(keyAttr).setValue(valueAttr).build()
                serialize_size += valueOfAttr.computeMessageSize(fieldNumber: 5)
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.FunctionDef.Builder {
            return Tensorflow.FunctionDef.classBuilder() as! Tensorflow.FunctionDef.Builder
        }
        public func getBuilder() -> Tensorflow.FunctionDef.Builder {
            return classBuilder() as! Tensorflow.FunctionDef.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.FunctionDef.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.FunctionDef.Builder()
        }
        public func toBuilder() throws -> Tensorflow.FunctionDef.Builder {
            return try Tensorflow.FunctionDef.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.FunctionDef) throws -> Tensorflow.FunctionDef.Builder {
            return try Tensorflow.FunctionDef.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasSignature {
                jsonMap["signature"] = try signature.encode()
            }
            if hasAttr {
                var mapAttr = Dictionary<String, Dictionary<String,Any>>()
                for (keyAttr, valueAttr) in attr {
                    mapAttr["\(keyAttr)"] = try valueAttr.encode()
                }
                jsonMap["attr"] = mapAttr
            }
            if !nodeDef.isEmpty {
                var jsonArrayNodeDef:Array<Dictionary<String,Any>> = []
                for oneValueNodeDef in nodeDef {
                    let ecodedMessageNodeDef = try oneValueNodeDef.encode()
                    jsonArrayNodeDef.append(ecodedMessageNodeDef)
                }
                jsonMap["nodeDef"] = jsonArrayNodeDef
            }
            if hasRet {
                var mapRet = Dictionary<String, String>()
                for (keyRet, valueRet) in ret {
                    mapRet["\(keyRet)"] = valueRet
                }
                jsonMap["ret"] = mapRet
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.FunctionDef {
            return try Tensorflow.FunctionDef.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.FunctionDef {
            return try Tensorflow.FunctionDef.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasSignature {
                output += "\(indent) signature {\n"
                if let outDescSignature = signature {
                    output += try outDescSignature.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            var nodeDefElementIndex:Int = 0
            for oneElementNodeDef in nodeDef {
                output += "\(indent) nodeDef[\(nodeDefElementIndex)] {\n"
                output += try oneElementNodeDef.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                nodeDefElementIndex += 1
            }
            if hasRet {
                output += "\(indent) ret: \(ret) \n"
            }
            if hasAttr {
                output += "\(indent) attr: \(attr) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasSignature {
                    if let hashValuesignature = signature?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuesignature
                    }
                }
                for oneElementNodeDef in nodeDef {
                    hashCode = (hashCode &* 31) &+ oneElementNodeDef.hashValue
                }
                if hasRet {
                    for (keyRet, valueRet) in ret {
                        hashCode = (hashCode &* 31) &+ keyRet.hashValue
                        hashCode = (hashCode &* 31) &+ valueRet.hashValue
                    }
                }
                if hasAttr {
                    for (keyAttr, valueAttr) in attr {
                        hashCode = (hashCode &* 31) &+ keyAttr.hashValue
                        hashCode = (hashCode &* 31) &+ valueAttr.hashValue
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.FunctionDef"
        }
        override public func className() -> String {
            return "Tensorflow.FunctionDef"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.FunctionDef = Tensorflow.FunctionDef()
            public func getMessage() -> Tensorflow.FunctionDef {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The definition of the function's name, arguments, return values,
            /// attrs etc.
            public var signature:Tensorflow.OpDef! {
                get {
                    if signatureBuilder_ != nil {
                        builderResult.signature = signatureBuilder_.getMessage()
                    }
                    return builderResult.signature
                }
                set (value) {
                    builderResult.hasSignature = true
                    builderResult.signature = value
                }
            }
            public var hasSignature:Bool {
                get {
                    return builderResult.hasSignature
                }
            }
            fileprivate var signatureBuilder_:Tensorflow.OpDef.Builder! {
                didSet {
                    builderResult.hasSignature = true
                }
            }
            public func getSignatureBuilder() -> Tensorflow.OpDef.Builder {
                if signatureBuilder_ == nil {
                    signatureBuilder_ = Tensorflow.OpDef.Builder()
                    builderResult.signature = signatureBuilder_.getMessage()
                    if signature != nil {
                        try! signatureBuilder_.mergeFrom(other: signature)
                    }
                }
                return signatureBuilder_
            }
            @discardableResult
            public func setSignature(_ value:Tensorflow.OpDef!) -> Tensorflow.FunctionDef.Builder {
                self.signature = value
                return self
            }
            @discardableResult
            public func mergeSignature(value:Tensorflow.OpDef) throws -> Tensorflow.FunctionDef.Builder {
                if builderResult.hasSignature {
                    builderResult.signature = try Tensorflow.OpDef.builderWithPrototype(prototype:builderResult.signature).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.signature = value
                }
                builderResult.hasSignature = true
                return self
            }
            @discardableResult
            public func clearSignature() -> Tensorflow.FunctionDef.Builder {
                signatureBuilder_ = nil
                builderResult.hasSignature = false
                builderResult.signature = nil
                return self
            }
            /// Attributes specific to this function definition.
            public var hasAttr:Bool {
                get {
                    return builderResult.hasAttr
                }
            }
            public var attr:Dictionary<String,Tensorflow.AttrValue> {
                get {
                    return builderResult.attr
                }
                set (value) {
                    builderResult.hasAttr = true
                    builderResult.attr = value
                }
            }
            @discardableResult
            public func setAttr(_ value:Dictionary<String,Tensorflow.AttrValue>) -> Tensorflow.FunctionDef.Builder {
                self.attr = value
                return self
            }
            @discardableResult
            public func clearAttr() -> Tensorflow.FunctionDef.Builder{
                builderResult.hasAttr = false
                builderResult.attr = Dictionary<String,Tensorflow.AttrValue>()
                return self
            }
            /// By convention, "op" in node_def is resolved by consulting with a
            /// user-defined library first. If not resolved, "func" is assumed to
            /// be a builtin op.
            public var nodeDef:Array<Tensorflow.NodeDef> {
                get {
                    return builderResult.nodeDef
                }
                set (value) {
                    builderResult.nodeDef = value
                }
            }
            @discardableResult
            public func setNodeDef(_ value:Array<Tensorflow.NodeDef>) -> Tensorflow.FunctionDef.Builder {
                self.nodeDef = value
                return self
            }
            @discardableResult
            public func clearNodeDef() -> Tensorflow.FunctionDef.Builder {
                builderResult.nodeDef.removeAll(keepingCapacity: false)
                return self
            }
            /// A mapping from the output arg names from `signature` to the
            /// outputs from `node_def` that should be returned by the function.
            public var hasRet:Bool {
                get {
                    return builderResult.hasRet
                }
            }
            public var ret:Dictionary<String,String> {
                get {
                    return builderResult.ret
                }
                set (value) {
                    builderResult.hasRet = true
                    builderResult.ret = value
                }
            }
            @discardableResult
            public func setRet(_ value:Dictionary<String,String>) -> Tensorflow.FunctionDef.Builder {
                self.ret = value
                return self
            }
            @discardableResult
            public func clearRet() -> Tensorflow.FunctionDef.Builder{
                builderResult.hasRet = false
                builderResult.ret = Dictionary<String,String>()
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.FunctionDef.Builder {
                builderResult = Tensorflow.FunctionDef()
                return self
            }
            override public func clone() throws -> Tensorflow.FunctionDef.Builder {
                return try Tensorflow.FunctionDef.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.FunctionDef {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.FunctionDef {
                let returnMe:Tensorflow.FunctionDef = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.FunctionDef) throws -> Tensorflow.FunctionDef.Builder {
                if other == Tensorflow.FunctionDef() {
                    return self
                }
                if (other.hasSignature) {
                    try mergeSignature(value: other.signature)
                }
                if other.hasAttr {
                    attr = other.attr
                }
                if !other.nodeDef.isEmpty  {
                     builderResult.nodeDef += other.nodeDef
                }
                if other.hasRet {
                    ret = other.ret
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.FunctionDef.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FunctionDef.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Tensorflow.OpDef.Builder = Tensorflow.OpDef.Builder()
                        if hasSignature {
                            try subBuilder.mergeFrom(other: signature)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        signature = subBuilder.buildPartial()

                    case 26:
                        let subBuilder = Tensorflow.NodeDef.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        nodeDef.append(subBuilder.buildPartial())

                    case 34:
                        let subBuilder = Tensorflow.FunctionDef.RetEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfRet = subBuilder.buildPartial()
                        ret[buildOfRet.key] = buildOfRet.value

                    case 42:
                        let subBuilder = Tensorflow.FunctionDef.AttrEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfAttr = subBuilder.buildPartial()
                        attr[buildOfAttr.key] = buildOfAttr.value

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.FunctionDef.Builder {
                let resultDecodedBuilder = Tensorflow.FunctionDef.Builder()
                if let jsonValueSignature = jsonMap["signature"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.signature = try Tensorflow.OpDef.Builder.decodeToBuilder(jsonMap:jsonValueSignature).build()

                }
                if let jsonValueAttr = jsonMap["attr"] as? Dictionary<String, Dictionary<String,Any>> {
                    var mapAttr = Dictionary<String, Tensorflow.AttrValue>()
                    for (keyAttr, valueAttr) in jsonValueAttr {
                        guard let keyFromAttr = String(keyAttr) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapAttr[keyFromAttr] = try Tensorflow.AttrValue.Builder.decodeToBuilder(jsonMap:valueAttr).build()

                    }
                    resultDecodedBuilder.attr = mapAttr
                }
                if let jsonValueNodeDef = jsonMap["nodeDef"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayNodeDef:Array<Tensorflow.NodeDef> = []
                    for oneValueNodeDef in jsonValueNodeDef {
                        let messageFromStringNodeDef = try Tensorflow.NodeDef.Builder.decodeToBuilder(jsonMap:oneValueNodeDef).build()

                        jsonArrayNodeDef.append(messageFromStringNodeDef)
                    }
                    resultDecodedBuilder.nodeDef = jsonArrayNodeDef
                }
                if let jsonValueRet = jsonMap["ret"] as? Dictionary<String, String> {
                    var mapRet = Dictionary<String, String>()
                    for (keyRet, valueRet) in jsonValueRet {
                        guard let keyFromRet = String(keyRet) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapRet[keyFromRet] = valueRet
                    }
                    resultDecodedBuilder.ret = mapRet
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.FunctionDef.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.FunctionDef.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// GradientDef defines the gradient function of a function defined in
    /// a function library.
    /// A gradient function g (specified by gradient_func) for a function f
    /// (specified by function_name) must follow the following:
    /// The function 'f' must be a numerical function which takes N inputs
    /// and produces M outputs. Its gradient function 'g', which is a
    /// function taking N + M inputs and produces N outputs.
    /// I.e. if we have
    ///    (y1, y2, ..., y_M) = f(x1, x2, ..., x_N),
    /// then, g is
    ///    (dL/dx1, dL/dx2, ..., dL/dx_N) = g(x1, x2, ..., x_N,
    ///                                      dL/dy1, dL/dy2, ..., dL/dy_M),
    /// where L is a scalar-value function of (x1, x2, ..., xN) (e.g., the
    /// loss function). dL/dx_i is the partial derivative of L with respect
    /// to x_i.
    final public class GradientDef : GeneratedMessage {

        public static func == (lhs: Tensorflow.GradientDef, rhs: Tensorflow.GradientDef) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasFunctionName == rhs.hasFunctionName) && (!lhs.hasFunctionName || lhs.functionName == rhs.functionName)
            fieldCheck = fieldCheck && (lhs.hasGradientFunc == rhs.hasGradientFunc) && (!lhs.hasGradientFunc || lhs.gradientFunc == rhs.gradientFunc)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// The function name.
        public fileprivate(set) var functionName:String = ""
        public fileprivate(set) var hasFunctionName:Bool = false

        /// The gradient function's name.
        public fileprivate(set) var gradientFunc:String = ""
        public fileprivate(set) var hasGradientFunc:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasFunctionName {
                try codedOutputStream.writeString(fieldNumber: 1, value:functionName)
            }
            if hasGradientFunc {
                try codedOutputStream.writeString(fieldNumber: 2, value:gradientFunc)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasFunctionName {
                serialize_size += functionName.computeStringSize(fieldNumber: 1)
            }
            if hasGradientFunc {
                serialize_size += gradientFunc.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.GradientDef.Builder {
            return Tensorflow.GradientDef.classBuilder() as! Tensorflow.GradientDef.Builder
        }
        public func getBuilder() -> Tensorflow.GradientDef.Builder {
            return classBuilder() as! Tensorflow.GradientDef.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.GradientDef.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.GradientDef.Builder()
        }
        public func toBuilder() throws -> Tensorflow.GradientDef.Builder {
            return try Tensorflow.GradientDef.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.GradientDef) throws -> Tensorflow.GradientDef.Builder {
            return try Tensorflow.GradientDef.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasFunctionName {
                jsonMap["functionName"] = functionName
            }
            if hasGradientFunc {
                jsonMap["gradientFunc"] = gradientFunc
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.GradientDef {
            return try Tensorflow.GradientDef.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.GradientDef {
            return try Tensorflow.GradientDef.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasFunctionName {
                output += "\(indent) functionName: \(functionName) \n"
            }
            if hasGradientFunc {
                output += "\(indent) gradientFunc: \(gradientFunc) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasFunctionName {
                    hashCode = (hashCode &* 31) &+ functionName.hashValue
                }
                if hasGradientFunc {
                    hashCode = (hashCode &* 31) &+ gradientFunc.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.GradientDef"
        }
        override public func className() -> String {
            return "Tensorflow.GradientDef"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.GradientDef = Tensorflow.GradientDef()
            public func getMessage() -> Tensorflow.GradientDef {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The function name.
            public var functionName:String {
                get {
                    return builderResult.functionName
                }
                set (value) {
                    builderResult.hasFunctionName = true
                    builderResult.functionName = value
                }
            }
            public var hasFunctionName:Bool {
                get {
                    return builderResult.hasFunctionName
                }
            }
            @discardableResult
            public func setFunctionName(_ value:String) -> Tensorflow.GradientDef.Builder {
                self.functionName = value
                return self
            }
            @discardableResult
            public func clearFunctionName() -> Tensorflow.GradientDef.Builder{
                builderResult.hasFunctionName = false
                builderResult.functionName = ""
                return self
            }
            /// The gradient function's name.
            public var gradientFunc:String {
                get {
                    return builderResult.gradientFunc
                }
                set (value) {
                    builderResult.hasGradientFunc = true
                    builderResult.gradientFunc = value
                }
            }
            public var hasGradientFunc:Bool {
                get {
                    return builderResult.hasGradientFunc
                }
            }
            @discardableResult
            public func setGradientFunc(_ value:String) -> Tensorflow.GradientDef.Builder {
                self.gradientFunc = value
                return self
            }
            @discardableResult
            public func clearGradientFunc() -> Tensorflow.GradientDef.Builder{
                builderResult.hasGradientFunc = false
                builderResult.gradientFunc = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.GradientDef.Builder {
                builderResult = Tensorflow.GradientDef()
                return self
            }
            override public func clone() throws -> Tensorflow.GradientDef.Builder {
                return try Tensorflow.GradientDef.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.GradientDef {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.GradientDef {
                let returnMe:Tensorflow.GradientDef = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.GradientDef) throws -> Tensorflow.GradientDef.Builder {
                if other == Tensorflow.GradientDef() {
                    return self
                }
                if other.hasFunctionName {
                    functionName = other.functionName
                }
                if other.hasGradientFunc {
                    gradientFunc = other.gradientFunc
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.GradientDef.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GradientDef.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        functionName = try codedInputStream.readString()

                    case 18:
                        gradientFunc = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.GradientDef.Builder {
                let resultDecodedBuilder = Tensorflow.GradientDef.Builder()
                if let jsonValueFunctionName = jsonMap["functionName"] as? String {
                    resultDecodedBuilder.functionName = jsonValueFunctionName
                }
                if let jsonValueGradientFunc = jsonMap["gradientFunc"] as? String {
                    resultDecodedBuilder.gradientFunc = jsonValueGradientFunc
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.GradientDef.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.GradientDef.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.FunctionDefLibrary: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.FunctionDefLibrary> {
        var mergedArray = Array<Tensorflow.FunctionDefLibrary>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.FunctionDefLibrary? {
        return try Tensorflow.FunctionDefLibrary.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.FunctionDefLibrary {
        return try Tensorflow.FunctionDefLibrary.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.FunctionRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FunctionDefLibrary {
        return try Tensorflow.FunctionDefLibrary.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.FunctionDefLibrary {
        return try Tensorflow.FunctionDefLibrary.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FunctionDefLibrary {
        return try Tensorflow.FunctionDefLibrary.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.FunctionDefLibrary {
        return try Tensorflow.FunctionDefLibrary.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FunctionDefLibrary {
        return try Tensorflow.FunctionDefLibrary.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "function": return self.function
        case "gradient": return self.gradient
        default: return nil
        }
    }
}
extension Tensorflow.FunctionDefLibrary.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "function": return self.function
            case "gradient": return self.gradient
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "function":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.FunctionDef> else {
                    return
                }
                self.function = newSubscriptValue
            case "gradient":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.GradientDef> else {
                    return
                }
                self.gradient = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.FunctionDef: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.FunctionDef> {
        var mergedArray = Array<Tensorflow.FunctionDef>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.FunctionDef? {
        return try Tensorflow.FunctionDef.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.FunctionDef {
        return try Tensorflow.FunctionDef.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.FunctionRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FunctionDef {
        return try Tensorflow.FunctionDef.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.FunctionDef {
        return try Tensorflow.FunctionDef.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FunctionDef {
        return try Tensorflow.FunctionDef.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.FunctionDef {
        return try Tensorflow.FunctionDef.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FunctionDef {
        return try Tensorflow.FunctionDef.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "signature": return self.signature
        case "attr": return self.attr
        case "nodeDef": return self.nodeDef
        case "ret": return self.ret
        default: return nil
        }
    }
}
extension Tensorflow.FunctionDef.AttrEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.FunctionDef.AttrEntry> {
        var mergedArray = Array<Tensorflow.FunctionDef.AttrEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.FunctionDef.AttrEntry? {
        return try Tensorflow.FunctionDef.AttrEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.FunctionDef.AttrEntry {
        return try Tensorflow.FunctionDef.AttrEntry.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.FunctionRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FunctionDef.AttrEntry {
        return try Tensorflow.FunctionDef.AttrEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.FunctionDef.AttrEntry {
        return try Tensorflow.FunctionDef.AttrEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FunctionDef.AttrEntry {
        return try Tensorflow.FunctionDef.AttrEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.FunctionDef.AttrEntry {
        return try Tensorflow.FunctionDef.AttrEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FunctionDef.AttrEntry {
        return try Tensorflow.FunctionDef.AttrEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.FunctionDef.RetEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.FunctionDef.RetEntry> {
        var mergedArray = Array<Tensorflow.FunctionDef.RetEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.FunctionDef.RetEntry? {
        return try Tensorflow.FunctionDef.RetEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.FunctionDef.RetEntry {
        return try Tensorflow.FunctionDef.RetEntry.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.FunctionRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FunctionDef.RetEntry {
        return try Tensorflow.FunctionDef.RetEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.FunctionDef.RetEntry {
        return try Tensorflow.FunctionDef.RetEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FunctionDef.RetEntry {
        return try Tensorflow.FunctionDef.RetEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.FunctionDef.RetEntry {
        return try Tensorflow.FunctionDef.RetEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FunctionDef.RetEntry {
        return try Tensorflow.FunctionDef.RetEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.FunctionDef.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "signature": return self.signature
            case "attr": return self.attr
            case "nodeDef": return self.nodeDef
            case "ret": return self.ret
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "signature":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.OpDef else {
                    return
                }
                self.signature = newSubscriptValue
            case "attr":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,Tensorflow.AttrValue> else {
                    return
                }
                self.attr = newSubscriptValue
            case "nodeDef":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.NodeDef> else {
                    return
                }
                self.nodeDef = newSubscriptValue
            case "ret":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,String> else {
                    return
                }
                self.ret = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.FunctionDef.AttrEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.AttrValue else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.FunctionDef.RetEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.GradientDef: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.GradientDef> {
        var mergedArray = Array<Tensorflow.GradientDef>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.GradientDef? {
        return try Tensorflow.GradientDef.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.GradientDef {
        return try Tensorflow.GradientDef.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.FunctionRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GradientDef {
        return try Tensorflow.GradientDef.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.GradientDef {
        return try Tensorflow.GradientDef.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GradientDef {
        return try Tensorflow.GradientDef.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.GradientDef {
        return try Tensorflow.GradientDef.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GradientDef {
        return try Tensorflow.GradientDef.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "functionName": return self.functionName
        case "gradientFunc": return self.gradientFunc
        default: return nil
        }
    }
}
extension Tensorflow.GradientDef.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "functionName": return self.functionName
            case "gradientFunc": return self.gradientFunc
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "functionName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.functionName = newSubscriptValue
            case "gradientFunc":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.gradientFunc = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "test_log.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { }

public extension Tensorflow {
    public struct TestLogRoot {
        public static let `default` = TestLogRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Google.Protobuf.AnyRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    final public class EntryValue : GeneratedMessage {

        public static func == (lhs: Tensorflow.EntryValue, rhs: Tensorflow.EntryValue) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasDoubleValue == rhs.hasDoubleValue) && (!lhs.hasDoubleValue || lhs.doubleValue == rhs.doubleValue)
            fieldCheck = fieldCheck && (lhs.hasStringValue == rhs.hasStringValue) && (!lhs.hasStringValue || lhs.stringValue == rhs.stringValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //OneOf declaration start

        public enum Kind {
            case OneOfKindNotSet

            public func checkOneOfIsSet() -> Bool {
                switch self {
                case .OneOfKindNotSet: return false
                default: return true
                }
            }
            case DoubleValue(Double)

            public static func getDoubleValue(_ value:Kind) -> Double? {
                switch value {
                case .DoubleValue(let enumValue): return enumValue
                default: return nil
                }
            }
            case StringValue(String)

            public static func getStringValue(_ value:Kind) -> String? {
                switch value {
                case .StringValue(let enumValue): return enumValue
                default: return nil
                }
            }
        }
        //OneOf declaration end

        fileprivate var storageKind:EntryValue.Kind =  EntryValue.Kind.OneOfKindNotSet
        public func getOneOfKind() ->  EntryValue.Kind {
            let copyObjectKind = storageKind
            return copyObjectKind
        }
        public fileprivate(set) var doubleValue:Double!{
            get {
                return EntryValue.Kind.getDoubleValue(storageKind)
            }
            set (newvalue) {
                storageKind = EntryValue.Kind.DoubleValue(newvalue)
            }
        }
        public fileprivate(set) var hasDoubleValue:Bool {
            get {
                guard let _ = EntryValue.Kind.getDoubleValue(storageKind) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var stringValue:String!{
            get {
                return EntryValue.Kind.getStringValue(storageKind)
            }
            set (newvalue) {
                storageKind = EntryValue.Kind.StringValue(newvalue)
            }
        }
        public fileprivate(set) var hasStringValue:Bool {
            get {
                guard let _ = EntryValue.Kind.getStringValue(storageKind) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasDoubleValue {
                try codedOutputStream.writeDouble(fieldNumber: 1, value:doubleValue)
            }
            if hasStringValue {
                try codedOutputStream.writeString(fieldNumber: 2, value:stringValue)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasDoubleValue {
                serialize_size += doubleValue.computeDoubleSize(fieldNumber: 1)
            }
            if hasStringValue {
                serialize_size += stringValue.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.EntryValue.Builder {
            return Tensorflow.EntryValue.classBuilder() as! Tensorflow.EntryValue.Builder
        }
        public func getBuilder() -> Tensorflow.EntryValue.Builder {
            return classBuilder() as! Tensorflow.EntryValue.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.EntryValue.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.EntryValue.Builder()
        }
        public func toBuilder() throws -> Tensorflow.EntryValue.Builder {
            return try Tensorflow.EntryValue.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.EntryValue) throws -> Tensorflow.EntryValue.Builder {
            return try Tensorflow.EntryValue.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasDoubleValue {
                jsonMap["doubleValue"] = Double(doubleValue)
            }
            if hasStringValue {
                jsonMap["stringValue"] = stringValue
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.EntryValue {
            return try Tensorflow.EntryValue.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.EntryValue {
            return try Tensorflow.EntryValue.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasDoubleValue {
                output += "\(indent) doubleValue: \(doubleValue) \n"
            }
            if hasStringValue {
                output += "\(indent) stringValue: \(stringValue) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasDoubleValue {
                    hashCode = (hashCode &* 31) &+ doubleValue.hashValue
                }
                if hasStringValue {
                    hashCode = (hashCode &* 31) &+ stringValue.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.EntryValue"
        }
        override public func className() -> String {
            return "Tensorflow.EntryValue"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.EntryValue = Tensorflow.EntryValue()
            public func getMessage() -> Tensorflow.EntryValue {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var doubleValue:Double {
                get {
                    return builderResult.doubleValue
                }
                set (value) {
                    builderResult.hasDoubleValue = true
                    builderResult.doubleValue = value
                }
            }
            public var hasDoubleValue:Bool {
                get {
                    return builderResult.hasDoubleValue
                }
            }
            @discardableResult
            public func setDoubleValue(_ value:Double) -> Tensorflow.EntryValue.Builder {
                self.doubleValue = value
                return self
            }
            @discardableResult
            public func clearDoubleValue() -> Tensorflow.EntryValue.Builder{
                builderResult.hasDoubleValue = false
                builderResult.doubleValue = Double(0)
                return self
            }
            public var stringValue:String {
                get {
                    return builderResult.stringValue
                }
                set (value) {
                    builderResult.hasStringValue = true
                    builderResult.stringValue = value
                }
            }
            public var hasStringValue:Bool {
                get {
                    return builderResult.hasStringValue
                }
            }
            @discardableResult
            public func setStringValue(_ value:String) -> Tensorflow.EntryValue.Builder {
                self.stringValue = value
                return self
            }
            @discardableResult
            public func clearStringValue() -> Tensorflow.EntryValue.Builder{
                builderResult.hasStringValue = false
                builderResult.stringValue = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.EntryValue.Builder {
                builderResult = Tensorflow.EntryValue()
                return self
            }
            override public func clone() throws -> Tensorflow.EntryValue.Builder {
                return try Tensorflow.EntryValue.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.EntryValue {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.EntryValue {
                let returnMe:Tensorflow.EntryValue = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.EntryValue) throws -> Tensorflow.EntryValue.Builder {
                if other == Tensorflow.EntryValue() {
                    return self
                }
                if other.hasDoubleValue {
                    doubleValue = other.doubleValue
                }
                if other.hasStringValue {
                    stringValue = other.stringValue
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.EntryValue.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.EntryValue.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 9:
                        doubleValue = try codedInputStream.readDouble()

                    case 18:
                        stringValue = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.EntryValue.Builder {
                let resultDecodedBuilder = Tensorflow.EntryValue.Builder()
                if let jsonValueDoubleValue = jsonMap["doubleValue"] as? Double {
                    resultDecodedBuilder.doubleValue = Double(jsonValueDoubleValue)
                } else if let jsonValueDoubleValue = jsonMap["doubleValue"] as? String {
                    resultDecodedBuilder.doubleValue = Double(jsonValueDoubleValue)!
                }
                if let jsonValueStringValue = jsonMap["stringValue"] as? String {
                    resultDecodedBuilder.stringValue = jsonValueStringValue
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.EntryValue.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.EntryValue.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Each unit test or benchmark in a test or benchmark run provides
    /// some set of information.  Here we provide some reasonable keys
    /// one would expect to see, with optional key/value pairs for things
    /// we haven't considered.
    /// This BenchmarkEntry should be emitted by each unit test or benchmark
    /// reporter.
    final public class BenchmarkEntry : GeneratedMessage {

        public static func == (lhs: Tensorflow.BenchmarkEntry, rhs: Tensorflow.BenchmarkEntry) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
            fieldCheck = fieldCheck && (lhs.hasIters == rhs.hasIters) && (!lhs.hasIters || lhs.iters == rhs.iters)
            fieldCheck = fieldCheck && (lhs.hasCpuTime == rhs.hasCpuTime) && (!lhs.hasCpuTime || lhs.cpuTime == rhs.cpuTime)
            fieldCheck = fieldCheck && (lhs.hasWallTime == rhs.hasWallTime) && (!lhs.hasWallTime || lhs.wallTime == rhs.wallTime)
            fieldCheck = fieldCheck && (lhs.hasThroughput == rhs.hasThroughput) && (!lhs.hasThroughput || lhs.throughput == rhs.throughput)
            fieldCheck = fieldCheck && (lhs.hasExtras == rhs.hasExtras) && (!lhs.hasExtras || lhs.extras == rhs.extras)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        final public class ExtrasEntry : GeneratedMessage {

            public static func == (lhs: Tensorflow.BenchmarkEntry.ExtrasEntry, rhs: Tensorflow.BenchmarkEntry.ExtrasEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:String = ""
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:Tensorflow.EntryValue!
            public fileprivate(set) var hasValue:Bool = false
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeString(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeMessage(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeStringSize(fieldNumber: 1)
                }
                if hasValue {
                    if let varSizevalue = value?.computeMessageSize(fieldNumber: 2) {
                        serialize_size += varSizevalue
                    }
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.BenchmarkEntry.ExtrasEntry.Builder {
                return Tensorflow.BenchmarkEntry.ExtrasEntry.classBuilder() as! Tensorflow.BenchmarkEntry.ExtrasEntry.Builder
            }
            public func getBuilder() -> Tensorflow.BenchmarkEntry.ExtrasEntry.Builder {
                return classBuilder() as! Tensorflow.BenchmarkEntry.ExtrasEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.BenchmarkEntry.ExtrasEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.BenchmarkEntry.ExtrasEntry.Builder()
            }
            public func toBuilder() throws -> Tensorflow.BenchmarkEntry.ExtrasEntry.Builder {
                return try Tensorflow.BenchmarkEntry.ExtrasEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.BenchmarkEntry.ExtrasEntry) throws -> Tensorflow.BenchmarkEntry.ExtrasEntry.Builder {
                return try Tensorflow.BenchmarkEntry.ExtrasEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = key
                }
                if hasValue {
                    jsonMap["value"] = try value.encode()
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BenchmarkEntry.ExtrasEntry {
                return try Tensorflow.BenchmarkEntry.ExtrasEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.BenchmarkEntry.ExtrasEntry {
                return try Tensorflow.BenchmarkEntry.ExtrasEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value {\n"
                    if let outDescValue = value {
                        output += try outDescValue.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        if let hashValuevalue = value?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuevalue
                        }
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.BenchmarkEntry.ExtrasEntry"
            }
            override public func className() -> String {
                return "Tensorflow.BenchmarkEntry.ExtrasEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.BenchmarkEntry.ExtrasEntry = Tensorflow.BenchmarkEntry.ExtrasEntry()
                public func getMessage() -> Tensorflow.BenchmarkEntry.ExtrasEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:String {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:String) -> Tensorflow.BenchmarkEntry.ExtrasEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> Tensorflow.BenchmarkEntry.ExtrasEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = ""
                    return self
                }
                public var value:Tensorflow.EntryValue! {
                    get {
                        if valueBuilder_ != nil {
                            builderResult.value = valueBuilder_.getMessage()
                        }
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                fileprivate var valueBuilder_:Tensorflow.EntryValue.Builder! {
                    didSet {
                        builderResult.hasValue = true
                    }
                }
                public func getValueBuilder() -> Tensorflow.EntryValue.Builder {
                    if valueBuilder_ == nil {
                        valueBuilder_ = Tensorflow.EntryValue.Builder()
                        builderResult.value = valueBuilder_.getMessage()
                        if value != nil {
                            try! valueBuilder_.mergeFrom(other: value)
                        }
                    }
                    return valueBuilder_
                }
                @discardableResult
                public func setValue(_ value:Tensorflow.EntryValue!) -> Tensorflow.BenchmarkEntry.ExtrasEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func mergeValue(value:Tensorflow.EntryValue) throws -> Tensorflow.BenchmarkEntry.ExtrasEntry.Builder {
                    if builderResult.hasValue {
                        builderResult.value = try Tensorflow.EntryValue.builderWithPrototype(prototype:builderResult.value).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.value = value
                    }
                    builderResult.hasValue = true
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.BenchmarkEntry.ExtrasEntry.Builder {
                    valueBuilder_ = nil
                    builderResult.hasValue = false
                    builderResult.value = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.BenchmarkEntry.ExtrasEntry.Builder {
                    builderResult = Tensorflow.BenchmarkEntry.ExtrasEntry()
                    return self
                }
                override public func clone() throws -> Tensorflow.BenchmarkEntry.ExtrasEntry.Builder {
                    return try Tensorflow.BenchmarkEntry.ExtrasEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.BenchmarkEntry.ExtrasEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.BenchmarkEntry.ExtrasEntry {
                    let returnMe:Tensorflow.BenchmarkEntry.ExtrasEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.BenchmarkEntry.ExtrasEntry) throws -> Tensorflow.BenchmarkEntry.ExtrasEntry.Builder {
                    if other == Tensorflow.BenchmarkEntry.ExtrasEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if (other.hasValue) {
                        try mergeValue(value: other.value)
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BenchmarkEntry.ExtrasEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BenchmarkEntry.ExtrasEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            key = try codedInputStream.readString()

                        case 18:
                            let subBuilder:Tensorflow.EntryValue.Builder = Tensorflow.EntryValue.Builder()
                            if hasValue {
                                try subBuilder.mergeFrom(other: value)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            value = subBuilder.buildPartial()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BenchmarkEntry.ExtrasEntry.Builder {
                    let resultDecodedBuilder = Tensorflow.BenchmarkEntry.ExtrasEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = jsonValueKey
                    }
                    if let jsonValueValue = jsonMap["value"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.value = try Tensorflow.EntryValue.Builder.decodeToBuilder(jsonMap:jsonValueValue).build()

                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.BenchmarkEntry.ExtrasEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.BenchmarkEntry.ExtrasEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        /// The name of the specific benchmark or test
        /// (e.g. BM_AdjustContrast_gpu_B_W_H)
        public fileprivate(set) var name:String = ""
        public fileprivate(set) var hasName:Bool = false

        /// If a benchmark, how many iterations it was run for
        public fileprivate(set) var iters:Int64 = Int64(0)
        public fileprivate(set) var hasIters:Bool = false

        /// Total cpu time used for all iterations (in seconds)
        public fileprivate(set) var cpuTime:Double = Double(0)
        public fileprivate(set) var hasCpuTime:Bool = false

        /// Total wall time used for all iterations (in seconds)
        public fileprivate(set) var wallTime:Double = Double(0)
        public fileprivate(set) var hasWallTime:Bool = false

        /// Throughput (in MB/s)
        public fileprivate(set) var throughput:Double = Double(0)
        public fileprivate(set) var hasThroughput:Bool = false

        /// Generic map from result key to value.
        public fileprivate(set) var extras:Dictionary<String,Tensorflow.EntryValue> = Dictionary<String,Tensorflow.EntryValue>()

        public fileprivate(set) var hasExtras:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasName {
                try codedOutputStream.writeString(fieldNumber: 1, value:name)
            }
            if hasIters {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:iters)
            }
            if hasCpuTime {
                try codedOutputStream.writeDouble(fieldNumber: 3, value:cpuTime)
            }
            if hasWallTime {
                try codedOutputStream.writeDouble(fieldNumber: 4, value:wallTime)
            }
            if hasThroughput {
                try codedOutputStream.writeDouble(fieldNumber: 5, value:throughput)
            }
            if hasExtras {
                for (keyExtras, valueExtras) in extras {
                    let valueOfExtras = try! Tensorflow.BenchmarkEntry.ExtrasEntry.Builder().setKey(keyExtras).setValue(valueExtras).build()
                      try codedOutputStream.writeMessage(fieldNumber: 6, value:valueOfExtras)
                  }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasName {
                serialize_size += name.computeStringSize(fieldNumber: 1)
            }
            if hasIters {
                serialize_size += iters.computeInt64Size(fieldNumber: 2)
            }
            if hasCpuTime {
                serialize_size += cpuTime.computeDoubleSize(fieldNumber: 3)
            }
            if hasWallTime {
                serialize_size += wallTime.computeDoubleSize(fieldNumber: 4)
            }
            if hasThroughput {
                serialize_size += throughput.computeDoubleSize(fieldNumber: 5)
            }
            if hasExtras {
                  for (keyExtras, valueExtras) in extras {
                      let valueOfExtras = try! Tensorflow.BenchmarkEntry.ExtrasEntry.Builder().setKey(keyExtras).setValue(valueExtras).build()
                serialize_size += valueOfExtras.computeMessageSize(fieldNumber: 6)
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.BenchmarkEntry.Builder {
            return Tensorflow.BenchmarkEntry.classBuilder() as! Tensorflow.BenchmarkEntry.Builder
        }
        public func getBuilder() -> Tensorflow.BenchmarkEntry.Builder {
            return classBuilder() as! Tensorflow.BenchmarkEntry.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BenchmarkEntry.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BenchmarkEntry.Builder()
        }
        public func toBuilder() throws -> Tensorflow.BenchmarkEntry.Builder {
            return try Tensorflow.BenchmarkEntry.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.BenchmarkEntry) throws -> Tensorflow.BenchmarkEntry.Builder {
            return try Tensorflow.BenchmarkEntry.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasName {
                jsonMap["name"] = name
            }
            if hasIters {
                jsonMap["iters"] = "\(iters)"
            }
            if hasCpuTime {
                jsonMap["cpuTime"] = Double(cpuTime)
            }
            if hasWallTime {
                jsonMap["wallTime"] = Double(wallTime)
            }
            if hasThroughput {
                jsonMap["throughput"] = Double(throughput)
            }
            if hasExtras {
                var mapExtras = Dictionary<String, Dictionary<String,Any>>()
                for (keyExtras, valueExtras) in extras {
                    mapExtras["\(keyExtras)"] = try valueExtras.encode()
                }
                jsonMap["extras"] = mapExtras
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BenchmarkEntry {
            return try Tensorflow.BenchmarkEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.BenchmarkEntry {
            return try Tensorflow.BenchmarkEntry.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasName {
                output += "\(indent) name: \(name) \n"
            }
            if hasIters {
                output += "\(indent) iters: \(iters) \n"
            }
            if hasCpuTime {
                output += "\(indent) cpuTime: \(cpuTime) \n"
            }
            if hasWallTime {
                output += "\(indent) wallTime: \(wallTime) \n"
            }
            if hasThroughput {
                output += "\(indent) throughput: \(throughput) \n"
            }
            if hasExtras {
                output += "\(indent) extras: \(extras) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasName {
                    hashCode = (hashCode &* 31) &+ name.hashValue
                }
                if hasIters {
                    hashCode = (hashCode &* 31) &+ iters.hashValue
                }
                if hasCpuTime {
                    hashCode = (hashCode &* 31) &+ cpuTime.hashValue
                }
                if hasWallTime {
                    hashCode = (hashCode &* 31) &+ wallTime.hashValue
                }
                if hasThroughput {
                    hashCode = (hashCode &* 31) &+ throughput.hashValue
                }
                if hasExtras {
                    for (keyExtras, valueExtras) in extras {
                        hashCode = (hashCode &* 31) &+ keyExtras.hashValue
                        hashCode = (hashCode &* 31) &+ valueExtras.hashValue
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.BenchmarkEntry"
        }
        override public func className() -> String {
            return "Tensorflow.BenchmarkEntry"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.BenchmarkEntry = Tensorflow.BenchmarkEntry()
            public func getMessage() -> Tensorflow.BenchmarkEntry {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The name of the specific benchmark or test
            /// (e.g. BM_AdjustContrast_gpu_B_W_H)
            public var name:String {
                get {
                    return builderResult.name
                }
                set (value) {
                    builderResult.hasName = true
                    builderResult.name = value
                }
            }
            public var hasName:Bool {
                get {
                    return builderResult.hasName
                }
            }
            @discardableResult
            public func setName(_ value:String) -> Tensorflow.BenchmarkEntry.Builder {
                self.name = value
                return self
            }
            @discardableResult
            public func clearName() -> Tensorflow.BenchmarkEntry.Builder{
                builderResult.hasName = false
                builderResult.name = ""
                return self
            }
            /// If a benchmark, how many iterations it was run for
            public var iters:Int64 {
                get {
                    return builderResult.iters
                }
                set (value) {
                    builderResult.hasIters = true
                    builderResult.iters = value
                }
            }
            public var hasIters:Bool {
                get {
                    return builderResult.hasIters
                }
            }
            @discardableResult
            public func setIters(_ value:Int64) -> Tensorflow.BenchmarkEntry.Builder {
                self.iters = value
                return self
            }
            @discardableResult
            public func clearIters() -> Tensorflow.BenchmarkEntry.Builder{
                builderResult.hasIters = false
                builderResult.iters = Int64(0)
                return self
            }
            /// Total cpu time used for all iterations (in seconds)
            public var cpuTime:Double {
                get {
                    return builderResult.cpuTime
                }
                set (value) {
                    builderResult.hasCpuTime = true
                    builderResult.cpuTime = value
                }
            }
            public var hasCpuTime:Bool {
                get {
                    return builderResult.hasCpuTime
                }
            }
            @discardableResult
            public func setCpuTime(_ value:Double) -> Tensorflow.BenchmarkEntry.Builder {
                self.cpuTime = value
                return self
            }
            @discardableResult
            public func clearCpuTime() -> Tensorflow.BenchmarkEntry.Builder{
                builderResult.hasCpuTime = false
                builderResult.cpuTime = Double(0)
                return self
            }
            /// Total wall time used for all iterations (in seconds)
            public var wallTime:Double {
                get {
                    return builderResult.wallTime
                }
                set (value) {
                    builderResult.hasWallTime = true
                    builderResult.wallTime = value
                }
            }
            public var hasWallTime:Bool {
                get {
                    return builderResult.hasWallTime
                }
            }
            @discardableResult
            public func setWallTime(_ value:Double) -> Tensorflow.BenchmarkEntry.Builder {
                self.wallTime = value
                return self
            }
            @discardableResult
            public func clearWallTime() -> Tensorflow.BenchmarkEntry.Builder{
                builderResult.hasWallTime = false
                builderResult.wallTime = Double(0)
                return self
            }
            /// Throughput (in MB/s)
            public var throughput:Double {
                get {
                    return builderResult.throughput
                }
                set (value) {
                    builderResult.hasThroughput = true
                    builderResult.throughput = value
                }
            }
            public var hasThroughput:Bool {
                get {
                    return builderResult.hasThroughput
                }
            }
            @discardableResult
            public func setThroughput(_ value:Double) -> Tensorflow.BenchmarkEntry.Builder {
                self.throughput = value
                return self
            }
            @discardableResult
            public func clearThroughput() -> Tensorflow.BenchmarkEntry.Builder{
                builderResult.hasThroughput = false
                builderResult.throughput = Double(0)
                return self
            }
            /// Generic map from result key to value.
            public var hasExtras:Bool {
                get {
                    return builderResult.hasExtras
                }
            }
            public var extras:Dictionary<String,Tensorflow.EntryValue> {
                get {
                    return builderResult.extras
                }
                set (value) {
                    builderResult.hasExtras = true
                    builderResult.extras = value
                }
            }
            @discardableResult
            public func setExtras(_ value:Dictionary<String,Tensorflow.EntryValue>) -> Tensorflow.BenchmarkEntry.Builder {
                self.extras = value
                return self
            }
            @discardableResult
            public func clearExtras() -> Tensorflow.BenchmarkEntry.Builder{
                builderResult.hasExtras = false
                builderResult.extras = Dictionary<String,Tensorflow.EntryValue>()
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.BenchmarkEntry.Builder {
                builderResult = Tensorflow.BenchmarkEntry()
                return self
            }
            override public func clone() throws -> Tensorflow.BenchmarkEntry.Builder {
                return try Tensorflow.BenchmarkEntry.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.BenchmarkEntry {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.BenchmarkEntry {
                let returnMe:Tensorflow.BenchmarkEntry = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.BenchmarkEntry) throws -> Tensorflow.BenchmarkEntry.Builder {
                if other == Tensorflow.BenchmarkEntry() {
                    return self
                }
                if other.hasName {
                    name = other.name
                }
                if other.hasIters {
                    iters = other.iters
                }
                if other.hasCpuTime {
                    cpuTime = other.cpuTime
                }
                if other.hasWallTime {
                    wallTime = other.wallTime
                }
                if other.hasThroughput {
                    throughput = other.throughput
                }
                if other.hasExtras {
                    extras = other.extras
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BenchmarkEntry.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BenchmarkEntry.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        name = try codedInputStream.readString()

                    case 16:
                        iters = try codedInputStream.readInt64()

                    case 25:
                        cpuTime = try codedInputStream.readDouble()

                    case 33:
                        wallTime = try codedInputStream.readDouble()

                    case 41:
                        throughput = try codedInputStream.readDouble()

                    case 50:
                        let subBuilder = Tensorflow.BenchmarkEntry.ExtrasEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfExtras = subBuilder.buildPartial()
                        extras[buildOfExtras.key] = buildOfExtras.value

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BenchmarkEntry.Builder {
                let resultDecodedBuilder = Tensorflow.BenchmarkEntry.Builder()
                if let jsonValueName = jsonMap["name"] as? String {
                    resultDecodedBuilder.name = jsonValueName
                }
                if let jsonValueIters = jsonMap["iters"] as? String {
                    resultDecodedBuilder.iters = Int64(jsonValueIters)!
                } else if let jsonValueIters = jsonMap["iters"] as? Int {
                    resultDecodedBuilder.iters = Int64(jsonValueIters)
                }
                if let jsonValueCpuTime = jsonMap["cpuTime"] as? Double {
                    resultDecodedBuilder.cpuTime = Double(jsonValueCpuTime)
                } else if let jsonValueCpuTime = jsonMap["cpuTime"] as? String {
                    resultDecodedBuilder.cpuTime = Double(jsonValueCpuTime)!
                }
                if let jsonValueWallTime = jsonMap["wallTime"] as? Double {
                    resultDecodedBuilder.wallTime = Double(jsonValueWallTime)
                } else if let jsonValueWallTime = jsonMap["wallTime"] as? String {
                    resultDecodedBuilder.wallTime = Double(jsonValueWallTime)!
                }
                if let jsonValueThroughput = jsonMap["throughput"] as? Double {
                    resultDecodedBuilder.throughput = Double(jsonValueThroughput)
                } else if let jsonValueThroughput = jsonMap["throughput"] as? String {
                    resultDecodedBuilder.throughput = Double(jsonValueThroughput)!
                }
                if let jsonValueExtras = jsonMap["extras"] as? Dictionary<String, Dictionary<String,Any>> {
                    var mapExtras = Dictionary<String, Tensorflow.EntryValue>()
                    for (keyExtras, valueExtras) in jsonValueExtras {
                        guard let keyFromExtras = String(keyExtras) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapExtras[keyFromExtras] = try Tensorflow.EntryValue.Builder.decodeToBuilder(jsonMap:valueExtras).build()

                    }
                    resultDecodedBuilder.extras = mapExtras
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.BenchmarkEntry.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.BenchmarkEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class BenchmarkEntries : GeneratedMessage {

        public static func == (lhs: Tensorflow.BenchmarkEntries, rhs: Tensorflow.BenchmarkEntries) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.entry == rhs.entry)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var entry:Array<Tensorflow.BenchmarkEntry>  = Array<Tensorflow.BenchmarkEntry>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementEntry in entry {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementEntry)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementEntry in entry {
                serialize_size += oneElementEntry.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.BenchmarkEntries.Builder {
            return Tensorflow.BenchmarkEntries.classBuilder() as! Tensorflow.BenchmarkEntries.Builder
        }
        public func getBuilder() -> Tensorflow.BenchmarkEntries.Builder {
            return classBuilder() as! Tensorflow.BenchmarkEntries.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BenchmarkEntries.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BenchmarkEntries.Builder()
        }
        public func toBuilder() throws -> Tensorflow.BenchmarkEntries.Builder {
            return try Tensorflow.BenchmarkEntries.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.BenchmarkEntries) throws -> Tensorflow.BenchmarkEntries.Builder {
            return try Tensorflow.BenchmarkEntries.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !entry.isEmpty {
                var jsonArrayEntry:Array<Dictionary<String,Any>> = []
                for oneValueEntry in entry {
                    let ecodedMessageEntry = try oneValueEntry.encode()
                    jsonArrayEntry.append(ecodedMessageEntry)
                }
                jsonMap["entry"] = jsonArrayEntry
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BenchmarkEntries {
            return try Tensorflow.BenchmarkEntries.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.BenchmarkEntries {
            return try Tensorflow.BenchmarkEntries.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var entryElementIndex:Int = 0
            for oneElementEntry in entry {
                output += "\(indent) entry[\(entryElementIndex)] {\n"
                output += try oneElementEntry.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                entryElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementEntry in entry {
                    hashCode = (hashCode &* 31) &+ oneElementEntry.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.BenchmarkEntries"
        }
        override public func className() -> String {
            return "Tensorflow.BenchmarkEntries"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.BenchmarkEntries = Tensorflow.BenchmarkEntries()
            public func getMessage() -> Tensorflow.BenchmarkEntries {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var entry:Array<Tensorflow.BenchmarkEntry> {
                get {
                    return builderResult.entry
                }
                set (value) {
                    builderResult.entry = value
                }
            }
            @discardableResult
            public func setEntry(_ value:Array<Tensorflow.BenchmarkEntry>) -> Tensorflow.BenchmarkEntries.Builder {
                self.entry = value
                return self
            }
            @discardableResult
            public func clearEntry() -> Tensorflow.BenchmarkEntries.Builder {
                builderResult.entry.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.BenchmarkEntries.Builder {
                builderResult = Tensorflow.BenchmarkEntries()
                return self
            }
            override public func clone() throws -> Tensorflow.BenchmarkEntries.Builder {
                return try Tensorflow.BenchmarkEntries.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.BenchmarkEntries {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.BenchmarkEntries {
                let returnMe:Tensorflow.BenchmarkEntries = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.BenchmarkEntries) throws -> Tensorflow.BenchmarkEntries.Builder {
                if other == Tensorflow.BenchmarkEntries() {
                    return self
                }
                if !other.entry.isEmpty  {
                     builderResult.entry += other.entry
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BenchmarkEntries.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BenchmarkEntries.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Tensorflow.BenchmarkEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        entry.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BenchmarkEntries.Builder {
                let resultDecodedBuilder = Tensorflow.BenchmarkEntries.Builder()
                if let jsonValueEntry = jsonMap["entry"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayEntry:Array<Tensorflow.BenchmarkEntry> = []
                    for oneValueEntry in jsonValueEntry {
                        let messageFromStringEntry = try Tensorflow.BenchmarkEntry.Builder.decodeToBuilder(jsonMap:oneValueEntry).build()

                        jsonArrayEntry.append(messageFromStringEntry)
                    }
                    resultDecodedBuilder.entry = jsonArrayEntry
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.BenchmarkEntries.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.BenchmarkEntries.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class BuildConfiguration : GeneratedMessage {

        public static func == (lhs: Tensorflow.BuildConfiguration, rhs: Tensorflow.BuildConfiguration) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasMode == rhs.hasMode) && (!lhs.hasMode || lhs.mode == rhs.mode)
            fieldCheck = fieldCheck && (lhs.ccFlags == rhs.ccFlags)
            fieldCheck = fieldCheck && (lhs.opts == rhs.opts)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// opt, dbg, etc
        public fileprivate(set) var mode:String = ""
        public fileprivate(set) var hasMode:Bool = false

        /// CC compiler flags, if known
        public fileprivate(set) var ccFlags:Array<String> = Array<String>()
        /// Bazel compilation options, if known
        public fileprivate(set) var opts:Array<String> = Array<String>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasMode {
                try codedOutputStream.writeString(fieldNumber: 1, value:mode)
            }
            if !ccFlags.isEmpty {
                for oneValueccFlags in ccFlags {
                    try codedOutputStream.writeString(fieldNumber: 2, value:oneValueccFlags)
                }
            }
            if !opts.isEmpty {
                for oneValueopts in opts {
                    try codedOutputStream.writeString(fieldNumber: 3, value:oneValueopts)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasMode {
                serialize_size += mode.computeStringSize(fieldNumber: 1)
            }
            var dataSizeCcFlags:Int32 = 0
            for oneValueccFlags in ccFlags {
                dataSizeCcFlags += oneValueccFlags.computeStringSizeNoTag()
            }
            serialize_size += dataSizeCcFlags
            serialize_size += 1 * Int32(ccFlags.count)
            var dataSizeOpts:Int32 = 0
            for oneValueopts in opts {
                dataSizeOpts += oneValueopts.computeStringSizeNoTag()
            }
            serialize_size += dataSizeOpts
            serialize_size += 1 * Int32(opts.count)
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.BuildConfiguration.Builder {
            return Tensorflow.BuildConfiguration.classBuilder() as! Tensorflow.BuildConfiguration.Builder
        }
        public func getBuilder() -> Tensorflow.BuildConfiguration.Builder {
            return classBuilder() as! Tensorflow.BuildConfiguration.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BuildConfiguration.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BuildConfiguration.Builder()
        }
        public func toBuilder() throws -> Tensorflow.BuildConfiguration.Builder {
            return try Tensorflow.BuildConfiguration.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.BuildConfiguration) throws -> Tensorflow.BuildConfiguration.Builder {
            return try Tensorflow.BuildConfiguration.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasMode {
                jsonMap["mode"] = mode
            }
            if !ccFlags.isEmpty {
                var jsonArrayCcFlags:Array<String> = []
                for oneValueCcFlags in ccFlags {
                    jsonArrayCcFlags.append(oneValueCcFlags)
                }
                jsonMap["ccFlags"] = jsonArrayCcFlags
            }
            if !opts.isEmpty {
                var jsonArrayOpts:Array<String> = []
                for oneValueOpts in opts {
                    jsonArrayOpts.append(oneValueOpts)
                }
                jsonMap["opts"] = jsonArrayOpts
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BuildConfiguration {
            return try Tensorflow.BuildConfiguration.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.BuildConfiguration {
            return try Tensorflow.BuildConfiguration.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasMode {
                output += "\(indent) mode: \(mode) \n"
            }
            var ccFlagsElementIndex:Int = 0
            for oneValueCcFlags in ccFlags  {
                output += "\(indent) ccFlags[\(ccFlagsElementIndex)]: \(oneValueCcFlags)\n"
                ccFlagsElementIndex += 1
            }
            var optsElementIndex:Int = 0
            for oneValueOpts in opts  {
                output += "\(indent) opts[\(optsElementIndex)]: \(oneValueOpts)\n"
                optsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasMode {
                    hashCode = (hashCode &* 31) &+ mode.hashValue
                }
                for oneValueCcFlags in ccFlags {
                    hashCode = (hashCode &* 31) &+ oneValueCcFlags.hashValue
                }
                for oneValueOpts in opts {
                    hashCode = (hashCode &* 31) &+ oneValueOpts.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.BuildConfiguration"
        }
        override public func className() -> String {
            return "Tensorflow.BuildConfiguration"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.BuildConfiguration = Tensorflow.BuildConfiguration()
            public func getMessage() -> Tensorflow.BuildConfiguration {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// opt, dbg, etc
            public var mode:String {
                get {
                    return builderResult.mode
                }
                set (value) {
                    builderResult.hasMode = true
                    builderResult.mode = value
                }
            }
            public var hasMode:Bool {
                get {
                    return builderResult.hasMode
                }
            }
            @discardableResult
            public func setMode(_ value:String) -> Tensorflow.BuildConfiguration.Builder {
                self.mode = value
                return self
            }
            @discardableResult
            public func clearMode() -> Tensorflow.BuildConfiguration.Builder{
                builderResult.hasMode = false
                builderResult.mode = ""
                return self
            }
            /// CC compiler flags, if known
            public var ccFlags:Array<String> {
                get {
                    return builderResult.ccFlags
                }
                set (array) {
                    builderResult.ccFlags = array
                }
            }
            @discardableResult
            public func setCcFlags(_ value:Array<String>) -> Tensorflow.BuildConfiguration.Builder {
                self.ccFlags = value
                return self
            }
            @discardableResult
            public func clearCcFlags() -> Tensorflow.BuildConfiguration.Builder {
                builderResult.ccFlags.removeAll(keepingCapacity: false)
                return self
            }
            /// Bazel compilation options, if known
            public var opts:Array<String> {
                get {
                    return builderResult.opts
                }
                set (array) {
                    builderResult.opts = array
                }
            }
            @discardableResult
            public func setOpts(_ value:Array<String>) -> Tensorflow.BuildConfiguration.Builder {
                self.opts = value
                return self
            }
            @discardableResult
            public func clearOpts() -> Tensorflow.BuildConfiguration.Builder {
                builderResult.opts.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.BuildConfiguration.Builder {
                builderResult = Tensorflow.BuildConfiguration()
                return self
            }
            override public func clone() throws -> Tensorflow.BuildConfiguration.Builder {
                return try Tensorflow.BuildConfiguration.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.BuildConfiguration {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.BuildConfiguration {
                let returnMe:Tensorflow.BuildConfiguration = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.BuildConfiguration) throws -> Tensorflow.BuildConfiguration.Builder {
                if other == Tensorflow.BuildConfiguration() {
                    return self
                }
                if other.hasMode {
                    mode = other.mode
                }
                if !other.ccFlags.isEmpty {
                    builderResult.ccFlags += other.ccFlags
                }
                if !other.opts.isEmpty {
                    builderResult.opts += other.opts
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BuildConfiguration.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BuildConfiguration.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        mode = try codedInputStream.readString()

                    case 18:
                        ccFlags += [try codedInputStream.readString()]

                    case 26:
                        opts += [try codedInputStream.readString()]

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BuildConfiguration.Builder {
                let resultDecodedBuilder = Tensorflow.BuildConfiguration.Builder()
                if let jsonValueMode = jsonMap["mode"] as? String {
                    resultDecodedBuilder.mode = jsonValueMode
                }
                if let jsonValueCcFlags = jsonMap["ccFlags"] as? Array<String> {
                    var jsonArrayCcFlags:Array<String> = []
                    for oneValueCcFlags in jsonValueCcFlags {
                        jsonArrayCcFlags.append(oneValueCcFlags)
                    }
                    resultDecodedBuilder.ccFlags = jsonArrayCcFlags
                }
                if let jsonValueOpts = jsonMap["opts"] as? Array<String> {
                    var jsonArrayOpts:Array<String> = []
                    for oneValueOpts in jsonValueOpts {
                        jsonArrayOpts.append(oneValueOpts)
                    }
                    resultDecodedBuilder.opts = jsonArrayOpts
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.BuildConfiguration.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.BuildConfiguration.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class CommitId : GeneratedMessage {

        public static func == (lhs: Tensorflow.CommitId, rhs: Tensorflow.CommitId) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasChangelist == rhs.hasChangelist) && (!lhs.hasChangelist || lhs.changelist == rhs.changelist)
            fieldCheck = fieldCheck && (lhs.hasHash == rhs.hasHash) && (!lhs.hasHash || lhs.hash == rhs.hash)
            fieldCheck = fieldCheck && (lhs.hasSnapshot == rhs.hasSnapshot) && (!lhs.hasSnapshot || lhs.snapshot == rhs.snapshot)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //OneOf declaration start

        public enum Kind {
            case OneOfKindNotSet

            public func checkOneOfIsSet() -> Bool {
                switch self {
                case .OneOfKindNotSet: return false
                default: return true
                }
            }
            case Changelist(Int64)

            public static func getChangelist(_ value:Kind) -> Int64? {
                switch value {
                case .Changelist(let enumValue): return enumValue
                default: return nil
                }
            }
            case Hash(String)

            public static func getHash(_ value:Kind) -> String? {
                switch value {
                case .Hash(let enumValue): return enumValue
                default: return nil
                }
            }
        }
        //OneOf declaration end

        fileprivate var storageKind:CommitId.Kind =  CommitId.Kind.OneOfKindNotSet
        public func getOneOfKind() ->  CommitId.Kind {
            let copyObjectKind = storageKind
            return copyObjectKind
        }
        public fileprivate(set) var changelist:Int64!{
            get {
                return CommitId.Kind.getChangelist(storageKind)
            }
            set (newvalue) {
                storageKind = CommitId.Kind.Changelist(newvalue)
            }
        }
        public fileprivate(set) var hasChangelist:Bool {
            get {
                guard let _ = CommitId.Kind.getChangelist(storageKind) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var hash:String!{
            get {
                return CommitId.Kind.getHash(storageKind)
            }
            set (newvalue) {
                storageKind = CommitId.Kind.Hash(newvalue)
            }
        }
        public fileprivate(set) var hasHash:Bool {
            get {
                guard let _ = CommitId.Kind.getHash(storageKind) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        /// Hash of intermediate change between hash/changelist and what was tested.
        /// Not used if the build is from a commit without modifications.
        public fileprivate(set) var snapshot:String = ""
        public fileprivate(set) var hasSnapshot:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasChangelist {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:changelist)
            }
            if hasHash {
                try codedOutputStream.writeString(fieldNumber: 2, value:hash)
            }
            if hasSnapshot {
                try codedOutputStream.writeString(fieldNumber: 3, value:snapshot)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasChangelist {
                serialize_size += changelist.computeInt64Size(fieldNumber: 1)
            }
            if hasHash {
                serialize_size += hash.computeStringSize(fieldNumber: 2)
            }
            if hasSnapshot {
                serialize_size += snapshot.computeStringSize(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.CommitId.Builder {
            return Tensorflow.CommitId.classBuilder() as! Tensorflow.CommitId.Builder
        }
        public func getBuilder() -> Tensorflow.CommitId.Builder {
            return classBuilder() as! Tensorflow.CommitId.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.CommitId.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.CommitId.Builder()
        }
        public func toBuilder() throws -> Tensorflow.CommitId.Builder {
            return try Tensorflow.CommitId.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.CommitId) throws -> Tensorflow.CommitId.Builder {
            return try Tensorflow.CommitId.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasChangelist {
                jsonMap["changelist"] = "\(changelist)"
            }
            if hasHash {
                jsonMap["hash"] = hash
            }
            if hasSnapshot {
                jsonMap["snapshot"] = snapshot
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CommitId {
            return try Tensorflow.CommitId.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.CommitId {
            return try Tensorflow.CommitId.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasChangelist {
                output += "\(indent) changelist: \(changelist) \n"
            }
            if hasHash {
                output += "\(indent) hash: \(hash) \n"
            }
            if hasSnapshot {
                output += "\(indent) snapshot: \(snapshot) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasChangelist {
                    hashCode = (hashCode &* 31) &+ changelist.hashValue
                }
                if hasHash {
                    hashCode = (hashCode &* 31) &+ hash.hashValue
                }
                if hasSnapshot {
                    hashCode = (hashCode &* 31) &+ snapshot.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.CommitId"
        }
        override public func className() -> String {
            return "Tensorflow.CommitId"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.CommitId = Tensorflow.CommitId()
            public func getMessage() -> Tensorflow.CommitId {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var changelist:Int64 {
                get {
                    return builderResult.changelist
                }
                set (value) {
                    builderResult.hasChangelist = true
                    builderResult.changelist = value
                }
            }
            public var hasChangelist:Bool {
                get {
                    return builderResult.hasChangelist
                }
            }
            @discardableResult
            public func setChangelist(_ value:Int64) -> Tensorflow.CommitId.Builder {
                self.changelist = value
                return self
            }
            @discardableResult
            public func clearChangelist() -> Tensorflow.CommitId.Builder{
                builderResult.hasChangelist = false
                builderResult.changelist = Int64(0)
                return self
            }
            public var hash:String {
                get {
                    return builderResult.hash
                }
                set (value) {
                    builderResult.hasHash = true
                    builderResult.hash = value
                }
            }
            public var hasHash:Bool {
                get {
                    return builderResult.hasHash
                }
            }
            @discardableResult
            public func setHash(_ value:String) -> Tensorflow.CommitId.Builder {
                self.hash = value
                return self
            }
            @discardableResult
            public func clearHash() -> Tensorflow.CommitId.Builder{
                builderResult.hasHash = false
                builderResult.hash = ""
                return self
            }
            /// Hash of intermediate change between hash/changelist and what was tested.
            /// Not used if the build is from a commit without modifications.
            public var snapshot:String {
                get {
                    return builderResult.snapshot
                }
                set (value) {
                    builderResult.hasSnapshot = true
                    builderResult.snapshot = value
                }
            }
            public var hasSnapshot:Bool {
                get {
                    return builderResult.hasSnapshot
                }
            }
            @discardableResult
            public func setSnapshot(_ value:String) -> Tensorflow.CommitId.Builder {
                self.snapshot = value
                return self
            }
            @discardableResult
            public func clearSnapshot() -> Tensorflow.CommitId.Builder{
                builderResult.hasSnapshot = false
                builderResult.snapshot = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.CommitId.Builder {
                builderResult = Tensorflow.CommitId()
                return self
            }
            override public func clone() throws -> Tensorflow.CommitId.Builder {
                return try Tensorflow.CommitId.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.CommitId {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.CommitId {
                let returnMe:Tensorflow.CommitId = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.CommitId) throws -> Tensorflow.CommitId.Builder {
                if other == Tensorflow.CommitId() {
                    return self
                }
                if other.hasChangelist {
                    changelist = other.changelist
                }
                if other.hasHash {
                    hash = other.hash
                }
                if other.hasSnapshot {
                    snapshot = other.snapshot
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CommitId.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CommitId.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        changelist = try codedInputStream.readInt64()

                    case 18:
                        hash = try codedInputStream.readString()

                    case 26:
                        snapshot = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CommitId.Builder {
                let resultDecodedBuilder = Tensorflow.CommitId.Builder()
                if let jsonValueChangelist = jsonMap["changelist"] as? String {
                    resultDecodedBuilder.changelist = Int64(jsonValueChangelist)!
                } else if let jsonValueChangelist = jsonMap["changelist"] as? Int {
                    resultDecodedBuilder.changelist = Int64(jsonValueChangelist)
                }
                if let jsonValueHash = jsonMap["hash"] as? String {
                    resultDecodedBuilder.hash = jsonValueHash
                }
                if let jsonValueSnapshot = jsonMap["snapshot"] as? String {
                    resultDecodedBuilder.snapshot = jsonValueSnapshot
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.CommitId.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.CommitId.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class Cpuinfo : GeneratedMessage {

        public static func == (lhs: Tensorflow.Cpuinfo, rhs: Tensorflow.Cpuinfo) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasNumCores == rhs.hasNumCores) && (!lhs.hasNumCores || lhs.numCores == rhs.numCores)
            fieldCheck = fieldCheck && (lhs.hasNumCoresAllowed == rhs.hasNumCoresAllowed) && (!lhs.hasNumCoresAllowed || lhs.numCoresAllowed == rhs.numCoresAllowed)
            fieldCheck = fieldCheck && (lhs.hasMhzPerCpu == rhs.hasMhzPerCpu) && (!lhs.hasMhzPerCpu || lhs.mhzPerCpu == rhs.mhzPerCpu)
            fieldCheck = fieldCheck && (lhs.hasCpuInfo == rhs.hasCpuInfo) && (!lhs.hasCpuInfo || lhs.cpuInfo == rhs.cpuInfo)
            fieldCheck = fieldCheck && (lhs.hasCpuGovernor == rhs.hasCpuGovernor) && (!lhs.hasCpuGovernor || lhs.cpuGovernor == rhs.cpuGovernor)
            fieldCheck = fieldCheck && (lhs.hasCacheSize == rhs.hasCacheSize) && (!lhs.hasCacheSize || lhs.cacheSize == rhs.cacheSize)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        final public class CacheSizeEntry : GeneratedMessage {

            public static func == (lhs: Tensorflow.Cpuinfo.CacheSizeEntry, rhs: Tensorflow.Cpuinfo.CacheSizeEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:String = ""
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:Int64 = Int64(0)
            public fileprivate(set) var hasValue:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeString(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeInt64(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeStringSize(fieldNumber: 1)
                }
                if hasValue {
                    serialize_size += value.computeInt64Size(fieldNumber: 2)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.Cpuinfo.CacheSizeEntry.Builder {
                return Tensorflow.Cpuinfo.CacheSizeEntry.classBuilder() as! Tensorflow.Cpuinfo.CacheSizeEntry.Builder
            }
            public func getBuilder() -> Tensorflow.Cpuinfo.CacheSizeEntry.Builder {
                return classBuilder() as! Tensorflow.Cpuinfo.CacheSizeEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.Cpuinfo.CacheSizeEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.Cpuinfo.CacheSizeEntry.Builder()
            }
            public func toBuilder() throws -> Tensorflow.Cpuinfo.CacheSizeEntry.Builder {
                return try Tensorflow.Cpuinfo.CacheSizeEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.Cpuinfo.CacheSizeEntry) throws -> Tensorflow.Cpuinfo.CacheSizeEntry.Builder {
                return try Tensorflow.Cpuinfo.CacheSizeEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = key
                }
                if hasValue {
                    jsonMap["value"] = "\(value)"
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Cpuinfo.CacheSizeEntry {
                return try Tensorflow.Cpuinfo.CacheSizeEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.Cpuinfo.CacheSizeEntry {
                return try Tensorflow.Cpuinfo.CacheSizeEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value: \(value) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        hashCode = (hashCode &* 31) &+ value.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.Cpuinfo.CacheSizeEntry"
            }
            override public func className() -> String {
                return "Tensorflow.Cpuinfo.CacheSizeEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.Cpuinfo.CacheSizeEntry = Tensorflow.Cpuinfo.CacheSizeEntry()
                public func getMessage() -> Tensorflow.Cpuinfo.CacheSizeEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:String {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:String) -> Tensorflow.Cpuinfo.CacheSizeEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> Tensorflow.Cpuinfo.CacheSizeEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = ""
                    return self
                }
                public var value:Int64 {
                    get {
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                @discardableResult
                public func setValue(_ value:Int64) -> Tensorflow.Cpuinfo.CacheSizeEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.Cpuinfo.CacheSizeEntry.Builder{
                    builderResult.hasValue = false
                    builderResult.value = Int64(0)
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.Cpuinfo.CacheSizeEntry.Builder {
                    builderResult = Tensorflow.Cpuinfo.CacheSizeEntry()
                    return self
                }
                override public func clone() throws -> Tensorflow.Cpuinfo.CacheSizeEntry.Builder {
                    return try Tensorflow.Cpuinfo.CacheSizeEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.Cpuinfo.CacheSizeEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.Cpuinfo.CacheSizeEntry {
                    let returnMe:Tensorflow.Cpuinfo.CacheSizeEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.Cpuinfo.CacheSizeEntry) throws -> Tensorflow.Cpuinfo.CacheSizeEntry.Builder {
                    if other == Tensorflow.Cpuinfo.CacheSizeEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if other.hasValue {
                        value = other.value
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Cpuinfo.CacheSizeEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Cpuinfo.CacheSizeEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            key = try codedInputStream.readString()

                        case 16:
                            value = try codedInputStream.readInt64()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Cpuinfo.CacheSizeEntry.Builder {
                    let resultDecodedBuilder = Tensorflow.Cpuinfo.CacheSizeEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = jsonValueKey
                    }
                    if let jsonValueValue = jsonMap["value"] as? String {
                        resultDecodedBuilder.value = Int64(jsonValueValue)!
                    } else if let jsonValueValue = jsonMap["value"] as? Int {
                        resultDecodedBuilder.value = Int64(jsonValueValue)
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Cpuinfo.CacheSizeEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.Cpuinfo.CacheSizeEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        public fileprivate(set) var numCores:Int64 = Int64(0)
        public fileprivate(set) var hasNumCores:Bool = false

        public fileprivate(set) var numCoresAllowed:Int64 = Int64(0)
        public fileprivate(set) var hasNumCoresAllowed:Bool = false

        /// How fast are these cpus?
        public fileprivate(set) var mhzPerCpu:Double = Double(0)
        public fileprivate(set) var hasMhzPerCpu:Bool = false

        /// Additional cpu information. For example,
        /// Intel Ivybridge with HyperThreading (24 cores) dL1:32KB dL2:256KB dL3:30MB
        public fileprivate(set) var cpuInfo:String = ""
        public fileprivate(set) var hasCpuInfo:Bool = false

        /// What kind of cpu scaling is enabled on the host.
        /// Examples include "performance", "ondemand", "conservative", "mixed".
        public fileprivate(set) var cpuGovernor:String = ""
        public fileprivate(set) var hasCpuGovernor:Bool = false

        /// Cache sizes (in bytes), e.g. "L2": 262144 (for 256KB)
        public fileprivate(set) var cacheSize:Dictionary<String,Int64> = Dictionary<String,Int64>()

        public fileprivate(set) var hasCacheSize:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasNumCores {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:numCores)
            }
            if hasNumCoresAllowed {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:numCoresAllowed)
            }
            if hasMhzPerCpu {
                try codedOutputStream.writeDouble(fieldNumber: 3, value:mhzPerCpu)
            }
            if hasCpuInfo {
                try codedOutputStream.writeString(fieldNumber: 4, value:cpuInfo)
            }
            if hasCpuGovernor {
                try codedOutputStream.writeString(fieldNumber: 5, value:cpuGovernor)
            }
            if hasCacheSize {
                for (keyCacheSize, valueCacheSize) in cacheSize {
                    let valueOfCacheSize = try! Tensorflow.Cpuinfo.CacheSizeEntry.Builder().setKey(keyCacheSize).setValue(valueCacheSize).build()
                      try codedOutputStream.writeMessage(fieldNumber: 6, value:valueOfCacheSize)
                  }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasNumCores {
                serialize_size += numCores.computeInt64Size(fieldNumber: 1)
            }
            if hasNumCoresAllowed {
                serialize_size += numCoresAllowed.computeInt64Size(fieldNumber: 2)
            }
            if hasMhzPerCpu {
                serialize_size += mhzPerCpu.computeDoubleSize(fieldNumber: 3)
            }
            if hasCpuInfo {
                serialize_size += cpuInfo.computeStringSize(fieldNumber: 4)
            }
            if hasCpuGovernor {
                serialize_size += cpuGovernor.computeStringSize(fieldNumber: 5)
            }
            if hasCacheSize {
                  for (keyCacheSize, valueCacheSize) in cacheSize {
                      let valueOfCacheSize = try! Tensorflow.Cpuinfo.CacheSizeEntry.Builder().setKey(keyCacheSize).setValue(valueCacheSize).build()
                serialize_size += valueOfCacheSize.computeMessageSize(fieldNumber: 6)
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.Cpuinfo.Builder {
            return Tensorflow.Cpuinfo.classBuilder() as! Tensorflow.Cpuinfo.Builder
        }
        public func getBuilder() -> Tensorflow.Cpuinfo.Builder {
            return classBuilder() as! Tensorflow.Cpuinfo.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Cpuinfo.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Cpuinfo.Builder()
        }
        public func toBuilder() throws -> Tensorflow.Cpuinfo.Builder {
            return try Tensorflow.Cpuinfo.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.Cpuinfo) throws -> Tensorflow.Cpuinfo.Builder {
            return try Tensorflow.Cpuinfo.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasNumCores {
                jsonMap["numCores"] = "\(numCores)"
            }
            if hasNumCoresAllowed {
                jsonMap["numCoresAllowed"] = "\(numCoresAllowed)"
            }
            if hasMhzPerCpu {
                jsonMap["mhzPerCpu"] = Double(mhzPerCpu)
            }
            if hasCpuInfo {
                jsonMap["cpuInfo"] = cpuInfo
            }
            if hasCpuGovernor {
                jsonMap["cpuGovernor"] = cpuGovernor
            }
            if hasCacheSize {
                var mapCacheSize = Dictionary<String, String>()
                for (keyCacheSize, valueCacheSize) in cacheSize {
                    mapCacheSize["\(keyCacheSize)"] = "\(valueCacheSize)"
                }
                jsonMap["cacheSize"] = mapCacheSize
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Cpuinfo {
            return try Tensorflow.Cpuinfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.Cpuinfo {
            return try Tensorflow.Cpuinfo.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasNumCores {
                output += "\(indent) numCores: \(numCores) \n"
            }
            if hasNumCoresAllowed {
                output += "\(indent) numCoresAllowed: \(numCoresAllowed) \n"
            }
            if hasMhzPerCpu {
                output += "\(indent) mhzPerCpu: \(mhzPerCpu) \n"
            }
            if hasCpuInfo {
                output += "\(indent) cpuInfo: \(cpuInfo) \n"
            }
            if hasCpuGovernor {
                output += "\(indent) cpuGovernor: \(cpuGovernor) \n"
            }
            if hasCacheSize {
                output += "\(indent) cacheSize: \(cacheSize) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasNumCores {
                    hashCode = (hashCode &* 31) &+ numCores.hashValue
                }
                if hasNumCoresAllowed {
                    hashCode = (hashCode &* 31) &+ numCoresAllowed.hashValue
                }
                if hasMhzPerCpu {
                    hashCode = (hashCode &* 31) &+ mhzPerCpu.hashValue
                }
                if hasCpuInfo {
                    hashCode = (hashCode &* 31) &+ cpuInfo.hashValue
                }
                if hasCpuGovernor {
                    hashCode = (hashCode &* 31) &+ cpuGovernor.hashValue
                }
                if hasCacheSize {
                    for (keyCacheSize, valueCacheSize) in cacheSize {
                        hashCode = (hashCode &* 31) &+ keyCacheSize.hashValue
                        hashCode = (hashCode &* 31) &+ valueCacheSize.hashValue
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.Cpuinfo"
        }
        override public func className() -> String {
            return "Tensorflow.Cpuinfo"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.Cpuinfo = Tensorflow.Cpuinfo()
            public func getMessage() -> Tensorflow.Cpuinfo {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var numCores:Int64 {
                get {
                    return builderResult.numCores
                }
                set (value) {
                    builderResult.hasNumCores = true
                    builderResult.numCores = value
                }
            }
            public var hasNumCores:Bool {
                get {
                    return builderResult.hasNumCores
                }
            }
            @discardableResult
            public func setNumCores(_ value:Int64) -> Tensorflow.Cpuinfo.Builder {
                self.numCores = value
                return self
            }
            @discardableResult
            public func clearNumCores() -> Tensorflow.Cpuinfo.Builder{
                builderResult.hasNumCores = false
                builderResult.numCores = Int64(0)
                return self
            }
            public var numCoresAllowed:Int64 {
                get {
                    return builderResult.numCoresAllowed
                }
                set (value) {
                    builderResult.hasNumCoresAllowed = true
                    builderResult.numCoresAllowed = value
                }
            }
            public var hasNumCoresAllowed:Bool {
                get {
                    return builderResult.hasNumCoresAllowed
                }
            }
            @discardableResult
            public func setNumCoresAllowed(_ value:Int64) -> Tensorflow.Cpuinfo.Builder {
                self.numCoresAllowed = value
                return self
            }
            @discardableResult
            public func clearNumCoresAllowed() -> Tensorflow.Cpuinfo.Builder{
                builderResult.hasNumCoresAllowed = false
                builderResult.numCoresAllowed = Int64(0)
                return self
            }
            /// How fast are these cpus?
            public var mhzPerCpu:Double {
                get {
                    return builderResult.mhzPerCpu
                }
                set (value) {
                    builderResult.hasMhzPerCpu = true
                    builderResult.mhzPerCpu = value
                }
            }
            public var hasMhzPerCpu:Bool {
                get {
                    return builderResult.hasMhzPerCpu
                }
            }
            @discardableResult
            public func setMhzPerCpu(_ value:Double) -> Tensorflow.Cpuinfo.Builder {
                self.mhzPerCpu = value
                return self
            }
            @discardableResult
            public func clearMhzPerCpu() -> Tensorflow.Cpuinfo.Builder{
                builderResult.hasMhzPerCpu = false
                builderResult.mhzPerCpu = Double(0)
                return self
            }
            /// Additional cpu information. For example,
            /// Intel Ivybridge with HyperThreading (24 cores) dL1:32KB dL2:256KB dL3:30MB
            public var cpuInfo:String {
                get {
                    return builderResult.cpuInfo
                }
                set (value) {
                    builderResult.hasCpuInfo = true
                    builderResult.cpuInfo = value
                }
            }
            public var hasCpuInfo:Bool {
                get {
                    return builderResult.hasCpuInfo
                }
            }
            @discardableResult
            public func setCpuInfo(_ value:String) -> Tensorflow.Cpuinfo.Builder {
                self.cpuInfo = value
                return self
            }
            @discardableResult
            public func clearCpuInfo() -> Tensorflow.Cpuinfo.Builder{
                builderResult.hasCpuInfo = false
                builderResult.cpuInfo = ""
                return self
            }
            /// What kind of cpu scaling is enabled on the host.
            /// Examples include "performance", "ondemand", "conservative", "mixed".
            public var cpuGovernor:String {
                get {
                    return builderResult.cpuGovernor
                }
                set (value) {
                    builderResult.hasCpuGovernor = true
                    builderResult.cpuGovernor = value
                }
            }
            public var hasCpuGovernor:Bool {
                get {
                    return builderResult.hasCpuGovernor
                }
            }
            @discardableResult
            public func setCpuGovernor(_ value:String) -> Tensorflow.Cpuinfo.Builder {
                self.cpuGovernor = value
                return self
            }
            @discardableResult
            public func clearCpuGovernor() -> Tensorflow.Cpuinfo.Builder{
                builderResult.hasCpuGovernor = false
                builderResult.cpuGovernor = ""
                return self
            }
            /// Cache sizes (in bytes), e.g. "L2": 262144 (for 256KB)
            public var hasCacheSize:Bool {
                get {
                    return builderResult.hasCacheSize
                }
            }
            public var cacheSize:Dictionary<String,Int64> {
                get {
                    return builderResult.cacheSize
                }
                set (value) {
                    builderResult.hasCacheSize = true
                    builderResult.cacheSize = value
                }
            }
            @discardableResult
            public func setCacheSize(_ value:Dictionary<String,Int64>) -> Tensorflow.Cpuinfo.Builder {
                self.cacheSize = value
                return self
            }
            @discardableResult
            public func clearCacheSize() -> Tensorflow.Cpuinfo.Builder{
                builderResult.hasCacheSize = false
                builderResult.cacheSize = Dictionary<String,Int64>()
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.Cpuinfo.Builder {
                builderResult = Tensorflow.Cpuinfo()
                return self
            }
            override public func clone() throws -> Tensorflow.Cpuinfo.Builder {
                return try Tensorflow.Cpuinfo.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.Cpuinfo {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.Cpuinfo {
                let returnMe:Tensorflow.Cpuinfo = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.Cpuinfo) throws -> Tensorflow.Cpuinfo.Builder {
                if other == Tensorflow.Cpuinfo() {
                    return self
                }
                if other.hasNumCores {
                    numCores = other.numCores
                }
                if other.hasNumCoresAllowed {
                    numCoresAllowed = other.numCoresAllowed
                }
                if other.hasMhzPerCpu {
                    mhzPerCpu = other.mhzPerCpu
                }
                if other.hasCpuInfo {
                    cpuInfo = other.cpuInfo
                }
                if other.hasCpuGovernor {
                    cpuGovernor = other.cpuGovernor
                }
                if other.hasCacheSize {
                    cacheSize = other.cacheSize
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Cpuinfo.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Cpuinfo.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        numCores = try codedInputStream.readInt64()

                    case 16:
                        numCoresAllowed = try codedInputStream.readInt64()

                    case 25:
                        mhzPerCpu = try codedInputStream.readDouble()

                    case 34:
                        cpuInfo = try codedInputStream.readString()

                    case 42:
                        cpuGovernor = try codedInputStream.readString()

                    case 50:
                        let subBuilder = Tensorflow.Cpuinfo.CacheSizeEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfCacheSize = subBuilder.buildPartial()
                        cacheSize[buildOfCacheSize.key] = buildOfCacheSize.value

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Cpuinfo.Builder {
                let resultDecodedBuilder = Tensorflow.Cpuinfo.Builder()
                if let jsonValueNumCores = jsonMap["numCores"] as? String {
                    resultDecodedBuilder.numCores = Int64(jsonValueNumCores)!
                } else if let jsonValueNumCores = jsonMap["numCores"] as? Int {
                    resultDecodedBuilder.numCores = Int64(jsonValueNumCores)
                }
                if let jsonValueNumCoresAllowed = jsonMap["numCoresAllowed"] as? String {
                    resultDecodedBuilder.numCoresAllowed = Int64(jsonValueNumCoresAllowed)!
                } else if let jsonValueNumCoresAllowed = jsonMap["numCoresAllowed"] as? Int {
                    resultDecodedBuilder.numCoresAllowed = Int64(jsonValueNumCoresAllowed)
                }
                if let jsonValueMhzPerCpu = jsonMap["mhzPerCpu"] as? Double {
                    resultDecodedBuilder.mhzPerCpu = Double(jsonValueMhzPerCpu)
                } else if let jsonValueMhzPerCpu = jsonMap["mhzPerCpu"] as? String {
                    resultDecodedBuilder.mhzPerCpu = Double(jsonValueMhzPerCpu)!
                }
                if let jsonValueCpuInfo = jsonMap["cpuInfo"] as? String {
                    resultDecodedBuilder.cpuInfo = jsonValueCpuInfo
                }
                if let jsonValueCpuGovernor = jsonMap["cpuGovernor"] as? String {
                    resultDecodedBuilder.cpuGovernor = jsonValueCpuGovernor
                }
                if let jsonValueCacheSize = jsonMap["cacheSize"] as? Dictionary<String, String> {
                    var mapCacheSize = Dictionary<String, Int64>()
                    for (keyCacheSize, valueCacheSize) in jsonValueCacheSize {
                        guard let keyFromCacheSize = String(keyCacheSize) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapCacheSize[keyFromCacheSize] = Int64(valueCacheSize)!
                    }
                    resultDecodedBuilder.cacheSize = mapCacheSize
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Cpuinfo.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.Cpuinfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class MemoryInfo : GeneratedMessage {

        public static func == (lhs: Tensorflow.MemoryInfo, rhs: Tensorflow.MemoryInfo) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasTotal == rhs.hasTotal) && (!lhs.hasTotal || lhs.total == rhs.total)
            fieldCheck = fieldCheck && (lhs.hasAvailable == rhs.hasAvailable) && (!lhs.hasAvailable || lhs.available == rhs.available)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Total virtual memory in bytes
        public fileprivate(set) var total:Int64 = Int64(0)
        public fileprivate(set) var hasTotal:Bool = false

        /// Immediately available memory in bytes
        public fileprivate(set) var available:Int64 = Int64(0)
        public fileprivate(set) var hasAvailable:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasTotal {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:total)
            }
            if hasAvailable {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:available)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasTotal {
                serialize_size += total.computeInt64Size(fieldNumber: 1)
            }
            if hasAvailable {
                serialize_size += available.computeInt64Size(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.MemoryInfo.Builder {
            return Tensorflow.MemoryInfo.classBuilder() as! Tensorflow.MemoryInfo.Builder
        }
        public func getBuilder() -> Tensorflow.MemoryInfo.Builder {
            return classBuilder() as! Tensorflow.MemoryInfo.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.MemoryInfo.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.MemoryInfo.Builder()
        }
        public func toBuilder() throws -> Tensorflow.MemoryInfo.Builder {
            return try Tensorflow.MemoryInfo.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.MemoryInfo) throws -> Tensorflow.MemoryInfo.Builder {
            return try Tensorflow.MemoryInfo.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasTotal {
                jsonMap["total"] = "\(total)"
            }
            if hasAvailable {
                jsonMap["available"] = "\(available)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.MemoryInfo {
            return try Tensorflow.MemoryInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.MemoryInfo {
            return try Tensorflow.MemoryInfo.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasTotal {
                output += "\(indent) total: \(total) \n"
            }
            if hasAvailable {
                output += "\(indent) available: \(available) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasTotal {
                    hashCode = (hashCode &* 31) &+ total.hashValue
                }
                if hasAvailable {
                    hashCode = (hashCode &* 31) &+ available.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.MemoryInfo"
        }
        override public func className() -> String {
            return "Tensorflow.MemoryInfo"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.MemoryInfo = Tensorflow.MemoryInfo()
            public func getMessage() -> Tensorflow.MemoryInfo {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Total virtual memory in bytes
            public var total:Int64 {
                get {
                    return builderResult.total
                }
                set (value) {
                    builderResult.hasTotal = true
                    builderResult.total = value
                }
            }
            public var hasTotal:Bool {
                get {
                    return builderResult.hasTotal
                }
            }
            @discardableResult
            public func setTotal(_ value:Int64) -> Tensorflow.MemoryInfo.Builder {
                self.total = value
                return self
            }
            @discardableResult
            public func clearTotal() -> Tensorflow.MemoryInfo.Builder{
                builderResult.hasTotal = false
                builderResult.total = Int64(0)
                return self
            }
            /// Immediately available memory in bytes
            public var available:Int64 {
                get {
                    return builderResult.available
                }
                set (value) {
                    builderResult.hasAvailable = true
                    builderResult.available = value
                }
            }
            public var hasAvailable:Bool {
                get {
                    return builderResult.hasAvailable
                }
            }
            @discardableResult
            public func setAvailable(_ value:Int64) -> Tensorflow.MemoryInfo.Builder {
                self.available = value
                return self
            }
            @discardableResult
            public func clearAvailable() -> Tensorflow.MemoryInfo.Builder{
                builderResult.hasAvailable = false
                builderResult.available = Int64(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.MemoryInfo.Builder {
                builderResult = Tensorflow.MemoryInfo()
                return self
            }
            override public func clone() throws -> Tensorflow.MemoryInfo.Builder {
                return try Tensorflow.MemoryInfo.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.MemoryInfo {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.MemoryInfo {
                let returnMe:Tensorflow.MemoryInfo = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.MemoryInfo) throws -> Tensorflow.MemoryInfo.Builder {
                if other == Tensorflow.MemoryInfo() {
                    return self
                }
                if other.hasTotal {
                    total = other.total
                }
                if other.hasAvailable {
                    available = other.available
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.MemoryInfo.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryInfo.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        total = try codedInputStream.readInt64()

                    case 16:
                        available = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.MemoryInfo.Builder {
                let resultDecodedBuilder = Tensorflow.MemoryInfo.Builder()
                if let jsonValueTotal = jsonMap["total"] as? String {
                    resultDecodedBuilder.total = Int64(jsonValueTotal)!
                } else if let jsonValueTotal = jsonMap["total"] as? Int {
                    resultDecodedBuilder.total = Int64(jsonValueTotal)
                }
                if let jsonValueAvailable = jsonMap["available"] as? String {
                    resultDecodedBuilder.available = Int64(jsonValueAvailable)!
                } else if let jsonValueAvailable = jsonMap["available"] as? Int {
                    resultDecodedBuilder.available = Int64(jsonValueAvailable)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.MemoryInfo.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.MemoryInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class Gpuinfo : GeneratedMessage {

        public static func == (lhs: Tensorflow.Gpuinfo, rhs: Tensorflow.Gpuinfo) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasModel == rhs.hasModel) && (!lhs.hasModel || lhs.model == rhs.model)
            fieldCheck = fieldCheck && (lhs.hasUuid == rhs.hasUuid) && (!lhs.hasUuid || lhs.uuid == rhs.uuid)
            fieldCheck = fieldCheck && (lhs.hasBusId == rhs.hasBusId) && (!lhs.hasBusId || lhs.busId == rhs.busId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// e.g. "Tesla K40c"
        public fileprivate(set) var model:String = ""
        public fileprivate(set) var hasModel:Bool = false

        /// Final entry in output of "nvidia-smi -L"
        public fileprivate(set) var uuid:String = ""
        public fileprivate(set) var hasUuid:Bool = false

        /// e.g. "0000:04:00.0"
        public fileprivate(set) var busId:String = ""
        public fileprivate(set) var hasBusId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasModel {
                try codedOutputStream.writeString(fieldNumber: 1, value:model)
            }
            if hasUuid {
                try codedOutputStream.writeString(fieldNumber: 2, value:uuid)
            }
            if hasBusId {
                try codedOutputStream.writeString(fieldNumber: 3, value:busId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasModel {
                serialize_size += model.computeStringSize(fieldNumber: 1)
            }
            if hasUuid {
                serialize_size += uuid.computeStringSize(fieldNumber: 2)
            }
            if hasBusId {
                serialize_size += busId.computeStringSize(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.Gpuinfo.Builder {
            return Tensorflow.Gpuinfo.classBuilder() as! Tensorflow.Gpuinfo.Builder
        }
        public func getBuilder() -> Tensorflow.Gpuinfo.Builder {
            return classBuilder() as! Tensorflow.Gpuinfo.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Gpuinfo.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Gpuinfo.Builder()
        }
        public func toBuilder() throws -> Tensorflow.Gpuinfo.Builder {
            return try Tensorflow.Gpuinfo.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.Gpuinfo) throws -> Tensorflow.Gpuinfo.Builder {
            return try Tensorflow.Gpuinfo.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasModel {
                jsonMap["model"] = model
            }
            if hasUuid {
                jsonMap["uuid"] = uuid
            }
            if hasBusId {
                jsonMap["busId"] = busId
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Gpuinfo {
            return try Tensorflow.Gpuinfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.Gpuinfo {
            return try Tensorflow.Gpuinfo.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasModel {
                output += "\(indent) model: \(model) \n"
            }
            if hasUuid {
                output += "\(indent) uuid: \(uuid) \n"
            }
            if hasBusId {
                output += "\(indent) busId: \(busId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasModel {
                    hashCode = (hashCode &* 31) &+ model.hashValue
                }
                if hasUuid {
                    hashCode = (hashCode &* 31) &+ uuid.hashValue
                }
                if hasBusId {
                    hashCode = (hashCode &* 31) &+ busId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.Gpuinfo"
        }
        override public func className() -> String {
            return "Tensorflow.Gpuinfo"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.Gpuinfo = Tensorflow.Gpuinfo()
            public func getMessage() -> Tensorflow.Gpuinfo {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// e.g. "Tesla K40c"
            public var model:String {
                get {
                    return builderResult.model
                }
                set (value) {
                    builderResult.hasModel = true
                    builderResult.model = value
                }
            }
            public var hasModel:Bool {
                get {
                    return builderResult.hasModel
                }
            }
            @discardableResult
            public func setModel(_ value:String) -> Tensorflow.Gpuinfo.Builder {
                self.model = value
                return self
            }
            @discardableResult
            public func clearModel() -> Tensorflow.Gpuinfo.Builder{
                builderResult.hasModel = false
                builderResult.model = ""
                return self
            }
            /// Final entry in output of "nvidia-smi -L"
            public var uuid:String {
                get {
                    return builderResult.uuid
                }
                set (value) {
                    builderResult.hasUuid = true
                    builderResult.uuid = value
                }
            }
            public var hasUuid:Bool {
                get {
                    return builderResult.hasUuid
                }
            }
            @discardableResult
            public func setUuid(_ value:String) -> Tensorflow.Gpuinfo.Builder {
                self.uuid = value
                return self
            }
            @discardableResult
            public func clearUuid() -> Tensorflow.Gpuinfo.Builder{
                builderResult.hasUuid = false
                builderResult.uuid = ""
                return self
            }
            /// e.g. "0000:04:00.0"
            public var busId:String {
                get {
                    return builderResult.busId
                }
                set (value) {
                    builderResult.hasBusId = true
                    builderResult.busId = value
                }
            }
            public var hasBusId:Bool {
                get {
                    return builderResult.hasBusId
                }
            }
            @discardableResult
            public func setBusId(_ value:String) -> Tensorflow.Gpuinfo.Builder {
                self.busId = value
                return self
            }
            @discardableResult
            public func clearBusId() -> Tensorflow.Gpuinfo.Builder{
                builderResult.hasBusId = false
                builderResult.busId = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.Gpuinfo.Builder {
                builderResult = Tensorflow.Gpuinfo()
                return self
            }
            override public func clone() throws -> Tensorflow.Gpuinfo.Builder {
                return try Tensorflow.Gpuinfo.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.Gpuinfo {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.Gpuinfo {
                let returnMe:Tensorflow.Gpuinfo = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.Gpuinfo) throws -> Tensorflow.Gpuinfo.Builder {
                if other == Tensorflow.Gpuinfo() {
                    return self
                }
                if other.hasModel {
                    model = other.model
                }
                if other.hasUuid {
                    uuid = other.uuid
                }
                if other.hasBusId {
                    busId = other.busId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Gpuinfo.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Gpuinfo.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        model = try codedInputStream.readString()

                    case 18:
                        uuid = try codedInputStream.readString()

                    case 26:
                        busId = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Gpuinfo.Builder {
                let resultDecodedBuilder = Tensorflow.Gpuinfo.Builder()
                if let jsonValueModel = jsonMap["model"] as? String {
                    resultDecodedBuilder.model = jsonValueModel
                }
                if let jsonValueUuid = jsonMap["uuid"] as? String {
                    resultDecodedBuilder.uuid = jsonValueUuid
                }
                if let jsonValueBusId = jsonMap["busId"] as? String {
                    resultDecodedBuilder.busId = jsonValueBusId
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Gpuinfo.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.Gpuinfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class PlatformInfo : GeneratedMessage {

        public static func == (lhs: Tensorflow.PlatformInfo, rhs: Tensorflow.PlatformInfo) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasBits == rhs.hasBits) && (!lhs.hasBits || lhs.bits == rhs.bits)
            fieldCheck = fieldCheck && (lhs.hasLinkage == rhs.hasLinkage) && (!lhs.hasLinkage || lhs.linkage == rhs.linkage)
            fieldCheck = fieldCheck && (lhs.hasMachine == rhs.hasMachine) && (!lhs.hasMachine || lhs.machine == rhs.machine)
            fieldCheck = fieldCheck && (lhs.hasRelease == rhs.hasRelease) && (!lhs.hasRelease || lhs.release == rhs.release)
            fieldCheck = fieldCheck && (lhs.hasSystem == rhs.hasSystem) && (!lhs.hasSystem || lhs.system == rhs.system)
            fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// e.g. '64bit'
        public fileprivate(set) var bits:String = ""
        public fileprivate(set) var hasBits:Bool = false

        /// e.g. 'ELF'
        public fileprivate(set) var linkage:String = ""
        public fileprivate(set) var hasLinkage:Bool = false

        /// e.g. 'i386'
        public fileprivate(set) var machine:String = ""
        public fileprivate(set) var hasMachine:Bool = false

        /// e.g. '3.13.0-76-generic'
        public fileprivate(set) var release:String = ""
        public fileprivate(set) var hasRelease:Bool = false

        /// e.g. 'Linux'
        public fileprivate(set) var system:String = ""
        public fileprivate(set) var hasSystem:Bool = false

        /// e.g. '#120-Ubuntu SMP Mon Jan 18 15:59:10 UTC 2016'
        public fileprivate(set) var version:String = ""
        public fileprivate(set) var hasVersion:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasBits {
                try codedOutputStream.writeString(fieldNumber: 1, value:bits)
            }
            if hasLinkage {
                try codedOutputStream.writeString(fieldNumber: 2, value:linkage)
            }
            if hasMachine {
                try codedOutputStream.writeString(fieldNumber: 3, value:machine)
            }
            if hasRelease {
                try codedOutputStream.writeString(fieldNumber: 4, value:release)
            }
            if hasSystem {
                try codedOutputStream.writeString(fieldNumber: 5, value:system)
            }
            if hasVersion {
                try codedOutputStream.writeString(fieldNumber: 6, value:version)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasBits {
                serialize_size += bits.computeStringSize(fieldNumber: 1)
            }
            if hasLinkage {
                serialize_size += linkage.computeStringSize(fieldNumber: 2)
            }
            if hasMachine {
                serialize_size += machine.computeStringSize(fieldNumber: 3)
            }
            if hasRelease {
                serialize_size += release.computeStringSize(fieldNumber: 4)
            }
            if hasSystem {
                serialize_size += system.computeStringSize(fieldNumber: 5)
            }
            if hasVersion {
                serialize_size += version.computeStringSize(fieldNumber: 6)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.PlatformInfo.Builder {
            return Tensorflow.PlatformInfo.classBuilder() as! Tensorflow.PlatformInfo.Builder
        }
        public func getBuilder() -> Tensorflow.PlatformInfo.Builder {
            return classBuilder() as! Tensorflow.PlatformInfo.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.PlatformInfo.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.PlatformInfo.Builder()
        }
        public func toBuilder() throws -> Tensorflow.PlatformInfo.Builder {
            return try Tensorflow.PlatformInfo.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.PlatformInfo) throws -> Tensorflow.PlatformInfo.Builder {
            return try Tensorflow.PlatformInfo.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasBits {
                jsonMap["bits"] = bits
            }
            if hasLinkage {
                jsonMap["linkage"] = linkage
            }
            if hasMachine {
                jsonMap["machine"] = machine
            }
            if hasRelease {
                jsonMap["release"] = release
            }
            if hasSystem {
                jsonMap["system"] = system
            }
            if hasVersion {
                jsonMap["version"] = version
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.PlatformInfo {
            return try Tensorflow.PlatformInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.PlatformInfo {
            return try Tensorflow.PlatformInfo.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasBits {
                output += "\(indent) bits: \(bits) \n"
            }
            if hasLinkage {
                output += "\(indent) linkage: \(linkage) \n"
            }
            if hasMachine {
                output += "\(indent) machine: \(machine) \n"
            }
            if hasRelease {
                output += "\(indent) release: \(release) \n"
            }
            if hasSystem {
                output += "\(indent) system: \(system) \n"
            }
            if hasVersion {
                output += "\(indent) version: \(version) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasBits {
                    hashCode = (hashCode &* 31) &+ bits.hashValue
                }
                if hasLinkage {
                    hashCode = (hashCode &* 31) &+ linkage.hashValue
                }
                if hasMachine {
                    hashCode = (hashCode &* 31) &+ machine.hashValue
                }
                if hasRelease {
                    hashCode = (hashCode &* 31) &+ release.hashValue
                }
                if hasSystem {
                    hashCode = (hashCode &* 31) &+ system.hashValue
                }
                if hasVersion {
                    hashCode = (hashCode &* 31) &+ version.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.PlatformInfo"
        }
        override public func className() -> String {
            return "Tensorflow.PlatformInfo"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.PlatformInfo = Tensorflow.PlatformInfo()
            public func getMessage() -> Tensorflow.PlatformInfo {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// e.g. '64bit'
            public var bits:String {
                get {
                    return builderResult.bits
                }
                set (value) {
                    builderResult.hasBits = true
                    builderResult.bits = value
                }
            }
            public var hasBits:Bool {
                get {
                    return builderResult.hasBits
                }
            }
            @discardableResult
            public func setBits(_ value:String) -> Tensorflow.PlatformInfo.Builder {
                self.bits = value
                return self
            }
            @discardableResult
            public func clearBits() -> Tensorflow.PlatformInfo.Builder{
                builderResult.hasBits = false
                builderResult.bits = ""
                return self
            }
            /// e.g. 'ELF'
            public var linkage:String {
                get {
                    return builderResult.linkage
                }
                set (value) {
                    builderResult.hasLinkage = true
                    builderResult.linkage = value
                }
            }
            public var hasLinkage:Bool {
                get {
                    return builderResult.hasLinkage
                }
            }
            @discardableResult
            public func setLinkage(_ value:String) -> Tensorflow.PlatformInfo.Builder {
                self.linkage = value
                return self
            }
            @discardableResult
            public func clearLinkage() -> Tensorflow.PlatformInfo.Builder{
                builderResult.hasLinkage = false
                builderResult.linkage = ""
                return self
            }
            /// e.g. 'i386'
            public var machine:String {
                get {
                    return builderResult.machine
                }
                set (value) {
                    builderResult.hasMachine = true
                    builderResult.machine = value
                }
            }
            public var hasMachine:Bool {
                get {
                    return builderResult.hasMachine
                }
            }
            @discardableResult
            public func setMachine(_ value:String) -> Tensorflow.PlatformInfo.Builder {
                self.machine = value
                return self
            }
            @discardableResult
            public func clearMachine() -> Tensorflow.PlatformInfo.Builder{
                builderResult.hasMachine = false
                builderResult.machine = ""
                return self
            }
            /// e.g. '3.13.0-76-generic'
            public var release:String {
                get {
                    return builderResult.release
                }
                set (value) {
                    builderResult.hasRelease = true
                    builderResult.release = value
                }
            }
            public var hasRelease:Bool {
                get {
                    return builderResult.hasRelease
                }
            }
            @discardableResult
            public func setRelease(_ value:String) -> Tensorflow.PlatformInfo.Builder {
                self.release = value
                return self
            }
            @discardableResult
            public func clearRelease() -> Tensorflow.PlatformInfo.Builder{
                builderResult.hasRelease = false
                builderResult.release = ""
                return self
            }
            /// e.g. 'Linux'
            public var system:String {
                get {
                    return builderResult.system
                }
                set (value) {
                    builderResult.hasSystem = true
                    builderResult.system = value
                }
            }
            public var hasSystem:Bool {
                get {
                    return builderResult.hasSystem
                }
            }
            @discardableResult
            public func setSystem(_ value:String) -> Tensorflow.PlatformInfo.Builder {
                self.system = value
                return self
            }
            @discardableResult
            public func clearSystem() -> Tensorflow.PlatformInfo.Builder{
                builderResult.hasSystem = false
                builderResult.system = ""
                return self
            }
            /// e.g. '#120-Ubuntu SMP Mon Jan 18 15:59:10 UTC 2016'
            public var version:String {
                get {
                    return builderResult.version
                }
                set (value) {
                    builderResult.hasVersion = true
                    builderResult.version = value
                }
            }
            public var hasVersion:Bool {
                get {
                    return builderResult.hasVersion
                }
            }
            @discardableResult
            public func setVersion(_ value:String) -> Tensorflow.PlatformInfo.Builder {
                self.version = value
                return self
            }
            @discardableResult
            public func clearVersion() -> Tensorflow.PlatformInfo.Builder{
                builderResult.hasVersion = false
                builderResult.version = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.PlatformInfo.Builder {
                builderResult = Tensorflow.PlatformInfo()
                return self
            }
            override public func clone() throws -> Tensorflow.PlatformInfo.Builder {
                return try Tensorflow.PlatformInfo.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.PlatformInfo {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.PlatformInfo {
                let returnMe:Tensorflow.PlatformInfo = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.PlatformInfo) throws -> Tensorflow.PlatformInfo.Builder {
                if other == Tensorflow.PlatformInfo() {
                    return self
                }
                if other.hasBits {
                    bits = other.bits
                }
                if other.hasLinkage {
                    linkage = other.linkage
                }
                if other.hasMachine {
                    machine = other.machine
                }
                if other.hasRelease {
                    release = other.release
                }
                if other.hasSystem {
                    system = other.system
                }
                if other.hasVersion {
                    version = other.version
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.PlatformInfo.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.PlatformInfo.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        bits = try codedInputStream.readString()

                    case 18:
                        linkage = try codedInputStream.readString()

                    case 26:
                        machine = try codedInputStream.readString()

                    case 34:
                        release = try codedInputStream.readString()

                    case 42:
                        system = try codedInputStream.readString()

                    case 50:
                        version = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.PlatformInfo.Builder {
                let resultDecodedBuilder = Tensorflow.PlatformInfo.Builder()
                if let jsonValueBits = jsonMap["bits"] as? String {
                    resultDecodedBuilder.bits = jsonValueBits
                }
                if let jsonValueLinkage = jsonMap["linkage"] as? String {
                    resultDecodedBuilder.linkage = jsonValueLinkage
                }
                if let jsonValueMachine = jsonMap["machine"] as? String {
                    resultDecodedBuilder.machine = jsonValueMachine
                }
                if let jsonValueRelease = jsonMap["release"] as? String {
                    resultDecodedBuilder.release = jsonValueRelease
                }
                if let jsonValueSystem = jsonMap["system"] as? String {
                    resultDecodedBuilder.system = jsonValueSystem
                }
                if let jsonValueVersion = jsonMap["version"] as? String {
                    resultDecodedBuilder.version = jsonValueVersion
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.PlatformInfo.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.PlatformInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Matches DeviceAttributes
    final public class AvailableDeviceInfo : GeneratedMessage {

        public static func == (lhs: Tensorflow.AvailableDeviceInfo, rhs: Tensorflow.AvailableDeviceInfo) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
            fieldCheck = fieldCheck && (lhs.hasType == rhs.hasType) && (!lhs.hasType || lhs.type == rhs.type)
            fieldCheck = fieldCheck && (lhs.hasMemoryLimit == rhs.hasMemoryLimit) && (!lhs.hasMemoryLimit || lhs.memoryLimit == rhs.memoryLimit)
            fieldCheck = fieldCheck && (lhs.hasPhysicalDescription == rhs.hasPhysicalDescription) && (!lhs.hasPhysicalDescription || lhs.physicalDescription == rhs.physicalDescription)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Device name.
        public fileprivate(set) var name:String = ""
        public fileprivate(set) var hasName:Bool = false

        /// Device type, e.g. 'CPU' or 'GPU'.
        public fileprivate(set) var type:String = ""
        public fileprivate(set) var hasType:Bool = false

        /// Memory capacity in bytes.
        public fileprivate(set) var memoryLimit:Int64 = Int64(0)
        public fileprivate(set) var hasMemoryLimit:Bool = false

        /// The physical description of this device.
        public fileprivate(set) var physicalDescription:String = ""
        public fileprivate(set) var hasPhysicalDescription:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasName {
                try codedOutputStream.writeString(fieldNumber: 1, value:name)
            }
            if hasType {
                try codedOutputStream.writeString(fieldNumber: 2, value:type)
            }
            if hasMemoryLimit {
                try codedOutputStream.writeInt64(fieldNumber: 3, value:memoryLimit)
            }
            if hasPhysicalDescription {
                try codedOutputStream.writeString(fieldNumber: 4, value:physicalDescription)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasName {
                serialize_size += name.computeStringSize(fieldNumber: 1)
            }
            if hasType {
                serialize_size += type.computeStringSize(fieldNumber: 2)
            }
            if hasMemoryLimit {
                serialize_size += memoryLimit.computeInt64Size(fieldNumber: 3)
            }
            if hasPhysicalDescription {
                serialize_size += physicalDescription.computeStringSize(fieldNumber: 4)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.AvailableDeviceInfo.Builder {
            return Tensorflow.AvailableDeviceInfo.classBuilder() as! Tensorflow.AvailableDeviceInfo.Builder
        }
        public func getBuilder() -> Tensorflow.AvailableDeviceInfo.Builder {
            return classBuilder() as! Tensorflow.AvailableDeviceInfo.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.AvailableDeviceInfo.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.AvailableDeviceInfo.Builder()
        }
        public func toBuilder() throws -> Tensorflow.AvailableDeviceInfo.Builder {
            return try Tensorflow.AvailableDeviceInfo.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.AvailableDeviceInfo) throws -> Tensorflow.AvailableDeviceInfo.Builder {
            return try Tensorflow.AvailableDeviceInfo.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasName {
                jsonMap["name"] = name
            }
            if hasType {
                jsonMap["type"] = type
            }
            if hasMemoryLimit {
                jsonMap["memoryLimit"] = "\(memoryLimit)"
            }
            if hasPhysicalDescription {
                jsonMap["physicalDescription"] = physicalDescription
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.AvailableDeviceInfo {
            return try Tensorflow.AvailableDeviceInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.AvailableDeviceInfo {
            return try Tensorflow.AvailableDeviceInfo.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasName {
                output += "\(indent) name: \(name) \n"
            }
            if hasType {
                output += "\(indent) type: \(type) \n"
            }
            if hasMemoryLimit {
                output += "\(indent) memoryLimit: \(memoryLimit) \n"
            }
            if hasPhysicalDescription {
                output += "\(indent) physicalDescription: \(physicalDescription) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasName {
                    hashCode = (hashCode &* 31) &+ name.hashValue
                }
                if hasType {
                    hashCode = (hashCode &* 31) &+ type.hashValue
                }
                if hasMemoryLimit {
                    hashCode = (hashCode &* 31) &+ memoryLimit.hashValue
                }
                if hasPhysicalDescription {
                    hashCode = (hashCode &* 31) &+ physicalDescription.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.AvailableDeviceInfo"
        }
        override public func className() -> String {
            return "Tensorflow.AvailableDeviceInfo"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.AvailableDeviceInfo = Tensorflow.AvailableDeviceInfo()
            public func getMessage() -> Tensorflow.AvailableDeviceInfo {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Device name.
            public var name:String {
                get {
                    return builderResult.name
                }
                set (value) {
                    builderResult.hasName = true
                    builderResult.name = value
                }
            }
            public var hasName:Bool {
                get {
                    return builderResult.hasName
                }
            }
            @discardableResult
            public func setName(_ value:String) -> Tensorflow.AvailableDeviceInfo.Builder {
                self.name = value
                return self
            }
            @discardableResult
            public func clearName() -> Tensorflow.AvailableDeviceInfo.Builder{
                builderResult.hasName = false
                builderResult.name = ""
                return self
            }
            /// Device type, e.g. 'CPU' or 'GPU'.
            public var type:String {
                get {
                    return builderResult.type
                }
                set (value) {
                    builderResult.hasType = true
                    builderResult.type = value
                }
            }
            public var hasType:Bool {
                get {
                    return builderResult.hasType
                }
            }
            @discardableResult
            public func setType(_ value:String) -> Tensorflow.AvailableDeviceInfo.Builder {
                self.type = value
                return self
            }
            @discardableResult
            public func clearType() -> Tensorflow.AvailableDeviceInfo.Builder{
                builderResult.hasType = false
                builderResult.type = ""
                return self
            }
            /// Memory capacity in bytes.
            public var memoryLimit:Int64 {
                get {
                    return builderResult.memoryLimit
                }
                set (value) {
                    builderResult.hasMemoryLimit = true
                    builderResult.memoryLimit = value
                }
            }
            public var hasMemoryLimit:Bool {
                get {
                    return builderResult.hasMemoryLimit
                }
            }
            @discardableResult
            public func setMemoryLimit(_ value:Int64) -> Tensorflow.AvailableDeviceInfo.Builder {
                self.memoryLimit = value
                return self
            }
            @discardableResult
            public func clearMemoryLimit() -> Tensorflow.AvailableDeviceInfo.Builder{
                builderResult.hasMemoryLimit = false
                builderResult.memoryLimit = Int64(0)
                return self
            }
            /// The physical description of this device.
            public var physicalDescription:String {
                get {
                    return builderResult.physicalDescription
                }
                set (value) {
                    builderResult.hasPhysicalDescription = true
                    builderResult.physicalDescription = value
                }
            }
            public var hasPhysicalDescription:Bool {
                get {
                    return builderResult.hasPhysicalDescription
                }
            }
            @discardableResult
            public func setPhysicalDescription(_ value:String) -> Tensorflow.AvailableDeviceInfo.Builder {
                self.physicalDescription = value
                return self
            }
            @discardableResult
            public func clearPhysicalDescription() -> Tensorflow.AvailableDeviceInfo.Builder{
                builderResult.hasPhysicalDescription = false
                builderResult.physicalDescription = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.AvailableDeviceInfo.Builder {
                builderResult = Tensorflow.AvailableDeviceInfo()
                return self
            }
            override public func clone() throws -> Tensorflow.AvailableDeviceInfo.Builder {
                return try Tensorflow.AvailableDeviceInfo.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.AvailableDeviceInfo {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.AvailableDeviceInfo {
                let returnMe:Tensorflow.AvailableDeviceInfo = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.AvailableDeviceInfo) throws -> Tensorflow.AvailableDeviceInfo.Builder {
                if other == Tensorflow.AvailableDeviceInfo() {
                    return self
                }
                if other.hasName {
                    name = other.name
                }
                if other.hasType {
                    type = other.type
                }
                if other.hasMemoryLimit {
                    memoryLimit = other.memoryLimit
                }
                if other.hasPhysicalDescription {
                    physicalDescription = other.physicalDescription
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.AvailableDeviceInfo.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.AvailableDeviceInfo.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        name = try codedInputStream.readString()

                    case 18:
                        type = try codedInputStream.readString()

                    case 24:
                        memoryLimit = try codedInputStream.readInt64()

                    case 34:
                        physicalDescription = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.AvailableDeviceInfo.Builder {
                let resultDecodedBuilder = Tensorflow.AvailableDeviceInfo.Builder()
                if let jsonValueName = jsonMap["name"] as? String {
                    resultDecodedBuilder.name = jsonValueName
                }
                if let jsonValueType = jsonMap["type"] as? String {
                    resultDecodedBuilder.type = jsonValueType
                }
                if let jsonValueMemoryLimit = jsonMap["memoryLimit"] as? String {
                    resultDecodedBuilder.memoryLimit = Int64(jsonValueMemoryLimit)!
                } else if let jsonValueMemoryLimit = jsonMap["memoryLimit"] as? Int {
                    resultDecodedBuilder.memoryLimit = Int64(jsonValueMemoryLimit)
                }
                if let jsonValuePhysicalDescription = jsonMap["physicalDescription"] as? String {
                    resultDecodedBuilder.physicalDescription = jsonValuePhysicalDescription
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.AvailableDeviceInfo.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.AvailableDeviceInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class MachineConfiguration : GeneratedMessage {

        public static func == (lhs: Tensorflow.MachineConfiguration, rhs: Tensorflow.MachineConfiguration) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasHostname == rhs.hasHostname) && (!lhs.hasHostname || lhs.hostname == rhs.hostname)
            fieldCheck = fieldCheck && (lhs.hasPlatformInfo == rhs.hasPlatformInfo) && (!lhs.hasPlatformInfo || lhs.platformInfo == rhs.platformInfo)
            fieldCheck = fieldCheck && (lhs.hasCpuInfo == rhs.hasCpuInfo) && (!lhs.hasCpuInfo || lhs.cpuInfo == rhs.cpuInfo)
            fieldCheck = fieldCheck && (lhs.deviceInfo == rhs.deviceInfo)
            fieldCheck = fieldCheck && (lhs.availableDeviceInfo == rhs.availableDeviceInfo)
            fieldCheck = fieldCheck && (lhs.hasMemoryInfo == rhs.hasMemoryInfo) && (!lhs.hasMemoryInfo || lhs.memoryInfo == rhs.memoryInfo)
            fieldCheck = fieldCheck && (lhs.hasSerialIdentifier == rhs.hasSerialIdentifier) && (!lhs.hasSerialIdentifier || lhs.serialIdentifier == rhs.serialIdentifier)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Host name of machine that ran the benchmark.
        public fileprivate(set) var hostname:String = ""
        public fileprivate(set) var hasHostname:Bool = false

        /// Unique serial number of the machine.
        public fileprivate(set) var serialIdentifier:String = ""
        public fileprivate(set) var hasSerialIdentifier:Bool = false

        public fileprivate(set) var platformInfo:Tensorflow.PlatformInfo!
        public fileprivate(set) var hasPlatformInfo:Bool = false
        public fileprivate(set) var cpuInfo:Tensorflow.Cpuinfo!
        public fileprivate(set) var hasCpuInfo:Bool = false
        public fileprivate(set) var deviceInfo:Array<Google.Protobuf.`Any`>  = Array<Google.Protobuf.`Any`>()
        public fileprivate(set) var availableDeviceInfo:Array<Tensorflow.AvailableDeviceInfo>  = Array<Tensorflow.AvailableDeviceInfo>()
        public fileprivate(set) var memoryInfo:Tensorflow.MemoryInfo!
        public fileprivate(set) var hasMemoryInfo:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasHostname {
                try codedOutputStream.writeString(fieldNumber: 1, value:hostname)
            }
            if hasPlatformInfo {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:platformInfo)
            }
            if hasCpuInfo {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:cpuInfo)
            }
            for oneElementDeviceInfo in deviceInfo {
                  try codedOutputStream.writeMessage(fieldNumber: 4, value:oneElementDeviceInfo)
            }
            for oneElementAvailableDeviceInfo in availableDeviceInfo {
                  try codedOutputStream.writeMessage(fieldNumber: 5, value:oneElementAvailableDeviceInfo)
            }
            if hasMemoryInfo {
                try codedOutputStream.writeMessage(fieldNumber: 6, value:memoryInfo)
            }
            if hasSerialIdentifier {
                try codedOutputStream.writeString(fieldNumber: 7, value:serialIdentifier)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasHostname {
                serialize_size += hostname.computeStringSize(fieldNumber: 1)
            }
            if hasPlatformInfo {
                if let varSizeplatformInfo = platformInfo?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeplatformInfo
                }
            }
            if hasCpuInfo {
                if let varSizecpuInfo = cpuInfo?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizecpuInfo
                }
            }
            for oneElementDeviceInfo in deviceInfo {
                serialize_size += oneElementDeviceInfo.computeMessageSize(fieldNumber: 4)
            }
            for oneElementAvailableDeviceInfo in availableDeviceInfo {
                serialize_size += oneElementAvailableDeviceInfo.computeMessageSize(fieldNumber: 5)
            }
            if hasMemoryInfo {
                if let varSizememoryInfo = memoryInfo?.computeMessageSize(fieldNumber: 6) {
                    serialize_size += varSizememoryInfo
                }
            }
            if hasSerialIdentifier {
                serialize_size += serialIdentifier.computeStringSize(fieldNumber: 7)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.MachineConfiguration.Builder {
            return Tensorflow.MachineConfiguration.classBuilder() as! Tensorflow.MachineConfiguration.Builder
        }
        public func getBuilder() -> Tensorflow.MachineConfiguration.Builder {
            return classBuilder() as! Tensorflow.MachineConfiguration.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.MachineConfiguration.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.MachineConfiguration.Builder()
        }
        public func toBuilder() throws -> Tensorflow.MachineConfiguration.Builder {
            return try Tensorflow.MachineConfiguration.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.MachineConfiguration) throws -> Tensorflow.MachineConfiguration.Builder {
            return try Tensorflow.MachineConfiguration.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasHostname {
                jsonMap["hostname"] = hostname
            }
            if hasSerialIdentifier {
                jsonMap["serialIdentifier"] = serialIdentifier
            }
            if hasPlatformInfo {
                jsonMap["platformInfo"] = try platformInfo.encode()
            }
            if hasCpuInfo {
                jsonMap["cpuInfo"] = try cpuInfo.encode()
            }
            if !deviceInfo.isEmpty {
                var jsonArrayDeviceInfo:Array<Dictionary<String,Any>> = []
                for oneValueDeviceInfo in deviceInfo {
                    let ecodedMessageDeviceInfo = try oneValueDeviceInfo.encode()
                    jsonArrayDeviceInfo.append(ecodedMessageDeviceInfo)
                }
                jsonMap["deviceInfo"] = jsonArrayDeviceInfo
            }
            if !availableDeviceInfo.isEmpty {
                var jsonArrayAvailableDeviceInfo:Array<Dictionary<String,Any>> = []
                for oneValueAvailableDeviceInfo in availableDeviceInfo {
                    let ecodedMessageAvailableDeviceInfo = try oneValueAvailableDeviceInfo.encode()
                    jsonArrayAvailableDeviceInfo.append(ecodedMessageAvailableDeviceInfo)
                }
                jsonMap["availableDeviceInfo"] = jsonArrayAvailableDeviceInfo
            }
            if hasMemoryInfo {
                jsonMap["memoryInfo"] = try memoryInfo.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.MachineConfiguration {
            return try Tensorflow.MachineConfiguration.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.MachineConfiguration {
            return try Tensorflow.MachineConfiguration.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasHostname {
                output += "\(indent) hostname: \(hostname) \n"
            }
            if hasPlatformInfo {
                output += "\(indent) platformInfo {\n"
                if let outDescPlatformInfo = platformInfo {
                    output += try outDescPlatformInfo.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasCpuInfo {
                output += "\(indent) cpuInfo {\n"
                if let outDescCpuInfo = cpuInfo {
                    output += try outDescCpuInfo.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            var deviceInfoElementIndex:Int = 0
            for oneElementDeviceInfo in deviceInfo {
                output += "\(indent) deviceInfo[\(deviceInfoElementIndex)] {\n"
                output += try oneElementDeviceInfo.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                deviceInfoElementIndex += 1
            }
            var availableDeviceInfoElementIndex:Int = 0
            for oneElementAvailableDeviceInfo in availableDeviceInfo {
                output += "\(indent) availableDeviceInfo[\(availableDeviceInfoElementIndex)] {\n"
                output += try oneElementAvailableDeviceInfo.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                availableDeviceInfoElementIndex += 1
            }
            if hasMemoryInfo {
                output += "\(indent) memoryInfo {\n"
                if let outDescMemoryInfo = memoryInfo {
                    output += try outDescMemoryInfo.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasSerialIdentifier {
                output += "\(indent) serialIdentifier: \(serialIdentifier) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasHostname {
                    hashCode = (hashCode &* 31) &+ hostname.hashValue
                }
                if hasPlatformInfo {
                    if let hashValueplatformInfo = platformInfo?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueplatformInfo
                    }
                }
                if hasCpuInfo {
                    if let hashValuecpuInfo = cpuInfo?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecpuInfo
                    }
                }
                for oneElementDeviceInfo in deviceInfo {
                    hashCode = (hashCode &* 31) &+ oneElementDeviceInfo.hashValue
                }
                for oneElementAvailableDeviceInfo in availableDeviceInfo {
                    hashCode = (hashCode &* 31) &+ oneElementAvailableDeviceInfo.hashValue
                }
                if hasMemoryInfo {
                    if let hashValuememoryInfo = memoryInfo?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuememoryInfo
                    }
                }
                if hasSerialIdentifier {
                    hashCode = (hashCode &* 31) &+ serialIdentifier.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.MachineConfiguration"
        }
        override public func className() -> String {
            return "Tensorflow.MachineConfiguration"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.MachineConfiguration = Tensorflow.MachineConfiguration()
            public func getMessage() -> Tensorflow.MachineConfiguration {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Host name of machine that ran the benchmark.
            public var hostname:String {
                get {
                    return builderResult.hostname
                }
                set (value) {
                    builderResult.hasHostname = true
                    builderResult.hostname = value
                }
            }
            public var hasHostname:Bool {
                get {
                    return builderResult.hasHostname
                }
            }
            @discardableResult
            public func setHostname(_ value:String) -> Tensorflow.MachineConfiguration.Builder {
                self.hostname = value
                return self
            }
            @discardableResult
            public func clearHostname() -> Tensorflow.MachineConfiguration.Builder{
                builderResult.hasHostname = false
                builderResult.hostname = ""
                return self
            }
            /// Unique serial number of the machine.
            public var serialIdentifier:String {
                get {
                    return builderResult.serialIdentifier
                }
                set (value) {
                    builderResult.hasSerialIdentifier = true
                    builderResult.serialIdentifier = value
                }
            }
            public var hasSerialIdentifier:Bool {
                get {
                    return builderResult.hasSerialIdentifier
                }
            }
            @discardableResult
            public func setSerialIdentifier(_ value:String) -> Tensorflow.MachineConfiguration.Builder {
                self.serialIdentifier = value
                return self
            }
            @discardableResult
            public func clearSerialIdentifier() -> Tensorflow.MachineConfiguration.Builder{
                builderResult.hasSerialIdentifier = false
                builderResult.serialIdentifier = ""
                return self
            }
            /// Additional platform information.
            public var platformInfo:Tensorflow.PlatformInfo! {
                get {
                    if platformInfoBuilder_ != nil {
                        builderResult.platformInfo = platformInfoBuilder_.getMessage()
                    }
                    return builderResult.platformInfo
                }
                set (value) {
                    builderResult.hasPlatformInfo = true
                    builderResult.platformInfo = value
                }
            }
            public var hasPlatformInfo:Bool {
                get {
                    return builderResult.hasPlatformInfo
                }
            }
            fileprivate var platformInfoBuilder_:Tensorflow.PlatformInfo.Builder! {
                didSet {
                    builderResult.hasPlatformInfo = true
                }
            }
            public func getPlatformInfoBuilder() -> Tensorflow.PlatformInfo.Builder {
                if platformInfoBuilder_ == nil {
                    platformInfoBuilder_ = Tensorflow.PlatformInfo.Builder()
                    builderResult.platformInfo = platformInfoBuilder_.getMessage()
                    if platformInfo != nil {
                        try! platformInfoBuilder_.mergeFrom(other: platformInfo)
                    }
                }
                return platformInfoBuilder_
            }
            @discardableResult
            public func setPlatformInfo(_ value:Tensorflow.PlatformInfo!) -> Tensorflow.MachineConfiguration.Builder {
                self.platformInfo = value
                return self
            }
            @discardableResult
            public func mergePlatformInfo(value:Tensorflow.PlatformInfo) throws -> Tensorflow.MachineConfiguration.Builder {
                if builderResult.hasPlatformInfo {
                    builderResult.platformInfo = try Tensorflow.PlatformInfo.builderWithPrototype(prototype:builderResult.platformInfo).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.platformInfo = value
                }
                builderResult.hasPlatformInfo = true
                return self
            }
            @discardableResult
            public func clearPlatformInfo() -> Tensorflow.MachineConfiguration.Builder {
                platformInfoBuilder_ = nil
                builderResult.hasPlatformInfo = false
                builderResult.platformInfo = nil
                return self
            }
            /// CPU Information.
            public var cpuInfo:Tensorflow.Cpuinfo! {
                get {
                    if cpuInfoBuilder_ != nil {
                        builderResult.cpuInfo = cpuInfoBuilder_.getMessage()
                    }
                    return builderResult.cpuInfo
                }
                set (value) {
                    builderResult.hasCpuInfo = true
                    builderResult.cpuInfo = value
                }
            }
            public var hasCpuInfo:Bool {
                get {
                    return builderResult.hasCpuInfo
                }
            }
            fileprivate var cpuInfoBuilder_:Tensorflow.Cpuinfo.Builder! {
                didSet {
                    builderResult.hasCpuInfo = true
                }
            }
            public func getCpuInfoBuilder() -> Tensorflow.Cpuinfo.Builder {
                if cpuInfoBuilder_ == nil {
                    cpuInfoBuilder_ = Tensorflow.Cpuinfo.Builder()
                    builderResult.cpuInfo = cpuInfoBuilder_.getMessage()
                    if cpuInfo != nil {
                        try! cpuInfoBuilder_.mergeFrom(other: cpuInfo)
                    }
                }
                return cpuInfoBuilder_
            }
            @discardableResult
            public func setCpuInfo(_ value:Tensorflow.Cpuinfo!) -> Tensorflow.MachineConfiguration.Builder {
                self.cpuInfo = value
                return self
            }
            @discardableResult
            public func mergeCpuInfo(value:Tensorflow.Cpuinfo) throws -> Tensorflow.MachineConfiguration.Builder {
                if builderResult.hasCpuInfo {
                    builderResult.cpuInfo = try Tensorflow.Cpuinfo.builderWithPrototype(prototype:builderResult.cpuInfo).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.cpuInfo = value
                }
                builderResult.hasCpuInfo = true
                return self
            }
            @discardableResult
            public func clearCpuInfo() -> Tensorflow.MachineConfiguration.Builder {
                cpuInfoBuilder_ = nil
                builderResult.hasCpuInfo = false
                builderResult.cpuInfo = nil
                return self
            }
            /// Other devices that are attached and relevant (e.g. GPUInfo).
            public var deviceInfo:Array<Google.Protobuf.`Any`> {
                get {
                    return builderResult.deviceInfo
                }
                set (value) {
                    builderResult.deviceInfo = value
                }
            }
            @discardableResult
            public func setDeviceInfo(_ value:Array<Google.Protobuf.`Any`>) -> Tensorflow.MachineConfiguration.Builder {
                self.deviceInfo = value
                return self
            }
            @discardableResult
            public func clearDeviceInfo() -> Tensorflow.MachineConfiguration.Builder {
                builderResult.deviceInfo.removeAll(keepingCapacity: false)
                return self
            }
            /// Devices accessible to the test (e.g. as given by list_local_devices).
            public var availableDeviceInfo:Array<Tensorflow.AvailableDeviceInfo> {
                get {
                    return builderResult.availableDeviceInfo
                }
                set (value) {
                    builderResult.availableDeviceInfo = value
                }
            }
            @discardableResult
            public func setAvailableDeviceInfo(_ value:Array<Tensorflow.AvailableDeviceInfo>) -> Tensorflow.MachineConfiguration.Builder {
                self.availableDeviceInfo = value
                return self
            }
            @discardableResult
            public func clearAvailableDeviceInfo() -> Tensorflow.MachineConfiguration.Builder {
                builderResult.availableDeviceInfo.removeAll(keepingCapacity: false)
                return self
            }
            public var memoryInfo:Tensorflow.MemoryInfo! {
                get {
                    if memoryInfoBuilder_ != nil {
                        builderResult.memoryInfo = memoryInfoBuilder_.getMessage()
                    }
                    return builderResult.memoryInfo
                }
                set (value) {
                    builderResult.hasMemoryInfo = true
                    builderResult.memoryInfo = value
                }
            }
            public var hasMemoryInfo:Bool {
                get {
                    return builderResult.hasMemoryInfo
                }
            }
            fileprivate var memoryInfoBuilder_:Tensorflow.MemoryInfo.Builder! {
                didSet {
                    builderResult.hasMemoryInfo = true
                }
            }
            public func getMemoryInfoBuilder() -> Tensorflow.MemoryInfo.Builder {
                if memoryInfoBuilder_ == nil {
                    memoryInfoBuilder_ = Tensorflow.MemoryInfo.Builder()
                    builderResult.memoryInfo = memoryInfoBuilder_.getMessage()
                    if memoryInfo != nil {
                        try! memoryInfoBuilder_.mergeFrom(other: memoryInfo)
                    }
                }
                return memoryInfoBuilder_
            }
            @discardableResult
            public func setMemoryInfo(_ value:Tensorflow.MemoryInfo!) -> Tensorflow.MachineConfiguration.Builder {
                self.memoryInfo = value
                return self
            }
            @discardableResult
            public func mergeMemoryInfo(value:Tensorflow.MemoryInfo) throws -> Tensorflow.MachineConfiguration.Builder {
                if builderResult.hasMemoryInfo {
                    builderResult.memoryInfo = try Tensorflow.MemoryInfo.builderWithPrototype(prototype:builderResult.memoryInfo).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.memoryInfo = value
                }
                builderResult.hasMemoryInfo = true
                return self
            }
            @discardableResult
            public func clearMemoryInfo() -> Tensorflow.MachineConfiguration.Builder {
                memoryInfoBuilder_ = nil
                builderResult.hasMemoryInfo = false
                builderResult.memoryInfo = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.MachineConfiguration.Builder {
                builderResult = Tensorflow.MachineConfiguration()
                return self
            }
            override public func clone() throws -> Tensorflow.MachineConfiguration.Builder {
                return try Tensorflow.MachineConfiguration.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.MachineConfiguration {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.MachineConfiguration {
                let returnMe:Tensorflow.MachineConfiguration = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.MachineConfiguration) throws -> Tensorflow.MachineConfiguration.Builder {
                if other == Tensorflow.MachineConfiguration() {
                    return self
                }
                if other.hasHostname {
                    hostname = other.hostname
                }
                if other.hasSerialIdentifier {
                    serialIdentifier = other.serialIdentifier
                }
                if (other.hasPlatformInfo) {
                    try mergePlatformInfo(value: other.platformInfo)
                }
                if (other.hasCpuInfo) {
                    try mergeCpuInfo(value: other.cpuInfo)
                }
                if !other.deviceInfo.isEmpty  {
                     builderResult.deviceInfo += other.deviceInfo
                }
                if !other.availableDeviceInfo.isEmpty  {
                     builderResult.availableDeviceInfo += other.availableDeviceInfo
                }
                if (other.hasMemoryInfo) {
                    try mergeMemoryInfo(value: other.memoryInfo)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.MachineConfiguration.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MachineConfiguration.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        hostname = try codedInputStream.readString()

                    case 18:
                        let subBuilder:Tensorflow.PlatformInfo.Builder = Tensorflow.PlatformInfo.Builder()
                        if hasPlatformInfo {
                            try subBuilder.mergeFrom(other: platformInfo)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        platformInfo = subBuilder.buildPartial()

                    case 26:
                        let subBuilder:Tensorflow.Cpuinfo.Builder = Tensorflow.Cpuinfo.Builder()
                        if hasCpuInfo {
                            try subBuilder.mergeFrom(other: cpuInfo)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        cpuInfo = subBuilder.buildPartial()

                    case 34:
                        let subBuilder = Google.Protobuf.`Any`.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        deviceInfo.append(subBuilder.buildPartial())

                    case 42:
                        let subBuilder = Tensorflow.AvailableDeviceInfo.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        availableDeviceInfo.append(subBuilder.buildPartial())

                    case 50:
                        let subBuilder:Tensorflow.MemoryInfo.Builder = Tensorflow.MemoryInfo.Builder()
                        if hasMemoryInfo {
                            try subBuilder.mergeFrom(other: memoryInfo)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        memoryInfo = subBuilder.buildPartial()

                    case 58:
                        serialIdentifier = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.MachineConfiguration.Builder {
                let resultDecodedBuilder = Tensorflow.MachineConfiguration.Builder()
                if let jsonValueHostname = jsonMap["hostname"] as? String {
                    resultDecodedBuilder.hostname = jsonValueHostname
                }
                if let jsonValueSerialIdentifier = jsonMap["serialIdentifier"] as? String {
                    resultDecodedBuilder.serialIdentifier = jsonValueSerialIdentifier
                }
                if let jsonValuePlatformInfo = jsonMap["platformInfo"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.platformInfo = try Tensorflow.PlatformInfo.Builder.decodeToBuilder(jsonMap:jsonValuePlatformInfo).build()

                }
                if let jsonValueCpuInfo = jsonMap["cpuInfo"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.cpuInfo = try Tensorflow.Cpuinfo.Builder.decodeToBuilder(jsonMap:jsonValueCpuInfo).build()

                }
                if let jsonValueDeviceInfo = jsonMap["deviceInfo"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayDeviceInfo:Array<Google.Protobuf.`Any`> = []
                    for oneValueDeviceInfo in jsonValueDeviceInfo {
                        let messageFromStringDeviceInfo = try Google.Protobuf.`Any`.Builder.decodeToBuilder(jsonMap:oneValueDeviceInfo).build()

                        jsonArrayDeviceInfo.append(messageFromStringDeviceInfo)
                    }
                    resultDecodedBuilder.deviceInfo = jsonArrayDeviceInfo
                }
                if let jsonValueAvailableDeviceInfo = jsonMap["availableDeviceInfo"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayAvailableDeviceInfo:Array<Tensorflow.AvailableDeviceInfo> = []
                    for oneValueAvailableDeviceInfo in jsonValueAvailableDeviceInfo {
                        let messageFromStringAvailableDeviceInfo = try Tensorflow.AvailableDeviceInfo.Builder.decodeToBuilder(jsonMap:oneValueAvailableDeviceInfo).build()

                        jsonArrayAvailableDeviceInfo.append(messageFromStringAvailableDeviceInfo)
                    }
                    resultDecodedBuilder.availableDeviceInfo = jsonArrayAvailableDeviceInfo
                }
                if let jsonValueMemoryInfo = jsonMap["memoryInfo"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.memoryInfo = try Tensorflow.MemoryInfo.Builder.decodeToBuilder(jsonMap:jsonValueMemoryInfo).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.MachineConfiguration.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.MachineConfiguration.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Run-specific items such as arguments to the test / benchmark.
    final public class RunConfiguration : GeneratedMessage {

        public static func == (lhs: Tensorflow.RunConfiguration, rhs: Tensorflow.RunConfiguration) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.argument == rhs.argument)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var argument:Array<String> = Array<String>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if !argument.isEmpty {
                for oneValueargument in argument {
                    try codedOutputStream.writeString(fieldNumber: 1, value:oneValueargument)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            var dataSizeArgument:Int32 = 0
            for oneValueargument in argument {
                dataSizeArgument += oneValueargument.computeStringSizeNoTag()
            }
            serialize_size += dataSizeArgument
            serialize_size += 1 * Int32(argument.count)
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.RunConfiguration.Builder {
            return Tensorflow.RunConfiguration.classBuilder() as! Tensorflow.RunConfiguration.Builder
        }
        public func getBuilder() -> Tensorflow.RunConfiguration.Builder {
            return classBuilder() as! Tensorflow.RunConfiguration.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.RunConfiguration.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.RunConfiguration.Builder()
        }
        public func toBuilder() throws -> Tensorflow.RunConfiguration.Builder {
            return try Tensorflow.RunConfiguration.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.RunConfiguration) throws -> Tensorflow.RunConfiguration.Builder {
            return try Tensorflow.RunConfiguration.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !argument.isEmpty {
                var jsonArrayArgument:Array<String> = []
                for oneValueArgument in argument {
                    jsonArrayArgument.append(oneValueArgument)
                }
                jsonMap["argument"] = jsonArrayArgument
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.RunConfiguration {
            return try Tensorflow.RunConfiguration.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.RunConfiguration {
            return try Tensorflow.RunConfiguration.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var argumentElementIndex:Int = 0
            for oneValueArgument in argument  {
                output += "\(indent) argument[\(argumentElementIndex)]: \(oneValueArgument)\n"
                argumentElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneValueArgument in argument {
                    hashCode = (hashCode &* 31) &+ oneValueArgument.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.RunConfiguration"
        }
        override public func className() -> String {
            return "Tensorflow.RunConfiguration"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.RunConfiguration = Tensorflow.RunConfiguration()
            public func getMessage() -> Tensorflow.RunConfiguration {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var argument:Array<String> {
                get {
                    return builderResult.argument
                }
                set (array) {
                    builderResult.argument = array
                }
            }
            @discardableResult
            public func setArgument(_ value:Array<String>) -> Tensorflow.RunConfiguration.Builder {
                self.argument = value
                return self
            }
            @discardableResult
            public func clearArgument() -> Tensorflow.RunConfiguration.Builder {
                builderResult.argument.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.RunConfiguration.Builder {
                builderResult = Tensorflow.RunConfiguration()
                return self
            }
            override public func clone() throws -> Tensorflow.RunConfiguration.Builder {
                return try Tensorflow.RunConfiguration.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.RunConfiguration {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.RunConfiguration {
                let returnMe:Tensorflow.RunConfiguration = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.RunConfiguration) throws -> Tensorflow.RunConfiguration.Builder {
                if other == Tensorflow.RunConfiguration() {
                    return self
                }
                if !other.argument.isEmpty {
                    builderResult.argument += other.argument
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.RunConfiguration.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RunConfiguration.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        argument += [try codedInputStream.readString()]

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.RunConfiguration.Builder {
                let resultDecodedBuilder = Tensorflow.RunConfiguration.Builder()
                if let jsonValueArgument = jsonMap["argument"] as? Array<String> {
                    var jsonArrayArgument:Array<String> = []
                    for oneValueArgument in jsonValueArgument {
                        jsonArrayArgument.append(oneValueArgument)
                    }
                    resultDecodedBuilder.argument = jsonArrayArgument
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.RunConfiguration.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.RunConfiguration.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// The output of one benchmark / test run.  Each run contains a list of
    /// tests or benchmarks, stored as BenchmarkEntry messages.
    /// This message should be emitted by the reporter (which runs the
    /// test / BM in a subprocess and then reads the emitted BenchmarkEntry messages;
    /// usually from a serialized json file, finally collecting them along
    /// with additional information about the test run.
    final public class TestResults : GeneratedMessage {

        public static func == (lhs: Tensorflow.TestResults, rhs: Tensorflow.TestResults) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasTarget == rhs.hasTarget) && (!lhs.hasTarget || lhs.target == rhs.target)
            fieldCheck = fieldCheck && (lhs.hasEntries == rhs.hasEntries) && (!lhs.hasEntries || lhs.entries == rhs.entries)
            fieldCheck = fieldCheck && (lhs.hasBuildConfiguration == rhs.hasBuildConfiguration) && (!lhs.hasBuildConfiguration || lhs.buildConfiguration == rhs.buildConfiguration)
            fieldCheck = fieldCheck && (lhs.hasCommitId == rhs.hasCommitId) && (!lhs.hasCommitId || lhs.commitId == rhs.commitId)
            fieldCheck = fieldCheck && (lhs.hasStartTime == rhs.hasStartTime) && (!lhs.hasStartTime || lhs.startTime == rhs.startTime)
            fieldCheck = fieldCheck && (lhs.hasRunTime == rhs.hasRunTime) && (!lhs.hasRunTime || lhs.runTime == rhs.runTime)
            fieldCheck = fieldCheck && (lhs.hasMachineConfiguration == rhs.hasMachineConfiguration) && (!lhs.hasMachineConfiguration || lhs.machineConfiguration == rhs.machineConfiguration)
            fieldCheck = fieldCheck && (lhs.hasRunConfiguration == rhs.hasRunConfiguration) && (!lhs.hasRunConfiguration || lhs.runConfiguration == rhs.runConfiguration)
            fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
            fieldCheck = fieldCheck && (lhs.hasBenchmarkType == rhs.hasBenchmarkType) && (!lhs.hasBenchmarkType || lhs.benchmarkType == rhs.benchmarkType)
            fieldCheck = fieldCheck && (lhs.hasRunMode == rhs.hasRunMode) && (!lhs.hasRunMode || lhs.runMode == rhs.runMode)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



            //Enum type declaration start 

            /// The type of benchmark.
            public enum BenchmarkType:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
                /// Fallback for protos written before Type was introduced.
                case unknown = 0
                case cppMicrobenchmark = 1
                case pythonBenchmark = 2
                case androidBenchmark = 3
                public func toString() -> String {
                    switch self {
                    case .unknown: return "UNKNOWN"
                    case .cppMicrobenchmark: return "CPP_MICROBENCHMARK"
                    case .pythonBenchmark: return "PYTHON_BENCHMARK"
                    case .androidBenchmark: return "ANDROID_BENCHMARK"
                    }
                }
                public static func fromString(str:String) throws -> Tensorflow.TestResults.BenchmarkType {
                    switch str {
                    case "UNKNOWN":    return .unknown
                    case "CPP_MICROBENCHMARK":    return .cppMicrobenchmark
                    case "PYTHON_BENCHMARK":    return .pythonBenchmark
                    case "ANDROID_BENCHMARK":    return .androidBenchmark
                    default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
                    }
                }
                public var debugDescription:String { return getDescription() }
                public var description:String { return getDescription() }
                private func getDescription() -> String { 
                    switch self {
                    case .unknown: return ".unknown"
                    case .cppMicrobenchmark: return ".cppMicrobenchmark"
                    case .pythonBenchmark: return ".pythonBenchmark"
                    case .androidBenchmark: return ".androidBenchmark"
                    }
                }
                public var hashValue:Int {
                    return self.rawValue.hashValue
                }
                public static func ==(lhs:BenchmarkType, rhs:BenchmarkType) -> Bool {
                    return lhs.hashValue == rhs.hashValue
                }
            }

            //Enum type declaration end 

        /// The target of the run, e.g.:
        ///  //tensorflow/core:kernels_adjust_contrast_op_benchmark_test
        public fileprivate(set) var target:String = ""
        public fileprivate(set) var hasTarget:Bool = false

        public fileprivate(set) var entries:Tensorflow.BenchmarkEntries!
        public fileprivate(set) var hasEntries:Bool = false
        public fileprivate(set) var buildConfiguration:Tensorflow.BuildConfiguration!
        public fileprivate(set) var hasBuildConfiguration:Bool = false
        public fileprivate(set) var commitId:Tensorflow.CommitId!
        public fileprivate(set) var hasCommitId:Bool = false
        /// The time the run started (in seconds of UTC time since Unix epoch)
        public fileprivate(set) var startTime:Int64 = Int64(0)
        public fileprivate(set) var hasStartTime:Bool = false

        /// The amount of time the total run took (wall time in seconds)
        public fileprivate(set) var runTime:Double = Double(0)
        public fileprivate(set) var hasRunTime:Bool = false

        public fileprivate(set) var machineConfiguration:Tensorflow.MachineConfiguration!
        public fileprivate(set) var hasMachineConfiguration:Bool = false
        public fileprivate(set) var runConfiguration:Tensorflow.RunConfiguration!
        public fileprivate(set) var hasRunConfiguration:Bool = false
        /// Benchmark target identifier.
        public fileprivate(set) var name:String = ""
        public fileprivate(set) var hasName:Bool = false

        public fileprivate(set) var benchmarkType:Tensorflow.TestResults.BenchmarkType = Tensorflow.TestResults.BenchmarkType.unknown
        public fileprivate(set) var hasBenchmarkType:Bool = false
        /// Used for differentiating between continuous and debug builds.
        public fileprivate(set) var runMode:String = ""
        public fileprivate(set) var hasRunMode:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasTarget {
                try codedOutputStream.writeString(fieldNumber: 1, value:target)
            }
            if hasEntries {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:entries)
            }
            if hasBuildConfiguration {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:buildConfiguration)
            }
            if hasCommitId {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:commitId)
            }
            if hasStartTime {
                try codedOutputStream.writeInt64(fieldNumber: 5, value:startTime)
            }
            if hasRunTime {
                try codedOutputStream.writeDouble(fieldNumber: 6, value:runTime)
            }
            if hasMachineConfiguration {
                try codedOutputStream.writeMessage(fieldNumber: 7, value:machineConfiguration)
            }
            if hasRunConfiguration {
                try codedOutputStream.writeMessage(fieldNumber: 8, value:runConfiguration)
            }
            if hasName {
                try codedOutputStream.writeString(fieldNumber: 9, value:name)
            }
            if hasBenchmarkType {
                try codedOutputStream.writeEnum(fieldNumber: 10, value:benchmarkType.rawValue)
            }
            if hasRunMode {
                try codedOutputStream.writeString(fieldNumber: 11, value:runMode)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasTarget {
                serialize_size += target.computeStringSize(fieldNumber: 1)
            }
            if hasEntries {
                if let varSizeentries = entries?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeentries
                }
            }
            if hasBuildConfiguration {
                if let varSizebuildConfiguration = buildConfiguration?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizebuildConfiguration
                }
            }
            if hasCommitId {
                if let varSizecommitId = commitId?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizecommitId
                }
            }
            if hasStartTime {
                serialize_size += startTime.computeInt64Size(fieldNumber: 5)
            }
            if hasRunTime {
                serialize_size += runTime.computeDoubleSize(fieldNumber: 6)
            }
            if hasMachineConfiguration {
                if let varSizemachineConfiguration = machineConfiguration?.computeMessageSize(fieldNumber: 7) {
                    serialize_size += varSizemachineConfiguration
                }
            }
            if hasRunConfiguration {
                if let varSizerunConfiguration = runConfiguration?.computeMessageSize(fieldNumber: 8) {
                    serialize_size += varSizerunConfiguration
                }
            }
            if hasName {
                serialize_size += name.computeStringSize(fieldNumber: 9)
            }
            if (hasBenchmarkType) {
                serialize_size += benchmarkType.rawValue.computeEnumSize(fieldNumber: 10)
            }
            if hasRunMode {
                serialize_size += runMode.computeStringSize(fieldNumber: 11)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.TestResults.Builder {
            return Tensorflow.TestResults.classBuilder() as! Tensorflow.TestResults.Builder
        }
        public func getBuilder() -> Tensorflow.TestResults.Builder {
            return classBuilder() as! Tensorflow.TestResults.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.TestResults.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.TestResults.Builder()
        }
        public func toBuilder() throws -> Tensorflow.TestResults.Builder {
            return try Tensorflow.TestResults.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.TestResults) throws -> Tensorflow.TestResults.Builder {
            return try Tensorflow.TestResults.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasTarget {
                jsonMap["target"] = target
            }
            if hasEntries {
                jsonMap["entries"] = try entries.encode()
            }
            if hasBuildConfiguration {
                jsonMap["buildConfiguration"] = try buildConfiguration.encode()
            }
            if hasCommitId {
                jsonMap["commitId"] = try commitId.encode()
            }
            if hasStartTime {
                jsonMap["startTime"] = "\(startTime)"
            }
            if hasRunTime {
                jsonMap["runTime"] = Double(runTime)
            }
            if hasMachineConfiguration {
                jsonMap["machineConfiguration"] = try machineConfiguration.encode()
            }
            if hasRunConfiguration {
                jsonMap["runConfiguration"] = try runConfiguration.encode()
            }
            if hasName {
                jsonMap["name"] = name
            }
            if hasBenchmarkType {
                jsonMap["benchmarkType"] = benchmarkType.toString()
            }
            if hasRunMode {
                jsonMap["runMode"] = runMode
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.TestResults {
            return try Tensorflow.TestResults.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.TestResults {
            return try Tensorflow.TestResults.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasTarget {
                output += "\(indent) target: \(target) \n"
            }
            if hasEntries {
                output += "\(indent) entries {\n"
                if let outDescEntries = entries {
                    output += try outDescEntries.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasBuildConfiguration {
                output += "\(indent) buildConfiguration {\n"
                if let outDescBuildConfiguration = buildConfiguration {
                    output += try outDescBuildConfiguration.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasCommitId {
                output += "\(indent) commitId {\n"
                if let outDescCommitId = commitId {
                    output += try outDescCommitId.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasStartTime {
                output += "\(indent) startTime: \(startTime) \n"
            }
            if hasRunTime {
                output += "\(indent) runTime: \(runTime) \n"
            }
            if hasMachineConfiguration {
                output += "\(indent) machineConfiguration {\n"
                if let outDescMachineConfiguration = machineConfiguration {
                    output += try outDescMachineConfiguration.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasRunConfiguration {
                output += "\(indent) runConfiguration {\n"
                if let outDescRunConfiguration = runConfiguration {
                    output += try outDescRunConfiguration.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasName {
                output += "\(indent) name: \(name) \n"
            }
            if (hasBenchmarkType) {
                output += "\(indent) benchmarkType: \(benchmarkType.description)\n"
            }
            if hasRunMode {
                output += "\(indent) runMode: \(runMode) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasTarget {
                    hashCode = (hashCode &* 31) &+ target.hashValue
                }
                if hasEntries {
                    if let hashValueentries = entries?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueentries
                    }
                }
                if hasBuildConfiguration {
                    if let hashValuebuildConfiguration = buildConfiguration?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuebuildConfiguration
                    }
                }
                if hasCommitId {
                    if let hashValuecommitId = commitId?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecommitId
                    }
                }
                if hasStartTime {
                    hashCode = (hashCode &* 31) &+ startTime.hashValue
                }
                if hasRunTime {
                    hashCode = (hashCode &* 31) &+ runTime.hashValue
                }
                if hasMachineConfiguration {
                    if let hashValuemachineConfiguration = machineConfiguration?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuemachineConfiguration
                    }
                }
                if hasRunConfiguration {
                    if let hashValuerunConfiguration = runConfiguration?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuerunConfiguration
                    }
                }
                if hasName {
                    hashCode = (hashCode &* 31) &+ name.hashValue
                }
                if hasBenchmarkType {
                     hashCode = (hashCode &* 31) &+ benchmarkType.hashValue
                }
                if hasRunMode {
                    hashCode = (hashCode &* 31) &+ runMode.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.TestResults"
        }
        override public func className() -> String {
            return "Tensorflow.TestResults"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.TestResults = Tensorflow.TestResults()
            public func getMessage() -> Tensorflow.TestResults {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The target of the run, e.g.:
            ///  //tensorflow/core:kernels_adjust_contrast_op_benchmark_test
            public var target:String {
                get {
                    return builderResult.target
                }
                set (value) {
                    builderResult.hasTarget = true
                    builderResult.target = value
                }
            }
            public var hasTarget:Bool {
                get {
                    return builderResult.hasTarget
                }
            }
            @discardableResult
            public func setTarget(_ value:String) -> Tensorflow.TestResults.Builder {
                self.target = value
                return self
            }
            @discardableResult
            public func clearTarget() -> Tensorflow.TestResults.Builder{
                builderResult.hasTarget = false
                builderResult.target = ""
                return self
            }
            /// The list of tests or benchmarks in this run.
            public var entries:Tensorflow.BenchmarkEntries! {
                get {
                    if entriesBuilder_ != nil {
                        builderResult.entries = entriesBuilder_.getMessage()
                    }
                    return builderResult.entries
                }
                set (value) {
                    builderResult.hasEntries = true
                    builderResult.entries = value
                }
            }
            public var hasEntries:Bool {
                get {
                    return builderResult.hasEntries
                }
            }
            fileprivate var entriesBuilder_:Tensorflow.BenchmarkEntries.Builder! {
                didSet {
                    builderResult.hasEntries = true
                }
            }
            public func getEntriesBuilder() -> Tensorflow.BenchmarkEntries.Builder {
                if entriesBuilder_ == nil {
                    entriesBuilder_ = Tensorflow.BenchmarkEntries.Builder()
                    builderResult.entries = entriesBuilder_.getMessage()
                    if entries != nil {
                        try! entriesBuilder_.mergeFrom(other: entries)
                    }
                }
                return entriesBuilder_
            }
            @discardableResult
            public func setEntries(_ value:Tensorflow.BenchmarkEntries!) -> Tensorflow.TestResults.Builder {
                self.entries = value
                return self
            }
            @discardableResult
            public func mergeEntries(value:Tensorflow.BenchmarkEntries) throws -> Tensorflow.TestResults.Builder {
                if builderResult.hasEntries {
                    builderResult.entries = try Tensorflow.BenchmarkEntries.builderWithPrototype(prototype:builderResult.entries).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.entries = value
                }
                builderResult.hasEntries = true
                return self
            }
            @discardableResult
            public func clearEntries() -> Tensorflow.TestResults.Builder {
                entriesBuilder_ = nil
                builderResult.hasEntries = false
                builderResult.entries = nil
                return self
            }
            /// The configuration of the build (compiled opt? with cuda? any copts?)
            public var buildConfiguration:Tensorflow.BuildConfiguration! {
                get {
                    if buildConfigurationBuilder_ != nil {
                        builderResult.buildConfiguration = buildConfigurationBuilder_.getMessage()
                    }
                    return builderResult.buildConfiguration
                }
                set (value) {
                    builderResult.hasBuildConfiguration = true
                    builderResult.buildConfiguration = value
                }
            }
            public var hasBuildConfiguration:Bool {
                get {
                    return builderResult.hasBuildConfiguration
                }
            }
            fileprivate var buildConfigurationBuilder_:Tensorflow.BuildConfiguration.Builder! {
                didSet {
                    builderResult.hasBuildConfiguration = true
                }
            }
            public func getBuildConfigurationBuilder() -> Tensorflow.BuildConfiguration.Builder {
                if buildConfigurationBuilder_ == nil {
                    buildConfigurationBuilder_ = Tensorflow.BuildConfiguration.Builder()
                    builderResult.buildConfiguration = buildConfigurationBuilder_.getMessage()
                    if buildConfiguration != nil {
                        try! buildConfigurationBuilder_.mergeFrom(other: buildConfiguration)
                    }
                }
                return buildConfigurationBuilder_
            }
            @discardableResult
            public func setBuildConfiguration(_ value:Tensorflow.BuildConfiguration!) -> Tensorflow.TestResults.Builder {
                self.buildConfiguration = value
                return self
            }
            @discardableResult
            public func mergeBuildConfiguration(value:Tensorflow.BuildConfiguration) throws -> Tensorflow.TestResults.Builder {
                if builderResult.hasBuildConfiguration {
                    builderResult.buildConfiguration = try Tensorflow.BuildConfiguration.builderWithPrototype(prototype:builderResult.buildConfiguration).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.buildConfiguration = value
                }
                builderResult.hasBuildConfiguration = true
                return self
            }
            @discardableResult
            public func clearBuildConfiguration() -> Tensorflow.TestResults.Builder {
                buildConfigurationBuilder_ = nil
                builderResult.hasBuildConfiguration = false
                builderResult.buildConfiguration = nil
                return self
            }
            /// The commit id (git hash or changelist)
            public var commitId:Tensorflow.CommitId! {
                get {
                    if commitIdBuilder_ != nil {
                        builderResult.commitId = commitIdBuilder_.getMessage()
                    }
                    return builderResult.commitId
                }
                set (value) {
                    builderResult.hasCommitId = true
                    builderResult.commitId = value
                }
            }
            public var hasCommitId:Bool {
                get {
                    return builderResult.hasCommitId
                }
            }
            fileprivate var commitIdBuilder_:Tensorflow.CommitId.Builder! {
                didSet {
                    builderResult.hasCommitId = true
                }
            }
            public func getCommitIdBuilder() -> Tensorflow.CommitId.Builder {
                if commitIdBuilder_ == nil {
                    commitIdBuilder_ = Tensorflow.CommitId.Builder()
                    builderResult.commitId = commitIdBuilder_.getMessage()
                    if commitId != nil {
                        try! commitIdBuilder_.mergeFrom(other: commitId)
                    }
                }
                return commitIdBuilder_
            }
            @discardableResult
            public func setCommitId(_ value:Tensorflow.CommitId!) -> Tensorflow.TestResults.Builder {
                self.commitId = value
                return self
            }
            @discardableResult
            public func mergeCommitId(value:Tensorflow.CommitId) throws -> Tensorflow.TestResults.Builder {
                if builderResult.hasCommitId {
                    builderResult.commitId = try Tensorflow.CommitId.builderWithPrototype(prototype:builderResult.commitId).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.commitId = value
                }
                builderResult.hasCommitId = true
                return self
            }
            @discardableResult
            public func clearCommitId() -> Tensorflow.TestResults.Builder {
                commitIdBuilder_ = nil
                builderResult.hasCommitId = false
                builderResult.commitId = nil
                return self
            }
            /// The time the run started (in seconds of UTC time since Unix epoch)
            public var startTime:Int64 {
                get {
                    return builderResult.startTime
                }
                set (value) {
                    builderResult.hasStartTime = true
                    builderResult.startTime = value
                }
            }
            public var hasStartTime:Bool {
                get {
                    return builderResult.hasStartTime
                }
            }
            @discardableResult
            public func setStartTime(_ value:Int64) -> Tensorflow.TestResults.Builder {
                self.startTime = value
                return self
            }
            @discardableResult
            public func clearStartTime() -> Tensorflow.TestResults.Builder{
                builderResult.hasStartTime = false
                builderResult.startTime = Int64(0)
                return self
            }
            /// The amount of time the total run took (wall time in seconds)
            public var runTime:Double {
                get {
                    return builderResult.runTime
                }
                set (value) {
                    builderResult.hasRunTime = true
                    builderResult.runTime = value
                }
            }
            public var hasRunTime:Bool {
                get {
                    return builderResult.hasRunTime
                }
            }
            @discardableResult
            public func setRunTime(_ value:Double) -> Tensorflow.TestResults.Builder {
                self.runTime = value
                return self
            }
            @discardableResult
            public func clearRunTime() -> Tensorflow.TestResults.Builder{
                builderResult.hasRunTime = false
                builderResult.runTime = Double(0)
                return self
            }
            /// Machine-specific parameters (Platform and CPU info)
            public var machineConfiguration:Tensorflow.MachineConfiguration! {
                get {
                    if machineConfigurationBuilder_ != nil {
                        builderResult.machineConfiguration = machineConfigurationBuilder_.getMessage()
                    }
                    return builderResult.machineConfiguration
                }
                set (value) {
                    builderResult.hasMachineConfiguration = true
                    builderResult.machineConfiguration = value
                }
            }
            public var hasMachineConfiguration:Bool {
                get {
                    return builderResult.hasMachineConfiguration
                }
            }
            fileprivate var machineConfigurationBuilder_:Tensorflow.MachineConfiguration.Builder! {
                didSet {
                    builderResult.hasMachineConfiguration = true
                }
            }
            public func getMachineConfigurationBuilder() -> Tensorflow.MachineConfiguration.Builder {
                if machineConfigurationBuilder_ == nil {
                    machineConfigurationBuilder_ = Tensorflow.MachineConfiguration.Builder()
                    builderResult.machineConfiguration = machineConfigurationBuilder_.getMessage()
                    if machineConfiguration != nil {
                        try! machineConfigurationBuilder_.mergeFrom(other: machineConfiguration)
                    }
                }
                return machineConfigurationBuilder_
            }
            @discardableResult
            public func setMachineConfiguration(_ value:Tensorflow.MachineConfiguration!) -> Tensorflow.TestResults.Builder {
                self.machineConfiguration = value
                return self
            }
            @discardableResult
            public func mergeMachineConfiguration(value:Tensorflow.MachineConfiguration) throws -> Tensorflow.TestResults.Builder {
                if builderResult.hasMachineConfiguration {
                    builderResult.machineConfiguration = try Tensorflow.MachineConfiguration.builderWithPrototype(prototype:builderResult.machineConfiguration).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.machineConfiguration = value
                }
                builderResult.hasMachineConfiguration = true
                return self
            }
            @discardableResult
            public func clearMachineConfiguration() -> Tensorflow.TestResults.Builder {
                machineConfigurationBuilder_ = nil
                builderResult.hasMachineConfiguration = false
                builderResult.machineConfiguration = nil
                return self
            }
            /// Run-specific parameters (arguments, etc)
            public var runConfiguration:Tensorflow.RunConfiguration! {
                get {
                    if runConfigurationBuilder_ != nil {
                        builderResult.runConfiguration = runConfigurationBuilder_.getMessage()
                    }
                    return builderResult.runConfiguration
                }
                set (value) {
                    builderResult.hasRunConfiguration = true
                    builderResult.runConfiguration = value
                }
            }
            public var hasRunConfiguration:Bool {
                get {
                    return builderResult.hasRunConfiguration
                }
            }
            fileprivate var runConfigurationBuilder_:Tensorflow.RunConfiguration.Builder! {
                didSet {
                    builderResult.hasRunConfiguration = true
                }
            }
            public func getRunConfigurationBuilder() -> Tensorflow.RunConfiguration.Builder {
                if runConfigurationBuilder_ == nil {
                    runConfigurationBuilder_ = Tensorflow.RunConfiguration.Builder()
                    builderResult.runConfiguration = runConfigurationBuilder_.getMessage()
                    if runConfiguration != nil {
                        try! runConfigurationBuilder_.mergeFrom(other: runConfiguration)
                    }
                }
                return runConfigurationBuilder_
            }
            @discardableResult
            public func setRunConfiguration(_ value:Tensorflow.RunConfiguration!) -> Tensorflow.TestResults.Builder {
                self.runConfiguration = value
                return self
            }
            @discardableResult
            public func mergeRunConfiguration(value:Tensorflow.RunConfiguration) throws -> Tensorflow.TestResults.Builder {
                if builderResult.hasRunConfiguration {
                    builderResult.runConfiguration = try Tensorflow.RunConfiguration.builderWithPrototype(prototype:builderResult.runConfiguration).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.runConfiguration = value
                }
                builderResult.hasRunConfiguration = true
                return self
            }
            @discardableResult
            public func clearRunConfiguration() -> Tensorflow.TestResults.Builder {
                runConfigurationBuilder_ = nil
                builderResult.hasRunConfiguration = false
                builderResult.runConfiguration = nil
                return self
            }
            /// Benchmark target identifier.
            public var name:String {
                get {
                    return builderResult.name
                }
                set (value) {
                    builderResult.hasName = true
                    builderResult.name = value
                }
            }
            public var hasName:Bool {
                get {
                    return builderResult.hasName
                }
            }
            @discardableResult
            public func setName(_ value:String) -> Tensorflow.TestResults.Builder {
                self.name = value
                return self
            }
            @discardableResult
            public func clearName() -> Tensorflow.TestResults.Builder{
                builderResult.hasName = false
                builderResult.name = ""
                return self
            }
                public var benchmarkType:Tensorflow.TestResults.BenchmarkType {
                    get {
                        return builderResult.benchmarkType
                    }
                    set (value) {
                        builderResult.hasBenchmarkType = true
                        builderResult.benchmarkType = value
                    }
                }
                public var hasBenchmarkType:Bool{
                    get {
                        return builderResult.hasBenchmarkType
                    }
                }
            @discardableResult
                public func setBenchmarkType(_ value:Tensorflow.TestResults.BenchmarkType) -> Tensorflow.TestResults.Builder {
                  self.benchmarkType = value
                  return self
                }
            @discardableResult
                public func clearBenchmarkType() -> Tensorflow.TestResults.Builder {
                   builderResult.hasBenchmarkType = false
                   builderResult.benchmarkType = .unknown
                   return self
                }
            /// Used for differentiating between continuous and debug builds.
            public var runMode:String {
                get {
                    return builderResult.runMode
                }
                set (value) {
                    builderResult.hasRunMode = true
                    builderResult.runMode = value
                }
            }
            public var hasRunMode:Bool {
                get {
                    return builderResult.hasRunMode
                }
            }
            @discardableResult
            public func setRunMode(_ value:String) -> Tensorflow.TestResults.Builder {
                self.runMode = value
                return self
            }
            @discardableResult
            public func clearRunMode() -> Tensorflow.TestResults.Builder{
                builderResult.hasRunMode = false
                builderResult.runMode = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.TestResults.Builder {
                builderResult = Tensorflow.TestResults()
                return self
            }
            override public func clone() throws -> Tensorflow.TestResults.Builder {
                return try Tensorflow.TestResults.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.TestResults {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.TestResults {
                let returnMe:Tensorflow.TestResults = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.TestResults) throws -> Tensorflow.TestResults.Builder {
                if other == Tensorflow.TestResults() {
                    return self
                }
                if other.hasTarget {
                    target = other.target
                }
                if (other.hasEntries) {
                    try mergeEntries(value: other.entries)
                }
                if (other.hasBuildConfiguration) {
                    try mergeBuildConfiguration(value: other.buildConfiguration)
                }
                if (other.hasCommitId) {
                    try mergeCommitId(value: other.commitId)
                }
                if other.hasStartTime {
                    startTime = other.startTime
                }
                if other.hasRunTime {
                    runTime = other.runTime
                }
                if (other.hasMachineConfiguration) {
                    try mergeMachineConfiguration(value: other.machineConfiguration)
                }
                if (other.hasRunConfiguration) {
                    try mergeRunConfiguration(value: other.runConfiguration)
                }
                if other.hasName {
                    name = other.name
                }
                if other.hasBenchmarkType {
                    benchmarkType = other.benchmarkType
                }
                if other.hasRunMode {
                    runMode = other.runMode
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.TestResults.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.TestResults.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        target = try codedInputStream.readString()

                    case 18:
                        let subBuilder:Tensorflow.BenchmarkEntries.Builder = Tensorflow.BenchmarkEntries.Builder()
                        if hasEntries {
                            try subBuilder.mergeFrom(other: entries)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        entries = subBuilder.buildPartial()

                    case 26:
                        let subBuilder:Tensorflow.BuildConfiguration.Builder = Tensorflow.BuildConfiguration.Builder()
                        if hasBuildConfiguration {
                            try subBuilder.mergeFrom(other: buildConfiguration)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        buildConfiguration = subBuilder.buildPartial()

                    case 34:
                        let subBuilder:Tensorflow.CommitId.Builder = Tensorflow.CommitId.Builder()
                        if hasCommitId {
                            try subBuilder.mergeFrom(other: commitId)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        commitId = subBuilder.buildPartial()

                    case 40:
                        startTime = try codedInputStream.readInt64()

                    case 49:
                        runTime = try codedInputStream.readDouble()

                    case 58:
                        let subBuilder:Tensorflow.MachineConfiguration.Builder = Tensorflow.MachineConfiguration.Builder()
                        if hasMachineConfiguration {
                            try subBuilder.mergeFrom(other: machineConfiguration)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        machineConfiguration = subBuilder.buildPartial()

                    case 66:
                        let subBuilder:Tensorflow.RunConfiguration.Builder = Tensorflow.RunConfiguration.Builder()
                        if hasRunConfiguration {
                            try subBuilder.mergeFrom(other: runConfiguration)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        runConfiguration = subBuilder.buildPartial()

                    case 74:
                        name = try codedInputStream.readString()

                    case 80:
                        let valueIntbenchmarkType = try codedInputStream.readEnum()
                        if let enumsbenchmarkType = Tensorflow.TestResults.BenchmarkType(rawValue:valueIntbenchmarkType){
                            benchmarkType = enumsbenchmarkType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 10, value:Int64(valueIntbenchmarkType))
                        }

                    case 90:
                        runMode = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.TestResults.Builder {
                let resultDecodedBuilder = Tensorflow.TestResults.Builder()
                if let jsonValueTarget = jsonMap["target"] as? String {
                    resultDecodedBuilder.target = jsonValueTarget
                }
                if let jsonValueEntries = jsonMap["entries"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.entries = try Tensorflow.BenchmarkEntries.Builder.decodeToBuilder(jsonMap:jsonValueEntries).build()

                }
                if let jsonValueBuildConfiguration = jsonMap["buildConfiguration"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.buildConfiguration = try Tensorflow.BuildConfiguration.Builder.decodeToBuilder(jsonMap:jsonValueBuildConfiguration).build()

                }
                if let jsonValueCommitId = jsonMap["commitId"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.commitId = try Tensorflow.CommitId.Builder.decodeToBuilder(jsonMap:jsonValueCommitId).build()

                }
                if let jsonValueStartTime = jsonMap["startTime"] as? String {
                    resultDecodedBuilder.startTime = Int64(jsonValueStartTime)!
                } else if let jsonValueStartTime = jsonMap["startTime"] as? Int {
                    resultDecodedBuilder.startTime = Int64(jsonValueStartTime)
                }
                if let jsonValueRunTime = jsonMap["runTime"] as? Double {
                    resultDecodedBuilder.runTime = Double(jsonValueRunTime)
                } else if let jsonValueRunTime = jsonMap["runTime"] as? String {
                    resultDecodedBuilder.runTime = Double(jsonValueRunTime)!
                }
                if let jsonValueMachineConfiguration = jsonMap["machineConfiguration"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.machineConfiguration = try Tensorflow.MachineConfiguration.Builder.decodeToBuilder(jsonMap:jsonValueMachineConfiguration).build()

                }
                if let jsonValueRunConfiguration = jsonMap["runConfiguration"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.runConfiguration = try Tensorflow.RunConfiguration.Builder.decodeToBuilder(jsonMap:jsonValueRunConfiguration).build()

                }
                if let jsonValueName = jsonMap["name"] as? String {
                    resultDecodedBuilder.name = jsonValueName
                }
                if let jsonValueBenchmarkType = jsonMap["benchmarkType"] as? String {
                    resultDecodedBuilder.benchmarkType = try Tensorflow.TestResults.BenchmarkType.fromString(str: jsonValueBenchmarkType)
                }
                if let jsonValueRunMode = jsonMap["runMode"] as? String {
                    resultDecodedBuilder.runMode = jsonValueRunMode
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.TestResults.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.TestResults.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.EntryValue: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.EntryValue> {
        var mergedArray = Array<Tensorflow.EntryValue>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.EntryValue? {
        return try Tensorflow.EntryValue.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.EntryValue {
        return try Tensorflow.EntryValue.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.TestLogRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.EntryValue {
        return try Tensorflow.EntryValue.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.EntryValue {
        return try Tensorflow.EntryValue.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.EntryValue {
        return try Tensorflow.EntryValue.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.EntryValue {
        return try Tensorflow.EntryValue.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.EntryValue {
        return try Tensorflow.EntryValue.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "doubleValue": return self.doubleValue
        case "stringValue": return self.stringValue
        default: return nil
        }
    }
}
extension Tensorflow.EntryValue.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "doubleValue": return self.doubleValue
            case "stringValue": return self.stringValue
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "doubleValue":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.doubleValue = newSubscriptValue
            case "stringValue":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.stringValue = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.BenchmarkEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.BenchmarkEntry> {
        var mergedArray = Array<Tensorflow.BenchmarkEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.BenchmarkEntry? {
        return try Tensorflow.BenchmarkEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.BenchmarkEntry {
        return try Tensorflow.BenchmarkEntry.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.TestLogRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BenchmarkEntry {
        return try Tensorflow.BenchmarkEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.BenchmarkEntry {
        return try Tensorflow.BenchmarkEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BenchmarkEntry {
        return try Tensorflow.BenchmarkEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BenchmarkEntry {
        return try Tensorflow.BenchmarkEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BenchmarkEntry {
        return try Tensorflow.BenchmarkEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "name": return self.name
        case "iters": return self.iters
        case "cpuTime": return self.cpuTime
        case "wallTime": return self.wallTime
        case "throughput": return self.throughput
        case "extras": return self.extras
        default: return nil
        }
    }
}
extension Tensorflow.BenchmarkEntry.ExtrasEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.BenchmarkEntry.ExtrasEntry> {
        var mergedArray = Array<Tensorflow.BenchmarkEntry.ExtrasEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.BenchmarkEntry.ExtrasEntry? {
        return try Tensorflow.BenchmarkEntry.ExtrasEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.BenchmarkEntry.ExtrasEntry {
        return try Tensorflow.BenchmarkEntry.ExtrasEntry.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.TestLogRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BenchmarkEntry.ExtrasEntry {
        return try Tensorflow.BenchmarkEntry.ExtrasEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.BenchmarkEntry.ExtrasEntry {
        return try Tensorflow.BenchmarkEntry.ExtrasEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BenchmarkEntry.ExtrasEntry {
        return try Tensorflow.BenchmarkEntry.ExtrasEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BenchmarkEntry.ExtrasEntry {
        return try Tensorflow.BenchmarkEntry.ExtrasEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BenchmarkEntry.ExtrasEntry {
        return try Tensorflow.BenchmarkEntry.ExtrasEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.BenchmarkEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "name": return self.name
            case "iters": return self.iters
            case "cpuTime": return self.cpuTime
            case "wallTime": return self.wallTime
            case "throughput": return self.throughput
            case "extras": return self.extras
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "iters":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.iters = newSubscriptValue
            case "cpuTime":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.cpuTime = newSubscriptValue
            case "wallTime":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.wallTime = newSubscriptValue
            case "throughput":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.throughput = newSubscriptValue
            case "extras":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,Tensorflow.EntryValue> else {
                    return
                }
                self.extras = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.BenchmarkEntry.ExtrasEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.EntryValue else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.BenchmarkEntries: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.BenchmarkEntries> {
        var mergedArray = Array<Tensorflow.BenchmarkEntries>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.BenchmarkEntries? {
        return try Tensorflow.BenchmarkEntries.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.BenchmarkEntries {
        return try Tensorflow.BenchmarkEntries.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.TestLogRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BenchmarkEntries {
        return try Tensorflow.BenchmarkEntries.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.BenchmarkEntries {
        return try Tensorflow.BenchmarkEntries.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BenchmarkEntries {
        return try Tensorflow.BenchmarkEntries.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BenchmarkEntries {
        return try Tensorflow.BenchmarkEntries.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BenchmarkEntries {
        return try Tensorflow.BenchmarkEntries.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "entry": return self.entry
        default: return nil
        }
    }
}
extension Tensorflow.BenchmarkEntries.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "entry": return self.entry
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "entry":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.BenchmarkEntry> else {
                    return
                }
                self.entry = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.BuildConfiguration: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.BuildConfiguration> {
        var mergedArray = Array<Tensorflow.BuildConfiguration>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.BuildConfiguration? {
        return try Tensorflow.BuildConfiguration.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.BuildConfiguration {
        return try Tensorflow.BuildConfiguration.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.TestLogRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BuildConfiguration {
        return try Tensorflow.BuildConfiguration.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.BuildConfiguration {
        return try Tensorflow.BuildConfiguration.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BuildConfiguration {
        return try Tensorflow.BuildConfiguration.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BuildConfiguration {
        return try Tensorflow.BuildConfiguration.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BuildConfiguration {
        return try Tensorflow.BuildConfiguration.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "mode": return self.mode
        case "ccFlags": return self.ccFlags
        case "opts": return self.opts
        default: return nil
        }
    }
}
extension Tensorflow.BuildConfiguration.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "mode": return self.mode
            case "ccFlags": return self.ccFlags
            case "opts": return self.opts
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "mode":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.mode = newSubscriptValue
            case "ccFlags":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.ccFlags = newSubscriptValue
            case "opts":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.opts = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.CommitId: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.CommitId> {
        var mergedArray = Array<Tensorflow.CommitId>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.CommitId? {
        return try Tensorflow.CommitId.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.CommitId {
        return try Tensorflow.CommitId.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.TestLogRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CommitId {
        return try Tensorflow.CommitId.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.CommitId {
        return try Tensorflow.CommitId.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CommitId {
        return try Tensorflow.CommitId.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CommitId {
        return try Tensorflow.CommitId.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CommitId {
        return try Tensorflow.CommitId.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "changelist": return self.changelist
        case "hash": return self.hash
        case "snapshot": return self.snapshot
        default: return nil
        }
    }
}
extension Tensorflow.CommitId.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "changelist": return self.changelist
            case "hash": return self.hash
            case "snapshot": return self.snapshot
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "changelist":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.changelist = newSubscriptValue
            case "hash":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.hash = newSubscriptValue
            case "snapshot":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.snapshot = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Cpuinfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Cpuinfo> {
        var mergedArray = Array<Tensorflow.Cpuinfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Cpuinfo? {
        return try Tensorflow.Cpuinfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Cpuinfo {
        return try Tensorflow.Cpuinfo.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.TestLogRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Cpuinfo {
        return try Tensorflow.Cpuinfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Cpuinfo {
        return try Tensorflow.Cpuinfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Cpuinfo {
        return try Tensorflow.Cpuinfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Cpuinfo {
        return try Tensorflow.Cpuinfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Cpuinfo {
        return try Tensorflow.Cpuinfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "numCores": return self.numCores
        case "numCoresAllowed": return self.numCoresAllowed
        case "mhzPerCpu": return self.mhzPerCpu
        case "cpuInfo": return self.cpuInfo
        case "cpuGovernor": return self.cpuGovernor
        case "cacheSize": return self.cacheSize
        default: return nil
        }
    }
}
extension Tensorflow.Cpuinfo.CacheSizeEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Cpuinfo.CacheSizeEntry> {
        var mergedArray = Array<Tensorflow.Cpuinfo.CacheSizeEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Cpuinfo.CacheSizeEntry? {
        return try Tensorflow.Cpuinfo.CacheSizeEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Cpuinfo.CacheSizeEntry {
        return try Tensorflow.Cpuinfo.CacheSizeEntry.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.TestLogRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Cpuinfo.CacheSizeEntry {
        return try Tensorflow.Cpuinfo.CacheSizeEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Cpuinfo.CacheSizeEntry {
        return try Tensorflow.Cpuinfo.CacheSizeEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Cpuinfo.CacheSizeEntry {
        return try Tensorflow.Cpuinfo.CacheSizeEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Cpuinfo.CacheSizeEntry {
        return try Tensorflow.Cpuinfo.CacheSizeEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Cpuinfo.CacheSizeEntry {
        return try Tensorflow.Cpuinfo.CacheSizeEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.Cpuinfo.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "numCores": return self.numCores
            case "numCoresAllowed": return self.numCoresAllowed
            case "mhzPerCpu": return self.mhzPerCpu
            case "cpuInfo": return self.cpuInfo
            case "cpuGovernor": return self.cpuGovernor
            case "cacheSize": return self.cacheSize
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "numCores":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.numCores = newSubscriptValue
            case "numCoresAllowed":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.numCoresAllowed = newSubscriptValue
            case "mhzPerCpu":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.mhzPerCpu = newSubscriptValue
            case "cpuInfo":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.cpuInfo = newSubscriptValue
            case "cpuGovernor":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.cpuGovernor = newSubscriptValue
            case "cacheSize":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,Int64> else {
                    return
                }
                self.cacheSize = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Cpuinfo.CacheSizeEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.MemoryInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.MemoryInfo> {
        var mergedArray = Array<Tensorflow.MemoryInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.MemoryInfo? {
        return try Tensorflow.MemoryInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.MemoryInfo {
        return try Tensorflow.MemoryInfo.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.TestLogRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryInfo {
        return try Tensorflow.MemoryInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.MemoryInfo {
        return try Tensorflow.MemoryInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryInfo {
        return try Tensorflow.MemoryInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.MemoryInfo {
        return try Tensorflow.MemoryInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MemoryInfo {
        return try Tensorflow.MemoryInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "total": return self.total
        case "available": return self.available
        default: return nil
        }
    }
}
extension Tensorflow.MemoryInfo.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "total": return self.total
            case "available": return self.available
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "total":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.total = newSubscriptValue
            case "available":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.available = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Gpuinfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Gpuinfo> {
        var mergedArray = Array<Tensorflow.Gpuinfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Gpuinfo? {
        return try Tensorflow.Gpuinfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Gpuinfo {
        return try Tensorflow.Gpuinfo.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.TestLogRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Gpuinfo {
        return try Tensorflow.Gpuinfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Gpuinfo {
        return try Tensorflow.Gpuinfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Gpuinfo {
        return try Tensorflow.Gpuinfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Gpuinfo {
        return try Tensorflow.Gpuinfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Gpuinfo {
        return try Tensorflow.Gpuinfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "model": return self.model
        case "uuid": return self.uuid
        case "busId": return self.busId
        default: return nil
        }
    }
}
extension Tensorflow.Gpuinfo.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "model": return self.model
            case "uuid": return self.uuid
            case "busId": return self.busId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "model":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.model = newSubscriptValue
            case "uuid":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.uuid = newSubscriptValue
            case "busId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.busId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.PlatformInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.PlatformInfo> {
        var mergedArray = Array<Tensorflow.PlatformInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.PlatformInfo? {
        return try Tensorflow.PlatformInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.PlatformInfo {
        return try Tensorflow.PlatformInfo.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.TestLogRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.PlatformInfo {
        return try Tensorflow.PlatformInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.PlatformInfo {
        return try Tensorflow.PlatformInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.PlatformInfo {
        return try Tensorflow.PlatformInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.PlatformInfo {
        return try Tensorflow.PlatformInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.PlatformInfo {
        return try Tensorflow.PlatformInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "bits": return self.bits
        case "linkage": return self.linkage
        case "machine": return self.machine
        case "release": return self.release
        case "system": return self.system
        case "version": return self.version
        default: return nil
        }
    }
}
extension Tensorflow.PlatformInfo.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "bits": return self.bits
            case "linkage": return self.linkage
            case "machine": return self.machine
            case "release": return self.release
            case "system": return self.system
            case "version": return self.version
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "bits":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.bits = newSubscriptValue
            case "linkage":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.linkage = newSubscriptValue
            case "machine":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.machine = newSubscriptValue
            case "release":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.release = newSubscriptValue
            case "system":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.system = newSubscriptValue
            case "version":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.version = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.AvailableDeviceInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.AvailableDeviceInfo> {
        var mergedArray = Array<Tensorflow.AvailableDeviceInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.AvailableDeviceInfo? {
        return try Tensorflow.AvailableDeviceInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.AvailableDeviceInfo {
        return try Tensorflow.AvailableDeviceInfo.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.TestLogRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.AvailableDeviceInfo {
        return try Tensorflow.AvailableDeviceInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.AvailableDeviceInfo {
        return try Tensorflow.AvailableDeviceInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.AvailableDeviceInfo {
        return try Tensorflow.AvailableDeviceInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.AvailableDeviceInfo {
        return try Tensorflow.AvailableDeviceInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.AvailableDeviceInfo {
        return try Tensorflow.AvailableDeviceInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "name": return self.name
        case "type": return self.type
        case "memoryLimit": return self.memoryLimit
        case "physicalDescription": return self.physicalDescription
        default: return nil
        }
    }
}
extension Tensorflow.AvailableDeviceInfo.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "name": return self.name
            case "type": return self.type
            case "memoryLimit": return self.memoryLimit
            case "physicalDescription": return self.physicalDescription
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "type":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.type = newSubscriptValue
            case "memoryLimit":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.memoryLimit = newSubscriptValue
            case "physicalDescription":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.physicalDescription = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.MachineConfiguration: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.MachineConfiguration> {
        var mergedArray = Array<Tensorflow.MachineConfiguration>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.MachineConfiguration? {
        return try Tensorflow.MachineConfiguration.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.MachineConfiguration {
        return try Tensorflow.MachineConfiguration.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.TestLogRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MachineConfiguration {
        return try Tensorflow.MachineConfiguration.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.MachineConfiguration {
        return try Tensorflow.MachineConfiguration.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MachineConfiguration {
        return try Tensorflow.MachineConfiguration.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.MachineConfiguration {
        return try Tensorflow.MachineConfiguration.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.MachineConfiguration {
        return try Tensorflow.MachineConfiguration.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "hostname": return self.hostname
        case "serialIdentifier": return self.serialIdentifier
        case "platformInfo": return self.platformInfo
        case "cpuInfo": return self.cpuInfo
        case "deviceInfo": return self.deviceInfo
        case "availableDeviceInfo": return self.availableDeviceInfo
        case "memoryInfo": return self.memoryInfo
        default: return nil
        }
    }
}
extension Tensorflow.MachineConfiguration.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "hostname": return self.hostname
            case "serialIdentifier": return self.serialIdentifier
            case "platformInfo": return self.platformInfo
            case "cpuInfo": return self.cpuInfo
            case "deviceInfo": return self.deviceInfo
            case "availableDeviceInfo": return self.availableDeviceInfo
            case "memoryInfo": return self.memoryInfo
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "hostname":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.hostname = newSubscriptValue
            case "serialIdentifier":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.serialIdentifier = newSubscriptValue
            case "platformInfo":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.PlatformInfo else {
                    return
                }
                self.platformInfo = newSubscriptValue
            case "cpuInfo":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Cpuinfo else {
                    return
                }
                self.cpuInfo = newSubscriptValue
            case "deviceInfo":
                guard let newSubscriptValue = newSubscriptValue as? Array<Google.Protobuf.`Any`> else {
                    return
                }
                self.deviceInfo = newSubscriptValue
            case "availableDeviceInfo":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.AvailableDeviceInfo> else {
                    return
                }
                self.availableDeviceInfo = newSubscriptValue
            case "memoryInfo":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.MemoryInfo else {
                    return
                }
                self.memoryInfo = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.RunConfiguration: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.RunConfiguration> {
        var mergedArray = Array<Tensorflow.RunConfiguration>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.RunConfiguration? {
        return try Tensorflow.RunConfiguration.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.RunConfiguration {
        return try Tensorflow.RunConfiguration.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.TestLogRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RunConfiguration {
        return try Tensorflow.RunConfiguration.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.RunConfiguration {
        return try Tensorflow.RunConfiguration.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RunConfiguration {
        return try Tensorflow.RunConfiguration.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.RunConfiguration {
        return try Tensorflow.RunConfiguration.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RunConfiguration {
        return try Tensorflow.RunConfiguration.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "argument": return self.argument
        default: return nil
        }
    }
}
extension Tensorflow.RunConfiguration.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "argument": return self.argument
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "argument":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.argument = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.TestResults: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.TestResults> {
        var mergedArray = Array<Tensorflow.TestResults>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.TestResults? {
        return try Tensorflow.TestResults.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.TestResults {
        return try Tensorflow.TestResults.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.TestLogRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.TestResults {
        return try Tensorflow.TestResults.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.TestResults {
        return try Tensorflow.TestResults.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.TestResults {
        return try Tensorflow.TestResults.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.TestResults {
        return try Tensorflow.TestResults.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.TestResults {
        return try Tensorflow.TestResults.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "target": return self.target
        case "entries": return self.entries
        case "buildConfiguration": return self.buildConfiguration
        case "commitId": return self.commitId
        case "startTime": return self.startTime
        case "runTime": return self.runTime
        case "machineConfiguration": return self.machineConfiguration
        case "runConfiguration": return self.runConfiguration
        case "name": return self.name
        case "benchmarkType": return self.benchmarkType
        case "runMode": return self.runMode
        default: return nil
        }
    }
}
extension Tensorflow.TestResults.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "target": return self.target
            case "entries": return self.entries
            case "buildConfiguration": return self.buildConfiguration
            case "commitId": return self.commitId
            case "startTime": return self.startTime
            case "runTime": return self.runTime
            case "machineConfiguration": return self.machineConfiguration
            case "runConfiguration": return self.runConfiguration
            case "name": return self.name
            case "benchmarkType": return self.benchmarkType
            case "runMode": return self.runMode
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "target":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.target = newSubscriptValue
            case "entries":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.BenchmarkEntries else {
                    return
                }
                self.entries = newSubscriptValue
            case "buildConfiguration":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.BuildConfiguration else {
                    return
                }
                self.buildConfiguration = newSubscriptValue
            case "commitId":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.CommitId else {
                    return
                }
                self.commitId = newSubscriptValue
            case "startTime":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.startTime = newSubscriptValue
            case "runTime":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.runTime = newSubscriptValue
            case "machineConfiguration":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.MachineConfiguration else {
                    return
                }
                self.machineConfiguration = newSubscriptValue
            case "runConfiguration":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.RunConfiguration else {
                    return
                }
                self.runConfiguration = newSubscriptValue
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "benchmarkType":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.TestResults.BenchmarkType else {
                    return
                }
                self.benchmarkType = newSubscriptValue
            case "runMode":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.runMode = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

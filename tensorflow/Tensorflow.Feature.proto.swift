/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "feature.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { }

public extension Tensorflow {
    public struct FeatureRoot {
        public static let `default` = FeatureRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    /// Containers to hold repeated fundamental values.
    final public class BytesList : GeneratedMessage {

        public static func == (lhs: Tensorflow.BytesList, rhs: Tensorflow.BytesList) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.value == rhs.value)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var value:Array<Data> = Array<Data>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if !value.isEmpty {
                for oneValuevalue in value {
                    try codedOutputStream.writeData(fieldNumber: 1, value:oneValuevalue)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            var dataSizeValue:Int32 = 0
            for oneValuevalue in value {
                dataSizeValue += oneValuevalue.computeDataSizeNoTag()
            }
            serialize_size += dataSizeValue
            serialize_size += 1 * Int32(value.count)
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.BytesList.Builder {
            return Tensorflow.BytesList.classBuilder() as! Tensorflow.BytesList.Builder
        }
        public func getBuilder() -> Tensorflow.BytesList.Builder {
            return classBuilder() as! Tensorflow.BytesList.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BytesList.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BytesList.Builder()
        }
        public func toBuilder() throws -> Tensorflow.BytesList.Builder {
            return try Tensorflow.BytesList.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.BytesList) throws -> Tensorflow.BytesList.Builder {
            return try Tensorflow.BytesList.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !value.isEmpty {
                var jsonArrayValue:Array<String> = []
                for oneValueValue in value {
                    jsonArrayValue.append(oneValueValue.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0)))
                }
                jsonMap["value"] = jsonArrayValue
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BytesList {
            return try Tensorflow.BytesList.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.BytesList {
            return try Tensorflow.BytesList.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var valueElementIndex:Int = 0
            for oneValueValue in value  {
                output += "\(indent) value[\(valueElementIndex)]: \(oneValueValue)\n"
                valueElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneValueValue in value {
                    hashCode = (hashCode &* 31) &+ oneValueValue.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.BytesList"
        }
        override public func className() -> String {
            return "Tensorflow.BytesList"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.BytesList = Tensorflow.BytesList()
            public func getMessage() -> Tensorflow.BytesList {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var value:Array<Data> {
                get {
                    return builderResult.value
                }
                set (array) {
                    builderResult.value = array
                }
            }
            @discardableResult
            public func setValue(_ value:Array<Data>) -> Tensorflow.BytesList.Builder {
                self.value = value
                return self
            }
            @discardableResult
            public func clearValue() -> Tensorflow.BytesList.Builder {
                builderResult.value.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.BytesList.Builder {
                builderResult = Tensorflow.BytesList()
                return self
            }
            override public func clone() throws -> Tensorflow.BytesList.Builder {
                return try Tensorflow.BytesList.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.BytesList {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.BytesList {
                let returnMe:Tensorflow.BytesList = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.BytesList) throws -> Tensorflow.BytesList.Builder {
                if other == Tensorflow.BytesList() {
                    return self
                }
                if !other.value.isEmpty {
                    builderResult.value += other.value
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BytesList.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BytesList.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        value += [try codedInputStream.readData()]

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BytesList.Builder {
                let resultDecodedBuilder = Tensorflow.BytesList.Builder()
                if let jsonValueValue = jsonMap["value"] as? Array<String> {
                    var jsonArrayValue:Array<Data> = []
                    for oneValueValue in jsonValueValue {
                        jsonArrayValue.append(Data(base64Encoded:oneValueValue, options: Data.Base64DecodingOptions(rawValue:0))!)
                    }
                    resultDecodedBuilder.value = jsonArrayValue
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.BytesList.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.BytesList.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class FloatList : GeneratedMessage {

        public static func == (lhs: Tensorflow.FloatList, rhs: Tensorflow.FloatList) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.value == rhs.value)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var value:Array<Float> = Array<Float>()
        private var valueMemoizedSerializedSize:Int32 = -1
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if !value.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 10)
                try codedOutputStream.writeRawVarint32(value: valueMemoizedSerializedSize)
                for oneValuevalue in value {
                    try codedOutputStream.writeFloatNoTag(value: oneValuevalue)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            var dataSizeValue:Int32 = 0
            dataSizeValue = 4 * Int32(value.count)
            serialize_size += dataSizeValue
            if !value.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeValue.computeInt32SizeNoTag()
            }
            valueMemoizedSerializedSize = dataSizeValue
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.FloatList.Builder {
            return Tensorflow.FloatList.classBuilder() as! Tensorflow.FloatList.Builder
        }
        public func getBuilder() -> Tensorflow.FloatList.Builder {
            return classBuilder() as! Tensorflow.FloatList.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.FloatList.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.FloatList.Builder()
        }
        public func toBuilder() throws -> Tensorflow.FloatList.Builder {
            return try Tensorflow.FloatList.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.FloatList) throws -> Tensorflow.FloatList.Builder {
            return try Tensorflow.FloatList.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !value.isEmpty {
                var jsonArrayValue:Array<Float> = []
                for oneValueValue in value {
                    jsonArrayValue.append(Float(oneValueValue))
                }
                jsonMap["value"] = jsonArrayValue
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.FloatList {
            return try Tensorflow.FloatList.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.FloatList {
            return try Tensorflow.FloatList.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var valueElementIndex:Int = 0
            for oneValueValue in value  {
                output += "\(indent) value[\(valueElementIndex)]: \(oneValueValue)\n"
                valueElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneValueValue in value {
                    hashCode = (hashCode &* 31) &+ oneValueValue.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.FloatList"
        }
        override public func className() -> String {
            return "Tensorflow.FloatList"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.FloatList = Tensorflow.FloatList()
            public func getMessage() -> Tensorflow.FloatList {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var value:Array<Float> {
                get {
                    return builderResult.value
                }
                set (array) {
                    builderResult.value = array
                }
            }
            @discardableResult
            public func setValue(_ value:Array<Float>) -> Tensorflow.FloatList.Builder {
                self.value = value
                return self
            }
            @discardableResult
            public func clearValue() -> Tensorflow.FloatList.Builder {
                builderResult.value.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.FloatList.Builder {
                builderResult = Tensorflow.FloatList()
                return self
            }
            override public func clone() throws -> Tensorflow.FloatList.Builder {
                return try Tensorflow.FloatList.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.FloatList {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.FloatList {
                let returnMe:Tensorflow.FloatList = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.FloatList) throws -> Tensorflow.FloatList.Builder {
                if other == Tensorflow.FloatList() {
                    return self
                }
                if !other.value.isEmpty {
                    builderResult.value += other.value
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.FloatList.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FloatList.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.value.append(try codedInputStream.readFloat())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.FloatList.Builder {
                let resultDecodedBuilder = Tensorflow.FloatList.Builder()
                if let jsonValueValue = jsonMap["value"] as? Array<Float> {
                    var jsonArrayValue:Array<Float> = []
                    for oneValueValue in jsonValueValue {
                        jsonArrayValue.append(Float(oneValueValue))
                    }
                    resultDecodedBuilder.value = jsonArrayValue
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.FloatList.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.FloatList.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class Int64List : GeneratedMessage {

        public static func == (lhs: Tensorflow.Int64List, rhs: Tensorflow.Int64List) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.value == rhs.value)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var value:Array<Int64> = Array<Int64>()
        private var valueMemoizedSerializedSize:Int32 = -1
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if !value.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 10)
                try codedOutputStream.writeRawVarint32(value: valueMemoizedSerializedSize)
                for oneValuevalue in value {
                    try codedOutputStream.writeInt64NoTag(value: oneValuevalue)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            var dataSizeValue:Int32 = 0
            for oneValuevalue in value {
                dataSizeValue += oneValuevalue.computeInt64SizeNoTag()
            }
            serialize_size += dataSizeValue
            if !value.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeValue.computeInt32SizeNoTag()
            }
            valueMemoizedSerializedSize = dataSizeValue
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.Int64List.Builder {
            return Tensorflow.Int64List.classBuilder() as! Tensorflow.Int64List.Builder
        }
        public func getBuilder() -> Tensorflow.Int64List.Builder {
            return classBuilder() as! Tensorflow.Int64List.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Int64List.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Int64List.Builder()
        }
        public func toBuilder() throws -> Tensorflow.Int64List.Builder {
            return try Tensorflow.Int64List.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.Int64List) throws -> Tensorflow.Int64List.Builder {
            return try Tensorflow.Int64List.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !value.isEmpty {
                var jsonArrayValue:Array<String> = []
                for oneValueValue in value {
                    jsonArrayValue.append("\(oneValueValue)")
                }
                jsonMap["value"] = jsonArrayValue
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Int64List {
            return try Tensorflow.Int64List.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.Int64List {
            return try Tensorflow.Int64List.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var valueElementIndex:Int = 0
            for oneValueValue in value  {
                output += "\(indent) value[\(valueElementIndex)]: \(oneValueValue)\n"
                valueElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneValueValue in value {
                    hashCode = (hashCode &* 31) &+ oneValueValue.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.Int64List"
        }
        override public func className() -> String {
            return "Tensorflow.Int64List"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.Int64List = Tensorflow.Int64List()
            public func getMessage() -> Tensorflow.Int64List {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var value:Array<Int64> {
                get {
                    return builderResult.value
                }
                set (array) {
                    builderResult.value = array
                }
            }
            @discardableResult
            public func setValue(_ value:Array<Int64>) -> Tensorflow.Int64List.Builder {
                self.value = value
                return self
            }
            @discardableResult
            public func clearValue() -> Tensorflow.Int64List.Builder {
                builderResult.value.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.Int64List.Builder {
                builderResult = Tensorflow.Int64List()
                return self
            }
            override public func clone() throws -> Tensorflow.Int64List.Builder {
                return try Tensorflow.Int64List.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.Int64List {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.Int64List {
                let returnMe:Tensorflow.Int64List = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.Int64List) throws -> Tensorflow.Int64List.Builder {
                if other == Tensorflow.Int64List() {
                    return self
                }
                if !other.value.isEmpty {
                    builderResult.value += other.value
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Int64List.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Int64List.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.value.append(try codedInputStream.readInt64())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Int64List.Builder {
                let resultDecodedBuilder = Tensorflow.Int64List.Builder()
                if let jsonValueValue = jsonMap["value"] as? Array<String> {
                    var jsonArrayValue:Array<Int64> = []
                    for oneValueValue in jsonValueValue {
                        jsonArrayValue.append(Int64(oneValueValue)!)
                    }
                    resultDecodedBuilder.value = jsonArrayValue
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Int64List.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.Int64List.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Containers for non-sequential data.
    final public class Feature : GeneratedMessage {

        public static func == (lhs: Tensorflow.Feature, rhs: Tensorflow.Feature) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasBytesList == rhs.hasBytesList) && (!lhs.hasBytesList || lhs.bytesList == rhs.bytesList)
            fieldCheck = fieldCheck && (lhs.hasFloatList == rhs.hasFloatList) && (!lhs.hasFloatList || lhs.floatList == rhs.floatList)
            fieldCheck = fieldCheck && (lhs.hasInt64List == rhs.hasInt64List) && (!lhs.hasInt64List || lhs.int64List == rhs.int64List)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //OneOf declaration start

        /// Each feature can be exactly one kind.
        public enum Kind {
            case OneOfKindNotSet

            public func checkOneOfIsSet() -> Bool {
                switch self {
                case .OneOfKindNotSet: return false
                default: return true
                }
            }
            case BytesList(Tensorflow.BytesList)

            public static func getBytesList(_ value:Kind) -> Tensorflow.BytesList? {
                switch value {
                case .BytesList(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case FloatList(Tensorflow.FloatList)

            public static func getFloatList(_ value:Kind) -> Tensorflow.FloatList? {
                switch value {
                case .FloatList(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case Int64List(Tensorflow.Int64List)

            public static func getInt64List(_ value:Kind) -> Tensorflow.Int64List? {
                switch value {
                case .Int64List(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
        }
        //OneOf declaration end

        fileprivate var storageKind:Feature.Kind =  Feature.Kind.OneOfKindNotSet
        public func getOneOfKind() ->  Feature.Kind {
            let copyObjectKind = storageKind
            return copyObjectKind
        }
        public fileprivate(set) var bytesList:Tensorflow.BytesList!{
            get {
                return Feature.Kind.getBytesList(storageKind)
            }
            set (newvalue) {
                storageKind = Feature.Kind.BytesList(newvalue)
            }
        }
        public fileprivate(set) var hasBytesList:Bool {
            get {
                guard let _ = Feature.Kind.getBytesList(storageKind) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var floatList:Tensorflow.FloatList!{
            get {
                return Feature.Kind.getFloatList(storageKind)
            }
            set (newvalue) {
                storageKind = Feature.Kind.FloatList(newvalue)
            }
        }
        public fileprivate(set) var hasFloatList:Bool {
            get {
                guard let _ = Feature.Kind.getFloatList(storageKind) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var int64List:Tensorflow.Int64List!{
            get {
                return Feature.Kind.getInt64List(storageKind)
            }
            set (newvalue) {
                storageKind = Feature.Kind.Int64List(newvalue)
            }
        }
        public fileprivate(set) var hasInt64List:Bool {
            get {
                guard let _ = Feature.Kind.getInt64List(storageKind) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasBytesList {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:bytesList)
            }
            if hasFloatList {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:floatList)
            }
            if hasInt64List {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:int64List)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasBytesList {
                if let varSizebytesList = bytesList?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizebytesList
                }
            }
            if hasFloatList {
                if let varSizefloatList = floatList?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizefloatList
                }
            }
            if hasInt64List {
                if let varSizeint64List = int64List?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizeint64List
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.Feature.Builder {
            return Tensorflow.Feature.classBuilder() as! Tensorflow.Feature.Builder
        }
        public func getBuilder() -> Tensorflow.Feature.Builder {
            return classBuilder() as! Tensorflow.Feature.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Feature.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Feature.Builder()
        }
        public func toBuilder() throws -> Tensorflow.Feature.Builder {
            return try Tensorflow.Feature.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.Feature) throws -> Tensorflow.Feature.Builder {
            return try Tensorflow.Feature.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasBytesList {
                jsonMap["bytesList"] = try bytesList.encode()
            }
            if hasFloatList {
                jsonMap["floatList"] = try floatList.encode()
            }
            if hasInt64List {
                jsonMap["int64List"] = try int64List.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Feature {
            return try Tensorflow.Feature.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.Feature {
            return try Tensorflow.Feature.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasBytesList {
                output += "\(indent) bytesList {\n"
                if let outDescBytesList = bytesList {
                    output += try outDescBytesList.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasFloatList {
                output += "\(indent) floatList {\n"
                if let outDescFloatList = floatList {
                    output += try outDescFloatList.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasInt64List {
                output += "\(indent) int64List {\n"
                if let outDescInt64List = int64List {
                    output += try outDescInt64List.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasBytesList {
                    if let hashValuebytesList = bytesList?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuebytesList
                    }
                }
                if hasFloatList {
                    if let hashValuefloatList = floatList?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuefloatList
                    }
                }
                if hasInt64List {
                    if let hashValueint64List = int64List?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueint64List
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.Feature"
        }
        override public func className() -> String {
            return "Tensorflow.Feature"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.Feature = Tensorflow.Feature()
            public func getMessage() -> Tensorflow.Feature {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var bytesList:Tensorflow.BytesList! {
                get {
                    if bytesListBuilder_ != nil {
                        builderResult.bytesList = bytesListBuilder_.getMessage()
                    }
                    return builderResult.bytesList
                }
                set (value) {
                    builderResult.hasBytesList = true
                    builderResult.bytesList = value
                }
            }
            public var hasBytesList:Bool {
                get {
                    return builderResult.hasBytesList
                }
            }
            fileprivate var bytesListBuilder_:Tensorflow.BytesList.Builder! {
                didSet {
                    builderResult.hasBytesList = true
                }
            }
            public func getBytesListBuilder() -> Tensorflow.BytesList.Builder {
                if bytesListBuilder_ == nil {
                    bytesListBuilder_ = Tensorflow.BytesList.Builder()
                    builderResult.bytesList = bytesListBuilder_.getMessage()
                    if bytesList != nil {
                        try! bytesListBuilder_.mergeFrom(other: bytesList)
                    }
                }
                return bytesListBuilder_
            }
            @discardableResult
            public func setBytesList(_ value:Tensorflow.BytesList!) -> Tensorflow.Feature.Builder {
                self.bytesList = value
                return self
            }
            @discardableResult
            public func mergeBytesList(value:Tensorflow.BytesList) throws -> Tensorflow.Feature.Builder {
                if builderResult.hasBytesList {
                    builderResult.bytesList = try Tensorflow.BytesList.builderWithPrototype(prototype:builderResult.bytesList).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.bytesList = value
                }
                builderResult.hasBytesList = true
                return self
            }
            @discardableResult
            public func clearBytesList() -> Tensorflow.Feature.Builder {
                bytesListBuilder_ = nil
                builderResult.hasBytesList = false
                builderResult.bytesList = nil
                return self
            }
            public var floatList:Tensorflow.FloatList! {
                get {
                    if floatListBuilder_ != nil {
                        builderResult.floatList = floatListBuilder_.getMessage()
                    }
                    return builderResult.floatList
                }
                set (value) {
                    builderResult.hasFloatList = true
                    builderResult.floatList = value
                }
            }
            public var hasFloatList:Bool {
                get {
                    return builderResult.hasFloatList
                }
            }
            fileprivate var floatListBuilder_:Tensorflow.FloatList.Builder! {
                didSet {
                    builderResult.hasFloatList = true
                }
            }
            public func getFloatListBuilder() -> Tensorflow.FloatList.Builder {
                if floatListBuilder_ == nil {
                    floatListBuilder_ = Tensorflow.FloatList.Builder()
                    builderResult.floatList = floatListBuilder_.getMessage()
                    if floatList != nil {
                        try! floatListBuilder_.mergeFrom(other: floatList)
                    }
                }
                return floatListBuilder_
            }
            @discardableResult
            public func setFloatList(_ value:Tensorflow.FloatList!) -> Tensorflow.Feature.Builder {
                self.floatList = value
                return self
            }
            @discardableResult
            public func mergeFloatList(value:Tensorflow.FloatList) throws -> Tensorflow.Feature.Builder {
                if builderResult.hasFloatList {
                    builderResult.floatList = try Tensorflow.FloatList.builderWithPrototype(prototype:builderResult.floatList).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.floatList = value
                }
                builderResult.hasFloatList = true
                return self
            }
            @discardableResult
            public func clearFloatList() -> Tensorflow.Feature.Builder {
                floatListBuilder_ = nil
                builderResult.hasFloatList = false
                builderResult.floatList = nil
                return self
            }
            public var int64List:Tensorflow.Int64List! {
                get {
                    if int64ListBuilder_ != nil {
                        builderResult.int64List = int64ListBuilder_.getMessage()
                    }
                    return builderResult.int64List
                }
                set (value) {
                    builderResult.hasInt64List = true
                    builderResult.int64List = value
                }
            }
            public var hasInt64List:Bool {
                get {
                    return builderResult.hasInt64List
                }
            }
            fileprivate var int64ListBuilder_:Tensorflow.Int64List.Builder! {
                didSet {
                    builderResult.hasInt64List = true
                }
            }
            public func getInt64ListBuilder() -> Tensorflow.Int64List.Builder {
                if int64ListBuilder_ == nil {
                    int64ListBuilder_ = Tensorflow.Int64List.Builder()
                    builderResult.int64List = int64ListBuilder_.getMessage()
                    if int64List != nil {
                        try! int64ListBuilder_.mergeFrom(other: int64List)
                    }
                }
                return int64ListBuilder_
            }
            @discardableResult
            public func setInt64List(_ value:Tensorflow.Int64List!) -> Tensorflow.Feature.Builder {
                self.int64List = value
                return self
            }
            @discardableResult
            public func mergeInt64List(value:Tensorflow.Int64List) throws -> Tensorflow.Feature.Builder {
                if builderResult.hasInt64List {
                    builderResult.int64List = try Tensorflow.Int64List.builderWithPrototype(prototype:builderResult.int64List).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.int64List = value
                }
                builderResult.hasInt64List = true
                return self
            }
            @discardableResult
            public func clearInt64List() -> Tensorflow.Feature.Builder {
                int64ListBuilder_ = nil
                builderResult.hasInt64List = false
                builderResult.int64List = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.Feature.Builder {
                builderResult = Tensorflow.Feature()
                return self
            }
            override public func clone() throws -> Tensorflow.Feature.Builder {
                return try Tensorflow.Feature.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.Feature {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.Feature {
                let returnMe:Tensorflow.Feature = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.Feature) throws -> Tensorflow.Feature.Builder {
                if other == Tensorflow.Feature() {
                    return self
                }
                if (other.hasBytesList) {
                    try mergeBytesList(value: other.bytesList)
                }
                if (other.hasFloatList) {
                    try mergeFloatList(value: other.floatList)
                }
                if (other.hasInt64List) {
                    try mergeInt64List(value: other.int64List)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Feature.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Feature.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Tensorflow.BytesList.Builder = Tensorflow.BytesList.Builder()
                        if hasBytesList {
                            try subBuilder.mergeFrom(other: bytesList)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        bytesList = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Tensorflow.FloatList.Builder = Tensorflow.FloatList.Builder()
                        if hasFloatList {
                            try subBuilder.mergeFrom(other: floatList)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        floatList = subBuilder.buildPartial()

                    case 26:
                        let subBuilder:Tensorflow.Int64List.Builder = Tensorflow.Int64List.Builder()
                        if hasInt64List {
                            try subBuilder.mergeFrom(other: int64List)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        int64List = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Feature.Builder {
                let resultDecodedBuilder = Tensorflow.Feature.Builder()
                if let jsonValueBytesList = jsonMap["bytesList"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.bytesList = try Tensorflow.BytesList.Builder.decodeToBuilder(jsonMap:jsonValueBytesList).build()

                }
                if let jsonValueFloatList = jsonMap["floatList"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.floatList = try Tensorflow.FloatList.Builder.decodeToBuilder(jsonMap:jsonValueFloatList).build()

                }
                if let jsonValueInt64List = jsonMap["int64List"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.int64List = try Tensorflow.Int64List.Builder.decodeToBuilder(jsonMap:jsonValueInt64List).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Feature.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.Feature.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class Features : GeneratedMessage {

        public static func == (lhs: Tensorflow.Features, rhs: Tensorflow.Features) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasFeature == rhs.hasFeature) && (!lhs.hasFeature || lhs.feature == rhs.feature)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        final public class FeatureEntry : GeneratedMessage {

            public static func == (lhs: Tensorflow.Features.FeatureEntry, rhs: Tensorflow.Features.FeatureEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:String = ""
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:Tensorflow.Feature!
            public fileprivate(set) var hasValue:Bool = false
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeString(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeMessage(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeStringSize(fieldNumber: 1)
                }
                if hasValue {
                    if let varSizevalue = value?.computeMessageSize(fieldNumber: 2) {
                        serialize_size += varSizevalue
                    }
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.Features.FeatureEntry.Builder {
                return Tensorflow.Features.FeatureEntry.classBuilder() as! Tensorflow.Features.FeatureEntry.Builder
            }
            public func getBuilder() -> Tensorflow.Features.FeatureEntry.Builder {
                return classBuilder() as! Tensorflow.Features.FeatureEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.Features.FeatureEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.Features.FeatureEntry.Builder()
            }
            public func toBuilder() throws -> Tensorflow.Features.FeatureEntry.Builder {
                return try Tensorflow.Features.FeatureEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.Features.FeatureEntry) throws -> Tensorflow.Features.FeatureEntry.Builder {
                return try Tensorflow.Features.FeatureEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = key
                }
                if hasValue {
                    jsonMap["value"] = try value.encode()
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Features.FeatureEntry {
                return try Tensorflow.Features.FeatureEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.Features.FeatureEntry {
                return try Tensorflow.Features.FeatureEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value {\n"
                    if let outDescValue = value {
                        output += try outDescValue.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        if let hashValuevalue = value?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuevalue
                        }
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.Features.FeatureEntry"
            }
            override public func className() -> String {
                return "Tensorflow.Features.FeatureEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.Features.FeatureEntry = Tensorflow.Features.FeatureEntry()
                public func getMessage() -> Tensorflow.Features.FeatureEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:String {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:String) -> Tensorflow.Features.FeatureEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> Tensorflow.Features.FeatureEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = ""
                    return self
                }
                public var value:Tensorflow.Feature! {
                    get {
                        if valueBuilder_ != nil {
                            builderResult.value = valueBuilder_.getMessage()
                        }
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                fileprivate var valueBuilder_:Tensorflow.Feature.Builder! {
                    didSet {
                        builderResult.hasValue = true
                    }
                }
                public func getValueBuilder() -> Tensorflow.Feature.Builder {
                    if valueBuilder_ == nil {
                        valueBuilder_ = Tensorflow.Feature.Builder()
                        builderResult.value = valueBuilder_.getMessage()
                        if value != nil {
                            try! valueBuilder_.mergeFrom(other: value)
                        }
                    }
                    return valueBuilder_
                }
                @discardableResult
                public func setValue(_ value:Tensorflow.Feature!) -> Tensorflow.Features.FeatureEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func mergeValue(value:Tensorflow.Feature) throws -> Tensorflow.Features.FeatureEntry.Builder {
                    if builderResult.hasValue {
                        builderResult.value = try Tensorflow.Feature.builderWithPrototype(prototype:builderResult.value).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.value = value
                    }
                    builderResult.hasValue = true
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.Features.FeatureEntry.Builder {
                    valueBuilder_ = nil
                    builderResult.hasValue = false
                    builderResult.value = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.Features.FeatureEntry.Builder {
                    builderResult = Tensorflow.Features.FeatureEntry()
                    return self
                }
                override public func clone() throws -> Tensorflow.Features.FeatureEntry.Builder {
                    return try Tensorflow.Features.FeatureEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.Features.FeatureEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.Features.FeatureEntry {
                    let returnMe:Tensorflow.Features.FeatureEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.Features.FeatureEntry) throws -> Tensorflow.Features.FeatureEntry.Builder {
                    if other == Tensorflow.Features.FeatureEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if (other.hasValue) {
                        try mergeValue(value: other.value)
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Features.FeatureEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Features.FeatureEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            key = try codedInputStream.readString()

                        case 18:
                            let subBuilder:Tensorflow.Feature.Builder = Tensorflow.Feature.Builder()
                            if hasValue {
                                try subBuilder.mergeFrom(other: value)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            value = subBuilder.buildPartial()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Features.FeatureEntry.Builder {
                    let resultDecodedBuilder = Tensorflow.Features.FeatureEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = jsonValueKey
                    }
                    if let jsonValueValue = jsonMap["value"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.value = try Tensorflow.Feature.Builder.decodeToBuilder(jsonMap:jsonValueValue).build()

                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Features.FeatureEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.Features.FeatureEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        /// Map from feature name to feature.
        public fileprivate(set) var feature:Dictionary<String,Tensorflow.Feature> = Dictionary<String,Tensorflow.Feature>()

        public fileprivate(set) var hasFeature:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasFeature {
                for (keyFeature, valueFeature) in feature {
                    let valueOfFeature = try! Tensorflow.Features.FeatureEntry.Builder().setKey(keyFeature).setValue(valueFeature).build()
                      try codedOutputStream.writeMessage(fieldNumber: 1, value:valueOfFeature)
                  }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasFeature {
                  for (keyFeature, valueFeature) in feature {
                      let valueOfFeature = try! Tensorflow.Features.FeatureEntry.Builder().setKey(keyFeature).setValue(valueFeature).build()
                serialize_size += valueOfFeature.computeMessageSize(fieldNumber: 1)
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.Features.Builder {
            return Tensorflow.Features.classBuilder() as! Tensorflow.Features.Builder
        }
        public func getBuilder() -> Tensorflow.Features.Builder {
            return classBuilder() as! Tensorflow.Features.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Features.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Features.Builder()
        }
        public func toBuilder() throws -> Tensorflow.Features.Builder {
            return try Tensorflow.Features.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.Features) throws -> Tensorflow.Features.Builder {
            return try Tensorflow.Features.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasFeature {
                var mapFeature = Dictionary<String, Dictionary<String,Any>>()
                for (keyFeature, valueFeature) in feature {
                    mapFeature["\(keyFeature)"] = try valueFeature.encode()
                }
                jsonMap["feature"] = mapFeature
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Features {
            return try Tensorflow.Features.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.Features {
            return try Tensorflow.Features.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasFeature {
                output += "\(indent) feature: \(feature) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasFeature {
                    for (keyFeature, valueFeature) in feature {
                        hashCode = (hashCode &* 31) &+ keyFeature.hashValue
                        hashCode = (hashCode &* 31) &+ valueFeature.hashValue
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.Features"
        }
        override public func className() -> String {
            return "Tensorflow.Features"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.Features = Tensorflow.Features()
            public func getMessage() -> Tensorflow.Features {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Map from feature name to feature.
            public var hasFeature:Bool {
                get {
                    return builderResult.hasFeature
                }
            }
            public var feature:Dictionary<String,Tensorflow.Feature> {
                get {
                    return builderResult.feature
                }
                set (value) {
                    builderResult.hasFeature = true
                    builderResult.feature = value
                }
            }
            @discardableResult
            public func setFeature(_ value:Dictionary<String,Tensorflow.Feature>) -> Tensorflow.Features.Builder {
                self.feature = value
                return self
            }
            @discardableResult
            public func clearFeature() -> Tensorflow.Features.Builder{
                builderResult.hasFeature = false
                builderResult.feature = Dictionary<String,Tensorflow.Feature>()
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.Features.Builder {
                builderResult = Tensorflow.Features()
                return self
            }
            override public func clone() throws -> Tensorflow.Features.Builder {
                return try Tensorflow.Features.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.Features {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.Features {
                let returnMe:Tensorflow.Features = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.Features) throws -> Tensorflow.Features.Builder {
                if other == Tensorflow.Features() {
                    return self
                }
                if other.hasFeature {
                    feature = other.feature
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Features.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Features.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Tensorflow.Features.FeatureEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfFeature = subBuilder.buildPartial()
                        feature[buildOfFeature.key] = buildOfFeature.value

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Features.Builder {
                let resultDecodedBuilder = Tensorflow.Features.Builder()
                if let jsonValueFeature = jsonMap["feature"] as? Dictionary<String, Dictionary<String,Any>> {
                    var mapFeature = Dictionary<String, Tensorflow.Feature>()
                    for (keyFeature, valueFeature) in jsonValueFeature {
                        guard let keyFromFeature = String(keyFeature) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapFeature[keyFromFeature] = try Tensorflow.Feature.Builder.decodeToBuilder(jsonMap:valueFeature).build()

                    }
                    resultDecodedBuilder.feature = mapFeature
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Features.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.Features.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Containers for sequential data.
    /// A FeatureList contains lists of Features.  These may hold zero or more
    /// Feature values.
    /// FeatureLists are organized into categories by name.  The FeatureLists message
    /// contains the mapping from name to FeatureList.
    final public class FeatureList : GeneratedMessage {

        public static func == (lhs: Tensorflow.FeatureList, rhs: Tensorflow.FeatureList) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.feature == rhs.feature)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var feature:Array<Tensorflow.Feature>  = Array<Tensorflow.Feature>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementFeature in feature {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementFeature)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementFeature in feature {
                serialize_size += oneElementFeature.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.FeatureList.Builder {
            return Tensorflow.FeatureList.classBuilder() as! Tensorflow.FeatureList.Builder
        }
        public func getBuilder() -> Tensorflow.FeatureList.Builder {
            return classBuilder() as! Tensorflow.FeatureList.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.FeatureList.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.FeatureList.Builder()
        }
        public func toBuilder() throws -> Tensorflow.FeatureList.Builder {
            return try Tensorflow.FeatureList.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.FeatureList) throws -> Tensorflow.FeatureList.Builder {
            return try Tensorflow.FeatureList.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !feature.isEmpty {
                var jsonArrayFeature:Array<Dictionary<String,Any>> = []
                for oneValueFeature in feature {
                    let ecodedMessageFeature = try oneValueFeature.encode()
                    jsonArrayFeature.append(ecodedMessageFeature)
                }
                jsonMap["feature"] = jsonArrayFeature
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.FeatureList {
            return try Tensorflow.FeatureList.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.FeatureList {
            return try Tensorflow.FeatureList.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var featureElementIndex:Int = 0
            for oneElementFeature in feature {
                output += "\(indent) feature[\(featureElementIndex)] {\n"
                output += try oneElementFeature.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                featureElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementFeature in feature {
                    hashCode = (hashCode &* 31) &+ oneElementFeature.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.FeatureList"
        }
        override public func className() -> String {
            return "Tensorflow.FeatureList"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.FeatureList = Tensorflow.FeatureList()
            public func getMessage() -> Tensorflow.FeatureList {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var feature:Array<Tensorflow.Feature> {
                get {
                    return builderResult.feature
                }
                set (value) {
                    builderResult.feature = value
                }
            }
            @discardableResult
            public func setFeature(_ value:Array<Tensorflow.Feature>) -> Tensorflow.FeatureList.Builder {
                self.feature = value
                return self
            }
            @discardableResult
            public func clearFeature() -> Tensorflow.FeatureList.Builder {
                builderResult.feature.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.FeatureList.Builder {
                builderResult = Tensorflow.FeatureList()
                return self
            }
            override public func clone() throws -> Tensorflow.FeatureList.Builder {
                return try Tensorflow.FeatureList.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.FeatureList {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.FeatureList {
                let returnMe:Tensorflow.FeatureList = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.FeatureList) throws -> Tensorflow.FeatureList.Builder {
                if other == Tensorflow.FeatureList() {
                    return self
                }
                if !other.feature.isEmpty  {
                     builderResult.feature += other.feature
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.FeatureList.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FeatureList.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Tensorflow.Feature.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        feature.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.FeatureList.Builder {
                let resultDecodedBuilder = Tensorflow.FeatureList.Builder()
                if let jsonValueFeature = jsonMap["feature"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayFeature:Array<Tensorflow.Feature> = []
                    for oneValueFeature in jsonValueFeature {
                        let messageFromStringFeature = try Tensorflow.Feature.Builder.decodeToBuilder(jsonMap:oneValueFeature).build()

                        jsonArrayFeature.append(messageFromStringFeature)
                    }
                    resultDecodedBuilder.feature = jsonArrayFeature
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.FeatureList.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.FeatureList.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class FeatureLists : GeneratedMessage {

        public static func == (lhs: Tensorflow.FeatureLists, rhs: Tensorflow.FeatureLists) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasFeatureList == rhs.hasFeatureList) && (!lhs.hasFeatureList || lhs.featureList == rhs.featureList)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        final public class FeatureListEntry : GeneratedMessage {

            public static func == (lhs: Tensorflow.FeatureLists.FeatureListEntry, rhs: Tensorflow.FeatureLists.FeatureListEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:String = ""
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:Tensorflow.FeatureList!
            public fileprivate(set) var hasValue:Bool = false
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeString(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeMessage(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeStringSize(fieldNumber: 1)
                }
                if hasValue {
                    if let varSizevalue = value?.computeMessageSize(fieldNumber: 2) {
                        serialize_size += varSizevalue
                    }
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.FeatureLists.FeatureListEntry.Builder {
                return Tensorflow.FeatureLists.FeatureListEntry.classBuilder() as! Tensorflow.FeatureLists.FeatureListEntry.Builder
            }
            public func getBuilder() -> Tensorflow.FeatureLists.FeatureListEntry.Builder {
                return classBuilder() as! Tensorflow.FeatureLists.FeatureListEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.FeatureLists.FeatureListEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.FeatureLists.FeatureListEntry.Builder()
            }
            public func toBuilder() throws -> Tensorflow.FeatureLists.FeatureListEntry.Builder {
                return try Tensorflow.FeatureLists.FeatureListEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.FeatureLists.FeatureListEntry) throws -> Tensorflow.FeatureLists.FeatureListEntry.Builder {
                return try Tensorflow.FeatureLists.FeatureListEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = key
                }
                if hasValue {
                    jsonMap["value"] = try value.encode()
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.FeatureLists.FeatureListEntry {
                return try Tensorflow.FeatureLists.FeatureListEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.FeatureLists.FeatureListEntry {
                return try Tensorflow.FeatureLists.FeatureListEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value {\n"
                    if let outDescValue = value {
                        output += try outDescValue.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        if let hashValuevalue = value?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuevalue
                        }
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.FeatureLists.FeatureListEntry"
            }
            override public func className() -> String {
                return "Tensorflow.FeatureLists.FeatureListEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.FeatureLists.FeatureListEntry = Tensorflow.FeatureLists.FeatureListEntry()
                public func getMessage() -> Tensorflow.FeatureLists.FeatureListEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:String {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:String) -> Tensorflow.FeatureLists.FeatureListEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> Tensorflow.FeatureLists.FeatureListEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = ""
                    return self
                }
                public var value:Tensorflow.FeatureList! {
                    get {
                        if valueBuilder_ != nil {
                            builderResult.value = valueBuilder_.getMessage()
                        }
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                fileprivate var valueBuilder_:Tensorflow.FeatureList.Builder! {
                    didSet {
                        builderResult.hasValue = true
                    }
                }
                public func getValueBuilder() -> Tensorflow.FeatureList.Builder {
                    if valueBuilder_ == nil {
                        valueBuilder_ = Tensorflow.FeatureList.Builder()
                        builderResult.value = valueBuilder_.getMessage()
                        if value != nil {
                            try! valueBuilder_.mergeFrom(other: value)
                        }
                    }
                    return valueBuilder_
                }
                @discardableResult
                public func setValue(_ value:Tensorflow.FeatureList!) -> Tensorflow.FeatureLists.FeatureListEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func mergeValue(value:Tensorflow.FeatureList) throws -> Tensorflow.FeatureLists.FeatureListEntry.Builder {
                    if builderResult.hasValue {
                        builderResult.value = try Tensorflow.FeatureList.builderWithPrototype(prototype:builderResult.value).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.value = value
                    }
                    builderResult.hasValue = true
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.FeatureLists.FeatureListEntry.Builder {
                    valueBuilder_ = nil
                    builderResult.hasValue = false
                    builderResult.value = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.FeatureLists.FeatureListEntry.Builder {
                    builderResult = Tensorflow.FeatureLists.FeatureListEntry()
                    return self
                }
                override public func clone() throws -> Tensorflow.FeatureLists.FeatureListEntry.Builder {
                    return try Tensorflow.FeatureLists.FeatureListEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.FeatureLists.FeatureListEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.FeatureLists.FeatureListEntry {
                    let returnMe:Tensorflow.FeatureLists.FeatureListEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.FeatureLists.FeatureListEntry) throws -> Tensorflow.FeatureLists.FeatureListEntry.Builder {
                    if other == Tensorflow.FeatureLists.FeatureListEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if (other.hasValue) {
                        try mergeValue(value: other.value)
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.FeatureLists.FeatureListEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FeatureLists.FeatureListEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            key = try codedInputStream.readString()

                        case 18:
                            let subBuilder:Tensorflow.FeatureList.Builder = Tensorflow.FeatureList.Builder()
                            if hasValue {
                                try subBuilder.mergeFrom(other: value)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            value = subBuilder.buildPartial()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.FeatureLists.FeatureListEntry.Builder {
                    let resultDecodedBuilder = Tensorflow.FeatureLists.FeatureListEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = jsonValueKey
                    }
                    if let jsonValueValue = jsonMap["value"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.value = try Tensorflow.FeatureList.Builder.decodeToBuilder(jsonMap:jsonValueValue).build()

                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.FeatureLists.FeatureListEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.FeatureLists.FeatureListEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        /// Map from feature name to feature list.
        public fileprivate(set) var featureList:Dictionary<String,Tensorflow.FeatureList> = Dictionary<String,Tensorflow.FeatureList>()

        public fileprivate(set) var hasFeatureList:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasFeatureList {
                for (keyFeatureList, valueFeatureList) in featureList {
                    let valueOfFeatureList = try! Tensorflow.FeatureLists.FeatureListEntry.Builder().setKey(keyFeatureList).setValue(valueFeatureList).build()
                      try codedOutputStream.writeMessage(fieldNumber: 1, value:valueOfFeatureList)
                  }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasFeatureList {
                  for (keyFeatureList, valueFeatureList) in featureList {
                      let valueOfFeatureList = try! Tensorflow.FeatureLists.FeatureListEntry.Builder().setKey(keyFeatureList).setValue(valueFeatureList).build()
                serialize_size += valueOfFeatureList.computeMessageSize(fieldNumber: 1)
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.FeatureLists.Builder {
            return Tensorflow.FeatureLists.classBuilder() as! Tensorflow.FeatureLists.Builder
        }
        public func getBuilder() -> Tensorflow.FeatureLists.Builder {
            return classBuilder() as! Tensorflow.FeatureLists.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.FeatureLists.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.FeatureLists.Builder()
        }
        public func toBuilder() throws -> Tensorflow.FeatureLists.Builder {
            return try Tensorflow.FeatureLists.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.FeatureLists) throws -> Tensorflow.FeatureLists.Builder {
            return try Tensorflow.FeatureLists.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasFeatureList {
                var mapFeatureList = Dictionary<String, Dictionary<String,Any>>()
                for (keyFeatureList, valueFeatureList) in featureList {
                    mapFeatureList["\(keyFeatureList)"] = try valueFeatureList.encode()
                }
                jsonMap["featureList"] = mapFeatureList
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.FeatureLists {
            return try Tensorflow.FeatureLists.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.FeatureLists {
            return try Tensorflow.FeatureLists.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasFeatureList {
                output += "\(indent) featureList: \(featureList) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasFeatureList {
                    for (keyFeatureList, valueFeatureList) in featureList {
                        hashCode = (hashCode &* 31) &+ keyFeatureList.hashValue
                        hashCode = (hashCode &* 31) &+ valueFeatureList.hashValue
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.FeatureLists"
        }
        override public func className() -> String {
            return "Tensorflow.FeatureLists"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.FeatureLists = Tensorflow.FeatureLists()
            public func getMessage() -> Tensorflow.FeatureLists {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Map from feature name to feature list.
            public var hasFeatureList:Bool {
                get {
                    return builderResult.hasFeatureList
                }
            }
            public var featureList:Dictionary<String,Tensorflow.FeatureList> {
                get {
                    return builderResult.featureList
                }
                set (value) {
                    builderResult.hasFeatureList = true
                    builderResult.featureList = value
                }
            }
            @discardableResult
            public func setFeatureList(_ value:Dictionary<String,Tensorflow.FeatureList>) -> Tensorflow.FeatureLists.Builder {
                self.featureList = value
                return self
            }
            @discardableResult
            public func clearFeatureList() -> Tensorflow.FeatureLists.Builder{
                builderResult.hasFeatureList = false
                builderResult.featureList = Dictionary<String,Tensorflow.FeatureList>()
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.FeatureLists.Builder {
                builderResult = Tensorflow.FeatureLists()
                return self
            }
            override public func clone() throws -> Tensorflow.FeatureLists.Builder {
                return try Tensorflow.FeatureLists.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.FeatureLists {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.FeatureLists {
                let returnMe:Tensorflow.FeatureLists = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.FeatureLists) throws -> Tensorflow.FeatureLists.Builder {
                if other == Tensorflow.FeatureLists() {
                    return self
                }
                if other.hasFeatureList {
                    featureList = other.featureList
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.FeatureLists.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FeatureLists.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Tensorflow.FeatureLists.FeatureListEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfFeatureList = subBuilder.buildPartial()
                        featureList[buildOfFeatureList.key] = buildOfFeatureList.value

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.FeatureLists.Builder {
                let resultDecodedBuilder = Tensorflow.FeatureLists.Builder()
                if let jsonValueFeatureList = jsonMap["featureList"] as? Dictionary<String, Dictionary<String,Any>> {
                    var mapFeatureList = Dictionary<String, Tensorflow.FeatureList>()
                    for (keyFeatureList, valueFeatureList) in jsonValueFeatureList {
                        guard let keyFromFeatureList = String(keyFeatureList) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapFeatureList[keyFromFeatureList] = try Tensorflow.FeatureList.Builder.decodeToBuilder(jsonMap:valueFeatureList).build()

                    }
                    resultDecodedBuilder.featureList = mapFeatureList
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.FeatureLists.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.FeatureLists.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.BytesList: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.BytesList> {
        var mergedArray = Array<Tensorflow.BytesList>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.BytesList? {
        return try Tensorflow.BytesList.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.BytesList {
        return try Tensorflow.BytesList.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.FeatureRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BytesList {
        return try Tensorflow.BytesList.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.BytesList {
        return try Tensorflow.BytesList.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BytesList {
        return try Tensorflow.BytesList.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BytesList {
        return try Tensorflow.BytesList.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BytesList {
        return try Tensorflow.BytesList.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.BytesList.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Array<Data> else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.FloatList: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.FloatList> {
        var mergedArray = Array<Tensorflow.FloatList>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.FloatList? {
        return try Tensorflow.FloatList.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.FloatList {
        return try Tensorflow.FloatList.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.FeatureRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FloatList {
        return try Tensorflow.FloatList.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.FloatList {
        return try Tensorflow.FloatList.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FloatList {
        return try Tensorflow.FloatList.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.FloatList {
        return try Tensorflow.FloatList.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FloatList {
        return try Tensorflow.FloatList.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.FloatList.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Array<Float> else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Int64List: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Int64List> {
        var mergedArray = Array<Tensorflow.Int64List>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Int64List? {
        return try Tensorflow.Int64List.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Int64List {
        return try Tensorflow.Int64List.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.FeatureRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Int64List {
        return try Tensorflow.Int64List.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Int64List {
        return try Tensorflow.Int64List.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Int64List {
        return try Tensorflow.Int64List.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Int64List {
        return try Tensorflow.Int64List.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Int64List {
        return try Tensorflow.Int64List.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.Int64List.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Feature: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Feature> {
        var mergedArray = Array<Tensorflow.Feature>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Feature? {
        return try Tensorflow.Feature.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Feature {
        return try Tensorflow.Feature.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.FeatureRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Feature {
        return try Tensorflow.Feature.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Feature {
        return try Tensorflow.Feature.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Feature {
        return try Tensorflow.Feature.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Feature {
        return try Tensorflow.Feature.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Feature {
        return try Tensorflow.Feature.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "bytesList": return self.bytesList
        case "floatList": return self.floatList
        case "int64List": return self.int64List
        default: return nil
        }
    }
}
extension Tensorflow.Feature.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "bytesList": return self.bytesList
            case "floatList": return self.floatList
            case "int64List": return self.int64List
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "bytesList":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.BytesList else {
                    return
                }
                self.bytesList = newSubscriptValue
            case "floatList":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.FloatList else {
                    return
                }
                self.floatList = newSubscriptValue
            case "int64List":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Int64List else {
                    return
                }
                self.int64List = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Features: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Features> {
        var mergedArray = Array<Tensorflow.Features>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Features? {
        return try Tensorflow.Features.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Features {
        return try Tensorflow.Features.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.FeatureRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Features {
        return try Tensorflow.Features.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Features {
        return try Tensorflow.Features.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Features {
        return try Tensorflow.Features.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Features {
        return try Tensorflow.Features.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Features {
        return try Tensorflow.Features.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "feature": return self.feature
        default: return nil
        }
    }
}
extension Tensorflow.Features.FeatureEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Features.FeatureEntry> {
        var mergedArray = Array<Tensorflow.Features.FeatureEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Features.FeatureEntry? {
        return try Tensorflow.Features.FeatureEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Features.FeatureEntry {
        return try Tensorflow.Features.FeatureEntry.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.FeatureRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Features.FeatureEntry {
        return try Tensorflow.Features.FeatureEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Features.FeatureEntry {
        return try Tensorflow.Features.FeatureEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Features.FeatureEntry {
        return try Tensorflow.Features.FeatureEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Features.FeatureEntry {
        return try Tensorflow.Features.FeatureEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Features.FeatureEntry {
        return try Tensorflow.Features.FeatureEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.Features.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "feature": return self.feature
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "feature":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,Tensorflow.Feature> else {
                    return
                }
                self.feature = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Features.FeatureEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Feature else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.FeatureList: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.FeatureList> {
        var mergedArray = Array<Tensorflow.FeatureList>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.FeatureList? {
        return try Tensorflow.FeatureList.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.FeatureList {
        return try Tensorflow.FeatureList.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.FeatureRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FeatureList {
        return try Tensorflow.FeatureList.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.FeatureList {
        return try Tensorflow.FeatureList.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FeatureList {
        return try Tensorflow.FeatureList.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.FeatureList {
        return try Tensorflow.FeatureList.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FeatureList {
        return try Tensorflow.FeatureList.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "feature": return self.feature
        default: return nil
        }
    }
}
extension Tensorflow.FeatureList.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "feature": return self.feature
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "feature":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.Feature> else {
                    return
                }
                self.feature = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.FeatureLists: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.FeatureLists> {
        var mergedArray = Array<Tensorflow.FeatureLists>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.FeatureLists? {
        return try Tensorflow.FeatureLists.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.FeatureLists {
        return try Tensorflow.FeatureLists.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.FeatureRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FeatureLists {
        return try Tensorflow.FeatureLists.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.FeatureLists {
        return try Tensorflow.FeatureLists.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FeatureLists {
        return try Tensorflow.FeatureLists.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.FeatureLists {
        return try Tensorflow.FeatureLists.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FeatureLists {
        return try Tensorflow.FeatureLists.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "featureList": return self.featureList
        default: return nil
        }
    }
}
extension Tensorflow.FeatureLists.FeatureListEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.FeatureLists.FeatureListEntry> {
        var mergedArray = Array<Tensorflow.FeatureLists.FeatureListEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.FeatureLists.FeatureListEntry? {
        return try Tensorflow.FeatureLists.FeatureListEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.FeatureLists.FeatureListEntry {
        return try Tensorflow.FeatureLists.FeatureListEntry.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.FeatureRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FeatureLists.FeatureListEntry {
        return try Tensorflow.FeatureLists.FeatureListEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.FeatureLists.FeatureListEntry {
        return try Tensorflow.FeatureLists.FeatureListEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FeatureLists.FeatureListEntry {
        return try Tensorflow.FeatureLists.FeatureListEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.FeatureLists.FeatureListEntry {
        return try Tensorflow.FeatureLists.FeatureListEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.FeatureLists.FeatureListEntry {
        return try Tensorflow.FeatureLists.FeatureListEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.FeatureLists.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "featureList": return self.featureList
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "featureList":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,Tensorflow.FeatureList> else {
                    return
                }
                self.featureList = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.FeatureLists.FeatureListEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.FeatureList else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "tfprof_output.proto"
/// Syntax "Proto2"

import Foundation
import ProtocolBuffers


public struct Tensorflow { public struct Tfprof { }}

public extension Tensorflow.Tfprof {
    public struct TfprofOutputRoot {
        public static let `default` = TfprofOutputRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Tensorflow.TensorShapeRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.TypesRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    final public class TfprofTensorProto : GeneratedMessage {

        public static func == (lhs: Tensorflow.Tfprof.TfprofTensorProto, rhs: Tensorflow.Tfprof.TfprofTensorProto) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasDtype == rhs.hasDtype) && (!lhs.hasDtype || lhs.dtype == rhs.dtype)
            fieldCheck = fieldCheck && (lhs.valueDouble == rhs.valueDouble)
            fieldCheck = fieldCheck && (lhs.valueInt64 == rhs.valueInt64)
            fieldCheck = fieldCheck && (lhs.valueStr == rhs.valueStr)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var dtype:Tensorflow.DataType = Tensorflow.DataType.dtInvalid
        public fileprivate(set) var hasDtype:Bool = false
        /// Flatten tensor in row-major.
        /// Only one of the following array is set.
        public fileprivate(set) var valueDouble:Array<Double> = Array<Double>()
        public fileprivate(set) var valueInt64:Array<Int64> = Array<Int64>()
        public fileprivate(set) var valueStr:Array<String> = Array<String>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasDtype {
                try codedOutputStream.writeEnum(fieldNumber: 1, value:dtype.rawValue)
            }
            if !valueDouble.isEmpty {
                for oneValuevalueDouble in valueDouble {
                    try codedOutputStream.writeDouble(fieldNumber: 2, value:oneValuevalueDouble)
                }
            }
            if !valueInt64.isEmpty {
                for oneValuevalueInt64 in valueInt64 {
                    try codedOutputStream.writeInt64(fieldNumber: 3, value:oneValuevalueInt64)
                }
            }
            if !valueStr.isEmpty {
                for oneValuevalueStr in valueStr {
                    try codedOutputStream.writeString(fieldNumber: 4, value:oneValuevalueStr)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if (hasDtype) {
                serialize_size += dtype.rawValue.computeEnumSize(fieldNumber: 1)
            }
            var dataSizeValueDouble:Int32 = 0
            dataSizeValueDouble = 8 * Int32(valueDouble.count)
            serialize_size += dataSizeValueDouble
            serialize_size += 1 * Int32(valueDouble.count)
            var dataSizeValueInt64:Int32 = 0
            for oneValuevalueInt64 in valueInt64 {
                dataSizeValueInt64 += oneValuevalueInt64.computeInt64SizeNoTag()
            }
            serialize_size += dataSizeValueInt64
            serialize_size += 1 * Int32(valueInt64.count)
            var dataSizeValueStr:Int32 = 0
            for oneValuevalueStr in valueStr {
                dataSizeValueStr += oneValuevalueStr.computeStringSizeNoTag()
            }
            serialize_size += dataSizeValueStr
            serialize_size += 1 * Int32(valueStr.count)
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.Tfprof.TfprofTensorProto.Builder {
            return Tensorflow.Tfprof.TfprofTensorProto.classBuilder() as! Tensorflow.Tfprof.TfprofTensorProto.Builder
        }
        public func getBuilder() -> Tensorflow.Tfprof.TfprofTensorProto.Builder {
            return classBuilder() as! Tensorflow.Tfprof.TfprofTensorProto.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Tfprof.TfprofTensorProto.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Tfprof.TfprofTensorProto.Builder()
        }
        public func toBuilder() throws -> Tensorflow.Tfprof.TfprofTensorProto.Builder {
            return try Tensorflow.Tfprof.TfprofTensorProto.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.Tfprof.TfprofTensorProto) throws -> Tensorflow.Tfprof.TfprofTensorProto.Builder {
            return try Tensorflow.Tfprof.TfprofTensorProto.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasDtype {
                jsonMap["dtype"] = dtype.toString()
            }
            if !valueDouble.isEmpty {
                var jsonArrayValueDouble:Array<Double> = []
                for oneValueValueDouble in valueDouble {
                    jsonArrayValueDouble.append(Double(oneValueValueDouble))
                }
                jsonMap["valueDouble"] = jsonArrayValueDouble
            }
            if !valueInt64.isEmpty {
                var jsonArrayValueInt64:Array<String> = []
                for oneValueValueInt64 in valueInt64 {
                    jsonArrayValueInt64.append("\(oneValueValueInt64)")
                }
                jsonMap["valueInt64"] = jsonArrayValueInt64
            }
            if !valueStr.isEmpty {
                var jsonArrayValueStr:Array<String> = []
                for oneValueValueStr in valueStr {
                    jsonArrayValueStr.append(oneValueValueStr)
                }
                jsonMap["valueStr"] = jsonArrayValueStr
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Tfprof.TfprofTensorProto {
            return try Tensorflow.Tfprof.TfprofTensorProto.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.Tfprof.TfprofTensorProto {
            return try Tensorflow.Tfprof.TfprofTensorProto.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if (hasDtype) {
                output += "\(indent) dtype: \(dtype.description)\n"
            }
            var valueDoubleElementIndex:Int = 0
            for oneValueValueDouble in valueDouble  {
                output += "\(indent) valueDouble[\(valueDoubleElementIndex)]: \(oneValueValueDouble)\n"
                valueDoubleElementIndex += 1
            }
            var valueInt64ElementIndex:Int = 0
            for oneValueValueInt64 in valueInt64  {
                output += "\(indent) valueInt64[\(valueInt64ElementIndex)]: \(oneValueValueInt64)\n"
                valueInt64ElementIndex += 1
            }
            var valueStrElementIndex:Int = 0
            for oneValueValueStr in valueStr  {
                output += "\(indent) valueStr[\(valueStrElementIndex)]: \(oneValueValueStr)\n"
                valueStrElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasDtype {
                     hashCode = (hashCode &* 31) &+ dtype.hashValue
                }
                for oneValueValueDouble in valueDouble {
                    hashCode = (hashCode &* 31) &+ oneValueValueDouble.hashValue
                }
                for oneValueValueInt64 in valueInt64 {
                    hashCode = (hashCode &* 31) &+ oneValueValueInt64.hashValue
                }
                for oneValueValueStr in valueStr {
                    hashCode = (hashCode &* 31) &+ oneValueValueStr.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.Tfprof.TfprofTensorProto"
        }
        override public func className() -> String {
            return "Tensorflow.Tfprof.TfprofTensorProto"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.Tfprof.TfprofTensorProto = Tensorflow.Tfprof.TfprofTensorProto()
            public func getMessage() -> Tensorflow.Tfprof.TfprofTensorProto {
                return builderResult
            }

            required override public init () {
                super.init()
            }
                public var dtype:Tensorflow.DataType {
                    get {
                        return builderResult.dtype
                    }
                    set (value) {
                        builderResult.hasDtype = true
                        builderResult.dtype = value
                    }
                }
                public var hasDtype:Bool{
                    get {
                        return builderResult.hasDtype
                    }
                }
            @discardableResult
                public func setDtype(_ value:Tensorflow.DataType) -> Tensorflow.Tfprof.TfprofTensorProto.Builder {
                  self.dtype = value
                  return self
                }
            @discardableResult
                public func clearDtype() -> Tensorflow.Tfprof.TfprofTensorProto.Builder {
                   builderResult.hasDtype = false
                   builderResult.dtype = .dtInvalid
                   return self
                }
            /// Flatten tensor in row-major.
            /// Only one of the following array is set.
            public var valueDouble:Array<Double> {
                get {
                    return builderResult.valueDouble
                }
                set (array) {
                    builderResult.valueDouble = array
                }
            }
            @discardableResult
            public func setValueDouble(_ value:Array<Double>) -> Tensorflow.Tfprof.TfprofTensorProto.Builder {
                self.valueDouble = value
                return self
            }
            @discardableResult
            public func clearValueDouble() -> Tensorflow.Tfprof.TfprofTensorProto.Builder {
                builderResult.valueDouble.removeAll(keepingCapacity: false)
                return self
            }
            public var valueInt64:Array<Int64> {
                get {
                    return builderResult.valueInt64
                }
                set (array) {
                    builderResult.valueInt64 = array
                }
            }
            @discardableResult
            public func setValueInt64(_ value:Array<Int64>) -> Tensorflow.Tfprof.TfprofTensorProto.Builder {
                self.valueInt64 = value
                return self
            }
            @discardableResult
            public func clearValueInt64() -> Tensorflow.Tfprof.TfprofTensorProto.Builder {
                builderResult.valueInt64.removeAll(keepingCapacity: false)
                return self
            }
            public var valueStr:Array<String> {
                get {
                    return builderResult.valueStr
                }
                set (array) {
                    builderResult.valueStr = array
                }
            }
            @discardableResult
            public func setValueStr(_ value:Array<String>) -> Tensorflow.Tfprof.TfprofTensorProto.Builder {
                self.valueStr = value
                return self
            }
            @discardableResult
            public func clearValueStr() -> Tensorflow.Tfprof.TfprofTensorProto.Builder {
                builderResult.valueStr.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.Tfprof.TfprofTensorProto.Builder {
                builderResult = Tensorflow.Tfprof.TfprofTensorProto()
                return self
            }
            override public func clone() throws -> Tensorflow.Tfprof.TfprofTensorProto.Builder {
                return try Tensorflow.Tfprof.TfprofTensorProto.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.Tfprof.TfprofTensorProto {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.Tfprof.TfprofTensorProto {
                let returnMe:Tensorflow.Tfprof.TfprofTensorProto = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.Tfprof.TfprofTensorProto) throws -> Tensorflow.Tfprof.TfprofTensorProto.Builder {
                if other == Tensorflow.Tfprof.TfprofTensorProto() {
                    return self
                }
                if other.hasDtype {
                    dtype = other.dtype
                }
                if !other.valueDouble.isEmpty {
                    builderResult.valueDouble += other.valueDouble
                }
                if !other.valueInt64.isEmpty {
                    builderResult.valueInt64 += other.valueInt64
                }
                if !other.valueStr.isEmpty {
                    builderResult.valueStr += other.valueStr
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Tfprof.TfprofTensorProto.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Tfprof.TfprofTensorProto.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        let valueIntdtype = try codedInputStream.readEnum()
                        if let enumsdtype = Tensorflow.DataType(rawValue:valueIntdtype){
                            dtype = enumsdtype
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntdtype))
                        }

                    case 17:
                        valueDouble += [try codedInputStream.readDouble()]

                    case 24:
                        valueInt64 += [try codedInputStream.readInt64()]

                    case 34:
                        valueStr += [try codedInputStream.readString()]

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Tfprof.TfprofTensorProto.Builder {
                let resultDecodedBuilder = Tensorflow.Tfprof.TfprofTensorProto.Builder()
                if let jsonValueDtype = jsonMap["dtype"] as? String {
                    resultDecodedBuilder.dtype = try Tensorflow.DataType.fromString(str: jsonValueDtype)
                }
                if let jsonValueValueDouble = jsonMap["valueDouble"] as? Array<Double> {
                    var jsonArrayValueDouble:Array<Double> = []
                    for oneValueValueDouble in jsonValueValueDouble {
                        jsonArrayValueDouble.append(Double(oneValueValueDouble))
                    }
                    resultDecodedBuilder.valueDouble = jsonArrayValueDouble
                }
                if let jsonValueValueInt64 = jsonMap["valueInt64"] as? Array<String> {
                    var jsonArrayValueInt64:Array<Int64> = []
                    for oneValueValueInt64 in jsonValueValueInt64 {
                        jsonArrayValueInt64.append(Int64(oneValueValueInt64)!)
                    }
                    resultDecodedBuilder.valueInt64 = jsonArrayValueInt64
                }
                if let jsonValueValueStr = jsonMap["valueStr"] as? Array<String> {
                    var jsonArrayValueStr:Array<String> = []
                    for oneValueValueStr in jsonValueValueStr {
                        jsonArrayValueStr.append(oneValueValueStr)
                    }
                    resultDecodedBuilder.valueStr = jsonArrayValueStr
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Tfprof.TfprofTensorProto.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.Tfprof.TfprofTensorProto.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class TfprofNode : GeneratedMessage {

        public static func == (lhs: Tensorflow.Tfprof.TfprofNode, rhs: Tensorflow.Tfprof.TfprofNode) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
            fieldCheck = fieldCheck && (lhs.hasExecMicros == rhs.hasExecMicros) && (!lhs.hasExecMicros || lhs.execMicros == rhs.execMicros)
            fieldCheck = fieldCheck && (lhs.hasRequestedBytes == rhs.hasRequestedBytes) && (!lhs.hasRequestedBytes || lhs.requestedBytes == rhs.requestedBytes)
            fieldCheck = fieldCheck && (lhs.hasParameters == rhs.hasParameters) && (!lhs.hasParameters || lhs.parameters == rhs.parameters)
            fieldCheck = fieldCheck && (lhs.hasInputs == rhs.hasInputs) && (!lhs.hasInputs || lhs.inputs == rhs.inputs)
            fieldCheck = fieldCheck && (lhs.hasTotalExecMicros == rhs.hasTotalExecMicros) && (!lhs.hasTotalExecMicros || lhs.totalExecMicros == rhs.totalExecMicros)
            fieldCheck = fieldCheck && (lhs.hasTotalRequestedBytes == rhs.hasTotalRequestedBytes) && (!lhs.hasTotalRequestedBytes || lhs.totalRequestedBytes == rhs.totalRequestedBytes)
            fieldCheck = fieldCheck && (lhs.hasTotalParameters == rhs.hasTotalParameters) && (!lhs.hasTotalParameters || lhs.totalParameters == rhs.totalParameters)
            fieldCheck = fieldCheck && (lhs.hasTotalInputs == rhs.hasTotalInputs) && (!lhs.hasTotalInputs || lhs.totalInputs == rhs.totalInputs)
            fieldCheck = fieldCheck && (lhs.hasDevice == rhs.hasDevice) && (!lhs.hasDevice || lhs.device == rhs.device)
            fieldCheck = fieldCheck && (lhs.shapes == rhs.shapes)
            fieldCheck = fieldCheck && (lhs.children == rhs.children)
            fieldCheck = fieldCheck && (lhs.hasFloatOps == rhs.hasFloatOps) && (!lhs.hasFloatOps || lhs.floatOps == rhs.floatOps)
            fieldCheck = fieldCheck && (lhs.hasTotalFloatOps == rhs.hasTotalFloatOps) && (!lhs.hasTotalFloatOps || lhs.totalFloatOps == rhs.totalFloatOps)
            fieldCheck = fieldCheck && (lhs.hasTensorValue == rhs.hasTensorValue) && (!lhs.hasTensorValue || lhs.tensorValue == rhs.tensorValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// op name.
        public fileprivate(set) var name:String = ""
        public fileprivate(set) var hasName:Bool = false

        public fileprivate(set) var tensorValue:Tensorflow.Tfprof.TfprofTensorProto!
        public fileprivate(set) var hasTensorValue:Bool = false
        /// op execution time.
        public fileprivate(set) var execMicros:Int64 = Int64(0)
        public fileprivate(set) var hasExecMicros:Bool = false

        /// Total requested bytes by the op.
        public fileprivate(set) var requestedBytes:Int64 = Int64(0)
        public fileprivate(set) var hasRequestedBytes:Bool = false

        /// Number of parameters if available.
        public fileprivate(set) var parameters:Int64 = Int64(0)
        public fileprivate(set) var hasParameters:Bool = false

        /// Number of float operations.
        public fileprivate(set) var floatOps:Int64 = Int64(0)
        public fileprivate(set) var hasFloatOps:Bool = false

        /// Number of inputs to the op.
        public fileprivate(set) var inputs:Int64 = Int64(0)
        public fileprivate(set) var hasInputs:Bool = false

        /// Device the op is assigned to.
        public fileprivate(set) var device:String = ""
        public fileprivate(set) var hasDevice:Bool = false

        /// The following are the aggregated stats from all accounted descendants and
        /// the op itself. The actual descendants depend on the data structure used
        /// (scope, graph).
        public fileprivate(set) var totalExecMicros:Int64 = Int64(0)
        public fileprivate(set) var hasTotalExecMicros:Bool = false

        public fileprivate(set) var totalRequestedBytes:Int64 = Int64(0)
        public fileprivate(set) var hasTotalRequestedBytes:Bool = false

        public fileprivate(set) var totalParameters:Int64 = Int64(0)
        public fileprivate(set) var hasTotalParameters:Bool = false

        public fileprivate(set) var totalFloatOps:Int64 = Int64(0)
        public fileprivate(set) var hasTotalFloatOps:Bool = false

        public fileprivate(set) var totalInputs:Int64 = Int64(0)
        public fileprivate(set) var hasTotalInputs:Bool = false

        public fileprivate(set) var shapes:Array<Tensorflow.TensorShapeProto>  = Array<Tensorflow.TensorShapeProto>()
        public fileprivate(set) var children:Array<Tensorflow.Tfprof.TfprofNode>  = Array<Tensorflow.Tfprof.TfprofNode>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasName {
                try codedOutputStream.writeString(fieldNumber: 1, value:name)
            }
            if hasExecMicros {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:execMicros)
            }
            if hasRequestedBytes {
                try codedOutputStream.writeInt64(fieldNumber: 3, value:requestedBytes)
            }
            if hasParameters {
                try codedOutputStream.writeInt64(fieldNumber: 4, value:parameters)
            }
            if hasInputs {
                try codedOutputStream.writeInt64(fieldNumber: 5, value:inputs)
            }
            if hasTotalExecMicros {
                try codedOutputStream.writeInt64(fieldNumber: 6, value:totalExecMicros)
            }
            if hasTotalRequestedBytes {
                try codedOutputStream.writeInt64(fieldNumber: 7, value:totalRequestedBytes)
            }
            if hasTotalParameters {
                try codedOutputStream.writeInt64(fieldNumber: 8, value:totalParameters)
            }
            if hasTotalInputs {
                try codedOutputStream.writeInt64(fieldNumber: 9, value:totalInputs)
            }
            if hasDevice {
                try codedOutputStream.writeString(fieldNumber: 10, value:device)
            }
            for oneElementShapes in shapes {
                  try codedOutputStream.writeMessage(fieldNumber: 11, value:oneElementShapes)
            }
            for oneElementChildren in children {
                  try codedOutputStream.writeMessage(fieldNumber: 12, value:oneElementChildren)
            }
            if hasFloatOps {
                try codedOutputStream.writeInt64(fieldNumber: 13, value:floatOps)
            }
            if hasTotalFloatOps {
                try codedOutputStream.writeInt64(fieldNumber: 14, value:totalFloatOps)
            }
            if hasTensorValue {
                try codedOutputStream.writeMessage(fieldNumber: 15, value:tensorValue)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasName {
                serialize_size += name.computeStringSize(fieldNumber: 1)
            }
            if hasExecMicros {
                serialize_size += execMicros.computeInt64Size(fieldNumber: 2)
            }
            if hasRequestedBytes {
                serialize_size += requestedBytes.computeInt64Size(fieldNumber: 3)
            }
            if hasParameters {
                serialize_size += parameters.computeInt64Size(fieldNumber: 4)
            }
            if hasInputs {
                serialize_size += inputs.computeInt64Size(fieldNumber: 5)
            }
            if hasTotalExecMicros {
                serialize_size += totalExecMicros.computeInt64Size(fieldNumber: 6)
            }
            if hasTotalRequestedBytes {
                serialize_size += totalRequestedBytes.computeInt64Size(fieldNumber: 7)
            }
            if hasTotalParameters {
                serialize_size += totalParameters.computeInt64Size(fieldNumber: 8)
            }
            if hasTotalInputs {
                serialize_size += totalInputs.computeInt64Size(fieldNumber: 9)
            }
            if hasDevice {
                serialize_size += device.computeStringSize(fieldNumber: 10)
            }
            for oneElementShapes in shapes {
                serialize_size += oneElementShapes.computeMessageSize(fieldNumber: 11)
            }
            for oneElementChildren in children {
                serialize_size += oneElementChildren.computeMessageSize(fieldNumber: 12)
            }
            if hasFloatOps {
                serialize_size += floatOps.computeInt64Size(fieldNumber: 13)
            }
            if hasTotalFloatOps {
                serialize_size += totalFloatOps.computeInt64Size(fieldNumber: 14)
            }
            if hasTensorValue {
                if let varSizetensorValue = tensorValue?.computeMessageSize(fieldNumber: 15) {
                    serialize_size += varSizetensorValue
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.Tfprof.TfprofNode.Builder {
            return Tensorflow.Tfprof.TfprofNode.classBuilder() as! Tensorflow.Tfprof.TfprofNode.Builder
        }
        public func getBuilder() -> Tensorflow.Tfprof.TfprofNode.Builder {
            return classBuilder() as! Tensorflow.Tfprof.TfprofNode.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Tfprof.TfprofNode.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Tfprof.TfprofNode.Builder()
        }
        public func toBuilder() throws -> Tensorflow.Tfprof.TfprofNode.Builder {
            return try Tensorflow.Tfprof.TfprofNode.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.Tfprof.TfprofNode) throws -> Tensorflow.Tfprof.TfprofNode.Builder {
            return try Tensorflow.Tfprof.TfprofNode.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasName {
                jsonMap["name"] = name
            }
            if hasTensorValue {
                jsonMap["tensorValue"] = try tensorValue.encode()
            }
            if hasExecMicros {
                jsonMap["execMicros"] = "\(execMicros)"
            }
            if hasRequestedBytes {
                jsonMap["requestedBytes"] = "\(requestedBytes)"
            }
            if hasParameters {
                jsonMap["parameters"] = "\(parameters)"
            }
            if hasFloatOps {
                jsonMap["floatOps"] = "\(floatOps)"
            }
            if hasInputs {
                jsonMap["inputs"] = "\(inputs)"
            }
            if hasDevice {
                jsonMap["device"] = device
            }
            if hasTotalExecMicros {
                jsonMap["totalExecMicros"] = "\(totalExecMicros)"
            }
            if hasTotalRequestedBytes {
                jsonMap["totalRequestedBytes"] = "\(totalRequestedBytes)"
            }
            if hasTotalParameters {
                jsonMap["totalParameters"] = "\(totalParameters)"
            }
            if hasTotalFloatOps {
                jsonMap["totalFloatOps"] = "\(totalFloatOps)"
            }
            if hasTotalInputs {
                jsonMap["totalInputs"] = "\(totalInputs)"
            }
            if !shapes.isEmpty {
                var jsonArrayShapes:Array<Dictionary<String,Any>> = []
                for oneValueShapes in shapes {
                    let ecodedMessageShapes = try oneValueShapes.encode()
                    jsonArrayShapes.append(ecodedMessageShapes)
                }
                jsonMap["shapes"] = jsonArrayShapes
            }
            if !children.isEmpty {
                var jsonArrayChildren:Array<Dictionary<String,Any>> = []
                for oneValueChildren in children {
                    let ecodedMessageChildren = try oneValueChildren.encode()
                    jsonArrayChildren.append(ecodedMessageChildren)
                }
                jsonMap["children"] = jsonArrayChildren
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Tfprof.TfprofNode {
            return try Tensorflow.Tfprof.TfprofNode.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.Tfprof.TfprofNode {
            return try Tensorflow.Tfprof.TfprofNode.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasName {
                output += "\(indent) name: \(name) \n"
            }
            if hasExecMicros {
                output += "\(indent) execMicros: \(execMicros) \n"
            }
            if hasRequestedBytes {
                output += "\(indent) requestedBytes: \(requestedBytes) \n"
            }
            if hasParameters {
                output += "\(indent) parameters: \(parameters) \n"
            }
            if hasInputs {
                output += "\(indent) inputs: \(inputs) \n"
            }
            if hasTotalExecMicros {
                output += "\(indent) totalExecMicros: \(totalExecMicros) \n"
            }
            if hasTotalRequestedBytes {
                output += "\(indent) totalRequestedBytes: \(totalRequestedBytes) \n"
            }
            if hasTotalParameters {
                output += "\(indent) totalParameters: \(totalParameters) \n"
            }
            if hasTotalInputs {
                output += "\(indent) totalInputs: \(totalInputs) \n"
            }
            if hasDevice {
                output += "\(indent) device: \(device) \n"
            }
            var shapesElementIndex:Int = 0
            for oneElementShapes in shapes {
                output += "\(indent) shapes[\(shapesElementIndex)] {\n"
                output += try oneElementShapes.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                shapesElementIndex += 1
            }
            var childrenElementIndex:Int = 0
            for oneElementChildren in children {
                output += "\(indent) children[\(childrenElementIndex)] {\n"
                output += try oneElementChildren.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                childrenElementIndex += 1
            }
            if hasFloatOps {
                output += "\(indent) floatOps: \(floatOps) \n"
            }
            if hasTotalFloatOps {
                output += "\(indent) totalFloatOps: \(totalFloatOps) \n"
            }
            if hasTensorValue {
                output += "\(indent) tensorValue {\n"
                if let outDescTensorValue = tensorValue {
                    output += try outDescTensorValue.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasName {
                    hashCode = (hashCode &* 31) &+ name.hashValue
                }
                if hasExecMicros {
                    hashCode = (hashCode &* 31) &+ execMicros.hashValue
                }
                if hasRequestedBytes {
                    hashCode = (hashCode &* 31) &+ requestedBytes.hashValue
                }
                if hasParameters {
                    hashCode = (hashCode &* 31) &+ parameters.hashValue
                }
                if hasInputs {
                    hashCode = (hashCode &* 31) &+ inputs.hashValue
                }
                if hasTotalExecMicros {
                    hashCode = (hashCode &* 31) &+ totalExecMicros.hashValue
                }
                if hasTotalRequestedBytes {
                    hashCode = (hashCode &* 31) &+ totalRequestedBytes.hashValue
                }
                if hasTotalParameters {
                    hashCode = (hashCode &* 31) &+ totalParameters.hashValue
                }
                if hasTotalInputs {
                    hashCode = (hashCode &* 31) &+ totalInputs.hashValue
                }
                if hasDevice {
                    hashCode = (hashCode &* 31) &+ device.hashValue
                }
                for oneElementShapes in shapes {
                    hashCode = (hashCode &* 31) &+ oneElementShapes.hashValue
                }
                for oneElementChildren in children {
                    hashCode = (hashCode &* 31) &+ oneElementChildren.hashValue
                }
                if hasFloatOps {
                    hashCode = (hashCode &* 31) &+ floatOps.hashValue
                }
                if hasTotalFloatOps {
                    hashCode = (hashCode &* 31) &+ totalFloatOps.hashValue
                }
                if hasTensorValue {
                    if let hashValuetensorValue = tensorValue?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuetensorValue
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.Tfprof.TfprofNode"
        }
        override public func className() -> String {
            return "Tensorflow.Tfprof.TfprofNode"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.Tfprof.TfprofNode = Tensorflow.Tfprof.TfprofNode()
            public func getMessage() -> Tensorflow.Tfprof.TfprofNode {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// op name.
            public var name:String {
                get {
                    return builderResult.name
                }
                set (value) {
                    builderResult.hasName = true
                    builderResult.name = value
                }
            }
            public var hasName:Bool {
                get {
                    return builderResult.hasName
                }
            }
            @discardableResult
            public func setName(_ value:String) -> Tensorflow.Tfprof.TfprofNode.Builder {
                self.name = value
                return self
            }
            @discardableResult
            public func clearName() -> Tensorflow.Tfprof.TfprofNode.Builder{
                builderResult.hasName = false
                builderResult.name = ""
                return self
            }
            /// tensor value restored from checkpoint.
            public var tensorValue:Tensorflow.Tfprof.TfprofTensorProto! {
                get {
                    if tensorValueBuilder_ != nil {
                        builderResult.tensorValue = tensorValueBuilder_.getMessage()
                    }
                    return builderResult.tensorValue
                }
                set (value) {
                    builderResult.hasTensorValue = true
                    builderResult.tensorValue = value
                }
            }
            public var hasTensorValue:Bool {
                get {
                    return builderResult.hasTensorValue
                }
            }
            fileprivate var tensorValueBuilder_:Tensorflow.Tfprof.TfprofTensorProto.Builder! {
                didSet {
                    builderResult.hasTensorValue = true
                }
            }
            public func getTensorValueBuilder() -> Tensorflow.Tfprof.TfprofTensorProto.Builder {
                if tensorValueBuilder_ == nil {
                    tensorValueBuilder_ = Tensorflow.Tfprof.TfprofTensorProto.Builder()
                    builderResult.tensorValue = tensorValueBuilder_.getMessage()
                    if tensorValue != nil {
                        try! tensorValueBuilder_.mergeFrom(other: tensorValue)
                    }
                }
                return tensorValueBuilder_
            }
            @discardableResult
            public func setTensorValue(_ value:Tensorflow.Tfprof.TfprofTensorProto!) -> Tensorflow.Tfprof.TfprofNode.Builder {
                self.tensorValue = value
                return self
            }
            @discardableResult
            public func mergeTensorValue(value:Tensorflow.Tfprof.TfprofTensorProto) throws -> Tensorflow.Tfprof.TfprofNode.Builder {
                if builderResult.hasTensorValue {
                    builderResult.tensorValue = try Tensorflow.Tfprof.TfprofTensorProto.builderWithPrototype(prototype:builderResult.tensorValue).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.tensorValue = value
                }
                builderResult.hasTensorValue = true
                return self
            }
            @discardableResult
            public func clearTensorValue() -> Tensorflow.Tfprof.TfprofNode.Builder {
                tensorValueBuilder_ = nil
                builderResult.hasTensorValue = false
                builderResult.tensorValue = nil
                return self
            }
            /// op execution time.
            public var execMicros:Int64 {
                get {
                    return builderResult.execMicros
                }
                set (value) {
                    builderResult.hasExecMicros = true
                    builderResult.execMicros = value
                }
            }
            public var hasExecMicros:Bool {
                get {
                    return builderResult.hasExecMicros
                }
            }
            @discardableResult
            public func setExecMicros(_ value:Int64) -> Tensorflow.Tfprof.TfprofNode.Builder {
                self.execMicros = value
                return self
            }
            @discardableResult
            public func clearExecMicros() -> Tensorflow.Tfprof.TfprofNode.Builder{
                builderResult.hasExecMicros = false
                builderResult.execMicros = Int64(0)
                return self
            }
            /// Total requested bytes by the op.
            public var requestedBytes:Int64 {
                get {
                    return builderResult.requestedBytes
                }
                set (value) {
                    builderResult.hasRequestedBytes = true
                    builderResult.requestedBytes = value
                }
            }
            public var hasRequestedBytes:Bool {
                get {
                    return builderResult.hasRequestedBytes
                }
            }
            @discardableResult
            public func setRequestedBytes(_ value:Int64) -> Tensorflow.Tfprof.TfprofNode.Builder {
                self.requestedBytes = value
                return self
            }
            @discardableResult
            public func clearRequestedBytes() -> Tensorflow.Tfprof.TfprofNode.Builder{
                builderResult.hasRequestedBytes = false
                builderResult.requestedBytes = Int64(0)
                return self
            }
            /// Number of parameters if available.
            public var parameters:Int64 {
                get {
                    return builderResult.parameters
                }
                set (value) {
                    builderResult.hasParameters = true
                    builderResult.parameters = value
                }
            }
            public var hasParameters:Bool {
                get {
                    return builderResult.hasParameters
                }
            }
            @discardableResult
            public func setParameters(_ value:Int64) -> Tensorflow.Tfprof.TfprofNode.Builder {
                self.parameters = value
                return self
            }
            @discardableResult
            public func clearParameters() -> Tensorflow.Tfprof.TfprofNode.Builder{
                builderResult.hasParameters = false
                builderResult.parameters = Int64(0)
                return self
            }
            /// Number of float operations.
            public var floatOps:Int64 {
                get {
                    return builderResult.floatOps
                }
                set (value) {
                    builderResult.hasFloatOps = true
                    builderResult.floatOps = value
                }
            }
            public var hasFloatOps:Bool {
                get {
                    return builderResult.hasFloatOps
                }
            }
            @discardableResult
            public func setFloatOps(_ value:Int64) -> Tensorflow.Tfprof.TfprofNode.Builder {
                self.floatOps = value
                return self
            }
            @discardableResult
            public func clearFloatOps() -> Tensorflow.Tfprof.TfprofNode.Builder{
                builderResult.hasFloatOps = false
                builderResult.floatOps = Int64(0)
                return self
            }
            /// Number of inputs to the op.
            public var inputs:Int64 {
                get {
                    return builderResult.inputs
                }
                set (value) {
                    builderResult.hasInputs = true
                    builderResult.inputs = value
                }
            }
            public var hasInputs:Bool {
                get {
                    return builderResult.hasInputs
                }
            }
            @discardableResult
            public func setInputs(_ value:Int64) -> Tensorflow.Tfprof.TfprofNode.Builder {
                self.inputs = value
                return self
            }
            @discardableResult
            public func clearInputs() -> Tensorflow.Tfprof.TfprofNode.Builder{
                builderResult.hasInputs = false
                builderResult.inputs = Int64(0)
                return self
            }
            /// Device the op is assigned to.
            public var device:String {
                get {
                    return builderResult.device
                }
                set (value) {
                    builderResult.hasDevice = true
                    builderResult.device = value
                }
            }
            public var hasDevice:Bool {
                get {
                    return builderResult.hasDevice
                }
            }
            @discardableResult
            public func setDevice(_ value:String) -> Tensorflow.Tfprof.TfprofNode.Builder {
                self.device = value
                return self
            }
            @discardableResult
            public func clearDevice() -> Tensorflow.Tfprof.TfprofNode.Builder{
                builderResult.hasDevice = false
                builderResult.device = ""
                return self
            }
            /// The following are the aggregated stats from all accounted descendants and
            /// the op itself. The actual descendants depend on the data structure used
            /// (scope, graph).
            public var totalExecMicros:Int64 {
                get {
                    return builderResult.totalExecMicros
                }
                set (value) {
                    builderResult.hasTotalExecMicros = true
                    builderResult.totalExecMicros = value
                }
            }
            public var hasTotalExecMicros:Bool {
                get {
                    return builderResult.hasTotalExecMicros
                }
            }
            @discardableResult
            public func setTotalExecMicros(_ value:Int64) -> Tensorflow.Tfprof.TfprofNode.Builder {
                self.totalExecMicros = value
                return self
            }
            @discardableResult
            public func clearTotalExecMicros() -> Tensorflow.Tfprof.TfprofNode.Builder{
                builderResult.hasTotalExecMicros = false
                builderResult.totalExecMicros = Int64(0)
                return self
            }
            public var totalRequestedBytes:Int64 {
                get {
                    return builderResult.totalRequestedBytes
                }
                set (value) {
                    builderResult.hasTotalRequestedBytes = true
                    builderResult.totalRequestedBytes = value
                }
            }
            public var hasTotalRequestedBytes:Bool {
                get {
                    return builderResult.hasTotalRequestedBytes
                }
            }
            @discardableResult
            public func setTotalRequestedBytes(_ value:Int64) -> Tensorflow.Tfprof.TfprofNode.Builder {
                self.totalRequestedBytes = value
                return self
            }
            @discardableResult
            public func clearTotalRequestedBytes() -> Tensorflow.Tfprof.TfprofNode.Builder{
                builderResult.hasTotalRequestedBytes = false
                builderResult.totalRequestedBytes = Int64(0)
                return self
            }
            public var totalParameters:Int64 {
                get {
                    return builderResult.totalParameters
                }
                set (value) {
                    builderResult.hasTotalParameters = true
                    builderResult.totalParameters = value
                }
            }
            public var hasTotalParameters:Bool {
                get {
                    return builderResult.hasTotalParameters
                }
            }
            @discardableResult
            public func setTotalParameters(_ value:Int64) -> Tensorflow.Tfprof.TfprofNode.Builder {
                self.totalParameters = value
                return self
            }
            @discardableResult
            public func clearTotalParameters() -> Tensorflow.Tfprof.TfprofNode.Builder{
                builderResult.hasTotalParameters = false
                builderResult.totalParameters = Int64(0)
                return self
            }
            public var totalFloatOps:Int64 {
                get {
                    return builderResult.totalFloatOps
                }
                set (value) {
                    builderResult.hasTotalFloatOps = true
                    builderResult.totalFloatOps = value
                }
            }
            public var hasTotalFloatOps:Bool {
                get {
                    return builderResult.hasTotalFloatOps
                }
            }
            @discardableResult
            public func setTotalFloatOps(_ value:Int64) -> Tensorflow.Tfprof.TfprofNode.Builder {
                self.totalFloatOps = value
                return self
            }
            @discardableResult
            public func clearTotalFloatOps() -> Tensorflow.Tfprof.TfprofNode.Builder{
                builderResult.hasTotalFloatOps = false
                builderResult.totalFloatOps = Int64(0)
                return self
            }
            public var totalInputs:Int64 {
                get {
                    return builderResult.totalInputs
                }
                set (value) {
                    builderResult.hasTotalInputs = true
                    builderResult.totalInputs = value
                }
            }
            public var hasTotalInputs:Bool {
                get {
                    return builderResult.hasTotalInputs
                }
            }
            @discardableResult
            public func setTotalInputs(_ value:Int64) -> Tensorflow.Tfprof.TfprofNode.Builder {
                self.totalInputs = value
                return self
            }
            @discardableResult
            public func clearTotalInputs() -> Tensorflow.Tfprof.TfprofNode.Builder{
                builderResult.hasTotalInputs = false
                builderResult.totalInputs = Int64(0)
                return self
            }
            /// shape information, if available.
            public var shapes:Array<Tensorflow.TensorShapeProto> {
                get {
                    return builderResult.shapes
                }
                set (value) {
                    builderResult.shapes = value
                }
            }
            @discardableResult
            public func setShapes(_ value:Array<Tensorflow.TensorShapeProto>) -> Tensorflow.Tfprof.TfprofNode.Builder {
                self.shapes = value
                return self
            }
            @discardableResult
            public func clearShapes() -> Tensorflow.Tfprof.TfprofNode.Builder {
                builderResult.shapes.removeAll(keepingCapacity: false)
                return self
            }
            /// Descendants of the graph. The actual descendants depend on the data
            /// structure used (scope, graph).
            public var children:Array<Tensorflow.Tfprof.TfprofNode> {
                get {
                    return builderResult.children
                }
                set (value) {
                    builderResult.children = value
                }
            }
            @discardableResult
            public func setChildren(_ value:Array<Tensorflow.Tfprof.TfprofNode>) -> Tensorflow.Tfprof.TfprofNode.Builder {
                self.children = value
                return self
            }
            @discardableResult
            public func clearChildren() -> Tensorflow.Tfprof.TfprofNode.Builder {
                builderResult.children.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.Tfprof.TfprofNode.Builder {
                builderResult = Tensorflow.Tfprof.TfprofNode()
                return self
            }
            override public func clone() throws -> Tensorflow.Tfprof.TfprofNode.Builder {
                return try Tensorflow.Tfprof.TfprofNode.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.Tfprof.TfprofNode {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.Tfprof.TfprofNode {
                let returnMe:Tensorflow.Tfprof.TfprofNode = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.Tfprof.TfprofNode) throws -> Tensorflow.Tfprof.TfprofNode.Builder {
                if other == Tensorflow.Tfprof.TfprofNode() {
                    return self
                }
                if other.hasName {
                    name = other.name
                }
                if (other.hasTensorValue) {
                    try mergeTensorValue(value: other.tensorValue)
                }
                if other.hasExecMicros {
                    execMicros = other.execMicros
                }
                if other.hasRequestedBytes {
                    requestedBytes = other.requestedBytes
                }
                if other.hasParameters {
                    parameters = other.parameters
                }
                if other.hasFloatOps {
                    floatOps = other.floatOps
                }
                if other.hasInputs {
                    inputs = other.inputs
                }
                if other.hasDevice {
                    device = other.device
                }
                if other.hasTotalExecMicros {
                    totalExecMicros = other.totalExecMicros
                }
                if other.hasTotalRequestedBytes {
                    totalRequestedBytes = other.totalRequestedBytes
                }
                if other.hasTotalParameters {
                    totalParameters = other.totalParameters
                }
                if other.hasTotalFloatOps {
                    totalFloatOps = other.totalFloatOps
                }
                if other.hasTotalInputs {
                    totalInputs = other.totalInputs
                }
                if !other.shapes.isEmpty  {
                     builderResult.shapes += other.shapes
                }
                if !other.children.isEmpty  {
                     builderResult.children += other.children
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Tfprof.TfprofNode.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Tfprof.TfprofNode.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        name = try codedInputStream.readString()

                    case 16:
                        execMicros = try codedInputStream.readInt64()

                    case 24:
                        requestedBytes = try codedInputStream.readInt64()

                    case 32:
                        parameters = try codedInputStream.readInt64()

                    case 40:
                        inputs = try codedInputStream.readInt64()

                    case 48:
                        totalExecMicros = try codedInputStream.readInt64()

                    case 56:
                        totalRequestedBytes = try codedInputStream.readInt64()

                    case 64:
                        totalParameters = try codedInputStream.readInt64()

                    case 72:
                        totalInputs = try codedInputStream.readInt64()

                    case 82:
                        device = try codedInputStream.readString()

                    case 90:
                        let subBuilder = Tensorflow.TensorShapeProto.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        shapes.append(subBuilder.buildPartial())

                    case 98:
                        let subBuilder = Tensorflow.Tfprof.TfprofNode.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        children.append(subBuilder.buildPartial())

                    case 104:
                        floatOps = try codedInputStream.readInt64()

                    case 112:
                        totalFloatOps = try codedInputStream.readInt64()

                    case 122:
                        let subBuilder:Tensorflow.Tfprof.TfprofTensorProto.Builder = Tensorflow.Tfprof.TfprofTensorProto.Builder()
                        if hasTensorValue {
                            try subBuilder.mergeFrom(other: tensorValue)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        tensorValue = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Tfprof.TfprofNode.Builder {
                let resultDecodedBuilder = Tensorflow.Tfprof.TfprofNode.Builder()
                if let jsonValueName = jsonMap["name"] as? String {
                    resultDecodedBuilder.name = jsonValueName
                }
                if let jsonValueTensorValue = jsonMap["tensorValue"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.tensorValue = try Tensorflow.Tfprof.TfprofTensorProto.Builder.decodeToBuilder(jsonMap:jsonValueTensorValue).build()

                }
                if let jsonValueExecMicros = jsonMap["execMicros"] as? String {
                    resultDecodedBuilder.execMicros = Int64(jsonValueExecMicros)!
                } else if let jsonValueExecMicros = jsonMap["execMicros"] as? Int {
                    resultDecodedBuilder.execMicros = Int64(jsonValueExecMicros)
                }
                if let jsonValueRequestedBytes = jsonMap["requestedBytes"] as? String {
                    resultDecodedBuilder.requestedBytes = Int64(jsonValueRequestedBytes)!
                } else if let jsonValueRequestedBytes = jsonMap["requestedBytes"] as? Int {
                    resultDecodedBuilder.requestedBytes = Int64(jsonValueRequestedBytes)
                }
                if let jsonValueParameters = jsonMap["parameters"] as? String {
                    resultDecodedBuilder.parameters = Int64(jsonValueParameters)!
                } else if let jsonValueParameters = jsonMap["parameters"] as? Int {
                    resultDecodedBuilder.parameters = Int64(jsonValueParameters)
                }
                if let jsonValueFloatOps = jsonMap["floatOps"] as? String {
                    resultDecodedBuilder.floatOps = Int64(jsonValueFloatOps)!
                } else if let jsonValueFloatOps = jsonMap["floatOps"] as? Int {
                    resultDecodedBuilder.floatOps = Int64(jsonValueFloatOps)
                }
                if let jsonValueInputs = jsonMap["inputs"] as? String {
                    resultDecodedBuilder.inputs = Int64(jsonValueInputs)!
                } else if let jsonValueInputs = jsonMap["inputs"] as? Int {
                    resultDecodedBuilder.inputs = Int64(jsonValueInputs)
                }
                if let jsonValueDevice = jsonMap["device"] as? String {
                    resultDecodedBuilder.device = jsonValueDevice
                }
                if let jsonValueTotalExecMicros = jsonMap["totalExecMicros"] as? String {
                    resultDecodedBuilder.totalExecMicros = Int64(jsonValueTotalExecMicros)!
                } else if let jsonValueTotalExecMicros = jsonMap["totalExecMicros"] as? Int {
                    resultDecodedBuilder.totalExecMicros = Int64(jsonValueTotalExecMicros)
                }
                if let jsonValueTotalRequestedBytes = jsonMap["totalRequestedBytes"] as? String {
                    resultDecodedBuilder.totalRequestedBytes = Int64(jsonValueTotalRequestedBytes)!
                } else if let jsonValueTotalRequestedBytes = jsonMap["totalRequestedBytes"] as? Int {
                    resultDecodedBuilder.totalRequestedBytes = Int64(jsonValueTotalRequestedBytes)
                }
                if let jsonValueTotalParameters = jsonMap["totalParameters"] as? String {
                    resultDecodedBuilder.totalParameters = Int64(jsonValueTotalParameters)!
                } else if let jsonValueTotalParameters = jsonMap["totalParameters"] as? Int {
                    resultDecodedBuilder.totalParameters = Int64(jsonValueTotalParameters)
                }
                if let jsonValueTotalFloatOps = jsonMap["totalFloatOps"] as? String {
                    resultDecodedBuilder.totalFloatOps = Int64(jsonValueTotalFloatOps)!
                } else if let jsonValueTotalFloatOps = jsonMap["totalFloatOps"] as? Int {
                    resultDecodedBuilder.totalFloatOps = Int64(jsonValueTotalFloatOps)
                }
                if let jsonValueTotalInputs = jsonMap["totalInputs"] as? String {
                    resultDecodedBuilder.totalInputs = Int64(jsonValueTotalInputs)!
                } else if let jsonValueTotalInputs = jsonMap["totalInputs"] as? Int {
                    resultDecodedBuilder.totalInputs = Int64(jsonValueTotalInputs)
                }
                if let jsonValueShapes = jsonMap["shapes"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayShapes:Array<Tensorflow.TensorShapeProto> = []
                    for oneValueShapes in jsonValueShapes {
                        let messageFromStringShapes = try Tensorflow.TensorShapeProto.Builder.decodeToBuilder(jsonMap:oneValueShapes).build()

                        jsonArrayShapes.append(messageFromStringShapes)
                    }
                    resultDecodedBuilder.shapes = jsonArrayShapes
                }
                if let jsonValueChildren = jsonMap["children"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayChildren:Array<Tensorflow.Tfprof.TfprofNode> = []
                    for oneValueChildren in jsonValueChildren {
                        let messageFromStringChildren = try Tensorflow.Tfprof.TfprofNode.Builder.decodeToBuilder(jsonMap:oneValueChildren).build()

                        jsonArrayChildren.append(messageFromStringChildren)
                    }
                    resultDecodedBuilder.children = jsonArrayChildren
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Tfprof.TfprofNode.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.Tfprof.TfprofNode.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.Tfprof.TfprofTensorProto: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Tfprof.TfprofTensorProto> {
        var mergedArray = Array<Tensorflow.Tfprof.TfprofTensorProto>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Tfprof.TfprofTensorProto? {
        return try Tensorflow.Tfprof.TfprofTensorProto.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Tfprof.TfprofTensorProto {
        return try Tensorflow.Tfprof.TfprofTensorProto.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.Tfprof.TfprofOutputRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Tfprof.TfprofTensorProto {
        return try Tensorflow.Tfprof.TfprofTensorProto.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Tfprof.TfprofTensorProto {
        return try Tensorflow.Tfprof.TfprofTensorProto.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Tfprof.TfprofTensorProto {
        return try Tensorflow.Tfprof.TfprofTensorProto.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Tfprof.TfprofTensorProto {
        return try Tensorflow.Tfprof.TfprofTensorProto.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Tfprof.TfprofTensorProto {
        return try Tensorflow.Tfprof.TfprofTensorProto.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "dtype": return self.dtype
        case "valueDouble": return self.valueDouble
        case "valueInt64": return self.valueInt64
        case "valueStr": return self.valueStr
        default: return nil
        }
    }
}
extension Tensorflow.Tfprof.TfprofTensorProto.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "dtype": return self.dtype
            case "valueDouble": return self.valueDouble
            case "valueInt64": return self.valueInt64
            case "valueStr": return self.valueStr
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "dtype":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.DataType else {
                    return
                }
                self.dtype = newSubscriptValue
            case "valueDouble":
                guard let newSubscriptValue = newSubscriptValue as? Array<Double> else {
                    return
                }
                self.valueDouble = newSubscriptValue
            case "valueInt64":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.valueInt64 = newSubscriptValue
            case "valueStr":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.valueStr = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Tfprof.TfprofNode: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Tfprof.TfprofNode> {
        var mergedArray = Array<Tensorflow.Tfprof.TfprofNode>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Tfprof.TfprofNode? {
        return try Tensorflow.Tfprof.TfprofNode.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Tfprof.TfprofNode {
        return try Tensorflow.Tfprof.TfprofNode.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.Tfprof.TfprofOutputRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Tfprof.TfprofNode {
        return try Tensorflow.Tfprof.TfprofNode.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Tfprof.TfprofNode {
        return try Tensorflow.Tfprof.TfprofNode.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Tfprof.TfprofNode {
        return try Tensorflow.Tfprof.TfprofNode.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Tfprof.TfprofNode {
        return try Tensorflow.Tfprof.TfprofNode.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Tfprof.TfprofNode {
        return try Tensorflow.Tfprof.TfprofNode.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "name": return self.name
        case "tensorValue": return self.tensorValue
        case "execMicros": return self.execMicros
        case "requestedBytes": return self.requestedBytes
        case "parameters": return self.parameters
        case "floatOps": return self.floatOps
        case "inputs": return self.inputs
        case "device": return self.device
        case "totalExecMicros": return self.totalExecMicros
        case "totalRequestedBytes": return self.totalRequestedBytes
        case "totalParameters": return self.totalParameters
        case "totalFloatOps": return self.totalFloatOps
        case "totalInputs": return self.totalInputs
        case "shapes": return self.shapes
        case "children": return self.children
        default: return nil
        }
    }
}
extension Tensorflow.Tfprof.TfprofNode.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "name": return self.name
            case "tensorValue": return self.tensorValue
            case "execMicros": return self.execMicros
            case "requestedBytes": return self.requestedBytes
            case "parameters": return self.parameters
            case "floatOps": return self.floatOps
            case "inputs": return self.inputs
            case "device": return self.device
            case "totalExecMicros": return self.totalExecMicros
            case "totalRequestedBytes": return self.totalRequestedBytes
            case "totalParameters": return self.totalParameters
            case "totalFloatOps": return self.totalFloatOps
            case "totalInputs": return self.totalInputs
            case "shapes": return self.shapes
            case "children": return self.children
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "tensorValue":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.Tfprof.TfprofTensorProto else {
                    return
                }
                self.tensorValue = newSubscriptValue
            case "execMicros":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.execMicros = newSubscriptValue
            case "requestedBytes":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.requestedBytes = newSubscriptValue
            case "parameters":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.parameters = newSubscriptValue
            case "floatOps":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.floatOps = newSubscriptValue
            case "inputs":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.inputs = newSubscriptValue
            case "device":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.device = newSubscriptValue
            case "totalExecMicros":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.totalExecMicros = newSubscriptValue
            case "totalRequestedBytes":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.totalRequestedBytes = newSubscriptValue
            case "totalParameters":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.totalParameters = newSubscriptValue
            case "totalFloatOps":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.totalFloatOps = newSubscriptValue
            case "totalInputs":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.totalInputs = newSubscriptValue
            case "shapes":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.TensorShapeProto> else {
                    return
                }
                self.shapes = newSubscriptValue
            case "children":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.Tfprof.TfprofNode> else {
                    return
                }
                self.children = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "op_def.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { }

public extension Tensorflow {
    public struct OpDefRoot {
        public static let `default` = OpDefRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Tensorflow.AttrValueRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.TypesRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    /// Defines an operation. A NodeDef in a GraphDef specifies an Op by
    /// using the "op" field which should match the name of a OpDef.
    final public class OpDef : GeneratedMessage {

        public static func == (lhs: Tensorflow.OpDef, rhs: Tensorflow.OpDef) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
            fieldCheck = fieldCheck && (lhs.inputArg == rhs.inputArg)
            fieldCheck = fieldCheck && (lhs.outputArg == rhs.outputArg)
            fieldCheck = fieldCheck && (lhs.attr == rhs.attr)
            fieldCheck = fieldCheck && (lhs.hasSummary == rhs.hasSummary) && (!lhs.hasSummary || lhs.summary == rhs.summary)
            fieldCheck = fieldCheck && (lhs.hasDescription == rhs.hasDescription) && (!lhs.hasDescription || lhs.description_ == rhs.description_)
            fieldCheck = fieldCheck && (lhs.hasDeprecation == rhs.hasDeprecation) && (!lhs.hasDeprecation || lhs.deprecation == rhs.deprecation)
            fieldCheck = fieldCheck && (lhs.hasIsAggregate == rhs.hasIsAggregate) && (!lhs.hasIsAggregate || lhs.isAggregate == rhs.isAggregate)
            fieldCheck = fieldCheck && (lhs.hasIsStateful == rhs.hasIsStateful) && (!lhs.hasIsStateful || lhs.isStateful == rhs.isStateful)
            fieldCheck = fieldCheck && (lhs.hasIsCommutative == rhs.hasIsCommutative) && (!lhs.hasIsCommutative || lhs.isCommutative == rhs.isCommutative)
            fieldCheck = fieldCheck && (lhs.hasAllowsUninitializedInput == rhs.hasAllowsUninitializedInput) && (!lhs.hasAllowsUninitializedInput || lhs.allowsUninitializedInput == rhs.allowsUninitializedInput)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        /// For describing inputs and outputs.
        final public class ArgDef : GeneratedMessage {

            public static func == (lhs: Tensorflow.OpDef.ArgDef, rhs: Tensorflow.OpDef.ArgDef) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
                fieldCheck = fieldCheck && (lhs.hasDescription == rhs.hasDescription) && (!lhs.hasDescription || lhs.description_ == rhs.description_)
                fieldCheck = fieldCheck && (lhs.hasType == rhs.hasType) && (!lhs.hasType || lhs.type == rhs.type)
                fieldCheck = fieldCheck && (lhs.hasTypeAttr == rhs.hasTypeAttr) && (!lhs.hasTypeAttr || lhs.typeAttr == rhs.typeAttr)
                fieldCheck = fieldCheck && (lhs.hasNumberAttr == rhs.hasNumberAttr) && (!lhs.hasNumberAttr || lhs.numberAttr == rhs.numberAttr)
                fieldCheck = fieldCheck && (lhs.hasTypeListAttr == rhs.hasTypeListAttr) && (!lhs.hasTypeListAttr || lhs.typeListAttr == rhs.typeListAttr)
                fieldCheck = fieldCheck && (lhs.hasIsRef == rhs.hasIsRef) && (!lhs.hasIsRef || lhs.isRef == rhs.isRef)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            /// Name for the input/output.  Should match the regexp "[a-z][a-z0-9_]*".
            public fileprivate(set) var name:String = ""
            public fileprivate(set) var hasName:Bool = false

            /// Human readable description.
            public fileprivate(set) var description_:String = ""
            public fileprivate(set) var hasDescription:Bool = false

            public fileprivate(set) var type:Tensorflow.DataType = Tensorflow.DataType.dtInvalid
            public fileprivate(set) var hasType:Bool = false
            /// if specified, attr must have type "type"
            public fileprivate(set) var typeAttr:String = ""
            public fileprivate(set) var hasTypeAttr:Bool = false

            /// if specified, attr must have type "int"
            public fileprivate(set) var numberAttr:String = ""
            public fileprivate(set) var hasNumberAttr:Bool = false

            /// If specified, attr must have type "list(type)", and none of
            /// type, type_attr, and number_attr may be specified.
            public fileprivate(set) var typeListAttr:String = ""
            public fileprivate(set) var hasTypeListAttr:Bool = false

            /// For inputs: if true, the inputs are required to be refs.
            ///   By default, inputs can be either refs or non-refs.
            /// For outputs: if true, outputs are refs, otherwise they are not.
            public fileprivate(set) var isRef:Bool = false
            public fileprivate(set) var hasIsRef:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasName {
                    try codedOutputStream.writeString(fieldNumber: 1, value:name)
                }
                if hasDescription {
                    try codedOutputStream.writeString(fieldNumber: 2, value:description_)
                }
                if hasType {
                    try codedOutputStream.writeEnum(fieldNumber: 3, value:type.rawValue)
                }
                if hasTypeAttr {
                    try codedOutputStream.writeString(fieldNumber: 4, value:typeAttr)
                }
                if hasNumberAttr {
                    try codedOutputStream.writeString(fieldNumber: 5, value:numberAttr)
                }
                if hasTypeListAttr {
                    try codedOutputStream.writeString(fieldNumber: 6, value:typeListAttr)
                }
                if hasIsRef {
                    try codedOutputStream.writeBool(fieldNumber: 16, value:isRef)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasName {
                    serialize_size += name.computeStringSize(fieldNumber: 1)
                }
                if hasDescription {
                    serialize_size += description_.computeStringSize(fieldNumber: 2)
                }
                if (hasType) {
                    serialize_size += type.rawValue.computeEnumSize(fieldNumber: 3)
                }
                if hasTypeAttr {
                    serialize_size += typeAttr.computeStringSize(fieldNumber: 4)
                }
                if hasNumberAttr {
                    serialize_size += numberAttr.computeStringSize(fieldNumber: 5)
                }
                if hasTypeListAttr {
                    serialize_size += typeListAttr.computeStringSize(fieldNumber: 6)
                }
                if hasIsRef {
                    serialize_size += isRef.computeBoolSize(fieldNumber: 16)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.OpDef.ArgDef.Builder {
                return Tensorflow.OpDef.ArgDef.classBuilder() as! Tensorflow.OpDef.ArgDef.Builder
            }
            public func getBuilder() -> Tensorflow.OpDef.ArgDef.Builder {
                return classBuilder() as! Tensorflow.OpDef.ArgDef.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.OpDef.ArgDef.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.OpDef.ArgDef.Builder()
            }
            public func toBuilder() throws -> Tensorflow.OpDef.ArgDef.Builder {
                return try Tensorflow.OpDef.ArgDef.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.OpDef.ArgDef) throws -> Tensorflow.OpDef.ArgDef.Builder {
                return try Tensorflow.OpDef.ArgDef.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasName {
                    jsonMap["name"] = name
                }
                if hasDescription {
                    jsonMap["description"] = description_
                }
                if hasType {
                    jsonMap["type"] = type.toString()
                }
                if hasTypeAttr {
                    jsonMap["typeAttr"] = typeAttr
                }
                if hasNumberAttr {
                    jsonMap["numberAttr"] = numberAttr
                }
                if hasTypeListAttr {
                    jsonMap["typeListAttr"] = typeListAttr
                }
                if hasIsRef {
                    jsonMap["isRef"] = isRef
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OpDef.ArgDef {
                return try Tensorflow.OpDef.ArgDef.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.OpDef.ArgDef {
                return try Tensorflow.OpDef.ArgDef.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasName {
                    output += "\(indent) name: \(name) \n"
                }
                if hasDescription {
                    output += "\(indent) description: \(description_) \n"
                }
                if (hasType) {
                    output += "\(indent) type: \(type.description)\n"
                }
                if hasTypeAttr {
                    output += "\(indent) typeAttr: \(typeAttr) \n"
                }
                if hasNumberAttr {
                    output += "\(indent) numberAttr: \(numberAttr) \n"
                }
                if hasTypeListAttr {
                    output += "\(indent) typeListAttr: \(typeListAttr) \n"
                }
                if hasIsRef {
                    output += "\(indent) isRef: \(isRef) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasName {
                        hashCode = (hashCode &* 31) &+ name.hashValue
                    }
                    if hasDescription {
                        hashCode = (hashCode &* 31) &+ description_.hashValue
                    }
                    if hasType {
                         hashCode = (hashCode &* 31) &+ type.hashValue
                    }
                    if hasTypeAttr {
                        hashCode = (hashCode &* 31) &+ typeAttr.hashValue
                    }
                    if hasNumberAttr {
                        hashCode = (hashCode &* 31) &+ numberAttr.hashValue
                    }
                    if hasTypeListAttr {
                        hashCode = (hashCode &* 31) &+ typeListAttr.hashValue
                    }
                    if hasIsRef {
                        hashCode = (hashCode &* 31) &+ isRef.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.OpDef.ArgDef"
            }
            override public func className() -> String {
                return "Tensorflow.OpDef.ArgDef"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.OpDef.ArgDef = Tensorflow.OpDef.ArgDef()
                public func getMessage() -> Tensorflow.OpDef.ArgDef {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                /// Name for the input/output.  Should match the regexp "[a-z][a-z0-9_]*".
                public var name:String {
                    get {
                        return builderResult.name
                    }
                    set (value) {
                        builderResult.hasName = true
                        builderResult.name = value
                    }
                }
                public var hasName:Bool {
                    get {
                        return builderResult.hasName
                    }
                }
                @discardableResult
                public func setName(_ value:String) -> Tensorflow.OpDef.ArgDef.Builder {
                    self.name = value
                    return self
                }
                @discardableResult
                public func clearName() -> Tensorflow.OpDef.ArgDef.Builder{
                    builderResult.hasName = false
                    builderResult.name = ""
                    return self
                }
                /// Human readable description.
                public var description_:String {
                    get {
                        return builderResult.description_
                    }
                    set (value) {
                        builderResult.hasDescription = true
                        builderResult.description_ = value
                    }
                }
                public var hasDescription:Bool {
                    get {
                        return builderResult.hasDescription
                    }
                }
                @discardableResult
                public func setDescription(_ value:String) -> Tensorflow.OpDef.ArgDef.Builder {
                    self.description_ = value
                    return self
                }
                @discardableResult
                public func clearDescription() -> Tensorflow.OpDef.ArgDef.Builder{
                    builderResult.hasDescription = false
                    builderResult.description_ = ""
                    return self
                }
                /// Describes the type of one or more tensors that are accepted/produced
                /// by this input/output arg.  The only legal combinations are:
                /// * For a single tensor: either the "type" field is set or the
                ///   "type_attr" field is set to the name of an attr with type "type".
                /// * For a sequence of tensors with the same type: the "number_attr"
                ///   field will be set to the name of an attr with type "int", and
                ///   either the "type" or "type_attr" field will be set as for
                ///   single tensors.
                /// * For a sequence of tensors, the "type_list_attr" field will be set
                ///   to the name of an attr with type "list(type)".
                    public var type:Tensorflow.DataType {
                        get {
                            return builderResult.type
                        }
                        set (value) {
                            builderResult.hasType = true
                            builderResult.type = value
                        }
                    }
                    public var hasType:Bool{
                        get {
                            return builderResult.hasType
                        }
                    }
                @discardableResult
                    public func setType(_ value:Tensorflow.DataType) -> Tensorflow.OpDef.ArgDef.Builder {
                      self.type = value
                      return self
                    }
                @discardableResult
                    public func clearType() -> Tensorflow.OpDef.ArgDef.Builder {
                       builderResult.hasType = false
                       builderResult.type = .dtInvalid
                       return self
                    }
                /// if specified, attr must have type "type"
                public var typeAttr:String {
                    get {
                        return builderResult.typeAttr
                    }
                    set (value) {
                        builderResult.hasTypeAttr = true
                        builderResult.typeAttr = value
                    }
                }
                public var hasTypeAttr:Bool {
                    get {
                        return builderResult.hasTypeAttr
                    }
                }
                @discardableResult
                public func setTypeAttr(_ value:String) -> Tensorflow.OpDef.ArgDef.Builder {
                    self.typeAttr = value
                    return self
                }
                @discardableResult
                public func clearTypeAttr() -> Tensorflow.OpDef.ArgDef.Builder{
                    builderResult.hasTypeAttr = false
                    builderResult.typeAttr = ""
                    return self
                }
                /// if specified, attr must have type "int"
                public var numberAttr:String {
                    get {
                        return builderResult.numberAttr
                    }
                    set (value) {
                        builderResult.hasNumberAttr = true
                        builderResult.numberAttr = value
                    }
                }
                public var hasNumberAttr:Bool {
                    get {
                        return builderResult.hasNumberAttr
                    }
                }
                @discardableResult
                public func setNumberAttr(_ value:String) -> Tensorflow.OpDef.ArgDef.Builder {
                    self.numberAttr = value
                    return self
                }
                @discardableResult
                public func clearNumberAttr() -> Tensorflow.OpDef.ArgDef.Builder{
                    builderResult.hasNumberAttr = false
                    builderResult.numberAttr = ""
                    return self
                }
                /// If specified, attr must have type "list(type)", and none of
                /// type, type_attr, and number_attr may be specified.
                public var typeListAttr:String {
                    get {
                        return builderResult.typeListAttr
                    }
                    set (value) {
                        builderResult.hasTypeListAttr = true
                        builderResult.typeListAttr = value
                    }
                }
                public var hasTypeListAttr:Bool {
                    get {
                        return builderResult.hasTypeListAttr
                    }
                }
                @discardableResult
                public func setTypeListAttr(_ value:String) -> Tensorflow.OpDef.ArgDef.Builder {
                    self.typeListAttr = value
                    return self
                }
                @discardableResult
                public func clearTypeListAttr() -> Tensorflow.OpDef.ArgDef.Builder{
                    builderResult.hasTypeListAttr = false
                    builderResult.typeListAttr = ""
                    return self
                }
                /// For inputs: if true, the inputs are required to be refs.
                ///   By default, inputs can be either refs or non-refs.
                /// For outputs: if true, outputs are refs, otherwise they are not.
                public var isRef:Bool {
                    get {
                        return builderResult.isRef
                    }
                    set (value) {
                        builderResult.hasIsRef = true
                        builderResult.isRef = value
                    }
                }
                public var hasIsRef:Bool {
                    get {
                        return builderResult.hasIsRef
                    }
                }
                @discardableResult
                public func setIsRef(_ value:Bool) -> Tensorflow.OpDef.ArgDef.Builder {
                    self.isRef = value
                    return self
                }
                @discardableResult
                public func clearIsRef() -> Tensorflow.OpDef.ArgDef.Builder{
                    builderResult.hasIsRef = false
                    builderResult.isRef = false
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.OpDef.ArgDef.Builder {
                    builderResult = Tensorflow.OpDef.ArgDef()
                    return self
                }
                override public func clone() throws -> Tensorflow.OpDef.ArgDef.Builder {
                    return try Tensorflow.OpDef.ArgDef.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.OpDef.ArgDef {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.OpDef.ArgDef {
                    let returnMe:Tensorflow.OpDef.ArgDef = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.OpDef.ArgDef) throws -> Tensorflow.OpDef.ArgDef.Builder {
                    if other == Tensorflow.OpDef.ArgDef() {
                        return self
                    }
                    if other.hasName {
                        name = other.name
                    }
                    if other.hasDescription {
                        description_ = other.description_
                    }
                    if other.hasType {
                        type = other.type
                    }
                    if other.hasTypeAttr {
                        typeAttr = other.typeAttr
                    }
                    if other.hasNumberAttr {
                        numberAttr = other.numberAttr
                    }
                    if other.hasTypeListAttr {
                        typeListAttr = other.typeListAttr
                    }
                    if other.hasIsRef {
                        isRef = other.isRef
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OpDef.ArgDef.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpDef.ArgDef.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            name = try codedInputStream.readString()

                        case 18:
                            description_ = try codedInputStream.readString()

                        case 24:
                            let valueInttype = try codedInputStream.readEnum()
                            if let enumstype = Tensorflow.DataType(rawValue:valueInttype){
                                type = enumstype
                            } else {
                                try unknownFieldsBuilder.mergeVarintField(fieldNumber: 3, value:Int64(valueInttype))
                            }

                        case 34:
                            typeAttr = try codedInputStream.readString()

                        case 42:
                            numberAttr = try codedInputStream.readString()

                        case 50:
                            typeListAttr = try codedInputStream.readString()

                        case 128:
                            isRef = try codedInputStream.readBool()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OpDef.ArgDef.Builder {
                    let resultDecodedBuilder = Tensorflow.OpDef.ArgDef.Builder()
                    if let jsonValueName = jsonMap["name"] as? String {
                        resultDecodedBuilder.name = jsonValueName
                    }
                    if let jsonValueDescription = jsonMap["description"] as? String {
                        resultDecodedBuilder.description_ = jsonValueDescription
                    }
                    if let jsonValueType = jsonMap["type"] as? String {
                        resultDecodedBuilder.type = try Tensorflow.DataType.fromString(str: jsonValueType)
                    }
                    if let jsonValueTypeAttr = jsonMap["typeAttr"] as? String {
                        resultDecodedBuilder.typeAttr = jsonValueTypeAttr
                    }
                    if let jsonValueNumberAttr = jsonMap["numberAttr"] as? String {
                        resultDecodedBuilder.numberAttr = jsonValueNumberAttr
                    }
                    if let jsonValueTypeListAttr = jsonMap["typeListAttr"] as? String {
                        resultDecodedBuilder.typeListAttr = jsonValueTypeListAttr
                    }
                    if let jsonValueIsRef = jsonMap["isRef"] as? Bool {
                        resultDecodedBuilder.isRef = jsonValueIsRef
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.OpDef.ArgDef.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.OpDef.ArgDef.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        /// Description of the graph-construction-time configuration of this
        /// Op.  That is to say, this describes the attr fields that will
        /// be specified in the NodeDef.
        final public class AttrDef : GeneratedMessage {

            public static func == (lhs: Tensorflow.OpDef.AttrDef, rhs: Tensorflow.OpDef.AttrDef) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
                fieldCheck = fieldCheck && (lhs.hasType == rhs.hasType) && (!lhs.hasType || lhs.type == rhs.type)
                fieldCheck = fieldCheck && (lhs.hasDefaultValue == rhs.hasDefaultValue) && (!lhs.hasDefaultValue || lhs.defaultValue == rhs.defaultValue)
                fieldCheck = fieldCheck && (lhs.hasDescription == rhs.hasDescription) && (!lhs.hasDescription || lhs.description_ == rhs.description_)
                fieldCheck = fieldCheck && (lhs.hasHasMinimum == rhs.hasHasMinimum) && (!lhs.hasHasMinimum || lhs.hasMinimum == rhs.hasMinimum)
                fieldCheck = fieldCheck && (lhs.hasMinimum == rhs.hasMinimum) && (!lhs.hasMinimum || lhs.minimum == rhs.minimum)
                fieldCheck = fieldCheck && (lhs.hasAllowedValues == rhs.hasAllowedValues) && (!lhs.hasAllowedValues || lhs.allowedValues == rhs.allowedValues)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            /// A descriptive name for the argument.  May be used, e.g. by the
            /// Python client, as a keyword argument name, and so should match
            /// the regexp "[a-z][a-z0-9_]+".
            public fileprivate(set) var name:String = ""
            public fileprivate(set) var hasName:Bool = false

            /// One of the type names from attr_value.proto ("string", "list(string)",
            /// "int", etc.).
            public fileprivate(set) var type:String = ""
            public fileprivate(set) var hasType:Bool = false

            public fileprivate(set) var defaultValue:Tensorflow.AttrValue!
            public fileprivate(set) var hasDefaultValue:Bool = false
            /// Human-readable description.
            public fileprivate(set) var description_:String = ""
            public fileprivate(set) var hasDescription:Bool = false

            /// For type == "int", this is a minimum value.  For "list(___)"
            /// types, this is the minimum length.
            public fileprivate(set) var hasMinimum:Bool = false
            public fileprivate(set) var hasHasMinimum:Bool = false

            public fileprivate(set) var minimum:Int64 = Int64(0)
            public fileprivate(set) var hasMinimum:Bool = false

            public fileprivate(set) var allowedValues:Tensorflow.AttrValue!
            public fileprivate(set) var hasAllowedValues:Bool = false
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasName {
                    try codedOutputStream.writeString(fieldNumber: 1, value:name)
                }
                if hasType {
                    try codedOutputStream.writeString(fieldNumber: 2, value:type)
                }
                if hasDefaultValue {
                    try codedOutputStream.writeMessage(fieldNumber: 3, value:defaultValue)
                }
                if hasDescription {
                    try codedOutputStream.writeString(fieldNumber: 4, value:description_)
                }
                if hasHasMinimum {
                    try codedOutputStream.writeBool(fieldNumber: 5, value:hasMinimum)
                }
                if hasMinimum {
                    try codedOutputStream.writeInt64(fieldNumber: 6, value:minimum)
                }
                if hasAllowedValues {
                    try codedOutputStream.writeMessage(fieldNumber: 7, value:allowedValues)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasName {
                    serialize_size += name.computeStringSize(fieldNumber: 1)
                }
                if hasType {
                    serialize_size += type.computeStringSize(fieldNumber: 2)
                }
                if hasDefaultValue {
                    if let varSizedefaultValue = defaultValue?.computeMessageSize(fieldNumber: 3) {
                        serialize_size += varSizedefaultValue
                    }
                }
                if hasDescription {
                    serialize_size += description_.computeStringSize(fieldNumber: 4)
                }
                if hasHasMinimum {
                    serialize_size += hasMinimum.computeBoolSize(fieldNumber: 5)
                }
                if hasMinimum {
                    serialize_size += minimum.computeInt64Size(fieldNumber: 6)
                }
                if hasAllowedValues {
                    if let varSizeallowedValues = allowedValues?.computeMessageSize(fieldNumber: 7) {
                        serialize_size += varSizeallowedValues
                    }
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.OpDef.AttrDef.Builder {
                return Tensorflow.OpDef.AttrDef.classBuilder() as! Tensorflow.OpDef.AttrDef.Builder
            }
            public func getBuilder() -> Tensorflow.OpDef.AttrDef.Builder {
                return classBuilder() as! Tensorflow.OpDef.AttrDef.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.OpDef.AttrDef.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.OpDef.AttrDef.Builder()
            }
            public func toBuilder() throws -> Tensorflow.OpDef.AttrDef.Builder {
                return try Tensorflow.OpDef.AttrDef.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.OpDef.AttrDef) throws -> Tensorflow.OpDef.AttrDef.Builder {
                return try Tensorflow.OpDef.AttrDef.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasName {
                    jsonMap["name"] = name
                }
                if hasType {
                    jsonMap["type"] = type
                }
                if hasDefaultValue {
                    jsonMap["defaultValue"] = try defaultValue.encode()
                }
                if hasDescription {
                    jsonMap["description"] = description_
                }
                if hasHasMinimum {
                    jsonMap["hasMinimum"] = hasMinimum
                }
                if hasMinimum {
                    jsonMap["minimum"] = "\(minimum)"
                }
                if hasAllowedValues {
                    jsonMap["allowedValues"] = try allowedValues.encode()
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OpDef.AttrDef {
                return try Tensorflow.OpDef.AttrDef.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.OpDef.AttrDef {
                return try Tensorflow.OpDef.AttrDef.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasName {
                    output += "\(indent) name: \(name) \n"
                }
                if hasType {
                    output += "\(indent) type: \(type) \n"
                }
                if hasDefaultValue {
                    output += "\(indent) defaultValue {\n"
                    if let outDescDefaultValue = defaultValue {
                        output += try outDescDefaultValue.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                if hasDescription {
                    output += "\(indent) description: \(description_) \n"
                }
                if hasHasMinimum {
                    output += "\(indent) hasMinimum: \(hasMinimum) \n"
                }
                if hasMinimum {
                    output += "\(indent) minimum: \(minimum) \n"
                }
                if hasAllowedValues {
                    output += "\(indent) allowedValues {\n"
                    if let outDescAllowedValues = allowedValues {
                        output += try outDescAllowedValues.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasName {
                        hashCode = (hashCode &* 31) &+ name.hashValue
                    }
                    if hasType {
                        hashCode = (hashCode &* 31) &+ type.hashValue
                    }
                    if hasDefaultValue {
                        if let hashValuedefaultValue = defaultValue?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuedefaultValue
                        }
                    }
                    if hasDescription {
                        hashCode = (hashCode &* 31) &+ description_.hashValue
                    }
                    if hasHasMinimum {
                        hashCode = (hashCode &* 31) &+ hasMinimum.hashValue
                    }
                    if hasMinimum {
                        hashCode = (hashCode &* 31) &+ minimum.hashValue
                    }
                    if hasAllowedValues {
                        if let hashValueallowedValues = allowedValues?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValueallowedValues
                        }
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.OpDef.AttrDef"
            }
            override public func className() -> String {
                return "Tensorflow.OpDef.AttrDef"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.OpDef.AttrDef = Tensorflow.OpDef.AttrDef()
                public func getMessage() -> Tensorflow.OpDef.AttrDef {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                /// A descriptive name for the argument.  May be used, e.g. by the
                /// Python client, as a keyword argument name, and so should match
                /// the regexp "[a-z][a-z0-9_]+".
                public var name:String {
                    get {
                        return builderResult.name
                    }
                    set (value) {
                        builderResult.hasName = true
                        builderResult.name = value
                    }
                }
                public var hasName:Bool {
                    get {
                        return builderResult.hasName
                    }
                }
                @discardableResult
                public func setName(_ value:String) -> Tensorflow.OpDef.AttrDef.Builder {
                    self.name = value
                    return self
                }
                @discardableResult
                public func clearName() -> Tensorflow.OpDef.AttrDef.Builder{
                    builderResult.hasName = false
                    builderResult.name = ""
                    return self
                }
                /// One of the type names from attr_value.proto ("string", "list(string)",
                /// "int", etc.).
                public var type:String {
                    get {
                        return builderResult.type
                    }
                    set (value) {
                        builderResult.hasType = true
                        builderResult.type = value
                    }
                }
                public var hasType:Bool {
                    get {
                        return builderResult.hasType
                    }
                }
                @discardableResult
                public func setType(_ value:String) -> Tensorflow.OpDef.AttrDef.Builder {
                    self.type = value
                    return self
                }
                @discardableResult
                public func clearType() -> Tensorflow.OpDef.AttrDef.Builder{
                    builderResult.hasType = false
                    builderResult.type = ""
                    return self
                }
                /// A reasonable default for this attribute if the user does not supply
                /// a value.  If not specified, the user must supply a value.
                public var defaultValue:Tensorflow.AttrValue! {
                    get {
                        if defaultValueBuilder_ != nil {
                            builderResult.defaultValue = defaultValueBuilder_.getMessage()
                        }
                        return builderResult.defaultValue
                    }
                    set (value) {
                        builderResult.hasDefaultValue = true
                        builderResult.defaultValue = value
                    }
                }
                public var hasDefaultValue:Bool {
                    get {
                        return builderResult.hasDefaultValue
                    }
                }
                fileprivate var defaultValueBuilder_:Tensorflow.AttrValue.Builder! {
                    didSet {
                        builderResult.hasDefaultValue = true
                    }
                }
                public func getDefaultValueBuilder() -> Tensorflow.AttrValue.Builder {
                    if defaultValueBuilder_ == nil {
                        defaultValueBuilder_ = Tensorflow.AttrValue.Builder()
                        builderResult.defaultValue = defaultValueBuilder_.getMessage()
                        if defaultValue != nil {
                            try! defaultValueBuilder_.mergeFrom(other: defaultValue)
                        }
                    }
                    return defaultValueBuilder_
                }
                @discardableResult
                public func setDefaultValue(_ value:Tensorflow.AttrValue!) -> Tensorflow.OpDef.AttrDef.Builder {
                    self.defaultValue = value
                    return self
                }
                @discardableResult
                public func mergeDefaultValue(value:Tensorflow.AttrValue) throws -> Tensorflow.OpDef.AttrDef.Builder {
                    if builderResult.hasDefaultValue {
                        builderResult.defaultValue = try Tensorflow.AttrValue.builderWithPrototype(prototype:builderResult.defaultValue).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.defaultValue = value
                    }
                    builderResult.hasDefaultValue = true
                    return self
                }
                @discardableResult
                public func clearDefaultValue() -> Tensorflow.OpDef.AttrDef.Builder {
                    defaultValueBuilder_ = nil
                    builderResult.hasDefaultValue = false
                    builderResult.defaultValue = nil
                    return self
                }
                /// Human-readable description.
                public var description_:String {
                    get {
                        return builderResult.description_
                    }
                    set (value) {
                        builderResult.hasDescription = true
                        builderResult.description_ = value
                    }
                }
                public var hasDescription:Bool {
                    get {
                        return builderResult.hasDescription
                    }
                }
                @discardableResult
                public func setDescription(_ value:String) -> Tensorflow.OpDef.AttrDef.Builder {
                    self.description_ = value
                    return self
                }
                @discardableResult
                public func clearDescription() -> Tensorflow.OpDef.AttrDef.Builder{
                    builderResult.hasDescription = false
                    builderResult.description_ = ""
                    return self
                }
                /// For type == "int", this is a minimum value.  For "list(___)"
                /// types, this is the minimum length.
                public var hasMinimum:Bool {
                    get {
                        return builderResult.hasMinimum
                    }
                    set (value) {
                        builderResult.hasHasMinimum = true
                        builderResult.hasMinimum = value
                    }
                }
                public var hasHasMinimum:Bool {
                    get {
                        return builderResult.hasHasMinimum
                    }
                }
                @discardableResult
                public func setHasMinimum(_ value:Bool) -> Tensorflow.OpDef.AttrDef.Builder {
                    self.hasMinimum = value
                    return self
                }
                @discardableResult
                public func clearHasMinimum() -> Tensorflow.OpDef.AttrDef.Builder{
                    builderResult.hasHasMinimum = false
                    builderResult.hasMinimum = false
                    return self
                }
                public var minimum:Int64 {
                    get {
                        return builderResult.minimum
                    }
                    set (value) {
                        builderResult.hasMinimum = true
                        builderResult.minimum = value
                    }
                }
                public var hasMinimum:Bool {
                    get {
                        return builderResult.hasMinimum
                    }
                }
                @discardableResult
                public func setMinimum(_ value:Int64) -> Tensorflow.OpDef.AttrDef.Builder {
                    self.minimum = value
                    return self
                }
                @discardableResult
                public func clearMinimum() -> Tensorflow.OpDef.AttrDef.Builder{
                    builderResult.hasMinimum = false
                    builderResult.minimum = Int64(0)
                    return self
                }
                /// The set of allowed values.  Has type that is the "list" version
                /// of the "type" field above (uses the "list" field of AttrValue).
                /// If type == "type" or "list(type)" above, then the "type" field
                /// of "allowed_values.list" has the set of allowed DataTypes.
                /// If type == "string" or "list(string)", then the "s" field of
                /// "allowed_values.list" has the set of allowed strings.
                public var allowedValues:Tensorflow.AttrValue! {
                    get {
                        if allowedValuesBuilder_ != nil {
                            builderResult.allowedValues = allowedValuesBuilder_.getMessage()
                        }
                        return builderResult.allowedValues
                    }
                    set (value) {
                        builderResult.hasAllowedValues = true
                        builderResult.allowedValues = value
                    }
                }
                public var hasAllowedValues:Bool {
                    get {
                        return builderResult.hasAllowedValues
                    }
                }
                fileprivate var allowedValuesBuilder_:Tensorflow.AttrValue.Builder! {
                    didSet {
                        builderResult.hasAllowedValues = true
                    }
                }
                public func getAllowedValuesBuilder() -> Tensorflow.AttrValue.Builder {
                    if allowedValuesBuilder_ == nil {
                        allowedValuesBuilder_ = Tensorflow.AttrValue.Builder()
                        builderResult.allowedValues = allowedValuesBuilder_.getMessage()
                        if allowedValues != nil {
                            try! allowedValuesBuilder_.mergeFrom(other: allowedValues)
                        }
                    }
                    return allowedValuesBuilder_
                }
                @discardableResult
                public func setAllowedValues(_ value:Tensorflow.AttrValue!) -> Tensorflow.OpDef.AttrDef.Builder {
                    self.allowedValues = value
                    return self
                }
                @discardableResult
                public func mergeAllowedValues(value:Tensorflow.AttrValue) throws -> Tensorflow.OpDef.AttrDef.Builder {
                    if builderResult.hasAllowedValues {
                        builderResult.allowedValues = try Tensorflow.AttrValue.builderWithPrototype(prototype:builderResult.allowedValues).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.allowedValues = value
                    }
                    builderResult.hasAllowedValues = true
                    return self
                }
                @discardableResult
                public func clearAllowedValues() -> Tensorflow.OpDef.AttrDef.Builder {
                    allowedValuesBuilder_ = nil
                    builderResult.hasAllowedValues = false
                    builderResult.allowedValues = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.OpDef.AttrDef.Builder {
                    builderResult = Tensorflow.OpDef.AttrDef()
                    return self
                }
                override public func clone() throws -> Tensorflow.OpDef.AttrDef.Builder {
                    return try Tensorflow.OpDef.AttrDef.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.OpDef.AttrDef {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.OpDef.AttrDef {
                    let returnMe:Tensorflow.OpDef.AttrDef = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.OpDef.AttrDef) throws -> Tensorflow.OpDef.AttrDef.Builder {
                    if other == Tensorflow.OpDef.AttrDef() {
                        return self
                    }
                    if other.hasName {
                        name = other.name
                    }
                    if other.hasType {
                        type = other.type
                    }
                    if (other.hasDefaultValue) {
                        try mergeDefaultValue(value: other.defaultValue)
                    }
                    if other.hasDescription {
                        description_ = other.description_
                    }
                    if other.hasHasMinimum {
                        hasMinimum = other.hasMinimum
                    }
                    if other.hasMinimum {
                        minimum = other.minimum
                    }
                    if (other.hasAllowedValues) {
                        try mergeAllowedValues(value: other.allowedValues)
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OpDef.AttrDef.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpDef.AttrDef.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            name = try codedInputStream.readString()

                        case 18:
                            type = try codedInputStream.readString()

                        case 26:
                            let subBuilder:Tensorflow.AttrValue.Builder = Tensorflow.AttrValue.Builder()
                            if hasDefaultValue {
                                try subBuilder.mergeFrom(other: defaultValue)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            defaultValue = subBuilder.buildPartial()

                        case 34:
                            description_ = try codedInputStream.readString()

                        case 40:
                            hasMinimum = try codedInputStream.readBool()

                        case 48:
                            minimum = try codedInputStream.readInt64()

                        case 58:
                            let subBuilder:Tensorflow.AttrValue.Builder = Tensorflow.AttrValue.Builder()
                            if hasAllowedValues {
                                try subBuilder.mergeFrom(other: allowedValues)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            allowedValues = subBuilder.buildPartial()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OpDef.AttrDef.Builder {
                    let resultDecodedBuilder = Tensorflow.OpDef.AttrDef.Builder()
                    if let jsonValueName = jsonMap["name"] as? String {
                        resultDecodedBuilder.name = jsonValueName
                    }
                    if let jsonValueType = jsonMap["type"] as? String {
                        resultDecodedBuilder.type = jsonValueType
                    }
                    if let jsonValueDefaultValue = jsonMap["defaultValue"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.defaultValue = try Tensorflow.AttrValue.Builder.decodeToBuilder(jsonMap:jsonValueDefaultValue).build()

                    }
                    if let jsonValueDescription = jsonMap["description"] as? String {
                        resultDecodedBuilder.description_ = jsonValueDescription
                    }
                    if let jsonValueHasMinimum = jsonMap["hasMinimum"] as? Bool {
                        resultDecodedBuilder.hasMinimum = jsonValueHasMinimum
                    }
                    if let jsonValueMinimum = jsonMap["minimum"] as? String {
                        resultDecodedBuilder.minimum = Int64(jsonValueMinimum)!
                    } else if let jsonValueMinimum = jsonMap["minimum"] as? Int {
                        resultDecodedBuilder.minimum = Int64(jsonValueMinimum)
                    }
                    if let jsonValueAllowedValues = jsonMap["allowedValues"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.allowedValues = try Tensorflow.AttrValue.Builder.decodeToBuilder(jsonMap:jsonValueAllowedValues).build()

                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.OpDef.AttrDef.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.OpDef.AttrDef.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        /// Op names starting with an underscore are reserved for internal use.
        /// Names should be CamelCase and match the regexp "[A-Z][a-zA-Z0-9_]*".
        public fileprivate(set) var name:String = ""
        public fileprivate(set) var hasName:Bool = false

        public fileprivate(set) var inputArg:Array<Tensorflow.OpDef.ArgDef>  = Array<Tensorflow.OpDef.ArgDef>()
        public fileprivate(set) var outputArg:Array<Tensorflow.OpDef.ArgDef>  = Array<Tensorflow.OpDef.ArgDef>()
        public fileprivate(set) var attr:Array<Tensorflow.OpDef.AttrDef>  = Array<Tensorflow.OpDef.AttrDef>()
        public fileprivate(set) var deprecation:Tensorflow.OpDeprecation!
        public fileprivate(set) var hasDeprecation:Bool = false
        /// One-line human-readable description of what the Op does.
        public fileprivate(set) var summary:String = ""
        public fileprivate(set) var hasSummary:Bool = false

        /// Additional, longer human-readable description of what the Op does.
        public fileprivate(set) var description_:String = ""
        public fileprivate(set) var hasDescription:Bool = false

        /// True if the operation is commutative ("op(a,b) == op(b,a)" for all inputs)
        public fileprivate(set) var isCommutative:Bool = false
        public fileprivate(set) var hasIsCommutative:Bool = false

        /// If is_aggregate is true, then this operation accepts N >= 2
        /// inputs and produces 1 output all of the same type.  Should be
        /// associative and commutative, and produce output with the same
        /// shape as the input.  The optimizer may replace an aggregate op
        /// taking input from multiple devices with a tree of aggregate ops
        /// that aggregate locally within each device (and possibly within
        /// groups of nearby devices) before communicating.
        /// TODO(josh11b): Implement that optimization.
        public fileprivate(set) var isAggregate:Bool = false
        public fileprivate(set) var hasIsAggregate:Bool = false

        /// By default Ops may be moved between devices.  Stateful ops should
        /// either not be moved, or should only be moved if that state can also
        /// be moved (e.g. via some sort of save / restore).
        /// Stateful ops are guaranteed to never be optimized away by Common
        /// Subexpression Elimination (CSE).
        public fileprivate(set) var isStateful:Bool = false
        public fileprivate(set) var hasIsStateful:Bool = false

        /// By default, all inputs to an Op must be initialized Tensors.  Ops
        /// that may initialize tensors for the first time should set this
        /// field to true, to allow the Op to take an uninitialized Tensor as
        /// input.
        public fileprivate(set) var allowsUninitializedInput:Bool = false
        public fileprivate(set) var hasAllowsUninitializedInput:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasName {
                try codedOutputStream.writeString(fieldNumber: 1, value:name)
            }
            for oneElementInputArg in inputArg {
                  try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementInputArg)
            }
            for oneElementOutputArg in outputArg {
                  try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementOutputArg)
            }
            for oneElementAttr in attr {
                  try codedOutputStream.writeMessage(fieldNumber: 4, value:oneElementAttr)
            }
            if hasSummary {
                try codedOutputStream.writeString(fieldNumber: 5, value:summary)
            }
            if hasDescription {
                try codedOutputStream.writeString(fieldNumber: 6, value:description_)
            }
            if hasDeprecation {
                try codedOutputStream.writeMessage(fieldNumber: 8, value:deprecation)
            }
            if hasIsAggregate {
                try codedOutputStream.writeBool(fieldNumber: 16, value:isAggregate)
            }
            if hasIsStateful {
                try codedOutputStream.writeBool(fieldNumber: 17, value:isStateful)
            }
            if hasIsCommutative {
                try codedOutputStream.writeBool(fieldNumber: 18, value:isCommutative)
            }
            if hasAllowsUninitializedInput {
                try codedOutputStream.writeBool(fieldNumber: 19, value:allowsUninitializedInput)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasName {
                serialize_size += name.computeStringSize(fieldNumber: 1)
            }
            for oneElementInputArg in inputArg {
                serialize_size += oneElementInputArg.computeMessageSize(fieldNumber: 2)
            }
            for oneElementOutputArg in outputArg {
                serialize_size += oneElementOutputArg.computeMessageSize(fieldNumber: 3)
            }
            for oneElementAttr in attr {
                serialize_size += oneElementAttr.computeMessageSize(fieldNumber: 4)
            }
            if hasSummary {
                serialize_size += summary.computeStringSize(fieldNumber: 5)
            }
            if hasDescription {
                serialize_size += description_.computeStringSize(fieldNumber: 6)
            }
            if hasDeprecation {
                if let varSizedeprecation = deprecation?.computeMessageSize(fieldNumber: 8) {
                    serialize_size += varSizedeprecation
                }
            }
            if hasIsAggregate {
                serialize_size += isAggregate.computeBoolSize(fieldNumber: 16)
            }
            if hasIsStateful {
                serialize_size += isStateful.computeBoolSize(fieldNumber: 17)
            }
            if hasIsCommutative {
                serialize_size += isCommutative.computeBoolSize(fieldNumber: 18)
            }
            if hasAllowsUninitializedInput {
                serialize_size += allowsUninitializedInput.computeBoolSize(fieldNumber: 19)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.OpDef.Builder {
            return Tensorflow.OpDef.classBuilder() as! Tensorflow.OpDef.Builder
        }
        public func getBuilder() -> Tensorflow.OpDef.Builder {
            return classBuilder() as! Tensorflow.OpDef.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.OpDef.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.OpDef.Builder()
        }
        public func toBuilder() throws -> Tensorflow.OpDef.Builder {
            return try Tensorflow.OpDef.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.OpDef) throws -> Tensorflow.OpDef.Builder {
            return try Tensorflow.OpDef.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasName {
                jsonMap["name"] = name
            }
            if !inputArg.isEmpty {
                var jsonArrayInputArg:Array<Dictionary<String,Any>> = []
                for oneValueInputArg in inputArg {
                    let ecodedMessageInputArg = try oneValueInputArg.encode()
                    jsonArrayInputArg.append(ecodedMessageInputArg)
                }
                jsonMap["inputArg"] = jsonArrayInputArg
            }
            if !outputArg.isEmpty {
                var jsonArrayOutputArg:Array<Dictionary<String,Any>> = []
                for oneValueOutputArg in outputArg {
                    let ecodedMessageOutputArg = try oneValueOutputArg.encode()
                    jsonArrayOutputArg.append(ecodedMessageOutputArg)
                }
                jsonMap["outputArg"] = jsonArrayOutputArg
            }
            if !attr.isEmpty {
                var jsonArrayAttr:Array<Dictionary<String,Any>> = []
                for oneValueAttr in attr {
                    let ecodedMessageAttr = try oneValueAttr.encode()
                    jsonArrayAttr.append(ecodedMessageAttr)
                }
                jsonMap["attr"] = jsonArrayAttr
            }
            if hasDeprecation {
                jsonMap["deprecation"] = try deprecation.encode()
            }
            if hasSummary {
                jsonMap["summary"] = summary
            }
            if hasDescription {
                jsonMap["description"] = description_
            }
            if hasIsCommutative {
                jsonMap["isCommutative"] = isCommutative
            }
            if hasIsAggregate {
                jsonMap["isAggregate"] = isAggregate
            }
            if hasIsStateful {
                jsonMap["isStateful"] = isStateful
            }
            if hasAllowsUninitializedInput {
                jsonMap["allowsUninitializedInput"] = allowsUninitializedInput
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OpDef {
            return try Tensorflow.OpDef.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.OpDef {
            return try Tensorflow.OpDef.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasName {
                output += "\(indent) name: \(name) \n"
            }
            var inputArgElementIndex:Int = 0
            for oneElementInputArg in inputArg {
                output += "\(indent) inputArg[\(inputArgElementIndex)] {\n"
                output += try oneElementInputArg.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                inputArgElementIndex += 1
            }
            var outputArgElementIndex:Int = 0
            for oneElementOutputArg in outputArg {
                output += "\(indent) outputArg[\(outputArgElementIndex)] {\n"
                output += try oneElementOutputArg.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                outputArgElementIndex += 1
            }
            var attrElementIndex:Int = 0
            for oneElementAttr in attr {
                output += "\(indent) attr[\(attrElementIndex)] {\n"
                output += try oneElementAttr.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                attrElementIndex += 1
            }
            if hasSummary {
                output += "\(indent) summary: \(summary) \n"
            }
            if hasDescription {
                output += "\(indent) description: \(description_) \n"
            }
            if hasDeprecation {
                output += "\(indent) deprecation {\n"
                if let outDescDeprecation = deprecation {
                    output += try outDescDeprecation.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasIsAggregate {
                output += "\(indent) isAggregate: \(isAggregate) \n"
            }
            if hasIsStateful {
                output += "\(indent) isStateful: \(isStateful) \n"
            }
            if hasIsCommutative {
                output += "\(indent) isCommutative: \(isCommutative) \n"
            }
            if hasAllowsUninitializedInput {
                output += "\(indent) allowsUninitializedInput: \(allowsUninitializedInput) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasName {
                    hashCode = (hashCode &* 31) &+ name.hashValue
                }
                for oneElementInputArg in inputArg {
                    hashCode = (hashCode &* 31) &+ oneElementInputArg.hashValue
                }
                for oneElementOutputArg in outputArg {
                    hashCode = (hashCode &* 31) &+ oneElementOutputArg.hashValue
                }
                for oneElementAttr in attr {
                    hashCode = (hashCode &* 31) &+ oneElementAttr.hashValue
                }
                if hasSummary {
                    hashCode = (hashCode &* 31) &+ summary.hashValue
                }
                if hasDescription {
                    hashCode = (hashCode &* 31) &+ description_.hashValue
                }
                if hasDeprecation {
                    if let hashValuedeprecation = deprecation?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuedeprecation
                    }
                }
                if hasIsAggregate {
                    hashCode = (hashCode &* 31) &+ isAggregate.hashValue
                }
                if hasIsStateful {
                    hashCode = (hashCode &* 31) &+ isStateful.hashValue
                }
                if hasIsCommutative {
                    hashCode = (hashCode &* 31) &+ isCommutative.hashValue
                }
                if hasAllowsUninitializedInput {
                    hashCode = (hashCode &* 31) &+ allowsUninitializedInput.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.OpDef"
        }
        override public func className() -> String {
            return "Tensorflow.OpDef"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.OpDef = Tensorflow.OpDef()
            public func getMessage() -> Tensorflow.OpDef {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Op names starting with an underscore are reserved for internal use.
            /// Names should be CamelCase and match the regexp "[A-Z][a-zA-Z0-9_]*".
            public var name:String {
                get {
                    return builderResult.name
                }
                set (value) {
                    builderResult.hasName = true
                    builderResult.name = value
                }
            }
            public var hasName:Bool {
                get {
                    return builderResult.hasName
                }
            }
            @discardableResult
            public func setName(_ value:String) -> Tensorflow.OpDef.Builder {
                self.name = value
                return self
            }
            @discardableResult
            public func clearName() -> Tensorflow.OpDef.Builder{
                builderResult.hasName = false
                builderResult.name = ""
                return self
            }
            /// Description of the input(s).
            public var inputArg:Array<Tensorflow.OpDef.ArgDef> {
                get {
                    return builderResult.inputArg
                }
                set (value) {
                    builderResult.inputArg = value
                }
            }
            @discardableResult
            public func setInputArg(_ value:Array<Tensorflow.OpDef.ArgDef>) -> Tensorflow.OpDef.Builder {
                self.inputArg = value
                return self
            }
            @discardableResult
            public func clearInputArg() -> Tensorflow.OpDef.Builder {
                builderResult.inputArg.removeAll(keepingCapacity: false)
                return self
            }
            /// Description of the output(s).
            public var outputArg:Array<Tensorflow.OpDef.ArgDef> {
                get {
                    return builderResult.outputArg
                }
                set (value) {
                    builderResult.outputArg = value
                }
            }
            @discardableResult
            public func setOutputArg(_ value:Array<Tensorflow.OpDef.ArgDef>) -> Tensorflow.OpDef.Builder {
                self.outputArg = value
                return self
            }
            @discardableResult
            public func clearOutputArg() -> Tensorflow.OpDef.Builder {
                builderResult.outputArg.removeAll(keepingCapacity: false)
                return self
            }
            public var attr:Array<Tensorflow.OpDef.AttrDef> {
                get {
                    return builderResult.attr
                }
                set (value) {
                    builderResult.attr = value
                }
            }
            @discardableResult
            public func setAttr(_ value:Array<Tensorflow.OpDef.AttrDef>) -> Tensorflow.OpDef.Builder {
                self.attr = value
                return self
            }
            @discardableResult
            public func clearAttr() -> Tensorflow.OpDef.Builder {
                builderResult.attr.removeAll(keepingCapacity: false)
                return self
            }
            /// Optional deprecation based on GraphDef versions.
            public var deprecation:Tensorflow.OpDeprecation! {
                get {
                    if deprecationBuilder_ != nil {
                        builderResult.deprecation = deprecationBuilder_.getMessage()
                    }
                    return builderResult.deprecation
                }
                set (value) {
                    builderResult.hasDeprecation = true
                    builderResult.deprecation = value
                }
            }
            public var hasDeprecation:Bool {
                get {
                    return builderResult.hasDeprecation
                }
            }
            fileprivate var deprecationBuilder_:Tensorflow.OpDeprecation.Builder! {
                didSet {
                    builderResult.hasDeprecation = true
                }
            }
            public func getDeprecationBuilder() -> Tensorflow.OpDeprecation.Builder {
                if deprecationBuilder_ == nil {
                    deprecationBuilder_ = Tensorflow.OpDeprecation.Builder()
                    builderResult.deprecation = deprecationBuilder_.getMessage()
                    if deprecation != nil {
                        try! deprecationBuilder_.mergeFrom(other: deprecation)
                    }
                }
                return deprecationBuilder_
            }
            @discardableResult
            public func setDeprecation(_ value:Tensorflow.OpDeprecation!) -> Tensorflow.OpDef.Builder {
                self.deprecation = value
                return self
            }
            @discardableResult
            public func mergeDeprecation(value:Tensorflow.OpDeprecation) throws -> Tensorflow.OpDef.Builder {
                if builderResult.hasDeprecation {
                    builderResult.deprecation = try Tensorflow.OpDeprecation.builderWithPrototype(prototype:builderResult.deprecation).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.deprecation = value
                }
                builderResult.hasDeprecation = true
                return self
            }
            @discardableResult
            public func clearDeprecation() -> Tensorflow.OpDef.Builder {
                deprecationBuilder_ = nil
                builderResult.hasDeprecation = false
                builderResult.deprecation = nil
                return self
            }
            /// One-line human-readable description of what the Op does.
            public var summary:String {
                get {
                    return builderResult.summary
                }
                set (value) {
                    builderResult.hasSummary = true
                    builderResult.summary = value
                }
            }
            public var hasSummary:Bool {
                get {
                    return builderResult.hasSummary
                }
            }
            @discardableResult
            public func setSummary(_ value:String) -> Tensorflow.OpDef.Builder {
                self.summary = value
                return self
            }
            @discardableResult
            public func clearSummary() -> Tensorflow.OpDef.Builder{
                builderResult.hasSummary = false
                builderResult.summary = ""
                return self
            }
            /// Additional, longer human-readable description of what the Op does.
            public var description_:String {
                get {
                    return builderResult.description_
                }
                set (value) {
                    builderResult.hasDescription = true
                    builderResult.description_ = value
                }
            }
            public var hasDescription:Bool {
                get {
                    return builderResult.hasDescription
                }
            }
            @discardableResult
            public func setDescription(_ value:String) -> Tensorflow.OpDef.Builder {
                self.description_ = value
                return self
            }
            @discardableResult
            public func clearDescription() -> Tensorflow.OpDef.Builder{
                builderResult.hasDescription = false
                builderResult.description_ = ""
                return self
            }
            /// True if the operation is commutative ("op(a,b) == op(b,a)" for all inputs)
            public var isCommutative:Bool {
                get {
                    return builderResult.isCommutative
                }
                set (value) {
                    builderResult.hasIsCommutative = true
                    builderResult.isCommutative = value
                }
            }
            public var hasIsCommutative:Bool {
                get {
                    return builderResult.hasIsCommutative
                }
            }
            @discardableResult
            public func setIsCommutative(_ value:Bool) -> Tensorflow.OpDef.Builder {
                self.isCommutative = value
                return self
            }
            @discardableResult
            public func clearIsCommutative() -> Tensorflow.OpDef.Builder{
                builderResult.hasIsCommutative = false
                builderResult.isCommutative = false
                return self
            }
            /// If is_aggregate is true, then this operation accepts N >= 2
            /// inputs and produces 1 output all of the same type.  Should be
            /// associative and commutative, and produce output with the same
            /// shape as the input.  The optimizer may replace an aggregate op
            /// taking input from multiple devices with a tree of aggregate ops
            /// that aggregate locally within each device (and possibly within
            /// groups of nearby devices) before communicating.
            /// TODO(josh11b): Implement that optimization.
            public var isAggregate:Bool {
                get {
                    return builderResult.isAggregate
                }
                set (value) {
                    builderResult.hasIsAggregate = true
                    builderResult.isAggregate = value
                }
            }
            public var hasIsAggregate:Bool {
                get {
                    return builderResult.hasIsAggregate
                }
            }
            @discardableResult
            public func setIsAggregate(_ value:Bool) -> Tensorflow.OpDef.Builder {
                self.isAggregate = value
                return self
            }
            @discardableResult
            public func clearIsAggregate() -> Tensorflow.OpDef.Builder{
                builderResult.hasIsAggregate = false
                builderResult.isAggregate = false
                return self
            }
            /// By default Ops may be moved between devices.  Stateful ops should
            /// either not be moved, or should only be moved if that state can also
            /// be moved (e.g. via some sort of save / restore).
            /// Stateful ops are guaranteed to never be optimized away by Common
            /// Subexpression Elimination (CSE).
            public var isStateful:Bool {
                get {
                    return builderResult.isStateful
                }
                set (value) {
                    builderResult.hasIsStateful = true
                    builderResult.isStateful = value
                }
            }
            public var hasIsStateful:Bool {
                get {
                    return builderResult.hasIsStateful
                }
            }
            @discardableResult
            public func setIsStateful(_ value:Bool) -> Tensorflow.OpDef.Builder {
                self.isStateful = value
                return self
            }
            @discardableResult
            public func clearIsStateful() -> Tensorflow.OpDef.Builder{
                builderResult.hasIsStateful = false
                builderResult.isStateful = false
                return self
            }
            /// By default, all inputs to an Op must be initialized Tensors.  Ops
            /// that may initialize tensors for the first time should set this
            /// field to true, to allow the Op to take an uninitialized Tensor as
            /// input.
            public var allowsUninitializedInput:Bool {
                get {
                    return builderResult.allowsUninitializedInput
                }
                set (value) {
                    builderResult.hasAllowsUninitializedInput = true
                    builderResult.allowsUninitializedInput = value
                }
            }
            public var hasAllowsUninitializedInput:Bool {
                get {
                    return builderResult.hasAllowsUninitializedInput
                }
            }
            @discardableResult
            public func setAllowsUninitializedInput(_ value:Bool) -> Tensorflow.OpDef.Builder {
                self.allowsUninitializedInput = value
                return self
            }
            @discardableResult
            public func clearAllowsUninitializedInput() -> Tensorflow.OpDef.Builder{
                builderResult.hasAllowsUninitializedInput = false
                builderResult.allowsUninitializedInput = false
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.OpDef.Builder {
                builderResult = Tensorflow.OpDef()
                return self
            }
            override public func clone() throws -> Tensorflow.OpDef.Builder {
                return try Tensorflow.OpDef.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.OpDef {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.OpDef {
                let returnMe:Tensorflow.OpDef = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.OpDef) throws -> Tensorflow.OpDef.Builder {
                if other == Tensorflow.OpDef() {
                    return self
                }
                if other.hasName {
                    name = other.name
                }
                if !other.inputArg.isEmpty  {
                     builderResult.inputArg += other.inputArg
                }
                if !other.outputArg.isEmpty  {
                     builderResult.outputArg += other.outputArg
                }
                if !other.attr.isEmpty  {
                     builderResult.attr += other.attr
                }
                if (other.hasDeprecation) {
                    try mergeDeprecation(value: other.deprecation)
                }
                if other.hasSummary {
                    summary = other.summary
                }
                if other.hasDescription {
                    description_ = other.description_
                }
                if other.hasIsCommutative {
                    isCommutative = other.isCommutative
                }
                if other.hasIsAggregate {
                    isAggregate = other.isAggregate
                }
                if other.hasIsStateful {
                    isStateful = other.isStateful
                }
                if other.hasAllowsUninitializedInput {
                    allowsUninitializedInput = other.allowsUninitializedInput
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OpDef.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpDef.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        name = try codedInputStream.readString()

                    case 18:
                        let subBuilder = Tensorflow.OpDef.ArgDef.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        inputArg.append(subBuilder.buildPartial())

                    case 26:
                        let subBuilder = Tensorflow.OpDef.ArgDef.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        outputArg.append(subBuilder.buildPartial())

                    case 34:
                        let subBuilder = Tensorflow.OpDef.AttrDef.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        attr.append(subBuilder.buildPartial())

                    case 42:
                        summary = try codedInputStream.readString()

                    case 50:
                        description_ = try codedInputStream.readString()

                    case 66:
                        let subBuilder:Tensorflow.OpDeprecation.Builder = Tensorflow.OpDeprecation.Builder()
                        if hasDeprecation {
                            try subBuilder.mergeFrom(other: deprecation)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        deprecation = subBuilder.buildPartial()

                    case 128:
                        isAggregate = try codedInputStream.readBool()

                    case 136:
                        isStateful = try codedInputStream.readBool()

                    case 144:
                        isCommutative = try codedInputStream.readBool()

                    case 152:
                        allowsUninitializedInput = try codedInputStream.readBool()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OpDef.Builder {
                let resultDecodedBuilder = Tensorflow.OpDef.Builder()
                if let jsonValueName = jsonMap["name"] as? String {
                    resultDecodedBuilder.name = jsonValueName
                }
                if let jsonValueInputArg = jsonMap["inputArg"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayInputArg:Array<Tensorflow.OpDef.ArgDef> = []
                    for oneValueInputArg in jsonValueInputArg {
                        let messageFromStringInputArg = try Tensorflow.OpDef.ArgDef.Builder.decodeToBuilder(jsonMap:oneValueInputArg).build()

                        jsonArrayInputArg.append(messageFromStringInputArg)
                    }
                    resultDecodedBuilder.inputArg = jsonArrayInputArg
                }
                if let jsonValueOutputArg = jsonMap["outputArg"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayOutputArg:Array<Tensorflow.OpDef.ArgDef> = []
                    for oneValueOutputArg in jsonValueOutputArg {
                        let messageFromStringOutputArg = try Tensorflow.OpDef.ArgDef.Builder.decodeToBuilder(jsonMap:oneValueOutputArg).build()

                        jsonArrayOutputArg.append(messageFromStringOutputArg)
                    }
                    resultDecodedBuilder.outputArg = jsonArrayOutputArg
                }
                if let jsonValueAttr = jsonMap["attr"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayAttr:Array<Tensorflow.OpDef.AttrDef> = []
                    for oneValueAttr in jsonValueAttr {
                        let messageFromStringAttr = try Tensorflow.OpDef.AttrDef.Builder.decodeToBuilder(jsonMap:oneValueAttr).build()

                        jsonArrayAttr.append(messageFromStringAttr)
                    }
                    resultDecodedBuilder.attr = jsonArrayAttr
                }
                if let jsonValueDeprecation = jsonMap["deprecation"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.deprecation = try Tensorflow.OpDeprecation.Builder.decodeToBuilder(jsonMap:jsonValueDeprecation).build()

                }
                if let jsonValueSummary = jsonMap["summary"] as? String {
                    resultDecodedBuilder.summary = jsonValueSummary
                }
                if let jsonValueDescription = jsonMap["description"] as? String {
                    resultDecodedBuilder.description_ = jsonValueDescription
                }
                if let jsonValueIsCommutative = jsonMap["isCommutative"] as? Bool {
                    resultDecodedBuilder.isCommutative = jsonValueIsCommutative
                }
                if let jsonValueIsAggregate = jsonMap["isAggregate"] as? Bool {
                    resultDecodedBuilder.isAggregate = jsonValueIsAggregate
                }
                if let jsonValueIsStateful = jsonMap["isStateful"] as? Bool {
                    resultDecodedBuilder.isStateful = jsonValueIsStateful
                }
                if let jsonValueAllowsUninitializedInput = jsonMap["allowsUninitializedInput"] as? Bool {
                    resultDecodedBuilder.allowsUninitializedInput = jsonValueAllowsUninitializedInput
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.OpDef.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.OpDef.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Information about version-dependent deprecation of an op
    final public class OpDeprecation : GeneratedMessage {

        public static func == (lhs: Tensorflow.OpDeprecation, rhs: Tensorflow.OpDeprecation) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
            fieldCheck = fieldCheck && (lhs.hasExplanation == rhs.hasExplanation) && (!lhs.hasExplanation || lhs.explanation == rhs.explanation)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// First GraphDef version at which the op is disallowed.
        public fileprivate(set) var version:Int32 = Int32(0)
        public fileprivate(set) var hasVersion:Bool = false

        /// Explanation of why it was deprecated and what to use instead.
        public fileprivate(set) var explanation:String = ""
        public fileprivate(set) var hasExplanation:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasVersion {
                try codedOutputStream.writeInt32(fieldNumber: 1, value:version)
            }
            if hasExplanation {
                try codedOutputStream.writeString(fieldNumber: 2, value:explanation)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasVersion {
                serialize_size += version.computeInt32Size(fieldNumber: 1)
            }
            if hasExplanation {
                serialize_size += explanation.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.OpDeprecation.Builder {
            return Tensorflow.OpDeprecation.classBuilder() as! Tensorflow.OpDeprecation.Builder
        }
        public func getBuilder() -> Tensorflow.OpDeprecation.Builder {
            return classBuilder() as! Tensorflow.OpDeprecation.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.OpDeprecation.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.OpDeprecation.Builder()
        }
        public func toBuilder() throws -> Tensorflow.OpDeprecation.Builder {
            return try Tensorflow.OpDeprecation.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.OpDeprecation) throws -> Tensorflow.OpDeprecation.Builder {
            return try Tensorflow.OpDeprecation.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasVersion {
                jsonMap["version"] = Int(version)
            }
            if hasExplanation {
                jsonMap["explanation"] = explanation
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OpDeprecation {
            return try Tensorflow.OpDeprecation.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.OpDeprecation {
            return try Tensorflow.OpDeprecation.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasVersion {
                output += "\(indent) version: \(version) \n"
            }
            if hasExplanation {
                output += "\(indent) explanation: \(explanation) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasVersion {
                    hashCode = (hashCode &* 31) &+ version.hashValue
                }
                if hasExplanation {
                    hashCode = (hashCode &* 31) &+ explanation.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.OpDeprecation"
        }
        override public func className() -> String {
            return "Tensorflow.OpDeprecation"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.OpDeprecation = Tensorflow.OpDeprecation()
            public func getMessage() -> Tensorflow.OpDeprecation {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// First GraphDef version at which the op is disallowed.
            public var version:Int32 {
                get {
                    return builderResult.version
                }
                set (value) {
                    builderResult.hasVersion = true
                    builderResult.version = value
                }
            }
            public var hasVersion:Bool {
                get {
                    return builderResult.hasVersion
                }
            }
            @discardableResult
            public func setVersion(_ value:Int32) -> Tensorflow.OpDeprecation.Builder {
                self.version = value
                return self
            }
            @discardableResult
            public func clearVersion() -> Tensorflow.OpDeprecation.Builder{
                builderResult.hasVersion = false
                builderResult.version = Int32(0)
                return self
            }
            /// Explanation of why it was deprecated and what to use instead.
            public var explanation:String {
                get {
                    return builderResult.explanation
                }
                set (value) {
                    builderResult.hasExplanation = true
                    builderResult.explanation = value
                }
            }
            public var hasExplanation:Bool {
                get {
                    return builderResult.hasExplanation
                }
            }
            @discardableResult
            public func setExplanation(_ value:String) -> Tensorflow.OpDeprecation.Builder {
                self.explanation = value
                return self
            }
            @discardableResult
            public func clearExplanation() -> Tensorflow.OpDeprecation.Builder{
                builderResult.hasExplanation = false
                builderResult.explanation = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.OpDeprecation.Builder {
                builderResult = Tensorflow.OpDeprecation()
                return self
            }
            override public func clone() throws -> Tensorflow.OpDeprecation.Builder {
                return try Tensorflow.OpDeprecation.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.OpDeprecation {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.OpDeprecation {
                let returnMe:Tensorflow.OpDeprecation = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.OpDeprecation) throws -> Tensorflow.OpDeprecation.Builder {
                if other == Tensorflow.OpDeprecation() {
                    return self
                }
                if other.hasVersion {
                    version = other.version
                }
                if other.hasExplanation {
                    explanation = other.explanation
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OpDeprecation.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpDeprecation.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        version = try codedInputStream.readInt32()

                    case 18:
                        explanation = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OpDeprecation.Builder {
                let resultDecodedBuilder = Tensorflow.OpDeprecation.Builder()
                if let jsonValueVersion = jsonMap["version"] as? Int {
                    resultDecodedBuilder.version = Int32(jsonValueVersion)
                } else if let jsonValueVersion = jsonMap["version"] as? String {
                    resultDecodedBuilder.version = Int32(jsonValueVersion)!
                }
                if let jsonValueExplanation = jsonMap["explanation"] as? String {
                    resultDecodedBuilder.explanation = jsonValueExplanation
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.OpDeprecation.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.OpDeprecation.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// A collection of OpDefs
    final public class OpList : GeneratedMessage {

        public static func == (lhs: Tensorflow.OpList, rhs: Tensorflow.OpList) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.op == rhs.op)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var op:Array<Tensorflow.OpDef>  = Array<Tensorflow.OpDef>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementOp in op {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementOp)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementOp in op {
                serialize_size += oneElementOp.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.OpList.Builder {
            return Tensorflow.OpList.classBuilder() as! Tensorflow.OpList.Builder
        }
        public func getBuilder() -> Tensorflow.OpList.Builder {
            return classBuilder() as! Tensorflow.OpList.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.OpList.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.OpList.Builder()
        }
        public func toBuilder() throws -> Tensorflow.OpList.Builder {
            return try Tensorflow.OpList.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.OpList) throws -> Tensorflow.OpList.Builder {
            return try Tensorflow.OpList.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !op.isEmpty {
                var jsonArrayOp:Array<Dictionary<String,Any>> = []
                for oneValueOp in op {
                    let ecodedMessageOp = try oneValueOp.encode()
                    jsonArrayOp.append(ecodedMessageOp)
                }
                jsonMap["op"] = jsonArrayOp
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OpList {
            return try Tensorflow.OpList.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.OpList {
            return try Tensorflow.OpList.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var opElementIndex:Int = 0
            for oneElementOp in op {
                output += "\(indent) op[\(opElementIndex)] {\n"
                output += try oneElementOp.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                opElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementOp in op {
                    hashCode = (hashCode &* 31) &+ oneElementOp.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.OpList"
        }
        override public func className() -> String {
            return "Tensorflow.OpList"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.OpList = Tensorflow.OpList()
            public func getMessage() -> Tensorflow.OpList {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var op:Array<Tensorflow.OpDef> {
                get {
                    return builderResult.op
                }
                set (value) {
                    builderResult.op = value
                }
            }
            @discardableResult
            public func setOp(_ value:Array<Tensorflow.OpDef>) -> Tensorflow.OpList.Builder {
                self.op = value
                return self
            }
            @discardableResult
            public func clearOp() -> Tensorflow.OpList.Builder {
                builderResult.op.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.OpList.Builder {
                builderResult = Tensorflow.OpList()
                return self
            }
            override public func clone() throws -> Tensorflow.OpList.Builder {
                return try Tensorflow.OpList.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.OpList {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.OpList {
                let returnMe:Tensorflow.OpList = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.OpList) throws -> Tensorflow.OpList.Builder {
                if other == Tensorflow.OpList() {
                    return self
                }
                if !other.op.isEmpty  {
                     builderResult.op += other.op
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OpList.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpList.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Tensorflow.OpDef.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        op.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.OpList.Builder {
                let resultDecodedBuilder = Tensorflow.OpList.Builder()
                if let jsonValueOp = jsonMap["op"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayOp:Array<Tensorflow.OpDef> = []
                    for oneValueOp in jsonValueOp {
                        let messageFromStringOp = try Tensorflow.OpDef.Builder.decodeToBuilder(jsonMap:oneValueOp).build()

                        jsonArrayOp.append(messageFromStringOp)
                    }
                    resultDecodedBuilder.op = jsonArrayOp
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.OpList.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.OpList.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.OpDef: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.OpDef> {
        var mergedArray = Array<Tensorflow.OpDef>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.OpDef? {
        return try Tensorflow.OpDef.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.OpDef {
        return try Tensorflow.OpDef.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.OpDefRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpDef {
        return try Tensorflow.OpDef.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.OpDef {
        return try Tensorflow.OpDef.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpDef {
        return try Tensorflow.OpDef.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OpDef {
        return try Tensorflow.OpDef.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpDef {
        return try Tensorflow.OpDef.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "name": return self.name
        case "inputArg": return self.inputArg
        case "outputArg": return self.outputArg
        case "attr": return self.attr
        case "deprecation": return self.deprecation
        case "summary": return self.summary
        case "description_": return self.description_
        case "isCommutative": return self.isCommutative
        case "isAggregate": return self.isAggregate
        case "isStateful": return self.isStateful
        case "allowsUninitializedInput": return self.allowsUninitializedInput
        default: return nil
        }
    }
}
extension Tensorflow.OpDef.ArgDef: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.OpDef.ArgDef> {
        var mergedArray = Array<Tensorflow.OpDef.ArgDef>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.OpDef.ArgDef? {
        return try Tensorflow.OpDef.ArgDef.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.OpDef.ArgDef {
        return try Tensorflow.OpDef.ArgDef.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.OpDefRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpDef.ArgDef {
        return try Tensorflow.OpDef.ArgDef.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.OpDef.ArgDef {
        return try Tensorflow.OpDef.ArgDef.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpDef.ArgDef {
        return try Tensorflow.OpDef.ArgDef.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OpDef.ArgDef {
        return try Tensorflow.OpDef.ArgDef.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpDef.ArgDef {
        return try Tensorflow.OpDef.ArgDef.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "name": return self.name
        case "description_": return self.description_
        case "type": return self.type
        case "typeAttr": return self.typeAttr
        case "numberAttr": return self.numberAttr
        case "typeListAttr": return self.typeListAttr
        case "isRef": return self.isRef
        default: return nil
        }
    }
}
extension Tensorflow.OpDef.AttrDef: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.OpDef.AttrDef> {
        var mergedArray = Array<Tensorflow.OpDef.AttrDef>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.OpDef.AttrDef? {
        return try Tensorflow.OpDef.AttrDef.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.OpDef.AttrDef {
        return try Tensorflow.OpDef.AttrDef.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.OpDefRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpDef.AttrDef {
        return try Tensorflow.OpDef.AttrDef.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.OpDef.AttrDef {
        return try Tensorflow.OpDef.AttrDef.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpDef.AttrDef {
        return try Tensorflow.OpDef.AttrDef.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OpDef.AttrDef {
        return try Tensorflow.OpDef.AttrDef.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpDef.AttrDef {
        return try Tensorflow.OpDef.AttrDef.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "name": return self.name
        case "type": return self.type
        case "defaultValue": return self.defaultValue
        case "description_": return self.description_
        case "hasMinimum": return self.hasMinimum
        case "minimum": return self.minimum
        case "allowedValues": return self.allowedValues
        default: return nil
        }
    }
}
extension Tensorflow.OpDef.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "name": return self.name
            case "inputArg": return self.inputArg
            case "outputArg": return self.outputArg
            case "attr": return self.attr
            case "deprecation": return self.deprecation
            case "summary": return self.summary
            case "description_": return self.description_
            case "isCommutative": return self.isCommutative
            case "isAggregate": return self.isAggregate
            case "isStateful": return self.isStateful
            case "allowsUninitializedInput": return self.allowsUninitializedInput
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "inputArg":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.OpDef.ArgDef> else {
                    return
                }
                self.inputArg = newSubscriptValue
            case "outputArg":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.OpDef.ArgDef> else {
                    return
                }
                self.outputArg = newSubscriptValue
            case "attr":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.OpDef.AttrDef> else {
                    return
                }
                self.attr = newSubscriptValue
            case "deprecation":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.OpDeprecation else {
                    return
                }
                self.deprecation = newSubscriptValue
            case "summary":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.summary = newSubscriptValue
            case "description_":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.description_ = newSubscriptValue
            case "isCommutative":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.isCommutative = newSubscriptValue
            case "isAggregate":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.isAggregate = newSubscriptValue
            case "isStateful":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.isStateful = newSubscriptValue
            case "allowsUninitializedInput":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.allowsUninitializedInput = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.OpDef.ArgDef.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "name": return self.name
            case "description_": return self.description_
            case "type": return self.type
            case "typeAttr": return self.typeAttr
            case "numberAttr": return self.numberAttr
            case "typeListAttr": return self.typeListAttr
            case "isRef": return self.isRef
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "description_":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.description_ = newSubscriptValue
            case "type":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.DataType else {
                    return
                }
                self.type = newSubscriptValue
            case "typeAttr":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.typeAttr = newSubscriptValue
            case "numberAttr":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.numberAttr = newSubscriptValue
            case "typeListAttr":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.typeListAttr = newSubscriptValue
            case "isRef":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.isRef = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.OpDef.AttrDef.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "name": return self.name
            case "type": return self.type
            case "defaultValue": return self.defaultValue
            case "description_": return self.description_
            case "hasMinimum": return self.hasMinimum
            case "minimum": return self.minimum
            case "allowedValues": return self.allowedValues
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "type":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.type = newSubscriptValue
            case "defaultValue":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.AttrValue else {
                    return
                }
                self.defaultValue = newSubscriptValue
            case "description_":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.description_ = newSubscriptValue
            case "hasMinimum":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.hasMinimum = newSubscriptValue
            case "minimum":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.minimum = newSubscriptValue
            case "allowedValues":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.AttrValue else {
                    return
                }
                self.allowedValues = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.OpDeprecation: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.OpDeprecation> {
        var mergedArray = Array<Tensorflow.OpDeprecation>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.OpDeprecation? {
        return try Tensorflow.OpDeprecation.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.OpDeprecation {
        return try Tensorflow.OpDeprecation.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.OpDefRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpDeprecation {
        return try Tensorflow.OpDeprecation.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.OpDeprecation {
        return try Tensorflow.OpDeprecation.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpDeprecation {
        return try Tensorflow.OpDeprecation.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OpDeprecation {
        return try Tensorflow.OpDeprecation.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpDeprecation {
        return try Tensorflow.OpDeprecation.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "version": return self.version
        case "explanation": return self.explanation
        default: return nil
        }
    }
}
extension Tensorflow.OpDeprecation.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "version": return self.version
            case "explanation": return self.explanation
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "version":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.version = newSubscriptValue
            case "explanation":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.explanation = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.OpList: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.OpList> {
        var mergedArray = Array<Tensorflow.OpList>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.OpList? {
        return try Tensorflow.OpList.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.OpList {
        return try Tensorflow.OpList.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.OpDefRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpList {
        return try Tensorflow.OpList.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.OpList {
        return try Tensorflow.OpList.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpList {
        return try Tensorflow.OpList.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.OpList {
        return try Tensorflow.OpList.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.OpList {
        return try Tensorflow.OpList.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "op": return self.op
        default: return nil
        }
    }
}
extension Tensorflow.OpList.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "op": return self.op
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "op":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.OpDef> else {
                    return
                }
                self.op = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

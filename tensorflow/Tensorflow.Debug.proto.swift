/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "debug.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { }

public extension Tensorflow {
    public struct DebugRoot {
        public static let `default` = DebugRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    /// EXPERIMENTAL. Option for watching a node.
    final public class DebugTensorWatch : GeneratedMessage {

        public static func == (lhs: Tensorflow.DebugTensorWatch, rhs: Tensorflow.DebugTensorWatch) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasNodeName == rhs.hasNodeName) && (!lhs.hasNodeName || lhs.nodeName == rhs.nodeName)
            fieldCheck = fieldCheck && (lhs.hasOutputSlot == rhs.hasOutputSlot) && (!lhs.hasOutputSlot || lhs.outputSlot == rhs.outputSlot)
            fieldCheck = fieldCheck && (lhs.debugOps == rhs.debugOps)
            fieldCheck = fieldCheck && (lhs.debugUrls == rhs.debugUrls)
            fieldCheck = fieldCheck && (lhs.hasTolerateDebugOpCreationFailures == rhs.hasTolerateDebugOpCreationFailures) && (!lhs.hasTolerateDebugOpCreationFailures || lhs.tolerateDebugOpCreationFailures == rhs.tolerateDebugOpCreationFailures)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Name of the node to watch.
        public fileprivate(set) var nodeName:String = ""
        public fileprivate(set) var hasNodeName:Bool = false

        /// Output slot to watch.
        /// The semantics of output_slot == -1 is that the node is only watched for
        /// completion, but not for any output tensors. See NodeCompletionCallback
        /// in debug_gateway.h.
        /// TODO(cais): Implement this semantics.
        public fileprivate(set) var outputSlot:Int32 = Int32(0)
        public fileprivate(set) var hasOutputSlot:Bool = false

        /// Name(s) of the debugging op(s).
        /// One or more than one probes on a tensor.
        /// e.g., {"DebugIdentity", "DebugNanCount"}
        public fileprivate(set) var debugOps:Array<String> = Array<String>()
        /// URL(s) for debug targets(s).
        ///   E.g., "file:///foo/tfdbg_dump", "grpc://localhost:11011"
        /// Each debug op listed in debug_ops will publish its output tensor (debug
        /// signal) to all URLs in debug_urls.
        /// N.B. Session::Run() supports concurrent invocations of the same inputs
        /// (feed keys), outputs and target nodes. If such concurrent invocations
        /// are to be debugged, the callers of Session::Run() must use distinct
        /// debug_urls to make sure that the streamed or dumped events do not overlap
        /// among the invocations.
        /// TODO(cais): More visible documentation of this in g3docs.
        public fileprivate(set) var debugUrls:Array<String> = Array<String>()
        /// Do not error out if debug op creation fails (e.g., due to dtype
        /// incompatibility). Instead, just log the failure.
        public fileprivate(set) var tolerateDebugOpCreationFailures:Bool = false
        public fileprivate(set) var hasTolerateDebugOpCreationFailures:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasNodeName {
                try codedOutputStream.writeString(fieldNumber: 1, value:nodeName)
            }
            if hasOutputSlot {
                try codedOutputStream.writeInt32(fieldNumber: 2, value:outputSlot)
            }
            if !debugOps.isEmpty {
                for oneValuedebugOps in debugOps {
                    try codedOutputStream.writeString(fieldNumber: 3, value:oneValuedebugOps)
                }
            }
            if !debugUrls.isEmpty {
                for oneValuedebugUrls in debugUrls {
                    try codedOutputStream.writeString(fieldNumber: 4, value:oneValuedebugUrls)
                }
            }
            if hasTolerateDebugOpCreationFailures {
                try codedOutputStream.writeBool(fieldNumber: 5, value:tolerateDebugOpCreationFailures)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasNodeName {
                serialize_size += nodeName.computeStringSize(fieldNumber: 1)
            }
            if hasOutputSlot {
                serialize_size += outputSlot.computeInt32Size(fieldNumber: 2)
            }
            var dataSizeDebugOps:Int32 = 0
            for oneValuedebugOps in debugOps {
                dataSizeDebugOps += oneValuedebugOps.computeStringSizeNoTag()
            }
            serialize_size += dataSizeDebugOps
            serialize_size += 1 * Int32(debugOps.count)
            var dataSizeDebugUrls:Int32 = 0
            for oneValuedebugUrls in debugUrls {
                dataSizeDebugUrls += oneValuedebugUrls.computeStringSizeNoTag()
            }
            serialize_size += dataSizeDebugUrls
            serialize_size += 1 * Int32(debugUrls.count)
            if hasTolerateDebugOpCreationFailures {
                serialize_size += tolerateDebugOpCreationFailures.computeBoolSize(fieldNumber: 5)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.DebugTensorWatch.Builder {
            return Tensorflow.DebugTensorWatch.classBuilder() as! Tensorflow.DebugTensorWatch.Builder
        }
        public func getBuilder() -> Tensorflow.DebugTensorWatch.Builder {
            return classBuilder() as! Tensorflow.DebugTensorWatch.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.DebugTensorWatch.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.DebugTensorWatch.Builder()
        }
        public func toBuilder() throws -> Tensorflow.DebugTensorWatch.Builder {
            return try Tensorflow.DebugTensorWatch.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.DebugTensorWatch) throws -> Tensorflow.DebugTensorWatch.Builder {
            return try Tensorflow.DebugTensorWatch.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasNodeName {
                jsonMap["nodeName"] = nodeName
            }
            if hasOutputSlot {
                jsonMap["outputSlot"] = Int(outputSlot)
            }
            if !debugOps.isEmpty {
                var jsonArrayDebugOps:Array<String> = []
                for oneValueDebugOps in debugOps {
                    jsonArrayDebugOps.append(oneValueDebugOps)
                }
                jsonMap["debugOps"] = jsonArrayDebugOps
            }
            if !debugUrls.isEmpty {
                var jsonArrayDebugUrls:Array<String> = []
                for oneValueDebugUrls in debugUrls {
                    jsonArrayDebugUrls.append(oneValueDebugUrls)
                }
                jsonMap["debugUrls"] = jsonArrayDebugUrls
            }
            if hasTolerateDebugOpCreationFailures {
                jsonMap["tolerateDebugOpCreationFailures"] = tolerateDebugOpCreationFailures
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.DebugTensorWatch {
            return try Tensorflow.DebugTensorWatch.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.DebugTensorWatch {
            return try Tensorflow.DebugTensorWatch.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasNodeName {
                output += "\(indent) nodeName: \(nodeName) \n"
            }
            if hasOutputSlot {
                output += "\(indent) outputSlot: \(outputSlot) \n"
            }
            var debugOpsElementIndex:Int = 0
            for oneValueDebugOps in debugOps  {
                output += "\(indent) debugOps[\(debugOpsElementIndex)]: \(oneValueDebugOps)\n"
                debugOpsElementIndex += 1
            }
            var debugUrlsElementIndex:Int = 0
            for oneValueDebugUrls in debugUrls  {
                output += "\(indent) debugUrls[\(debugUrlsElementIndex)]: \(oneValueDebugUrls)\n"
                debugUrlsElementIndex += 1
            }
            if hasTolerateDebugOpCreationFailures {
                output += "\(indent) tolerateDebugOpCreationFailures: \(tolerateDebugOpCreationFailures) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasNodeName {
                    hashCode = (hashCode &* 31) &+ nodeName.hashValue
                }
                if hasOutputSlot {
                    hashCode = (hashCode &* 31) &+ outputSlot.hashValue
                }
                for oneValueDebugOps in debugOps {
                    hashCode = (hashCode &* 31) &+ oneValueDebugOps.hashValue
                }
                for oneValueDebugUrls in debugUrls {
                    hashCode = (hashCode &* 31) &+ oneValueDebugUrls.hashValue
                }
                if hasTolerateDebugOpCreationFailures {
                    hashCode = (hashCode &* 31) &+ tolerateDebugOpCreationFailures.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.DebugTensorWatch"
        }
        override public func className() -> String {
            return "Tensorflow.DebugTensorWatch"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.DebugTensorWatch = Tensorflow.DebugTensorWatch()
            public func getMessage() -> Tensorflow.DebugTensorWatch {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Name of the node to watch.
            public var nodeName:String {
                get {
                    return builderResult.nodeName
                }
                set (value) {
                    builderResult.hasNodeName = true
                    builderResult.nodeName = value
                }
            }
            public var hasNodeName:Bool {
                get {
                    return builderResult.hasNodeName
                }
            }
            @discardableResult
            public func setNodeName(_ value:String) -> Tensorflow.DebugTensorWatch.Builder {
                self.nodeName = value
                return self
            }
            @discardableResult
            public func clearNodeName() -> Tensorflow.DebugTensorWatch.Builder{
                builderResult.hasNodeName = false
                builderResult.nodeName = ""
                return self
            }
            /// Output slot to watch.
            /// The semantics of output_slot == -1 is that the node is only watched for
            /// completion, but not for any output tensors. See NodeCompletionCallback
            /// in debug_gateway.h.
            /// TODO(cais): Implement this semantics.
            public var outputSlot:Int32 {
                get {
                    return builderResult.outputSlot
                }
                set (value) {
                    builderResult.hasOutputSlot = true
                    builderResult.outputSlot = value
                }
            }
            public var hasOutputSlot:Bool {
                get {
                    return builderResult.hasOutputSlot
                }
            }
            @discardableResult
            public func setOutputSlot(_ value:Int32) -> Tensorflow.DebugTensorWatch.Builder {
                self.outputSlot = value
                return self
            }
            @discardableResult
            public func clearOutputSlot() -> Tensorflow.DebugTensorWatch.Builder{
                builderResult.hasOutputSlot = false
                builderResult.outputSlot = Int32(0)
                return self
            }
            /// Name(s) of the debugging op(s).
            /// One or more than one probes on a tensor.
            /// e.g., {"DebugIdentity", "DebugNanCount"}
            public var debugOps:Array<String> {
                get {
                    return builderResult.debugOps
                }
                set (array) {
                    builderResult.debugOps = array
                }
            }
            @discardableResult
            public func setDebugOps(_ value:Array<String>) -> Tensorflow.DebugTensorWatch.Builder {
                self.debugOps = value
                return self
            }
            @discardableResult
            public func clearDebugOps() -> Tensorflow.DebugTensorWatch.Builder {
                builderResult.debugOps.removeAll(keepingCapacity: false)
                return self
            }
            /// URL(s) for debug targets(s).
            ///   E.g., "file:///foo/tfdbg_dump", "grpc://localhost:11011"
            /// Each debug op listed in debug_ops will publish its output tensor (debug
            /// signal) to all URLs in debug_urls.
            /// N.B. Session::Run() supports concurrent invocations of the same inputs
            /// (feed keys), outputs and target nodes. If such concurrent invocations
            /// are to be debugged, the callers of Session::Run() must use distinct
            /// debug_urls to make sure that the streamed or dumped events do not overlap
            /// among the invocations.
            /// TODO(cais): More visible documentation of this in g3docs.
            public var debugUrls:Array<String> {
                get {
                    return builderResult.debugUrls
                }
                set (array) {
                    builderResult.debugUrls = array
                }
            }
            @discardableResult
            public func setDebugUrls(_ value:Array<String>) -> Tensorflow.DebugTensorWatch.Builder {
                self.debugUrls = value
                return self
            }
            @discardableResult
            public func clearDebugUrls() -> Tensorflow.DebugTensorWatch.Builder {
                builderResult.debugUrls.removeAll(keepingCapacity: false)
                return self
            }
            /// Do not error out if debug op creation fails (e.g., due to dtype
            /// incompatibility). Instead, just log the failure.
            public var tolerateDebugOpCreationFailures:Bool {
                get {
                    return builderResult.tolerateDebugOpCreationFailures
                }
                set (value) {
                    builderResult.hasTolerateDebugOpCreationFailures = true
                    builderResult.tolerateDebugOpCreationFailures = value
                }
            }
            public var hasTolerateDebugOpCreationFailures:Bool {
                get {
                    return builderResult.hasTolerateDebugOpCreationFailures
                }
            }
            @discardableResult
            public func setTolerateDebugOpCreationFailures(_ value:Bool) -> Tensorflow.DebugTensorWatch.Builder {
                self.tolerateDebugOpCreationFailures = value
                return self
            }
            @discardableResult
            public func clearTolerateDebugOpCreationFailures() -> Tensorflow.DebugTensorWatch.Builder{
                builderResult.hasTolerateDebugOpCreationFailures = false
                builderResult.tolerateDebugOpCreationFailures = false
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.DebugTensorWatch.Builder {
                builderResult = Tensorflow.DebugTensorWatch()
                return self
            }
            override public func clone() throws -> Tensorflow.DebugTensorWatch.Builder {
                return try Tensorflow.DebugTensorWatch.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.DebugTensorWatch {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.DebugTensorWatch {
                let returnMe:Tensorflow.DebugTensorWatch = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.DebugTensorWatch) throws -> Tensorflow.DebugTensorWatch.Builder {
                if other == Tensorflow.DebugTensorWatch() {
                    return self
                }
                if other.hasNodeName {
                    nodeName = other.nodeName
                }
                if other.hasOutputSlot {
                    outputSlot = other.outputSlot
                }
                if !other.debugOps.isEmpty {
                    builderResult.debugOps += other.debugOps
                }
                if !other.debugUrls.isEmpty {
                    builderResult.debugUrls += other.debugUrls
                }
                if other.hasTolerateDebugOpCreationFailures {
                    tolerateDebugOpCreationFailures = other.tolerateDebugOpCreationFailures
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.DebugTensorWatch.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.DebugTensorWatch.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        nodeName = try codedInputStream.readString()

                    case 16:
                        outputSlot = try codedInputStream.readInt32()

                    case 26:
                        debugOps += [try codedInputStream.readString()]

                    case 34:
                        debugUrls += [try codedInputStream.readString()]

                    case 40:
                        tolerateDebugOpCreationFailures = try codedInputStream.readBool()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.DebugTensorWatch.Builder {
                let resultDecodedBuilder = Tensorflow.DebugTensorWatch.Builder()
                if let jsonValueNodeName = jsonMap["nodeName"] as? String {
                    resultDecodedBuilder.nodeName = jsonValueNodeName
                }
                if let jsonValueOutputSlot = jsonMap["outputSlot"] as? Int {
                    resultDecodedBuilder.outputSlot = Int32(jsonValueOutputSlot)
                } else if let jsonValueOutputSlot = jsonMap["outputSlot"] as? String {
                    resultDecodedBuilder.outputSlot = Int32(jsonValueOutputSlot)!
                }
                if let jsonValueDebugOps = jsonMap["debugOps"] as? Array<String> {
                    var jsonArrayDebugOps:Array<String> = []
                    for oneValueDebugOps in jsonValueDebugOps {
                        jsonArrayDebugOps.append(oneValueDebugOps)
                    }
                    resultDecodedBuilder.debugOps = jsonArrayDebugOps
                }
                if let jsonValueDebugUrls = jsonMap["debugUrls"] as? Array<String> {
                    var jsonArrayDebugUrls:Array<String> = []
                    for oneValueDebugUrls in jsonValueDebugUrls {
                        jsonArrayDebugUrls.append(oneValueDebugUrls)
                    }
                    resultDecodedBuilder.debugUrls = jsonArrayDebugUrls
                }
                if let jsonValueTolerateDebugOpCreationFailures = jsonMap["tolerateDebugOpCreationFailures"] as? Bool {
                    resultDecodedBuilder.tolerateDebugOpCreationFailures = jsonValueTolerateDebugOpCreationFailures
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.DebugTensorWatch.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.DebugTensorWatch.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// EXPERIMENTAL. Options for initializing DebuggerState.
    final public class DebugOptions : GeneratedMessage {

        public static func == (lhs: Tensorflow.DebugOptions, rhs: Tensorflow.DebugOptions) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.debugTensorWatchOpts == rhs.debugTensorWatchOpts)
            fieldCheck = fieldCheck && (lhs.hasGlobalStep == rhs.hasGlobalStep) && (!lhs.hasGlobalStep || lhs.globalStep == rhs.globalStep)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var debugTensorWatchOpts:Array<Tensorflow.DebugTensorWatch>  = Array<Tensorflow.DebugTensorWatch>()
        /// Caller-specified global step count.
        /// Note that this is distinct from the session run count and the executor
        /// step count.
        public fileprivate(set) var globalStep:Int64 = Int64(0)
        public fileprivate(set) var hasGlobalStep:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementDebugTensorWatchOpts in debugTensorWatchOpts {
                  try codedOutputStream.writeMessage(fieldNumber: 4, value:oneElementDebugTensorWatchOpts)
            }
            if hasGlobalStep {
                try codedOutputStream.writeInt64(fieldNumber: 10, value:globalStep)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementDebugTensorWatchOpts in debugTensorWatchOpts {
                serialize_size += oneElementDebugTensorWatchOpts.computeMessageSize(fieldNumber: 4)
            }
            if hasGlobalStep {
                serialize_size += globalStep.computeInt64Size(fieldNumber: 10)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.DebugOptions.Builder {
            return Tensorflow.DebugOptions.classBuilder() as! Tensorflow.DebugOptions.Builder
        }
        public func getBuilder() -> Tensorflow.DebugOptions.Builder {
            return classBuilder() as! Tensorflow.DebugOptions.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.DebugOptions.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.DebugOptions.Builder()
        }
        public func toBuilder() throws -> Tensorflow.DebugOptions.Builder {
            return try Tensorflow.DebugOptions.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.DebugOptions) throws -> Tensorflow.DebugOptions.Builder {
            return try Tensorflow.DebugOptions.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !debugTensorWatchOpts.isEmpty {
                var jsonArrayDebugTensorWatchOpts:Array<Dictionary<String,Any>> = []
                for oneValueDebugTensorWatchOpts in debugTensorWatchOpts {
                    let ecodedMessageDebugTensorWatchOpts = try oneValueDebugTensorWatchOpts.encode()
                    jsonArrayDebugTensorWatchOpts.append(ecodedMessageDebugTensorWatchOpts)
                }
                jsonMap["debugTensorWatchOpts"] = jsonArrayDebugTensorWatchOpts
            }
            if hasGlobalStep {
                jsonMap["globalStep"] = "\(globalStep)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.DebugOptions {
            return try Tensorflow.DebugOptions.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.DebugOptions {
            return try Tensorflow.DebugOptions.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var debugTensorWatchOptsElementIndex:Int = 0
            for oneElementDebugTensorWatchOpts in debugTensorWatchOpts {
                output += "\(indent) debugTensorWatchOpts[\(debugTensorWatchOptsElementIndex)] {\n"
                output += try oneElementDebugTensorWatchOpts.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                debugTensorWatchOptsElementIndex += 1
            }
            if hasGlobalStep {
                output += "\(indent) globalStep: \(globalStep) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementDebugTensorWatchOpts in debugTensorWatchOpts {
                    hashCode = (hashCode &* 31) &+ oneElementDebugTensorWatchOpts.hashValue
                }
                if hasGlobalStep {
                    hashCode = (hashCode &* 31) &+ globalStep.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.DebugOptions"
        }
        override public func className() -> String {
            return "Tensorflow.DebugOptions"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.DebugOptions = Tensorflow.DebugOptions()
            public func getMessage() -> Tensorflow.DebugOptions {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Debugging options
            public var debugTensorWatchOpts:Array<Tensorflow.DebugTensorWatch> {
                get {
                    return builderResult.debugTensorWatchOpts
                }
                set (value) {
                    builderResult.debugTensorWatchOpts = value
                }
            }
            @discardableResult
            public func setDebugTensorWatchOpts(_ value:Array<Tensorflow.DebugTensorWatch>) -> Tensorflow.DebugOptions.Builder {
                self.debugTensorWatchOpts = value
                return self
            }
            @discardableResult
            public func clearDebugTensorWatchOpts() -> Tensorflow.DebugOptions.Builder {
                builderResult.debugTensorWatchOpts.removeAll(keepingCapacity: false)
                return self
            }
            /// Caller-specified global step count.
            /// Note that this is distinct from the session run count and the executor
            /// step count.
            public var globalStep:Int64 {
                get {
                    return builderResult.globalStep
                }
                set (value) {
                    builderResult.hasGlobalStep = true
                    builderResult.globalStep = value
                }
            }
            public var hasGlobalStep:Bool {
                get {
                    return builderResult.hasGlobalStep
                }
            }
            @discardableResult
            public func setGlobalStep(_ value:Int64) -> Tensorflow.DebugOptions.Builder {
                self.globalStep = value
                return self
            }
            @discardableResult
            public func clearGlobalStep() -> Tensorflow.DebugOptions.Builder{
                builderResult.hasGlobalStep = false
                builderResult.globalStep = Int64(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.DebugOptions.Builder {
                builderResult = Tensorflow.DebugOptions()
                return self
            }
            override public func clone() throws -> Tensorflow.DebugOptions.Builder {
                return try Tensorflow.DebugOptions.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.DebugOptions {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.DebugOptions {
                let returnMe:Tensorflow.DebugOptions = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.DebugOptions) throws -> Tensorflow.DebugOptions.Builder {
                if other == Tensorflow.DebugOptions() {
                    return self
                }
                if !other.debugTensorWatchOpts.isEmpty  {
                     builderResult.debugTensorWatchOpts += other.debugTensorWatchOpts
                }
                if other.hasGlobalStep {
                    globalStep = other.globalStep
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.DebugOptions.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.DebugOptions.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 34:
                        let subBuilder = Tensorflow.DebugTensorWatch.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        debugTensorWatchOpts.append(subBuilder.buildPartial())

                    case 80:
                        globalStep = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.DebugOptions.Builder {
                let resultDecodedBuilder = Tensorflow.DebugOptions.Builder()
                if let jsonValueDebugTensorWatchOpts = jsonMap["debugTensorWatchOpts"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayDebugTensorWatchOpts:Array<Tensorflow.DebugTensorWatch> = []
                    for oneValueDebugTensorWatchOpts in jsonValueDebugTensorWatchOpts {
                        let messageFromStringDebugTensorWatchOpts = try Tensorflow.DebugTensorWatch.Builder.decodeToBuilder(jsonMap:oneValueDebugTensorWatchOpts).build()

                        jsonArrayDebugTensorWatchOpts.append(messageFromStringDebugTensorWatchOpts)
                    }
                    resultDecodedBuilder.debugTensorWatchOpts = jsonArrayDebugTensorWatchOpts
                }
                if let jsonValueGlobalStep = jsonMap["globalStep"] as? String {
                    resultDecodedBuilder.globalStep = Int64(jsonValueGlobalStep)!
                } else if let jsonValueGlobalStep = jsonMap["globalStep"] as? Int {
                    resultDecodedBuilder.globalStep = Int64(jsonValueGlobalStep)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.DebugOptions.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.DebugOptions.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.DebugTensorWatch: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.DebugTensorWatch> {
        var mergedArray = Array<Tensorflow.DebugTensorWatch>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.DebugTensorWatch? {
        return try Tensorflow.DebugTensorWatch.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.DebugTensorWatch {
        return try Tensorflow.DebugTensorWatch.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.DebugRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.DebugTensorWatch {
        return try Tensorflow.DebugTensorWatch.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.DebugTensorWatch {
        return try Tensorflow.DebugTensorWatch.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.DebugTensorWatch {
        return try Tensorflow.DebugTensorWatch.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.DebugTensorWatch {
        return try Tensorflow.DebugTensorWatch.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.DebugTensorWatch {
        return try Tensorflow.DebugTensorWatch.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "nodeName": return self.nodeName
        case "outputSlot": return self.outputSlot
        case "debugOps": return self.debugOps
        case "debugUrls": return self.debugUrls
        case "tolerateDebugOpCreationFailures": return self.tolerateDebugOpCreationFailures
        default: return nil
        }
    }
}
extension Tensorflow.DebugTensorWatch.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "nodeName": return self.nodeName
            case "outputSlot": return self.outputSlot
            case "debugOps": return self.debugOps
            case "debugUrls": return self.debugUrls
            case "tolerateDebugOpCreationFailures": return self.tolerateDebugOpCreationFailures
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "nodeName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.nodeName = newSubscriptValue
            case "outputSlot":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.outputSlot = newSubscriptValue
            case "debugOps":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.debugOps = newSubscriptValue
            case "debugUrls":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.debugUrls = newSubscriptValue
            case "tolerateDebugOpCreationFailures":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.tolerateDebugOpCreationFailures = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.DebugOptions: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.DebugOptions> {
        var mergedArray = Array<Tensorflow.DebugOptions>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.DebugOptions? {
        return try Tensorflow.DebugOptions.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.DebugOptions {
        return try Tensorflow.DebugOptions.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.DebugRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.DebugOptions {
        return try Tensorflow.DebugOptions.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.DebugOptions {
        return try Tensorflow.DebugOptions.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.DebugOptions {
        return try Tensorflow.DebugOptions.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.DebugOptions {
        return try Tensorflow.DebugOptions.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.DebugOptions {
        return try Tensorflow.DebugOptions.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "debugTensorWatchOpts": return self.debugTensorWatchOpts
        case "globalStep": return self.globalStep
        default: return nil
        }
    }
}
extension Tensorflow.DebugOptions.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "debugTensorWatchOpts": return self.debugTensorWatchOpts
            case "globalStep": return self.globalStep
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "debugTensorWatchOpts":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.DebugTensorWatch> else {
                    return
                }
                self.debugTensorWatchOpts = newSubscriptValue
            case "globalStep":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.globalStep = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

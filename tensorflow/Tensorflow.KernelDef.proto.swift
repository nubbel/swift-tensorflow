/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "kernel_def.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { }

public extension Tensorflow {
    public struct KernelDefRoot {
        public static let `default` = KernelDefRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Tensorflow.AttrValueRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    final public class KernelDef : GeneratedMessage {

        public static func == (lhs: Tensorflow.KernelDef, rhs: Tensorflow.KernelDef) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasOp == rhs.hasOp) && (!lhs.hasOp || lhs.op == rhs.op)
            fieldCheck = fieldCheck && (lhs.hasDeviceType == rhs.hasDeviceType) && (!lhs.hasDeviceType || lhs.deviceType == rhs.deviceType)
            fieldCheck = fieldCheck && (lhs.constraint == rhs.constraint)
            fieldCheck = fieldCheck && (lhs.hostMemoryArg == rhs.hostMemoryArg)
            fieldCheck = fieldCheck && (lhs.hasLabel == rhs.hasLabel) && (!lhs.hasLabel || lhs.label == rhs.label)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        final public class AttrConstraint : GeneratedMessage {

            public static func == (lhs: Tensorflow.KernelDef.AttrConstraint, rhs: Tensorflow.KernelDef.AttrConstraint) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
                fieldCheck = fieldCheck && (lhs.hasAllowedValues == rhs.hasAllowedValues) && (!lhs.hasAllowedValues || lhs.allowedValues == rhs.allowedValues)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            /// Name of an attr from the Op.
            public fileprivate(set) var name:String = ""
            public fileprivate(set) var hasName:Bool = false

            public fileprivate(set) var allowedValues:Tensorflow.AttrValue!
            public fileprivate(set) var hasAllowedValues:Bool = false
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasName {
                    try codedOutputStream.writeString(fieldNumber: 1, value:name)
                }
                if hasAllowedValues {
                    try codedOutputStream.writeMessage(fieldNumber: 2, value:allowedValues)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasName {
                    serialize_size += name.computeStringSize(fieldNumber: 1)
                }
                if hasAllowedValues {
                    if let varSizeallowedValues = allowedValues?.computeMessageSize(fieldNumber: 2) {
                        serialize_size += varSizeallowedValues
                    }
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.KernelDef.AttrConstraint.Builder {
                return Tensorflow.KernelDef.AttrConstraint.classBuilder() as! Tensorflow.KernelDef.AttrConstraint.Builder
            }
            public func getBuilder() -> Tensorflow.KernelDef.AttrConstraint.Builder {
                return classBuilder() as! Tensorflow.KernelDef.AttrConstraint.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.KernelDef.AttrConstraint.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.KernelDef.AttrConstraint.Builder()
            }
            public func toBuilder() throws -> Tensorflow.KernelDef.AttrConstraint.Builder {
                return try Tensorflow.KernelDef.AttrConstraint.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.KernelDef.AttrConstraint) throws -> Tensorflow.KernelDef.AttrConstraint.Builder {
                return try Tensorflow.KernelDef.AttrConstraint.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasName {
                    jsonMap["name"] = name
                }
                if hasAllowedValues {
                    jsonMap["allowedValues"] = try allowedValues.encode()
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.KernelDef.AttrConstraint {
                return try Tensorflow.KernelDef.AttrConstraint.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.KernelDef.AttrConstraint {
                return try Tensorflow.KernelDef.AttrConstraint.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasName {
                    output += "\(indent) name: \(name) \n"
                }
                if hasAllowedValues {
                    output += "\(indent) allowedValues {\n"
                    if let outDescAllowedValues = allowedValues {
                        output += try outDescAllowedValues.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasName {
                        hashCode = (hashCode &* 31) &+ name.hashValue
                    }
                    if hasAllowedValues {
                        if let hashValueallowedValues = allowedValues?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValueallowedValues
                        }
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.KernelDef.AttrConstraint"
            }
            override public func className() -> String {
                return "Tensorflow.KernelDef.AttrConstraint"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.KernelDef.AttrConstraint = Tensorflow.KernelDef.AttrConstraint()
                public func getMessage() -> Tensorflow.KernelDef.AttrConstraint {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                /// Name of an attr from the Op.
                public var name:String {
                    get {
                        return builderResult.name
                    }
                    set (value) {
                        builderResult.hasName = true
                        builderResult.name = value
                    }
                }
                public var hasName:Bool {
                    get {
                        return builderResult.hasName
                    }
                }
                @discardableResult
                public func setName(_ value:String) -> Tensorflow.KernelDef.AttrConstraint.Builder {
                    self.name = value
                    return self
                }
                @discardableResult
                public func clearName() -> Tensorflow.KernelDef.AttrConstraint.Builder{
                    builderResult.hasName = false
                    builderResult.name = ""
                    return self
                }
                /// A list of values that this kernel supports for this attr.
                /// Like OpDef.AttrDef.allowed_values, except for kernels instead of Ops.
                public var allowedValues:Tensorflow.AttrValue! {
                    get {
                        if allowedValuesBuilder_ != nil {
                            builderResult.allowedValues = allowedValuesBuilder_.getMessage()
                        }
                        return builderResult.allowedValues
                    }
                    set (value) {
                        builderResult.hasAllowedValues = true
                        builderResult.allowedValues = value
                    }
                }
                public var hasAllowedValues:Bool {
                    get {
                        return builderResult.hasAllowedValues
                    }
                }
                fileprivate var allowedValuesBuilder_:Tensorflow.AttrValue.Builder! {
                    didSet {
                        builderResult.hasAllowedValues = true
                    }
                }
                public func getAllowedValuesBuilder() -> Tensorflow.AttrValue.Builder {
                    if allowedValuesBuilder_ == nil {
                        allowedValuesBuilder_ = Tensorflow.AttrValue.Builder()
                        builderResult.allowedValues = allowedValuesBuilder_.getMessage()
                        if allowedValues != nil {
                            try! allowedValuesBuilder_.mergeFrom(other: allowedValues)
                        }
                    }
                    return allowedValuesBuilder_
                }
                @discardableResult
                public func setAllowedValues(_ value:Tensorflow.AttrValue!) -> Tensorflow.KernelDef.AttrConstraint.Builder {
                    self.allowedValues = value
                    return self
                }
                @discardableResult
                public func mergeAllowedValues(value:Tensorflow.AttrValue) throws -> Tensorflow.KernelDef.AttrConstraint.Builder {
                    if builderResult.hasAllowedValues {
                        builderResult.allowedValues = try Tensorflow.AttrValue.builderWithPrototype(prototype:builderResult.allowedValues).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.allowedValues = value
                    }
                    builderResult.hasAllowedValues = true
                    return self
                }
                @discardableResult
                public func clearAllowedValues() -> Tensorflow.KernelDef.AttrConstraint.Builder {
                    allowedValuesBuilder_ = nil
                    builderResult.hasAllowedValues = false
                    builderResult.allowedValues = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.KernelDef.AttrConstraint.Builder {
                    builderResult = Tensorflow.KernelDef.AttrConstraint()
                    return self
                }
                override public func clone() throws -> Tensorflow.KernelDef.AttrConstraint.Builder {
                    return try Tensorflow.KernelDef.AttrConstraint.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.KernelDef.AttrConstraint {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.KernelDef.AttrConstraint {
                    let returnMe:Tensorflow.KernelDef.AttrConstraint = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.KernelDef.AttrConstraint) throws -> Tensorflow.KernelDef.AttrConstraint.Builder {
                    if other == Tensorflow.KernelDef.AttrConstraint() {
                        return self
                    }
                    if other.hasName {
                        name = other.name
                    }
                    if (other.hasAllowedValues) {
                        try mergeAllowedValues(value: other.allowedValues)
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.KernelDef.AttrConstraint.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.KernelDef.AttrConstraint.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            name = try codedInputStream.readString()

                        case 18:
                            let subBuilder:Tensorflow.AttrValue.Builder = Tensorflow.AttrValue.Builder()
                            if hasAllowedValues {
                                try subBuilder.mergeFrom(other: allowedValues)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            allowedValues = subBuilder.buildPartial()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.KernelDef.AttrConstraint.Builder {
                    let resultDecodedBuilder = Tensorflow.KernelDef.AttrConstraint.Builder()
                    if let jsonValueName = jsonMap["name"] as? String {
                        resultDecodedBuilder.name = jsonValueName
                    }
                    if let jsonValueAllowedValues = jsonMap["allowedValues"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.allowedValues = try Tensorflow.AttrValue.Builder.decodeToBuilder(jsonMap:jsonValueAllowedValues).build()

                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.KernelDef.AttrConstraint.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.KernelDef.AttrConstraint.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        /// Must match the name of an Op.
        public fileprivate(set) var op:String = ""
        public fileprivate(set) var hasOp:Bool = false

        /// Type of device this kernel runs on.
        public fileprivate(set) var deviceType:String = ""
        public fileprivate(set) var hasDeviceType:Bool = false

        public fileprivate(set) var constraint:Array<Tensorflow.KernelDef.AttrConstraint>  = Array<Tensorflow.KernelDef.AttrConstraint>()
        /// Names of the Op's input_/output_args that reside in host memory
        /// instead of device memory.
        public fileprivate(set) var hostMemoryArg:Array<String> = Array<String>()
        /// This allows experimental kernels to be registered for an op that
        /// won't be used unless the user specifies a "_kernel" attr with
        /// value matching this.
        public fileprivate(set) var label:String = ""
        public fileprivate(set) var hasLabel:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasOp {
                try codedOutputStream.writeString(fieldNumber: 1, value:op)
            }
            if hasDeviceType {
                try codedOutputStream.writeString(fieldNumber: 2, value:deviceType)
            }
            for oneElementConstraint in constraint {
                  try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementConstraint)
            }
            if !hostMemoryArg.isEmpty {
                for oneValuehostMemoryArg in hostMemoryArg {
                    try codedOutputStream.writeString(fieldNumber: 4, value:oneValuehostMemoryArg)
                }
            }
            if hasLabel {
                try codedOutputStream.writeString(fieldNumber: 5, value:label)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasOp {
                serialize_size += op.computeStringSize(fieldNumber: 1)
            }
            if hasDeviceType {
                serialize_size += deviceType.computeStringSize(fieldNumber: 2)
            }
            for oneElementConstraint in constraint {
                serialize_size += oneElementConstraint.computeMessageSize(fieldNumber: 3)
            }
            var dataSizeHostMemoryArg:Int32 = 0
            for oneValuehostMemoryArg in hostMemoryArg {
                dataSizeHostMemoryArg += oneValuehostMemoryArg.computeStringSizeNoTag()
            }
            serialize_size += dataSizeHostMemoryArg
            serialize_size += 1 * Int32(hostMemoryArg.count)
            if hasLabel {
                serialize_size += label.computeStringSize(fieldNumber: 5)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.KernelDef.Builder {
            return Tensorflow.KernelDef.classBuilder() as! Tensorflow.KernelDef.Builder
        }
        public func getBuilder() -> Tensorflow.KernelDef.Builder {
            return classBuilder() as! Tensorflow.KernelDef.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.KernelDef.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.KernelDef.Builder()
        }
        public func toBuilder() throws -> Tensorflow.KernelDef.Builder {
            return try Tensorflow.KernelDef.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.KernelDef) throws -> Tensorflow.KernelDef.Builder {
            return try Tensorflow.KernelDef.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasOp {
                jsonMap["op"] = op
            }
            if hasDeviceType {
                jsonMap["deviceType"] = deviceType
            }
            if !constraint.isEmpty {
                var jsonArrayConstraint:Array<Dictionary<String,Any>> = []
                for oneValueConstraint in constraint {
                    let ecodedMessageConstraint = try oneValueConstraint.encode()
                    jsonArrayConstraint.append(ecodedMessageConstraint)
                }
                jsonMap["constraint"] = jsonArrayConstraint
            }
            if !hostMemoryArg.isEmpty {
                var jsonArrayHostMemoryArg:Array<String> = []
                for oneValueHostMemoryArg in hostMemoryArg {
                    jsonArrayHostMemoryArg.append(oneValueHostMemoryArg)
                }
                jsonMap["hostMemoryArg"] = jsonArrayHostMemoryArg
            }
            if hasLabel {
                jsonMap["label"] = label
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.KernelDef {
            return try Tensorflow.KernelDef.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.KernelDef {
            return try Tensorflow.KernelDef.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasOp {
                output += "\(indent) op: \(op) \n"
            }
            if hasDeviceType {
                output += "\(indent) deviceType: \(deviceType) \n"
            }
            var constraintElementIndex:Int = 0
            for oneElementConstraint in constraint {
                output += "\(indent) constraint[\(constraintElementIndex)] {\n"
                output += try oneElementConstraint.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                constraintElementIndex += 1
            }
            var hostMemoryArgElementIndex:Int = 0
            for oneValueHostMemoryArg in hostMemoryArg  {
                output += "\(indent) hostMemoryArg[\(hostMemoryArgElementIndex)]: \(oneValueHostMemoryArg)\n"
                hostMemoryArgElementIndex += 1
            }
            if hasLabel {
                output += "\(indent) label: \(label) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasOp {
                    hashCode = (hashCode &* 31) &+ op.hashValue
                }
                if hasDeviceType {
                    hashCode = (hashCode &* 31) &+ deviceType.hashValue
                }
                for oneElementConstraint in constraint {
                    hashCode = (hashCode &* 31) &+ oneElementConstraint.hashValue
                }
                for oneValueHostMemoryArg in hostMemoryArg {
                    hashCode = (hashCode &* 31) &+ oneValueHostMemoryArg.hashValue
                }
                if hasLabel {
                    hashCode = (hashCode &* 31) &+ label.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.KernelDef"
        }
        override public func className() -> String {
            return "Tensorflow.KernelDef"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.KernelDef = Tensorflow.KernelDef()
            public func getMessage() -> Tensorflow.KernelDef {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Must match the name of an Op.
            public var op:String {
                get {
                    return builderResult.op
                }
                set (value) {
                    builderResult.hasOp = true
                    builderResult.op = value
                }
            }
            public var hasOp:Bool {
                get {
                    return builderResult.hasOp
                }
            }
            @discardableResult
            public func setOp(_ value:String) -> Tensorflow.KernelDef.Builder {
                self.op = value
                return self
            }
            @discardableResult
            public func clearOp() -> Tensorflow.KernelDef.Builder{
                builderResult.hasOp = false
                builderResult.op = ""
                return self
            }
            /// Type of device this kernel runs on.
            public var deviceType:String {
                get {
                    return builderResult.deviceType
                }
                set (value) {
                    builderResult.hasDeviceType = true
                    builderResult.deviceType = value
                }
            }
            public var hasDeviceType:Bool {
                get {
                    return builderResult.hasDeviceType
                }
            }
            @discardableResult
            public func setDeviceType(_ value:String) -> Tensorflow.KernelDef.Builder {
                self.deviceType = value
                return self
            }
            @discardableResult
            public func clearDeviceType() -> Tensorflow.KernelDef.Builder{
                builderResult.hasDeviceType = false
                builderResult.deviceType = ""
                return self
            }
            public var constraint:Array<Tensorflow.KernelDef.AttrConstraint> {
                get {
                    return builderResult.constraint
                }
                set (value) {
                    builderResult.constraint = value
                }
            }
            @discardableResult
            public func setConstraint(_ value:Array<Tensorflow.KernelDef.AttrConstraint>) -> Tensorflow.KernelDef.Builder {
                self.constraint = value
                return self
            }
            @discardableResult
            public func clearConstraint() -> Tensorflow.KernelDef.Builder {
                builderResult.constraint.removeAll(keepingCapacity: false)
                return self
            }
            /// Names of the Op's input_/output_args that reside in host memory
            /// instead of device memory.
            public var hostMemoryArg:Array<String> {
                get {
                    return builderResult.hostMemoryArg
                }
                set (array) {
                    builderResult.hostMemoryArg = array
                }
            }
            @discardableResult
            public func setHostMemoryArg(_ value:Array<String>) -> Tensorflow.KernelDef.Builder {
                self.hostMemoryArg = value
                return self
            }
            @discardableResult
            public func clearHostMemoryArg() -> Tensorflow.KernelDef.Builder {
                builderResult.hostMemoryArg.removeAll(keepingCapacity: false)
                return self
            }
            /// This allows experimental kernels to be registered for an op that
            /// won't be used unless the user specifies a "_kernel" attr with
            /// value matching this.
            public var label:String {
                get {
                    return builderResult.label
                }
                set (value) {
                    builderResult.hasLabel = true
                    builderResult.label = value
                }
            }
            public var hasLabel:Bool {
                get {
                    return builderResult.hasLabel
                }
            }
            @discardableResult
            public func setLabel(_ value:String) -> Tensorflow.KernelDef.Builder {
                self.label = value
                return self
            }
            @discardableResult
            public func clearLabel() -> Tensorflow.KernelDef.Builder{
                builderResult.hasLabel = false
                builderResult.label = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.KernelDef.Builder {
                builderResult = Tensorflow.KernelDef()
                return self
            }
            override public func clone() throws -> Tensorflow.KernelDef.Builder {
                return try Tensorflow.KernelDef.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.KernelDef {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.KernelDef {
                let returnMe:Tensorflow.KernelDef = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.KernelDef) throws -> Tensorflow.KernelDef.Builder {
                if other == Tensorflow.KernelDef() {
                    return self
                }
                if other.hasOp {
                    op = other.op
                }
                if other.hasDeviceType {
                    deviceType = other.deviceType
                }
                if !other.constraint.isEmpty  {
                     builderResult.constraint += other.constraint
                }
                if !other.hostMemoryArg.isEmpty {
                    builderResult.hostMemoryArg += other.hostMemoryArg
                }
                if other.hasLabel {
                    label = other.label
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.KernelDef.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.KernelDef.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        op = try codedInputStream.readString()

                    case 18:
                        deviceType = try codedInputStream.readString()

                    case 26:
                        let subBuilder = Tensorflow.KernelDef.AttrConstraint.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        constraint.append(subBuilder.buildPartial())

                    case 34:
                        hostMemoryArg += [try codedInputStream.readString()]

                    case 42:
                        label = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.KernelDef.Builder {
                let resultDecodedBuilder = Tensorflow.KernelDef.Builder()
                if let jsonValueOp = jsonMap["op"] as? String {
                    resultDecodedBuilder.op = jsonValueOp
                }
                if let jsonValueDeviceType = jsonMap["deviceType"] as? String {
                    resultDecodedBuilder.deviceType = jsonValueDeviceType
                }
                if let jsonValueConstraint = jsonMap["constraint"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayConstraint:Array<Tensorflow.KernelDef.AttrConstraint> = []
                    for oneValueConstraint in jsonValueConstraint {
                        let messageFromStringConstraint = try Tensorflow.KernelDef.AttrConstraint.Builder.decodeToBuilder(jsonMap:oneValueConstraint).build()

                        jsonArrayConstraint.append(messageFromStringConstraint)
                    }
                    resultDecodedBuilder.constraint = jsonArrayConstraint
                }
                if let jsonValueHostMemoryArg = jsonMap["hostMemoryArg"] as? Array<String> {
                    var jsonArrayHostMemoryArg:Array<String> = []
                    for oneValueHostMemoryArg in jsonValueHostMemoryArg {
                        jsonArrayHostMemoryArg.append(oneValueHostMemoryArg)
                    }
                    resultDecodedBuilder.hostMemoryArg = jsonArrayHostMemoryArg
                }
                if let jsonValueLabel = jsonMap["label"] as? String {
                    resultDecodedBuilder.label = jsonValueLabel
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.KernelDef.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.KernelDef.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.KernelDef: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.KernelDef> {
        var mergedArray = Array<Tensorflow.KernelDef>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.KernelDef? {
        return try Tensorflow.KernelDef.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.KernelDef {
        return try Tensorflow.KernelDef.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.KernelDefRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.KernelDef {
        return try Tensorflow.KernelDef.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.KernelDef {
        return try Tensorflow.KernelDef.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.KernelDef {
        return try Tensorflow.KernelDef.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.KernelDef {
        return try Tensorflow.KernelDef.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.KernelDef {
        return try Tensorflow.KernelDef.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "op": return self.op
        case "deviceType": return self.deviceType
        case "constraint": return self.constraint
        case "hostMemoryArg": return self.hostMemoryArg
        case "label": return self.label
        default: return nil
        }
    }
}
extension Tensorflow.KernelDef.AttrConstraint: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.KernelDef.AttrConstraint> {
        var mergedArray = Array<Tensorflow.KernelDef.AttrConstraint>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.KernelDef.AttrConstraint? {
        return try Tensorflow.KernelDef.AttrConstraint.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.KernelDef.AttrConstraint {
        return try Tensorflow.KernelDef.AttrConstraint.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.KernelDefRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.KernelDef.AttrConstraint {
        return try Tensorflow.KernelDef.AttrConstraint.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.KernelDef.AttrConstraint {
        return try Tensorflow.KernelDef.AttrConstraint.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.KernelDef.AttrConstraint {
        return try Tensorflow.KernelDef.AttrConstraint.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.KernelDef.AttrConstraint {
        return try Tensorflow.KernelDef.AttrConstraint.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.KernelDef.AttrConstraint {
        return try Tensorflow.KernelDef.AttrConstraint.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "name": return self.name
        case "allowedValues": return self.allowedValues
        default: return nil
        }
    }
}
extension Tensorflow.KernelDef.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "op": return self.op
            case "deviceType": return self.deviceType
            case "constraint": return self.constraint
            case "hostMemoryArg": return self.hostMemoryArg
            case "label": return self.label
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "op":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.op = newSubscriptValue
            case "deviceType":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.deviceType = newSubscriptValue
            case "constraint":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.KernelDef.AttrConstraint> else {
                    return
                }
                self.constraint = newSubscriptValue
            case "hostMemoryArg":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.hostMemoryArg = newSubscriptValue
            case "label":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.label = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.KernelDef.AttrConstraint.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "name": return self.name
            case "allowedValues": return self.allowedValues
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "allowedValues":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.AttrValue else {
                    return
                }
                self.allowedValues = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

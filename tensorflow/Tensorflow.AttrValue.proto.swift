/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "attr_value.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { }

public extension Tensorflow {
    public struct AttrValueRoot {
        public static let `default` = AttrValueRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Tensorflow.TensorRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.TensorShapeRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.TypesRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    /// Protocol buffer representing the value for an attr used to configure an Op.
    /// Comment indicates the corresponding attr type.  Only the field matching the
    /// attr type may be filled.
    final public class AttrValue : GeneratedMessage {

        public static func == (lhs: Tensorflow.AttrValue, rhs: Tensorflow.AttrValue) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasList == rhs.hasList) && (!lhs.hasList || lhs.list == rhs.list)
            fieldCheck = fieldCheck && (lhs.hasS == rhs.hasS) && (!lhs.hasS || lhs.s == rhs.s)
            fieldCheck = fieldCheck && (lhs.hasI == rhs.hasI) && (!lhs.hasI || lhs.i == rhs.i)
            fieldCheck = fieldCheck && (lhs.hasF == rhs.hasF) && (!lhs.hasF || lhs.f == rhs.f)
            fieldCheck = fieldCheck && (lhs.hasB == rhs.hasB) && (!lhs.hasB || lhs.b == rhs.b)
            fieldCheck = fieldCheck && (lhs.hasType == rhs.hasType) && (!lhs.hasType || lhs.type == rhs.type)
            fieldCheck = fieldCheck && (lhs.hasShape == rhs.hasShape) && (!lhs.hasShape || lhs.shape == rhs.shape)
            fieldCheck = fieldCheck && (lhs.hasTensor == rhs.hasTensor) && (!lhs.hasTensor || lhs.tensor == rhs.tensor)
            fieldCheck = fieldCheck && (lhs.hasPlaceholder == rhs.hasPlaceholder) && (!lhs.hasPlaceholder || lhs.placeholder == rhs.placeholder)
            fieldCheck = fieldCheck && (lhs.hasFunc == rhs.hasFunc) && (!lhs.hasFunc || lhs.`func` == rhs.`func`)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        /// LINT.IfChange
        final public class ListValue : GeneratedMessage {

            public static func == (lhs: Tensorflow.AttrValue.ListValue, rhs: Tensorflow.AttrValue.ListValue) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.s == rhs.s)
                fieldCheck = fieldCheck && (lhs.i == rhs.i)
                fieldCheck = fieldCheck && (lhs.f == rhs.f)
                fieldCheck = fieldCheck && (lhs.b == rhs.b)
                fieldCheck = fieldCheck && (lhs.type == rhs.type)
                fieldCheck = fieldCheck && (lhs.shape == rhs.shape)
                fieldCheck = fieldCheck && (lhs.tensor == rhs.tensor)
                fieldCheck = fieldCheck && (lhs.`func` == rhs.`func`)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            /// "list(string)"
            public fileprivate(set) var s:Array<Data> = Array<Data>()
            /// "list(int)"
            public fileprivate(set) var i:Array<Int64> = Array<Int64>()
            private var iMemoizedSerializedSize:Int32 = -1
            /// "list(float)"
            public fileprivate(set) var f:Array<Float> = Array<Float>()
            private var fMemoizedSerializedSize:Int32 = -1
            /// "list(bool)"
            public fileprivate(set) var b:Array<Bool> = Array<Bool>()
            private var bMemoizedSerializedSize:Int32 = -1
            private var typeMemoizedSerializedSize:Int32 = 0
            public fileprivate(set) var type:Array<Tensorflow.DataType> = Array<Tensorflow.DataType>()
            public fileprivate(set) var shape:Array<Tensorflow.TensorShapeProto>  = Array<Tensorflow.TensorShapeProto>()
            public fileprivate(set) var tensor:Array<Tensorflow.TensorProto>  = Array<Tensorflow.TensorProto>()
            public fileprivate(set) var `func`:Array<Tensorflow.NameAttrList>  = Array<Tensorflow.NameAttrList>()
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if !s.isEmpty {
                    for oneValues in s {
                        try codedOutputStream.writeData(fieldNumber: 2, value:oneValues)
                    }
                }
                if !i.isEmpty {
                    try codedOutputStream.writeRawVarint32(value: 26)
                    try codedOutputStream.writeRawVarint32(value: iMemoizedSerializedSize)
                    for oneValuei in i {
                        try codedOutputStream.writeInt64NoTag(value: oneValuei)
                    }
                }
                if !f.isEmpty {
                    try codedOutputStream.writeRawVarint32(value: 34)
                    try codedOutputStream.writeRawVarint32(value: fMemoizedSerializedSize)
                    for oneValuef in f {
                        try codedOutputStream.writeFloatNoTag(value: oneValuef)
                    }
                }
                if !b.isEmpty {
                    try codedOutputStream.writeRawVarint32(value: 42)
                    try codedOutputStream.writeRawVarint32(value: bMemoizedSerializedSize)
                    for oneValueb in b {
                        try codedOutputStream.writeBoolNoTag(value: oneValueb)
                    }
                }
                if !type.isEmpty {
                    try codedOutputStream.writeRawVarint32(value: 50)
                    try codedOutputStream.writeRawVarint32(value: typeMemoizedSerializedSize)
                }
                for oneValueOftype in type {
                      try codedOutputStream.writeEnumNoTag(value: oneValueOftype.rawValue)
                }
                for oneElementShape in shape {
                      try codedOutputStream.writeMessage(fieldNumber: 7, value:oneElementShape)
                }
                for oneElementTensor in tensor {
                      try codedOutputStream.writeMessage(fieldNumber: 8, value:oneElementTensor)
                }
                for oneElementFunc in `func` {
                      try codedOutputStream.writeMessage(fieldNumber: 9, value:oneElementFunc)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                var dataSizeS:Int32 = 0
                for oneValues in s {
                    dataSizeS += oneValues.computeDataSizeNoTag()
                }
                serialize_size += dataSizeS
                serialize_size += 1 * Int32(s.count)
                var dataSizeI:Int32 = 0
                for oneValuei in i {
                    dataSizeI += oneValuei.computeInt64SizeNoTag()
                }
                serialize_size += dataSizeI
                if !i.isEmpty {
                    serialize_size += 1
                    serialize_size += dataSizeI.computeInt32SizeNoTag()
                }
                iMemoizedSerializedSize = dataSizeI
                var dataSizeF:Int32 = 0
                dataSizeF = 4 * Int32(f.count)
                serialize_size += dataSizeF
                if !f.isEmpty {
                    serialize_size += 1
                    serialize_size += dataSizeF.computeInt32SizeNoTag()
                }
                fMemoizedSerializedSize = dataSizeF
                var dataSizeB:Int32 = 0
                dataSizeB = 1 * Int32(b.count)
                serialize_size += dataSizeB
                if !b.isEmpty {
                    serialize_size += 1
                    serialize_size += dataSizeB.computeInt32SizeNoTag()
                }
                bMemoizedSerializedSize = dataSizeB
                var dataSizetype:Int32 = 0
                for oneValueOftype in type {
                    dataSizetype += oneValueOftype.rawValue.computeEnumSizeNoTag()
                }
                serialize_size += dataSizetype
                if !type.isEmpty {
                    serialize_size += 1
                    serialize_size += dataSizetype.computeRawVarint32Size()
                }
                typeMemoizedSerializedSize = dataSizetype
                for oneElementShape in shape {
                    serialize_size += oneElementShape.computeMessageSize(fieldNumber: 7)
                }
                for oneElementTensor in tensor {
                    serialize_size += oneElementTensor.computeMessageSize(fieldNumber: 8)
                }
                for oneElementFunc in `func` {
                    serialize_size += oneElementFunc.computeMessageSize(fieldNumber: 9)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.AttrValue.ListValue.Builder {
                return Tensorflow.AttrValue.ListValue.classBuilder() as! Tensorflow.AttrValue.ListValue.Builder
            }
            public func getBuilder() -> Tensorflow.AttrValue.ListValue.Builder {
                return classBuilder() as! Tensorflow.AttrValue.ListValue.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.AttrValue.ListValue.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.AttrValue.ListValue.Builder()
            }
            public func toBuilder() throws -> Tensorflow.AttrValue.ListValue.Builder {
                return try Tensorflow.AttrValue.ListValue.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.AttrValue.ListValue) throws -> Tensorflow.AttrValue.ListValue.Builder {
                return try Tensorflow.AttrValue.ListValue.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if !s.isEmpty {
                    var jsonArrayS:Array<String> = []
                    for oneValueS in s {
                        jsonArrayS.append(oneValueS.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0)))
                    }
                    jsonMap["s"] = jsonArrayS
                }
                if !i.isEmpty {
                    var jsonArrayI:Array<String> = []
                    for oneValueI in i {
                        jsonArrayI.append("\(oneValueI)")
                    }
                    jsonMap["i"] = jsonArrayI
                }
                if !f.isEmpty {
                    var jsonArrayF:Array<Float> = []
                    for oneValueF in f {
                        jsonArrayF.append(Float(oneValueF))
                    }
                    jsonMap["f"] = jsonArrayF
                }
                if !b.isEmpty {
                    var jsonArrayB:Array<Bool> = []
                    for oneValueB in b {
                        jsonArrayB.append(oneValueB)
                    }
                    jsonMap["b"] = jsonArrayB
                }
                if !type.isEmpty {
                    var jsonArrayType:Array<String> = []
                    for oneValueType in type {
                        jsonArrayType.append(oneValueType.toString())
                    }
                    jsonMap["type"] = jsonArrayType
                }
                if !shape.isEmpty {
                    var jsonArrayShape:Array<Dictionary<String,Any>> = []
                    for oneValueShape in shape {
                        let ecodedMessageShape = try oneValueShape.encode()
                        jsonArrayShape.append(ecodedMessageShape)
                    }
                    jsonMap["shape"] = jsonArrayShape
                }
                if !tensor.isEmpty {
                    var jsonArrayTensor:Array<Dictionary<String,Any>> = []
                    for oneValueTensor in tensor {
                        let ecodedMessageTensor = try oneValueTensor.encode()
                        jsonArrayTensor.append(ecodedMessageTensor)
                    }
                    jsonMap["tensor"] = jsonArrayTensor
                }
                if !`func`.isEmpty {
                    var jsonArrayFunc:Array<Dictionary<String,Any>> = []
                    for oneValueFunc in `func` {
                        let ecodedMessageFunc = try oneValueFunc.encode()
                        jsonArrayFunc.append(ecodedMessageFunc)
                    }
                    jsonMap["func"] = jsonArrayFunc
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.AttrValue.ListValue {
                return try Tensorflow.AttrValue.ListValue.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.AttrValue.ListValue {
                return try Tensorflow.AttrValue.ListValue.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                var sElementIndex:Int = 0
                for oneValueS in s  {
                    output += "\(indent) s[\(sElementIndex)]: \(oneValueS)\n"
                    sElementIndex += 1
                }
                var iElementIndex:Int = 0
                for oneValueI in i  {
                    output += "\(indent) i[\(iElementIndex)]: \(oneValueI)\n"
                    iElementIndex += 1
                }
                var fElementIndex:Int = 0
                for oneValueF in f  {
                    output += "\(indent) f[\(fElementIndex)]: \(oneValueF)\n"
                    fElementIndex += 1
                }
                var bElementIndex:Int = 0
                for oneValueB in b  {
                    output += "\(indent) b[\(bElementIndex)]: \(oneValueB)\n"
                    bElementIndex += 1
                }
                var typeElementIndex:Int = 0
                for oneValueOftype in type {
                    output += "\(indent) type[\(typeElementIndex)]: \(oneValueOftype.description)\n"
                    typeElementIndex += 1
                }
                var shapeElementIndex:Int = 0
                for oneElementShape in shape {
                    output += "\(indent) shape[\(shapeElementIndex)] {\n"
                    output += try oneElementShape.getDescription(indent: "\(indent)  ")
                    output += "\(indent)}\n"
                    shapeElementIndex += 1
                }
                var tensorElementIndex:Int = 0
                for oneElementTensor in tensor {
                    output += "\(indent) tensor[\(tensorElementIndex)] {\n"
                    output += try oneElementTensor.getDescription(indent: "\(indent)  ")
                    output += "\(indent)}\n"
                    tensorElementIndex += 1
                }
                var funcElementIndex:Int = 0
                for oneElementFunc in `func` {
                    output += "\(indent) func[\(funcElementIndex)] {\n"
                    output += try oneElementFunc.getDescription(indent: "\(indent)  ")
                    output += "\(indent)}\n"
                    funcElementIndex += 1
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    for oneValueS in s {
                        hashCode = (hashCode &* 31) &+ oneValueS.hashValue
                    }
                    for oneValueI in i {
                        hashCode = (hashCode &* 31) &+ oneValueI.hashValue
                    }
                    for oneValueF in f {
                        hashCode = (hashCode &* 31) &+ oneValueF.hashValue
                    }
                    for oneValueB in b {
                        hashCode = (hashCode &* 31) &+ oneValueB.hashValue
                    }
                    for oneValueOftype in type {
                        hashCode = (hashCode &* 31) &+ oneValueOftype.hashValue
                    }
                    for oneElementShape in shape {
                        hashCode = (hashCode &* 31) &+ oneElementShape.hashValue
                    }
                    for oneElementTensor in tensor {
                        hashCode = (hashCode &* 31) &+ oneElementTensor.hashValue
                    }
                    for oneElementFunc in `func` {
                        hashCode = (hashCode &* 31) &+ oneElementFunc.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.AttrValue.ListValue"
            }
            override public func className() -> String {
                return "Tensorflow.AttrValue.ListValue"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.AttrValue.ListValue = Tensorflow.AttrValue.ListValue()
                public func getMessage() -> Tensorflow.AttrValue.ListValue {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                /// "list(string)"
                public var s:Array<Data> {
                    get {
                        return builderResult.s
                    }
                    set (array) {
                        builderResult.s = array
                    }
                }
                @discardableResult
                public func setS(_ value:Array<Data>) -> Tensorflow.AttrValue.ListValue.Builder {
                    self.s = value
                    return self
                }
                @discardableResult
                public func clearS() -> Tensorflow.AttrValue.ListValue.Builder {
                    builderResult.s.removeAll(keepingCapacity: false)
                    return self
                }
                /// "list(int)"
                public var i:Array<Int64> {
                    get {
                        return builderResult.i
                    }
                    set (array) {
                        builderResult.i = array
                    }
                }
                @discardableResult
                public func setI(_ value:Array<Int64>) -> Tensorflow.AttrValue.ListValue.Builder {
                    self.i = value
                    return self
                }
                @discardableResult
                public func clearI() -> Tensorflow.AttrValue.ListValue.Builder {
                    builderResult.i.removeAll(keepingCapacity: false)
                    return self
                }
                /// "list(float)"
                public var f:Array<Float> {
                    get {
                        return builderResult.f
                    }
                    set (array) {
                        builderResult.f = array
                    }
                }
                @discardableResult
                public func setF(_ value:Array<Float>) -> Tensorflow.AttrValue.ListValue.Builder {
                    self.f = value
                    return self
                }
                @discardableResult
                public func clearF() -> Tensorflow.AttrValue.ListValue.Builder {
                    builderResult.f.removeAll(keepingCapacity: false)
                    return self
                }
                /// "list(bool)"
                public var b:Array<Bool> {
                    get {
                        return builderResult.b
                    }
                    set (array) {
                        builderResult.b = array
                    }
                }
                @discardableResult
                public func setB(_ value:Array<Bool>) -> Tensorflow.AttrValue.ListValue.Builder {
                    self.b = value
                    return self
                }
                @discardableResult
                public func clearB() -> Tensorflow.AttrValue.ListValue.Builder {
                    builderResult.b.removeAll(keepingCapacity: false)
                    return self
                }
                /// "list(type)"
                public var type:Array<Tensorflow.DataType> {
                    get {
                        return builderResult.type
                    }
                    set (value) {
                        builderResult.type = value
                    }
                }
                @discardableResult
                public func setType(_ value:Array<Tensorflow.DataType>) -> Tensorflow.AttrValue.ListValue.Builder {
                    self.type = value
                    return self
                }
                @discardableResult
                public func clearType() -> Tensorflow.AttrValue.ListValue.Builder {
                    builderResult.type.removeAll(keepingCapacity: false)
                    return self
                }
                /// "list(shape)"
                public var shape:Array<Tensorflow.TensorShapeProto> {
                    get {
                        return builderResult.shape
                    }
                    set (value) {
                        builderResult.shape = value
                    }
                }
                @discardableResult
                public func setShape(_ value:Array<Tensorflow.TensorShapeProto>) -> Tensorflow.AttrValue.ListValue.Builder {
                    self.shape = value
                    return self
                }
                @discardableResult
                public func clearShape() -> Tensorflow.AttrValue.ListValue.Builder {
                    builderResult.shape.removeAll(keepingCapacity: false)
                    return self
                }
                /// "list(tensor)"
                public var tensor:Array<Tensorflow.TensorProto> {
                    get {
                        return builderResult.tensor
                    }
                    set (value) {
                        builderResult.tensor = value
                    }
                }
                @discardableResult
                public func setTensor(_ value:Array<Tensorflow.TensorProto>) -> Tensorflow.AttrValue.ListValue.Builder {
                    self.tensor = value
                    return self
                }
                @discardableResult
                public func clearTensor() -> Tensorflow.AttrValue.ListValue.Builder {
                    builderResult.tensor.removeAll(keepingCapacity: false)
                    return self
                }
                /// "list(attr)"
                public var `func`:Array<Tensorflow.NameAttrList> {
                    get {
                        return builderResult.`func`
                    }
                    set (value) {
                        builderResult.`func` = value
                    }
                }
                @discardableResult
                public func setFunc(_ value:Array<Tensorflow.NameAttrList>) -> Tensorflow.AttrValue.ListValue.Builder {
                    self.`func` = value
                    return self
                }
                @discardableResult
                public func clearFunc() -> Tensorflow.AttrValue.ListValue.Builder {
                    builderResult.`func`.removeAll(keepingCapacity: false)
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.AttrValue.ListValue.Builder {
                    builderResult = Tensorflow.AttrValue.ListValue()
                    return self
                }
                override public func clone() throws -> Tensorflow.AttrValue.ListValue.Builder {
                    return try Tensorflow.AttrValue.ListValue.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.AttrValue.ListValue {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.AttrValue.ListValue {
                    let returnMe:Tensorflow.AttrValue.ListValue = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.AttrValue.ListValue) throws -> Tensorflow.AttrValue.ListValue.Builder {
                    if other == Tensorflow.AttrValue.ListValue() {
                        return self
                    }
                    if !other.s.isEmpty {
                        builderResult.s += other.s
                    }
                    if !other.i.isEmpty {
                        builderResult.i += other.i
                    }
                    if !other.f.isEmpty {
                        builderResult.f += other.f
                    }
                    if !other.b.isEmpty {
                        builderResult.b += other.b
                    }
                    if !other.type.isEmpty {
                         builderResult.type += other.type
                    }
                    if !other.shape.isEmpty  {
                         builderResult.shape += other.shape
                    }
                    if !other.tensor.isEmpty  {
                         builderResult.tensor += other.tensor
                    }
                    if !other.`func`.isEmpty  {
                         builderResult.`func` += other.`func`
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.AttrValue.ListValue.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.AttrValue.ListValue.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 18:
                            s += [try codedInputStream.readData()]

                        case 26:
                            let length = Int(try codedInputStream.readRawVarint32())
                            let limit = try codedInputStream.pushLimit(byteLimit: length)
                            while (codedInputStream.bytesUntilLimit() > 0) {
                                builderResult.i.append(try codedInputStream.readInt64())
                            }
                            codedInputStream.popLimit(oldLimit: limit)

                        case 34:
                            let length = Int(try codedInputStream.readRawVarint32())
                            let limit = try codedInputStream.pushLimit(byteLimit: length)
                            while (codedInputStream.bytesUntilLimit() > 0) {
                                builderResult.f.append(try codedInputStream.readFloat())
                            }
                            codedInputStream.popLimit(oldLimit: limit)

                        case 42:
                            let length = Int(try codedInputStream.readRawVarint32())
                            let limit = try codedInputStream.pushLimit(byteLimit: length)
                            while (codedInputStream.bytesUntilLimit() > 0) {
                                builderResult.b.append(try codedInputStream.readBool())
                            }
                            codedInputStream.popLimit(oldLimit: limit)

                        case 50:
                            let length = Int(try codedInputStream.readRawVarint32())
                            let oldLimit = try codedInputStream.pushLimit(byteLimit: length)
                            while codedInputStream.bytesUntilLimit() > 0 {
                            let valueInttype = try codedInputStream.readEnum()
                            if let enumstype = Tensorflow.DataType(rawValue:valueInttype) {
                                builderResult.type.append(enumstype)
                            } else {
                                try unknownFieldsBuilder.mergeVarintField(fieldNumber: 6, value:Int64(valueInttype))
                            }
                            }
                            codedInputStream.popLimit(oldLimit: oldLimit)

                        case 58:
                            let subBuilder = Tensorflow.TensorShapeProto.Builder()
                            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                            shape.append(subBuilder.buildPartial())

                        case 66:
                            let subBuilder = Tensorflow.TensorProto.Builder()
                            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                            tensor.append(subBuilder.buildPartial())

                        case 74:
                            let subBuilder = Tensorflow.NameAttrList.Builder()
                            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                            `func`.append(subBuilder.buildPartial())

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.AttrValue.ListValue.Builder {
                    let resultDecodedBuilder = Tensorflow.AttrValue.ListValue.Builder()
                    if let jsonValueS = jsonMap["s"] as? Array<String> {
                        var jsonArrayS:Array<Data> = []
                        for oneValueS in jsonValueS {
                            jsonArrayS.append(Data(base64Encoded:oneValueS, options: Data.Base64DecodingOptions(rawValue:0))!)
                        }
                        resultDecodedBuilder.s = jsonArrayS
                    }
                    if let jsonValueI = jsonMap["i"] as? Array<String> {
                        var jsonArrayI:Array<Int64> = []
                        for oneValueI in jsonValueI {
                            jsonArrayI.append(Int64(oneValueI)!)
                        }
                        resultDecodedBuilder.i = jsonArrayI
                    }
                    if let jsonValueF = jsonMap["f"] as? Array<Float> {
                        var jsonArrayF:Array<Float> = []
                        for oneValueF in jsonValueF {
                            jsonArrayF.append(Float(oneValueF))
                        }
                        resultDecodedBuilder.f = jsonArrayF
                    }
                    if let jsonValueB = jsonMap["b"] as? Array<Bool> {
                        var jsonArrayB:Array<Bool> = []
                        for oneValueB in jsonValueB {
                            jsonArrayB.append(oneValueB)
                        }
                        resultDecodedBuilder.b = jsonArrayB
                    }
                    if let jsonValueType = jsonMap["type"] as? Array<String> {
                        var jsonArrayType:Array<Tensorflow.DataType> = []
                        for oneValueType in jsonValueType {
                            let enumFromStringType = try Tensorflow.DataType.fromString(str: oneValueType)
                            jsonArrayType.append(enumFromStringType)
                        }
                        resultDecodedBuilder.type = jsonArrayType
                    }
                    if let jsonValueShape = jsonMap["shape"] as? Array<Dictionary<String,Any>> {
                        var jsonArrayShape:Array<Tensorflow.TensorShapeProto> = []
                        for oneValueShape in jsonValueShape {
                            let messageFromStringShape = try Tensorflow.TensorShapeProto.Builder.decodeToBuilder(jsonMap:oneValueShape).build()

                            jsonArrayShape.append(messageFromStringShape)
                        }
                        resultDecodedBuilder.shape = jsonArrayShape
                    }
                    if let jsonValueTensor = jsonMap["tensor"] as? Array<Dictionary<String,Any>> {
                        var jsonArrayTensor:Array<Tensorflow.TensorProto> = []
                        for oneValueTensor in jsonValueTensor {
                            let messageFromStringTensor = try Tensorflow.TensorProto.Builder.decodeToBuilder(jsonMap:oneValueTensor).build()

                            jsonArrayTensor.append(messageFromStringTensor)
                        }
                        resultDecodedBuilder.tensor = jsonArrayTensor
                    }
                    if let jsonValueFunc = jsonMap["func"] as? Array<Dictionary<String,Any>> {
                        var jsonArrayFunc:Array<Tensorflow.NameAttrList> = []
                        for oneValueFunc in jsonValueFunc {
                            let messageFromStringFunc = try Tensorflow.NameAttrList.Builder.decodeToBuilder(jsonMap:oneValueFunc).build()

                            jsonArrayFunc.append(messageFromStringFunc)
                        }
                        resultDecodedBuilder.`func` = jsonArrayFunc
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.AttrValue.ListValue.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.AttrValue.ListValue.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //OneOf declaration start

        public enum Value {
            case OneOfValueNotSet

            public func checkOneOfIsSet() -> Bool {
                switch self {
                case .OneOfValueNotSet: return false
                default: return true
                }
            }
            case S(Data)

            public static func getS(_ value:Value) -> Data? {
                switch value {
                case .S(let enumValue): return enumValue
                default: return nil
                }
            }
            case I(Int64)

            public static func getI(_ value:Value) -> Int64? {
                switch value {
                case .I(let enumValue): return enumValue
                default: return nil
                }
            }
            case F(Float)

            public static func getF(_ value:Value) -> Float? {
                switch value {
                case .F(let enumValue): return enumValue
                default: return nil
                }
            }
            case B(Bool)

            public static func getB(_ value:Value) -> Bool? {
                switch value {
                case .B(let enumValue): return enumValue
                default: return nil
                }
            }
            case Type(Tensorflow.DataType)

            public static func get`Type`(_ value:Value) -> Tensorflow.DataType? {
                switch value {
                case .`Type`(let enumValue): return enumValue
                default: return nil
                }
            }
            case Shape(Tensorflow.TensorShapeProto)

            public static func getShape(_ value:Value) -> Tensorflow.TensorShapeProto? {
                switch value {
                case .Shape(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case Tensor(Tensorflow.TensorProto)

            public static func getTensor(_ value:Value) -> Tensorflow.TensorProto? {
                switch value {
                case .Tensor(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case List(Tensorflow.AttrValue.ListValue)

            public static func getList(_ value:Value) -> Tensorflow.AttrValue.ListValue? {
                switch value {
                case .List(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case Func(Tensorflow.NameAttrList)

            public static func getFunc(_ value:Value) -> Tensorflow.NameAttrList? {
                switch value {
                case .Func(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case Placeholder(String)

            public static func getPlaceholder(_ value:Value) -> String? {
                switch value {
                case .Placeholder(let enumValue): return enumValue
                default: return nil
                }
            }
        }
        //OneOf declaration end

        fileprivate var storageValue:AttrValue.Value =  AttrValue.Value.OneOfValueNotSet
        public func getOneOfValue() ->  AttrValue.Value {
            let copyObjectValue = storageValue
            return copyObjectValue
        }
        /// "string"
        public fileprivate(set) var s:Data!{
            get {
                return AttrValue.Value.getS(storageValue)
            }
            set (newvalue) {
                storageValue = AttrValue.Value.S(newvalue)
            }
        }
        public fileprivate(set) var hasS:Bool {
            get {
                guard let _ = AttrValue.Value.getS(storageValue) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        /// "int"
        public fileprivate(set) var i:Int64!{
            get {
                return AttrValue.Value.getI(storageValue)
            }
            set (newvalue) {
                storageValue = AttrValue.Value.I(newvalue)
            }
        }
        public fileprivate(set) var hasI:Bool {
            get {
                guard let _ = AttrValue.Value.getI(storageValue) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        /// "float"
        public fileprivate(set) var f:Float!{
            get {
                return AttrValue.Value.getF(storageValue)
            }
            set (newvalue) {
                storageValue = AttrValue.Value.F(newvalue)
            }
        }
        public fileprivate(set) var hasF:Bool {
            get {
                guard let _ = AttrValue.Value.getF(storageValue) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        /// "bool"
        public fileprivate(set) var b:Bool!{
            get {
                return AttrValue.Value.getB(storageValue)
            }
            set (newvalue) {
                storageValue = AttrValue.Value.B(newvalue)
            }
        }
        public fileprivate(set) var hasB:Bool {
            get {
                guard let _ = AttrValue.Value.getB(storageValue) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var type:Tensorflow.DataType!{
            get {
                return AttrValue.Value.getType(storageValue)
            }
            set (newvalue) {
                storageValue = AttrValue.Value.Type(newvalue)
            }
        }
        public fileprivate(set) var hasType:Bool {
            get {
                guard let _ = AttrValue.Value.getType(storageValue) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var shape:Tensorflow.TensorShapeProto!{
            get {
                return AttrValue.Value.getShape(storageValue)
            }
            set (newvalue) {
                storageValue = AttrValue.Value.Shape(newvalue)
            }
        }
        public fileprivate(set) var hasShape:Bool {
            get {
                guard let _ = AttrValue.Value.getShape(storageValue) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var tensor:Tensorflow.TensorProto!{
            get {
                return AttrValue.Value.getTensor(storageValue)
            }
            set (newvalue) {
                storageValue = AttrValue.Value.Tensor(newvalue)
            }
        }
        public fileprivate(set) var hasTensor:Bool {
            get {
                guard let _ = AttrValue.Value.getTensor(storageValue) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var list:Tensorflow.AttrValue.ListValue!{
            get {
                return AttrValue.Value.getList(storageValue)
            }
            set (newvalue) {
                storageValue = AttrValue.Value.List(newvalue)
            }
        }
        public fileprivate(set) var hasList:Bool {
            get {
                guard let _ = AttrValue.Value.getList(storageValue) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var `func`:Tensorflow.NameAttrList!{
            get {
                return AttrValue.Value.getFunc(storageValue)
            }
            set (newvalue) {
                storageValue = AttrValue.Value.Func(newvalue)
            }
        }
        public fileprivate(set) var hasFunc:Bool {
            get {
                guard let _ = AttrValue.Value.getFunc(storageValue) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        /// This is a placeholder only used in nodes defined inside a
        /// function.  It indicates the attr value will be supplied when
        /// the function is instantiated.  For example, let us suppose a
        /// node "N" in function "FN". "N" has an attr "A" with value
        /// placeholder = "foo". When FN is instantiated with attr "foo"
        /// set to "bar", the instantiated node N's attr A will have been
        /// given the value "bar".
        public fileprivate(set) var placeholder:String!{
            get {
                return AttrValue.Value.getPlaceholder(storageValue)
            }
            set (newvalue) {
                storageValue = AttrValue.Value.Placeholder(newvalue)
            }
        }
        public fileprivate(set) var hasPlaceholder:Bool {
            get {
                guard let _ = AttrValue.Value.getPlaceholder(storageValue) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasList {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:list)
            }
            if hasS {
                try codedOutputStream.writeData(fieldNumber: 2, value:s)
            }
            if hasI {
                try codedOutputStream.writeInt64(fieldNumber: 3, value:i)
            }
            if hasF {
                try codedOutputStream.writeFloat(fieldNumber: 4, value:f)
            }
            if hasB {
                try codedOutputStream.writeBool(fieldNumber: 5, value:b)
            }
            if hasType {
                try codedOutputStream.writeEnum(fieldNumber: 6, value:type.rawValue)
            }
            if hasShape {
                try codedOutputStream.writeMessage(fieldNumber: 7, value:shape)
            }
            if hasTensor {
                try codedOutputStream.writeMessage(fieldNumber: 8, value:tensor)
            }
            if hasPlaceholder {
                try codedOutputStream.writeString(fieldNumber: 9, value:placeholder)
            }
            if hasFunc {
                try codedOutputStream.writeMessage(fieldNumber: 10, value:`func`)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasList {
                if let varSizelist = list?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizelist
                }
            }
            if hasS {
                serialize_size += s.computeDataSize(fieldNumber: 2)
            }
            if hasI {
                serialize_size += i.computeInt64Size(fieldNumber: 3)
            }
            if hasF {
                serialize_size += f.computeFloatSize(fieldNumber: 4)
            }
            if hasB {
                serialize_size += b.computeBoolSize(fieldNumber: 5)
            }
            if (hasType) {
                serialize_size += type.rawValue.computeEnumSize(fieldNumber: 6)
            }
            if hasShape {
                if let varSizeshape = shape?.computeMessageSize(fieldNumber: 7) {
                    serialize_size += varSizeshape
                }
            }
            if hasTensor {
                if let varSizetensor = tensor?.computeMessageSize(fieldNumber: 8) {
                    serialize_size += varSizetensor
                }
            }
            if hasPlaceholder {
                serialize_size += placeholder.computeStringSize(fieldNumber: 9)
            }
            if hasFunc {
                if let varSizefunc = `func`?.computeMessageSize(fieldNumber: 10) {
                    serialize_size += varSizefunc
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.AttrValue.Builder {
            return Tensorflow.AttrValue.classBuilder() as! Tensorflow.AttrValue.Builder
        }
        public func getBuilder() -> Tensorflow.AttrValue.Builder {
            return classBuilder() as! Tensorflow.AttrValue.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.AttrValue.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.AttrValue.Builder()
        }
        public func toBuilder() throws -> Tensorflow.AttrValue.Builder {
            return try Tensorflow.AttrValue.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.AttrValue) throws -> Tensorflow.AttrValue.Builder {
            return try Tensorflow.AttrValue.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasS {
                jsonMap["s"] = s.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            if hasI {
                jsonMap["i"] = "\(i)"
            }
            if hasF {
                jsonMap["f"] = Float(f)
            }
            if hasB {
                jsonMap["b"] = b
            }
            if hasType {
                jsonMap["type"] = type.toString()
            }
            if hasShape {
                jsonMap["shape"] = try shape.encode()
            }
            if hasTensor {
                jsonMap["tensor"] = try tensor.encode()
            }
            if hasList {
                jsonMap["list"] = try list.encode()
            }
            if hasFunc {
                jsonMap["func"] = try `func`.encode()
            }
            if hasPlaceholder {
                jsonMap["placeholder"] = placeholder
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.AttrValue {
            return try Tensorflow.AttrValue.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.AttrValue {
            return try Tensorflow.AttrValue.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasList {
                output += "\(indent) list {\n"
                if let outDescList = list {
                    output += try outDescList.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasS {
                output += "\(indent) s: \(s) \n"
            }
            if hasI {
                output += "\(indent) i: \(i) \n"
            }
            if hasF {
                output += "\(indent) f: \(f) \n"
            }
            if hasB {
                output += "\(indent) b: \(b) \n"
            }
            if (hasType) {
                output += "\(indent) type: \(type.description)\n"
            }
            if hasShape {
                output += "\(indent) shape {\n"
                if let outDescShape = shape {
                    output += try outDescShape.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasTensor {
                output += "\(indent) tensor {\n"
                if let outDescTensor = tensor {
                    output += try outDescTensor.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasPlaceholder {
                output += "\(indent) placeholder: \(placeholder) \n"
            }
            if hasFunc {
                output += "\(indent) func {\n"
                if let outDescFunc = `func` {
                    output += try outDescFunc.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasList {
                    if let hashValuelist = list?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuelist
                    }
                }
                if hasS {
                    hashCode = (hashCode &* 31) &+ s.hashValue
                }
                if hasI {
                    hashCode = (hashCode &* 31) &+ i.hashValue
                }
                if hasF {
                    hashCode = (hashCode &* 31) &+ f.hashValue
                }
                if hasB {
                    hashCode = (hashCode &* 31) &+ b.hashValue
                }
                if hasType {
                     hashCode = (hashCode &* 31) &+ type.hashValue
                }
                if hasShape {
                    if let hashValueshape = shape?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueshape
                    }
                }
                if hasTensor {
                    if let hashValuetensor = tensor?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuetensor
                    }
                }
                if hasPlaceholder {
                    hashCode = (hashCode &* 31) &+ placeholder.hashValue
                }
                if hasFunc {
                    if let hashValuefunc = `func`?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuefunc
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.AttrValue"
        }
        override public func className() -> String {
            return "Tensorflow.AttrValue"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.AttrValue = Tensorflow.AttrValue()
            public func getMessage() -> Tensorflow.AttrValue {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// "string"
            public var s:Data {
                get {
                    return builderResult.s
                }
                set (value) {
                    builderResult.hasS = true
                    builderResult.s = value
                }
            }
            public var hasS:Bool {
                get {
                    return builderResult.hasS
                }
            }
            @discardableResult
            public func setS(_ value:Data) -> Tensorflow.AttrValue.Builder {
                self.s = value
                return self
            }
            @discardableResult
            public func clearS() -> Tensorflow.AttrValue.Builder{
                builderResult.hasS = false
                builderResult.s = Data()
                return self
            }
            /// "int"
            public var i:Int64 {
                get {
                    return builderResult.i
                }
                set (value) {
                    builderResult.hasI = true
                    builderResult.i = value
                }
            }
            public var hasI:Bool {
                get {
                    return builderResult.hasI
                }
            }
            @discardableResult
            public func setI(_ value:Int64) -> Tensorflow.AttrValue.Builder {
                self.i = value
                return self
            }
            @discardableResult
            public func clearI() -> Tensorflow.AttrValue.Builder{
                builderResult.hasI = false
                builderResult.i = Int64(0)
                return self
            }
            /// "float"
            public var f:Float {
                get {
                    return builderResult.f
                }
                set (value) {
                    builderResult.hasF = true
                    builderResult.f = value
                }
            }
            public var hasF:Bool {
                get {
                    return builderResult.hasF
                }
            }
            @discardableResult
            public func setF(_ value:Float) -> Tensorflow.AttrValue.Builder {
                self.f = value
                return self
            }
            @discardableResult
            public func clearF() -> Tensorflow.AttrValue.Builder{
                builderResult.hasF = false
                builderResult.f = Float(0)
                return self
            }
            /// "bool"
            public var b:Bool {
                get {
                    return builderResult.b
                }
                set (value) {
                    builderResult.hasB = true
                    builderResult.b = value
                }
            }
            public var hasB:Bool {
                get {
                    return builderResult.hasB
                }
            }
            @discardableResult
            public func setB(_ value:Bool) -> Tensorflow.AttrValue.Builder {
                self.b = value
                return self
            }
            @discardableResult
            public func clearB() -> Tensorflow.AttrValue.Builder{
                builderResult.hasB = false
                builderResult.b = false
                return self
            }
            /// "type"
                public var type:Tensorflow.DataType {
                    get {
                        return builderResult.type
                    }
                    set (value) {
                        builderResult.hasType = true
                        builderResult.type = value
                    }
                }
                public var hasType:Bool{
                    get {
                        return builderResult.hasType
                    }
                }
            @discardableResult
                public func setType(_ value:Tensorflow.DataType) -> Tensorflow.AttrValue.Builder {
                  self.type = value
                  return self
                }
            @discardableResult
                public func clearType() -> Tensorflow.AttrValue.Builder {
                   builderResult.hasType = false
                   builderResult.type = .dtInvalid
                   return self
                }
            /// "shape"
            public var shape:Tensorflow.TensorShapeProto! {
                get {
                    if shapeBuilder_ != nil {
                        builderResult.shape = shapeBuilder_.getMessage()
                    }
                    return builderResult.shape
                }
                set (value) {
                    builderResult.hasShape = true
                    builderResult.shape = value
                }
            }
            public var hasShape:Bool {
                get {
                    return builderResult.hasShape
                }
            }
            fileprivate var shapeBuilder_:Tensorflow.TensorShapeProto.Builder! {
                didSet {
                    builderResult.hasShape = true
                }
            }
            public func getShapeBuilder() -> Tensorflow.TensorShapeProto.Builder {
                if shapeBuilder_ == nil {
                    shapeBuilder_ = Tensorflow.TensorShapeProto.Builder()
                    builderResult.shape = shapeBuilder_.getMessage()
                    if shape != nil {
                        try! shapeBuilder_.mergeFrom(other: shape)
                    }
                }
                return shapeBuilder_
            }
            @discardableResult
            public func setShape(_ value:Tensorflow.TensorShapeProto!) -> Tensorflow.AttrValue.Builder {
                self.shape = value
                return self
            }
            @discardableResult
            public func mergeShape(value:Tensorflow.TensorShapeProto) throws -> Tensorflow.AttrValue.Builder {
                if builderResult.hasShape {
                    builderResult.shape = try Tensorflow.TensorShapeProto.builderWithPrototype(prototype:builderResult.shape).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.shape = value
                }
                builderResult.hasShape = true
                return self
            }
            @discardableResult
            public func clearShape() -> Tensorflow.AttrValue.Builder {
                shapeBuilder_ = nil
                builderResult.hasShape = false
                builderResult.shape = nil
                return self
            }
            /// "tensor"
            public var tensor:Tensorflow.TensorProto! {
                get {
                    if tensorBuilder_ != nil {
                        builderResult.tensor = tensorBuilder_.getMessage()
                    }
                    return builderResult.tensor
                }
                set (value) {
                    builderResult.hasTensor = true
                    builderResult.tensor = value
                }
            }
            public var hasTensor:Bool {
                get {
                    return builderResult.hasTensor
                }
            }
            fileprivate var tensorBuilder_:Tensorflow.TensorProto.Builder! {
                didSet {
                    builderResult.hasTensor = true
                }
            }
            public func getTensorBuilder() -> Tensorflow.TensorProto.Builder {
                if tensorBuilder_ == nil {
                    tensorBuilder_ = Tensorflow.TensorProto.Builder()
                    builderResult.tensor = tensorBuilder_.getMessage()
                    if tensor != nil {
                        try! tensorBuilder_.mergeFrom(other: tensor)
                    }
                }
                return tensorBuilder_
            }
            @discardableResult
            public func setTensor(_ value:Tensorflow.TensorProto!) -> Tensorflow.AttrValue.Builder {
                self.tensor = value
                return self
            }
            @discardableResult
            public func mergeTensor(value:Tensorflow.TensorProto) throws -> Tensorflow.AttrValue.Builder {
                if builderResult.hasTensor {
                    builderResult.tensor = try Tensorflow.TensorProto.builderWithPrototype(prototype:builderResult.tensor).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.tensor = value
                }
                builderResult.hasTensor = true
                return self
            }
            @discardableResult
            public func clearTensor() -> Tensorflow.AttrValue.Builder {
                tensorBuilder_ = nil
                builderResult.hasTensor = false
                builderResult.tensor = nil
                return self
            }
            /// any "list(...)"
            public var list:Tensorflow.AttrValue.ListValue! {
                get {
                    if listBuilder_ != nil {
                        builderResult.list = listBuilder_.getMessage()
                    }
                    return builderResult.list
                }
                set (value) {
                    builderResult.hasList = true
                    builderResult.list = value
                }
            }
            public var hasList:Bool {
                get {
                    return builderResult.hasList
                }
            }
            fileprivate var listBuilder_:Tensorflow.AttrValue.ListValue.Builder! {
                didSet {
                    builderResult.hasList = true
                }
            }
            public func getListBuilder() -> Tensorflow.AttrValue.ListValue.Builder {
                if listBuilder_ == nil {
                    listBuilder_ = Tensorflow.AttrValue.ListValue.Builder()
                    builderResult.list = listBuilder_.getMessage()
                    if list != nil {
                        try! listBuilder_.mergeFrom(other: list)
                    }
                }
                return listBuilder_
            }
            @discardableResult
            public func setList(_ value:Tensorflow.AttrValue.ListValue!) -> Tensorflow.AttrValue.Builder {
                self.list = value
                return self
            }
            @discardableResult
            public func mergeList(value:Tensorflow.AttrValue.ListValue) throws -> Tensorflow.AttrValue.Builder {
                if builderResult.hasList {
                    builderResult.list = try Tensorflow.AttrValue.ListValue.builderWithPrototype(prototype:builderResult.list).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.list = value
                }
                builderResult.hasList = true
                return self
            }
            @discardableResult
            public func clearList() -> Tensorflow.AttrValue.Builder {
                listBuilder_ = nil
                builderResult.hasList = false
                builderResult.list = nil
                return self
            }
            /// "func" represents a function. func.name is a function's name or
            /// a primitive op's name. func.attr.first is the name of an attr
            /// defined for that function. func.attr.second is the value for
            /// that attr in the instantiation.
            public var `func`:Tensorflow.NameAttrList! {
                get {
                    if funcBuilder_ != nil {
                        builderResult.`func` = funcBuilder_.getMessage()
                    }
                    return builderResult.`func`
                }
                set (value) {
                    builderResult.hasFunc = true
                    builderResult.`func` = value
                }
            }
            public var hasFunc:Bool {
                get {
                    return builderResult.hasFunc
                }
            }
            fileprivate var funcBuilder_:Tensorflow.NameAttrList.Builder! {
                didSet {
                    builderResult.hasFunc = true
                }
            }
            public func getFuncBuilder() -> Tensorflow.NameAttrList.Builder {
                if funcBuilder_ == nil {
                    funcBuilder_ = Tensorflow.NameAttrList.Builder()
                    builderResult.`func` = funcBuilder_.getMessage()
                    if `func` != nil {
                        try! funcBuilder_.mergeFrom(other: `func`)
                    }
                }
                return funcBuilder_
            }
            @discardableResult
            public func setFunc(_ value:Tensorflow.NameAttrList!) -> Tensorflow.AttrValue.Builder {
                self.`func` = value
                return self
            }
            @discardableResult
            public func mergeFunc(value:Tensorflow.NameAttrList) throws -> Tensorflow.AttrValue.Builder {
                if builderResult.hasFunc {
                    builderResult.`func` = try Tensorflow.NameAttrList.builderWithPrototype(prototype:builderResult.`func`).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.`func` = value
                }
                builderResult.hasFunc = true
                return self
            }
            @discardableResult
            public func clearFunc() -> Tensorflow.AttrValue.Builder {
                funcBuilder_ = nil
                builderResult.hasFunc = false
                builderResult.`func` = nil
                return self
            }
            /// This is a placeholder only used in nodes defined inside a
            /// function.  It indicates the attr value will be supplied when
            /// the function is instantiated.  For example, let us suppose a
            /// node "N" in function "FN". "N" has an attr "A" with value
            /// placeholder = "foo". When FN is instantiated with attr "foo"
            /// set to "bar", the instantiated node N's attr A will have been
            /// given the value "bar".
            public var placeholder:String {
                get {
                    return builderResult.placeholder
                }
                set (value) {
                    builderResult.hasPlaceholder = true
                    builderResult.placeholder = value
                }
            }
            public var hasPlaceholder:Bool {
                get {
                    return builderResult.hasPlaceholder
                }
            }
            @discardableResult
            public func setPlaceholder(_ value:String) -> Tensorflow.AttrValue.Builder {
                self.placeholder = value
                return self
            }
            @discardableResult
            public func clearPlaceholder() -> Tensorflow.AttrValue.Builder{
                builderResult.hasPlaceholder = false
                builderResult.placeholder = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.AttrValue.Builder {
                builderResult = Tensorflow.AttrValue()
                return self
            }
            override public func clone() throws -> Tensorflow.AttrValue.Builder {
                return try Tensorflow.AttrValue.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.AttrValue {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.AttrValue {
                let returnMe:Tensorflow.AttrValue = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.AttrValue) throws -> Tensorflow.AttrValue.Builder {
                if other == Tensorflow.AttrValue() {
                    return self
                }
                if other.hasS {
                    s = other.s
                }
                if other.hasI {
                    i = other.i
                }
                if other.hasF {
                    f = other.f
                }
                if other.hasB {
                    b = other.b
                }
                if other.hasType {
                    type = other.type
                }
                if (other.hasShape) {
                    try mergeShape(value: other.shape)
                }
                if (other.hasTensor) {
                    try mergeTensor(value: other.tensor)
                }
                if (other.hasList) {
                    try mergeList(value: other.list)
                }
                if (other.hasFunc) {
                    try mergeFunc(value: other.`func`)
                }
                if other.hasPlaceholder {
                    placeholder = other.placeholder
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.AttrValue.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.AttrValue.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Tensorflow.AttrValue.ListValue.Builder = Tensorflow.AttrValue.ListValue.Builder()
                        if hasList {
                            try subBuilder.mergeFrom(other: list)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        list = subBuilder.buildPartial()

                    case 18:
                        s = try codedInputStream.readData()

                    case 24:
                        i = try codedInputStream.readInt64()

                    case 37:
                        f = try codedInputStream.readFloat()

                    case 40:
                        b = try codedInputStream.readBool()

                    case 48:
                        let valueInttype = try codedInputStream.readEnum()
                        if let enumstype = Tensorflow.DataType(rawValue:valueInttype){
                            type = enumstype
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 6, value:Int64(valueInttype))
                        }

                    case 58:
                        let subBuilder:Tensorflow.TensorShapeProto.Builder = Tensorflow.TensorShapeProto.Builder()
                        if hasShape {
                            try subBuilder.mergeFrom(other: shape)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        shape = subBuilder.buildPartial()

                    case 66:
                        let subBuilder:Tensorflow.TensorProto.Builder = Tensorflow.TensorProto.Builder()
                        if hasTensor {
                            try subBuilder.mergeFrom(other: tensor)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        tensor = subBuilder.buildPartial()

                    case 74:
                        placeholder = try codedInputStream.readString()

                    case 82:
                        let subBuilder:Tensorflow.NameAttrList.Builder = Tensorflow.NameAttrList.Builder()
                        if hasFunc {
                            try subBuilder.mergeFrom(other: `func`)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        `func` = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.AttrValue.Builder {
                let resultDecodedBuilder = Tensorflow.AttrValue.Builder()
                if let jsonValueS = jsonMap["s"] as? String {
                    resultDecodedBuilder.s = Data(base64Encoded:jsonValueS, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                if let jsonValueI = jsonMap["i"] as? String {
                    resultDecodedBuilder.i = Int64(jsonValueI)!
                } else if let jsonValueI = jsonMap["i"] as? Int {
                    resultDecodedBuilder.i = Int64(jsonValueI)
                }
                if let jsonValueF = jsonMap["f"] as? Float {
                    resultDecodedBuilder.f = Float(jsonValueF)
                } else if let jsonValueF = jsonMap["f"] as? String {
                    resultDecodedBuilder.f = Float(jsonValueF)!
                }
                if let jsonValueB = jsonMap["b"] as? Bool {
                    resultDecodedBuilder.b = jsonValueB
                }
                if let jsonValueType = jsonMap["type"] as? String {
                    resultDecodedBuilder.type = try Tensorflow.DataType.fromString(str: jsonValueType)
                }
                if let jsonValueShape = jsonMap["shape"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.shape = try Tensorflow.TensorShapeProto.Builder.decodeToBuilder(jsonMap:jsonValueShape).build()

                }
                if let jsonValueTensor = jsonMap["tensor"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.tensor = try Tensorflow.TensorProto.Builder.decodeToBuilder(jsonMap:jsonValueTensor).build()

                }
                if let jsonValueList = jsonMap["list"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.list = try Tensorflow.AttrValue.ListValue.Builder.decodeToBuilder(jsonMap:jsonValueList).build()

                }
                if let jsonValueFunc = jsonMap["func"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.`func` = try Tensorflow.NameAttrList.Builder.decodeToBuilder(jsonMap:jsonValueFunc).build()

                }
                if let jsonValuePlaceholder = jsonMap["placeholder"] as? String {
                    resultDecodedBuilder.placeholder = jsonValuePlaceholder
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.AttrValue.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.AttrValue.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// A list of attr names and their values. The whole list is attached
    /// with a string name.  E.g., MatMul[T=float].
    final public class NameAttrList : GeneratedMessage {

        public static func == (lhs: Tensorflow.NameAttrList, rhs: Tensorflow.NameAttrList) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
            fieldCheck = fieldCheck && (lhs.hasAttr == rhs.hasAttr) && (!lhs.hasAttr || lhs.attr == rhs.attr)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        final public class AttrEntry : GeneratedMessage {

            public static func == (lhs: Tensorflow.NameAttrList.AttrEntry, rhs: Tensorflow.NameAttrList.AttrEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:String = ""
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:Tensorflow.AttrValue!
            public fileprivate(set) var hasValue:Bool = false
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeString(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeMessage(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeStringSize(fieldNumber: 1)
                }
                if hasValue {
                    if let varSizevalue = value?.computeMessageSize(fieldNumber: 2) {
                        serialize_size += varSizevalue
                    }
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.NameAttrList.AttrEntry.Builder {
                return Tensorflow.NameAttrList.AttrEntry.classBuilder() as! Tensorflow.NameAttrList.AttrEntry.Builder
            }
            public func getBuilder() -> Tensorflow.NameAttrList.AttrEntry.Builder {
                return classBuilder() as! Tensorflow.NameAttrList.AttrEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.NameAttrList.AttrEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.NameAttrList.AttrEntry.Builder()
            }
            public func toBuilder() throws -> Tensorflow.NameAttrList.AttrEntry.Builder {
                return try Tensorflow.NameAttrList.AttrEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.NameAttrList.AttrEntry) throws -> Tensorflow.NameAttrList.AttrEntry.Builder {
                return try Tensorflow.NameAttrList.AttrEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = key
                }
                if hasValue {
                    jsonMap["value"] = try value.encode()
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.NameAttrList.AttrEntry {
                return try Tensorflow.NameAttrList.AttrEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.NameAttrList.AttrEntry {
                return try Tensorflow.NameAttrList.AttrEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value {\n"
                    if let outDescValue = value {
                        output += try outDescValue.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        if let hashValuevalue = value?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuevalue
                        }
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.NameAttrList.AttrEntry"
            }
            override public func className() -> String {
                return "Tensorflow.NameAttrList.AttrEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.NameAttrList.AttrEntry = Tensorflow.NameAttrList.AttrEntry()
                public func getMessage() -> Tensorflow.NameAttrList.AttrEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:String {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:String) -> Tensorflow.NameAttrList.AttrEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> Tensorflow.NameAttrList.AttrEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = ""
                    return self
                }
                public var value:Tensorflow.AttrValue! {
                    get {
                        if valueBuilder_ != nil {
                            builderResult.value = valueBuilder_.getMessage()
                        }
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                fileprivate var valueBuilder_:Tensorflow.AttrValue.Builder! {
                    didSet {
                        builderResult.hasValue = true
                    }
                }
                public func getValueBuilder() -> Tensorflow.AttrValue.Builder {
                    if valueBuilder_ == nil {
                        valueBuilder_ = Tensorflow.AttrValue.Builder()
                        builderResult.value = valueBuilder_.getMessage()
                        if value != nil {
                            try! valueBuilder_.mergeFrom(other: value)
                        }
                    }
                    return valueBuilder_
                }
                @discardableResult
                public func setValue(_ value:Tensorflow.AttrValue!) -> Tensorflow.NameAttrList.AttrEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func mergeValue(value:Tensorflow.AttrValue) throws -> Tensorflow.NameAttrList.AttrEntry.Builder {
                    if builderResult.hasValue {
                        builderResult.value = try Tensorflow.AttrValue.builderWithPrototype(prototype:builderResult.value).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.value = value
                    }
                    builderResult.hasValue = true
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.NameAttrList.AttrEntry.Builder {
                    valueBuilder_ = nil
                    builderResult.hasValue = false
                    builderResult.value = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.NameAttrList.AttrEntry.Builder {
                    builderResult = Tensorflow.NameAttrList.AttrEntry()
                    return self
                }
                override public func clone() throws -> Tensorflow.NameAttrList.AttrEntry.Builder {
                    return try Tensorflow.NameAttrList.AttrEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.NameAttrList.AttrEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.NameAttrList.AttrEntry {
                    let returnMe:Tensorflow.NameAttrList.AttrEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.NameAttrList.AttrEntry) throws -> Tensorflow.NameAttrList.AttrEntry.Builder {
                    if other == Tensorflow.NameAttrList.AttrEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if (other.hasValue) {
                        try mergeValue(value: other.value)
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.NameAttrList.AttrEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.NameAttrList.AttrEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            key = try codedInputStream.readString()

                        case 18:
                            let subBuilder:Tensorflow.AttrValue.Builder = Tensorflow.AttrValue.Builder()
                            if hasValue {
                                try subBuilder.mergeFrom(other: value)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            value = subBuilder.buildPartial()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.NameAttrList.AttrEntry.Builder {
                    let resultDecodedBuilder = Tensorflow.NameAttrList.AttrEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = jsonValueKey
                    }
                    if let jsonValueValue = jsonMap["value"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.value = try Tensorflow.AttrValue.Builder.decodeToBuilder(jsonMap:jsonValueValue).build()

                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.NameAttrList.AttrEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.NameAttrList.AttrEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        public fileprivate(set) var name:String = ""
        public fileprivate(set) var hasName:Bool = false

        public fileprivate(set) var attr:Dictionary<String,Tensorflow.AttrValue> = Dictionary<String,Tensorflow.AttrValue>()

        public fileprivate(set) var hasAttr:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasName {
                try codedOutputStream.writeString(fieldNumber: 1, value:name)
            }
            if hasAttr {
                for (keyAttr, valueAttr) in attr {
                    let valueOfAttr = try! Tensorflow.NameAttrList.AttrEntry.Builder().setKey(keyAttr).setValue(valueAttr).build()
                      try codedOutputStream.writeMessage(fieldNumber: 2, value:valueOfAttr)
                  }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasName {
                serialize_size += name.computeStringSize(fieldNumber: 1)
            }
            if hasAttr {
                  for (keyAttr, valueAttr) in attr {
                      let valueOfAttr = try! Tensorflow.NameAttrList.AttrEntry.Builder().setKey(keyAttr).setValue(valueAttr).build()
                serialize_size += valueOfAttr.computeMessageSize(fieldNumber: 2)
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.NameAttrList.Builder {
            return Tensorflow.NameAttrList.classBuilder() as! Tensorflow.NameAttrList.Builder
        }
        public func getBuilder() -> Tensorflow.NameAttrList.Builder {
            return classBuilder() as! Tensorflow.NameAttrList.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.NameAttrList.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.NameAttrList.Builder()
        }
        public func toBuilder() throws -> Tensorflow.NameAttrList.Builder {
            return try Tensorflow.NameAttrList.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.NameAttrList) throws -> Tensorflow.NameAttrList.Builder {
            return try Tensorflow.NameAttrList.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasName {
                jsonMap["name"] = name
            }
            if hasAttr {
                var mapAttr = Dictionary<String, Dictionary<String,Any>>()
                for (keyAttr, valueAttr) in attr {
                    mapAttr["\(keyAttr)"] = try valueAttr.encode()
                }
                jsonMap["attr"] = mapAttr
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.NameAttrList {
            return try Tensorflow.NameAttrList.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.NameAttrList {
            return try Tensorflow.NameAttrList.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasName {
                output += "\(indent) name: \(name) \n"
            }
            if hasAttr {
                output += "\(indent) attr: \(attr) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasName {
                    hashCode = (hashCode &* 31) &+ name.hashValue
                }
                if hasAttr {
                    for (keyAttr, valueAttr) in attr {
                        hashCode = (hashCode &* 31) &+ keyAttr.hashValue
                        hashCode = (hashCode &* 31) &+ valueAttr.hashValue
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.NameAttrList"
        }
        override public func className() -> String {
            return "Tensorflow.NameAttrList"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.NameAttrList = Tensorflow.NameAttrList()
            public func getMessage() -> Tensorflow.NameAttrList {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var name:String {
                get {
                    return builderResult.name
                }
                set (value) {
                    builderResult.hasName = true
                    builderResult.name = value
                }
            }
            public var hasName:Bool {
                get {
                    return builderResult.hasName
                }
            }
            @discardableResult
            public func setName(_ value:String) -> Tensorflow.NameAttrList.Builder {
                self.name = value
                return self
            }
            @discardableResult
            public func clearName() -> Tensorflow.NameAttrList.Builder{
                builderResult.hasName = false
                builderResult.name = ""
                return self
            }
            public var hasAttr:Bool {
                get {
                    return builderResult.hasAttr
                }
            }
            public var attr:Dictionary<String,Tensorflow.AttrValue> {
                get {
                    return builderResult.attr
                }
                set (value) {
                    builderResult.hasAttr = true
                    builderResult.attr = value
                }
            }
            @discardableResult
            public func setAttr(_ value:Dictionary<String,Tensorflow.AttrValue>) -> Tensorflow.NameAttrList.Builder {
                self.attr = value
                return self
            }
            @discardableResult
            public func clearAttr() -> Tensorflow.NameAttrList.Builder{
                builderResult.hasAttr = false
                builderResult.attr = Dictionary<String,Tensorflow.AttrValue>()
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.NameAttrList.Builder {
                builderResult = Tensorflow.NameAttrList()
                return self
            }
            override public func clone() throws -> Tensorflow.NameAttrList.Builder {
                return try Tensorflow.NameAttrList.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.NameAttrList {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.NameAttrList {
                let returnMe:Tensorflow.NameAttrList = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.NameAttrList) throws -> Tensorflow.NameAttrList.Builder {
                if other == Tensorflow.NameAttrList() {
                    return self
                }
                if other.hasName {
                    name = other.name
                }
                if other.hasAttr {
                    attr = other.attr
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.NameAttrList.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.NameAttrList.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        name = try codedInputStream.readString()

                    case 18:
                        let subBuilder = Tensorflow.NameAttrList.AttrEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfAttr = subBuilder.buildPartial()
                        attr[buildOfAttr.key] = buildOfAttr.value

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.NameAttrList.Builder {
                let resultDecodedBuilder = Tensorflow.NameAttrList.Builder()
                if let jsonValueName = jsonMap["name"] as? String {
                    resultDecodedBuilder.name = jsonValueName
                }
                if let jsonValueAttr = jsonMap["attr"] as? Dictionary<String, Dictionary<String,Any>> {
                    var mapAttr = Dictionary<String, Tensorflow.AttrValue>()
                    for (keyAttr, valueAttr) in jsonValueAttr {
                        guard let keyFromAttr = String(keyAttr) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapAttr[keyFromAttr] = try Tensorflow.AttrValue.Builder.decodeToBuilder(jsonMap:valueAttr).build()

                    }
                    resultDecodedBuilder.attr = mapAttr
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.NameAttrList.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.NameAttrList.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.AttrValue: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.AttrValue> {
        var mergedArray = Array<Tensorflow.AttrValue>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.AttrValue? {
        return try Tensorflow.AttrValue.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.AttrValue {
        return try Tensorflow.AttrValue.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.AttrValueRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.AttrValue {
        return try Tensorflow.AttrValue.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.AttrValue {
        return try Tensorflow.AttrValue.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.AttrValue {
        return try Tensorflow.AttrValue.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.AttrValue {
        return try Tensorflow.AttrValue.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.AttrValue {
        return try Tensorflow.AttrValue.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "s": return self.s
        case "i": return self.i
        case "f": return self.f
        case "b": return self.b
        case "type": return self.type
        case "shape": return self.shape
        case "tensor": return self.tensor
        case "list": return self.list
        case "`func`": return self.`func`
        case "placeholder": return self.placeholder
        default: return nil
        }
    }
}
extension Tensorflow.AttrValue.ListValue: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.AttrValue.ListValue> {
        var mergedArray = Array<Tensorflow.AttrValue.ListValue>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.AttrValue.ListValue? {
        return try Tensorflow.AttrValue.ListValue.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.AttrValue.ListValue {
        return try Tensorflow.AttrValue.ListValue.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.AttrValueRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.AttrValue.ListValue {
        return try Tensorflow.AttrValue.ListValue.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.AttrValue.ListValue {
        return try Tensorflow.AttrValue.ListValue.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.AttrValue.ListValue {
        return try Tensorflow.AttrValue.ListValue.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.AttrValue.ListValue {
        return try Tensorflow.AttrValue.ListValue.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.AttrValue.ListValue {
        return try Tensorflow.AttrValue.ListValue.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "s": return self.s
        case "i": return self.i
        case "f": return self.f
        case "b": return self.b
        case "type": return self.type
        case "shape": return self.shape
        case "tensor": return self.tensor
        case "`func`": return self.`func`
        default: return nil
        }
    }
}
extension Tensorflow.AttrValue.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "s": return self.s
            case "i": return self.i
            case "f": return self.f
            case "b": return self.b
            case "type": return self.type
            case "shape": return self.shape
            case "tensor": return self.tensor
            case "list": return self.list
            case "`func`": return self.`func`
            case "placeholder": return self.placeholder
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "s":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.s = newSubscriptValue
            case "i":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.i = newSubscriptValue
            case "f":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.f = newSubscriptValue
            case "b":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.b = newSubscriptValue
            case "type":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.DataType else {
                    return
                }
                self.type = newSubscriptValue
            case "shape":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.TensorShapeProto else {
                    return
                }
                self.shape = newSubscriptValue
            case "tensor":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.TensorProto else {
                    return
                }
                self.tensor = newSubscriptValue
            case "list":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.AttrValue.ListValue else {
                    return
                }
                self.list = newSubscriptValue
            case "`func`":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.NameAttrList else {
                    return
                }
                self.`func` = newSubscriptValue
            case "placeholder":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.placeholder = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.AttrValue.ListValue.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "s": return self.s
            case "i": return self.i
            case "f": return self.f
            case "b": return self.b
            case "type": return self.type
            case "shape": return self.shape
            case "tensor": return self.tensor
            case "`func`": return self.`func`
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "s":
                guard let newSubscriptValue = newSubscriptValue as? Array<Data> else {
                    return
                }
                self.s = newSubscriptValue
            case "i":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.i = newSubscriptValue
            case "f":
                guard let newSubscriptValue = newSubscriptValue as? Array<Float> else {
                    return
                }
                self.f = newSubscriptValue
            case "b":
                guard let newSubscriptValue = newSubscriptValue as? Array<Bool> else {
                    return
                }
                self.b = newSubscriptValue
            case "type":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.DataType> else {
                    return
                }
                self.type = newSubscriptValue
            case "shape":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.TensorShapeProto> else {
                    return
                }
                self.shape = newSubscriptValue
            case "tensor":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.TensorProto> else {
                    return
                }
                self.tensor = newSubscriptValue
            case "`func`":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.NameAttrList> else {
                    return
                }
                self.`func` = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.NameAttrList: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.NameAttrList> {
        var mergedArray = Array<Tensorflow.NameAttrList>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.NameAttrList? {
        return try Tensorflow.NameAttrList.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.NameAttrList {
        return try Tensorflow.NameAttrList.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.AttrValueRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.NameAttrList {
        return try Tensorflow.NameAttrList.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.NameAttrList {
        return try Tensorflow.NameAttrList.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.NameAttrList {
        return try Tensorflow.NameAttrList.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.NameAttrList {
        return try Tensorflow.NameAttrList.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.NameAttrList {
        return try Tensorflow.NameAttrList.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "name": return self.name
        case "attr": return self.attr
        default: return nil
        }
    }
}
extension Tensorflow.NameAttrList.AttrEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.NameAttrList.AttrEntry> {
        var mergedArray = Array<Tensorflow.NameAttrList.AttrEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.NameAttrList.AttrEntry? {
        return try Tensorflow.NameAttrList.AttrEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.NameAttrList.AttrEntry {
        return try Tensorflow.NameAttrList.AttrEntry.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.AttrValueRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.NameAttrList.AttrEntry {
        return try Tensorflow.NameAttrList.AttrEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.NameAttrList.AttrEntry {
        return try Tensorflow.NameAttrList.AttrEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.NameAttrList.AttrEntry {
        return try Tensorflow.NameAttrList.AttrEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.NameAttrList.AttrEntry {
        return try Tensorflow.NameAttrList.AttrEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.NameAttrList.AttrEntry {
        return try Tensorflow.NameAttrList.AttrEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.NameAttrList.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "name": return self.name
            case "attr": return self.attr
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "attr":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,Tensorflow.AttrValue> else {
                    return
                }
                self.attr = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.NameAttrList.AttrEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.AttrValue else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "cost_graph.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { }

public extension Tensorflow {
    public struct CostGraphRoot {
        public static let `default` = CostGraphRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Tensorflow.TensorShapeRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.TypesRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    final public class CostGraphDef : GeneratedMessage {

        public static func == (lhs: Tensorflow.CostGraphDef, rhs: Tensorflow.CostGraphDef) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.node == rhs.node)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        final public class Node : GeneratedMessage {

            public static func == (lhs: Tensorflow.CostGraphDef.Node, rhs: Tensorflow.CostGraphDef.Node) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
                fieldCheck = fieldCheck && (lhs.hasDevice == rhs.hasDevice) && (!lhs.hasDevice || lhs.device == rhs.device)
                fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
                fieldCheck = fieldCheck && (lhs.inputInfo == rhs.inputInfo)
                fieldCheck = fieldCheck && (lhs.outputInfo == rhs.outputInfo)
                fieldCheck = fieldCheck && (lhs.hasTemporaryMemorySize == rhs.hasTemporaryMemorySize) && (!lhs.hasTemporaryMemorySize || lhs.temporaryMemorySize == rhs.temporaryMemorySize)
                fieldCheck = fieldCheck && (lhs.hasIsFinal == rhs.hasIsFinal) && (!lhs.hasIsFinal || lhs.isFinal == rhs.isFinal)
                fieldCheck = fieldCheck && (lhs.controlInput == rhs.controlInput)
                fieldCheck = fieldCheck && (lhs.hasComputeCost == rhs.hasComputeCost) && (!lhs.hasComputeCost || lhs.computeCost == rhs.computeCost)
                fieldCheck = fieldCheck && (lhs.hasHostTempMemorySize == rhs.hasHostTempMemorySize) && (!lhs.hasHostTempMemorySize || lhs.hostTempMemorySize == rhs.hostTempMemorySize)
                fieldCheck = fieldCheck && (lhs.hasDeviceTempMemorySize == rhs.hasDeviceTempMemorySize) && (!lhs.hasDeviceTempMemorySize || lhs.deviceTempMemorySize == rhs.deviceTempMemorySize)
                fieldCheck = fieldCheck && (lhs.hasHostPersistentMemorySize == rhs.hasHostPersistentMemorySize) && (!lhs.hasHostPersistentMemorySize || lhs.hostPersistentMemorySize == rhs.hostPersistentMemorySize)
                fieldCheck = fieldCheck && (lhs.hasComputeTime == rhs.hasComputeTime) && (!lhs.hasComputeTime || lhs.computeTime == rhs.computeTime)
                fieldCheck = fieldCheck && (lhs.hasMemoryTime == rhs.hasMemoryTime) && (!lhs.hasMemoryTime || lhs.memoryTime == rhs.memoryTime)
                fieldCheck = fieldCheck && (lhs.hasDevicePersistentMemorySize == rhs.hasDevicePersistentMemorySize) && (!lhs.hasDevicePersistentMemorySize || lhs.devicePersistentMemorySize == rhs.devicePersistentMemorySize)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }



            //Nested type declaration start

            /// Inputs of this node. They must be executed before this node can be
            /// executed. An input is a particular output of another node, specified
            /// by the node id and the output index.
            final public class InputInfo : GeneratedMessage {

                public static func == (lhs: Tensorflow.CostGraphDef.Node.InputInfo, rhs: Tensorflow.CostGraphDef.Node.InputInfo) -> Bool {
                    if lhs === rhs {
                        return true
                    }
                    var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                    fieldCheck = fieldCheck && (lhs.hasPrecedingNode == rhs.hasPrecedingNode) && (!lhs.hasPrecedingNode || lhs.precedingNode == rhs.precedingNode)
                    fieldCheck = fieldCheck && (lhs.hasPrecedingPort == rhs.hasPrecedingPort) && (!lhs.hasPrecedingPort || lhs.precedingPort == rhs.precedingPort)
                    fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                    return fieldCheck
                }

                public fileprivate(set) var precedingNode:Int32 = Int32(0)
                public fileprivate(set) var hasPrecedingNode:Bool = false

                public fileprivate(set) var precedingPort:Int32 = Int32(0)
                public fileprivate(set) var hasPrecedingPort:Bool = false

                required public init() {
                    super.init()
                }
                override public func isInitialized() -> Bool {
                    return true
                }
                override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                    if hasPrecedingNode {
                        try codedOutputStream.writeInt32(fieldNumber: 1, value:precedingNode)
                    }
                    if hasPrecedingPort {
                        try codedOutputStream.writeInt32(fieldNumber: 2, value:precedingPort)
                    }
                    try unknownFields.writeTo(codedOutputStream: codedOutputStream)
                }
                override public func serializedSize() -> Int32 {
                    var serialize_size:Int32 = memoizedSerializedSize
                    if serialize_size != -1 {
                     return serialize_size
                    }

                    serialize_size = 0
                    if hasPrecedingNode {
                        serialize_size += precedingNode.computeInt32Size(fieldNumber: 1)
                    }
                    if hasPrecedingPort {
                        serialize_size += precedingPort.computeInt32Size(fieldNumber: 2)
                    }
                    serialize_size += unknownFields.serializedSize()
                    memoizedSerializedSize = serialize_size
                    return serialize_size
                }
                public class func getBuilder() -> Tensorflow.CostGraphDef.Node.InputInfo.Builder {
                    return Tensorflow.CostGraphDef.Node.InputInfo.classBuilder() as! Tensorflow.CostGraphDef.Node.InputInfo.Builder
                }
                public func getBuilder() -> Tensorflow.CostGraphDef.Node.InputInfo.Builder {
                    return classBuilder() as! Tensorflow.CostGraphDef.Node.InputInfo.Builder
                }
                override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                    return Tensorflow.CostGraphDef.Node.InputInfo.Builder()
                }
                override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                    return Tensorflow.CostGraphDef.Node.InputInfo.Builder()
                }
                public func toBuilder() throws -> Tensorflow.CostGraphDef.Node.InputInfo.Builder {
                    return try Tensorflow.CostGraphDef.Node.InputInfo.builderWithPrototype(prototype:self)
                }
                public class func builderWithPrototype(prototype:Tensorflow.CostGraphDef.Node.InputInfo) throws -> Tensorflow.CostGraphDef.Node.InputInfo.Builder {
                    return try Tensorflow.CostGraphDef.Node.InputInfo.Builder().mergeFrom(other:prototype)
                }
                override public func encode() throws -> Dictionary<String,Any> {
                    guard isInitialized() else {
                        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                    }

                    var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                    if hasPrecedingNode {
                        jsonMap["precedingNode"] = Int(precedingNode)
                    }
                    if hasPrecedingPort {
                        jsonMap["precedingPort"] = Int(precedingPort)
                    }
                    return jsonMap
                }
                override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CostGraphDef.Node.InputInfo {
                    return try Tensorflow.CostGraphDef.Node.InputInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
                }
                override class public func fromJSON(data:Data) throws -> Tensorflow.CostGraphDef.Node.InputInfo {
                    return try Tensorflow.CostGraphDef.Node.InputInfo.Builder.fromJSONToBuilder(data:data).build()
                }
                override public func getDescription(indent:String) throws -> String {
                    var output = ""
                    if hasPrecedingNode {
                        output += "\(indent) precedingNode: \(precedingNode) \n"
                    }
                    if hasPrecedingPort {
                        output += "\(indent) precedingPort: \(precedingPort) \n"
                    }
                    output += unknownFields.getDescription(indent: indent)
                    return output
                }
                override public var hashValue:Int {
                    get {
                        var hashCode:Int = 7
                        if hasPrecedingNode {
                            hashCode = (hashCode &* 31) &+ precedingNode.hashValue
                        }
                        if hasPrecedingPort {
                            hashCode = (hashCode &* 31) &+ precedingPort.hashValue
                        }
                        hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                        return hashCode
                    }
                }


                //Meta information declaration start

                override public class func className() -> String {
                    return "Tensorflow.CostGraphDef.Node.InputInfo"
                }
                override public func className() -> String {
                    return "Tensorflow.CostGraphDef.Node.InputInfo"
                }
                //Meta information declaration end

                final public class Builder : GeneratedMessageBuilder {
                    fileprivate var builderResult:Tensorflow.CostGraphDef.Node.InputInfo = Tensorflow.CostGraphDef.Node.InputInfo()
                    public func getMessage() -> Tensorflow.CostGraphDef.Node.InputInfo {
                        return builderResult
                    }

                    required override public init () {
                        super.init()
                    }
                    public var precedingNode:Int32 {
                        get {
                            return builderResult.precedingNode
                        }
                        set (value) {
                            builderResult.hasPrecedingNode = true
                            builderResult.precedingNode = value
                        }
                    }
                    public var hasPrecedingNode:Bool {
                        get {
                            return builderResult.hasPrecedingNode
                        }
                    }
                    @discardableResult
                    public func setPrecedingNode(_ value:Int32) -> Tensorflow.CostGraphDef.Node.InputInfo.Builder {
                        self.precedingNode = value
                        return self
                    }
                    @discardableResult
                    public func clearPrecedingNode() -> Tensorflow.CostGraphDef.Node.InputInfo.Builder{
                        builderResult.hasPrecedingNode = false
                        builderResult.precedingNode = Int32(0)
                        return self
                    }
                    public var precedingPort:Int32 {
                        get {
                            return builderResult.precedingPort
                        }
                        set (value) {
                            builderResult.hasPrecedingPort = true
                            builderResult.precedingPort = value
                        }
                    }
                    public var hasPrecedingPort:Bool {
                        get {
                            return builderResult.hasPrecedingPort
                        }
                    }
                    @discardableResult
                    public func setPrecedingPort(_ value:Int32) -> Tensorflow.CostGraphDef.Node.InputInfo.Builder {
                        self.precedingPort = value
                        return self
                    }
                    @discardableResult
                    public func clearPrecedingPort() -> Tensorflow.CostGraphDef.Node.InputInfo.Builder{
                        builderResult.hasPrecedingPort = false
                        builderResult.precedingPort = Int32(0)
                        return self
                    }
                    override public var internalGetResult:GeneratedMessage {
                        get {
                            return builderResult
                        }
                    }
                    @discardableResult
                    override public func clear() -> Tensorflow.CostGraphDef.Node.InputInfo.Builder {
                        builderResult = Tensorflow.CostGraphDef.Node.InputInfo()
                        return self
                    }
                    override public func clone() throws -> Tensorflow.CostGraphDef.Node.InputInfo.Builder {
                        return try Tensorflow.CostGraphDef.Node.InputInfo.builderWithPrototype(prototype:builderResult)
                    }
                    override public func build() throws -> Tensorflow.CostGraphDef.Node.InputInfo {
                        try checkInitialized()
                        return buildPartial()
                    }
                    public func buildPartial() -> Tensorflow.CostGraphDef.Node.InputInfo {
                        let returnMe:Tensorflow.CostGraphDef.Node.InputInfo = builderResult
                        return returnMe
                    }
                    @discardableResult
                    public func mergeFrom(other:Tensorflow.CostGraphDef.Node.InputInfo) throws -> Tensorflow.CostGraphDef.Node.InputInfo.Builder {
                        if other == Tensorflow.CostGraphDef.Node.InputInfo() {
                            return self
                        }
                        if other.hasPrecedingNode {
                            precedingNode = other.precedingNode
                        }
                        if other.hasPrecedingPort {
                            precedingPort = other.precedingPort
                        }
                        try merge(unknownField: other.unknownFields)
                        return self
                    }
                    @discardableResult
                    override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CostGraphDef.Node.InputInfo.Builder {
                        return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                    }
                    @discardableResult
                    override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CostGraphDef.Node.InputInfo.Builder {
                        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                        while (true) {
                            let protobufTag = try codedInputStream.readTag()
                            switch protobufTag {
                            case 0: 
                                self.unknownFields = try unknownFieldsBuilder.build()
                                return self

                            case 8:
                                precedingNode = try codedInputStream.readInt32()

                            case 16:
                                precedingPort = try codedInputStream.readInt32()

                            default:
                                if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                    unknownFields = try unknownFieldsBuilder.build()
                                    return self
                                }
                            }
                        }
                    }
                    class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CostGraphDef.Node.InputInfo.Builder {
                        let resultDecodedBuilder = Tensorflow.CostGraphDef.Node.InputInfo.Builder()
                        if let jsonValuePrecedingNode = jsonMap["precedingNode"] as? Int {
                            resultDecodedBuilder.precedingNode = Int32(jsonValuePrecedingNode)
                        } else if let jsonValuePrecedingNode = jsonMap["precedingNode"] as? String {
                            resultDecodedBuilder.precedingNode = Int32(jsonValuePrecedingNode)!
                        }
                        if let jsonValuePrecedingPort = jsonMap["precedingPort"] as? Int {
                            resultDecodedBuilder.precedingPort = Int32(jsonValuePrecedingPort)
                        } else if let jsonValuePrecedingPort = jsonMap["precedingPort"] as? String {
                            resultDecodedBuilder.precedingPort = Int32(jsonValuePrecedingPort)!
                        }
                        return resultDecodedBuilder
                    }
                    override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.CostGraphDef.Node.InputInfo.Builder {
                        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        return try Tensorflow.CostGraphDef.Node.InputInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
                    }
                }

            }

            //Nested type declaration end



            //Nested type declaration start

            /// Outputs of this node.
            final public class OutputInfo : GeneratedMessage {

                public static func == (lhs: Tensorflow.CostGraphDef.Node.OutputInfo, rhs: Tensorflow.CostGraphDef.Node.OutputInfo) -> Bool {
                    if lhs === rhs {
                        return true
                    }
                    var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                    fieldCheck = fieldCheck && (lhs.hasSize == rhs.hasSize) && (!lhs.hasSize || lhs.size == rhs.size)
                    fieldCheck = fieldCheck && (lhs.hasAliasInputPort == rhs.hasAliasInputPort) && (!lhs.hasAliasInputPort || lhs.aliasInputPort == rhs.aliasInputPort)
                    fieldCheck = fieldCheck && (lhs.hasShape == rhs.hasShape) && (!lhs.hasShape || lhs.shape == rhs.shape)
                    fieldCheck = fieldCheck && (lhs.hasDtype == rhs.hasDtype) && (!lhs.hasDtype || lhs.dtype == rhs.dtype)
                    fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                    return fieldCheck
                }

                public fileprivate(set) var size:Int64 = Int64(0)
                public fileprivate(set) var hasSize:Bool = false

                /// If >= 0, the output is an alias of an input. Note that an alias input
                /// may itself be an alias. The algorithm will therefore need to follow
                /// those pointers.
                public fileprivate(set) var aliasInputPort:Int64 = Int64(0)
                public fileprivate(set) var hasAliasInputPort:Bool = false

                public fileprivate(set) var shape:Tensorflow.TensorShapeProto!
                public fileprivate(set) var hasShape:Bool = false
                public fileprivate(set) var dtype:Tensorflow.DataType = Tensorflow.DataType.dtInvalid
                public fileprivate(set) var hasDtype:Bool = false
                required public init() {
                    super.init()
                }
                override public func isInitialized() -> Bool {
                    return true
                }
                override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                    if hasSize {
                        try codedOutputStream.writeInt64(fieldNumber: 1, value:size)
                    }
                    if hasAliasInputPort {
                        try codedOutputStream.writeInt64(fieldNumber: 2, value:aliasInputPort)
                    }
                    if hasShape {
                        try codedOutputStream.writeMessage(fieldNumber: 3, value:shape)
                    }
                    if hasDtype {
                        try codedOutputStream.writeEnum(fieldNumber: 4, value:dtype.rawValue)
                    }
                    try unknownFields.writeTo(codedOutputStream: codedOutputStream)
                }
                override public func serializedSize() -> Int32 {
                    var serialize_size:Int32 = memoizedSerializedSize
                    if serialize_size != -1 {
                     return serialize_size
                    }

                    serialize_size = 0
                    if hasSize {
                        serialize_size += size.computeInt64Size(fieldNumber: 1)
                    }
                    if hasAliasInputPort {
                        serialize_size += aliasInputPort.computeInt64Size(fieldNumber: 2)
                    }
                    if hasShape {
                        if let varSizeshape = shape?.computeMessageSize(fieldNumber: 3) {
                            serialize_size += varSizeshape
                        }
                    }
                    if (hasDtype) {
                        serialize_size += dtype.rawValue.computeEnumSize(fieldNumber: 4)
                    }
                    serialize_size += unknownFields.serializedSize()
                    memoizedSerializedSize = serialize_size
                    return serialize_size
                }
                public class func getBuilder() -> Tensorflow.CostGraphDef.Node.OutputInfo.Builder {
                    return Tensorflow.CostGraphDef.Node.OutputInfo.classBuilder() as! Tensorflow.CostGraphDef.Node.OutputInfo.Builder
                }
                public func getBuilder() -> Tensorflow.CostGraphDef.Node.OutputInfo.Builder {
                    return classBuilder() as! Tensorflow.CostGraphDef.Node.OutputInfo.Builder
                }
                override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                    return Tensorflow.CostGraphDef.Node.OutputInfo.Builder()
                }
                override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                    return Tensorflow.CostGraphDef.Node.OutputInfo.Builder()
                }
                public func toBuilder() throws -> Tensorflow.CostGraphDef.Node.OutputInfo.Builder {
                    return try Tensorflow.CostGraphDef.Node.OutputInfo.builderWithPrototype(prototype:self)
                }
                public class func builderWithPrototype(prototype:Tensorflow.CostGraphDef.Node.OutputInfo) throws -> Tensorflow.CostGraphDef.Node.OutputInfo.Builder {
                    return try Tensorflow.CostGraphDef.Node.OutputInfo.Builder().mergeFrom(other:prototype)
                }
                override public func encode() throws -> Dictionary<String,Any> {
                    guard isInitialized() else {
                        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                    }

                    var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                    if hasSize {
                        jsonMap["size"] = "\(size)"
                    }
                    if hasAliasInputPort {
                        jsonMap["aliasInputPort"] = "\(aliasInputPort)"
                    }
                    if hasShape {
                        jsonMap["shape"] = try shape.encode()
                    }
                    if hasDtype {
                        jsonMap["dtype"] = dtype.toString()
                    }
                    return jsonMap
                }
                override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CostGraphDef.Node.OutputInfo {
                    return try Tensorflow.CostGraphDef.Node.OutputInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
                }
                override class public func fromJSON(data:Data) throws -> Tensorflow.CostGraphDef.Node.OutputInfo {
                    return try Tensorflow.CostGraphDef.Node.OutputInfo.Builder.fromJSONToBuilder(data:data).build()
                }
                override public func getDescription(indent:String) throws -> String {
                    var output = ""
                    if hasSize {
                        output += "\(indent) size: \(size) \n"
                    }
                    if hasAliasInputPort {
                        output += "\(indent) aliasInputPort: \(aliasInputPort) \n"
                    }
                    if hasShape {
                        output += "\(indent) shape {\n"
                        if let outDescShape = shape {
                            output += try outDescShape.getDescription(indent: "\(indent)  ")
                        }
                        output += "\(indent) }\n"
                    }
                    if (hasDtype) {
                        output += "\(indent) dtype: \(dtype.description)\n"
                    }
                    output += unknownFields.getDescription(indent: indent)
                    return output
                }
                override public var hashValue:Int {
                    get {
                        var hashCode:Int = 7
                        if hasSize {
                            hashCode = (hashCode &* 31) &+ size.hashValue
                        }
                        if hasAliasInputPort {
                            hashCode = (hashCode &* 31) &+ aliasInputPort.hashValue
                        }
                        if hasShape {
                            if let hashValueshape = shape?.hashValue {
                                hashCode = (hashCode &* 31) &+ hashValueshape
                            }
                        }
                        if hasDtype {
                             hashCode = (hashCode &* 31) &+ dtype.hashValue
                        }
                        hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                        return hashCode
                    }
                }


                //Meta information declaration start

                override public class func className() -> String {
                    return "Tensorflow.CostGraphDef.Node.OutputInfo"
                }
                override public func className() -> String {
                    return "Tensorflow.CostGraphDef.Node.OutputInfo"
                }
                //Meta information declaration end

                final public class Builder : GeneratedMessageBuilder {
                    fileprivate var builderResult:Tensorflow.CostGraphDef.Node.OutputInfo = Tensorflow.CostGraphDef.Node.OutputInfo()
                    public func getMessage() -> Tensorflow.CostGraphDef.Node.OutputInfo {
                        return builderResult
                    }

                    required override public init () {
                        super.init()
                    }
                    public var size:Int64 {
                        get {
                            return builderResult.size
                        }
                        set (value) {
                            builderResult.hasSize = true
                            builderResult.size = value
                        }
                    }
                    public var hasSize:Bool {
                        get {
                            return builderResult.hasSize
                        }
                    }
                    @discardableResult
                    public func setSize(_ value:Int64) -> Tensorflow.CostGraphDef.Node.OutputInfo.Builder {
                        self.size = value
                        return self
                    }
                    @discardableResult
                    public func clearSize() -> Tensorflow.CostGraphDef.Node.OutputInfo.Builder{
                        builderResult.hasSize = false
                        builderResult.size = Int64(0)
                        return self
                    }
                    /// If >= 0, the output is an alias of an input. Note that an alias input
                    /// may itself be an alias. The algorithm will therefore need to follow
                    /// those pointers.
                    public var aliasInputPort:Int64 {
                        get {
                            return builderResult.aliasInputPort
                        }
                        set (value) {
                            builderResult.hasAliasInputPort = true
                            builderResult.aliasInputPort = value
                        }
                    }
                    public var hasAliasInputPort:Bool {
                        get {
                            return builderResult.hasAliasInputPort
                        }
                    }
                    @discardableResult
                    public func setAliasInputPort(_ value:Int64) -> Tensorflow.CostGraphDef.Node.OutputInfo.Builder {
                        self.aliasInputPort = value
                        return self
                    }
                    @discardableResult
                    public func clearAliasInputPort() -> Tensorflow.CostGraphDef.Node.OutputInfo.Builder{
                        builderResult.hasAliasInputPort = false
                        builderResult.aliasInputPort = Int64(0)
                        return self
                    }
                    public var shape:Tensorflow.TensorShapeProto! {
                        get {
                            if shapeBuilder_ != nil {
                                builderResult.shape = shapeBuilder_.getMessage()
                            }
                            return builderResult.shape
                        }
                        set (value) {
                            builderResult.hasShape = true
                            builderResult.shape = value
                        }
                    }
                    public var hasShape:Bool {
                        get {
                            return builderResult.hasShape
                        }
                    }
                    fileprivate var shapeBuilder_:Tensorflow.TensorShapeProto.Builder! {
                        didSet {
                            builderResult.hasShape = true
                        }
                    }
                    public func getShapeBuilder() -> Tensorflow.TensorShapeProto.Builder {
                        if shapeBuilder_ == nil {
                            shapeBuilder_ = Tensorflow.TensorShapeProto.Builder()
                            builderResult.shape = shapeBuilder_.getMessage()
                            if shape != nil {
                                try! shapeBuilder_.mergeFrom(other: shape)
                            }
                        }
                        return shapeBuilder_
                    }
                    @discardableResult
                    public func setShape(_ value:Tensorflow.TensorShapeProto!) -> Tensorflow.CostGraphDef.Node.OutputInfo.Builder {
                        self.shape = value
                        return self
                    }
                    @discardableResult
                    public func mergeShape(value:Tensorflow.TensorShapeProto) throws -> Tensorflow.CostGraphDef.Node.OutputInfo.Builder {
                        if builderResult.hasShape {
                            builderResult.shape = try Tensorflow.TensorShapeProto.builderWithPrototype(prototype:builderResult.shape).mergeFrom(other: value).buildPartial()
                        } else {
                            builderResult.shape = value
                        }
                        builderResult.hasShape = true
                        return self
                    }
                    @discardableResult
                    public func clearShape() -> Tensorflow.CostGraphDef.Node.OutputInfo.Builder {
                        shapeBuilder_ = nil
                        builderResult.hasShape = false
                        builderResult.shape = nil
                        return self
                    }
                        public var dtype:Tensorflow.DataType {
                            get {
                                return builderResult.dtype
                            }
                            set (value) {
                                builderResult.hasDtype = true
                                builderResult.dtype = value
                            }
                        }
                        public var hasDtype:Bool{
                            get {
                                return builderResult.hasDtype
                            }
                        }
                    @discardableResult
                        public func setDtype(_ value:Tensorflow.DataType) -> Tensorflow.CostGraphDef.Node.OutputInfo.Builder {
                          self.dtype = value
                          return self
                        }
                    @discardableResult
                        public func clearDtype() -> Tensorflow.CostGraphDef.Node.OutputInfo.Builder {
                           builderResult.hasDtype = false
                           builderResult.dtype = .dtInvalid
                           return self
                        }
                    override public var internalGetResult:GeneratedMessage {
                        get {
                            return builderResult
                        }
                    }
                    @discardableResult
                    override public func clear() -> Tensorflow.CostGraphDef.Node.OutputInfo.Builder {
                        builderResult = Tensorflow.CostGraphDef.Node.OutputInfo()
                        return self
                    }
                    override public func clone() throws -> Tensorflow.CostGraphDef.Node.OutputInfo.Builder {
                        return try Tensorflow.CostGraphDef.Node.OutputInfo.builderWithPrototype(prototype:builderResult)
                    }
                    override public func build() throws -> Tensorflow.CostGraphDef.Node.OutputInfo {
                        try checkInitialized()
                        return buildPartial()
                    }
                    public func buildPartial() -> Tensorflow.CostGraphDef.Node.OutputInfo {
                        let returnMe:Tensorflow.CostGraphDef.Node.OutputInfo = builderResult
                        return returnMe
                    }
                    @discardableResult
                    public func mergeFrom(other:Tensorflow.CostGraphDef.Node.OutputInfo) throws -> Tensorflow.CostGraphDef.Node.OutputInfo.Builder {
                        if other == Tensorflow.CostGraphDef.Node.OutputInfo() {
                            return self
                        }
                        if other.hasSize {
                            size = other.size
                        }
                        if other.hasAliasInputPort {
                            aliasInputPort = other.aliasInputPort
                        }
                        if (other.hasShape) {
                            try mergeShape(value: other.shape)
                        }
                        if other.hasDtype {
                            dtype = other.dtype
                        }
                        try merge(unknownField: other.unknownFields)
                        return self
                    }
                    @discardableResult
                    override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CostGraphDef.Node.OutputInfo.Builder {
                        return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                    }
                    @discardableResult
                    override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CostGraphDef.Node.OutputInfo.Builder {
                        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                        while (true) {
                            let protobufTag = try codedInputStream.readTag()
                            switch protobufTag {
                            case 0: 
                                self.unknownFields = try unknownFieldsBuilder.build()
                                return self

                            case 8:
                                size = try codedInputStream.readInt64()

                            case 16:
                                aliasInputPort = try codedInputStream.readInt64()

                            case 26:
                                let subBuilder:Tensorflow.TensorShapeProto.Builder = Tensorflow.TensorShapeProto.Builder()
                                if hasShape {
                                    try subBuilder.mergeFrom(other: shape)
                                }
                                try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                                shape = subBuilder.buildPartial()

                            case 32:
                                let valueIntdtype = try codedInputStream.readEnum()
                                if let enumsdtype = Tensorflow.DataType(rawValue:valueIntdtype){
                                    dtype = enumsdtype
                                } else {
                                    try unknownFieldsBuilder.mergeVarintField(fieldNumber: 4, value:Int64(valueIntdtype))
                                }

                            default:
                                if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                    unknownFields = try unknownFieldsBuilder.build()
                                    return self
                                }
                            }
                        }
                    }
                    class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CostGraphDef.Node.OutputInfo.Builder {
                        let resultDecodedBuilder = Tensorflow.CostGraphDef.Node.OutputInfo.Builder()
                        if let jsonValueSize = jsonMap["size"] as? String {
                            resultDecodedBuilder.size = Int64(jsonValueSize)!
                        } else if let jsonValueSize = jsonMap["size"] as? Int {
                            resultDecodedBuilder.size = Int64(jsonValueSize)
                        }
                        if let jsonValueAliasInputPort = jsonMap["aliasInputPort"] as? String {
                            resultDecodedBuilder.aliasInputPort = Int64(jsonValueAliasInputPort)!
                        } else if let jsonValueAliasInputPort = jsonMap["aliasInputPort"] as? Int {
                            resultDecodedBuilder.aliasInputPort = Int64(jsonValueAliasInputPort)
                        }
                        if let jsonValueShape = jsonMap["shape"] as? Dictionary<String,Any> {
                            resultDecodedBuilder.shape = try Tensorflow.TensorShapeProto.Builder.decodeToBuilder(jsonMap:jsonValueShape).build()

                        }
                        if let jsonValueDtype = jsonMap["dtype"] as? String {
                            resultDecodedBuilder.dtype = try Tensorflow.DataType.fromString(str: jsonValueDtype)
                        }
                        return resultDecodedBuilder
                    }
                    override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.CostGraphDef.Node.OutputInfo.Builder {
                        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        return try Tensorflow.CostGraphDef.Node.OutputInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
                    }
                }

            }

            //Nested type declaration end

            /// The name of the node. Names are globally unique.
            public fileprivate(set) var name:String = ""
            public fileprivate(set) var hasName:Bool = false

            /// The device of the node. Can be empty if the node is mapped to the
            /// default partition or partitioning hasn't been run yet.
            public fileprivate(set) var device:String = ""
            public fileprivate(set) var hasDevice:Bool = false

            /// The id of the node. Node ids are only unique inside a partition.
            public fileprivate(set) var id:Int32 = Int32(0)
            public fileprivate(set) var hasId:Bool = false

            public fileprivate(set) var inputInfo:Array<Tensorflow.CostGraphDef.Node.InputInfo>  = Array<Tensorflow.CostGraphDef.Node.InputInfo>()
            public fileprivate(set) var outputInfo:Array<Tensorflow.CostGraphDef.Node.OutputInfo>  = Array<Tensorflow.CostGraphDef.Node.OutputInfo>()
            /// Temporary memory used by this node.
            public fileprivate(set) var temporaryMemorySize:Int64 = Int64(0)
            public fileprivate(set) var hasTemporaryMemorySize:Bool = false

            public fileprivate(set) var hostTempMemorySize:Int64 = Int64(0)
            public fileprivate(set) var hasHostTempMemorySize:Bool = false

            public fileprivate(set) var deviceTempMemorySize:Int64 = Int64(0)
            public fileprivate(set) var hasDeviceTempMemorySize:Bool = false

            public fileprivate(set) var hostPersistentMemorySize:Int64 = Int64(0)
            public fileprivate(set) var hasHostPersistentMemorySize:Bool = false

            public fileprivate(set) var devicePersistentMemorySize:Int64 = Int64(0)
            public fileprivate(set) var hasDevicePersistentMemorySize:Bool = false

            /// Estimate of the computational cost of this node, in microseconds.
            public fileprivate(set) var computeCost:Int64 = Int64(0)
            public fileprivate(set) var hasComputeCost:Bool = false

            /// Analytical estimate of the computational cost of this node, in
            /// microseconds.
            public fileprivate(set) var computeTime:Int64 = Int64(0)
            public fileprivate(set) var hasComputeTime:Bool = false

            /// Analytical estimate of the memory access cost of this node, in
            /// microseconds.
            public fileprivate(set) var memoryTime:Int64 = Int64(0)
            public fileprivate(set) var hasMemoryTime:Bool = false

            /// If true, the output is permanent: it can't be discarded, because this
            /// node is part of the "final output". Nodes may depend on final nodes.
            public fileprivate(set) var isFinal:Bool = false
            public fileprivate(set) var hasIsFinal:Bool = false

            /// Ids of the control inputs for this node.
            public fileprivate(set) var controlInput:Array<Int32> = Array<Int32>()
            private var controlInputMemoizedSerializedSize:Int32 = -1
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasName {
                    try codedOutputStream.writeString(fieldNumber: 1, value:name)
                }
                if hasDevice {
                    try codedOutputStream.writeString(fieldNumber: 2, value:device)
                }
                if hasId {
                    try codedOutputStream.writeInt32(fieldNumber: 3, value:id)
                }
                for oneElementInputInfo in inputInfo {
                      try codedOutputStream.writeMessage(fieldNumber: 4, value:oneElementInputInfo)
                }
                for oneElementOutputInfo in outputInfo {
                      try codedOutputStream.writeMessage(fieldNumber: 5, value:oneElementOutputInfo)
                }
                if hasTemporaryMemorySize {
                    try codedOutputStream.writeInt64(fieldNumber: 6, value:temporaryMemorySize)
                }
                if hasIsFinal {
                    try codedOutputStream.writeBool(fieldNumber: 7, value:isFinal)
                }
                if !controlInput.isEmpty {
                    try codedOutputStream.writeRawVarint32(value: 66)
                    try codedOutputStream.writeRawVarint32(value: controlInputMemoizedSerializedSize)
                    for oneValuecontrolInput in controlInput {
                        try codedOutputStream.writeInt32NoTag(value: oneValuecontrolInput)
                    }
                }
                if hasComputeCost {
                    try codedOutputStream.writeInt64(fieldNumber: 9, value:computeCost)
                }
                if hasHostTempMemorySize {
                    try codedOutputStream.writeInt64(fieldNumber: 10, value:hostTempMemorySize)
                }
                if hasDeviceTempMemorySize {
                    try codedOutputStream.writeInt64(fieldNumber: 11, value:deviceTempMemorySize)
                }
                if hasHostPersistentMemorySize {
                    try codedOutputStream.writeInt64(fieldNumber: 12, value:hostPersistentMemorySize)
                }
                if hasComputeTime {
                    try codedOutputStream.writeInt64(fieldNumber: 14, value:computeTime)
                }
                if hasMemoryTime {
                    try codedOutputStream.writeInt64(fieldNumber: 15, value:memoryTime)
                }
                if hasDevicePersistentMemorySize {
                    try codedOutputStream.writeInt64(fieldNumber: 16, value:devicePersistentMemorySize)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasName {
                    serialize_size += name.computeStringSize(fieldNumber: 1)
                }
                if hasDevice {
                    serialize_size += device.computeStringSize(fieldNumber: 2)
                }
                if hasId {
                    serialize_size += id.computeInt32Size(fieldNumber: 3)
                }
                for oneElementInputInfo in inputInfo {
                    serialize_size += oneElementInputInfo.computeMessageSize(fieldNumber: 4)
                }
                for oneElementOutputInfo in outputInfo {
                    serialize_size += oneElementOutputInfo.computeMessageSize(fieldNumber: 5)
                }
                if hasTemporaryMemorySize {
                    serialize_size += temporaryMemorySize.computeInt64Size(fieldNumber: 6)
                }
                if hasIsFinal {
                    serialize_size += isFinal.computeBoolSize(fieldNumber: 7)
                }
                var dataSizeControlInput:Int32 = 0
                for oneValuecontrolInput in controlInput {
                    dataSizeControlInput += oneValuecontrolInput.computeInt32SizeNoTag()
                }
                serialize_size += dataSizeControlInput
                if !controlInput.isEmpty {
                    serialize_size += 1
                    serialize_size += dataSizeControlInput.computeInt32SizeNoTag()
                }
                controlInputMemoizedSerializedSize = dataSizeControlInput
                if hasComputeCost {
                    serialize_size += computeCost.computeInt64Size(fieldNumber: 9)
                }
                if hasHostTempMemorySize {
                    serialize_size += hostTempMemorySize.computeInt64Size(fieldNumber: 10)
                }
                if hasDeviceTempMemorySize {
                    serialize_size += deviceTempMemorySize.computeInt64Size(fieldNumber: 11)
                }
                if hasHostPersistentMemorySize {
                    serialize_size += hostPersistentMemorySize.computeInt64Size(fieldNumber: 12)
                }
                if hasComputeTime {
                    serialize_size += computeTime.computeInt64Size(fieldNumber: 14)
                }
                if hasMemoryTime {
                    serialize_size += memoryTime.computeInt64Size(fieldNumber: 15)
                }
                if hasDevicePersistentMemorySize {
                    serialize_size += devicePersistentMemorySize.computeInt64Size(fieldNumber: 16)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.CostGraphDef.Node.Builder {
                return Tensorflow.CostGraphDef.Node.classBuilder() as! Tensorflow.CostGraphDef.Node.Builder
            }
            public func getBuilder() -> Tensorflow.CostGraphDef.Node.Builder {
                return classBuilder() as! Tensorflow.CostGraphDef.Node.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.CostGraphDef.Node.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.CostGraphDef.Node.Builder()
            }
            public func toBuilder() throws -> Tensorflow.CostGraphDef.Node.Builder {
                return try Tensorflow.CostGraphDef.Node.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.CostGraphDef.Node) throws -> Tensorflow.CostGraphDef.Node.Builder {
                return try Tensorflow.CostGraphDef.Node.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasName {
                    jsonMap["name"] = name
                }
                if hasDevice {
                    jsonMap["device"] = device
                }
                if hasId {
                    jsonMap["id"] = Int(id)
                }
                if !inputInfo.isEmpty {
                    var jsonArrayInputInfo:Array<Dictionary<String,Any>> = []
                    for oneValueInputInfo in inputInfo {
                        let ecodedMessageInputInfo = try oneValueInputInfo.encode()
                        jsonArrayInputInfo.append(ecodedMessageInputInfo)
                    }
                    jsonMap["inputInfo"] = jsonArrayInputInfo
                }
                if !outputInfo.isEmpty {
                    var jsonArrayOutputInfo:Array<Dictionary<String,Any>> = []
                    for oneValueOutputInfo in outputInfo {
                        let ecodedMessageOutputInfo = try oneValueOutputInfo.encode()
                        jsonArrayOutputInfo.append(ecodedMessageOutputInfo)
                    }
                    jsonMap["outputInfo"] = jsonArrayOutputInfo
                }
                if hasTemporaryMemorySize {
                    jsonMap["temporaryMemorySize"] = "\(temporaryMemorySize)"
                }
                if hasHostTempMemorySize {
                    jsonMap["hostTempMemorySize"] = "\(hostTempMemorySize)"
                }
                if hasDeviceTempMemorySize {
                    jsonMap["deviceTempMemorySize"] = "\(deviceTempMemorySize)"
                }
                if hasHostPersistentMemorySize {
                    jsonMap["hostPersistentMemorySize"] = "\(hostPersistentMemorySize)"
                }
                if hasDevicePersistentMemorySize {
                    jsonMap["devicePersistentMemorySize"] = "\(devicePersistentMemorySize)"
                }
                if hasComputeCost {
                    jsonMap["computeCost"] = "\(computeCost)"
                }
                if hasComputeTime {
                    jsonMap["computeTime"] = "\(computeTime)"
                }
                if hasMemoryTime {
                    jsonMap["memoryTime"] = "\(memoryTime)"
                }
                if hasIsFinal {
                    jsonMap["isFinal"] = isFinal
                }
                if !controlInput.isEmpty {
                    var jsonArrayControlInput:Array<Int> = []
                    for oneValueControlInput in controlInput {
                        jsonArrayControlInput.append(Int(oneValueControlInput))
                    }
                    jsonMap["controlInput"] = jsonArrayControlInput
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CostGraphDef.Node {
                return try Tensorflow.CostGraphDef.Node.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.CostGraphDef.Node {
                return try Tensorflow.CostGraphDef.Node.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasName {
                    output += "\(indent) name: \(name) \n"
                }
                if hasDevice {
                    output += "\(indent) device: \(device) \n"
                }
                if hasId {
                    output += "\(indent) id: \(id) \n"
                }
                var inputInfoElementIndex:Int = 0
                for oneElementInputInfo in inputInfo {
                    output += "\(indent) inputInfo[\(inputInfoElementIndex)] {\n"
                    output += try oneElementInputInfo.getDescription(indent: "\(indent)  ")
                    output += "\(indent)}\n"
                    inputInfoElementIndex += 1
                }
                var outputInfoElementIndex:Int = 0
                for oneElementOutputInfo in outputInfo {
                    output += "\(indent) outputInfo[\(outputInfoElementIndex)] {\n"
                    output += try oneElementOutputInfo.getDescription(indent: "\(indent)  ")
                    output += "\(indent)}\n"
                    outputInfoElementIndex += 1
                }
                if hasTemporaryMemorySize {
                    output += "\(indent) temporaryMemorySize: \(temporaryMemorySize) \n"
                }
                if hasIsFinal {
                    output += "\(indent) isFinal: \(isFinal) \n"
                }
                var controlInputElementIndex:Int = 0
                for oneValueControlInput in controlInput  {
                    output += "\(indent) controlInput[\(controlInputElementIndex)]: \(oneValueControlInput)\n"
                    controlInputElementIndex += 1
                }
                if hasComputeCost {
                    output += "\(indent) computeCost: \(computeCost) \n"
                }
                if hasHostTempMemorySize {
                    output += "\(indent) hostTempMemorySize: \(hostTempMemorySize) \n"
                }
                if hasDeviceTempMemorySize {
                    output += "\(indent) deviceTempMemorySize: \(deviceTempMemorySize) \n"
                }
                if hasHostPersistentMemorySize {
                    output += "\(indent) hostPersistentMemorySize: \(hostPersistentMemorySize) \n"
                }
                if hasComputeTime {
                    output += "\(indent) computeTime: \(computeTime) \n"
                }
                if hasMemoryTime {
                    output += "\(indent) memoryTime: \(memoryTime) \n"
                }
                if hasDevicePersistentMemorySize {
                    output += "\(indent) devicePersistentMemorySize: \(devicePersistentMemorySize) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasName {
                        hashCode = (hashCode &* 31) &+ name.hashValue
                    }
                    if hasDevice {
                        hashCode = (hashCode &* 31) &+ device.hashValue
                    }
                    if hasId {
                        hashCode = (hashCode &* 31) &+ id.hashValue
                    }
                    for oneElementInputInfo in inputInfo {
                        hashCode = (hashCode &* 31) &+ oneElementInputInfo.hashValue
                    }
                    for oneElementOutputInfo in outputInfo {
                        hashCode = (hashCode &* 31) &+ oneElementOutputInfo.hashValue
                    }
                    if hasTemporaryMemorySize {
                        hashCode = (hashCode &* 31) &+ temporaryMemorySize.hashValue
                    }
                    if hasIsFinal {
                        hashCode = (hashCode &* 31) &+ isFinal.hashValue
                    }
                    for oneValueControlInput in controlInput {
                        hashCode = (hashCode &* 31) &+ oneValueControlInput.hashValue
                    }
                    if hasComputeCost {
                        hashCode = (hashCode &* 31) &+ computeCost.hashValue
                    }
                    if hasHostTempMemorySize {
                        hashCode = (hashCode &* 31) &+ hostTempMemorySize.hashValue
                    }
                    if hasDeviceTempMemorySize {
                        hashCode = (hashCode &* 31) &+ deviceTempMemorySize.hashValue
                    }
                    if hasHostPersistentMemorySize {
                        hashCode = (hashCode &* 31) &+ hostPersistentMemorySize.hashValue
                    }
                    if hasComputeTime {
                        hashCode = (hashCode &* 31) &+ computeTime.hashValue
                    }
                    if hasMemoryTime {
                        hashCode = (hashCode &* 31) &+ memoryTime.hashValue
                    }
                    if hasDevicePersistentMemorySize {
                        hashCode = (hashCode &* 31) &+ devicePersistentMemorySize.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.CostGraphDef.Node"
            }
            override public func className() -> String {
                return "Tensorflow.CostGraphDef.Node"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.CostGraphDef.Node = Tensorflow.CostGraphDef.Node()
                public func getMessage() -> Tensorflow.CostGraphDef.Node {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                /// The name of the node. Names are globally unique.
                public var name:String {
                    get {
                        return builderResult.name
                    }
                    set (value) {
                        builderResult.hasName = true
                        builderResult.name = value
                    }
                }
                public var hasName:Bool {
                    get {
                        return builderResult.hasName
                    }
                }
                @discardableResult
                public func setName(_ value:String) -> Tensorflow.CostGraphDef.Node.Builder {
                    self.name = value
                    return self
                }
                @discardableResult
                public func clearName() -> Tensorflow.CostGraphDef.Node.Builder{
                    builderResult.hasName = false
                    builderResult.name = ""
                    return self
                }
                /// The device of the node. Can be empty if the node is mapped to the
                /// default partition or partitioning hasn't been run yet.
                public var device:String {
                    get {
                        return builderResult.device
                    }
                    set (value) {
                        builderResult.hasDevice = true
                        builderResult.device = value
                    }
                }
                public var hasDevice:Bool {
                    get {
                        return builderResult.hasDevice
                    }
                }
                @discardableResult
                public func setDevice(_ value:String) -> Tensorflow.CostGraphDef.Node.Builder {
                    self.device = value
                    return self
                }
                @discardableResult
                public func clearDevice() -> Tensorflow.CostGraphDef.Node.Builder{
                    builderResult.hasDevice = false
                    builderResult.device = ""
                    return self
                }
                /// The id of the node. Node ids are only unique inside a partition.
                public var id:Int32 {
                    get {
                        return builderResult.id
                    }
                    set (value) {
                        builderResult.hasId = true
                        builderResult.id = value
                    }
                }
                public var hasId:Bool {
                    get {
                        return builderResult.hasId
                    }
                }
                @discardableResult
                public func setId(_ value:Int32) -> Tensorflow.CostGraphDef.Node.Builder {
                    self.id = value
                    return self
                }
                @discardableResult
                public func clearId() -> Tensorflow.CostGraphDef.Node.Builder{
                    builderResult.hasId = false
                    builderResult.id = Int32(0)
                    return self
                }
                public var inputInfo:Array<Tensorflow.CostGraphDef.Node.InputInfo> {
                    get {
                        return builderResult.inputInfo
                    }
                    set (value) {
                        builderResult.inputInfo = value
                    }
                }
                @discardableResult
                public func setInputInfo(_ value:Array<Tensorflow.CostGraphDef.Node.InputInfo>) -> Tensorflow.CostGraphDef.Node.Builder {
                    self.inputInfo = value
                    return self
                }
                @discardableResult
                public func clearInputInfo() -> Tensorflow.CostGraphDef.Node.Builder {
                    builderResult.inputInfo.removeAll(keepingCapacity: false)
                    return self
                }
                public var outputInfo:Array<Tensorflow.CostGraphDef.Node.OutputInfo> {
                    get {
                        return builderResult.outputInfo
                    }
                    set (value) {
                        builderResult.outputInfo = value
                    }
                }
                @discardableResult
                public func setOutputInfo(_ value:Array<Tensorflow.CostGraphDef.Node.OutputInfo>) -> Tensorflow.CostGraphDef.Node.Builder {
                    self.outputInfo = value
                    return self
                }
                @discardableResult
                public func clearOutputInfo() -> Tensorflow.CostGraphDef.Node.Builder {
                    builderResult.outputInfo.removeAll(keepingCapacity: false)
                    return self
                }
                /// Temporary memory used by this node.
                public var temporaryMemorySize:Int64 {
                    get {
                        return builderResult.temporaryMemorySize
                    }
                    set (value) {
                        builderResult.hasTemporaryMemorySize = true
                        builderResult.temporaryMemorySize = value
                    }
                }
                public var hasTemporaryMemorySize:Bool {
                    get {
                        return builderResult.hasTemporaryMemorySize
                    }
                }
                @discardableResult
                public func setTemporaryMemorySize(_ value:Int64) -> Tensorflow.CostGraphDef.Node.Builder {
                    self.temporaryMemorySize = value
                    return self
                }
                @discardableResult
                public func clearTemporaryMemorySize() -> Tensorflow.CostGraphDef.Node.Builder{
                    builderResult.hasTemporaryMemorySize = false
                    builderResult.temporaryMemorySize = Int64(0)
                    return self
                }
                public var hostTempMemorySize:Int64 {
                    get {
                        return builderResult.hostTempMemorySize
                    }
                    set (value) {
                        builderResult.hasHostTempMemorySize = true
                        builderResult.hostTempMemorySize = value
                    }
                }
                public var hasHostTempMemorySize:Bool {
                    get {
                        return builderResult.hasHostTempMemorySize
                    }
                }
                @discardableResult
                public func setHostTempMemorySize(_ value:Int64) -> Tensorflow.CostGraphDef.Node.Builder {
                    self.hostTempMemorySize = value
                    return self
                }
                @discardableResult
                public func clearHostTempMemorySize() -> Tensorflow.CostGraphDef.Node.Builder{
                    builderResult.hasHostTempMemorySize = false
                    builderResult.hostTempMemorySize = Int64(0)
                    return self
                }
                public var deviceTempMemorySize:Int64 {
                    get {
                        return builderResult.deviceTempMemorySize
                    }
                    set (value) {
                        builderResult.hasDeviceTempMemorySize = true
                        builderResult.deviceTempMemorySize = value
                    }
                }
                public var hasDeviceTempMemorySize:Bool {
                    get {
                        return builderResult.hasDeviceTempMemorySize
                    }
                }
                @discardableResult
                public func setDeviceTempMemorySize(_ value:Int64) -> Tensorflow.CostGraphDef.Node.Builder {
                    self.deviceTempMemorySize = value
                    return self
                }
                @discardableResult
                public func clearDeviceTempMemorySize() -> Tensorflow.CostGraphDef.Node.Builder{
                    builderResult.hasDeviceTempMemorySize = false
                    builderResult.deviceTempMemorySize = Int64(0)
                    return self
                }
                public var hostPersistentMemorySize:Int64 {
                    get {
                        return builderResult.hostPersistentMemorySize
                    }
                    set (value) {
                        builderResult.hasHostPersistentMemorySize = true
                        builderResult.hostPersistentMemorySize = value
                    }
                }
                public var hasHostPersistentMemorySize:Bool {
                    get {
                        return builderResult.hasHostPersistentMemorySize
                    }
                }
                @discardableResult
                public func setHostPersistentMemorySize(_ value:Int64) -> Tensorflow.CostGraphDef.Node.Builder {
                    self.hostPersistentMemorySize = value
                    return self
                }
                @discardableResult
                public func clearHostPersistentMemorySize() -> Tensorflow.CostGraphDef.Node.Builder{
                    builderResult.hasHostPersistentMemorySize = false
                    builderResult.hostPersistentMemorySize = Int64(0)
                    return self
                }
                public var devicePersistentMemorySize:Int64 {
                    get {
                        return builderResult.devicePersistentMemorySize
                    }
                    set (value) {
                        builderResult.hasDevicePersistentMemorySize = true
                        builderResult.devicePersistentMemorySize = value
                    }
                }
                public var hasDevicePersistentMemorySize:Bool {
                    get {
                        return builderResult.hasDevicePersistentMemorySize
                    }
                }
                @discardableResult
                public func setDevicePersistentMemorySize(_ value:Int64) -> Tensorflow.CostGraphDef.Node.Builder {
                    self.devicePersistentMemorySize = value
                    return self
                }
                @discardableResult
                public func clearDevicePersistentMemorySize() -> Tensorflow.CostGraphDef.Node.Builder{
                    builderResult.hasDevicePersistentMemorySize = false
                    builderResult.devicePersistentMemorySize = Int64(0)
                    return self
                }
                /// Estimate of the computational cost of this node, in microseconds.
                public var computeCost:Int64 {
                    get {
                        return builderResult.computeCost
                    }
                    set (value) {
                        builderResult.hasComputeCost = true
                        builderResult.computeCost = value
                    }
                }
                public var hasComputeCost:Bool {
                    get {
                        return builderResult.hasComputeCost
                    }
                }
                @discardableResult
                public func setComputeCost(_ value:Int64) -> Tensorflow.CostGraphDef.Node.Builder {
                    self.computeCost = value
                    return self
                }
                @discardableResult
                public func clearComputeCost() -> Tensorflow.CostGraphDef.Node.Builder{
                    builderResult.hasComputeCost = false
                    builderResult.computeCost = Int64(0)
                    return self
                }
                /// Analytical estimate of the computational cost of this node, in
                /// microseconds.
                public var computeTime:Int64 {
                    get {
                        return builderResult.computeTime
                    }
                    set (value) {
                        builderResult.hasComputeTime = true
                        builderResult.computeTime = value
                    }
                }
                public var hasComputeTime:Bool {
                    get {
                        return builderResult.hasComputeTime
                    }
                }
                @discardableResult
                public func setComputeTime(_ value:Int64) -> Tensorflow.CostGraphDef.Node.Builder {
                    self.computeTime = value
                    return self
                }
                @discardableResult
                public func clearComputeTime() -> Tensorflow.CostGraphDef.Node.Builder{
                    builderResult.hasComputeTime = false
                    builderResult.computeTime = Int64(0)
                    return self
                }
                /// Analytical estimate of the memory access cost of this node, in
                /// microseconds.
                public var memoryTime:Int64 {
                    get {
                        return builderResult.memoryTime
                    }
                    set (value) {
                        builderResult.hasMemoryTime = true
                        builderResult.memoryTime = value
                    }
                }
                public var hasMemoryTime:Bool {
                    get {
                        return builderResult.hasMemoryTime
                    }
                }
                @discardableResult
                public func setMemoryTime(_ value:Int64) -> Tensorflow.CostGraphDef.Node.Builder {
                    self.memoryTime = value
                    return self
                }
                @discardableResult
                public func clearMemoryTime() -> Tensorflow.CostGraphDef.Node.Builder{
                    builderResult.hasMemoryTime = false
                    builderResult.memoryTime = Int64(0)
                    return self
                }
                /// If true, the output is permanent: it can't be discarded, because this
                /// node is part of the "final output". Nodes may depend on final nodes.
                public var isFinal:Bool {
                    get {
                        return builderResult.isFinal
                    }
                    set (value) {
                        builderResult.hasIsFinal = true
                        builderResult.isFinal = value
                    }
                }
                public var hasIsFinal:Bool {
                    get {
                        return builderResult.hasIsFinal
                    }
                }
                @discardableResult
                public func setIsFinal(_ value:Bool) -> Tensorflow.CostGraphDef.Node.Builder {
                    self.isFinal = value
                    return self
                }
                @discardableResult
                public func clearIsFinal() -> Tensorflow.CostGraphDef.Node.Builder{
                    builderResult.hasIsFinal = false
                    builderResult.isFinal = false
                    return self
                }
                /// Ids of the control inputs for this node.
                public var controlInput:Array<Int32> {
                    get {
                        return builderResult.controlInput
                    }
                    set (array) {
                        builderResult.controlInput = array
                    }
                }
                @discardableResult
                public func setControlInput(_ value:Array<Int32>) -> Tensorflow.CostGraphDef.Node.Builder {
                    self.controlInput = value
                    return self
                }
                @discardableResult
                public func clearControlInput() -> Tensorflow.CostGraphDef.Node.Builder {
                    builderResult.controlInput.removeAll(keepingCapacity: false)
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.CostGraphDef.Node.Builder {
                    builderResult = Tensorflow.CostGraphDef.Node()
                    return self
                }
                override public func clone() throws -> Tensorflow.CostGraphDef.Node.Builder {
                    return try Tensorflow.CostGraphDef.Node.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.CostGraphDef.Node {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.CostGraphDef.Node {
                    let returnMe:Tensorflow.CostGraphDef.Node = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.CostGraphDef.Node) throws -> Tensorflow.CostGraphDef.Node.Builder {
                    if other == Tensorflow.CostGraphDef.Node() {
                        return self
                    }
                    if other.hasName {
                        name = other.name
                    }
                    if other.hasDevice {
                        device = other.device
                    }
                    if other.hasId {
                        id = other.id
                    }
                    if !other.inputInfo.isEmpty  {
                         builderResult.inputInfo += other.inputInfo
                    }
                    if !other.outputInfo.isEmpty  {
                         builderResult.outputInfo += other.outputInfo
                    }
                    if other.hasTemporaryMemorySize {
                        temporaryMemorySize = other.temporaryMemorySize
                    }
                    if other.hasHostTempMemorySize {
                        hostTempMemorySize = other.hostTempMemorySize
                    }
                    if other.hasDeviceTempMemorySize {
                        deviceTempMemorySize = other.deviceTempMemorySize
                    }
                    if other.hasHostPersistentMemorySize {
                        hostPersistentMemorySize = other.hostPersistentMemorySize
                    }
                    if other.hasDevicePersistentMemorySize {
                        devicePersistentMemorySize = other.devicePersistentMemorySize
                    }
                    if other.hasComputeCost {
                        computeCost = other.computeCost
                    }
                    if other.hasComputeTime {
                        computeTime = other.computeTime
                    }
                    if other.hasMemoryTime {
                        memoryTime = other.memoryTime
                    }
                    if other.hasIsFinal {
                        isFinal = other.isFinal
                    }
                    if !other.controlInput.isEmpty {
                        builderResult.controlInput += other.controlInput
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CostGraphDef.Node.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CostGraphDef.Node.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            name = try codedInputStream.readString()

                        case 18:
                            device = try codedInputStream.readString()

                        case 24:
                            id = try codedInputStream.readInt32()

                        case 34:
                            let subBuilder = Tensorflow.CostGraphDef.Node.InputInfo.Builder()
                            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                            inputInfo.append(subBuilder.buildPartial())

                        case 42:
                            let subBuilder = Tensorflow.CostGraphDef.Node.OutputInfo.Builder()
                            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                            outputInfo.append(subBuilder.buildPartial())

                        case 48:
                            temporaryMemorySize = try codedInputStream.readInt64()

                        case 56:
                            isFinal = try codedInputStream.readBool()

                        case 66:
                            let length = Int(try codedInputStream.readRawVarint32())
                            let limit = try codedInputStream.pushLimit(byteLimit: length)
                            while (codedInputStream.bytesUntilLimit() > 0) {
                                builderResult.controlInput.append(try codedInputStream.readInt32())
                            }
                            codedInputStream.popLimit(oldLimit: limit)

                        case 72:
                            computeCost = try codedInputStream.readInt64()

                        case 80:
                            hostTempMemorySize = try codedInputStream.readInt64()

                        case 88:
                            deviceTempMemorySize = try codedInputStream.readInt64()

                        case 96:
                            hostPersistentMemorySize = try codedInputStream.readInt64()

                        case 112:
                            computeTime = try codedInputStream.readInt64()

                        case 120:
                            memoryTime = try codedInputStream.readInt64()

                        case 128:
                            devicePersistentMemorySize = try codedInputStream.readInt64()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CostGraphDef.Node.Builder {
                    let resultDecodedBuilder = Tensorflow.CostGraphDef.Node.Builder()
                    if let jsonValueName = jsonMap["name"] as? String {
                        resultDecodedBuilder.name = jsonValueName
                    }
                    if let jsonValueDevice = jsonMap["device"] as? String {
                        resultDecodedBuilder.device = jsonValueDevice
                    }
                    if let jsonValueId = jsonMap["id"] as? Int {
                        resultDecodedBuilder.id = Int32(jsonValueId)
                    } else if let jsonValueId = jsonMap["id"] as? String {
                        resultDecodedBuilder.id = Int32(jsonValueId)!
                    }
                    if let jsonValueInputInfo = jsonMap["inputInfo"] as? Array<Dictionary<String,Any>> {
                        var jsonArrayInputInfo:Array<Tensorflow.CostGraphDef.Node.InputInfo> = []
                        for oneValueInputInfo in jsonValueInputInfo {
                            let messageFromStringInputInfo = try Tensorflow.CostGraphDef.Node.InputInfo.Builder.decodeToBuilder(jsonMap:oneValueInputInfo).build()

                            jsonArrayInputInfo.append(messageFromStringInputInfo)
                        }
                        resultDecodedBuilder.inputInfo = jsonArrayInputInfo
                    }
                    if let jsonValueOutputInfo = jsonMap["outputInfo"] as? Array<Dictionary<String,Any>> {
                        var jsonArrayOutputInfo:Array<Tensorflow.CostGraphDef.Node.OutputInfo> = []
                        for oneValueOutputInfo in jsonValueOutputInfo {
                            let messageFromStringOutputInfo = try Tensorflow.CostGraphDef.Node.OutputInfo.Builder.decodeToBuilder(jsonMap:oneValueOutputInfo).build()

                            jsonArrayOutputInfo.append(messageFromStringOutputInfo)
                        }
                        resultDecodedBuilder.outputInfo = jsonArrayOutputInfo
                    }
                    if let jsonValueTemporaryMemorySize = jsonMap["temporaryMemorySize"] as? String {
                        resultDecodedBuilder.temporaryMemorySize = Int64(jsonValueTemporaryMemorySize)!
                    } else if let jsonValueTemporaryMemorySize = jsonMap["temporaryMemorySize"] as? Int {
                        resultDecodedBuilder.temporaryMemorySize = Int64(jsonValueTemporaryMemorySize)
                    }
                    if let jsonValueHostTempMemorySize = jsonMap["hostTempMemorySize"] as? String {
                        resultDecodedBuilder.hostTempMemorySize = Int64(jsonValueHostTempMemorySize)!
                    } else if let jsonValueHostTempMemorySize = jsonMap["hostTempMemorySize"] as? Int {
                        resultDecodedBuilder.hostTempMemorySize = Int64(jsonValueHostTempMemorySize)
                    }
                    if let jsonValueDeviceTempMemorySize = jsonMap["deviceTempMemorySize"] as? String {
                        resultDecodedBuilder.deviceTempMemorySize = Int64(jsonValueDeviceTempMemorySize)!
                    } else if let jsonValueDeviceTempMemorySize = jsonMap["deviceTempMemorySize"] as? Int {
                        resultDecodedBuilder.deviceTempMemorySize = Int64(jsonValueDeviceTempMemorySize)
                    }
                    if let jsonValueHostPersistentMemorySize = jsonMap["hostPersistentMemorySize"] as? String {
                        resultDecodedBuilder.hostPersistentMemorySize = Int64(jsonValueHostPersistentMemorySize)!
                    } else if let jsonValueHostPersistentMemorySize = jsonMap["hostPersistentMemorySize"] as? Int {
                        resultDecodedBuilder.hostPersistentMemorySize = Int64(jsonValueHostPersistentMemorySize)
                    }
                    if let jsonValueDevicePersistentMemorySize = jsonMap["devicePersistentMemorySize"] as? String {
                        resultDecodedBuilder.devicePersistentMemorySize = Int64(jsonValueDevicePersistentMemorySize)!
                    } else if let jsonValueDevicePersistentMemorySize = jsonMap["devicePersistentMemorySize"] as? Int {
                        resultDecodedBuilder.devicePersistentMemorySize = Int64(jsonValueDevicePersistentMemorySize)
                    }
                    if let jsonValueComputeCost = jsonMap["computeCost"] as? String {
                        resultDecodedBuilder.computeCost = Int64(jsonValueComputeCost)!
                    } else if let jsonValueComputeCost = jsonMap["computeCost"] as? Int {
                        resultDecodedBuilder.computeCost = Int64(jsonValueComputeCost)
                    }
                    if let jsonValueComputeTime = jsonMap["computeTime"] as? String {
                        resultDecodedBuilder.computeTime = Int64(jsonValueComputeTime)!
                    } else if let jsonValueComputeTime = jsonMap["computeTime"] as? Int {
                        resultDecodedBuilder.computeTime = Int64(jsonValueComputeTime)
                    }
                    if let jsonValueMemoryTime = jsonMap["memoryTime"] as? String {
                        resultDecodedBuilder.memoryTime = Int64(jsonValueMemoryTime)!
                    } else if let jsonValueMemoryTime = jsonMap["memoryTime"] as? Int {
                        resultDecodedBuilder.memoryTime = Int64(jsonValueMemoryTime)
                    }
                    if let jsonValueIsFinal = jsonMap["isFinal"] as? Bool {
                        resultDecodedBuilder.isFinal = jsonValueIsFinal
                    }
                    if let jsonValueControlInput = jsonMap["controlInput"] as? Array<Int> {
                        var jsonArrayControlInput:Array<Int32> = []
                        for oneValueControlInput in jsonValueControlInput {
                            jsonArrayControlInput.append(Int32(oneValueControlInput))
                        }
                        resultDecodedBuilder.controlInput = jsonArrayControlInput
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.CostGraphDef.Node.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.CostGraphDef.Node.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        public fileprivate(set) var node:Array<Tensorflow.CostGraphDef.Node>  = Array<Tensorflow.CostGraphDef.Node>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementNode in node {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementNode)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementNode in node {
                serialize_size += oneElementNode.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.CostGraphDef.Builder {
            return Tensorflow.CostGraphDef.classBuilder() as! Tensorflow.CostGraphDef.Builder
        }
        public func getBuilder() -> Tensorflow.CostGraphDef.Builder {
            return classBuilder() as! Tensorflow.CostGraphDef.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.CostGraphDef.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.CostGraphDef.Builder()
        }
        public func toBuilder() throws -> Tensorflow.CostGraphDef.Builder {
            return try Tensorflow.CostGraphDef.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.CostGraphDef) throws -> Tensorflow.CostGraphDef.Builder {
            return try Tensorflow.CostGraphDef.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !node.isEmpty {
                var jsonArrayNode:Array<Dictionary<String,Any>> = []
                for oneValueNode in node {
                    let ecodedMessageNode = try oneValueNode.encode()
                    jsonArrayNode.append(ecodedMessageNode)
                }
                jsonMap["node"] = jsonArrayNode
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CostGraphDef {
            return try Tensorflow.CostGraphDef.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.CostGraphDef {
            return try Tensorflow.CostGraphDef.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var nodeElementIndex:Int = 0
            for oneElementNode in node {
                output += "\(indent) node[\(nodeElementIndex)] {\n"
                output += try oneElementNode.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                nodeElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementNode in node {
                    hashCode = (hashCode &* 31) &+ oneElementNode.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.CostGraphDef"
        }
        override public func className() -> String {
            return "Tensorflow.CostGraphDef"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.CostGraphDef = Tensorflow.CostGraphDef()
            public func getMessage() -> Tensorflow.CostGraphDef {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var node:Array<Tensorflow.CostGraphDef.Node> {
                get {
                    return builderResult.node
                }
                set (value) {
                    builderResult.node = value
                }
            }
            @discardableResult
            public func setNode(_ value:Array<Tensorflow.CostGraphDef.Node>) -> Tensorflow.CostGraphDef.Builder {
                self.node = value
                return self
            }
            @discardableResult
            public func clearNode() -> Tensorflow.CostGraphDef.Builder {
                builderResult.node.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.CostGraphDef.Builder {
                builderResult = Tensorflow.CostGraphDef()
                return self
            }
            override public func clone() throws -> Tensorflow.CostGraphDef.Builder {
                return try Tensorflow.CostGraphDef.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.CostGraphDef {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.CostGraphDef {
                let returnMe:Tensorflow.CostGraphDef = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.CostGraphDef) throws -> Tensorflow.CostGraphDef.Builder {
                if other == Tensorflow.CostGraphDef() {
                    return self
                }
                if !other.node.isEmpty  {
                     builderResult.node += other.node
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CostGraphDef.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CostGraphDef.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Tensorflow.CostGraphDef.Node.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        node.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CostGraphDef.Builder {
                let resultDecodedBuilder = Tensorflow.CostGraphDef.Builder()
                if let jsonValueNode = jsonMap["node"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayNode:Array<Tensorflow.CostGraphDef.Node> = []
                    for oneValueNode in jsonValueNode {
                        let messageFromStringNode = try Tensorflow.CostGraphDef.Node.Builder.decodeToBuilder(jsonMap:oneValueNode).build()

                        jsonArrayNode.append(messageFromStringNode)
                    }
                    resultDecodedBuilder.node = jsonArrayNode
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.CostGraphDef.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.CostGraphDef.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.CostGraphDef: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.CostGraphDef> {
        var mergedArray = Array<Tensorflow.CostGraphDef>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.CostGraphDef? {
        return try Tensorflow.CostGraphDef.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.CostGraphDef {
        return try Tensorflow.CostGraphDef.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.CostGraphRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CostGraphDef {
        return try Tensorflow.CostGraphDef.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.CostGraphDef {
        return try Tensorflow.CostGraphDef.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CostGraphDef {
        return try Tensorflow.CostGraphDef.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CostGraphDef {
        return try Tensorflow.CostGraphDef.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CostGraphDef {
        return try Tensorflow.CostGraphDef.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "node": return self.node
        default: return nil
        }
    }
}
extension Tensorflow.CostGraphDef.Node: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.CostGraphDef.Node> {
        var mergedArray = Array<Tensorflow.CostGraphDef.Node>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.CostGraphDef.Node? {
        return try Tensorflow.CostGraphDef.Node.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.CostGraphDef.Node {
        return try Tensorflow.CostGraphDef.Node.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.CostGraphRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CostGraphDef.Node {
        return try Tensorflow.CostGraphDef.Node.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.CostGraphDef.Node {
        return try Tensorflow.CostGraphDef.Node.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CostGraphDef.Node {
        return try Tensorflow.CostGraphDef.Node.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CostGraphDef.Node {
        return try Tensorflow.CostGraphDef.Node.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CostGraphDef.Node {
        return try Tensorflow.CostGraphDef.Node.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "name": return self.name
        case "device": return self.device
        case "id": return self.id
        case "inputInfo": return self.inputInfo
        case "outputInfo": return self.outputInfo
        case "temporaryMemorySize": return self.temporaryMemorySize
        case "hostTempMemorySize": return self.hostTempMemorySize
        case "deviceTempMemorySize": return self.deviceTempMemorySize
        case "hostPersistentMemorySize": return self.hostPersistentMemorySize
        case "devicePersistentMemorySize": return self.devicePersistentMemorySize
        case "computeCost": return self.computeCost
        case "computeTime": return self.computeTime
        case "memoryTime": return self.memoryTime
        case "isFinal": return self.isFinal
        case "controlInput": return self.controlInput
        default: return nil
        }
    }
}
extension Tensorflow.CostGraphDef.Node.InputInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.CostGraphDef.Node.InputInfo> {
        var mergedArray = Array<Tensorflow.CostGraphDef.Node.InputInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.CostGraphDef.Node.InputInfo? {
        return try Tensorflow.CostGraphDef.Node.InputInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.CostGraphDef.Node.InputInfo {
        return try Tensorflow.CostGraphDef.Node.InputInfo.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.CostGraphRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CostGraphDef.Node.InputInfo {
        return try Tensorflow.CostGraphDef.Node.InputInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.CostGraphDef.Node.InputInfo {
        return try Tensorflow.CostGraphDef.Node.InputInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CostGraphDef.Node.InputInfo {
        return try Tensorflow.CostGraphDef.Node.InputInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CostGraphDef.Node.InputInfo {
        return try Tensorflow.CostGraphDef.Node.InputInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CostGraphDef.Node.InputInfo {
        return try Tensorflow.CostGraphDef.Node.InputInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "precedingNode": return self.precedingNode
        case "precedingPort": return self.precedingPort
        default: return nil
        }
    }
}
extension Tensorflow.CostGraphDef.Node.OutputInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.CostGraphDef.Node.OutputInfo> {
        var mergedArray = Array<Tensorflow.CostGraphDef.Node.OutputInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.CostGraphDef.Node.OutputInfo? {
        return try Tensorflow.CostGraphDef.Node.OutputInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.CostGraphDef.Node.OutputInfo {
        return try Tensorflow.CostGraphDef.Node.OutputInfo.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.CostGraphRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CostGraphDef.Node.OutputInfo {
        return try Tensorflow.CostGraphDef.Node.OutputInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.CostGraphDef.Node.OutputInfo {
        return try Tensorflow.CostGraphDef.Node.OutputInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CostGraphDef.Node.OutputInfo {
        return try Tensorflow.CostGraphDef.Node.OutputInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CostGraphDef.Node.OutputInfo {
        return try Tensorflow.CostGraphDef.Node.OutputInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CostGraphDef.Node.OutputInfo {
        return try Tensorflow.CostGraphDef.Node.OutputInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "size": return self.size
        case "aliasInputPort": return self.aliasInputPort
        case "shape": return self.shape
        case "dtype": return self.dtype
        default: return nil
        }
    }
}
extension Tensorflow.CostGraphDef.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "node": return self.node
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "node":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.CostGraphDef.Node> else {
                    return
                }
                self.node = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.CostGraphDef.Node.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "name": return self.name
            case "device": return self.device
            case "id": return self.id
            case "inputInfo": return self.inputInfo
            case "outputInfo": return self.outputInfo
            case "temporaryMemorySize": return self.temporaryMemorySize
            case "hostTempMemorySize": return self.hostTempMemorySize
            case "deviceTempMemorySize": return self.deviceTempMemorySize
            case "hostPersistentMemorySize": return self.hostPersistentMemorySize
            case "devicePersistentMemorySize": return self.devicePersistentMemorySize
            case "computeCost": return self.computeCost
            case "computeTime": return self.computeTime
            case "memoryTime": return self.memoryTime
            case "isFinal": return self.isFinal
            case "controlInput": return self.controlInput
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "device":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.device = newSubscriptValue
            case "id":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.id = newSubscriptValue
            case "inputInfo":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.CostGraphDef.Node.InputInfo> else {
                    return
                }
                self.inputInfo = newSubscriptValue
            case "outputInfo":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.CostGraphDef.Node.OutputInfo> else {
                    return
                }
                self.outputInfo = newSubscriptValue
            case "temporaryMemorySize":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.temporaryMemorySize = newSubscriptValue
            case "hostTempMemorySize":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.hostTempMemorySize = newSubscriptValue
            case "deviceTempMemorySize":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.deviceTempMemorySize = newSubscriptValue
            case "hostPersistentMemorySize":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.hostPersistentMemorySize = newSubscriptValue
            case "devicePersistentMemorySize":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.devicePersistentMemorySize = newSubscriptValue
            case "computeCost":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.computeCost = newSubscriptValue
            case "computeTime":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.computeTime = newSubscriptValue
            case "memoryTime":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.memoryTime = newSubscriptValue
            case "isFinal":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.isFinal = newSubscriptValue
            case "controlInput":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int32> else {
                    return
                }
                self.controlInput = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.CostGraphDef.Node.InputInfo.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "precedingNode": return self.precedingNode
            case "precedingPort": return self.precedingPort
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "precedingNode":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.precedingNode = newSubscriptValue
            case "precedingPort":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.precedingPort = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.CostGraphDef.Node.OutputInfo.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "size": return self.size
            case "aliasInputPort": return self.aliasInputPort
            case "shape": return self.shape
            case "dtype": return self.dtype
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "size":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.size = newSubscriptValue
            case "aliasInputPort":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.aliasInputPort = newSubscriptValue
            case "shape":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.TensorShapeProto else {
                    return
                }
                self.shape = newSubscriptValue
            case "dtype":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.DataType else {
                    return
                }
                self.dtype = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

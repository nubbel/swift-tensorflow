/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "worker.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { }

public extension Tensorflow {
    public struct WorkerRoot {
        public static let `default` = WorkerRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Google.Protobuf.AnyRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.CostGraphRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.StepStatsRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.DeviceAttributesRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.GraphRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.TensorRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.ConfigRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.NamedTensorRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.TensorflowServerRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    final public class GetStatusRequest : GeneratedMessage {

        public static func == (lhs: Tensorflow.GetStatusRequest, rhs: Tensorflow.GetStatusRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.GetStatusRequest.Builder {
            return Tensorflow.GetStatusRequest.classBuilder() as! Tensorflow.GetStatusRequest.Builder
        }
        public func getBuilder() -> Tensorflow.GetStatusRequest.Builder {
            return classBuilder() as! Tensorflow.GetStatusRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.GetStatusRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.GetStatusRequest.Builder()
        }
        public func toBuilder() throws -> Tensorflow.GetStatusRequest.Builder {
            return try Tensorflow.GetStatusRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.GetStatusRequest) throws -> Tensorflow.GetStatusRequest.Builder {
            return try Tensorflow.GetStatusRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.GetStatusRequest {
            return try Tensorflow.GetStatusRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.GetStatusRequest {
            return try Tensorflow.GetStatusRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.GetStatusRequest"
        }
        override public func className() -> String {
            return "Tensorflow.GetStatusRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.GetStatusRequest = Tensorflow.GetStatusRequest()
            public func getMessage() -> Tensorflow.GetStatusRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.GetStatusRequest.Builder {
                builderResult = Tensorflow.GetStatusRequest()
                return self
            }
            override public func clone() throws -> Tensorflow.GetStatusRequest.Builder {
                return try Tensorflow.GetStatusRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.GetStatusRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.GetStatusRequest {
                let returnMe:Tensorflow.GetStatusRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.GetStatusRequest) throws -> Tensorflow.GetStatusRequest.Builder {
                if other == Tensorflow.GetStatusRequest() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.GetStatusRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GetStatusRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.GetStatusRequest.Builder {
                let resultDecodedBuilder = Tensorflow.GetStatusRequest.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.GetStatusRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.GetStatusRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class GetStatusResponse : GeneratedMessage {

        public static func == (lhs: Tensorflow.GetStatusResponse, rhs: Tensorflow.GetStatusResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.deviceAttributes == rhs.deviceAttributes)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var deviceAttributes:Array<Tensorflow.DeviceAttributes>  = Array<Tensorflow.DeviceAttributes>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementDeviceAttributes in deviceAttributes {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementDeviceAttributes)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementDeviceAttributes in deviceAttributes {
                serialize_size += oneElementDeviceAttributes.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.GetStatusResponse.Builder {
            return Tensorflow.GetStatusResponse.classBuilder() as! Tensorflow.GetStatusResponse.Builder
        }
        public func getBuilder() -> Tensorflow.GetStatusResponse.Builder {
            return classBuilder() as! Tensorflow.GetStatusResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.GetStatusResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.GetStatusResponse.Builder()
        }
        public func toBuilder() throws -> Tensorflow.GetStatusResponse.Builder {
            return try Tensorflow.GetStatusResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.GetStatusResponse) throws -> Tensorflow.GetStatusResponse.Builder {
            return try Tensorflow.GetStatusResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !deviceAttributes.isEmpty {
                var jsonArrayDeviceAttributes:Array<Dictionary<String,Any>> = []
                for oneValueDeviceAttributes in deviceAttributes {
                    let ecodedMessageDeviceAttributes = try oneValueDeviceAttributes.encode()
                    jsonArrayDeviceAttributes.append(ecodedMessageDeviceAttributes)
                }
                jsonMap["deviceAttributes"] = jsonArrayDeviceAttributes
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.GetStatusResponse {
            return try Tensorflow.GetStatusResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.GetStatusResponse {
            return try Tensorflow.GetStatusResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var deviceAttributesElementIndex:Int = 0
            for oneElementDeviceAttributes in deviceAttributes {
                output += "\(indent) deviceAttributes[\(deviceAttributesElementIndex)] {\n"
                output += try oneElementDeviceAttributes.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                deviceAttributesElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementDeviceAttributes in deviceAttributes {
                    hashCode = (hashCode &* 31) &+ oneElementDeviceAttributes.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.GetStatusResponse"
        }
        override public func className() -> String {
            return "Tensorflow.GetStatusResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.GetStatusResponse = Tensorflow.GetStatusResponse()
            public func getMessage() -> Tensorflow.GetStatusResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var deviceAttributes:Array<Tensorflow.DeviceAttributes> {
                get {
                    return builderResult.deviceAttributes
                }
                set (value) {
                    builderResult.deviceAttributes = value
                }
            }
            @discardableResult
            public func setDeviceAttributes(_ value:Array<Tensorflow.DeviceAttributes>) -> Tensorflow.GetStatusResponse.Builder {
                self.deviceAttributes = value
                return self
            }
            @discardableResult
            public func clearDeviceAttributes() -> Tensorflow.GetStatusResponse.Builder {
                builderResult.deviceAttributes.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.GetStatusResponse.Builder {
                builderResult = Tensorflow.GetStatusResponse()
                return self
            }
            override public func clone() throws -> Tensorflow.GetStatusResponse.Builder {
                return try Tensorflow.GetStatusResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.GetStatusResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.GetStatusResponse {
                let returnMe:Tensorflow.GetStatusResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.GetStatusResponse) throws -> Tensorflow.GetStatusResponse.Builder {
                if other == Tensorflow.GetStatusResponse() {
                    return self
                }
                if !other.deviceAttributes.isEmpty  {
                     builderResult.deviceAttributes += other.deviceAttributes
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.GetStatusResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GetStatusResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Tensorflow.DeviceAttributes.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        deviceAttributes.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.GetStatusResponse.Builder {
                let resultDecodedBuilder = Tensorflow.GetStatusResponse.Builder()
                if let jsonValueDeviceAttributes = jsonMap["deviceAttributes"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayDeviceAttributes:Array<Tensorflow.DeviceAttributes> = []
                    for oneValueDeviceAttributes in jsonValueDeviceAttributes {
                        let messageFromStringDeviceAttributes = try Tensorflow.DeviceAttributes.Builder.decodeToBuilder(jsonMap:oneValueDeviceAttributes).build()

                        jsonArrayDeviceAttributes.append(messageFromStringDeviceAttributes)
                    }
                    resultDecodedBuilder.deviceAttributes = jsonArrayDeviceAttributes
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.GetStatusResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.GetStatusResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class CreateWorkerSessionRequest : GeneratedMessage {

        public static func == (lhs: Tensorflow.CreateWorkerSessionRequest, rhs: Tensorflow.CreateWorkerSessionRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasSessionHandle == rhs.hasSessionHandle) && (!lhs.hasSessionHandle || lhs.sessionHandle == rhs.sessionHandle)
            fieldCheck = fieldCheck && (lhs.hasServerDef == rhs.hasServerDef) && (!lhs.hasServerDef || lhs.serverDef == rhs.serverDef)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Sessions are identified by a given handle.
        public fileprivate(set) var sessionHandle:String = ""
        public fileprivate(set) var hasSessionHandle:Bool = false

        public fileprivate(set) var serverDef:Tensorflow.ServerDef!
        public fileprivate(set) var hasServerDef:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasSessionHandle {
                try codedOutputStream.writeString(fieldNumber: 1, value:sessionHandle)
            }
            if hasServerDef {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:serverDef)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasSessionHandle {
                serialize_size += sessionHandle.computeStringSize(fieldNumber: 1)
            }
            if hasServerDef {
                if let varSizeserverDef = serverDef?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeserverDef
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.CreateWorkerSessionRequest.Builder {
            return Tensorflow.CreateWorkerSessionRequest.classBuilder() as! Tensorflow.CreateWorkerSessionRequest.Builder
        }
        public func getBuilder() -> Tensorflow.CreateWorkerSessionRequest.Builder {
            return classBuilder() as! Tensorflow.CreateWorkerSessionRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.CreateWorkerSessionRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.CreateWorkerSessionRequest.Builder()
        }
        public func toBuilder() throws -> Tensorflow.CreateWorkerSessionRequest.Builder {
            return try Tensorflow.CreateWorkerSessionRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.CreateWorkerSessionRequest) throws -> Tensorflow.CreateWorkerSessionRequest.Builder {
            return try Tensorflow.CreateWorkerSessionRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasSessionHandle {
                jsonMap["sessionHandle"] = sessionHandle
            }
            if hasServerDef {
                jsonMap["serverDef"] = try serverDef.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CreateWorkerSessionRequest {
            return try Tensorflow.CreateWorkerSessionRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.CreateWorkerSessionRequest {
            return try Tensorflow.CreateWorkerSessionRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasSessionHandle {
                output += "\(indent) sessionHandle: \(sessionHandle) \n"
            }
            if hasServerDef {
                output += "\(indent) serverDef {\n"
                if let outDescServerDef = serverDef {
                    output += try outDescServerDef.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasSessionHandle {
                    hashCode = (hashCode &* 31) &+ sessionHandle.hashValue
                }
                if hasServerDef {
                    if let hashValueserverDef = serverDef?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueserverDef
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.CreateWorkerSessionRequest"
        }
        override public func className() -> String {
            return "Tensorflow.CreateWorkerSessionRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.CreateWorkerSessionRequest = Tensorflow.CreateWorkerSessionRequest()
            public func getMessage() -> Tensorflow.CreateWorkerSessionRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Sessions are identified by a given handle.
            public var sessionHandle:String {
                get {
                    return builderResult.sessionHandle
                }
                set (value) {
                    builderResult.hasSessionHandle = true
                    builderResult.sessionHandle = value
                }
            }
            public var hasSessionHandle:Bool {
                get {
                    return builderResult.hasSessionHandle
                }
            }
            @discardableResult
            public func setSessionHandle(_ value:String) -> Tensorflow.CreateWorkerSessionRequest.Builder {
                self.sessionHandle = value
                return self
            }
            @discardableResult
            public func clearSessionHandle() -> Tensorflow.CreateWorkerSessionRequest.Builder{
                builderResult.hasSessionHandle = false
                builderResult.sessionHandle = ""
                return self
            }
            /// Defines the configuration of a TensorFlow worker.
            public var serverDef:Tensorflow.ServerDef! {
                get {
                    if serverDefBuilder_ != nil {
                        builderResult.serverDef = serverDefBuilder_.getMessage()
                    }
                    return builderResult.serverDef
                }
                set (value) {
                    builderResult.hasServerDef = true
                    builderResult.serverDef = value
                }
            }
            public var hasServerDef:Bool {
                get {
                    return builderResult.hasServerDef
                }
            }
            fileprivate var serverDefBuilder_:Tensorflow.ServerDef.Builder! {
                didSet {
                    builderResult.hasServerDef = true
                }
            }
            public func getServerDefBuilder() -> Tensorflow.ServerDef.Builder {
                if serverDefBuilder_ == nil {
                    serverDefBuilder_ = Tensorflow.ServerDef.Builder()
                    builderResult.serverDef = serverDefBuilder_.getMessage()
                    if serverDef != nil {
                        try! serverDefBuilder_.mergeFrom(other: serverDef)
                    }
                }
                return serverDefBuilder_
            }
            @discardableResult
            public func setServerDef(_ value:Tensorflow.ServerDef!) -> Tensorflow.CreateWorkerSessionRequest.Builder {
                self.serverDef = value
                return self
            }
            @discardableResult
            public func mergeServerDef(value:Tensorflow.ServerDef) throws -> Tensorflow.CreateWorkerSessionRequest.Builder {
                if builderResult.hasServerDef {
                    builderResult.serverDef = try Tensorflow.ServerDef.builderWithPrototype(prototype:builderResult.serverDef).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.serverDef = value
                }
                builderResult.hasServerDef = true
                return self
            }
            @discardableResult
            public func clearServerDef() -> Tensorflow.CreateWorkerSessionRequest.Builder {
                serverDefBuilder_ = nil
                builderResult.hasServerDef = false
                builderResult.serverDef = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.CreateWorkerSessionRequest.Builder {
                builderResult = Tensorflow.CreateWorkerSessionRequest()
                return self
            }
            override public func clone() throws -> Tensorflow.CreateWorkerSessionRequest.Builder {
                return try Tensorflow.CreateWorkerSessionRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.CreateWorkerSessionRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.CreateWorkerSessionRequest {
                let returnMe:Tensorflow.CreateWorkerSessionRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.CreateWorkerSessionRequest) throws -> Tensorflow.CreateWorkerSessionRequest.Builder {
                if other == Tensorflow.CreateWorkerSessionRequest() {
                    return self
                }
                if other.hasSessionHandle {
                    sessionHandle = other.sessionHandle
                }
                if (other.hasServerDef) {
                    try mergeServerDef(value: other.serverDef)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CreateWorkerSessionRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CreateWorkerSessionRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        sessionHandle = try codedInputStream.readString()

                    case 18:
                        let subBuilder:Tensorflow.ServerDef.Builder = Tensorflow.ServerDef.Builder()
                        if hasServerDef {
                            try subBuilder.mergeFrom(other: serverDef)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        serverDef = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CreateWorkerSessionRequest.Builder {
                let resultDecodedBuilder = Tensorflow.CreateWorkerSessionRequest.Builder()
                if let jsonValueSessionHandle = jsonMap["sessionHandle"] as? String {
                    resultDecodedBuilder.sessionHandle = jsonValueSessionHandle
                }
                if let jsonValueServerDef = jsonMap["serverDef"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.serverDef = try Tensorflow.ServerDef.Builder.decodeToBuilder(jsonMap:jsonValueServerDef).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.CreateWorkerSessionRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.CreateWorkerSessionRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class CreateWorkerSessionResponse : GeneratedMessage {

        public static func == (lhs: Tensorflow.CreateWorkerSessionResponse, rhs: Tensorflow.CreateWorkerSessionResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.CreateWorkerSessionResponse.Builder {
            return Tensorflow.CreateWorkerSessionResponse.classBuilder() as! Tensorflow.CreateWorkerSessionResponse.Builder
        }
        public func getBuilder() -> Tensorflow.CreateWorkerSessionResponse.Builder {
            return classBuilder() as! Tensorflow.CreateWorkerSessionResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.CreateWorkerSessionResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.CreateWorkerSessionResponse.Builder()
        }
        public func toBuilder() throws -> Tensorflow.CreateWorkerSessionResponse.Builder {
            return try Tensorflow.CreateWorkerSessionResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.CreateWorkerSessionResponse) throws -> Tensorflow.CreateWorkerSessionResponse.Builder {
            return try Tensorflow.CreateWorkerSessionResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CreateWorkerSessionResponse {
            return try Tensorflow.CreateWorkerSessionResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.CreateWorkerSessionResponse {
            return try Tensorflow.CreateWorkerSessionResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.CreateWorkerSessionResponse"
        }
        override public func className() -> String {
            return "Tensorflow.CreateWorkerSessionResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.CreateWorkerSessionResponse = Tensorflow.CreateWorkerSessionResponse()
            public func getMessage() -> Tensorflow.CreateWorkerSessionResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.CreateWorkerSessionResponse.Builder {
                builderResult = Tensorflow.CreateWorkerSessionResponse()
                return self
            }
            override public func clone() throws -> Tensorflow.CreateWorkerSessionResponse.Builder {
                return try Tensorflow.CreateWorkerSessionResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.CreateWorkerSessionResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.CreateWorkerSessionResponse {
                let returnMe:Tensorflow.CreateWorkerSessionResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.CreateWorkerSessionResponse) throws -> Tensorflow.CreateWorkerSessionResponse.Builder {
                if other == Tensorflow.CreateWorkerSessionResponse() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CreateWorkerSessionResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CreateWorkerSessionResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CreateWorkerSessionResponse.Builder {
                let resultDecodedBuilder = Tensorflow.CreateWorkerSessionResponse.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.CreateWorkerSessionResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.CreateWorkerSessionResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class RegisterGraphRequest : GeneratedMessage {

        public static func == (lhs: Tensorflow.RegisterGraphRequest, rhs: Tensorflow.RegisterGraphRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasSessionHandle == rhs.hasSessionHandle) && (!lhs.hasSessionHandle || lhs.sessionHandle == rhs.sessionHandle)
            fieldCheck = fieldCheck && (lhs.hasGraphDef == rhs.hasGraphDef) && (!lhs.hasGraphDef || lhs.graphDef == rhs.graphDef)
            fieldCheck = fieldCheck && (lhs.hasHasControlFlow == rhs.hasHasControlFlow) && (!lhs.hasHasControlFlow || lhs.hasControlFlow == rhs.hasControlFlow)
            fieldCheck = fieldCheck && (lhs.hasGraphOptions == rhs.hasGraphOptions) && (!lhs.hasGraphOptions || lhs.graphOptions == rhs.graphOptions)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Subgraphs are scoped within one session.
        public fileprivate(set) var sessionHandle:String = ""
        public fileprivate(set) var hasSessionHandle:Bool = false

        public fileprivate(set) var graphDef:Tensorflow.GraphDef!
        public fileprivate(set) var hasGraphDef:Bool = false
        /// True iff the graph (before partitioning) contains control flow nodes.
        /// As of 01/11/2015, this is no longer set by clients.
        @available(*, deprecated:0.1, message:"hasControlFlow is marked as \"Deprecated\"")
        public fileprivate(set) var hasControlFlow:Bool = false
        public fileprivate(set) var hasHasControlFlow:Bool = false

        public fileprivate(set) var graphOptions:Tensorflow.GraphOptions!
        public fileprivate(set) var hasGraphOptions:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasSessionHandle {
                try codedOutputStream.writeString(fieldNumber: 1, value:sessionHandle)
            }
            if hasGraphDef {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:graphDef)
            }
            if hasHasControlFlow {
                try codedOutputStream.writeBool(fieldNumber: 3, value:hasControlFlow)
            }
            if hasGraphOptions {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:graphOptions)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasSessionHandle {
                serialize_size += sessionHandle.computeStringSize(fieldNumber: 1)
            }
            if hasGraphDef {
                if let varSizegraphDef = graphDef?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizegraphDef
                }
            }
            if hasHasControlFlow {
                serialize_size += hasControlFlow.computeBoolSize(fieldNumber: 3)
            }
            if hasGraphOptions {
                if let varSizegraphOptions = graphOptions?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizegraphOptions
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.RegisterGraphRequest.Builder {
            return Tensorflow.RegisterGraphRequest.classBuilder() as! Tensorflow.RegisterGraphRequest.Builder
        }
        public func getBuilder() -> Tensorflow.RegisterGraphRequest.Builder {
            return classBuilder() as! Tensorflow.RegisterGraphRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.RegisterGraphRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.RegisterGraphRequest.Builder()
        }
        public func toBuilder() throws -> Tensorflow.RegisterGraphRequest.Builder {
            return try Tensorflow.RegisterGraphRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.RegisterGraphRequest) throws -> Tensorflow.RegisterGraphRequest.Builder {
            return try Tensorflow.RegisterGraphRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasSessionHandle {
                jsonMap["sessionHandle"] = sessionHandle
            }
            if hasGraphDef {
                jsonMap["graphDef"] = try graphDef.encode()
            }
            if hasHasControlFlow {
                jsonMap["hasControlFlow"] = hasControlFlow
            }
            if hasGraphOptions {
                jsonMap["graphOptions"] = try graphOptions.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.RegisterGraphRequest {
            return try Tensorflow.RegisterGraphRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.RegisterGraphRequest {
            return try Tensorflow.RegisterGraphRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasSessionHandle {
                output += "\(indent) sessionHandle: \(sessionHandle) \n"
            }
            if hasGraphDef {
                output += "\(indent) graphDef {\n"
                if let outDescGraphDef = graphDef {
                    output += try outDescGraphDef.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasHasControlFlow {
                output += "\(indent) hasControlFlow: \(hasControlFlow) \n"
            }
            if hasGraphOptions {
                output += "\(indent) graphOptions {\n"
                if let outDescGraphOptions = graphOptions {
                    output += try outDescGraphOptions.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasSessionHandle {
                    hashCode = (hashCode &* 31) &+ sessionHandle.hashValue
                }
                if hasGraphDef {
                    if let hashValuegraphDef = graphDef?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuegraphDef
                    }
                }
                if hasHasControlFlow {
                    hashCode = (hashCode &* 31) &+ hasControlFlow.hashValue
                }
                if hasGraphOptions {
                    if let hashValuegraphOptions = graphOptions?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuegraphOptions
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.RegisterGraphRequest"
        }
        override public func className() -> String {
            return "Tensorflow.RegisterGraphRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.RegisterGraphRequest = Tensorflow.RegisterGraphRequest()
            public func getMessage() -> Tensorflow.RegisterGraphRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Subgraphs are scoped within one session.
            public var sessionHandle:String {
                get {
                    return builderResult.sessionHandle
                }
                set (value) {
                    builderResult.hasSessionHandle = true
                    builderResult.sessionHandle = value
                }
            }
            public var hasSessionHandle:Bool {
                get {
                    return builderResult.hasSessionHandle
                }
            }
            @discardableResult
            public func setSessionHandle(_ value:String) -> Tensorflow.RegisterGraphRequest.Builder {
                self.sessionHandle = value
                return self
            }
            @discardableResult
            public func clearSessionHandle() -> Tensorflow.RegisterGraphRequest.Builder{
                builderResult.hasSessionHandle = false
                builderResult.sessionHandle = ""
                return self
            }
            /// "graph_def" has the subgraph of nodes for this worker, with each node
            /// having its device_name filled in.
            public var graphDef:Tensorflow.GraphDef! {
                get {
                    if graphDefBuilder_ != nil {
                        builderResult.graphDef = graphDefBuilder_.getMessage()
                    }
                    return builderResult.graphDef
                }
                set (value) {
                    builderResult.hasGraphDef = true
                    builderResult.graphDef = value
                }
            }
            public var hasGraphDef:Bool {
                get {
                    return builderResult.hasGraphDef
                }
            }
            fileprivate var graphDefBuilder_:Tensorflow.GraphDef.Builder! {
                didSet {
                    builderResult.hasGraphDef = true
                }
            }
            public func getGraphDefBuilder() -> Tensorflow.GraphDef.Builder {
                if graphDefBuilder_ == nil {
                    graphDefBuilder_ = Tensorflow.GraphDef.Builder()
                    builderResult.graphDef = graphDefBuilder_.getMessage()
                    if graphDef != nil {
                        try! graphDefBuilder_.mergeFrom(other: graphDef)
                    }
                }
                return graphDefBuilder_
            }
            @discardableResult
            public func setGraphDef(_ value:Tensorflow.GraphDef!) -> Tensorflow.RegisterGraphRequest.Builder {
                self.graphDef = value
                return self
            }
            @discardableResult
            public func mergeGraphDef(value:Tensorflow.GraphDef) throws -> Tensorflow.RegisterGraphRequest.Builder {
                if builderResult.hasGraphDef {
                    builderResult.graphDef = try Tensorflow.GraphDef.builderWithPrototype(prototype:builderResult.graphDef).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.graphDef = value
                }
                builderResult.hasGraphDef = true
                return self
            }
            @discardableResult
            public func clearGraphDef() -> Tensorflow.RegisterGraphRequest.Builder {
                graphDefBuilder_ = nil
                builderResult.hasGraphDef = false
                builderResult.graphDef = nil
                return self
            }
            /// True iff the graph (before partitioning) contains control flow nodes.
            /// As of 01/11/2015, this is no longer set by clients.
            public var hasControlFlow:Bool {
                get {
                    return builderResult.hasControlFlow
                }
                set (value) {
                    builderResult.hasHasControlFlow = true
                    builderResult.hasControlFlow = value
                }
            }
            public var hasHasControlFlow:Bool {
                get {
                    return builderResult.hasHasControlFlow
                }
            }
            @discardableResult
            public func setHasControlFlow(_ value:Bool) -> Tensorflow.RegisterGraphRequest.Builder {
                self.hasControlFlow = value
                return self
            }
            @discardableResult
            public func clearHasControlFlow() -> Tensorflow.RegisterGraphRequest.Builder{
                builderResult.hasHasControlFlow = false
                builderResult.hasControlFlow = false
                return self
            }
            /// Configuration options for the session in which this graph was created.
            public var graphOptions:Tensorflow.GraphOptions! {
                get {
                    if graphOptionsBuilder_ != nil {
                        builderResult.graphOptions = graphOptionsBuilder_.getMessage()
                    }
                    return builderResult.graphOptions
                }
                set (value) {
                    builderResult.hasGraphOptions = true
                    builderResult.graphOptions = value
                }
            }
            public var hasGraphOptions:Bool {
                get {
                    return builderResult.hasGraphOptions
                }
            }
            fileprivate var graphOptionsBuilder_:Tensorflow.GraphOptions.Builder! {
                didSet {
                    builderResult.hasGraphOptions = true
                }
            }
            public func getGraphOptionsBuilder() -> Tensorflow.GraphOptions.Builder {
                if graphOptionsBuilder_ == nil {
                    graphOptionsBuilder_ = Tensorflow.GraphOptions.Builder()
                    builderResult.graphOptions = graphOptionsBuilder_.getMessage()
                    if graphOptions != nil {
                        try! graphOptionsBuilder_.mergeFrom(other: graphOptions)
                    }
                }
                return graphOptionsBuilder_
            }
            @discardableResult
            public func setGraphOptions(_ value:Tensorflow.GraphOptions!) -> Tensorflow.RegisterGraphRequest.Builder {
                self.graphOptions = value
                return self
            }
            @discardableResult
            public func mergeGraphOptions(value:Tensorflow.GraphOptions) throws -> Tensorflow.RegisterGraphRequest.Builder {
                if builderResult.hasGraphOptions {
                    builderResult.graphOptions = try Tensorflow.GraphOptions.builderWithPrototype(prototype:builderResult.graphOptions).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.graphOptions = value
                }
                builderResult.hasGraphOptions = true
                return self
            }
            @discardableResult
            public func clearGraphOptions() -> Tensorflow.RegisterGraphRequest.Builder {
                graphOptionsBuilder_ = nil
                builderResult.hasGraphOptions = false
                builderResult.graphOptions = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.RegisterGraphRequest.Builder {
                builderResult = Tensorflow.RegisterGraphRequest()
                return self
            }
            override public func clone() throws -> Tensorflow.RegisterGraphRequest.Builder {
                return try Tensorflow.RegisterGraphRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.RegisterGraphRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.RegisterGraphRequest {
                let returnMe:Tensorflow.RegisterGraphRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.RegisterGraphRequest) throws -> Tensorflow.RegisterGraphRequest.Builder {
                if other == Tensorflow.RegisterGraphRequest() {
                    return self
                }
                if other.hasSessionHandle {
                    sessionHandle = other.sessionHandle
                }
                if (other.hasGraphDef) {
                    try mergeGraphDef(value: other.graphDef)
                }
                if other.hasHasControlFlow {
                    hasControlFlow = other.hasControlFlow
                }
                if (other.hasGraphOptions) {
                    try mergeGraphOptions(value: other.graphOptions)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.RegisterGraphRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RegisterGraphRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        sessionHandle = try codedInputStream.readString()

                    case 18:
                        let subBuilder:Tensorflow.GraphDef.Builder = Tensorflow.GraphDef.Builder()
                        if hasGraphDef {
                            try subBuilder.mergeFrom(other: graphDef)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        graphDef = subBuilder.buildPartial()

                    case 24:
                        hasControlFlow = try codedInputStream.readBool()

                    case 34:
                        let subBuilder:Tensorflow.GraphOptions.Builder = Tensorflow.GraphOptions.Builder()
                        if hasGraphOptions {
                            try subBuilder.mergeFrom(other: graphOptions)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        graphOptions = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.RegisterGraphRequest.Builder {
                let resultDecodedBuilder = Tensorflow.RegisterGraphRequest.Builder()
                if let jsonValueSessionHandle = jsonMap["sessionHandle"] as? String {
                    resultDecodedBuilder.sessionHandle = jsonValueSessionHandle
                }
                if let jsonValueGraphDef = jsonMap["graphDef"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.graphDef = try Tensorflow.GraphDef.Builder.decodeToBuilder(jsonMap:jsonValueGraphDef).build()

                }
                if let jsonValueHasControlFlow = jsonMap["hasControlFlow"] as? Bool {
                    resultDecodedBuilder.hasControlFlow = jsonValueHasControlFlow
                }
                if let jsonValueGraphOptions = jsonMap["graphOptions"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.graphOptions = try Tensorflow.GraphOptions.Builder.decodeToBuilder(jsonMap:jsonValueGraphOptions).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.RegisterGraphRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.RegisterGraphRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class RegisterGraphResponse : GeneratedMessage {

        public static func == (lhs: Tensorflow.RegisterGraphResponse, rhs: Tensorflow.RegisterGraphResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasGraphHandle == rhs.hasGraphHandle) && (!lhs.hasGraphHandle || lhs.graphHandle == rhs.graphHandle)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// If the registration succeeds, returns an opaque graph_handle to
        /// the master. The master calls RunGraph with graph_handle to
        /// compute different steps.
        public fileprivate(set) var graphHandle:String = ""
        public fileprivate(set) var hasGraphHandle:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasGraphHandle {
                try codedOutputStream.writeString(fieldNumber: 1, value:graphHandle)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasGraphHandle {
                serialize_size += graphHandle.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.RegisterGraphResponse.Builder {
            return Tensorflow.RegisterGraphResponse.classBuilder() as! Tensorflow.RegisterGraphResponse.Builder
        }
        public func getBuilder() -> Tensorflow.RegisterGraphResponse.Builder {
            return classBuilder() as! Tensorflow.RegisterGraphResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.RegisterGraphResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.RegisterGraphResponse.Builder()
        }
        public func toBuilder() throws -> Tensorflow.RegisterGraphResponse.Builder {
            return try Tensorflow.RegisterGraphResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.RegisterGraphResponse) throws -> Tensorflow.RegisterGraphResponse.Builder {
            return try Tensorflow.RegisterGraphResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasGraphHandle {
                jsonMap["graphHandle"] = graphHandle
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.RegisterGraphResponse {
            return try Tensorflow.RegisterGraphResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.RegisterGraphResponse {
            return try Tensorflow.RegisterGraphResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasGraphHandle {
                output += "\(indent) graphHandle: \(graphHandle) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasGraphHandle {
                    hashCode = (hashCode &* 31) &+ graphHandle.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.RegisterGraphResponse"
        }
        override public func className() -> String {
            return "Tensorflow.RegisterGraphResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.RegisterGraphResponse = Tensorflow.RegisterGraphResponse()
            public func getMessage() -> Tensorflow.RegisterGraphResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// If the registration succeeds, returns an opaque graph_handle to
            /// the master. The master calls RunGraph with graph_handle to
            /// compute different steps.
            public var graphHandle:String {
                get {
                    return builderResult.graphHandle
                }
                set (value) {
                    builderResult.hasGraphHandle = true
                    builderResult.graphHandle = value
                }
            }
            public var hasGraphHandle:Bool {
                get {
                    return builderResult.hasGraphHandle
                }
            }
            @discardableResult
            public func setGraphHandle(_ value:String) -> Tensorflow.RegisterGraphResponse.Builder {
                self.graphHandle = value
                return self
            }
            @discardableResult
            public func clearGraphHandle() -> Tensorflow.RegisterGraphResponse.Builder{
                builderResult.hasGraphHandle = false
                builderResult.graphHandle = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.RegisterGraphResponse.Builder {
                builderResult = Tensorflow.RegisterGraphResponse()
                return self
            }
            override public func clone() throws -> Tensorflow.RegisterGraphResponse.Builder {
                return try Tensorflow.RegisterGraphResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.RegisterGraphResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.RegisterGraphResponse {
                let returnMe:Tensorflow.RegisterGraphResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.RegisterGraphResponse) throws -> Tensorflow.RegisterGraphResponse.Builder {
                if other == Tensorflow.RegisterGraphResponse() {
                    return self
                }
                if other.hasGraphHandle {
                    graphHandle = other.graphHandle
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.RegisterGraphResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RegisterGraphResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        graphHandle = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.RegisterGraphResponse.Builder {
                let resultDecodedBuilder = Tensorflow.RegisterGraphResponse.Builder()
                if let jsonValueGraphHandle = jsonMap["graphHandle"] as? String {
                    resultDecodedBuilder.graphHandle = jsonValueGraphHandle
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.RegisterGraphResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.RegisterGraphResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class DeregisterGraphRequest : GeneratedMessage {

        public static func == (lhs: Tensorflow.DeregisterGraphRequest, rhs: Tensorflow.DeregisterGraphRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasGraphHandle == rhs.hasGraphHandle) && (!lhs.hasGraphHandle || lhs.graphHandle == rhs.graphHandle)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// REQUIRED: graph_handle must be returned by a RegisterGraph call
        /// to the same WorkerService.
        public fileprivate(set) var graphHandle:String = ""
        public fileprivate(set) var hasGraphHandle:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasGraphHandle {
                try codedOutputStream.writeString(fieldNumber: 1, value:graphHandle)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasGraphHandle {
                serialize_size += graphHandle.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.DeregisterGraphRequest.Builder {
            return Tensorflow.DeregisterGraphRequest.classBuilder() as! Tensorflow.DeregisterGraphRequest.Builder
        }
        public func getBuilder() -> Tensorflow.DeregisterGraphRequest.Builder {
            return classBuilder() as! Tensorflow.DeregisterGraphRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.DeregisterGraphRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.DeregisterGraphRequest.Builder()
        }
        public func toBuilder() throws -> Tensorflow.DeregisterGraphRequest.Builder {
            return try Tensorflow.DeregisterGraphRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.DeregisterGraphRequest) throws -> Tensorflow.DeregisterGraphRequest.Builder {
            return try Tensorflow.DeregisterGraphRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasGraphHandle {
                jsonMap["graphHandle"] = graphHandle
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.DeregisterGraphRequest {
            return try Tensorflow.DeregisterGraphRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.DeregisterGraphRequest {
            return try Tensorflow.DeregisterGraphRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasGraphHandle {
                output += "\(indent) graphHandle: \(graphHandle) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasGraphHandle {
                    hashCode = (hashCode &* 31) &+ graphHandle.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.DeregisterGraphRequest"
        }
        override public func className() -> String {
            return "Tensorflow.DeregisterGraphRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.DeregisterGraphRequest = Tensorflow.DeregisterGraphRequest()
            public func getMessage() -> Tensorflow.DeregisterGraphRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// REQUIRED: graph_handle must be returned by a RegisterGraph call
            /// to the same WorkerService.
            public var graphHandle:String {
                get {
                    return builderResult.graphHandle
                }
                set (value) {
                    builderResult.hasGraphHandle = true
                    builderResult.graphHandle = value
                }
            }
            public var hasGraphHandle:Bool {
                get {
                    return builderResult.hasGraphHandle
                }
            }
            @discardableResult
            public func setGraphHandle(_ value:String) -> Tensorflow.DeregisterGraphRequest.Builder {
                self.graphHandle = value
                return self
            }
            @discardableResult
            public func clearGraphHandle() -> Tensorflow.DeregisterGraphRequest.Builder{
                builderResult.hasGraphHandle = false
                builderResult.graphHandle = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.DeregisterGraphRequest.Builder {
                builderResult = Tensorflow.DeregisterGraphRequest()
                return self
            }
            override public func clone() throws -> Tensorflow.DeregisterGraphRequest.Builder {
                return try Tensorflow.DeregisterGraphRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.DeregisterGraphRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.DeregisterGraphRequest {
                let returnMe:Tensorflow.DeregisterGraphRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.DeregisterGraphRequest) throws -> Tensorflow.DeregisterGraphRequest.Builder {
                if other == Tensorflow.DeregisterGraphRequest() {
                    return self
                }
                if other.hasGraphHandle {
                    graphHandle = other.graphHandle
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.DeregisterGraphRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.DeregisterGraphRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        graphHandle = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.DeregisterGraphRequest.Builder {
                let resultDecodedBuilder = Tensorflow.DeregisterGraphRequest.Builder()
                if let jsonValueGraphHandle = jsonMap["graphHandle"] as? String {
                    resultDecodedBuilder.graphHandle = jsonValueGraphHandle
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.DeregisterGraphRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.DeregisterGraphRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// TODO(mrry): Optionally add summary stats for the graph.
    final public class DeregisterGraphResponse : GeneratedMessage {

        public static func == (lhs: Tensorflow.DeregisterGraphResponse, rhs: Tensorflow.DeregisterGraphResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.DeregisterGraphResponse.Builder {
            return Tensorflow.DeregisterGraphResponse.classBuilder() as! Tensorflow.DeregisterGraphResponse.Builder
        }
        public func getBuilder() -> Tensorflow.DeregisterGraphResponse.Builder {
            return classBuilder() as! Tensorflow.DeregisterGraphResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.DeregisterGraphResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.DeregisterGraphResponse.Builder()
        }
        public func toBuilder() throws -> Tensorflow.DeregisterGraphResponse.Builder {
            return try Tensorflow.DeregisterGraphResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.DeregisterGraphResponse) throws -> Tensorflow.DeregisterGraphResponse.Builder {
            return try Tensorflow.DeregisterGraphResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.DeregisterGraphResponse {
            return try Tensorflow.DeregisterGraphResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.DeregisterGraphResponse {
            return try Tensorflow.DeregisterGraphResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.DeregisterGraphResponse"
        }
        override public func className() -> String {
            return "Tensorflow.DeregisterGraphResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.DeregisterGraphResponse = Tensorflow.DeregisterGraphResponse()
            public func getMessage() -> Tensorflow.DeregisterGraphResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.DeregisterGraphResponse.Builder {
                builderResult = Tensorflow.DeregisterGraphResponse()
                return self
            }
            override public func clone() throws -> Tensorflow.DeregisterGraphResponse.Builder {
                return try Tensorflow.DeregisterGraphResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.DeregisterGraphResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.DeregisterGraphResponse {
                let returnMe:Tensorflow.DeregisterGraphResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.DeregisterGraphResponse) throws -> Tensorflow.DeregisterGraphResponse.Builder {
                if other == Tensorflow.DeregisterGraphResponse() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.DeregisterGraphResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.DeregisterGraphResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.DeregisterGraphResponse.Builder {
                let resultDecodedBuilder = Tensorflow.DeregisterGraphResponse.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.DeregisterGraphResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.DeregisterGraphResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class CleanupAllRequest : GeneratedMessage {

        public static func == (lhs: Tensorflow.CleanupAllRequest, rhs: Tensorflow.CleanupAllRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.container == rhs.container)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// A list of container names.
        /// If 'container' is not empty, releases resoures in the given
        /// containers in all devices.
        /// If 'container' is empty, releases resources in the default
        /// container in all devices.
        public fileprivate(set) var container:Array<String> = Array<String>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if !container.isEmpty {
                for oneValuecontainer in container {
                    try codedOutputStream.writeString(fieldNumber: 1, value:oneValuecontainer)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            var dataSizeContainer:Int32 = 0
            for oneValuecontainer in container {
                dataSizeContainer += oneValuecontainer.computeStringSizeNoTag()
            }
            serialize_size += dataSizeContainer
            serialize_size += 1 * Int32(container.count)
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.CleanupAllRequest.Builder {
            return Tensorflow.CleanupAllRequest.classBuilder() as! Tensorflow.CleanupAllRequest.Builder
        }
        public func getBuilder() -> Tensorflow.CleanupAllRequest.Builder {
            return classBuilder() as! Tensorflow.CleanupAllRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.CleanupAllRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.CleanupAllRequest.Builder()
        }
        public func toBuilder() throws -> Tensorflow.CleanupAllRequest.Builder {
            return try Tensorflow.CleanupAllRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.CleanupAllRequest) throws -> Tensorflow.CleanupAllRequest.Builder {
            return try Tensorflow.CleanupAllRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !container.isEmpty {
                var jsonArrayContainer:Array<String> = []
                for oneValueContainer in container {
                    jsonArrayContainer.append(oneValueContainer)
                }
                jsonMap["container"] = jsonArrayContainer
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CleanupAllRequest {
            return try Tensorflow.CleanupAllRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.CleanupAllRequest {
            return try Tensorflow.CleanupAllRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var containerElementIndex:Int = 0
            for oneValueContainer in container  {
                output += "\(indent) container[\(containerElementIndex)]: \(oneValueContainer)\n"
                containerElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneValueContainer in container {
                    hashCode = (hashCode &* 31) &+ oneValueContainer.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.CleanupAllRequest"
        }
        override public func className() -> String {
            return "Tensorflow.CleanupAllRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.CleanupAllRequest = Tensorflow.CleanupAllRequest()
            public func getMessage() -> Tensorflow.CleanupAllRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// A list of container names.
            /// If 'container' is not empty, releases resoures in the given
            /// containers in all devices.
            /// If 'container' is empty, releases resources in the default
            /// container in all devices.
            public var container:Array<String> {
                get {
                    return builderResult.container
                }
                set (array) {
                    builderResult.container = array
                }
            }
            @discardableResult
            public func setContainer(_ value:Array<String>) -> Tensorflow.CleanupAllRequest.Builder {
                self.container = value
                return self
            }
            @discardableResult
            public func clearContainer() -> Tensorflow.CleanupAllRequest.Builder {
                builderResult.container.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.CleanupAllRequest.Builder {
                builderResult = Tensorflow.CleanupAllRequest()
                return self
            }
            override public func clone() throws -> Tensorflow.CleanupAllRequest.Builder {
                return try Tensorflow.CleanupAllRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.CleanupAllRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.CleanupAllRequest {
                let returnMe:Tensorflow.CleanupAllRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.CleanupAllRequest) throws -> Tensorflow.CleanupAllRequest.Builder {
                if other == Tensorflow.CleanupAllRequest() {
                    return self
                }
                if !other.container.isEmpty {
                    builderResult.container += other.container
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CleanupAllRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CleanupAllRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        container += [try codedInputStream.readString()]

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CleanupAllRequest.Builder {
                let resultDecodedBuilder = Tensorflow.CleanupAllRequest.Builder()
                if let jsonValueContainer = jsonMap["container"] as? Array<String> {
                    var jsonArrayContainer:Array<String> = []
                    for oneValueContainer in jsonValueContainer {
                        jsonArrayContainer.append(oneValueContainer)
                    }
                    resultDecodedBuilder.container = jsonArrayContainer
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.CleanupAllRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.CleanupAllRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class CleanupAllResponse : GeneratedMessage {

        public static func == (lhs: Tensorflow.CleanupAllResponse, rhs: Tensorflow.CleanupAllResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.CleanupAllResponse.Builder {
            return Tensorflow.CleanupAllResponse.classBuilder() as! Tensorflow.CleanupAllResponse.Builder
        }
        public func getBuilder() -> Tensorflow.CleanupAllResponse.Builder {
            return classBuilder() as! Tensorflow.CleanupAllResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.CleanupAllResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.CleanupAllResponse.Builder()
        }
        public func toBuilder() throws -> Tensorflow.CleanupAllResponse.Builder {
            return try Tensorflow.CleanupAllResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.CleanupAllResponse) throws -> Tensorflow.CleanupAllResponse.Builder {
            return try Tensorflow.CleanupAllResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CleanupAllResponse {
            return try Tensorflow.CleanupAllResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.CleanupAllResponse {
            return try Tensorflow.CleanupAllResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.CleanupAllResponse"
        }
        override public func className() -> String {
            return "Tensorflow.CleanupAllResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.CleanupAllResponse = Tensorflow.CleanupAllResponse()
            public func getMessage() -> Tensorflow.CleanupAllResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.CleanupAllResponse.Builder {
                builderResult = Tensorflow.CleanupAllResponse()
                return self
            }
            override public func clone() throws -> Tensorflow.CleanupAllResponse.Builder {
                return try Tensorflow.CleanupAllResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.CleanupAllResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.CleanupAllResponse {
                let returnMe:Tensorflow.CleanupAllResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.CleanupAllResponse) throws -> Tensorflow.CleanupAllResponse.Builder {
                if other == Tensorflow.CleanupAllResponse() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CleanupAllResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CleanupAllResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CleanupAllResponse.Builder {
                let resultDecodedBuilder = Tensorflow.CleanupAllResponse.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.CleanupAllResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.CleanupAllResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Options specific to the execution of a single step.
    final public class ExecutorOpts : GeneratedMessage {

        public static func == (lhs: Tensorflow.ExecutorOpts, rhs: Tensorflow.ExecutorOpts) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasRecordCosts == rhs.hasRecordCosts) && (!lhs.hasRecordCosts || lhs.recordCosts == rhs.recordCosts)
            fieldCheck = fieldCheck && (lhs.hasRecordTimeline == rhs.hasRecordTimeline) && (!lhs.hasRecordTimeline || lhs.recordTimeline == rhs.recordTimeline)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var recordCosts:Bool = false
        public fileprivate(set) var hasRecordCosts:Bool = false

        public fileprivate(set) var recordTimeline:Bool = false
        public fileprivate(set) var hasRecordTimeline:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasRecordCosts {
                try codedOutputStream.writeBool(fieldNumber: 1, value:recordCosts)
            }
            if hasRecordTimeline {
                try codedOutputStream.writeBool(fieldNumber: 3, value:recordTimeline)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasRecordCosts {
                serialize_size += recordCosts.computeBoolSize(fieldNumber: 1)
            }
            if hasRecordTimeline {
                serialize_size += recordTimeline.computeBoolSize(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.ExecutorOpts.Builder {
            return Tensorflow.ExecutorOpts.classBuilder() as! Tensorflow.ExecutorOpts.Builder
        }
        public func getBuilder() -> Tensorflow.ExecutorOpts.Builder {
            return classBuilder() as! Tensorflow.ExecutorOpts.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.ExecutorOpts.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.ExecutorOpts.Builder()
        }
        public func toBuilder() throws -> Tensorflow.ExecutorOpts.Builder {
            return try Tensorflow.ExecutorOpts.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.ExecutorOpts) throws -> Tensorflow.ExecutorOpts.Builder {
            return try Tensorflow.ExecutorOpts.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasRecordCosts {
                jsonMap["recordCosts"] = recordCosts
            }
            if hasRecordTimeline {
                jsonMap["recordTimeline"] = recordTimeline
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.ExecutorOpts {
            return try Tensorflow.ExecutorOpts.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.ExecutorOpts {
            return try Tensorflow.ExecutorOpts.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasRecordCosts {
                output += "\(indent) recordCosts: \(recordCosts) \n"
            }
            if hasRecordTimeline {
                output += "\(indent) recordTimeline: \(recordTimeline) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasRecordCosts {
                    hashCode = (hashCode &* 31) &+ recordCosts.hashValue
                }
                if hasRecordTimeline {
                    hashCode = (hashCode &* 31) &+ recordTimeline.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.ExecutorOpts"
        }
        override public func className() -> String {
            return "Tensorflow.ExecutorOpts"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.ExecutorOpts = Tensorflow.ExecutorOpts()
            public func getMessage() -> Tensorflow.ExecutorOpts {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var recordCosts:Bool {
                get {
                    return builderResult.recordCosts
                }
                set (value) {
                    builderResult.hasRecordCosts = true
                    builderResult.recordCosts = value
                }
            }
            public var hasRecordCosts:Bool {
                get {
                    return builderResult.hasRecordCosts
                }
            }
            @discardableResult
            public func setRecordCosts(_ value:Bool) -> Tensorflow.ExecutorOpts.Builder {
                self.recordCosts = value
                return self
            }
            @discardableResult
            public func clearRecordCosts() -> Tensorflow.ExecutorOpts.Builder{
                builderResult.hasRecordCosts = false
                builderResult.recordCosts = false
                return self
            }
            public var recordTimeline:Bool {
                get {
                    return builderResult.recordTimeline
                }
                set (value) {
                    builderResult.hasRecordTimeline = true
                    builderResult.recordTimeline = value
                }
            }
            public var hasRecordTimeline:Bool {
                get {
                    return builderResult.hasRecordTimeline
                }
            }
            @discardableResult
            public func setRecordTimeline(_ value:Bool) -> Tensorflow.ExecutorOpts.Builder {
                self.recordTimeline = value
                return self
            }
            @discardableResult
            public func clearRecordTimeline() -> Tensorflow.ExecutorOpts.Builder{
                builderResult.hasRecordTimeline = false
                builderResult.recordTimeline = false
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.ExecutorOpts.Builder {
                builderResult = Tensorflow.ExecutorOpts()
                return self
            }
            override public func clone() throws -> Tensorflow.ExecutorOpts.Builder {
                return try Tensorflow.ExecutorOpts.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.ExecutorOpts {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.ExecutorOpts {
                let returnMe:Tensorflow.ExecutorOpts = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.ExecutorOpts) throws -> Tensorflow.ExecutorOpts.Builder {
                if other == Tensorflow.ExecutorOpts() {
                    return self
                }
                if other.hasRecordCosts {
                    recordCosts = other.recordCosts
                }
                if other.hasRecordTimeline {
                    recordTimeline = other.recordTimeline
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.ExecutorOpts.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ExecutorOpts.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        recordCosts = try codedInputStream.readBool()

                    case 24:
                        recordTimeline = try codedInputStream.readBool()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.ExecutorOpts.Builder {
                let resultDecodedBuilder = Tensorflow.ExecutorOpts.Builder()
                if let jsonValueRecordCosts = jsonMap["recordCosts"] as? Bool {
                    resultDecodedBuilder.recordCosts = jsonValueRecordCosts
                }
                if let jsonValueRecordTimeline = jsonMap["recordTimeline"] as? Bool {
                    resultDecodedBuilder.recordTimeline = jsonValueRecordTimeline
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.ExecutorOpts.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.ExecutorOpts.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class RunGraphRequest : GeneratedMessage {

        public static func == (lhs: Tensorflow.RunGraphRequest, rhs: Tensorflow.RunGraphRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasGraphHandle == rhs.hasGraphHandle) && (!lhs.hasGraphHandle || lhs.graphHandle == rhs.graphHandle)
            fieldCheck = fieldCheck && (lhs.hasStepId == rhs.hasStepId) && (!lhs.hasStepId || lhs.stepId == rhs.stepId)
            fieldCheck = fieldCheck && (lhs.send == rhs.send)
            fieldCheck = fieldCheck && (lhs.recvKey == rhs.recvKey)
            fieldCheck = fieldCheck && (lhs.hasExecOpts == rhs.hasExecOpts) && (!lhs.hasExecOpts || lhs.execOpts == rhs.execOpts)
            fieldCheck = fieldCheck && (lhs.hasIsPartial == rhs.hasIsPartial) && (!lhs.hasIsPartial || lhs.isPartial == rhs.isPartial)
            fieldCheck = fieldCheck && (lhs.hasIsLastPartialRun == rhs.hasIsLastPartialRun) && (!lhs.hasIsLastPartialRun || lhs.isLastPartialRun == rhs.isLastPartialRun)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// REQUIRED: graph_handle must be returned by a RegisterGraph call
        /// to the same WorkerService.
        public fileprivate(set) var graphHandle:String = ""
        public fileprivate(set) var hasGraphHandle:Bool = false

        /// A unique ID to distinguish different runs of the same graph.
        /// The master generates a global unique `step_id` to distinguish
        /// different runs of the graph computation. Subgraphs communicate
        /// (e.g., send/recv ops) with each other using `step_id` to
        /// distinguish tensors generated by different runs.
        public fileprivate(set) var stepId:Int64 = Int64(0)
        public fileprivate(set) var hasStepId:Bool = false

        public fileprivate(set) var execOpts:Tensorflow.ExecutorOpts!
        public fileprivate(set) var hasExecOpts:Bool = false
        public fileprivate(set) var send:Array<Tensorflow.NamedTensorProto>  = Array<Tensorflow.NamedTensorProto>()
        public fileprivate(set) var recvKey:Array<String> = Array<String>()
        /// True if the RunGraphRequest is a partial run request.
        public fileprivate(set) var isPartial:Bool = false
        public fileprivate(set) var hasIsPartial:Bool = false

        /// True if this is the last partial run request in a sequence of requests.
        public fileprivate(set) var isLastPartialRun:Bool = false
        public fileprivate(set) var hasIsLastPartialRun:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasGraphHandle {
                try codedOutputStream.writeString(fieldNumber: 1, value:graphHandle)
            }
            if hasStepId {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:stepId)
            }
            for oneElementSend in send {
                  try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementSend)
            }
            if !recvKey.isEmpty {
                for oneValuerecvKey in recvKey {
                    try codedOutputStream.writeString(fieldNumber: 4, value:oneValuerecvKey)
                }
            }
            if hasExecOpts {
                try codedOutputStream.writeMessage(fieldNumber: 5, value:execOpts)
            }
            if hasIsPartial {
                try codedOutputStream.writeBool(fieldNumber: 6, value:isPartial)
            }
            if hasIsLastPartialRun {
                try codedOutputStream.writeBool(fieldNumber: 7, value:isLastPartialRun)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasGraphHandle {
                serialize_size += graphHandle.computeStringSize(fieldNumber: 1)
            }
            if hasStepId {
                serialize_size += stepId.computeInt64Size(fieldNumber: 2)
            }
            for oneElementSend in send {
                serialize_size += oneElementSend.computeMessageSize(fieldNumber: 3)
            }
            var dataSizeRecvKey:Int32 = 0
            for oneValuerecvKey in recvKey {
                dataSizeRecvKey += oneValuerecvKey.computeStringSizeNoTag()
            }
            serialize_size += dataSizeRecvKey
            serialize_size += 1 * Int32(recvKey.count)
            if hasExecOpts {
                if let varSizeexecOpts = execOpts?.computeMessageSize(fieldNumber: 5) {
                    serialize_size += varSizeexecOpts
                }
            }
            if hasIsPartial {
                serialize_size += isPartial.computeBoolSize(fieldNumber: 6)
            }
            if hasIsLastPartialRun {
                serialize_size += isLastPartialRun.computeBoolSize(fieldNumber: 7)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.RunGraphRequest.Builder {
            return Tensorflow.RunGraphRequest.classBuilder() as! Tensorflow.RunGraphRequest.Builder
        }
        public func getBuilder() -> Tensorflow.RunGraphRequest.Builder {
            return classBuilder() as! Tensorflow.RunGraphRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.RunGraphRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.RunGraphRequest.Builder()
        }
        public func toBuilder() throws -> Tensorflow.RunGraphRequest.Builder {
            return try Tensorflow.RunGraphRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.RunGraphRequest) throws -> Tensorflow.RunGraphRequest.Builder {
            return try Tensorflow.RunGraphRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasGraphHandle {
                jsonMap["graphHandle"] = graphHandle
            }
            if hasStepId {
                jsonMap["stepId"] = "\(stepId)"
            }
            if hasExecOpts {
                jsonMap["execOpts"] = try execOpts.encode()
            }
            if !send.isEmpty {
                var jsonArraySend:Array<Dictionary<String,Any>> = []
                for oneValueSend in send {
                    let ecodedMessageSend = try oneValueSend.encode()
                    jsonArraySend.append(ecodedMessageSend)
                }
                jsonMap["send"] = jsonArraySend
            }
            if !recvKey.isEmpty {
                var jsonArrayRecvKey:Array<String> = []
                for oneValueRecvKey in recvKey {
                    jsonArrayRecvKey.append(oneValueRecvKey)
                }
                jsonMap["recvKey"] = jsonArrayRecvKey
            }
            if hasIsPartial {
                jsonMap["isPartial"] = isPartial
            }
            if hasIsLastPartialRun {
                jsonMap["isLastPartialRun"] = isLastPartialRun
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.RunGraphRequest {
            return try Tensorflow.RunGraphRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.RunGraphRequest {
            return try Tensorflow.RunGraphRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasGraphHandle {
                output += "\(indent) graphHandle: \(graphHandle) \n"
            }
            if hasStepId {
                output += "\(indent) stepId: \(stepId) \n"
            }
            var sendElementIndex:Int = 0
            for oneElementSend in send {
                output += "\(indent) send[\(sendElementIndex)] {\n"
                output += try oneElementSend.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                sendElementIndex += 1
            }
            var recvKeyElementIndex:Int = 0
            for oneValueRecvKey in recvKey  {
                output += "\(indent) recvKey[\(recvKeyElementIndex)]: \(oneValueRecvKey)\n"
                recvKeyElementIndex += 1
            }
            if hasExecOpts {
                output += "\(indent) execOpts {\n"
                if let outDescExecOpts = execOpts {
                    output += try outDescExecOpts.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasIsPartial {
                output += "\(indent) isPartial: \(isPartial) \n"
            }
            if hasIsLastPartialRun {
                output += "\(indent) isLastPartialRun: \(isLastPartialRun) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasGraphHandle {
                    hashCode = (hashCode &* 31) &+ graphHandle.hashValue
                }
                if hasStepId {
                    hashCode = (hashCode &* 31) &+ stepId.hashValue
                }
                for oneElementSend in send {
                    hashCode = (hashCode &* 31) &+ oneElementSend.hashValue
                }
                for oneValueRecvKey in recvKey {
                    hashCode = (hashCode &* 31) &+ oneValueRecvKey.hashValue
                }
                if hasExecOpts {
                    if let hashValueexecOpts = execOpts?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueexecOpts
                    }
                }
                if hasIsPartial {
                    hashCode = (hashCode &* 31) &+ isPartial.hashValue
                }
                if hasIsLastPartialRun {
                    hashCode = (hashCode &* 31) &+ isLastPartialRun.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.RunGraphRequest"
        }
        override public func className() -> String {
            return "Tensorflow.RunGraphRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.RunGraphRequest = Tensorflow.RunGraphRequest()
            public func getMessage() -> Tensorflow.RunGraphRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// REQUIRED: graph_handle must be returned by a RegisterGraph call
            /// to the same WorkerService.
            public var graphHandle:String {
                get {
                    return builderResult.graphHandle
                }
                set (value) {
                    builderResult.hasGraphHandle = true
                    builderResult.graphHandle = value
                }
            }
            public var hasGraphHandle:Bool {
                get {
                    return builderResult.hasGraphHandle
                }
            }
            @discardableResult
            public func setGraphHandle(_ value:String) -> Tensorflow.RunGraphRequest.Builder {
                self.graphHandle = value
                return self
            }
            @discardableResult
            public func clearGraphHandle() -> Tensorflow.RunGraphRequest.Builder{
                builderResult.hasGraphHandle = false
                builderResult.graphHandle = ""
                return self
            }
            /// A unique ID to distinguish different runs of the same graph.
            /// The master generates a global unique `step_id` to distinguish
            /// different runs of the graph computation. Subgraphs communicate
            /// (e.g., send/recv ops) with each other using `step_id` to
            /// distinguish tensors generated by different runs.
            public var stepId:Int64 {
                get {
                    return builderResult.stepId
                }
                set (value) {
                    builderResult.hasStepId = true
                    builderResult.stepId = value
                }
            }
            public var hasStepId:Bool {
                get {
                    return builderResult.hasStepId
                }
            }
            @discardableResult
            public func setStepId(_ value:Int64) -> Tensorflow.RunGraphRequest.Builder {
                self.stepId = value
                return self
            }
            @discardableResult
            public func clearStepId() -> Tensorflow.RunGraphRequest.Builder{
                builderResult.hasStepId = false
                builderResult.stepId = Int64(0)
                return self
            }
            /// Options for this step.
            public var execOpts:Tensorflow.ExecutorOpts! {
                get {
                    if execOptsBuilder_ != nil {
                        builderResult.execOpts = execOptsBuilder_.getMessage()
                    }
                    return builderResult.execOpts
                }
                set (value) {
                    builderResult.hasExecOpts = true
                    builderResult.execOpts = value
                }
            }
            public var hasExecOpts:Bool {
                get {
                    return builderResult.hasExecOpts
                }
            }
            fileprivate var execOptsBuilder_:Tensorflow.ExecutorOpts.Builder! {
                didSet {
                    builderResult.hasExecOpts = true
                }
            }
            public func getExecOptsBuilder() -> Tensorflow.ExecutorOpts.Builder {
                if execOptsBuilder_ == nil {
                    execOptsBuilder_ = Tensorflow.ExecutorOpts.Builder()
                    builderResult.execOpts = execOptsBuilder_.getMessage()
                    if execOpts != nil {
                        try! execOptsBuilder_.mergeFrom(other: execOpts)
                    }
                }
                return execOptsBuilder_
            }
            @discardableResult
            public func setExecOpts(_ value:Tensorflow.ExecutorOpts!) -> Tensorflow.RunGraphRequest.Builder {
                self.execOpts = value
                return self
            }
            @discardableResult
            public func mergeExecOpts(value:Tensorflow.ExecutorOpts) throws -> Tensorflow.RunGraphRequest.Builder {
                if builderResult.hasExecOpts {
                    builderResult.execOpts = try Tensorflow.ExecutorOpts.builderWithPrototype(prototype:builderResult.execOpts).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.execOpts = value
                }
                builderResult.hasExecOpts = true
                return self
            }
            @discardableResult
            public func clearExecOpts() -> Tensorflow.RunGraphRequest.Builder {
                execOptsBuilder_ = nil
                builderResult.hasExecOpts = false
                builderResult.execOpts = nil
                return self
            }
            /// Runs the graph.
            /// Sends the tensors in "send" into the graph before the run and
            /// fetches the keys into `RunGraphResponse.recv` after the run.
            public var send:Array<Tensorflow.NamedTensorProto> {
                get {
                    return builderResult.send
                }
                set (value) {
                    builderResult.send = value
                }
            }
            @discardableResult
            public func setSend(_ value:Array<Tensorflow.NamedTensorProto>) -> Tensorflow.RunGraphRequest.Builder {
                self.send = value
                return self
            }
            @discardableResult
            public func clearSend() -> Tensorflow.RunGraphRequest.Builder {
                builderResult.send.removeAll(keepingCapacity: false)
                return self
            }
            public var recvKey:Array<String> {
                get {
                    return builderResult.recvKey
                }
                set (array) {
                    builderResult.recvKey = array
                }
            }
            @discardableResult
            public func setRecvKey(_ value:Array<String>) -> Tensorflow.RunGraphRequest.Builder {
                self.recvKey = value
                return self
            }
            @discardableResult
            public func clearRecvKey() -> Tensorflow.RunGraphRequest.Builder {
                builderResult.recvKey.removeAll(keepingCapacity: false)
                return self
            }
            /// True if the RunGraphRequest is a partial run request.
            public var isPartial:Bool {
                get {
                    return builderResult.isPartial
                }
                set (value) {
                    builderResult.hasIsPartial = true
                    builderResult.isPartial = value
                }
            }
            public var hasIsPartial:Bool {
                get {
                    return builderResult.hasIsPartial
                }
            }
            @discardableResult
            public func setIsPartial(_ value:Bool) -> Tensorflow.RunGraphRequest.Builder {
                self.isPartial = value
                return self
            }
            @discardableResult
            public func clearIsPartial() -> Tensorflow.RunGraphRequest.Builder{
                builderResult.hasIsPartial = false
                builderResult.isPartial = false
                return self
            }
            /// True if this is the last partial run request in a sequence of requests.
            public var isLastPartialRun:Bool {
                get {
                    return builderResult.isLastPartialRun
                }
                set (value) {
                    builderResult.hasIsLastPartialRun = true
                    builderResult.isLastPartialRun = value
                }
            }
            public var hasIsLastPartialRun:Bool {
                get {
                    return builderResult.hasIsLastPartialRun
                }
            }
            @discardableResult
            public func setIsLastPartialRun(_ value:Bool) -> Tensorflow.RunGraphRequest.Builder {
                self.isLastPartialRun = value
                return self
            }
            @discardableResult
            public func clearIsLastPartialRun() -> Tensorflow.RunGraphRequest.Builder{
                builderResult.hasIsLastPartialRun = false
                builderResult.isLastPartialRun = false
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.RunGraphRequest.Builder {
                builderResult = Tensorflow.RunGraphRequest()
                return self
            }
            override public func clone() throws -> Tensorflow.RunGraphRequest.Builder {
                return try Tensorflow.RunGraphRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.RunGraphRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.RunGraphRequest {
                let returnMe:Tensorflow.RunGraphRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.RunGraphRequest) throws -> Tensorflow.RunGraphRequest.Builder {
                if other == Tensorflow.RunGraphRequest() {
                    return self
                }
                if other.hasGraphHandle {
                    graphHandle = other.graphHandle
                }
                if other.hasStepId {
                    stepId = other.stepId
                }
                if (other.hasExecOpts) {
                    try mergeExecOpts(value: other.execOpts)
                }
                if !other.send.isEmpty  {
                     builderResult.send += other.send
                }
                if !other.recvKey.isEmpty {
                    builderResult.recvKey += other.recvKey
                }
                if other.hasIsPartial {
                    isPartial = other.isPartial
                }
                if other.hasIsLastPartialRun {
                    isLastPartialRun = other.isLastPartialRun
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.RunGraphRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RunGraphRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        graphHandle = try codedInputStream.readString()

                    case 16:
                        stepId = try codedInputStream.readInt64()

                    case 26:
                        let subBuilder = Tensorflow.NamedTensorProto.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        send.append(subBuilder.buildPartial())

                    case 34:
                        recvKey += [try codedInputStream.readString()]

                    case 42:
                        let subBuilder:Tensorflow.ExecutorOpts.Builder = Tensorflow.ExecutorOpts.Builder()
                        if hasExecOpts {
                            try subBuilder.mergeFrom(other: execOpts)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        execOpts = subBuilder.buildPartial()

                    case 48:
                        isPartial = try codedInputStream.readBool()

                    case 56:
                        isLastPartialRun = try codedInputStream.readBool()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.RunGraphRequest.Builder {
                let resultDecodedBuilder = Tensorflow.RunGraphRequest.Builder()
                if let jsonValueGraphHandle = jsonMap["graphHandle"] as? String {
                    resultDecodedBuilder.graphHandle = jsonValueGraphHandle
                }
                if let jsonValueStepId = jsonMap["stepId"] as? String {
                    resultDecodedBuilder.stepId = Int64(jsonValueStepId)!
                } else if let jsonValueStepId = jsonMap["stepId"] as? Int {
                    resultDecodedBuilder.stepId = Int64(jsonValueStepId)
                }
                if let jsonValueExecOpts = jsonMap["execOpts"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.execOpts = try Tensorflow.ExecutorOpts.Builder.decodeToBuilder(jsonMap:jsonValueExecOpts).build()

                }
                if let jsonValueSend = jsonMap["send"] as? Array<Dictionary<String,Any>> {
                    var jsonArraySend:Array<Tensorflow.NamedTensorProto> = []
                    for oneValueSend in jsonValueSend {
                        let messageFromStringSend = try Tensorflow.NamedTensorProto.Builder.decodeToBuilder(jsonMap:oneValueSend).build()

                        jsonArraySend.append(messageFromStringSend)
                    }
                    resultDecodedBuilder.send = jsonArraySend
                }
                if let jsonValueRecvKey = jsonMap["recvKey"] as? Array<String> {
                    var jsonArrayRecvKey:Array<String> = []
                    for oneValueRecvKey in jsonValueRecvKey {
                        jsonArrayRecvKey.append(oneValueRecvKey)
                    }
                    resultDecodedBuilder.recvKey = jsonArrayRecvKey
                }
                if let jsonValueIsPartial = jsonMap["isPartial"] as? Bool {
                    resultDecodedBuilder.isPartial = jsonValueIsPartial
                }
                if let jsonValueIsLastPartialRun = jsonMap["isLastPartialRun"] as? Bool {
                    resultDecodedBuilder.isLastPartialRun = jsonValueIsLastPartialRun
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.RunGraphRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.RunGraphRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class RunGraphResponse : GeneratedMessage {

        public static func == (lhs: Tensorflow.RunGraphResponse, rhs: Tensorflow.RunGraphResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.recv == rhs.recv)
            fieldCheck = fieldCheck && (lhs.hasStepStats == rhs.hasStepStats) && (!lhs.hasStepStats || lhs.stepStats == rhs.stepStats)
            fieldCheck = fieldCheck && (lhs.hasCostGraph == rhs.hasCostGraph) && (!lhs.hasCostGraph || lhs.costGraph == rhs.costGraph)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var recv:Array<Tensorflow.NamedTensorProto>  = Array<Tensorflow.NamedTensorProto>()
        public fileprivate(set) var stepStats:Tensorflow.StepStats!
        public fileprivate(set) var hasStepStats:Bool = false
        public fileprivate(set) var costGraph:Tensorflow.CostGraphDef!
        public fileprivate(set) var hasCostGraph:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementRecv in recv {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementRecv)
            }
            if hasStepStats {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:stepStats)
            }
            if hasCostGraph {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:costGraph)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementRecv in recv {
                serialize_size += oneElementRecv.computeMessageSize(fieldNumber: 1)
            }
            if hasStepStats {
                if let varSizestepStats = stepStats?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizestepStats
                }
            }
            if hasCostGraph {
                if let varSizecostGraph = costGraph?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizecostGraph
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.RunGraphResponse.Builder {
            return Tensorflow.RunGraphResponse.classBuilder() as! Tensorflow.RunGraphResponse.Builder
        }
        public func getBuilder() -> Tensorflow.RunGraphResponse.Builder {
            return classBuilder() as! Tensorflow.RunGraphResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.RunGraphResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.RunGraphResponse.Builder()
        }
        public func toBuilder() throws -> Tensorflow.RunGraphResponse.Builder {
            return try Tensorflow.RunGraphResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.RunGraphResponse) throws -> Tensorflow.RunGraphResponse.Builder {
            return try Tensorflow.RunGraphResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !recv.isEmpty {
                var jsonArrayRecv:Array<Dictionary<String,Any>> = []
                for oneValueRecv in recv {
                    let ecodedMessageRecv = try oneValueRecv.encode()
                    jsonArrayRecv.append(ecodedMessageRecv)
                }
                jsonMap["recv"] = jsonArrayRecv
            }
            if hasStepStats {
                jsonMap["stepStats"] = try stepStats.encode()
            }
            if hasCostGraph {
                jsonMap["costGraph"] = try costGraph.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.RunGraphResponse {
            return try Tensorflow.RunGraphResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.RunGraphResponse {
            return try Tensorflow.RunGraphResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var recvElementIndex:Int = 0
            for oneElementRecv in recv {
                output += "\(indent) recv[\(recvElementIndex)] {\n"
                output += try oneElementRecv.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                recvElementIndex += 1
            }
            if hasStepStats {
                output += "\(indent) stepStats {\n"
                if let outDescStepStats = stepStats {
                    output += try outDescStepStats.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasCostGraph {
                output += "\(indent) costGraph {\n"
                if let outDescCostGraph = costGraph {
                    output += try outDescCostGraph.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementRecv in recv {
                    hashCode = (hashCode &* 31) &+ oneElementRecv.hashValue
                }
                if hasStepStats {
                    if let hashValuestepStats = stepStats?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuestepStats
                    }
                }
                if hasCostGraph {
                    if let hashValuecostGraph = costGraph?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecostGraph
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.RunGraphResponse"
        }
        override public func className() -> String {
            return "Tensorflow.RunGraphResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.RunGraphResponse = Tensorflow.RunGraphResponse()
            public func getMessage() -> Tensorflow.RunGraphResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// A list of tensors corresponding to those requested by
            /// `RunGraphRequest.recv_key`.
            public var recv:Array<Tensorflow.NamedTensorProto> {
                get {
                    return builderResult.recv
                }
                set (value) {
                    builderResult.recv = value
                }
            }
            @discardableResult
            public func setRecv(_ value:Array<Tensorflow.NamedTensorProto>) -> Tensorflow.RunGraphResponse.Builder {
                self.recv = value
                return self
            }
            @discardableResult
            public func clearRecv() -> Tensorflow.RunGraphResponse.Builder {
                builderResult.recv.removeAll(keepingCapacity: false)
                return self
            }
            /// If the request asked for execution stats or cost graph, these are returned
            /// here.
            public var stepStats:Tensorflow.StepStats! {
                get {
                    if stepStatsBuilder_ != nil {
                        builderResult.stepStats = stepStatsBuilder_.getMessage()
                    }
                    return builderResult.stepStats
                }
                set (value) {
                    builderResult.hasStepStats = true
                    builderResult.stepStats = value
                }
            }
            public var hasStepStats:Bool {
                get {
                    return builderResult.hasStepStats
                }
            }
            fileprivate var stepStatsBuilder_:Tensorflow.StepStats.Builder! {
                didSet {
                    builderResult.hasStepStats = true
                }
            }
            public func getStepStatsBuilder() -> Tensorflow.StepStats.Builder {
                if stepStatsBuilder_ == nil {
                    stepStatsBuilder_ = Tensorflow.StepStats.Builder()
                    builderResult.stepStats = stepStatsBuilder_.getMessage()
                    if stepStats != nil {
                        try! stepStatsBuilder_.mergeFrom(other: stepStats)
                    }
                }
                return stepStatsBuilder_
            }
            @discardableResult
            public func setStepStats(_ value:Tensorflow.StepStats!) -> Tensorflow.RunGraphResponse.Builder {
                self.stepStats = value
                return self
            }
            @discardableResult
            public func mergeStepStats(value:Tensorflow.StepStats) throws -> Tensorflow.RunGraphResponse.Builder {
                if builderResult.hasStepStats {
                    builderResult.stepStats = try Tensorflow.StepStats.builderWithPrototype(prototype:builderResult.stepStats).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.stepStats = value
                }
                builderResult.hasStepStats = true
                return self
            }
            @discardableResult
            public func clearStepStats() -> Tensorflow.RunGraphResponse.Builder {
                stepStatsBuilder_ = nil
                builderResult.hasStepStats = false
                builderResult.stepStats = nil
                return self
            }
            public var costGraph:Tensorflow.CostGraphDef! {
                get {
                    if costGraphBuilder_ != nil {
                        builderResult.costGraph = costGraphBuilder_.getMessage()
                    }
                    return builderResult.costGraph
                }
                set (value) {
                    builderResult.hasCostGraph = true
                    builderResult.costGraph = value
                }
            }
            public var hasCostGraph:Bool {
                get {
                    return builderResult.hasCostGraph
                }
            }
            fileprivate var costGraphBuilder_:Tensorflow.CostGraphDef.Builder! {
                didSet {
                    builderResult.hasCostGraph = true
                }
            }
            public func getCostGraphBuilder() -> Tensorflow.CostGraphDef.Builder {
                if costGraphBuilder_ == nil {
                    costGraphBuilder_ = Tensorflow.CostGraphDef.Builder()
                    builderResult.costGraph = costGraphBuilder_.getMessage()
                    if costGraph != nil {
                        try! costGraphBuilder_.mergeFrom(other: costGraph)
                    }
                }
                return costGraphBuilder_
            }
            @discardableResult
            public func setCostGraph(_ value:Tensorflow.CostGraphDef!) -> Tensorflow.RunGraphResponse.Builder {
                self.costGraph = value
                return self
            }
            @discardableResult
            public func mergeCostGraph(value:Tensorflow.CostGraphDef) throws -> Tensorflow.RunGraphResponse.Builder {
                if builderResult.hasCostGraph {
                    builderResult.costGraph = try Tensorflow.CostGraphDef.builderWithPrototype(prototype:builderResult.costGraph).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.costGraph = value
                }
                builderResult.hasCostGraph = true
                return self
            }
            @discardableResult
            public func clearCostGraph() -> Tensorflow.RunGraphResponse.Builder {
                costGraphBuilder_ = nil
                builderResult.hasCostGraph = false
                builderResult.costGraph = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.RunGraphResponse.Builder {
                builderResult = Tensorflow.RunGraphResponse()
                return self
            }
            override public func clone() throws -> Tensorflow.RunGraphResponse.Builder {
                return try Tensorflow.RunGraphResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.RunGraphResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.RunGraphResponse {
                let returnMe:Tensorflow.RunGraphResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.RunGraphResponse) throws -> Tensorflow.RunGraphResponse.Builder {
                if other == Tensorflow.RunGraphResponse() {
                    return self
                }
                if !other.recv.isEmpty  {
                     builderResult.recv += other.recv
                }
                if (other.hasStepStats) {
                    try mergeStepStats(value: other.stepStats)
                }
                if (other.hasCostGraph) {
                    try mergeCostGraph(value: other.costGraph)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.RunGraphResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RunGraphResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Tensorflow.NamedTensorProto.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        recv.append(subBuilder.buildPartial())

                    case 18:
                        let subBuilder:Tensorflow.StepStats.Builder = Tensorflow.StepStats.Builder()
                        if hasStepStats {
                            try subBuilder.mergeFrom(other: stepStats)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        stepStats = subBuilder.buildPartial()

                    case 26:
                        let subBuilder:Tensorflow.CostGraphDef.Builder = Tensorflow.CostGraphDef.Builder()
                        if hasCostGraph {
                            try subBuilder.mergeFrom(other: costGraph)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        costGraph = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.RunGraphResponse.Builder {
                let resultDecodedBuilder = Tensorflow.RunGraphResponse.Builder()
                if let jsonValueRecv = jsonMap["recv"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayRecv:Array<Tensorflow.NamedTensorProto> = []
                    for oneValueRecv in jsonValueRecv {
                        let messageFromStringRecv = try Tensorflow.NamedTensorProto.Builder.decodeToBuilder(jsonMap:oneValueRecv).build()

                        jsonArrayRecv.append(messageFromStringRecv)
                    }
                    resultDecodedBuilder.recv = jsonArrayRecv
                }
                if let jsonValueStepStats = jsonMap["stepStats"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.stepStats = try Tensorflow.StepStats.Builder.decodeToBuilder(jsonMap:jsonValueStepStats).build()

                }
                if let jsonValueCostGraph = jsonMap["costGraph"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.costGraph = try Tensorflow.CostGraphDef.Builder.decodeToBuilder(jsonMap:jsonValueCostGraph).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.RunGraphResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.RunGraphResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class CleanupGraphRequest : GeneratedMessage {

        public static func == (lhs: Tensorflow.CleanupGraphRequest, rhs: Tensorflow.CleanupGraphRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasStepId == rhs.hasStepId) && (!lhs.hasStepId || lhs.stepId == rhs.stepId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var stepId:Int64 = Int64(0)
        public fileprivate(set) var hasStepId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasStepId {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:stepId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasStepId {
                serialize_size += stepId.computeInt64Size(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.CleanupGraphRequest.Builder {
            return Tensorflow.CleanupGraphRequest.classBuilder() as! Tensorflow.CleanupGraphRequest.Builder
        }
        public func getBuilder() -> Tensorflow.CleanupGraphRequest.Builder {
            return classBuilder() as! Tensorflow.CleanupGraphRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.CleanupGraphRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.CleanupGraphRequest.Builder()
        }
        public func toBuilder() throws -> Tensorflow.CleanupGraphRequest.Builder {
            return try Tensorflow.CleanupGraphRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.CleanupGraphRequest) throws -> Tensorflow.CleanupGraphRequest.Builder {
            return try Tensorflow.CleanupGraphRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasStepId {
                jsonMap["stepId"] = "\(stepId)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CleanupGraphRequest {
            return try Tensorflow.CleanupGraphRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.CleanupGraphRequest {
            return try Tensorflow.CleanupGraphRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasStepId {
                output += "\(indent) stepId: \(stepId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasStepId {
                    hashCode = (hashCode &* 31) &+ stepId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.CleanupGraphRequest"
        }
        override public func className() -> String {
            return "Tensorflow.CleanupGraphRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.CleanupGraphRequest = Tensorflow.CleanupGraphRequest()
            public func getMessage() -> Tensorflow.CleanupGraphRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var stepId:Int64 {
                get {
                    return builderResult.stepId
                }
                set (value) {
                    builderResult.hasStepId = true
                    builderResult.stepId = value
                }
            }
            public var hasStepId:Bool {
                get {
                    return builderResult.hasStepId
                }
            }
            @discardableResult
            public func setStepId(_ value:Int64) -> Tensorflow.CleanupGraphRequest.Builder {
                self.stepId = value
                return self
            }
            @discardableResult
            public func clearStepId() -> Tensorflow.CleanupGraphRequest.Builder{
                builderResult.hasStepId = false
                builderResult.stepId = Int64(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.CleanupGraphRequest.Builder {
                builderResult = Tensorflow.CleanupGraphRequest()
                return self
            }
            override public func clone() throws -> Tensorflow.CleanupGraphRequest.Builder {
                return try Tensorflow.CleanupGraphRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.CleanupGraphRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.CleanupGraphRequest {
                let returnMe:Tensorflow.CleanupGraphRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.CleanupGraphRequest) throws -> Tensorflow.CleanupGraphRequest.Builder {
                if other == Tensorflow.CleanupGraphRequest() {
                    return self
                }
                if other.hasStepId {
                    stepId = other.stepId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CleanupGraphRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CleanupGraphRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        stepId = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CleanupGraphRequest.Builder {
                let resultDecodedBuilder = Tensorflow.CleanupGraphRequest.Builder()
                if let jsonValueStepId = jsonMap["stepId"] as? String {
                    resultDecodedBuilder.stepId = Int64(jsonValueStepId)!
                } else if let jsonValueStepId = jsonMap["stepId"] as? Int {
                    resultDecodedBuilder.stepId = Int64(jsonValueStepId)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.CleanupGraphRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.CleanupGraphRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class CleanupGraphResponse : GeneratedMessage {

        public static func == (lhs: Tensorflow.CleanupGraphResponse, rhs: Tensorflow.CleanupGraphResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.CleanupGraphResponse.Builder {
            return Tensorflow.CleanupGraphResponse.classBuilder() as! Tensorflow.CleanupGraphResponse.Builder
        }
        public func getBuilder() -> Tensorflow.CleanupGraphResponse.Builder {
            return classBuilder() as! Tensorflow.CleanupGraphResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.CleanupGraphResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.CleanupGraphResponse.Builder()
        }
        public func toBuilder() throws -> Tensorflow.CleanupGraphResponse.Builder {
            return try Tensorflow.CleanupGraphResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.CleanupGraphResponse) throws -> Tensorflow.CleanupGraphResponse.Builder {
            return try Tensorflow.CleanupGraphResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CleanupGraphResponse {
            return try Tensorflow.CleanupGraphResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.CleanupGraphResponse {
            return try Tensorflow.CleanupGraphResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.CleanupGraphResponse"
        }
        override public func className() -> String {
            return "Tensorflow.CleanupGraphResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.CleanupGraphResponse = Tensorflow.CleanupGraphResponse()
            public func getMessage() -> Tensorflow.CleanupGraphResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.CleanupGraphResponse.Builder {
                builderResult = Tensorflow.CleanupGraphResponse()
                return self
            }
            override public func clone() throws -> Tensorflow.CleanupGraphResponse.Builder {
                return try Tensorflow.CleanupGraphResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.CleanupGraphResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.CleanupGraphResponse {
                let returnMe:Tensorflow.CleanupGraphResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.CleanupGraphResponse) throws -> Tensorflow.CleanupGraphResponse.Builder {
                if other == Tensorflow.CleanupGraphResponse() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CleanupGraphResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CleanupGraphResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.CleanupGraphResponse.Builder {
                let resultDecodedBuilder = Tensorflow.CleanupGraphResponse.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.CleanupGraphResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.CleanupGraphResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class RecvTensorRequest : GeneratedMessage {

        public static func == (lhs: Tensorflow.RecvTensorRequest, rhs: Tensorflow.RecvTensorRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasStepId == rhs.hasStepId) && (!lhs.hasStepId || lhs.stepId == rhs.stepId)
            fieldCheck = fieldCheck && (lhs.hasRendezvousKey == rhs.hasRendezvousKey) && (!lhs.hasRendezvousKey || lhs.rendezvousKey == rhs.rendezvousKey)
            fieldCheck = fieldCheck && (lhs.hasDmaOk == rhs.hasDmaOk) && (!lhs.hasDmaOk || lhs.dmaOk == rhs.dmaOk)
            fieldCheck = fieldCheck && (lhs.hasClientLocality == rhs.hasClientLocality) && (!lhs.hasClientLocality || lhs.clientLocality == rhs.clientLocality)
            fieldCheck = fieldCheck && (lhs.hasServerLocality == rhs.hasServerLocality) && (!lhs.hasServerLocality || lhs.serverLocality == rhs.serverLocality)
            fieldCheck = fieldCheck && (lhs.hasTransportOptions == rhs.hasTransportOptions) && (!lhs.hasTransportOptions || lhs.transportOptions == rhs.transportOptions)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// The step in which the tensor will be produced.
        /// REQUIRED: This must eventually correspond to the `step_id` passed
        /// into a RunGraph call on the same WorkerService.
        public fileprivate(set) var stepId:Int64 = Int64(0)
        public fileprivate(set) var hasStepId:Bool = false

        /// A key that identifies the tensor to be received.
        public fileprivate(set) var rendezvousKey:String = ""
        public fileprivate(set) var hasRendezvousKey:Bool = false

        /// If true, use an out-of-band DMA mechanism to transfer the
        /// received tensor.
        public fileprivate(set) var dmaOk:Bool = false
        public fileprivate(set) var hasDmaOk:Bool = false

        public fileprivate(set) var clientLocality:Tensorflow.DeviceLocality!
        public fileprivate(set) var hasClientLocality:Bool = false
        public fileprivate(set) var serverLocality:Tensorflow.DeviceLocality!
        public fileprivate(set) var hasServerLocality:Bool = false
        public fileprivate(set) var transportOptions:Google.Protobuf.`Any`!
        public fileprivate(set) var hasTransportOptions:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasStepId {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:stepId)
            }
            if hasRendezvousKey {
                try codedOutputStream.writeString(fieldNumber: 2, value:rendezvousKey)
            }
            if hasDmaOk {
                try codedOutputStream.writeBool(fieldNumber: 3, value:dmaOk)
            }
            if hasClientLocality {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:clientLocality)
            }
            if hasServerLocality {
                try codedOutputStream.writeMessage(fieldNumber: 5, value:serverLocality)
            }
            if hasTransportOptions {
                try codedOutputStream.writeMessage(fieldNumber: 6, value:transportOptions)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasStepId {
                serialize_size += stepId.computeInt64Size(fieldNumber: 1)
            }
            if hasRendezvousKey {
                serialize_size += rendezvousKey.computeStringSize(fieldNumber: 2)
            }
            if hasDmaOk {
                serialize_size += dmaOk.computeBoolSize(fieldNumber: 3)
            }
            if hasClientLocality {
                if let varSizeclientLocality = clientLocality?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizeclientLocality
                }
            }
            if hasServerLocality {
                if let varSizeserverLocality = serverLocality?.computeMessageSize(fieldNumber: 5) {
                    serialize_size += varSizeserverLocality
                }
            }
            if hasTransportOptions {
                if let varSizetransportOptions = transportOptions?.computeMessageSize(fieldNumber: 6) {
                    serialize_size += varSizetransportOptions
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.RecvTensorRequest.Builder {
            return Tensorflow.RecvTensorRequest.classBuilder() as! Tensorflow.RecvTensorRequest.Builder
        }
        public func getBuilder() -> Tensorflow.RecvTensorRequest.Builder {
            return classBuilder() as! Tensorflow.RecvTensorRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.RecvTensorRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.RecvTensorRequest.Builder()
        }
        public func toBuilder() throws -> Tensorflow.RecvTensorRequest.Builder {
            return try Tensorflow.RecvTensorRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.RecvTensorRequest) throws -> Tensorflow.RecvTensorRequest.Builder {
            return try Tensorflow.RecvTensorRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasStepId {
                jsonMap["stepId"] = "\(stepId)"
            }
            if hasRendezvousKey {
                jsonMap["rendezvousKey"] = rendezvousKey
            }
            if hasDmaOk {
                jsonMap["dmaOk"] = dmaOk
            }
            if hasClientLocality {
                jsonMap["clientLocality"] = try clientLocality.encode()
            }
            if hasServerLocality {
                jsonMap["serverLocality"] = try serverLocality.encode()
            }
            if hasTransportOptions {
                jsonMap["transportOptions"] = try transportOptions.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.RecvTensorRequest {
            return try Tensorflow.RecvTensorRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.RecvTensorRequest {
            return try Tensorflow.RecvTensorRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasStepId {
                output += "\(indent) stepId: \(stepId) \n"
            }
            if hasRendezvousKey {
                output += "\(indent) rendezvousKey: \(rendezvousKey) \n"
            }
            if hasDmaOk {
                output += "\(indent) dmaOk: \(dmaOk) \n"
            }
            if hasClientLocality {
                output += "\(indent) clientLocality {\n"
                if let outDescClientLocality = clientLocality {
                    output += try outDescClientLocality.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasServerLocality {
                output += "\(indent) serverLocality {\n"
                if let outDescServerLocality = serverLocality {
                    output += try outDescServerLocality.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasTransportOptions {
                output += "\(indent) transportOptions {\n"
                if let outDescTransportOptions = transportOptions {
                    output += try outDescTransportOptions.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasStepId {
                    hashCode = (hashCode &* 31) &+ stepId.hashValue
                }
                if hasRendezvousKey {
                    hashCode = (hashCode &* 31) &+ rendezvousKey.hashValue
                }
                if hasDmaOk {
                    hashCode = (hashCode &* 31) &+ dmaOk.hashValue
                }
                if hasClientLocality {
                    if let hashValueclientLocality = clientLocality?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueclientLocality
                    }
                }
                if hasServerLocality {
                    if let hashValueserverLocality = serverLocality?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueserverLocality
                    }
                }
                if hasTransportOptions {
                    if let hashValuetransportOptions = transportOptions?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuetransportOptions
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.RecvTensorRequest"
        }
        override public func className() -> String {
            return "Tensorflow.RecvTensorRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.RecvTensorRequest = Tensorflow.RecvTensorRequest()
            public func getMessage() -> Tensorflow.RecvTensorRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The step in which the tensor will be produced.
            /// REQUIRED: This must eventually correspond to the `step_id` passed
            /// into a RunGraph call on the same WorkerService.
            public var stepId:Int64 {
                get {
                    return builderResult.stepId
                }
                set (value) {
                    builderResult.hasStepId = true
                    builderResult.stepId = value
                }
            }
            public var hasStepId:Bool {
                get {
                    return builderResult.hasStepId
                }
            }
            @discardableResult
            public func setStepId(_ value:Int64) -> Tensorflow.RecvTensorRequest.Builder {
                self.stepId = value
                return self
            }
            @discardableResult
            public func clearStepId() -> Tensorflow.RecvTensorRequest.Builder{
                builderResult.hasStepId = false
                builderResult.stepId = Int64(0)
                return self
            }
            /// A key that identifies the tensor to be received.
            public var rendezvousKey:String {
                get {
                    return builderResult.rendezvousKey
                }
                set (value) {
                    builderResult.hasRendezvousKey = true
                    builderResult.rendezvousKey = value
                }
            }
            public var hasRendezvousKey:Bool {
                get {
                    return builderResult.hasRendezvousKey
                }
            }
            @discardableResult
            public func setRendezvousKey(_ value:String) -> Tensorflow.RecvTensorRequest.Builder {
                self.rendezvousKey = value
                return self
            }
            @discardableResult
            public func clearRendezvousKey() -> Tensorflow.RecvTensorRequest.Builder{
                builderResult.hasRendezvousKey = false
                builderResult.rendezvousKey = ""
                return self
            }
            /// If true, use an out-of-band DMA mechanism to transfer the
            /// received tensor.
            public var dmaOk:Bool {
                get {
                    return builderResult.dmaOk
                }
                set (value) {
                    builderResult.hasDmaOk = true
                    builderResult.dmaOk = value
                }
            }
            public var hasDmaOk:Bool {
                get {
                    return builderResult.hasDmaOk
                }
            }
            @discardableResult
            public func setDmaOk(_ value:Bool) -> Tensorflow.RecvTensorRequest.Builder {
                self.dmaOk = value
                return self
            }
            @discardableResult
            public func clearDmaOk() -> Tensorflow.RecvTensorRequest.Builder{
                builderResult.hasDmaOk = false
                builderResult.dmaOk = false
                return self
            }
            /// Optional information on client-side device locality.
            public var clientLocality:Tensorflow.DeviceLocality! {
                get {
                    if clientLocalityBuilder_ != nil {
                        builderResult.clientLocality = clientLocalityBuilder_.getMessage()
                    }
                    return builderResult.clientLocality
                }
                set (value) {
                    builderResult.hasClientLocality = true
                    builderResult.clientLocality = value
                }
            }
            public var hasClientLocality:Bool {
                get {
                    return builderResult.hasClientLocality
                }
            }
            fileprivate var clientLocalityBuilder_:Tensorflow.DeviceLocality.Builder! {
                didSet {
                    builderResult.hasClientLocality = true
                }
            }
            public func getClientLocalityBuilder() -> Tensorflow.DeviceLocality.Builder {
                if clientLocalityBuilder_ == nil {
                    clientLocalityBuilder_ = Tensorflow.DeviceLocality.Builder()
                    builderResult.clientLocality = clientLocalityBuilder_.getMessage()
                    if clientLocality != nil {
                        try! clientLocalityBuilder_.mergeFrom(other: clientLocality)
                    }
                }
                return clientLocalityBuilder_
            }
            @discardableResult
            public func setClientLocality(_ value:Tensorflow.DeviceLocality!) -> Tensorflow.RecvTensorRequest.Builder {
                self.clientLocality = value
                return self
            }
            @discardableResult
            public func mergeClientLocality(value:Tensorflow.DeviceLocality) throws -> Tensorflow.RecvTensorRequest.Builder {
                if builderResult.hasClientLocality {
                    builderResult.clientLocality = try Tensorflow.DeviceLocality.builderWithPrototype(prototype:builderResult.clientLocality).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.clientLocality = value
                }
                builderResult.hasClientLocality = true
                return self
            }
            @discardableResult
            public func clearClientLocality() -> Tensorflow.RecvTensorRequest.Builder {
                clientLocalityBuilder_ = nil
                builderResult.hasClientLocality = false
                builderResult.clientLocality = nil
                return self
            }
            /// Optional information on server-side device locality.
            public var serverLocality:Tensorflow.DeviceLocality! {
                get {
                    if serverLocalityBuilder_ != nil {
                        builderResult.serverLocality = serverLocalityBuilder_.getMessage()
                    }
                    return builderResult.serverLocality
                }
                set (value) {
                    builderResult.hasServerLocality = true
                    builderResult.serverLocality = value
                }
            }
            public var hasServerLocality:Bool {
                get {
                    return builderResult.hasServerLocality
                }
            }
            fileprivate var serverLocalityBuilder_:Tensorflow.DeviceLocality.Builder! {
                didSet {
                    builderResult.hasServerLocality = true
                }
            }
            public func getServerLocalityBuilder() -> Tensorflow.DeviceLocality.Builder {
                if serverLocalityBuilder_ == nil {
                    serverLocalityBuilder_ = Tensorflow.DeviceLocality.Builder()
                    builderResult.serverLocality = serverLocalityBuilder_.getMessage()
                    if serverLocality != nil {
                        try! serverLocalityBuilder_.mergeFrom(other: serverLocality)
                    }
                }
                return serverLocalityBuilder_
            }
            @discardableResult
            public func setServerLocality(_ value:Tensorflow.DeviceLocality!) -> Tensorflow.RecvTensorRequest.Builder {
                self.serverLocality = value
                return self
            }
            @discardableResult
            public func mergeServerLocality(value:Tensorflow.DeviceLocality) throws -> Tensorflow.RecvTensorRequest.Builder {
                if builderResult.hasServerLocality {
                    builderResult.serverLocality = try Tensorflow.DeviceLocality.builderWithPrototype(prototype:builderResult.serverLocality).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.serverLocality = value
                }
                builderResult.hasServerLocality = true
                return self
            }
            @discardableResult
            public func clearServerLocality() -> Tensorflow.RecvTensorRequest.Builder {
                serverLocalityBuilder_ = nil
                builderResult.hasServerLocality = false
                builderResult.serverLocality = nil
                return self
            }
            /// Optional information needed by the RPC subsystem.
            public var transportOptions:Google.Protobuf.`Any`! {
                get {
                    if transportOptionsBuilder_ != nil {
                        builderResult.transportOptions = transportOptionsBuilder_.getMessage()
                    }
                    return builderResult.transportOptions
                }
                set (value) {
                    builderResult.hasTransportOptions = true
                    builderResult.transportOptions = value
                }
            }
            public var hasTransportOptions:Bool {
                get {
                    return builderResult.hasTransportOptions
                }
            }
            fileprivate var transportOptionsBuilder_:Google.Protobuf.`Any`.Builder! {
                didSet {
                    builderResult.hasTransportOptions = true
                }
            }
            public func getTransportOptionsBuilder() -> Google.Protobuf.`Any`.Builder {
                if transportOptionsBuilder_ == nil {
                    transportOptionsBuilder_ = Google.Protobuf.`Any`.Builder()
                    builderResult.transportOptions = transportOptionsBuilder_.getMessage()
                    if transportOptions != nil {
                        try! transportOptionsBuilder_.mergeFrom(other: transportOptions)
                    }
                }
                return transportOptionsBuilder_
            }
            @discardableResult
            public func setTransportOptions(_ value:Google.Protobuf.`Any`!) -> Tensorflow.RecvTensorRequest.Builder {
                self.transportOptions = value
                return self
            }
            @discardableResult
            public func mergeTransportOptions(value:Google.Protobuf.`Any`) throws -> Tensorflow.RecvTensorRequest.Builder {
                if builderResult.hasTransportOptions {
                    builderResult.transportOptions = try Google.Protobuf.`Any`.builderWithPrototype(prototype:builderResult.transportOptions).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.transportOptions = value
                }
                builderResult.hasTransportOptions = true
                return self
            }
            @discardableResult
            public func clearTransportOptions() -> Tensorflow.RecvTensorRequest.Builder {
                transportOptionsBuilder_ = nil
                builderResult.hasTransportOptions = false
                builderResult.transportOptions = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.RecvTensorRequest.Builder {
                builderResult = Tensorflow.RecvTensorRequest()
                return self
            }
            override public func clone() throws -> Tensorflow.RecvTensorRequest.Builder {
                return try Tensorflow.RecvTensorRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.RecvTensorRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.RecvTensorRequest {
                let returnMe:Tensorflow.RecvTensorRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.RecvTensorRequest) throws -> Tensorflow.RecvTensorRequest.Builder {
                if other == Tensorflow.RecvTensorRequest() {
                    return self
                }
                if other.hasStepId {
                    stepId = other.stepId
                }
                if other.hasRendezvousKey {
                    rendezvousKey = other.rendezvousKey
                }
                if other.hasDmaOk {
                    dmaOk = other.dmaOk
                }
                if (other.hasClientLocality) {
                    try mergeClientLocality(value: other.clientLocality)
                }
                if (other.hasServerLocality) {
                    try mergeServerLocality(value: other.serverLocality)
                }
                if (other.hasTransportOptions) {
                    try mergeTransportOptions(value: other.transportOptions)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.RecvTensorRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RecvTensorRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        stepId = try codedInputStream.readInt64()

                    case 18:
                        rendezvousKey = try codedInputStream.readString()

                    case 24:
                        dmaOk = try codedInputStream.readBool()

                    case 34:
                        let subBuilder:Tensorflow.DeviceLocality.Builder = Tensorflow.DeviceLocality.Builder()
                        if hasClientLocality {
                            try subBuilder.mergeFrom(other: clientLocality)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        clientLocality = subBuilder.buildPartial()

                    case 42:
                        let subBuilder:Tensorflow.DeviceLocality.Builder = Tensorflow.DeviceLocality.Builder()
                        if hasServerLocality {
                            try subBuilder.mergeFrom(other: serverLocality)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        serverLocality = subBuilder.buildPartial()

                    case 50:
                        let subBuilder:Google.Protobuf.`Any`.Builder = Google.Protobuf.`Any`.Builder()
                        if hasTransportOptions {
                            try subBuilder.mergeFrom(other: transportOptions)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        transportOptions = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.RecvTensorRequest.Builder {
                let resultDecodedBuilder = Tensorflow.RecvTensorRequest.Builder()
                if let jsonValueStepId = jsonMap["stepId"] as? String {
                    resultDecodedBuilder.stepId = Int64(jsonValueStepId)!
                } else if let jsonValueStepId = jsonMap["stepId"] as? Int {
                    resultDecodedBuilder.stepId = Int64(jsonValueStepId)
                }
                if let jsonValueRendezvousKey = jsonMap["rendezvousKey"] as? String {
                    resultDecodedBuilder.rendezvousKey = jsonValueRendezvousKey
                }
                if let jsonValueDmaOk = jsonMap["dmaOk"] as? Bool {
                    resultDecodedBuilder.dmaOk = jsonValueDmaOk
                }
                if let jsonValueClientLocality = jsonMap["clientLocality"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.clientLocality = try Tensorflow.DeviceLocality.Builder.decodeToBuilder(jsonMap:jsonValueClientLocality).build()

                }
                if let jsonValueServerLocality = jsonMap["serverLocality"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.serverLocality = try Tensorflow.DeviceLocality.Builder.decodeToBuilder(jsonMap:jsonValueServerLocality).build()

                }
                if let jsonValueTransportOptions = jsonMap["transportOptions"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.transportOptions = try Google.Protobuf.`Any`.Builder.decodeToBuilder(jsonMap:jsonValueTransportOptions).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.RecvTensorRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.RecvTensorRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class RecvTensorResponse : GeneratedMessage {

        public static func == (lhs: Tensorflow.RecvTensorResponse, rhs: Tensorflow.RecvTensorResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasTensor == rhs.hasTensor) && (!lhs.hasTensor || lhs.tensor == rhs.tensor)
            fieldCheck = fieldCheck && (lhs.hasIsDead == rhs.hasIsDead) && (!lhs.hasIsDead || lhs.isDead == rhs.isDead)
            fieldCheck = fieldCheck && (lhs.hasSendStartMicros == rhs.hasSendStartMicros) && (!lhs.hasSendStartMicros || lhs.sendStartMicros == rhs.sendStartMicros)
            fieldCheck = fieldCheck && (lhs.hasTransportOptions == rhs.hasTransportOptions) && (!lhs.hasTransportOptions || lhs.transportOptions == rhs.transportOptions)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var tensor:Tensorflow.TensorProto!
        public fileprivate(set) var hasTensor:Bool = false
        /// If true, this tensor was the output of a dead node, and the
        /// content is invalid.
        public fileprivate(set) var isDead:Bool = false
        public fileprivate(set) var hasIsDead:Bool = false

        /// The time at which tensor was available and started to be returned.
        public fileprivate(set) var sendStartMicros:Int64 = Int64(0)
        public fileprivate(set) var hasSendStartMicros:Bool = false

        public fileprivate(set) var transportOptions:Google.Protobuf.`Any`!
        public fileprivate(set) var hasTransportOptions:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasTensor {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:tensor)
            }
            if hasIsDead {
                try codedOutputStream.writeBool(fieldNumber: 2, value:isDead)
            }
            if hasSendStartMicros {
                try codedOutputStream.writeInt64(fieldNumber: 3, value:sendStartMicros)
            }
            if hasTransportOptions {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:transportOptions)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasTensor {
                if let varSizetensor = tensor?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizetensor
                }
            }
            if hasIsDead {
                serialize_size += isDead.computeBoolSize(fieldNumber: 2)
            }
            if hasSendStartMicros {
                serialize_size += sendStartMicros.computeInt64Size(fieldNumber: 3)
            }
            if hasTransportOptions {
                if let varSizetransportOptions = transportOptions?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizetransportOptions
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.RecvTensorResponse.Builder {
            return Tensorflow.RecvTensorResponse.classBuilder() as! Tensorflow.RecvTensorResponse.Builder
        }
        public func getBuilder() -> Tensorflow.RecvTensorResponse.Builder {
            return classBuilder() as! Tensorflow.RecvTensorResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.RecvTensorResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.RecvTensorResponse.Builder()
        }
        public func toBuilder() throws -> Tensorflow.RecvTensorResponse.Builder {
            return try Tensorflow.RecvTensorResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.RecvTensorResponse) throws -> Tensorflow.RecvTensorResponse.Builder {
            return try Tensorflow.RecvTensorResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasTensor {
                jsonMap["tensor"] = try tensor.encode()
            }
            if hasIsDead {
                jsonMap["isDead"] = isDead
            }
            if hasSendStartMicros {
                jsonMap["sendStartMicros"] = "\(sendStartMicros)"
            }
            if hasTransportOptions {
                jsonMap["transportOptions"] = try transportOptions.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.RecvTensorResponse {
            return try Tensorflow.RecvTensorResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.RecvTensorResponse {
            return try Tensorflow.RecvTensorResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasTensor {
                output += "\(indent) tensor {\n"
                if let outDescTensor = tensor {
                    output += try outDescTensor.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasIsDead {
                output += "\(indent) isDead: \(isDead) \n"
            }
            if hasSendStartMicros {
                output += "\(indent) sendStartMicros: \(sendStartMicros) \n"
            }
            if hasTransportOptions {
                output += "\(indent) transportOptions {\n"
                if let outDescTransportOptions = transportOptions {
                    output += try outDescTransportOptions.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasTensor {
                    if let hashValuetensor = tensor?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuetensor
                    }
                }
                if hasIsDead {
                    hashCode = (hashCode &* 31) &+ isDead.hashValue
                }
                if hasSendStartMicros {
                    hashCode = (hashCode &* 31) &+ sendStartMicros.hashValue
                }
                if hasTransportOptions {
                    if let hashValuetransportOptions = transportOptions?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuetransportOptions
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.RecvTensorResponse"
        }
        override public func className() -> String {
            return "Tensorflow.RecvTensorResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.RecvTensorResponse = Tensorflow.RecvTensorResponse()
            public func getMessage() -> Tensorflow.RecvTensorResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The tensor as a proto.
            public var tensor:Tensorflow.TensorProto! {
                get {
                    if tensorBuilder_ != nil {
                        builderResult.tensor = tensorBuilder_.getMessage()
                    }
                    return builderResult.tensor
                }
                set (value) {
                    builderResult.hasTensor = true
                    builderResult.tensor = value
                }
            }
            public var hasTensor:Bool {
                get {
                    return builderResult.hasTensor
                }
            }
            fileprivate var tensorBuilder_:Tensorflow.TensorProto.Builder! {
                didSet {
                    builderResult.hasTensor = true
                }
            }
            public func getTensorBuilder() -> Tensorflow.TensorProto.Builder {
                if tensorBuilder_ == nil {
                    tensorBuilder_ = Tensorflow.TensorProto.Builder()
                    builderResult.tensor = tensorBuilder_.getMessage()
                    if tensor != nil {
                        try! tensorBuilder_.mergeFrom(other: tensor)
                    }
                }
                return tensorBuilder_
            }
            @discardableResult
            public func setTensor(_ value:Tensorflow.TensorProto!) -> Tensorflow.RecvTensorResponse.Builder {
                self.tensor = value
                return self
            }
            @discardableResult
            public func mergeTensor(value:Tensorflow.TensorProto) throws -> Tensorflow.RecvTensorResponse.Builder {
                if builderResult.hasTensor {
                    builderResult.tensor = try Tensorflow.TensorProto.builderWithPrototype(prototype:builderResult.tensor).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.tensor = value
                }
                builderResult.hasTensor = true
                return self
            }
            @discardableResult
            public func clearTensor() -> Tensorflow.RecvTensorResponse.Builder {
                tensorBuilder_ = nil
                builderResult.hasTensor = false
                builderResult.tensor = nil
                return self
            }
            /// If true, this tensor was the output of a dead node, and the
            /// content is invalid.
            public var isDead:Bool {
                get {
                    return builderResult.isDead
                }
                set (value) {
                    builderResult.hasIsDead = true
                    builderResult.isDead = value
                }
            }
            public var hasIsDead:Bool {
                get {
                    return builderResult.hasIsDead
                }
            }
            @discardableResult
            public func setIsDead(_ value:Bool) -> Tensorflow.RecvTensorResponse.Builder {
                self.isDead = value
                return self
            }
            @discardableResult
            public func clearIsDead() -> Tensorflow.RecvTensorResponse.Builder{
                builderResult.hasIsDead = false
                builderResult.isDead = false
                return self
            }
            /// The time at which tensor was available and started to be returned.
            public var sendStartMicros:Int64 {
                get {
                    return builderResult.sendStartMicros
                }
                set (value) {
                    builderResult.hasSendStartMicros = true
                    builderResult.sendStartMicros = value
                }
            }
            public var hasSendStartMicros:Bool {
                get {
                    return builderResult.hasSendStartMicros
                }
            }
            @discardableResult
            public func setSendStartMicros(_ value:Int64) -> Tensorflow.RecvTensorResponse.Builder {
                self.sendStartMicros = value
                return self
            }
            @discardableResult
            public func clearSendStartMicros() -> Tensorflow.RecvTensorResponse.Builder{
                builderResult.hasSendStartMicros = false
                builderResult.sendStartMicros = Int64(0)
                return self
            }
            /// Optional additional information about how to receive the tensor,
            /// e.g. in the event that `RecvTensorRequest.dma_ok` was true.
            public var transportOptions:Google.Protobuf.`Any`! {
                get {
                    if transportOptionsBuilder_ != nil {
                        builderResult.transportOptions = transportOptionsBuilder_.getMessage()
                    }
                    return builderResult.transportOptions
                }
                set (value) {
                    builderResult.hasTransportOptions = true
                    builderResult.transportOptions = value
                }
            }
            public var hasTransportOptions:Bool {
                get {
                    return builderResult.hasTransportOptions
                }
            }
            fileprivate var transportOptionsBuilder_:Google.Protobuf.`Any`.Builder! {
                didSet {
                    builderResult.hasTransportOptions = true
                }
            }
            public func getTransportOptionsBuilder() -> Google.Protobuf.`Any`.Builder {
                if transportOptionsBuilder_ == nil {
                    transportOptionsBuilder_ = Google.Protobuf.`Any`.Builder()
                    builderResult.transportOptions = transportOptionsBuilder_.getMessage()
                    if transportOptions != nil {
                        try! transportOptionsBuilder_.mergeFrom(other: transportOptions)
                    }
                }
                return transportOptionsBuilder_
            }
            @discardableResult
            public func setTransportOptions(_ value:Google.Protobuf.`Any`!) -> Tensorflow.RecvTensorResponse.Builder {
                self.transportOptions = value
                return self
            }
            @discardableResult
            public func mergeTransportOptions(value:Google.Protobuf.`Any`) throws -> Tensorflow.RecvTensorResponse.Builder {
                if builderResult.hasTransportOptions {
                    builderResult.transportOptions = try Google.Protobuf.`Any`.builderWithPrototype(prototype:builderResult.transportOptions).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.transportOptions = value
                }
                builderResult.hasTransportOptions = true
                return self
            }
            @discardableResult
            public func clearTransportOptions() -> Tensorflow.RecvTensorResponse.Builder {
                transportOptionsBuilder_ = nil
                builderResult.hasTransportOptions = false
                builderResult.transportOptions = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.RecvTensorResponse.Builder {
                builderResult = Tensorflow.RecvTensorResponse()
                return self
            }
            override public func clone() throws -> Tensorflow.RecvTensorResponse.Builder {
                return try Tensorflow.RecvTensorResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.RecvTensorResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.RecvTensorResponse {
                let returnMe:Tensorflow.RecvTensorResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.RecvTensorResponse) throws -> Tensorflow.RecvTensorResponse.Builder {
                if other == Tensorflow.RecvTensorResponse() {
                    return self
                }
                if (other.hasTensor) {
                    try mergeTensor(value: other.tensor)
                }
                if other.hasIsDead {
                    isDead = other.isDead
                }
                if other.hasSendStartMicros {
                    sendStartMicros = other.sendStartMicros
                }
                if (other.hasTransportOptions) {
                    try mergeTransportOptions(value: other.transportOptions)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.RecvTensorResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RecvTensorResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Tensorflow.TensorProto.Builder = Tensorflow.TensorProto.Builder()
                        if hasTensor {
                            try subBuilder.mergeFrom(other: tensor)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        tensor = subBuilder.buildPartial()

                    case 16:
                        isDead = try codedInputStream.readBool()

                    case 24:
                        sendStartMicros = try codedInputStream.readInt64()

                    case 34:
                        let subBuilder:Google.Protobuf.`Any`.Builder = Google.Protobuf.`Any`.Builder()
                        if hasTransportOptions {
                            try subBuilder.mergeFrom(other: transportOptions)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        transportOptions = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.RecvTensorResponse.Builder {
                let resultDecodedBuilder = Tensorflow.RecvTensorResponse.Builder()
                if let jsonValueTensor = jsonMap["tensor"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.tensor = try Tensorflow.TensorProto.Builder.decodeToBuilder(jsonMap:jsonValueTensor).build()

                }
                if let jsonValueIsDead = jsonMap["isDead"] as? Bool {
                    resultDecodedBuilder.isDead = jsonValueIsDead
                }
                if let jsonValueSendStartMicros = jsonMap["sendStartMicros"] as? String {
                    resultDecodedBuilder.sendStartMicros = Int64(jsonValueSendStartMicros)!
                } else if let jsonValueSendStartMicros = jsonMap["sendStartMicros"] as? Int {
                    resultDecodedBuilder.sendStartMicros = Int64(jsonValueSendStartMicros)
                }
                if let jsonValueTransportOptions = jsonMap["transportOptions"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.transportOptions = try Google.Protobuf.`Any`.Builder.decodeToBuilder(jsonMap:jsonValueTransportOptions).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.RecvTensorResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.RecvTensorResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Out-of-band request to begin or end logging, or
    /// to retrieve logs for particular steps.
    final public class LoggingRequest : GeneratedMessage {

        public static func == (lhs: Tensorflow.LoggingRequest, rhs: Tensorflow.LoggingRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasRpcLogging == rhs.hasRpcLogging) && (!lhs.hasRpcLogging || lhs.rpcLogging == rhs.rpcLogging)
            fieldCheck = fieldCheck && (lhs.hasClear == rhs.hasClear) && (!lhs.hasClear || lhs.clear == rhs.clear)
            fieldCheck = fieldCheck && (lhs.fetchStepId == rhs.fetchStepId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// If true, RPC logging will be activated.
        public fileprivate(set) var rpcLogging:Bool = false
        public fileprivate(set) var hasRpcLogging:Bool = false

        /// If true, discard any saved logging data (for all steps).
        public fileprivate(set) var clear:Bool = false
        public fileprivate(set) var hasClear:Bool = false

        /// When set, requests all saved log data pertaining to the step.
        /// Any log data retrieved is eliminated from the store and cannot be
        /// retrieved again.
        public fileprivate(set) var fetchStepId:Array<Int64> = Array<Int64>()
        private var fetchStepIdMemoizedSerializedSize:Int32 = -1
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasRpcLogging {
                try codedOutputStream.writeBool(fieldNumber: 1, value:rpcLogging)
            }
            if hasClear {
                try codedOutputStream.writeBool(fieldNumber: 2, value:clear)
            }
            if !fetchStepId.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 26)
                try codedOutputStream.writeRawVarint32(value: fetchStepIdMemoizedSerializedSize)
                for oneValuefetchStepId in fetchStepId {
                    try codedOutputStream.writeInt64NoTag(value: oneValuefetchStepId)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasRpcLogging {
                serialize_size += rpcLogging.computeBoolSize(fieldNumber: 1)
            }
            if hasClear {
                serialize_size += clear.computeBoolSize(fieldNumber: 2)
            }
            var dataSizeFetchStepId:Int32 = 0
            for oneValuefetchStepId in fetchStepId {
                dataSizeFetchStepId += oneValuefetchStepId.computeInt64SizeNoTag()
            }
            serialize_size += dataSizeFetchStepId
            if !fetchStepId.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeFetchStepId.computeInt32SizeNoTag()
            }
            fetchStepIdMemoizedSerializedSize = dataSizeFetchStepId
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.LoggingRequest.Builder {
            return Tensorflow.LoggingRequest.classBuilder() as! Tensorflow.LoggingRequest.Builder
        }
        public func getBuilder() -> Tensorflow.LoggingRequest.Builder {
            return classBuilder() as! Tensorflow.LoggingRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.LoggingRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.LoggingRequest.Builder()
        }
        public func toBuilder() throws -> Tensorflow.LoggingRequest.Builder {
            return try Tensorflow.LoggingRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.LoggingRequest) throws -> Tensorflow.LoggingRequest.Builder {
            return try Tensorflow.LoggingRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasRpcLogging {
                jsonMap["rpcLogging"] = rpcLogging
            }
            if hasClear {
                jsonMap["clear"] = clear
            }
            if !fetchStepId.isEmpty {
                var jsonArrayFetchStepId:Array<String> = []
                for oneValueFetchStepId in fetchStepId {
                    jsonArrayFetchStepId.append("\(oneValueFetchStepId)")
                }
                jsonMap["fetchStepId"] = jsonArrayFetchStepId
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.LoggingRequest {
            return try Tensorflow.LoggingRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.LoggingRequest {
            return try Tensorflow.LoggingRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasRpcLogging {
                output += "\(indent) rpcLogging: \(rpcLogging) \n"
            }
            if hasClear {
                output += "\(indent) clear: \(clear) \n"
            }
            var fetchStepIdElementIndex:Int = 0
            for oneValueFetchStepId in fetchStepId  {
                output += "\(indent) fetchStepId[\(fetchStepIdElementIndex)]: \(oneValueFetchStepId)\n"
                fetchStepIdElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasRpcLogging {
                    hashCode = (hashCode &* 31) &+ rpcLogging.hashValue
                }
                if hasClear {
                    hashCode = (hashCode &* 31) &+ clear.hashValue
                }
                for oneValueFetchStepId in fetchStepId {
                    hashCode = (hashCode &* 31) &+ oneValueFetchStepId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.LoggingRequest"
        }
        override public func className() -> String {
            return "Tensorflow.LoggingRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.LoggingRequest = Tensorflow.LoggingRequest()
            public func getMessage() -> Tensorflow.LoggingRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// If true, RPC logging will be activated.
            public var rpcLogging:Bool {
                get {
                    return builderResult.rpcLogging
                }
                set (value) {
                    builderResult.hasRpcLogging = true
                    builderResult.rpcLogging = value
                }
            }
            public var hasRpcLogging:Bool {
                get {
                    return builderResult.hasRpcLogging
                }
            }
            @discardableResult
            public func setRpcLogging(_ value:Bool) -> Tensorflow.LoggingRequest.Builder {
                self.rpcLogging = value
                return self
            }
            @discardableResult
            public func clearRpcLogging() -> Tensorflow.LoggingRequest.Builder{
                builderResult.hasRpcLogging = false
                builderResult.rpcLogging = false
                return self
            }
            /// If true, discard any saved logging data (for all steps).
            public var clear:Bool {
                get {
                    return builderResult.clear
                }
                set (value) {
                    builderResult.hasClear = true
                    builderResult.clear = value
                }
            }
            public var hasClear:Bool {
                get {
                    return builderResult.hasClear
                }
            }
            @discardableResult
            public func setClear(_ value:Bool) -> Tensorflow.LoggingRequest.Builder {
                self.clear = value
                return self
            }
            @discardableResult
            public func clearClear() -> Tensorflow.LoggingRequest.Builder{
                builderResult.hasClear = false
                builderResult.clear = false
                return self
            }
            /// When set, requests all saved log data pertaining to the step.
            /// Any log data retrieved is eliminated from the store and cannot be
            /// retrieved again.
            public var fetchStepId:Array<Int64> {
                get {
                    return builderResult.fetchStepId
                }
                set (array) {
                    builderResult.fetchStepId = array
                }
            }
            @discardableResult
            public func setFetchStepId(_ value:Array<Int64>) -> Tensorflow.LoggingRequest.Builder {
                self.fetchStepId = value
                return self
            }
            @discardableResult
            public func clearFetchStepId() -> Tensorflow.LoggingRequest.Builder {
                builderResult.fetchStepId.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.LoggingRequest.Builder {
                builderResult = Tensorflow.LoggingRequest()
                return self
            }
            override public func clone() throws -> Tensorflow.LoggingRequest.Builder {
                return try Tensorflow.LoggingRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.LoggingRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.LoggingRequest {
                let returnMe:Tensorflow.LoggingRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.LoggingRequest) throws -> Tensorflow.LoggingRequest.Builder {
                if other == Tensorflow.LoggingRequest() {
                    return self
                }
                if other.hasRpcLogging {
                    rpcLogging = other.rpcLogging
                }
                if other.hasClear {
                    clear = other.clear
                }
                if !other.fetchStepId.isEmpty {
                    builderResult.fetchStepId += other.fetchStepId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.LoggingRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.LoggingRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        rpcLogging = try codedInputStream.readBool()

                    case 16:
                        clear = try codedInputStream.readBool()

                    case 26:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.fetchStepId.append(try codedInputStream.readInt64())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.LoggingRequest.Builder {
                let resultDecodedBuilder = Tensorflow.LoggingRequest.Builder()
                if let jsonValueRpcLogging = jsonMap["rpcLogging"] as? Bool {
                    resultDecodedBuilder.rpcLogging = jsonValueRpcLogging
                }
                if let jsonValueClear = jsonMap["clear"] as? Bool {
                    resultDecodedBuilder.clear = jsonValueClear
                }
                if let jsonValueFetchStepId = jsonMap["fetchStepId"] as? Array<String> {
                    var jsonArrayFetchStepId:Array<Int64> = []
                    for oneValueFetchStepId in jsonValueFetchStepId {
                        jsonArrayFetchStepId.append(Int64(oneValueFetchStepId)!)
                    }
                    resultDecodedBuilder.fetchStepId = jsonArrayFetchStepId
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.LoggingRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.LoggingRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class LabeledStepStats : GeneratedMessage {

        public static func == (lhs: Tensorflow.LabeledStepStats, rhs: Tensorflow.LabeledStepStats) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasStepId == rhs.hasStepId) && (!lhs.hasStepId || lhs.stepId == rhs.stepId)
            fieldCheck = fieldCheck && (lhs.hasStepStats == rhs.hasStepStats) && (!lhs.hasStepStats || lhs.stepStats == rhs.stepStats)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var stepId:Int64 = Int64(0)
        public fileprivate(set) var hasStepId:Bool = false

        public fileprivate(set) var stepStats:Tensorflow.StepStats!
        public fileprivate(set) var hasStepStats:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasStepId {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:stepId)
            }
            if hasStepStats {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:stepStats)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasStepId {
                serialize_size += stepId.computeInt64Size(fieldNumber: 1)
            }
            if hasStepStats {
                if let varSizestepStats = stepStats?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizestepStats
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.LabeledStepStats.Builder {
            return Tensorflow.LabeledStepStats.classBuilder() as! Tensorflow.LabeledStepStats.Builder
        }
        public func getBuilder() -> Tensorflow.LabeledStepStats.Builder {
            return classBuilder() as! Tensorflow.LabeledStepStats.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.LabeledStepStats.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.LabeledStepStats.Builder()
        }
        public func toBuilder() throws -> Tensorflow.LabeledStepStats.Builder {
            return try Tensorflow.LabeledStepStats.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.LabeledStepStats) throws -> Tensorflow.LabeledStepStats.Builder {
            return try Tensorflow.LabeledStepStats.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasStepId {
                jsonMap["stepId"] = "\(stepId)"
            }
            if hasStepStats {
                jsonMap["stepStats"] = try stepStats.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.LabeledStepStats {
            return try Tensorflow.LabeledStepStats.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.LabeledStepStats {
            return try Tensorflow.LabeledStepStats.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasStepId {
                output += "\(indent) stepId: \(stepId) \n"
            }
            if hasStepStats {
                output += "\(indent) stepStats {\n"
                if let outDescStepStats = stepStats {
                    output += try outDescStepStats.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasStepId {
                    hashCode = (hashCode &* 31) &+ stepId.hashValue
                }
                if hasStepStats {
                    if let hashValuestepStats = stepStats?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuestepStats
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.LabeledStepStats"
        }
        override public func className() -> String {
            return "Tensorflow.LabeledStepStats"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.LabeledStepStats = Tensorflow.LabeledStepStats()
            public func getMessage() -> Tensorflow.LabeledStepStats {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var stepId:Int64 {
                get {
                    return builderResult.stepId
                }
                set (value) {
                    builderResult.hasStepId = true
                    builderResult.stepId = value
                }
            }
            public var hasStepId:Bool {
                get {
                    return builderResult.hasStepId
                }
            }
            @discardableResult
            public func setStepId(_ value:Int64) -> Tensorflow.LabeledStepStats.Builder {
                self.stepId = value
                return self
            }
            @discardableResult
            public func clearStepId() -> Tensorflow.LabeledStepStats.Builder{
                builderResult.hasStepId = false
                builderResult.stepId = Int64(0)
                return self
            }
            public var stepStats:Tensorflow.StepStats! {
                get {
                    if stepStatsBuilder_ != nil {
                        builderResult.stepStats = stepStatsBuilder_.getMessage()
                    }
                    return builderResult.stepStats
                }
                set (value) {
                    builderResult.hasStepStats = true
                    builderResult.stepStats = value
                }
            }
            public var hasStepStats:Bool {
                get {
                    return builderResult.hasStepStats
                }
            }
            fileprivate var stepStatsBuilder_:Tensorflow.StepStats.Builder! {
                didSet {
                    builderResult.hasStepStats = true
                }
            }
            public func getStepStatsBuilder() -> Tensorflow.StepStats.Builder {
                if stepStatsBuilder_ == nil {
                    stepStatsBuilder_ = Tensorflow.StepStats.Builder()
                    builderResult.stepStats = stepStatsBuilder_.getMessage()
                    if stepStats != nil {
                        try! stepStatsBuilder_.mergeFrom(other: stepStats)
                    }
                }
                return stepStatsBuilder_
            }
            @discardableResult
            public func setStepStats(_ value:Tensorflow.StepStats!) -> Tensorflow.LabeledStepStats.Builder {
                self.stepStats = value
                return self
            }
            @discardableResult
            public func mergeStepStats(value:Tensorflow.StepStats) throws -> Tensorflow.LabeledStepStats.Builder {
                if builderResult.hasStepStats {
                    builderResult.stepStats = try Tensorflow.StepStats.builderWithPrototype(prototype:builderResult.stepStats).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.stepStats = value
                }
                builderResult.hasStepStats = true
                return self
            }
            @discardableResult
            public func clearStepStats() -> Tensorflow.LabeledStepStats.Builder {
                stepStatsBuilder_ = nil
                builderResult.hasStepStats = false
                builderResult.stepStats = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.LabeledStepStats.Builder {
                builderResult = Tensorflow.LabeledStepStats()
                return self
            }
            override public func clone() throws -> Tensorflow.LabeledStepStats.Builder {
                return try Tensorflow.LabeledStepStats.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.LabeledStepStats {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.LabeledStepStats {
                let returnMe:Tensorflow.LabeledStepStats = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.LabeledStepStats) throws -> Tensorflow.LabeledStepStats.Builder {
                if other == Tensorflow.LabeledStepStats() {
                    return self
                }
                if other.hasStepId {
                    stepId = other.stepId
                }
                if (other.hasStepStats) {
                    try mergeStepStats(value: other.stepStats)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.LabeledStepStats.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.LabeledStepStats.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        stepId = try codedInputStream.readInt64()

                    case 18:
                        let subBuilder:Tensorflow.StepStats.Builder = Tensorflow.StepStats.Builder()
                        if hasStepStats {
                            try subBuilder.mergeFrom(other: stepStats)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        stepStats = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.LabeledStepStats.Builder {
                let resultDecodedBuilder = Tensorflow.LabeledStepStats.Builder()
                if let jsonValueStepId = jsonMap["stepId"] as? String {
                    resultDecodedBuilder.stepId = Int64(jsonValueStepId)!
                } else if let jsonValueStepId = jsonMap["stepId"] as? Int {
                    resultDecodedBuilder.stepId = Int64(jsonValueStepId)
                }
                if let jsonValueStepStats = jsonMap["stepStats"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.stepStats = try Tensorflow.StepStats.Builder.decodeToBuilder(jsonMap:jsonValueStepStats).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.LabeledStepStats.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.LabeledStepStats.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class LoggingResponse : GeneratedMessage {

        public static func == (lhs: Tensorflow.LoggingResponse, rhs: Tensorflow.LoggingResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.step == rhs.step)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var step:Array<Tensorflow.LabeledStepStats>  = Array<Tensorflow.LabeledStepStats>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementStep in step {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementStep)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementStep in step {
                serialize_size += oneElementStep.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.LoggingResponse.Builder {
            return Tensorflow.LoggingResponse.classBuilder() as! Tensorflow.LoggingResponse.Builder
        }
        public func getBuilder() -> Tensorflow.LoggingResponse.Builder {
            return classBuilder() as! Tensorflow.LoggingResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.LoggingResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.LoggingResponse.Builder()
        }
        public func toBuilder() throws -> Tensorflow.LoggingResponse.Builder {
            return try Tensorflow.LoggingResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.LoggingResponse) throws -> Tensorflow.LoggingResponse.Builder {
            return try Tensorflow.LoggingResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !step.isEmpty {
                var jsonArrayStep:Array<Dictionary<String,Any>> = []
                for oneValueStep in step {
                    let ecodedMessageStep = try oneValueStep.encode()
                    jsonArrayStep.append(ecodedMessageStep)
                }
                jsonMap["step"] = jsonArrayStep
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.LoggingResponse {
            return try Tensorflow.LoggingResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.LoggingResponse {
            return try Tensorflow.LoggingResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var stepElementIndex:Int = 0
            for oneElementStep in step {
                output += "\(indent) step[\(stepElementIndex)] {\n"
                output += try oneElementStep.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                stepElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementStep in step {
                    hashCode = (hashCode &* 31) &+ oneElementStep.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.LoggingResponse"
        }
        override public func className() -> String {
            return "Tensorflow.LoggingResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.LoggingResponse = Tensorflow.LoggingResponse()
            public func getMessage() -> Tensorflow.LoggingResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var step:Array<Tensorflow.LabeledStepStats> {
                get {
                    return builderResult.step
                }
                set (value) {
                    builderResult.step = value
                }
            }
            @discardableResult
            public func setStep(_ value:Array<Tensorflow.LabeledStepStats>) -> Tensorflow.LoggingResponse.Builder {
                self.step = value
                return self
            }
            @discardableResult
            public func clearStep() -> Tensorflow.LoggingResponse.Builder {
                builderResult.step.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.LoggingResponse.Builder {
                builderResult = Tensorflow.LoggingResponse()
                return self
            }
            override public func clone() throws -> Tensorflow.LoggingResponse.Builder {
                return try Tensorflow.LoggingResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.LoggingResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.LoggingResponse {
                let returnMe:Tensorflow.LoggingResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.LoggingResponse) throws -> Tensorflow.LoggingResponse.Builder {
                if other == Tensorflow.LoggingResponse() {
                    return self
                }
                if !other.step.isEmpty  {
                     builderResult.step += other.step
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.LoggingResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.LoggingResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Tensorflow.LabeledStepStats.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        step.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.LoggingResponse.Builder {
                let resultDecodedBuilder = Tensorflow.LoggingResponse.Builder()
                if let jsonValueStep = jsonMap["step"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayStep:Array<Tensorflow.LabeledStepStats> = []
                    for oneValueStep in jsonValueStep {
                        let messageFromStringStep = try Tensorflow.LabeledStepStats.Builder.decodeToBuilder(jsonMap:oneValueStep).build()

                        jsonArrayStep.append(messageFromStringStep)
                    }
                    resultDecodedBuilder.step = jsonArrayStep
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.LoggingResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.LoggingResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class TraceOpts : GeneratedMessage {

        public static func == (lhs: Tensorflow.TraceOpts, rhs: Tensorflow.TraceOpts) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasDuration == rhs.hasDuration) && (!lhs.hasDuration || lhs.duration == rhs.duration)
            fieldCheck = fieldCheck && (lhs.hasUseStepProfiler == rhs.hasUseStepProfiler) && (!lhs.hasUseStepProfiler || lhs.useStepProfiler == rhs.useStepProfiler)
            fieldCheck = fieldCheck && (lhs.hasUseKernelProfiler == rhs.hasUseKernelProfiler) && (!lhs.hasUseKernelProfiler || lhs.useKernelProfiler == rhs.useKernelProfiler)
            fieldCheck = fieldCheck && (lhs.hasUseExtendedProfiler == rhs.hasUseExtendedProfiler) && (!lhs.hasUseExtendedProfiler || lhs.useExtendedProfiler == rhs.useExtendedProfiler)
            fieldCheck = fieldCheck && (lhs.hasUseGpuProfiler == rhs.hasUseGpuProfiler) && (!lhs.hasUseGpuProfiler || lhs.useGpuProfiler == rhs.useGpuProfiler)
            fieldCheck = fieldCheck && (lhs.hasUseSampleProfiler == rhs.hasUseSampleProfiler) && (!lhs.hasUseSampleProfiler || lhs.useSampleProfiler == rhs.useSampleProfiler)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Length of the trace to be taken, in seconds.
        public fileprivate(set) var duration:Double = Double(0)
        public fileprivate(set) var hasDuration:Bool = false

        /// If true, capture step profile locally in each worker. Currently
        /// unimplemented.
        public fileprivate(set) var useStepProfiler:Bool = false
        public fileprivate(set) var hasUseStepProfiler:Bool = false

        /// If true, capture kernel events from each worker.
        public fileprivate(set) var useKernelProfiler:Bool = false
        public fileprivate(set) var hasUseKernelProfiler:Bool = false

        /// If true, capture extended profiling events from TensorFlow process.
        public fileprivate(set) var useExtendedProfiler:Bool = false
        public fileprivate(set) var hasUseExtendedProfiler:Bool = false

        /// If true, capture GPU profiling events locally on each
        /// machine. Currently unimplemented.
        public fileprivate(set) var useGpuProfiler:Bool = false
        public fileprivate(set) var hasUseGpuProfiler:Bool = false

        /// If true, collect sampled profile events. Currently unimplemented.
        public fileprivate(set) var useSampleProfiler:Bool = false
        public fileprivate(set) var hasUseSampleProfiler:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasDuration {
                try codedOutputStream.writeDouble(fieldNumber: 1, value:duration)
            }
            if hasUseStepProfiler {
                try codedOutputStream.writeBool(fieldNumber: 2, value:useStepProfiler)
            }
            if hasUseKernelProfiler {
                try codedOutputStream.writeBool(fieldNumber: 3, value:useKernelProfiler)
            }
            if hasUseExtendedProfiler {
                try codedOutputStream.writeBool(fieldNumber: 4, value:useExtendedProfiler)
            }
            if hasUseGpuProfiler {
                try codedOutputStream.writeBool(fieldNumber: 5, value:useGpuProfiler)
            }
            if hasUseSampleProfiler {
                try codedOutputStream.writeBool(fieldNumber: 6, value:useSampleProfiler)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasDuration {
                serialize_size += duration.computeDoubleSize(fieldNumber: 1)
            }
            if hasUseStepProfiler {
                serialize_size += useStepProfiler.computeBoolSize(fieldNumber: 2)
            }
            if hasUseKernelProfiler {
                serialize_size += useKernelProfiler.computeBoolSize(fieldNumber: 3)
            }
            if hasUseExtendedProfiler {
                serialize_size += useExtendedProfiler.computeBoolSize(fieldNumber: 4)
            }
            if hasUseGpuProfiler {
                serialize_size += useGpuProfiler.computeBoolSize(fieldNumber: 5)
            }
            if hasUseSampleProfiler {
                serialize_size += useSampleProfiler.computeBoolSize(fieldNumber: 6)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.TraceOpts.Builder {
            return Tensorflow.TraceOpts.classBuilder() as! Tensorflow.TraceOpts.Builder
        }
        public func getBuilder() -> Tensorflow.TraceOpts.Builder {
            return classBuilder() as! Tensorflow.TraceOpts.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.TraceOpts.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.TraceOpts.Builder()
        }
        public func toBuilder() throws -> Tensorflow.TraceOpts.Builder {
            return try Tensorflow.TraceOpts.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.TraceOpts) throws -> Tensorflow.TraceOpts.Builder {
            return try Tensorflow.TraceOpts.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasDuration {
                jsonMap["duration"] = Double(duration)
            }
            if hasUseStepProfiler {
                jsonMap["useStepProfiler"] = useStepProfiler
            }
            if hasUseKernelProfiler {
                jsonMap["useKernelProfiler"] = useKernelProfiler
            }
            if hasUseExtendedProfiler {
                jsonMap["useExtendedProfiler"] = useExtendedProfiler
            }
            if hasUseGpuProfiler {
                jsonMap["useGpuProfiler"] = useGpuProfiler
            }
            if hasUseSampleProfiler {
                jsonMap["useSampleProfiler"] = useSampleProfiler
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.TraceOpts {
            return try Tensorflow.TraceOpts.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.TraceOpts {
            return try Tensorflow.TraceOpts.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasDuration {
                output += "\(indent) duration: \(duration) \n"
            }
            if hasUseStepProfiler {
                output += "\(indent) useStepProfiler: \(useStepProfiler) \n"
            }
            if hasUseKernelProfiler {
                output += "\(indent) useKernelProfiler: \(useKernelProfiler) \n"
            }
            if hasUseExtendedProfiler {
                output += "\(indent) useExtendedProfiler: \(useExtendedProfiler) \n"
            }
            if hasUseGpuProfiler {
                output += "\(indent) useGpuProfiler: \(useGpuProfiler) \n"
            }
            if hasUseSampleProfiler {
                output += "\(indent) useSampleProfiler: \(useSampleProfiler) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasDuration {
                    hashCode = (hashCode &* 31) &+ duration.hashValue
                }
                if hasUseStepProfiler {
                    hashCode = (hashCode &* 31) &+ useStepProfiler.hashValue
                }
                if hasUseKernelProfiler {
                    hashCode = (hashCode &* 31) &+ useKernelProfiler.hashValue
                }
                if hasUseExtendedProfiler {
                    hashCode = (hashCode &* 31) &+ useExtendedProfiler.hashValue
                }
                if hasUseGpuProfiler {
                    hashCode = (hashCode &* 31) &+ useGpuProfiler.hashValue
                }
                if hasUseSampleProfiler {
                    hashCode = (hashCode &* 31) &+ useSampleProfiler.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.TraceOpts"
        }
        override public func className() -> String {
            return "Tensorflow.TraceOpts"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.TraceOpts = Tensorflow.TraceOpts()
            public func getMessage() -> Tensorflow.TraceOpts {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Length of the trace to be taken, in seconds.
            public var duration:Double {
                get {
                    return builderResult.duration
                }
                set (value) {
                    builderResult.hasDuration = true
                    builderResult.duration = value
                }
            }
            public var hasDuration:Bool {
                get {
                    return builderResult.hasDuration
                }
            }
            @discardableResult
            public func setDuration(_ value:Double) -> Tensorflow.TraceOpts.Builder {
                self.duration = value
                return self
            }
            @discardableResult
            public func clearDuration() -> Tensorflow.TraceOpts.Builder{
                builderResult.hasDuration = false
                builderResult.duration = Double(0)
                return self
            }
            /// If true, capture step profile locally in each worker. Currently
            /// unimplemented.
            public var useStepProfiler:Bool {
                get {
                    return builderResult.useStepProfiler
                }
                set (value) {
                    builderResult.hasUseStepProfiler = true
                    builderResult.useStepProfiler = value
                }
            }
            public var hasUseStepProfiler:Bool {
                get {
                    return builderResult.hasUseStepProfiler
                }
            }
            @discardableResult
            public func setUseStepProfiler(_ value:Bool) -> Tensorflow.TraceOpts.Builder {
                self.useStepProfiler = value
                return self
            }
            @discardableResult
            public func clearUseStepProfiler() -> Tensorflow.TraceOpts.Builder{
                builderResult.hasUseStepProfiler = false
                builderResult.useStepProfiler = false
                return self
            }
            /// If true, capture kernel events from each worker.
            public var useKernelProfiler:Bool {
                get {
                    return builderResult.useKernelProfiler
                }
                set (value) {
                    builderResult.hasUseKernelProfiler = true
                    builderResult.useKernelProfiler = value
                }
            }
            public var hasUseKernelProfiler:Bool {
                get {
                    return builderResult.hasUseKernelProfiler
                }
            }
            @discardableResult
            public func setUseKernelProfiler(_ value:Bool) -> Tensorflow.TraceOpts.Builder {
                self.useKernelProfiler = value
                return self
            }
            @discardableResult
            public func clearUseKernelProfiler() -> Tensorflow.TraceOpts.Builder{
                builderResult.hasUseKernelProfiler = false
                builderResult.useKernelProfiler = false
                return self
            }
            /// If true, capture extended profiling events from TensorFlow process.
            public var useExtendedProfiler:Bool {
                get {
                    return builderResult.useExtendedProfiler
                }
                set (value) {
                    builderResult.hasUseExtendedProfiler = true
                    builderResult.useExtendedProfiler = value
                }
            }
            public var hasUseExtendedProfiler:Bool {
                get {
                    return builderResult.hasUseExtendedProfiler
                }
            }
            @discardableResult
            public func setUseExtendedProfiler(_ value:Bool) -> Tensorflow.TraceOpts.Builder {
                self.useExtendedProfiler = value
                return self
            }
            @discardableResult
            public func clearUseExtendedProfiler() -> Tensorflow.TraceOpts.Builder{
                builderResult.hasUseExtendedProfiler = false
                builderResult.useExtendedProfiler = false
                return self
            }
            /// If true, capture GPU profiling events locally on each
            /// machine. Currently unimplemented.
            public var useGpuProfiler:Bool {
                get {
                    return builderResult.useGpuProfiler
                }
                set (value) {
                    builderResult.hasUseGpuProfiler = true
                    builderResult.useGpuProfiler = value
                }
            }
            public var hasUseGpuProfiler:Bool {
                get {
                    return builderResult.hasUseGpuProfiler
                }
            }
            @discardableResult
            public func setUseGpuProfiler(_ value:Bool) -> Tensorflow.TraceOpts.Builder {
                self.useGpuProfiler = value
                return self
            }
            @discardableResult
            public func clearUseGpuProfiler() -> Tensorflow.TraceOpts.Builder{
                builderResult.hasUseGpuProfiler = false
                builderResult.useGpuProfiler = false
                return self
            }
            /// If true, collect sampled profile events. Currently unimplemented.
            public var useSampleProfiler:Bool {
                get {
                    return builderResult.useSampleProfiler
                }
                set (value) {
                    builderResult.hasUseSampleProfiler = true
                    builderResult.useSampleProfiler = value
                }
            }
            public var hasUseSampleProfiler:Bool {
                get {
                    return builderResult.hasUseSampleProfiler
                }
            }
            @discardableResult
            public func setUseSampleProfiler(_ value:Bool) -> Tensorflow.TraceOpts.Builder {
                self.useSampleProfiler = value
                return self
            }
            @discardableResult
            public func clearUseSampleProfiler() -> Tensorflow.TraceOpts.Builder{
                builderResult.hasUseSampleProfiler = false
                builderResult.useSampleProfiler = false
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.TraceOpts.Builder {
                builderResult = Tensorflow.TraceOpts()
                return self
            }
            override public func clone() throws -> Tensorflow.TraceOpts.Builder {
                return try Tensorflow.TraceOpts.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.TraceOpts {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.TraceOpts {
                let returnMe:Tensorflow.TraceOpts = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.TraceOpts) throws -> Tensorflow.TraceOpts.Builder {
                if other == Tensorflow.TraceOpts() {
                    return self
                }
                if other.hasDuration {
                    duration = other.duration
                }
                if other.hasUseStepProfiler {
                    useStepProfiler = other.useStepProfiler
                }
                if other.hasUseKernelProfiler {
                    useKernelProfiler = other.useKernelProfiler
                }
                if other.hasUseExtendedProfiler {
                    useExtendedProfiler = other.useExtendedProfiler
                }
                if other.hasUseGpuProfiler {
                    useGpuProfiler = other.useGpuProfiler
                }
                if other.hasUseSampleProfiler {
                    useSampleProfiler = other.useSampleProfiler
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.TraceOpts.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.TraceOpts.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 9:
                        duration = try codedInputStream.readDouble()

                    case 16:
                        useStepProfiler = try codedInputStream.readBool()

                    case 24:
                        useKernelProfiler = try codedInputStream.readBool()

                    case 32:
                        useExtendedProfiler = try codedInputStream.readBool()

                    case 40:
                        useGpuProfiler = try codedInputStream.readBool()

                    case 48:
                        useSampleProfiler = try codedInputStream.readBool()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.TraceOpts.Builder {
                let resultDecodedBuilder = Tensorflow.TraceOpts.Builder()
                if let jsonValueDuration = jsonMap["duration"] as? Double {
                    resultDecodedBuilder.duration = Double(jsonValueDuration)
                } else if let jsonValueDuration = jsonMap["duration"] as? String {
                    resultDecodedBuilder.duration = Double(jsonValueDuration)!
                }
                if let jsonValueUseStepProfiler = jsonMap["useStepProfiler"] as? Bool {
                    resultDecodedBuilder.useStepProfiler = jsonValueUseStepProfiler
                }
                if let jsonValueUseKernelProfiler = jsonMap["useKernelProfiler"] as? Bool {
                    resultDecodedBuilder.useKernelProfiler = jsonValueUseKernelProfiler
                }
                if let jsonValueUseExtendedProfiler = jsonMap["useExtendedProfiler"] as? Bool {
                    resultDecodedBuilder.useExtendedProfiler = jsonValueUseExtendedProfiler
                }
                if let jsonValueUseGpuProfiler = jsonMap["useGpuProfiler"] as? Bool {
                    resultDecodedBuilder.useGpuProfiler = jsonValueUseGpuProfiler
                }
                if let jsonValueUseSampleProfiler = jsonMap["useSampleProfiler"] as? Bool {
                    resultDecodedBuilder.useSampleProfiler = jsonValueUseSampleProfiler
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.TraceOpts.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.TraceOpts.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Out-of-band request to configure distributed tracing.
    final public class TracingRequest : GeneratedMessage {

        public static func == (lhs: Tensorflow.TracingRequest, rhs: Tensorflow.TracingRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasOptions == rhs.hasOptions) && (!lhs.hasOptions || lhs.options == rhs.options)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var options:Tensorflow.TraceOpts!
        public fileprivate(set) var hasOptions:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasOptions {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:options)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasOptions {
                if let varSizeoptions = options?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeoptions
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.TracingRequest.Builder {
            return Tensorflow.TracingRequest.classBuilder() as! Tensorflow.TracingRequest.Builder
        }
        public func getBuilder() -> Tensorflow.TracingRequest.Builder {
            return classBuilder() as! Tensorflow.TracingRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.TracingRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.TracingRequest.Builder()
        }
        public func toBuilder() throws -> Tensorflow.TracingRequest.Builder {
            return try Tensorflow.TracingRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.TracingRequest) throws -> Tensorflow.TracingRequest.Builder {
            return try Tensorflow.TracingRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasOptions {
                jsonMap["options"] = try options.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.TracingRequest {
            return try Tensorflow.TracingRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.TracingRequest {
            return try Tensorflow.TracingRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasOptions {
                output += "\(indent) options {\n"
                if let outDescOptions = options {
                    output += try outDescOptions.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasOptions {
                    if let hashValueoptions = options?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueoptions
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.TracingRequest"
        }
        override public func className() -> String {
            return "Tensorflow.TracingRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.TracingRequest = Tensorflow.TracingRequest()
            public func getMessage() -> Tensorflow.TracingRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var options:Tensorflow.TraceOpts! {
                get {
                    if optionsBuilder_ != nil {
                        builderResult.options = optionsBuilder_.getMessage()
                    }
                    return builderResult.options
                }
                set (value) {
                    builderResult.hasOptions = true
                    builderResult.options = value
                }
            }
            public var hasOptions:Bool {
                get {
                    return builderResult.hasOptions
                }
            }
            fileprivate var optionsBuilder_:Tensorflow.TraceOpts.Builder! {
                didSet {
                    builderResult.hasOptions = true
                }
            }
            public func getOptionsBuilder() -> Tensorflow.TraceOpts.Builder {
                if optionsBuilder_ == nil {
                    optionsBuilder_ = Tensorflow.TraceOpts.Builder()
                    builderResult.options = optionsBuilder_.getMessage()
                    if options != nil {
                        try! optionsBuilder_.mergeFrom(other: options)
                    }
                }
                return optionsBuilder_
            }
            @discardableResult
            public func setOptions(_ value:Tensorflow.TraceOpts!) -> Tensorflow.TracingRequest.Builder {
                self.options = value
                return self
            }
            @discardableResult
            public func mergeOptions(value:Tensorflow.TraceOpts) throws -> Tensorflow.TracingRequest.Builder {
                if builderResult.hasOptions {
                    builderResult.options = try Tensorflow.TraceOpts.builderWithPrototype(prototype:builderResult.options).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.options = value
                }
                builderResult.hasOptions = true
                return self
            }
            @discardableResult
            public func clearOptions() -> Tensorflow.TracingRequest.Builder {
                optionsBuilder_ = nil
                builderResult.hasOptions = false
                builderResult.options = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.TracingRequest.Builder {
                builderResult = Tensorflow.TracingRequest()
                return self
            }
            override public func clone() throws -> Tensorflow.TracingRequest.Builder {
                return try Tensorflow.TracingRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.TracingRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.TracingRequest {
                let returnMe:Tensorflow.TracingRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.TracingRequest) throws -> Tensorflow.TracingRequest.Builder {
                if other == Tensorflow.TracingRequest() {
                    return self
                }
                if (other.hasOptions) {
                    try mergeOptions(value: other.options)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.TracingRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.TracingRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Tensorflow.TraceOpts.Builder = Tensorflow.TraceOpts.Builder()
                        if hasOptions {
                            try subBuilder.mergeFrom(other: options)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        options = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.TracingRequest.Builder {
                let resultDecodedBuilder = Tensorflow.TracingRequest.Builder()
                if let jsonValueOptions = jsonMap["options"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.options = try Tensorflow.TraceOpts.Builder.decodeToBuilder(jsonMap:jsonValueOptions).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.TracingRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.TracingRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class TracingResponse : GeneratedMessage {

        public static func == (lhs: Tensorflow.TracingResponse, rhs: Tensorflow.TracingResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.TracingResponse.Builder {
            return Tensorflow.TracingResponse.classBuilder() as! Tensorflow.TracingResponse.Builder
        }
        public func getBuilder() -> Tensorflow.TracingResponse.Builder {
            return classBuilder() as! Tensorflow.TracingResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.TracingResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.TracingResponse.Builder()
        }
        public func toBuilder() throws -> Tensorflow.TracingResponse.Builder {
            return try Tensorflow.TracingResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.TracingResponse) throws -> Tensorflow.TracingResponse.Builder {
            return try Tensorflow.TracingResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.TracingResponse {
            return try Tensorflow.TracingResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.TracingResponse {
            return try Tensorflow.TracingResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.TracingResponse"
        }
        override public func className() -> String {
            return "Tensorflow.TracingResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.TracingResponse = Tensorflow.TracingResponse()
            public func getMessage() -> Tensorflow.TracingResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.TracingResponse.Builder {
                builderResult = Tensorflow.TracingResponse()
                return self
            }
            override public func clone() throws -> Tensorflow.TracingResponse.Builder {
                return try Tensorflow.TracingResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.TracingResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.TracingResponse {
                let returnMe:Tensorflow.TracingResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.TracingResponse) throws -> Tensorflow.TracingResponse.Builder {
                if other == Tensorflow.TracingResponse() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.TracingResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.TracingResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.TracingResponse.Builder {
                let resultDecodedBuilder = Tensorflow.TracingResponse.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.TracingResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.TracingResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.GetStatusRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.GetStatusRequest> {
        var mergedArray = Array<Tensorflow.GetStatusRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.GetStatusRequest? {
        return try Tensorflow.GetStatusRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.GetStatusRequest {
        return try Tensorflow.GetStatusRequest.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.WorkerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GetStatusRequest {
        return try Tensorflow.GetStatusRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.GetStatusRequest {
        return try Tensorflow.GetStatusRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GetStatusRequest {
        return try Tensorflow.GetStatusRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.GetStatusRequest {
        return try Tensorflow.GetStatusRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GetStatusRequest {
        return try Tensorflow.GetStatusRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Tensorflow.GetStatusRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Tensorflow.GetStatusResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.GetStatusResponse> {
        var mergedArray = Array<Tensorflow.GetStatusResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.GetStatusResponse? {
        return try Tensorflow.GetStatusResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.GetStatusResponse {
        return try Tensorflow.GetStatusResponse.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.WorkerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GetStatusResponse {
        return try Tensorflow.GetStatusResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.GetStatusResponse {
        return try Tensorflow.GetStatusResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GetStatusResponse {
        return try Tensorflow.GetStatusResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.GetStatusResponse {
        return try Tensorflow.GetStatusResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.GetStatusResponse {
        return try Tensorflow.GetStatusResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "deviceAttributes": return self.deviceAttributes
        default: return nil
        }
    }
}
extension Tensorflow.GetStatusResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "deviceAttributes": return self.deviceAttributes
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "deviceAttributes":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.DeviceAttributes> else {
                    return
                }
                self.deviceAttributes = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.CreateWorkerSessionRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.CreateWorkerSessionRequest> {
        var mergedArray = Array<Tensorflow.CreateWorkerSessionRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.CreateWorkerSessionRequest? {
        return try Tensorflow.CreateWorkerSessionRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.CreateWorkerSessionRequest {
        return try Tensorflow.CreateWorkerSessionRequest.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.WorkerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CreateWorkerSessionRequest {
        return try Tensorflow.CreateWorkerSessionRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.CreateWorkerSessionRequest {
        return try Tensorflow.CreateWorkerSessionRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CreateWorkerSessionRequest {
        return try Tensorflow.CreateWorkerSessionRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CreateWorkerSessionRequest {
        return try Tensorflow.CreateWorkerSessionRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CreateWorkerSessionRequest {
        return try Tensorflow.CreateWorkerSessionRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "sessionHandle": return self.sessionHandle
        case "serverDef": return self.serverDef
        default: return nil
        }
    }
}
extension Tensorflow.CreateWorkerSessionRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "sessionHandle": return self.sessionHandle
            case "serverDef": return self.serverDef
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "sessionHandle":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.sessionHandle = newSubscriptValue
            case "serverDef":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.ServerDef else {
                    return
                }
                self.serverDef = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.CreateWorkerSessionResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.CreateWorkerSessionResponse> {
        var mergedArray = Array<Tensorflow.CreateWorkerSessionResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.CreateWorkerSessionResponse? {
        return try Tensorflow.CreateWorkerSessionResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.CreateWorkerSessionResponse {
        return try Tensorflow.CreateWorkerSessionResponse.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.WorkerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CreateWorkerSessionResponse {
        return try Tensorflow.CreateWorkerSessionResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.CreateWorkerSessionResponse {
        return try Tensorflow.CreateWorkerSessionResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CreateWorkerSessionResponse {
        return try Tensorflow.CreateWorkerSessionResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CreateWorkerSessionResponse {
        return try Tensorflow.CreateWorkerSessionResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CreateWorkerSessionResponse {
        return try Tensorflow.CreateWorkerSessionResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Tensorflow.CreateWorkerSessionResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Tensorflow.RegisterGraphRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.RegisterGraphRequest> {
        var mergedArray = Array<Tensorflow.RegisterGraphRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.RegisterGraphRequest? {
        return try Tensorflow.RegisterGraphRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.RegisterGraphRequest {
        return try Tensorflow.RegisterGraphRequest.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.WorkerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RegisterGraphRequest {
        return try Tensorflow.RegisterGraphRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.RegisterGraphRequest {
        return try Tensorflow.RegisterGraphRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RegisterGraphRequest {
        return try Tensorflow.RegisterGraphRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.RegisterGraphRequest {
        return try Tensorflow.RegisterGraphRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RegisterGraphRequest {
        return try Tensorflow.RegisterGraphRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "sessionHandle": return self.sessionHandle
        case "graphDef": return self.graphDef
        case "hasControlFlow": return self.hasControlFlow
        case "graphOptions": return self.graphOptions
        default: return nil
        }
    }
}
extension Tensorflow.RegisterGraphRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "sessionHandle": return self.sessionHandle
            case "graphDef": return self.graphDef
            case "hasControlFlow": return self.hasControlFlow
            case "graphOptions": return self.graphOptions
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "sessionHandle":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.sessionHandle = newSubscriptValue
            case "graphDef":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.GraphDef else {
                    return
                }
                self.graphDef = newSubscriptValue
            case "hasControlFlow":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.hasControlFlow = newSubscriptValue
            case "graphOptions":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.GraphOptions else {
                    return
                }
                self.graphOptions = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.RegisterGraphResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.RegisterGraphResponse> {
        var mergedArray = Array<Tensorflow.RegisterGraphResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.RegisterGraphResponse? {
        return try Tensorflow.RegisterGraphResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.RegisterGraphResponse {
        return try Tensorflow.RegisterGraphResponse.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.WorkerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RegisterGraphResponse {
        return try Tensorflow.RegisterGraphResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.RegisterGraphResponse {
        return try Tensorflow.RegisterGraphResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RegisterGraphResponse {
        return try Tensorflow.RegisterGraphResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.RegisterGraphResponse {
        return try Tensorflow.RegisterGraphResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RegisterGraphResponse {
        return try Tensorflow.RegisterGraphResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "graphHandle": return self.graphHandle
        default: return nil
        }
    }
}
extension Tensorflow.RegisterGraphResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "graphHandle": return self.graphHandle
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "graphHandle":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.graphHandle = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.DeregisterGraphRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.DeregisterGraphRequest> {
        var mergedArray = Array<Tensorflow.DeregisterGraphRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.DeregisterGraphRequest? {
        return try Tensorflow.DeregisterGraphRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.DeregisterGraphRequest {
        return try Tensorflow.DeregisterGraphRequest.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.WorkerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.DeregisterGraphRequest {
        return try Tensorflow.DeregisterGraphRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.DeregisterGraphRequest {
        return try Tensorflow.DeregisterGraphRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.DeregisterGraphRequest {
        return try Tensorflow.DeregisterGraphRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.DeregisterGraphRequest {
        return try Tensorflow.DeregisterGraphRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.DeregisterGraphRequest {
        return try Tensorflow.DeregisterGraphRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "graphHandle": return self.graphHandle
        default: return nil
        }
    }
}
extension Tensorflow.DeregisterGraphRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "graphHandle": return self.graphHandle
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "graphHandle":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.graphHandle = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.DeregisterGraphResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.DeregisterGraphResponse> {
        var mergedArray = Array<Tensorflow.DeregisterGraphResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.DeregisterGraphResponse? {
        return try Tensorflow.DeregisterGraphResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.DeregisterGraphResponse {
        return try Tensorflow.DeregisterGraphResponse.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.WorkerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.DeregisterGraphResponse {
        return try Tensorflow.DeregisterGraphResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.DeregisterGraphResponse {
        return try Tensorflow.DeregisterGraphResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.DeregisterGraphResponse {
        return try Tensorflow.DeregisterGraphResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.DeregisterGraphResponse {
        return try Tensorflow.DeregisterGraphResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.DeregisterGraphResponse {
        return try Tensorflow.DeregisterGraphResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Tensorflow.DeregisterGraphResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Tensorflow.CleanupAllRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.CleanupAllRequest> {
        var mergedArray = Array<Tensorflow.CleanupAllRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.CleanupAllRequest? {
        return try Tensorflow.CleanupAllRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.CleanupAllRequest {
        return try Tensorflow.CleanupAllRequest.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.WorkerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CleanupAllRequest {
        return try Tensorflow.CleanupAllRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.CleanupAllRequest {
        return try Tensorflow.CleanupAllRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CleanupAllRequest {
        return try Tensorflow.CleanupAllRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CleanupAllRequest {
        return try Tensorflow.CleanupAllRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CleanupAllRequest {
        return try Tensorflow.CleanupAllRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "container": return self.container
        default: return nil
        }
    }
}
extension Tensorflow.CleanupAllRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "container": return self.container
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "container":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.container = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.CleanupAllResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.CleanupAllResponse> {
        var mergedArray = Array<Tensorflow.CleanupAllResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.CleanupAllResponse? {
        return try Tensorflow.CleanupAllResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.CleanupAllResponse {
        return try Tensorflow.CleanupAllResponse.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.WorkerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CleanupAllResponse {
        return try Tensorflow.CleanupAllResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.CleanupAllResponse {
        return try Tensorflow.CleanupAllResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CleanupAllResponse {
        return try Tensorflow.CleanupAllResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CleanupAllResponse {
        return try Tensorflow.CleanupAllResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CleanupAllResponse {
        return try Tensorflow.CleanupAllResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Tensorflow.CleanupAllResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Tensorflow.ExecutorOpts: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.ExecutorOpts> {
        var mergedArray = Array<Tensorflow.ExecutorOpts>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.ExecutorOpts? {
        return try Tensorflow.ExecutorOpts.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.ExecutorOpts {
        return try Tensorflow.ExecutorOpts.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.WorkerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ExecutorOpts {
        return try Tensorflow.ExecutorOpts.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.ExecutorOpts {
        return try Tensorflow.ExecutorOpts.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ExecutorOpts {
        return try Tensorflow.ExecutorOpts.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.ExecutorOpts {
        return try Tensorflow.ExecutorOpts.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.ExecutorOpts {
        return try Tensorflow.ExecutorOpts.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "recordCosts": return self.recordCosts
        case "recordTimeline": return self.recordTimeline
        default: return nil
        }
    }
}
extension Tensorflow.ExecutorOpts.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "recordCosts": return self.recordCosts
            case "recordTimeline": return self.recordTimeline
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "recordCosts":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.recordCosts = newSubscriptValue
            case "recordTimeline":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.recordTimeline = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.RunGraphRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.RunGraphRequest> {
        var mergedArray = Array<Tensorflow.RunGraphRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.RunGraphRequest? {
        return try Tensorflow.RunGraphRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.RunGraphRequest {
        return try Tensorflow.RunGraphRequest.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.WorkerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RunGraphRequest {
        return try Tensorflow.RunGraphRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.RunGraphRequest {
        return try Tensorflow.RunGraphRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RunGraphRequest {
        return try Tensorflow.RunGraphRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.RunGraphRequest {
        return try Tensorflow.RunGraphRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RunGraphRequest {
        return try Tensorflow.RunGraphRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "graphHandle": return self.graphHandle
        case "stepId": return self.stepId
        case "execOpts": return self.execOpts
        case "send": return self.send
        case "recvKey": return self.recvKey
        case "isPartial": return self.isPartial
        case "isLastPartialRun": return self.isLastPartialRun
        default: return nil
        }
    }
}
extension Tensorflow.RunGraphRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "graphHandle": return self.graphHandle
            case "stepId": return self.stepId
            case "execOpts": return self.execOpts
            case "send": return self.send
            case "recvKey": return self.recvKey
            case "isPartial": return self.isPartial
            case "isLastPartialRun": return self.isLastPartialRun
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "graphHandle":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.graphHandle = newSubscriptValue
            case "stepId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.stepId = newSubscriptValue
            case "execOpts":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.ExecutorOpts else {
                    return
                }
                self.execOpts = newSubscriptValue
            case "send":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.NamedTensorProto> else {
                    return
                }
                self.send = newSubscriptValue
            case "recvKey":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.recvKey = newSubscriptValue
            case "isPartial":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.isPartial = newSubscriptValue
            case "isLastPartialRun":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.isLastPartialRun = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.RunGraphResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.RunGraphResponse> {
        var mergedArray = Array<Tensorflow.RunGraphResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.RunGraphResponse? {
        return try Tensorflow.RunGraphResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.RunGraphResponse {
        return try Tensorflow.RunGraphResponse.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.WorkerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RunGraphResponse {
        return try Tensorflow.RunGraphResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.RunGraphResponse {
        return try Tensorflow.RunGraphResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RunGraphResponse {
        return try Tensorflow.RunGraphResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.RunGraphResponse {
        return try Tensorflow.RunGraphResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RunGraphResponse {
        return try Tensorflow.RunGraphResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "recv": return self.recv
        case "stepStats": return self.stepStats
        case "costGraph": return self.costGraph
        default: return nil
        }
    }
}
extension Tensorflow.RunGraphResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "recv": return self.recv
            case "stepStats": return self.stepStats
            case "costGraph": return self.costGraph
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "recv":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.NamedTensorProto> else {
                    return
                }
                self.recv = newSubscriptValue
            case "stepStats":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.StepStats else {
                    return
                }
                self.stepStats = newSubscriptValue
            case "costGraph":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.CostGraphDef else {
                    return
                }
                self.costGraph = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.CleanupGraphRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.CleanupGraphRequest> {
        var mergedArray = Array<Tensorflow.CleanupGraphRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.CleanupGraphRequest? {
        return try Tensorflow.CleanupGraphRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.CleanupGraphRequest {
        return try Tensorflow.CleanupGraphRequest.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.WorkerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CleanupGraphRequest {
        return try Tensorflow.CleanupGraphRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.CleanupGraphRequest {
        return try Tensorflow.CleanupGraphRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CleanupGraphRequest {
        return try Tensorflow.CleanupGraphRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CleanupGraphRequest {
        return try Tensorflow.CleanupGraphRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CleanupGraphRequest {
        return try Tensorflow.CleanupGraphRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "stepId": return self.stepId
        default: return nil
        }
    }
}
extension Tensorflow.CleanupGraphRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "stepId": return self.stepId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "stepId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.stepId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.CleanupGraphResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.CleanupGraphResponse> {
        var mergedArray = Array<Tensorflow.CleanupGraphResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.CleanupGraphResponse? {
        return try Tensorflow.CleanupGraphResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.CleanupGraphResponse {
        return try Tensorflow.CleanupGraphResponse.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.WorkerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CleanupGraphResponse {
        return try Tensorflow.CleanupGraphResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.CleanupGraphResponse {
        return try Tensorflow.CleanupGraphResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CleanupGraphResponse {
        return try Tensorflow.CleanupGraphResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.CleanupGraphResponse {
        return try Tensorflow.CleanupGraphResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.CleanupGraphResponse {
        return try Tensorflow.CleanupGraphResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Tensorflow.CleanupGraphResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Tensorflow.RecvTensorRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.RecvTensorRequest> {
        var mergedArray = Array<Tensorflow.RecvTensorRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.RecvTensorRequest? {
        return try Tensorflow.RecvTensorRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.RecvTensorRequest {
        return try Tensorflow.RecvTensorRequest.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.WorkerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RecvTensorRequest {
        return try Tensorflow.RecvTensorRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.RecvTensorRequest {
        return try Tensorflow.RecvTensorRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RecvTensorRequest {
        return try Tensorflow.RecvTensorRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.RecvTensorRequest {
        return try Tensorflow.RecvTensorRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RecvTensorRequest {
        return try Tensorflow.RecvTensorRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "stepId": return self.stepId
        case "rendezvousKey": return self.rendezvousKey
        case "dmaOk": return self.dmaOk
        case "clientLocality": return self.clientLocality
        case "serverLocality": return self.serverLocality
        case "transportOptions": return self.transportOptions
        default: return nil
        }
    }
}
extension Tensorflow.RecvTensorRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "stepId": return self.stepId
            case "rendezvousKey": return self.rendezvousKey
            case "dmaOk": return self.dmaOk
            case "clientLocality": return self.clientLocality
            case "serverLocality": return self.serverLocality
            case "transportOptions": return self.transportOptions
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "stepId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.stepId = newSubscriptValue
            case "rendezvousKey":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.rendezvousKey = newSubscriptValue
            case "dmaOk":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.dmaOk = newSubscriptValue
            case "clientLocality":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.DeviceLocality else {
                    return
                }
                self.clientLocality = newSubscriptValue
            case "serverLocality":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.DeviceLocality else {
                    return
                }
                self.serverLocality = newSubscriptValue
            case "transportOptions":
                guard let newSubscriptValue = newSubscriptValue as? Google.Protobuf.`Any` else {
                    return
                }
                self.transportOptions = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.RecvTensorResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.RecvTensorResponse> {
        var mergedArray = Array<Tensorflow.RecvTensorResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.RecvTensorResponse? {
        return try Tensorflow.RecvTensorResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.RecvTensorResponse {
        return try Tensorflow.RecvTensorResponse.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.WorkerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RecvTensorResponse {
        return try Tensorflow.RecvTensorResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.RecvTensorResponse {
        return try Tensorflow.RecvTensorResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RecvTensorResponse {
        return try Tensorflow.RecvTensorResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.RecvTensorResponse {
        return try Tensorflow.RecvTensorResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.RecvTensorResponse {
        return try Tensorflow.RecvTensorResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "tensor": return self.tensor
        case "isDead": return self.isDead
        case "sendStartMicros": return self.sendStartMicros
        case "transportOptions": return self.transportOptions
        default: return nil
        }
    }
}
extension Tensorflow.RecvTensorResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "tensor": return self.tensor
            case "isDead": return self.isDead
            case "sendStartMicros": return self.sendStartMicros
            case "transportOptions": return self.transportOptions
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "tensor":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.TensorProto else {
                    return
                }
                self.tensor = newSubscriptValue
            case "isDead":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.isDead = newSubscriptValue
            case "sendStartMicros":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.sendStartMicros = newSubscriptValue
            case "transportOptions":
                guard let newSubscriptValue = newSubscriptValue as? Google.Protobuf.`Any` else {
                    return
                }
                self.transportOptions = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.LoggingRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.LoggingRequest> {
        var mergedArray = Array<Tensorflow.LoggingRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.LoggingRequest? {
        return try Tensorflow.LoggingRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.LoggingRequest {
        return try Tensorflow.LoggingRequest.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.WorkerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.LoggingRequest {
        return try Tensorflow.LoggingRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.LoggingRequest {
        return try Tensorflow.LoggingRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.LoggingRequest {
        return try Tensorflow.LoggingRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.LoggingRequest {
        return try Tensorflow.LoggingRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.LoggingRequest {
        return try Tensorflow.LoggingRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "rpcLogging": return self.rpcLogging
        case "clear": return self.clear
        case "fetchStepId": return self.fetchStepId
        default: return nil
        }
    }
}
extension Tensorflow.LoggingRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "rpcLogging": return self.rpcLogging
            case "clear": return self.clear
            case "fetchStepId": return self.fetchStepId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "rpcLogging":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.rpcLogging = newSubscriptValue
            case "clear":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.clear = newSubscriptValue
            case "fetchStepId":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.fetchStepId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.LabeledStepStats: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.LabeledStepStats> {
        var mergedArray = Array<Tensorflow.LabeledStepStats>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.LabeledStepStats? {
        return try Tensorflow.LabeledStepStats.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.LabeledStepStats {
        return try Tensorflow.LabeledStepStats.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.WorkerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.LabeledStepStats {
        return try Tensorflow.LabeledStepStats.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.LabeledStepStats {
        return try Tensorflow.LabeledStepStats.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.LabeledStepStats {
        return try Tensorflow.LabeledStepStats.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.LabeledStepStats {
        return try Tensorflow.LabeledStepStats.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.LabeledStepStats {
        return try Tensorflow.LabeledStepStats.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "stepId": return self.stepId
        case "stepStats": return self.stepStats
        default: return nil
        }
    }
}
extension Tensorflow.LabeledStepStats.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "stepId": return self.stepId
            case "stepStats": return self.stepStats
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "stepId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.stepId = newSubscriptValue
            case "stepStats":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.StepStats else {
                    return
                }
                self.stepStats = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.LoggingResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.LoggingResponse> {
        var mergedArray = Array<Tensorflow.LoggingResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.LoggingResponse? {
        return try Tensorflow.LoggingResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.LoggingResponse {
        return try Tensorflow.LoggingResponse.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.WorkerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.LoggingResponse {
        return try Tensorflow.LoggingResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.LoggingResponse {
        return try Tensorflow.LoggingResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.LoggingResponse {
        return try Tensorflow.LoggingResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.LoggingResponse {
        return try Tensorflow.LoggingResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.LoggingResponse {
        return try Tensorflow.LoggingResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "step": return self.step
        default: return nil
        }
    }
}
extension Tensorflow.LoggingResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "step": return self.step
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "step":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.LabeledStepStats> else {
                    return
                }
                self.step = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.TraceOpts: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.TraceOpts> {
        var mergedArray = Array<Tensorflow.TraceOpts>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.TraceOpts? {
        return try Tensorflow.TraceOpts.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.TraceOpts {
        return try Tensorflow.TraceOpts.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.WorkerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.TraceOpts {
        return try Tensorflow.TraceOpts.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.TraceOpts {
        return try Tensorflow.TraceOpts.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.TraceOpts {
        return try Tensorflow.TraceOpts.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.TraceOpts {
        return try Tensorflow.TraceOpts.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.TraceOpts {
        return try Tensorflow.TraceOpts.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "duration": return self.duration
        case "useStepProfiler": return self.useStepProfiler
        case "useKernelProfiler": return self.useKernelProfiler
        case "useExtendedProfiler": return self.useExtendedProfiler
        case "useGpuProfiler": return self.useGpuProfiler
        case "useSampleProfiler": return self.useSampleProfiler
        default: return nil
        }
    }
}
extension Tensorflow.TraceOpts.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "duration": return self.duration
            case "useStepProfiler": return self.useStepProfiler
            case "useKernelProfiler": return self.useKernelProfiler
            case "useExtendedProfiler": return self.useExtendedProfiler
            case "useGpuProfiler": return self.useGpuProfiler
            case "useSampleProfiler": return self.useSampleProfiler
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "duration":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.duration = newSubscriptValue
            case "useStepProfiler":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.useStepProfiler = newSubscriptValue
            case "useKernelProfiler":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.useKernelProfiler = newSubscriptValue
            case "useExtendedProfiler":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.useExtendedProfiler = newSubscriptValue
            case "useGpuProfiler":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.useGpuProfiler = newSubscriptValue
            case "useSampleProfiler":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.useSampleProfiler = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.TracingRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.TracingRequest> {
        var mergedArray = Array<Tensorflow.TracingRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.TracingRequest? {
        return try Tensorflow.TracingRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.TracingRequest {
        return try Tensorflow.TracingRequest.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.WorkerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.TracingRequest {
        return try Tensorflow.TracingRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.TracingRequest {
        return try Tensorflow.TracingRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.TracingRequest {
        return try Tensorflow.TracingRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.TracingRequest {
        return try Tensorflow.TracingRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.TracingRequest {
        return try Tensorflow.TracingRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "options": return self.options
        default: return nil
        }
    }
}
extension Tensorflow.TracingRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "options": return self.options
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "options":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.TraceOpts else {
                    return
                }
                self.options = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.TracingResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.TracingResponse> {
        var mergedArray = Array<Tensorflow.TracingResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.TracingResponse? {
        return try Tensorflow.TracingResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.TracingResponse {
        return try Tensorflow.TracingResponse.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.WorkerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.TracingResponse {
        return try Tensorflow.TracingResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.TracingResponse {
        return try Tensorflow.TracingResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.TracingResponse {
        return try Tensorflow.TracingResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.TracingResponse {
        return try Tensorflow.TracingResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.TracingResponse {
        return try Tensorflow.TracingResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Tensorflow.TracingResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}

// @@protoc_insertion_point(global_scope)

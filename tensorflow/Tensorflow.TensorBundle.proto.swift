/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "tensor_bundle.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { }

public extension Tensorflow {
    public struct TensorBundleRoot {
        public static let `default` = TensorBundleRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Tensorflow.TensorShapeRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.TensorSliceRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.TypesRoot.default.registerAllExtensions(registry: extensionRegistry)
            Tensorflow.VersionsRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    /// Special header that is associated with a bundle.
    /// TODO(zongheng,zhifengc): maybe in the future, we can add information about
    /// which binary produced this checkpoint, timestamp, etc. Sometime, these can be
    /// valuable debugging information. And if needed, these can be used as defensive
    /// information ensuring reader (binary version) of the checkpoint and the writer
    /// (binary version) must match within certain range, etc.
    final public class BundleHeaderProto : GeneratedMessage {

        public static func == (lhs: Tensorflow.BundleHeaderProto, rhs: Tensorflow.BundleHeaderProto) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasNumShards == rhs.hasNumShards) && (!lhs.hasNumShards || lhs.numShards == rhs.numShards)
            fieldCheck = fieldCheck && (lhs.hasEndianness == rhs.hasEndianness) && (!lhs.hasEndianness || lhs.endianness == rhs.endianness)
            fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



            //Enum type declaration start 

            /// An enum indicating the endianness of the platform that produced this
            /// bundle.  A bundle can only be read by a platform with matching endianness.
            /// Defaults to LITTLE, as most modern platforms are little-endian.
            /// Affects the binary tensor data bytes only, not the metadata in protobufs.
            public enum Endianness:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
                case little = 0
                case big = 1
                public func toString() -> String {
                    switch self {
                    case .little: return "LITTLE"
                    case .big: return "BIG"
                    }
                }
                public static func fromString(str:String) throws -> Tensorflow.BundleHeaderProto.Endianness {
                    switch str {
                    case "LITTLE":    return .little
                    case "BIG":    return .big
                    default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
                    }
                }
                public var debugDescription:String { return getDescription() }
                public var description:String { return getDescription() }
                private func getDescription() -> String { 
                    switch self {
                    case .little: return ".little"
                    case .big: return ".big"
                    }
                }
                public var hashValue:Int {
                    return self.rawValue.hashValue
                }
                public static func ==(lhs:Endianness, rhs:Endianness) -> Bool {
                    return lhs.hashValue == rhs.hashValue
                }
            }

            //Enum type declaration end 

        /// Number of data files in the bundle.
        public fileprivate(set) var numShards:Int32 = Int32(0)
        public fileprivate(set) var hasNumShards:Bool = false

        public fileprivate(set) var endianness:Tensorflow.BundleHeaderProto.Endianness = Tensorflow.BundleHeaderProto.Endianness.little
        public fileprivate(set) var hasEndianness:Bool = false
        public fileprivate(set) var version:Tensorflow.VersionDef!
        public fileprivate(set) var hasVersion:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasNumShards {
                try codedOutputStream.writeInt32(fieldNumber: 1, value:numShards)
            }
            if hasEndianness {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:endianness.rawValue)
            }
            if hasVersion {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:version)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasNumShards {
                serialize_size += numShards.computeInt32Size(fieldNumber: 1)
            }
            if (hasEndianness) {
                serialize_size += endianness.rawValue.computeEnumSize(fieldNumber: 2)
            }
            if hasVersion {
                if let varSizeversion = version?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizeversion
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.BundleHeaderProto.Builder {
            return Tensorflow.BundleHeaderProto.classBuilder() as! Tensorflow.BundleHeaderProto.Builder
        }
        public func getBuilder() -> Tensorflow.BundleHeaderProto.Builder {
            return classBuilder() as! Tensorflow.BundleHeaderProto.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BundleHeaderProto.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BundleHeaderProto.Builder()
        }
        public func toBuilder() throws -> Tensorflow.BundleHeaderProto.Builder {
            return try Tensorflow.BundleHeaderProto.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.BundleHeaderProto) throws -> Tensorflow.BundleHeaderProto.Builder {
            return try Tensorflow.BundleHeaderProto.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasNumShards {
                jsonMap["numShards"] = Int(numShards)
            }
            if hasEndianness {
                jsonMap["endianness"] = endianness.toString()
            }
            if hasVersion {
                jsonMap["version"] = try version.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BundleHeaderProto {
            return try Tensorflow.BundleHeaderProto.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.BundleHeaderProto {
            return try Tensorflow.BundleHeaderProto.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasNumShards {
                output += "\(indent) numShards: \(numShards) \n"
            }
            if (hasEndianness) {
                output += "\(indent) endianness: \(endianness.description)\n"
            }
            if hasVersion {
                output += "\(indent) version {\n"
                if let outDescVersion = version {
                    output += try outDescVersion.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasNumShards {
                    hashCode = (hashCode &* 31) &+ numShards.hashValue
                }
                if hasEndianness {
                     hashCode = (hashCode &* 31) &+ endianness.hashValue
                }
                if hasVersion {
                    if let hashValueversion = version?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueversion
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.BundleHeaderProto"
        }
        override public func className() -> String {
            return "Tensorflow.BundleHeaderProto"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.BundleHeaderProto = Tensorflow.BundleHeaderProto()
            public func getMessage() -> Tensorflow.BundleHeaderProto {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Number of data files in the bundle.
            public var numShards:Int32 {
                get {
                    return builderResult.numShards
                }
                set (value) {
                    builderResult.hasNumShards = true
                    builderResult.numShards = value
                }
            }
            public var hasNumShards:Bool {
                get {
                    return builderResult.hasNumShards
                }
            }
            @discardableResult
            public func setNumShards(_ value:Int32) -> Tensorflow.BundleHeaderProto.Builder {
                self.numShards = value
                return self
            }
            @discardableResult
            public func clearNumShards() -> Tensorflow.BundleHeaderProto.Builder{
                builderResult.hasNumShards = false
                builderResult.numShards = Int32(0)
                return self
            }
                public var endianness:Tensorflow.BundleHeaderProto.Endianness {
                    get {
                        return builderResult.endianness
                    }
                    set (value) {
                        builderResult.hasEndianness = true
                        builderResult.endianness = value
                    }
                }
                public var hasEndianness:Bool{
                    get {
                        return builderResult.hasEndianness
                    }
                }
            @discardableResult
                public func setEndianness(_ value:Tensorflow.BundleHeaderProto.Endianness) -> Tensorflow.BundleHeaderProto.Builder {
                  self.endianness = value
                  return self
                }
            @discardableResult
                public func clearEndianness() -> Tensorflow.BundleHeaderProto.Builder {
                   builderResult.hasEndianness = false
                   builderResult.endianness = .little
                   return self
                }
            /// Versioning of the tensor bundle format.
            public var version:Tensorflow.VersionDef! {
                get {
                    if versionBuilder_ != nil {
                        builderResult.version = versionBuilder_.getMessage()
                    }
                    return builderResult.version
                }
                set (value) {
                    builderResult.hasVersion = true
                    builderResult.version = value
                }
            }
            public var hasVersion:Bool {
                get {
                    return builderResult.hasVersion
                }
            }
            fileprivate var versionBuilder_:Tensorflow.VersionDef.Builder! {
                didSet {
                    builderResult.hasVersion = true
                }
            }
            public func getVersionBuilder() -> Tensorflow.VersionDef.Builder {
                if versionBuilder_ == nil {
                    versionBuilder_ = Tensorflow.VersionDef.Builder()
                    builderResult.version = versionBuilder_.getMessage()
                    if version != nil {
                        try! versionBuilder_.mergeFrom(other: version)
                    }
                }
                return versionBuilder_
            }
            @discardableResult
            public func setVersion(_ value:Tensorflow.VersionDef!) -> Tensorflow.BundleHeaderProto.Builder {
                self.version = value
                return self
            }
            @discardableResult
            public func mergeVersion(value:Tensorflow.VersionDef) throws -> Tensorflow.BundleHeaderProto.Builder {
                if builderResult.hasVersion {
                    builderResult.version = try Tensorflow.VersionDef.builderWithPrototype(prototype:builderResult.version).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.version = value
                }
                builderResult.hasVersion = true
                return self
            }
            @discardableResult
            public func clearVersion() -> Tensorflow.BundleHeaderProto.Builder {
                versionBuilder_ = nil
                builderResult.hasVersion = false
                builderResult.version = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.BundleHeaderProto.Builder {
                builderResult = Tensorflow.BundleHeaderProto()
                return self
            }
            override public func clone() throws -> Tensorflow.BundleHeaderProto.Builder {
                return try Tensorflow.BundleHeaderProto.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.BundleHeaderProto {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.BundleHeaderProto {
                let returnMe:Tensorflow.BundleHeaderProto = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.BundleHeaderProto) throws -> Tensorflow.BundleHeaderProto.Builder {
                if other == Tensorflow.BundleHeaderProto() {
                    return self
                }
                if other.hasNumShards {
                    numShards = other.numShards
                }
                if other.hasEndianness {
                    endianness = other.endianness
                }
                if (other.hasVersion) {
                    try mergeVersion(value: other.version)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BundleHeaderProto.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BundleHeaderProto.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        numShards = try codedInputStream.readInt32()

                    case 16:
                        let valueIntendianness = try codedInputStream.readEnum()
                        if let enumsendianness = Tensorflow.BundleHeaderProto.Endianness(rawValue:valueIntendianness){
                            endianness = enumsendianness
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntendianness))
                        }

                    case 26:
                        let subBuilder:Tensorflow.VersionDef.Builder = Tensorflow.VersionDef.Builder()
                        if hasVersion {
                            try subBuilder.mergeFrom(other: version)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        version = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BundleHeaderProto.Builder {
                let resultDecodedBuilder = Tensorflow.BundleHeaderProto.Builder()
                if let jsonValueNumShards = jsonMap["numShards"] as? Int {
                    resultDecodedBuilder.numShards = Int32(jsonValueNumShards)
                } else if let jsonValueNumShards = jsonMap["numShards"] as? String {
                    resultDecodedBuilder.numShards = Int32(jsonValueNumShards)!
                }
                if let jsonValueEndianness = jsonMap["endianness"] as? String {
                    resultDecodedBuilder.endianness = try Tensorflow.BundleHeaderProto.Endianness.fromString(str: jsonValueEndianness)
                }
                if let jsonValueVersion = jsonMap["version"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.version = try Tensorflow.VersionDef.Builder.decodeToBuilder(jsonMap:jsonValueVersion).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.BundleHeaderProto.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.BundleHeaderProto.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Describes the metadata related to a checkpointed tensor.
    final public class BundleEntryProto : GeneratedMessage {

        public static func == (lhs: Tensorflow.BundleEntryProto, rhs: Tensorflow.BundleEntryProto) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasDtype == rhs.hasDtype) && (!lhs.hasDtype || lhs.dtype == rhs.dtype)
            fieldCheck = fieldCheck && (lhs.hasShape == rhs.hasShape) && (!lhs.hasShape || lhs.shape == rhs.shape)
            fieldCheck = fieldCheck && (lhs.hasShardId == rhs.hasShardId) && (!lhs.hasShardId || lhs.shardId == rhs.shardId)
            fieldCheck = fieldCheck && (lhs.hasOffset == rhs.hasOffset) && (!lhs.hasOffset || lhs.offset == rhs.offset)
            fieldCheck = fieldCheck && (lhs.hasSize == rhs.hasSize) && (!lhs.hasSize || lhs.size == rhs.size)
            fieldCheck = fieldCheck && (lhs.hasCrc32C == rhs.hasCrc32C) && (!lhs.hasCrc32C || lhs.crc32C == rhs.crc32C)
            fieldCheck = fieldCheck && (lhs.slices == rhs.slices)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var dtype:Tensorflow.DataType = Tensorflow.DataType.dtInvalid
        public fileprivate(set) var hasDtype:Bool = false
        public fileprivate(set) var shape:Tensorflow.TensorShapeProto!
        public fileprivate(set) var hasShape:Bool = false
        /// The binary content of the tensor lies in:
        ///   File "shard_id": bytes [offset, offset + size).
        public fileprivate(set) var shardId:Int32 = Int32(0)
        public fileprivate(set) var hasShardId:Bool = false

        public fileprivate(set) var offset:Int64 = Int64(0)
        public fileprivate(set) var hasOffset:Bool = false

        public fileprivate(set) var size:Int64 = Int64(0)
        public fileprivate(set) var hasSize:Bool = false

        /// The CRC32C checksum of the tensor bytes.
        public fileprivate(set) var crc32C:UInt32 = UInt32(0)
        public fileprivate(set) var hasCrc32C:Bool = false

        public fileprivate(set) var slices:Array<Tensorflow.TensorSliceProto>  = Array<Tensorflow.TensorSliceProto>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasDtype {
                try codedOutputStream.writeEnum(fieldNumber: 1, value:dtype.rawValue)
            }
            if hasShape {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:shape)
            }
            if hasShardId {
                try codedOutputStream.writeInt32(fieldNumber: 3, value:shardId)
            }
            if hasOffset {
                try codedOutputStream.writeInt64(fieldNumber: 4, value:offset)
            }
            if hasSize {
                try codedOutputStream.writeInt64(fieldNumber: 5, value:size)
            }
            if hasCrc32C {
                try codedOutputStream.writeFixed32(fieldNumber: 6, value:crc32C)
            }
            for oneElementSlices in slices {
                  try codedOutputStream.writeMessage(fieldNumber: 7, value:oneElementSlices)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if (hasDtype) {
                serialize_size += dtype.rawValue.computeEnumSize(fieldNumber: 1)
            }
            if hasShape {
                if let varSizeshape = shape?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeshape
                }
            }
            if hasShardId {
                serialize_size += shardId.computeInt32Size(fieldNumber: 3)
            }
            if hasOffset {
                serialize_size += offset.computeInt64Size(fieldNumber: 4)
            }
            if hasSize {
                serialize_size += size.computeInt64Size(fieldNumber: 5)
            }
            if hasCrc32C {
                serialize_size += crc32C.computeFixed32Size(fieldNumber: 6)
            }
            for oneElementSlices in slices {
                serialize_size += oneElementSlices.computeMessageSize(fieldNumber: 7)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.BundleEntryProto.Builder {
            return Tensorflow.BundleEntryProto.classBuilder() as! Tensorflow.BundleEntryProto.Builder
        }
        public func getBuilder() -> Tensorflow.BundleEntryProto.Builder {
            return classBuilder() as! Tensorflow.BundleEntryProto.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BundleEntryProto.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.BundleEntryProto.Builder()
        }
        public func toBuilder() throws -> Tensorflow.BundleEntryProto.Builder {
            return try Tensorflow.BundleEntryProto.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.BundleEntryProto) throws -> Tensorflow.BundleEntryProto.Builder {
            return try Tensorflow.BundleEntryProto.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasDtype {
                jsonMap["dtype"] = dtype.toString()
            }
            if hasShape {
                jsonMap["shape"] = try shape.encode()
            }
            if hasShardId {
                jsonMap["shardId"] = Int(shardId)
            }
            if hasOffset {
                jsonMap["offset"] = "\(offset)"
            }
            if hasSize {
                jsonMap["size"] = "\(size)"
            }
            if hasCrc32C {
                jsonMap["crc32c"] = UInt(crc32C)
            }
            if !slices.isEmpty {
                var jsonArraySlices:Array<Dictionary<String,Any>> = []
                for oneValueSlices in slices {
                    let ecodedMessageSlices = try oneValueSlices.encode()
                    jsonArraySlices.append(ecodedMessageSlices)
                }
                jsonMap["slices"] = jsonArraySlices
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BundleEntryProto {
            return try Tensorflow.BundleEntryProto.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.BundleEntryProto {
            return try Tensorflow.BundleEntryProto.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if (hasDtype) {
                output += "\(indent) dtype: \(dtype.description)\n"
            }
            if hasShape {
                output += "\(indent) shape {\n"
                if let outDescShape = shape {
                    output += try outDescShape.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasShardId {
                output += "\(indent) shardId: \(shardId) \n"
            }
            if hasOffset {
                output += "\(indent) offset: \(offset) \n"
            }
            if hasSize {
                output += "\(indent) size: \(size) \n"
            }
            if hasCrc32C {
                output += "\(indent) crc32C: \(crc32C) \n"
            }
            var slicesElementIndex:Int = 0
            for oneElementSlices in slices {
                output += "\(indent) slices[\(slicesElementIndex)] {\n"
                output += try oneElementSlices.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                slicesElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasDtype {
                     hashCode = (hashCode &* 31) &+ dtype.hashValue
                }
                if hasShape {
                    if let hashValueshape = shape?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueshape
                    }
                }
                if hasShardId {
                    hashCode = (hashCode &* 31) &+ shardId.hashValue
                }
                if hasOffset {
                    hashCode = (hashCode &* 31) &+ offset.hashValue
                }
                if hasSize {
                    hashCode = (hashCode &* 31) &+ size.hashValue
                }
                if hasCrc32C {
                    hashCode = (hashCode &* 31) &+ crc32C.hashValue
                }
                for oneElementSlices in slices {
                    hashCode = (hashCode &* 31) &+ oneElementSlices.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.BundleEntryProto"
        }
        override public func className() -> String {
            return "Tensorflow.BundleEntryProto"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.BundleEntryProto = Tensorflow.BundleEntryProto()
            public func getMessage() -> Tensorflow.BundleEntryProto {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The tensor dtype and shape.
                public var dtype:Tensorflow.DataType {
                    get {
                        return builderResult.dtype
                    }
                    set (value) {
                        builderResult.hasDtype = true
                        builderResult.dtype = value
                    }
                }
                public var hasDtype:Bool{
                    get {
                        return builderResult.hasDtype
                    }
                }
            @discardableResult
                public func setDtype(_ value:Tensorflow.DataType) -> Tensorflow.BundleEntryProto.Builder {
                  self.dtype = value
                  return self
                }
            @discardableResult
                public func clearDtype() -> Tensorflow.BundleEntryProto.Builder {
                   builderResult.hasDtype = false
                   builderResult.dtype = .dtInvalid
                   return self
                }
            public var shape:Tensorflow.TensorShapeProto! {
                get {
                    if shapeBuilder_ != nil {
                        builderResult.shape = shapeBuilder_.getMessage()
                    }
                    return builderResult.shape
                }
                set (value) {
                    builderResult.hasShape = true
                    builderResult.shape = value
                }
            }
            public var hasShape:Bool {
                get {
                    return builderResult.hasShape
                }
            }
            fileprivate var shapeBuilder_:Tensorflow.TensorShapeProto.Builder! {
                didSet {
                    builderResult.hasShape = true
                }
            }
            public func getShapeBuilder() -> Tensorflow.TensorShapeProto.Builder {
                if shapeBuilder_ == nil {
                    shapeBuilder_ = Tensorflow.TensorShapeProto.Builder()
                    builderResult.shape = shapeBuilder_.getMessage()
                    if shape != nil {
                        try! shapeBuilder_.mergeFrom(other: shape)
                    }
                }
                return shapeBuilder_
            }
            @discardableResult
            public func setShape(_ value:Tensorflow.TensorShapeProto!) -> Tensorflow.BundleEntryProto.Builder {
                self.shape = value
                return self
            }
            @discardableResult
            public func mergeShape(value:Tensorflow.TensorShapeProto) throws -> Tensorflow.BundleEntryProto.Builder {
                if builderResult.hasShape {
                    builderResult.shape = try Tensorflow.TensorShapeProto.builderWithPrototype(prototype:builderResult.shape).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.shape = value
                }
                builderResult.hasShape = true
                return self
            }
            @discardableResult
            public func clearShape() -> Tensorflow.BundleEntryProto.Builder {
                shapeBuilder_ = nil
                builderResult.hasShape = false
                builderResult.shape = nil
                return self
            }
            /// The binary content of the tensor lies in:
            ///   File "shard_id": bytes [offset, offset + size).
            public var shardId:Int32 {
                get {
                    return builderResult.shardId
                }
                set (value) {
                    builderResult.hasShardId = true
                    builderResult.shardId = value
                }
            }
            public var hasShardId:Bool {
                get {
                    return builderResult.hasShardId
                }
            }
            @discardableResult
            public func setShardId(_ value:Int32) -> Tensorflow.BundleEntryProto.Builder {
                self.shardId = value
                return self
            }
            @discardableResult
            public func clearShardId() -> Tensorflow.BundleEntryProto.Builder{
                builderResult.hasShardId = false
                builderResult.shardId = Int32(0)
                return self
            }
            public var offset:Int64 {
                get {
                    return builderResult.offset
                }
                set (value) {
                    builderResult.hasOffset = true
                    builderResult.offset = value
                }
            }
            public var hasOffset:Bool {
                get {
                    return builderResult.hasOffset
                }
            }
            @discardableResult
            public func setOffset(_ value:Int64) -> Tensorflow.BundleEntryProto.Builder {
                self.offset = value
                return self
            }
            @discardableResult
            public func clearOffset() -> Tensorflow.BundleEntryProto.Builder{
                builderResult.hasOffset = false
                builderResult.offset = Int64(0)
                return self
            }
            public var size:Int64 {
                get {
                    return builderResult.size
                }
                set (value) {
                    builderResult.hasSize = true
                    builderResult.size = value
                }
            }
            public var hasSize:Bool {
                get {
                    return builderResult.hasSize
                }
            }
            @discardableResult
            public func setSize(_ value:Int64) -> Tensorflow.BundleEntryProto.Builder {
                self.size = value
                return self
            }
            @discardableResult
            public func clearSize() -> Tensorflow.BundleEntryProto.Builder{
                builderResult.hasSize = false
                builderResult.size = Int64(0)
                return self
            }
            /// The CRC32C checksum of the tensor bytes.
            public var crc32C:UInt32 {
                get {
                    return builderResult.crc32C
                }
                set (value) {
                    builderResult.hasCrc32C = true
                    builderResult.crc32C = value
                }
            }
            public var hasCrc32C:Bool {
                get {
                    return builderResult.hasCrc32C
                }
            }
            @discardableResult
            public func setCrc32C(_ value:UInt32) -> Tensorflow.BundleEntryProto.Builder {
                self.crc32C = value
                return self
            }
            @discardableResult
            public func clearCrc32C() -> Tensorflow.BundleEntryProto.Builder{
                builderResult.hasCrc32C = false
                builderResult.crc32C = UInt32(0)
                return self
            }
            /// Iff present, this entry represents a partitioned tensor.  The previous
            /// fields are interpreted as follows:
            ///   "dtype", "shape": describe the full tensor.
            ///   "shard_id", "offset", "size", "crc32c": all IGNORED.
            ///      These information for each slice can be looked up in their own
            ///      BundleEntryProto, keyed by each "slice_name".
            public var slices:Array<Tensorflow.TensorSliceProto> {
                get {
                    return builderResult.slices
                }
                set (value) {
                    builderResult.slices = value
                }
            }
            @discardableResult
            public func setSlices(_ value:Array<Tensorflow.TensorSliceProto>) -> Tensorflow.BundleEntryProto.Builder {
                self.slices = value
                return self
            }
            @discardableResult
            public func clearSlices() -> Tensorflow.BundleEntryProto.Builder {
                builderResult.slices.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.BundleEntryProto.Builder {
                builderResult = Tensorflow.BundleEntryProto()
                return self
            }
            override public func clone() throws -> Tensorflow.BundleEntryProto.Builder {
                return try Tensorflow.BundleEntryProto.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.BundleEntryProto {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.BundleEntryProto {
                let returnMe:Tensorflow.BundleEntryProto = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.BundleEntryProto) throws -> Tensorflow.BundleEntryProto.Builder {
                if other == Tensorflow.BundleEntryProto() {
                    return self
                }
                if other.hasDtype {
                    dtype = other.dtype
                }
                if (other.hasShape) {
                    try mergeShape(value: other.shape)
                }
                if other.hasShardId {
                    shardId = other.shardId
                }
                if other.hasOffset {
                    offset = other.offset
                }
                if other.hasSize {
                    size = other.size
                }
                if other.hasCrc32C {
                    crc32C = other.crc32C
                }
                if !other.slices.isEmpty  {
                     builderResult.slices += other.slices
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BundleEntryProto.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BundleEntryProto.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        let valueIntdtype = try codedInputStream.readEnum()
                        if let enumsdtype = Tensorflow.DataType(rawValue:valueIntdtype){
                            dtype = enumsdtype
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntdtype))
                        }

                    case 18:
                        let subBuilder:Tensorflow.TensorShapeProto.Builder = Tensorflow.TensorShapeProto.Builder()
                        if hasShape {
                            try subBuilder.mergeFrom(other: shape)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        shape = subBuilder.buildPartial()

                    case 24:
                        shardId = try codedInputStream.readInt32()

                    case 32:
                        offset = try codedInputStream.readInt64()

                    case 40:
                        size = try codedInputStream.readInt64()

                    case 53:
                        crc32C = try codedInputStream.readFixed32()

                    case 58:
                        let subBuilder = Tensorflow.TensorSliceProto.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        slices.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.BundleEntryProto.Builder {
                let resultDecodedBuilder = Tensorflow.BundleEntryProto.Builder()
                if let jsonValueDtype = jsonMap["dtype"] as? String {
                    resultDecodedBuilder.dtype = try Tensorflow.DataType.fromString(str: jsonValueDtype)
                }
                if let jsonValueShape = jsonMap["shape"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.shape = try Tensorflow.TensorShapeProto.Builder.decodeToBuilder(jsonMap:jsonValueShape).build()

                }
                if let jsonValueShardId = jsonMap["shardId"] as? Int {
                    resultDecodedBuilder.shardId = Int32(jsonValueShardId)
                } else if let jsonValueShardId = jsonMap["shardId"] as? String {
                    resultDecodedBuilder.shardId = Int32(jsonValueShardId)!
                }
                if let jsonValueOffset = jsonMap["offset"] as? String {
                    resultDecodedBuilder.offset = Int64(jsonValueOffset)!
                } else if let jsonValueOffset = jsonMap["offset"] as? Int {
                    resultDecodedBuilder.offset = Int64(jsonValueOffset)
                }
                if let jsonValueSize = jsonMap["size"] as? String {
                    resultDecodedBuilder.size = Int64(jsonValueSize)!
                } else if let jsonValueSize = jsonMap["size"] as? Int {
                    resultDecodedBuilder.size = Int64(jsonValueSize)
                }
                if let jsonValueCrc32C = jsonMap["crc32c"] as? UInt {
                    resultDecodedBuilder.crc32C = UInt32(jsonValueCrc32C)
                } else if let jsonValueCrc32C = jsonMap["crc32c"] as? String {
                    resultDecodedBuilder.crc32C = UInt32(jsonValueCrc32C)!
                }
                if let jsonValueSlices = jsonMap["slices"] as? Array<Dictionary<String,Any>> {
                    var jsonArraySlices:Array<Tensorflow.TensorSliceProto> = []
                    for oneValueSlices in jsonValueSlices {
                        let messageFromStringSlices = try Tensorflow.TensorSliceProto.Builder.decodeToBuilder(jsonMap:oneValueSlices).build()

                        jsonArraySlices.append(messageFromStringSlices)
                    }
                    resultDecodedBuilder.slices = jsonArraySlices
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.BundleEntryProto.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.BundleEntryProto.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.BundleHeaderProto: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.BundleHeaderProto> {
        var mergedArray = Array<Tensorflow.BundleHeaderProto>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.BundleHeaderProto? {
        return try Tensorflow.BundleHeaderProto.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.BundleHeaderProto {
        return try Tensorflow.BundleHeaderProto.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.TensorBundleRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BundleHeaderProto {
        return try Tensorflow.BundleHeaderProto.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.BundleHeaderProto {
        return try Tensorflow.BundleHeaderProto.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BundleHeaderProto {
        return try Tensorflow.BundleHeaderProto.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BundleHeaderProto {
        return try Tensorflow.BundleHeaderProto.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BundleHeaderProto {
        return try Tensorflow.BundleHeaderProto.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "numShards": return self.numShards
        case "endianness": return self.endianness
        case "version": return self.version
        default: return nil
        }
    }
}
extension Tensorflow.BundleHeaderProto.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "numShards": return self.numShards
            case "endianness": return self.endianness
            case "version": return self.version
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "numShards":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.numShards = newSubscriptValue
            case "endianness":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.BundleHeaderProto.Endianness else {
                    return
                }
                self.endianness = newSubscriptValue
            case "version":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.VersionDef else {
                    return
                }
                self.version = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.BundleEntryProto: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.BundleEntryProto> {
        var mergedArray = Array<Tensorflow.BundleEntryProto>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.BundleEntryProto? {
        return try Tensorflow.BundleEntryProto.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.BundleEntryProto {
        return try Tensorflow.BundleEntryProto.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.TensorBundleRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BundleEntryProto {
        return try Tensorflow.BundleEntryProto.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.BundleEntryProto {
        return try Tensorflow.BundleEntryProto.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BundleEntryProto {
        return try Tensorflow.BundleEntryProto.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.BundleEntryProto {
        return try Tensorflow.BundleEntryProto.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.BundleEntryProto {
        return try Tensorflow.BundleEntryProto.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "dtype": return self.dtype
        case "shape": return self.shape
        case "shardId": return self.shardId
        case "offset": return self.offset
        case "size": return self.size
        case "crc32C": return self.crc32C
        case "slices": return self.slices
        default: return nil
        }
    }
}
extension Tensorflow.BundleEntryProto.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "dtype": return self.dtype
            case "shape": return self.shape
            case "shardId": return self.shardId
            case "offset": return self.offset
            case "size": return self.size
            case "crc32C": return self.crc32C
            case "slices": return self.slices
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "dtype":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.DataType else {
                    return
                }
                self.dtype = newSubscriptValue
            case "shape":
                guard let newSubscriptValue = newSubscriptValue as? Tensorflow.TensorShapeProto else {
                    return
                }
                self.shape = newSubscriptValue
            case "shardId":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.shardId = newSubscriptValue
            case "offset":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.offset = newSubscriptValue
            case "size":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.size = newSubscriptValue
            case "crc32C":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.crc32C = newSubscriptValue
            case "slices":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.TensorSliceProto> else {
                    return
                }
                self.slices = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)

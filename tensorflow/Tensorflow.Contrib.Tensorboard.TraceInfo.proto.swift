/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "trace_info.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Tensorflow { public struct Contrib { public struct Tensorboard { }}}

public extension Tensorflow.Contrib.Tensorboard {
    public struct TraceInfoRoot {
        public static let `default` = TraceInfoRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    final public class TraceInfo : GeneratedMessage {

        public static func == (lhs: Tensorflow.Contrib.Tensorboard.TraceInfo, rhs: Tensorflow.Contrib.Tensorboard.TraceInfo) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.ops == rhs.ops)
            fieldCheck = fieldCheck && (lhs.files == rhs.files)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var ops:Array<Tensorflow.Contrib.Tensorboard.OpInfo>  = Array<Tensorflow.Contrib.Tensorboard.OpInfo>()
        public fileprivate(set) var files:Array<Tensorflow.Contrib.Tensorboard.FileInfo>  = Array<Tensorflow.Contrib.Tensorboard.FileInfo>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementOps in ops {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementOps)
            }
            for oneElementFiles in files {
                  try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementFiles)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementOps in ops {
                serialize_size += oneElementOps.computeMessageSize(fieldNumber: 1)
            }
            for oneElementFiles in files {
                serialize_size += oneElementFiles.computeMessageSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.Contrib.Tensorboard.TraceInfo.Builder {
            return Tensorflow.Contrib.Tensorboard.TraceInfo.classBuilder() as! Tensorflow.Contrib.Tensorboard.TraceInfo.Builder
        }
        public func getBuilder() -> Tensorflow.Contrib.Tensorboard.TraceInfo.Builder {
            return classBuilder() as! Tensorflow.Contrib.Tensorboard.TraceInfo.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Contrib.Tensorboard.TraceInfo.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Contrib.Tensorboard.TraceInfo.Builder()
        }
        public func toBuilder() throws -> Tensorflow.Contrib.Tensorboard.TraceInfo.Builder {
            return try Tensorflow.Contrib.Tensorboard.TraceInfo.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.Contrib.Tensorboard.TraceInfo) throws -> Tensorflow.Contrib.Tensorboard.TraceInfo.Builder {
            return try Tensorflow.Contrib.Tensorboard.TraceInfo.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !ops.isEmpty {
                var jsonArrayOps:Array<Dictionary<String,Any>> = []
                for oneValueOps in ops {
                    let ecodedMessageOps = try oneValueOps.encode()
                    jsonArrayOps.append(ecodedMessageOps)
                }
                jsonMap["ops"] = jsonArrayOps
            }
            if !files.isEmpty {
                var jsonArrayFiles:Array<Dictionary<String,Any>> = []
                for oneValueFiles in files {
                    let ecodedMessageFiles = try oneValueFiles.encode()
                    jsonArrayFiles.append(ecodedMessageFiles)
                }
                jsonMap["files"] = jsonArrayFiles
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Contrib.Tensorboard.TraceInfo {
            return try Tensorflow.Contrib.Tensorboard.TraceInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.Contrib.Tensorboard.TraceInfo {
            return try Tensorflow.Contrib.Tensorboard.TraceInfo.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var opsElementIndex:Int = 0
            for oneElementOps in ops {
                output += "\(indent) ops[\(opsElementIndex)] {\n"
                output += try oneElementOps.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                opsElementIndex += 1
            }
            var filesElementIndex:Int = 0
            for oneElementFiles in files {
                output += "\(indent) files[\(filesElementIndex)] {\n"
                output += try oneElementFiles.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                filesElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementOps in ops {
                    hashCode = (hashCode &* 31) &+ oneElementOps.hashValue
                }
                for oneElementFiles in files {
                    hashCode = (hashCode &* 31) &+ oneElementFiles.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.Contrib.Tensorboard.TraceInfo"
        }
        override public func className() -> String {
            return "Tensorflow.Contrib.Tensorboard.TraceInfo"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.Contrib.Tensorboard.TraceInfo = Tensorflow.Contrib.Tensorboard.TraceInfo()
            public func getMessage() -> Tensorflow.Contrib.Tensorboard.TraceInfo {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var ops:Array<Tensorflow.Contrib.Tensorboard.OpInfo> {
                get {
                    return builderResult.ops
                }
                set (value) {
                    builderResult.ops = value
                }
            }
            @discardableResult
            public func setOps(_ value:Array<Tensorflow.Contrib.Tensorboard.OpInfo>) -> Tensorflow.Contrib.Tensorboard.TraceInfo.Builder {
                self.ops = value
                return self
            }
            @discardableResult
            public func clearOps() -> Tensorflow.Contrib.Tensorboard.TraceInfo.Builder {
                builderResult.ops.removeAll(keepingCapacity: false)
                return self
            }
            public var files:Array<Tensorflow.Contrib.Tensorboard.FileInfo> {
                get {
                    return builderResult.files
                }
                set (value) {
                    builderResult.files = value
                }
            }
            @discardableResult
            public func setFiles(_ value:Array<Tensorflow.Contrib.Tensorboard.FileInfo>) -> Tensorflow.Contrib.Tensorboard.TraceInfo.Builder {
                self.files = value
                return self
            }
            @discardableResult
            public func clearFiles() -> Tensorflow.Contrib.Tensorboard.TraceInfo.Builder {
                builderResult.files.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.Contrib.Tensorboard.TraceInfo.Builder {
                builderResult = Tensorflow.Contrib.Tensorboard.TraceInfo()
                return self
            }
            override public func clone() throws -> Tensorflow.Contrib.Tensorboard.TraceInfo.Builder {
                return try Tensorflow.Contrib.Tensorboard.TraceInfo.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.Contrib.Tensorboard.TraceInfo {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.Contrib.Tensorboard.TraceInfo {
                let returnMe:Tensorflow.Contrib.Tensorboard.TraceInfo = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.Contrib.Tensorboard.TraceInfo) throws -> Tensorflow.Contrib.Tensorboard.TraceInfo.Builder {
                if other == Tensorflow.Contrib.Tensorboard.TraceInfo() {
                    return self
                }
                if !other.ops.isEmpty  {
                     builderResult.ops += other.ops
                }
                if !other.files.isEmpty  {
                     builderResult.files += other.files
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Contrib.Tensorboard.TraceInfo.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Contrib.Tensorboard.TraceInfo.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Tensorflow.Contrib.Tensorboard.OpInfo.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        ops.append(subBuilder.buildPartial())

                    case 18:
                        let subBuilder = Tensorflow.Contrib.Tensorboard.FileInfo.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        files.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Contrib.Tensorboard.TraceInfo.Builder {
                let resultDecodedBuilder = Tensorflow.Contrib.Tensorboard.TraceInfo.Builder()
                if let jsonValueOps = jsonMap["ops"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayOps:Array<Tensorflow.Contrib.Tensorboard.OpInfo> = []
                    for oneValueOps in jsonValueOps {
                        let messageFromStringOps = try Tensorflow.Contrib.Tensorboard.OpInfo.Builder.decodeToBuilder(jsonMap:oneValueOps).build()

                        jsonArrayOps.append(messageFromStringOps)
                    }
                    resultDecodedBuilder.ops = jsonArrayOps
                }
                if let jsonValueFiles = jsonMap["files"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayFiles:Array<Tensorflow.Contrib.Tensorboard.FileInfo> = []
                    for oneValueFiles in jsonValueFiles {
                        let messageFromStringFiles = try Tensorflow.Contrib.Tensorboard.FileInfo.Builder.decodeToBuilder(jsonMap:oneValueFiles).build()

                        jsonArrayFiles.append(messageFromStringFiles)
                    }
                    resultDecodedBuilder.files = jsonArrayFiles
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Contrib.Tensorboard.TraceInfo.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.Contrib.Tensorboard.TraceInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class OpInfo : GeneratedMessage {

        public static func == (lhs: Tensorflow.Contrib.Tensorboard.OpInfo, rhs: Tensorflow.Contrib.Tensorboard.OpInfo) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
            fieldCheck = fieldCheck && (lhs.hasOpType == rhs.hasOpType) && (!lhs.hasOpType || lhs.opType == rhs.opType)
            fieldCheck = fieldCheck && (lhs.hasDevice == rhs.hasDevice) && (!lhs.hasDevice || lhs.device == rhs.device)
            fieldCheck = fieldCheck && (lhs.traceback == rhs.traceback)
            fieldCheck = fieldCheck && (lhs.inputs == rhs.inputs)
            fieldCheck = fieldCheck && (lhs.outputs == rhs.outputs)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var name:String = ""
        public fileprivate(set) var hasName:Bool = false

        public fileprivate(set) var opType:String = ""
        public fileprivate(set) var hasOpType:Bool = false

        public fileprivate(set) var device:String = ""
        public fileprivate(set) var hasDevice:Bool = false

        public fileprivate(set) var traceback:Array<Tensorflow.Contrib.Tensorboard.LineTrace>  = Array<Tensorflow.Contrib.Tensorboard.LineTrace>()
        public fileprivate(set) var inputs:Array<Tensorflow.Contrib.Tensorboard.TensorInfo>  = Array<Tensorflow.Contrib.Tensorboard.TensorInfo>()
        public fileprivate(set) var outputs:Array<Tensorflow.Contrib.Tensorboard.TensorInfo>  = Array<Tensorflow.Contrib.Tensorboard.TensorInfo>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasName {
                try codedOutputStream.writeString(fieldNumber: 1, value:name)
            }
            if hasOpType {
                try codedOutputStream.writeString(fieldNumber: 2, value:opType)
            }
            if hasDevice {
                try codedOutputStream.writeString(fieldNumber: 3, value:device)
            }
            for oneElementTraceback in traceback {
                  try codedOutputStream.writeMessage(fieldNumber: 4, value:oneElementTraceback)
            }
            for oneElementInputs in inputs {
                  try codedOutputStream.writeMessage(fieldNumber: 5, value:oneElementInputs)
            }
            for oneElementOutputs in outputs {
                  try codedOutputStream.writeMessage(fieldNumber: 6, value:oneElementOutputs)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasName {
                serialize_size += name.computeStringSize(fieldNumber: 1)
            }
            if hasOpType {
                serialize_size += opType.computeStringSize(fieldNumber: 2)
            }
            if hasDevice {
                serialize_size += device.computeStringSize(fieldNumber: 3)
            }
            for oneElementTraceback in traceback {
                serialize_size += oneElementTraceback.computeMessageSize(fieldNumber: 4)
            }
            for oneElementInputs in inputs {
                serialize_size += oneElementInputs.computeMessageSize(fieldNumber: 5)
            }
            for oneElementOutputs in outputs {
                serialize_size += oneElementOutputs.computeMessageSize(fieldNumber: 6)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.Contrib.Tensorboard.OpInfo.Builder {
            return Tensorflow.Contrib.Tensorboard.OpInfo.classBuilder() as! Tensorflow.Contrib.Tensorboard.OpInfo.Builder
        }
        public func getBuilder() -> Tensorflow.Contrib.Tensorboard.OpInfo.Builder {
            return classBuilder() as! Tensorflow.Contrib.Tensorboard.OpInfo.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Contrib.Tensorboard.OpInfo.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Contrib.Tensorboard.OpInfo.Builder()
        }
        public func toBuilder() throws -> Tensorflow.Contrib.Tensorboard.OpInfo.Builder {
            return try Tensorflow.Contrib.Tensorboard.OpInfo.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.Contrib.Tensorboard.OpInfo) throws -> Tensorflow.Contrib.Tensorboard.OpInfo.Builder {
            return try Tensorflow.Contrib.Tensorboard.OpInfo.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasName {
                jsonMap["name"] = name
            }
            if hasOpType {
                jsonMap["opType"] = opType
            }
            if hasDevice {
                jsonMap["device"] = device
            }
            if !traceback.isEmpty {
                var jsonArrayTraceback:Array<Dictionary<String,Any>> = []
                for oneValueTraceback in traceback {
                    let ecodedMessageTraceback = try oneValueTraceback.encode()
                    jsonArrayTraceback.append(ecodedMessageTraceback)
                }
                jsonMap["traceback"] = jsonArrayTraceback
            }
            if !inputs.isEmpty {
                var jsonArrayInputs:Array<Dictionary<String,Any>> = []
                for oneValueInputs in inputs {
                    let ecodedMessageInputs = try oneValueInputs.encode()
                    jsonArrayInputs.append(ecodedMessageInputs)
                }
                jsonMap["inputs"] = jsonArrayInputs
            }
            if !outputs.isEmpty {
                var jsonArrayOutputs:Array<Dictionary<String,Any>> = []
                for oneValueOutputs in outputs {
                    let ecodedMessageOutputs = try oneValueOutputs.encode()
                    jsonArrayOutputs.append(ecodedMessageOutputs)
                }
                jsonMap["outputs"] = jsonArrayOutputs
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Contrib.Tensorboard.OpInfo {
            return try Tensorflow.Contrib.Tensorboard.OpInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.Contrib.Tensorboard.OpInfo {
            return try Tensorflow.Contrib.Tensorboard.OpInfo.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasName {
                output += "\(indent) name: \(name) \n"
            }
            if hasOpType {
                output += "\(indent) opType: \(opType) \n"
            }
            if hasDevice {
                output += "\(indent) device: \(device) \n"
            }
            var tracebackElementIndex:Int = 0
            for oneElementTraceback in traceback {
                output += "\(indent) traceback[\(tracebackElementIndex)] {\n"
                output += try oneElementTraceback.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                tracebackElementIndex += 1
            }
            var inputsElementIndex:Int = 0
            for oneElementInputs in inputs {
                output += "\(indent) inputs[\(inputsElementIndex)] {\n"
                output += try oneElementInputs.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                inputsElementIndex += 1
            }
            var outputsElementIndex:Int = 0
            for oneElementOutputs in outputs {
                output += "\(indent) outputs[\(outputsElementIndex)] {\n"
                output += try oneElementOutputs.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                outputsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasName {
                    hashCode = (hashCode &* 31) &+ name.hashValue
                }
                if hasOpType {
                    hashCode = (hashCode &* 31) &+ opType.hashValue
                }
                if hasDevice {
                    hashCode = (hashCode &* 31) &+ device.hashValue
                }
                for oneElementTraceback in traceback {
                    hashCode = (hashCode &* 31) &+ oneElementTraceback.hashValue
                }
                for oneElementInputs in inputs {
                    hashCode = (hashCode &* 31) &+ oneElementInputs.hashValue
                }
                for oneElementOutputs in outputs {
                    hashCode = (hashCode &* 31) &+ oneElementOutputs.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.Contrib.Tensorboard.OpInfo"
        }
        override public func className() -> String {
            return "Tensorflow.Contrib.Tensorboard.OpInfo"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.Contrib.Tensorboard.OpInfo = Tensorflow.Contrib.Tensorboard.OpInfo()
            public func getMessage() -> Tensorflow.Contrib.Tensorboard.OpInfo {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var name:String {
                get {
                    return builderResult.name
                }
                set (value) {
                    builderResult.hasName = true
                    builderResult.name = value
                }
            }
            public var hasName:Bool {
                get {
                    return builderResult.hasName
                }
            }
            @discardableResult
            public func setName(_ value:String) -> Tensorflow.Contrib.Tensorboard.OpInfo.Builder {
                self.name = value
                return self
            }
            @discardableResult
            public func clearName() -> Tensorflow.Contrib.Tensorboard.OpInfo.Builder{
                builderResult.hasName = false
                builderResult.name = ""
                return self
            }
            public var opType:String {
                get {
                    return builderResult.opType
                }
                set (value) {
                    builderResult.hasOpType = true
                    builderResult.opType = value
                }
            }
            public var hasOpType:Bool {
                get {
                    return builderResult.hasOpType
                }
            }
            @discardableResult
            public func setOpType(_ value:String) -> Tensorflow.Contrib.Tensorboard.OpInfo.Builder {
                self.opType = value
                return self
            }
            @discardableResult
            public func clearOpType() -> Tensorflow.Contrib.Tensorboard.OpInfo.Builder{
                builderResult.hasOpType = false
                builderResult.opType = ""
                return self
            }
            public var device:String {
                get {
                    return builderResult.device
                }
                set (value) {
                    builderResult.hasDevice = true
                    builderResult.device = value
                }
            }
            public var hasDevice:Bool {
                get {
                    return builderResult.hasDevice
                }
            }
            @discardableResult
            public func setDevice(_ value:String) -> Tensorflow.Contrib.Tensorboard.OpInfo.Builder {
                self.device = value
                return self
            }
            @discardableResult
            public func clearDevice() -> Tensorflow.Contrib.Tensorboard.OpInfo.Builder{
                builderResult.hasDevice = false
                builderResult.device = ""
                return self
            }
            public var traceback:Array<Tensorflow.Contrib.Tensorboard.LineTrace> {
                get {
                    return builderResult.traceback
                }
                set (value) {
                    builderResult.traceback = value
                }
            }
            @discardableResult
            public func setTraceback(_ value:Array<Tensorflow.Contrib.Tensorboard.LineTrace>) -> Tensorflow.Contrib.Tensorboard.OpInfo.Builder {
                self.traceback = value
                return self
            }
            @discardableResult
            public func clearTraceback() -> Tensorflow.Contrib.Tensorboard.OpInfo.Builder {
                builderResult.traceback.removeAll(keepingCapacity: false)
                return self
            }
            public var inputs:Array<Tensorflow.Contrib.Tensorboard.TensorInfo> {
                get {
                    return builderResult.inputs
                }
                set (value) {
                    builderResult.inputs = value
                }
            }
            @discardableResult
            public func setInputs(_ value:Array<Tensorflow.Contrib.Tensorboard.TensorInfo>) -> Tensorflow.Contrib.Tensorboard.OpInfo.Builder {
                self.inputs = value
                return self
            }
            @discardableResult
            public func clearInputs() -> Tensorflow.Contrib.Tensorboard.OpInfo.Builder {
                builderResult.inputs.removeAll(keepingCapacity: false)
                return self
            }
            public var outputs:Array<Tensorflow.Contrib.Tensorboard.TensorInfo> {
                get {
                    return builderResult.outputs
                }
                set (value) {
                    builderResult.outputs = value
                }
            }
            @discardableResult
            public func setOutputs(_ value:Array<Tensorflow.Contrib.Tensorboard.TensorInfo>) -> Tensorflow.Contrib.Tensorboard.OpInfo.Builder {
                self.outputs = value
                return self
            }
            @discardableResult
            public func clearOutputs() -> Tensorflow.Contrib.Tensorboard.OpInfo.Builder {
                builderResult.outputs.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.Contrib.Tensorboard.OpInfo.Builder {
                builderResult = Tensorflow.Contrib.Tensorboard.OpInfo()
                return self
            }
            override public func clone() throws -> Tensorflow.Contrib.Tensorboard.OpInfo.Builder {
                return try Tensorflow.Contrib.Tensorboard.OpInfo.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.Contrib.Tensorboard.OpInfo {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.Contrib.Tensorboard.OpInfo {
                let returnMe:Tensorflow.Contrib.Tensorboard.OpInfo = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.Contrib.Tensorboard.OpInfo) throws -> Tensorflow.Contrib.Tensorboard.OpInfo.Builder {
                if other == Tensorflow.Contrib.Tensorboard.OpInfo() {
                    return self
                }
                if other.hasName {
                    name = other.name
                }
                if other.hasOpType {
                    opType = other.opType
                }
                if other.hasDevice {
                    device = other.device
                }
                if !other.traceback.isEmpty  {
                     builderResult.traceback += other.traceback
                }
                if !other.inputs.isEmpty  {
                     builderResult.inputs += other.inputs
                }
                if !other.outputs.isEmpty  {
                     builderResult.outputs += other.outputs
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Contrib.Tensorboard.OpInfo.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Contrib.Tensorboard.OpInfo.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        name = try codedInputStream.readString()

                    case 18:
                        opType = try codedInputStream.readString()

                    case 26:
                        device = try codedInputStream.readString()

                    case 34:
                        let subBuilder = Tensorflow.Contrib.Tensorboard.LineTrace.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        traceback.append(subBuilder.buildPartial())

                    case 42:
                        let subBuilder = Tensorflow.Contrib.Tensorboard.TensorInfo.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        inputs.append(subBuilder.buildPartial())

                    case 50:
                        let subBuilder = Tensorflow.Contrib.Tensorboard.TensorInfo.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        outputs.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Contrib.Tensorboard.OpInfo.Builder {
                let resultDecodedBuilder = Tensorflow.Contrib.Tensorboard.OpInfo.Builder()
                if let jsonValueName = jsonMap["name"] as? String {
                    resultDecodedBuilder.name = jsonValueName
                }
                if let jsonValueOpType = jsonMap["opType"] as? String {
                    resultDecodedBuilder.opType = jsonValueOpType
                }
                if let jsonValueDevice = jsonMap["device"] as? String {
                    resultDecodedBuilder.device = jsonValueDevice
                }
                if let jsonValueTraceback = jsonMap["traceback"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayTraceback:Array<Tensorflow.Contrib.Tensorboard.LineTrace> = []
                    for oneValueTraceback in jsonValueTraceback {
                        let messageFromStringTraceback = try Tensorflow.Contrib.Tensorboard.LineTrace.Builder.decodeToBuilder(jsonMap:oneValueTraceback).build()

                        jsonArrayTraceback.append(messageFromStringTraceback)
                    }
                    resultDecodedBuilder.traceback = jsonArrayTraceback
                }
                if let jsonValueInputs = jsonMap["inputs"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayInputs:Array<Tensorflow.Contrib.Tensorboard.TensorInfo> = []
                    for oneValueInputs in jsonValueInputs {
                        let messageFromStringInputs = try Tensorflow.Contrib.Tensorboard.TensorInfo.Builder.decodeToBuilder(jsonMap:oneValueInputs).build()

                        jsonArrayInputs.append(messageFromStringInputs)
                    }
                    resultDecodedBuilder.inputs = jsonArrayInputs
                }
                if let jsonValueOutputs = jsonMap["outputs"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayOutputs:Array<Tensorflow.Contrib.Tensorboard.TensorInfo> = []
                    for oneValueOutputs in jsonValueOutputs {
                        let messageFromStringOutputs = try Tensorflow.Contrib.Tensorboard.TensorInfo.Builder.decodeToBuilder(jsonMap:oneValueOutputs).build()

                        jsonArrayOutputs.append(messageFromStringOutputs)
                    }
                    resultDecodedBuilder.outputs = jsonArrayOutputs
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Contrib.Tensorboard.OpInfo.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.Contrib.Tensorboard.OpInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class LineTrace : GeneratedMessage {

        public static func == (lhs: Tensorflow.Contrib.Tensorboard.LineTrace, rhs: Tensorflow.Contrib.Tensorboard.LineTrace) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasFilePath == rhs.hasFilePath) && (!lhs.hasFilePath || lhs.filePath == rhs.filePath)
            fieldCheck = fieldCheck && (lhs.hasLineNumber == rhs.hasLineNumber) && (!lhs.hasLineNumber || lhs.lineNumber == rhs.lineNumber)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Absolute file path.
        public fileprivate(set) var filePath:String = ""
        public fileprivate(set) var hasFilePath:Bool = false

        /// 1-based line number.
        public fileprivate(set) var lineNumber:UInt32 = UInt32(0)
        public fileprivate(set) var hasLineNumber:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasFilePath {
                try codedOutputStream.writeString(fieldNumber: 1, value:filePath)
            }
            if hasLineNumber {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:lineNumber)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasFilePath {
                serialize_size += filePath.computeStringSize(fieldNumber: 1)
            }
            if hasLineNumber {
                serialize_size += lineNumber.computeUInt32Size(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.Contrib.Tensorboard.LineTrace.Builder {
            return Tensorflow.Contrib.Tensorboard.LineTrace.classBuilder() as! Tensorflow.Contrib.Tensorboard.LineTrace.Builder
        }
        public func getBuilder() -> Tensorflow.Contrib.Tensorboard.LineTrace.Builder {
            return classBuilder() as! Tensorflow.Contrib.Tensorboard.LineTrace.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Contrib.Tensorboard.LineTrace.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Contrib.Tensorboard.LineTrace.Builder()
        }
        public func toBuilder() throws -> Tensorflow.Contrib.Tensorboard.LineTrace.Builder {
            return try Tensorflow.Contrib.Tensorboard.LineTrace.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.Contrib.Tensorboard.LineTrace) throws -> Tensorflow.Contrib.Tensorboard.LineTrace.Builder {
            return try Tensorflow.Contrib.Tensorboard.LineTrace.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasFilePath {
                jsonMap["filePath"] = filePath
            }
            if hasLineNumber {
                jsonMap["lineNumber"] = UInt(lineNumber)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Contrib.Tensorboard.LineTrace {
            return try Tensorflow.Contrib.Tensorboard.LineTrace.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.Contrib.Tensorboard.LineTrace {
            return try Tensorflow.Contrib.Tensorboard.LineTrace.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasFilePath {
                output += "\(indent) filePath: \(filePath) \n"
            }
            if hasLineNumber {
                output += "\(indent) lineNumber: \(lineNumber) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasFilePath {
                    hashCode = (hashCode &* 31) &+ filePath.hashValue
                }
                if hasLineNumber {
                    hashCode = (hashCode &* 31) &+ lineNumber.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.Contrib.Tensorboard.LineTrace"
        }
        override public func className() -> String {
            return "Tensorflow.Contrib.Tensorboard.LineTrace"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.Contrib.Tensorboard.LineTrace = Tensorflow.Contrib.Tensorboard.LineTrace()
            public func getMessage() -> Tensorflow.Contrib.Tensorboard.LineTrace {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Absolute file path.
            public var filePath:String {
                get {
                    return builderResult.filePath
                }
                set (value) {
                    builderResult.hasFilePath = true
                    builderResult.filePath = value
                }
            }
            public var hasFilePath:Bool {
                get {
                    return builderResult.hasFilePath
                }
            }
            @discardableResult
            public func setFilePath(_ value:String) -> Tensorflow.Contrib.Tensorboard.LineTrace.Builder {
                self.filePath = value
                return self
            }
            @discardableResult
            public func clearFilePath() -> Tensorflow.Contrib.Tensorboard.LineTrace.Builder{
                builderResult.hasFilePath = false
                builderResult.filePath = ""
                return self
            }
            /// 1-based line number.
            public var lineNumber:UInt32 {
                get {
                    return builderResult.lineNumber
                }
                set (value) {
                    builderResult.hasLineNumber = true
                    builderResult.lineNumber = value
                }
            }
            public var hasLineNumber:Bool {
                get {
                    return builderResult.hasLineNumber
                }
            }
            @discardableResult
            public func setLineNumber(_ value:UInt32) -> Tensorflow.Contrib.Tensorboard.LineTrace.Builder {
                self.lineNumber = value
                return self
            }
            @discardableResult
            public func clearLineNumber() -> Tensorflow.Contrib.Tensorboard.LineTrace.Builder{
                builderResult.hasLineNumber = false
                builderResult.lineNumber = UInt32(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.Contrib.Tensorboard.LineTrace.Builder {
                builderResult = Tensorflow.Contrib.Tensorboard.LineTrace()
                return self
            }
            override public func clone() throws -> Tensorflow.Contrib.Tensorboard.LineTrace.Builder {
                return try Tensorflow.Contrib.Tensorboard.LineTrace.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.Contrib.Tensorboard.LineTrace {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.Contrib.Tensorboard.LineTrace {
                let returnMe:Tensorflow.Contrib.Tensorboard.LineTrace = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.Contrib.Tensorboard.LineTrace) throws -> Tensorflow.Contrib.Tensorboard.LineTrace.Builder {
                if other == Tensorflow.Contrib.Tensorboard.LineTrace() {
                    return self
                }
                if other.hasFilePath {
                    filePath = other.filePath
                }
                if other.hasLineNumber {
                    lineNumber = other.lineNumber
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Contrib.Tensorboard.LineTrace.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Contrib.Tensorboard.LineTrace.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        filePath = try codedInputStream.readString()

                    case 16:
                        lineNumber = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Contrib.Tensorboard.LineTrace.Builder {
                let resultDecodedBuilder = Tensorflow.Contrib.Tensorboard.LineTrace.Builder()
                if let jsonValueFilePath = jsonMap["filePath"] as? String {
                    resultDecodedBuilder.filePath = jsonValueFilePath
                }
                if let jsonValueLineNumber = jsonMap["lineNumber"] as? UInt {
                    resultDecodedBuilder.lineNumber = UInt32(jsonValueLineNumber)
                } else if let jsonValueLineNumber = jsonMap["lineNumber"] as? String {
                    resultDecodedBuilder.lineNumber = UInt32(jsonValueLineNumber)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Contrib.Tensorboard.LineTrace.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.Contrib.Tensorboard.LineTrace.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class TensorInfo : GeneratedMessage {

        public static func == (lhs: Tensorflow.Contrib.Tensorboard.TensorInfo, rhs: Tensorflow.Contrib.Tensorboard.TensorInfo) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.shape == rhs.shape)
            fieldCheck = fieldCheck && (lhs.hasDtype == rhs.hasDtype) && (!lhs.hasDtype || lhs.dtype == rhs.dtype)
            fieldCheck = fieldCheck && (lhs.hasNumBytesPerElem == rhs.hasNumBytesPerElem) && (!lhs.hasNumBytesPerElem || lhs.numBytesPerElem == rhs.numBytesPerElem)
            fieldCheck = fieldCheck && (lhs.consumers == rhs.consumers)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Size of the tensor for each dimension. Value of -1 denotes "unknown"
        /// size for that dimension.
        public fileprivate(set) var shape:Array<Int32> = Array<Int32>()
        private var shapeMemoizedSerializedSize:Int32 = -1
        /// The data type of the tensor.
        public fileprivate(set) var dtype:String = ""
        public fileprivate(set) var hasDtype:Bool = false

        /// Number of bytes per element in the tensor.
        public fileprivate(set) var numBytesPerElem:UInt32 = UInt32(0)
        public fileprivate(set) var hasNumBytesPerElem:Bool = false

        /// List of operation names that consume this tensor.
        public fileprivate(set) var consumers:Array<String> = Array<String>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if !shape.isEmpty {
                try codedOutputStream.writeRawVarint32(value: 10)
                try codedOutputStream.writeRawVarint32(value: shapeMemoizedSerializedSize)
                for oneValueshape in shape {
                    try codedOutputStream.writeInt32NoTag(value: oneValueshape)
                }
            }
            if hasDtype {
                try codedOutputStream.writeString(fieldNumber: 2, value:dtype)
            }
            if hasNumBytesPerElem {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:numBytesPerElem)
            }
            if !consumers.isEmpty {
                for oneValueconsumers in consumers {
                    try codedOutputStream.writeString(fieldNumber: 4, value:oneValueconsumers)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            var dataSizeShape:Int32 = 0
            for oneValueshape in shape {
                dataSizeShape += oneValueshape.computeInt32SizeNoTag()
            }
            serialize_size += dataSizeShape
            if !shape.isEmpty {
                serialize_size += 1
                serialize_size += dataSizeShape.computeInt32SizeNoTag()
            }
            shapeMemoizedSerializedSize = dataSizeShape
            if hasDtype {
                serialize_size += dtype.computeStringSize(fieldNumber: 2)
            }
            if hasNumBytesPerElem {
                serialize_size += numBytesPerElem.computeUInt32Size(fieldNumber: 3)
            }
            var dataSizeConsumers:Int32 = 0
            for oneValueconsumers in consumers {
                dataSizeConsumers += oneValueconsumers.computeStringSizeNoTag()
            }
            serialize_size += dataSizeConsumers
            serialize_size += 1 * Int32(consumers.count)
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.Contrib.Tensorboard.TensorInfo.Builder {
            return Tensorflow.Contrib.Tensorboard.TensorInfo.classBuilder() as! Tensorflow.Contrib.Tensorboard.TensorInfo.Builder
        }
        public func getBuilder() -> Tensorflow.Contrib.Tensorboard.TensorInfo.Builder {
            return classBuilder() as! Tensorflow.Contrib.Tensorboard.TensorInfo.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Contrib.Tensorboard.TensorInfo.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Contrib.Tensorboard.TensorInfo.Builder()
        }
        public func toBuilder() throws -> Tensorflow.Contrib.Tensorboard.TensorInfo.Builder {
            return try Tensorflow.Contrib.Tensorboard.TensorInfo.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.Contrib.Tensorboard.TensorInfo) throws -> Tensorflow.Contrib.Tensorboard.TensorInfo.Builder {
            return try Tensorflow.Contrib.Tensorboard.TensorInfo.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !shape.isEmpty {
                var jsonArrayShape:Array<Int> = []
                for oneValueShape in shape {
                    jsonArrayShape.append(Int(oneValueShape))
                }
                jsonMap["shape"] = jsonArrayShape
            }
            if hasDtype {
                jsonMap["dtype"] = dtype
            }
            if hasNumBytesPerElem {
                jsonMap["numBytesPerElem"] = UInt(numBytesPerElem)
            }
            if !consumers.isEmpty {
                var jsonArrayConsumers:Array<String> = []
                for oneValueConsumers in consumers {
                    jsonArrayConsumers.append(oneValueConsumers)
                }
                jsonMap["consumers"] = jsonArrayConsumers
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Contrib.Tensorboard.TensorInfo {
            return try Tensorflow.Contrib.Tensorboard.TensorInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.Contrib.Tensorboard.TensorInfo {
            return try Tensorflow.Contrib.Tensorboard.TensorInfo.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var shapeElementIndex:Int = 0
            for oneValueShape in shape  {
                output += "\(indent) shape[\(shapeElementIndex)]: \(oneValueShape)\n"
                shapeElementIndex += 1
            }
            if hasDtype {
                output += "\(indent) dtype: \(dtype) \n"
            }
            if hasNumBytesPerElem {
                output += "\(indent) numBytesPerElem: \(numBytesPerElem) \n"
            }
            var consumersElementIndex:Int = 0
            for oneValueConsumers in consumers  {
                output += "\(indent) consumers[\(consumersElementIndex)]: \(oneValueConsumers)\n"
                consumersElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneValueShape in shape {
                    hashCode = (hashCode &* 31) &+ oneValueShape.hashValue
                }
                if hasDtype {
                    hashCode = (hashCode &* 31) &+ dtype.hashValue
                }
                if hasNumBytesPerElem {
                    hashCode = (hashCode &* 31) &+ numBytesPerElem.hashValue
                }
                for oneValueConsumers in consumers {
                    hashCode = (hashCode &* 31) &+ oneValueConsumers.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.Contrib.Tensorboard.TensorInfo"
        }
        override public func className() -> String {
            return "Tensorflow.Contrib.Tensorboard.TensorInfo"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.Contrib.Tensorboard.TensorInfo = Tensorflow.Contrib.Tensorboard.TensorInfo()
            public func getMessage() -> Tensorflow.Contrib.Tensorboard.TensorInfo {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Size of the tensor for each dimension. Value of -1 denotes "unknown"
            /// size for that dimension.
            public var shape:Array<Int32> {
                get {
                    return builderResult.shape
                }
                set (array) {
                    builderResult.shape = array
                }
            }
            @discardableResult
            public func setShape(_ value:Array<Int32>) -> Tensorflow.Contrib.Tensorboard.TensorInfo.Builder {
                self.shape = value
                return self
            }
            @discardableResult
            public func clearShape() -> Tensorflow.Contrib.Tensorboard.TensorInfo.Builder {
                builderResult.shape.removeAll(keepingCapacity: false)
                return self
            }
            /// The data type of the tensor.
            public var dtype:String {
                get {
                    return builderResult.dtype
                }
                set (value) {
                    builderResult.hasDtype = true
                    builderResult.dtype = value
                }
            }
            public var hasDtype:Bool {
                get {
                    return builderResult.hasDtype
                }
            }
            @discardableResult
            public func setDtype(_ value:String) -> Tensorflow.Contrib.Tensorboard.TensorInfo.Builder {
                self.dtype = value
                return self
            }
            @discardableResult
            public func clearDtype() -> Tensorflow.Contrib.Tensorboard.TensorInfo.Builder{
                builderResult.hasDtype = false
                builderResult.dtype = ""
                return self
            }
            /// Number of bytes per element in the tensor.
            public var numBytesPerElem:UInt32 {
                get {
                    return builderResult.numBytesPerElem
                }
                set (value) {
                    builderResult.hasNumBytesPerElem = true
                    builderResult.numBytesPerElem = value
                }
            }
            public var hasNumBytesPerElem:Bool {
                get {
                    return builderResult.hasNumBytesPerElem
                }
            }
            @discardableResult
            public func setNumBytesPerElem(_ value:UInt32) -> Tensorflow.Contrib.Tensorboard.TensorInfo.Builder {
                self.numBytesPerElem = value
                return self
            }
            @discardableResult
            public func clearNumBytesPerElem() -> Tensorflow.Contrib.Tensorboard.TensorInfo.Builder{
                builderResult.hasNumBytesPerElem = false
                builderResult.numBytesPerElem = UInt32(0)
                return self
            }
            /// List of operation names that consume this tensor.
            public var consumers:Array<String> {
                get {
                    return builderResult.consumers
                }
                set (array) {
                    builderResult.consumers = array
                }
            }
            @discardableResult
            public func setConsumers(_ value:Array<String>) -> Tensorflow.Contrib.Tensorboard.TensorInfo.Builder {
                self.consumers = value
                return self
            }
            @discardableResult
            public func clearConsumers() -> Tensorflow.Contrib.Tensorboard.TensorInfo.Builder {
                builderResult.consumers.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.Contrib.Tensorboard.TensorInfo.Builder {
                builderResult = Tensorflow.Contrib.Tensorboard.TensorInfo()
                return self
            }
            override public func clone() throws -> Tensorflow.Contrib.Tensorboard.TensorInfo.Builder {
                return try Tensorflow.Contrib.Tensorboard.TensorInfo.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.Contrib.Tensorboard.TensorInfo {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.Contrib.Tensorboard.TensorInfo {
                let returnMe:Tensorflow.Contrib.Tensorboard.TensorInfo = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.Contrib.Tensorboard.TensorInfo) throws -> Tensorflow.Contrib.Tensorboard.TensorInfo.Builder {
                if other == Tensorflow.Contrib.Tensorboard.TensorInfo() {
                    return self
                }
                if !other.shape.isEmpty {
                    builderResult.shape += other.shape
                }
                if other.hasDtype {
                    dtype = other.dtype
                }
                if other.hasNumBytesPerElem {
                    numBytesPerElem = other.numBytesPerElem
                }
                if !other.consumers.isEmpty {
                    builderResult.consumers += other.consumers
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Contrib.Tensorboard.TensorInfo.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Contrib.Tensorboard.TensorInfo.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let length = Int(try codedInputStream.readRawVarint32())
                        let limit = try codedInputStream.pushLimit(byteLimit: length)
                        while (codedInputStream.bytesUntilLimit() > 0) {
                            builderResult.shape.append(try codedInputStream.readInt32())
                        }
                        codedInputStream.popLimit(oldLimit: limit)

                    case 18:
                        dtype = try codedInputStream.readString()

                    case 24:
                        numBytesPerElem = try codedInputStream.readUInt32()

                    case 34:
                        consumers += [try codedInputStream.readString()]

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Contrib.Tensorboard.TensorInfo.Builder {
                let resultDecodedBuilder = Tensorflow.Contrib.Tensorboard.TensorInfo.Builder()
                if let jsonValueShape = jsonMap["shape"] as? Array<Int> {
                    var jsonArrayShape:Array<Int32> = []
                    for oneValueShape in jsonValueShape {
                        jsonArrayShape.append(Int32(oneValueShape))
                    }
                    resultDecodedBuilder.shape = jsonArrayShape
                }
                if let jsonValueDtype = jsonMap["dtype"] as? String {
                    resultDecodedBuilder.dtype = jsonValueDtype
                }
                if let jsonValueNumBytesPerElem = jsonMap["numBytesPerElem"] as? UInt {
                    resultDecodedBuilder.numBytesPerElem = UInt32(jsonValueNumBytesPerElem)
                } else if let jsonValueNumBytesPerElem = jsonMap["numBytesPerElem"] as? String {
                    resultDecodedBuilder.numBytesPerElem = UInt32(jsonValueNumBytesPerElem)!
                }
                if let jsonValueConsumers = jsonMap["consumers"] as? Array<String> {
                    var jsonArrayConsumers:Array<String> = []
                    for oneValueConsumers in jsonValueConsumers {
                        jsonArrayConsumers.append(oneValueConsumers)
                    }
                    resultDecodedBuilder.consumers = jsonArrayConsumers
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Contrib.Tensorboard.TensorInfo.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.Contrib.Tensorboard.TensorInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class FileInfo : GeneratedMessage {

        public static func == (lhs: Tensorflow.Contrib.Tensorboard.FileInfo, rhs: Tensorflow.Contrib.Tensorboard.FileInfo) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasFilePath == rhs.hasFilePath) && (!lhs.hasFilePath || lhs.filePath == rhs.filePath)
            fieldCheck = fieldCheck && (lhs.hasSourceCode == rhs.hasSourceCode) && (!lhs.hasSourceCode || lhs.sourceCode == rhs.sourceCode)
            fieldCheck = fieldCheck && (lhs.hasMultilineStatements == rhs.hasMultilineStatements) && (!lhs.hasMultilineStatements || lhs.multilineStatements == rhs.multilineStatements)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        final public class MultilineStatementsEntry : GeneratedMessage {

            public static func == (lhs: Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry, rhs: Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:UInt32 = UInt32(0)
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:UInt32 = UInt32(0)
            public fileprivate(set) var hasValue:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeUInt32(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeUInt32(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeUInt32Size(fieldNumber: 1)
                }
                if hasValue {
                    serialize_size += value.computeUInt32Size(fieldNumber: 2)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder {
                return Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.classBuilder() as! Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder
            }
            public func getBuilder() -> Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder {
                return classBuilder() as! Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder()
            }
            public func toBuilder() throws -> Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder {
                return try Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry) throws -> Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder {
                return try Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = UInt(key)
                }
                if hasValue {
                    jsonMap["value"] = UInt(value)
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry {
                return try Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry {
                return try Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value: \(value) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        hashCode = (hashCode &* 31) &+ value.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry"
            }
            override public func className() -> String {
                return "Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry = Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry()
                public func getMessage() -> Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:UInt32 {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:UInt32) -> Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = UInt32(0)
                    return self
                }
                public var value:UInt32 {
                    get {
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                @discardableResult
                public func setValue(_ value:UInt32) -> Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func clearValue() -> Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder{
                    builderResult.hasValue = false
                    builderResult.value = UInt32(0)
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder {
                    builderResult = Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry()
                    return self
                }
                override public func clone() throws -> Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder {
                    return try Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry {
                    let returnMe:Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry) throws -> Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder {
                    if other == Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if other.hasValue {
                        value = other.value
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 8:
                            key = try codedInputStream.readUInt32()

                        case 16:
                            value = try codedInputStream.readUInt32()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder {
                    let resultDecodedBuilder = Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? UInt {
                        resultDecodedBuilder.key = UInt32(jsonValueKey)
                    } else if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = UInt32(jsonValueKey)!
                    }
                    if let jsonValueValue = jsonMap["value"] as? UInt {
                        resultDecodedBuilder.value = UInt32(jsonValueValue)
                    } else if let jsonValueValue = jsonMap["value"] as? String {
                        resultDecodedBuilder.value = UInt32(jsonValueValue)!
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        /// Absolute file path to the source code.
        public fileprivate(set) var filePath:String = ""
        public fileprivate(set) var hasFilePath:Bool = false

        public fileprivate(set) var sourceCode:String = ""
        public fileprivate(set) var hasSourceCode:Bool = false

        /// Map from end of statement to start of statement. End and start are 0-based
        /// line indexes.
        public fileprivate(set) var multilineStatements:Dictionary<UInt32,UInt32> = Dictionary<UInt32,UInt32>()

        public fileprivate(set) var hasMultilineStatements:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasFilePath {
                try codedOutputStream.writeString(fieldNumber: 1, value:filePath)
            }
            if hasSourceCode {
                try codedOutputStream.writeString(fieldNumber: 2, value:sourceCode)
            }
            if hasMultilineStatements {
                for (keyMultilineStatements, valueMultilineStatements) in multilineStatements {
                    let valueOfMultilineStatements = try! Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder().setKey(keyMultilineStatements).setValue(valueMultilineStatements).build()
                      try codedOutputStream.writeMessage(fieldNumber: 3, value:valueOfMultilineStatements)
                  }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasFilePath {
                serialize_size += filePath.computeStringSize(fieldNumber: 1)
            }
            if hasSourceCode {
                serialize_size += sourceCode.computeStringSize(fieldNumber: 2)
            }
            if hasMultilineStatements {
                  for (keyMultilineStatements, valueMultilineStatements) in multilineStatements {
                      let valueOfMultilineStatements = try! Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder().setKey(keyMultilineStatements).setValue(valueMultilineStatements).build()
                serialize_size += valueOfMultilineStatements.computeMessageSize(fieldNumber: 3)
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Tensorflow.Contrib.Tensorboard.FileInfo.Builder {
            return Tensorflow.Contrib.Tensorboard.FileInfo.classBuilder() as! Tensorflow.Contrib.Tensorboard.FileInfo.Builder
        }
        public func getBuilder() -> Tensorflow.Contrib.Tensorboard.FileInfo.Builder {
            return classBuilder() as! Tensorflow.Contrib.Tensorboard.FileInfo.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Contrib.Tensorboard.FileInfo.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Tensorflow.Contrib.Tensorboard.FileInfo.Builder()
        }
        public func toBuilder() throws -> Tensorflow.Contrib.Tensorboard.FileInfo.Builder {
            return try Tensorflow.Contrib.Tensorboard.FileInfo.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Tensorflow.Contrib.Tensorboard.FileInfo) throws -> Tensorflow.Contrib.Tensorboard.FileInfo.Builder {
            return try Tensorflow.Contrib.Tensorboard.FileInfo.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasFilePath {
                jsonMap["filePath"] = filePath
            }
            if hasSourceCode {
                jsonMap["sourceCode"] = sourceCode
            }
            if hasMultilineStatements {
                var mapMultilineStatements = Dictionary<String, UInt>()
                for (keyMultilineStatements, valueMultilineStatements) in multilineStatements {
                    mapMultilineStatements["\(keyMultilineStatements)"] = UInt(valueMultilineStatements)
                }
                jsonMap["multilineStatements"] = mapMultilineStatements
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Contrib.Tensorboard.FileInfo {
            return try Tensorflow.Contrib.Tensorboard.FileInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Tensorflow.Contrib.Tensorboard.FileInfo {
            return try Tensorflow.Contrib.Tensorboard.FileInfo.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasFilePath {
                output += "\(indent) filePath: \(filePath) \n"
            }
            if hasSourceCode {
                output += "\(indent) sourceCode: \(sourceCode) \n"
            }
            if hasMultilineStatements {
                output += "\(indent) multilineStatements: \(multilineStatements) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasFilePath {
                    hashCode = (hashCode &* 31) &+ filePath.hashValue
                }
                if hasSourceCode {
                    hashCode = (hashCode &* 31) &+ sourceCode.hashValue
                }
                if hasMultilineStatements {
                    for (keyMultilineStatements, valueMultilineStatements) in multilineStatements {
                        hashCode = (hashCode &* 31) &+ keyMultilineStatements.hashValue
                        hashCode = (hashCode &* 31) &+ valueMultilineStatements.hashValue
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Tensorflow.Contrib.Tensorboard.FileInfo"
        }
        override public func className() -> String {
            return "Tensorflow.Contrib.Tensorboard.FileInfo"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Tensorflow.Contrib.Tensorboard.FileInfo = Tensorflow.Contrib.Tensorboard.FileInfo()
            public func getMessage() -> Tensorflow.Contrib.Tensorboard.FileInfo {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Absolute file path to the source code.
            public var filePath:String {
                get {
                    return builderResult.filePath
                }
                set (value) {
                    builderResult.hasFilePath = true
                    builderResult.filePath = value
                }
            }
            public var hasFilePath:Bool {
                get {
                    return builderResult.hasFilePath
                }
            }
            @discardableResult
            public func setFilePath(_ value:String) -> Tensorflow.Contrib.Tensorboard.FileInfo.Builder {
                self.filePath = value
                return self
            }
            @discardableResult
            public func clearFilePath() -> Tensorflow.Contrib.Tensorboard.FileInfo.Builder{
                builderResult.hasFilePath = false
                builderResult.filePath = ""
                return self
            }
            public var sourceCode:String {
                get {
                    return builderResult.sourceCode
                }
                set (value) {
                    builderResult.hasSourceCode = true
                    builderResult.sourceCode = value
                }
            }
            public var hasSourceCode:Bool {
                get {
                    return builderResult.hasSourceCode
                }
            }
            @discardableResult
            public func setSourceCode(_ value:String) -> Tensorflow.Contrib.Tensorboard.FileInfo.Builder {
                self.sourceCode = value
                return self
            }
            @discardableResult
            public func clearSourceCode() -> Tensorflow.Contrib.Tensorboard.FileInfo.Builder{
                builderResult.hasSourceCode = false
                builderResult.sourceCode = ""
                return self
            }
            /// Map from end of statement to start of statement. End and start are 0-based
            /// line indexes.
            public var hasMultilineStatements:Bool {
                get {
                    return builderResult.hasMultilineStatements
                }
            }
            public var multilineStatements:Dictionary<UInt32,UInt32> {
                get {
                    return builderResult.multilineStatements
                }
                set (value) {
                    builderResult.hasMultilineStatements = true
                    builderResult.multilineStatements = value
                }
            }
            @discardableResult
            public func setMultilineStatements(_ value:Dictionary<UInt32,UInt32>) -> Tensorflow.Contrib.Tensorboard.FileInfo.Builder {
                self.multilineStatements = value
                return self
            }
            @discardableResult
            public func clearMultilineStatements() -> Tensorflow.Contrib.Tensorboard.FileInfo.Builder{
                builderResult.hasMultilineStatements = false
                builderResult.multilineStatements = Dictionary<UInt32,UInt32>()
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Tensorflow.Contrib.Tensorboard.FileInfo.Builder {
                builderResult = Tensorflow.Contrib.Tensorboard.FileInfo()
                return self
            }
            override public func clone() throws -> Tensorflow.Contrib.Tensorboard.FileInfo.Builder {
                return try Tensorflow.Contrib.Tensorboard.FileInfo.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Tensorflow.Contrib.Tensorboard.FileInfo {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Tensorflow.Contrib.Tensorboard.FileInfo {
                let returnMe:Tensorflow.Contrib.Tensorboard.FileInfo = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Tensorflow.Contrib.Tensorboard.FileInfo) throws -> Tensorflow.Contrib.Tensorboard.FileInfo.Builder {
                if other == Tensorflow.Contrib.Tensorboard.FileInfo() {
                    return self
                }
                if other.hasFilePath {
                    filePath = other.filePath
                }
                if other.hasSourceCode {
                    sourceCode = other.sourceCode
                }
                if other.hasMultilineStatements {
                    multilineStatements = other.multilineStatements
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Contrib.Tensorboard.FileInfo.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Contrib.Tensorboard.FileInfo.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        filePath = try codedInputStream.readString()

                    case 18:
                        sourceCode = try codedInputStream.readString()

                    case 26:
                        let subBuilder = Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfMultilineStatements = subBuilder.buildPartial()
                        multilineStatements[buildOfMultilineStatements.key] = buildOfMultilineStatements.value

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Tensorflow.Contrib.Tensorboard.FileInfo.Builder {
                let resultDecodedBuilder = Tensorflow.Contrib.Tensorboard.FileInfo.Builder()
                if let jsonValueFilePath = jsonMap["filePath"] as? String {
                    resultDecodedBuilder.filePath = jsonValueFilePath
                }
                if let jsonValueSourceCode = jsonMap["sourceCode"] as? String {
                    resultDecodedBuilder.sourceCode = jsonValueSourceCode
                }
                if let jsonValueMultilineStatements = jsonMap["multilineStatements"] as? Dictionary<String, UInt> {
                    var mapMultilineStatements = Dictionary<UInt32, UInt32>()
                    for (keyMultilineStatements, valueMultilineStatements) in jsonValueMultilineStatements {
                        guard let keyFromMultilineStatements = UInt32(keyMultilineStatements) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapMultilineStatements[keyFromMultilineStatements] = UInt32(valueMultilineStatements)
                    }
                    resultDecodedBuilder.multilineStatements = mapMultilineStatements
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Tensorflow.Contrib.Tensorboard.FileInfo.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Tensorflow.Contrib.Tensorboard.FileInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Tensorflow.Contrib.Tensorboard.TraceInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Contrib.Tensorboard.TraceInfo> {
        var mergedArray = Array<Tensorflow.Contrib.Tensorboard.TraceInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Contrib.Tensorboard.TraceInfo? {
        return try Tensorflow.Contrib.Tensorboard.TraceInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Contrib.Tensorboard.TraceInfo {
        return try Tensorflow.Contrib.Tensorboard.TraceInfo.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.Contrib.Tensorboard.TraceInfoRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Contrib.Tensorboard.TraceInfo {
        return try Tensorflow.Contrib.Tensorboard.TraceInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Contrib.Tensorboard.TraceInfo {
        return try Tensorflow.Contrib.Tensorboard.TraceInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Contrib.Tensorboard.TraceInfo {
        return try Tensorflow.Contrib.Tensorboard.TraceInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Contrib.Tensorboard.TraceInfo {
        return try Tensorflow.Contrib.Tensorboard.TraceInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Contrib.Tensorboard.TraceInfo {
        return try Tensorflow.Contrib.Tensorboard.TraceInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "ops": return self.ops
        case "files": return self.files
        default: return nil
        }
    }
}
extension Tensorflow.Contrib.Tensorboard.TraceInfo.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "ops": return self.ops
            case "files": return self.files
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "ops":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.Contrib.Tensorboard.OpInfo> else {
                    return
                }
                self.ops = newSubscriptValue
            case "files":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.Contrib.Tensorboard.FileInfo> else {
                    return
                }
                self.files = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Contrib.Tensorboard.OpInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Contrib.Tensorboard.OpInfo> {
        var mergedArray = Array<Tensorflow.Contrib.Tensorboard.OpInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Contrib.Tensorboard.OpInfo? {
        return try Tensorflow.Contrib.Tensorboard.OpInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Contrib.Tensorboard.OpInfo {
        return try Tensorflow.Contrib.Tensorboard.OpInfo.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.Contrib.Tensorboard.TraceInfoRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Contrib.Tensorboard.OpInfo {
        return try Tensorflow.Contrib.Tensorboard.OpInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Contrib.Tensorboard.OpInfo {
        return try Tensorflow.Contrib.Tensorboard.OpInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Contrib.Tensorboard.OpInfo {
        return try Tensorflow.Contrib.Tensorboard.OpInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Contrib.Tensorboard.OpInfo {
        return try Tensorflow.Contrib.Tensorboard.OpInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Contrib.Tensorboard.OpInfo {
        return try Tensorflow.Contrib.Tensorboard.OpInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "name": return self.name
        case "opType": return self.opType
        case "device": return self.device
        case "traceback": return self.traceback
        case "inputs": return self.inputs
        case "outputs": return self.outputs
        default: return nil
        }
    }
}
extension Tensorflow.Contrib.Tensorboard.OpInfo.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "name": return self.name
            case "opType": return self.opType
            case "device": return self.device
            case "traceback": return self.traceback
            case "inputs": return self.inputs
            case "outputs": return self.outputs
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "opType":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.opType = newSubscriptValue
            case "device":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.device = newSubscriptValue
            case "traceback":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.Contrib.Tensorboard.LineTrace> else {
                    return
                }
                self.traceback = newSubscriptValue
            case "inputs":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.Contrib.Tensorboard.TensorInfo> else {
                    return
                }
                self.inputs = newSubscriptValue
            case "outputs":
                guard let newSubscriptValue = newSubscriptValue as? Array<Tensorflow.Contrib.Tensorboard.TensorInfo> else {
                    return
                }
                self.outputs = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Contrib.Tensorboard.LineTrace: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Contrib.Tensorboard.LineTrace> {
        var mergedArray = Array<Tensorflow.Contrib.Tensorboard.LineTrace>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Contrib.Tensorboard.LineTrace? {
        return try Tensorflow.Contrib.Tensorboard.LineTrace.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Contrib.Tensorboard.LineTrace {
        return try Tensorflow.Contrib.Tensorboard.LineTrace.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.Contrib.Tensorboard.TraceInfoRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Contrib.Tensorboard.LineTrace {
        return try Tensorflow.Contrib.Tensorboard.LineTrace.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Contrib.Tensorboard.LineTrace {
        return try Tensorflow.Contrib.Tensorboard.LineTrace.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Contrib.Tensorboard.LineTrace {
        return try Tensorflow.Contrib.Tensorboard.LineTrace.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Contrib.Tensorboard.LineTrace {
        return try Tensorflow.Contrib.Tensorboard.LineTrace.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Contrib.Tensorboard.LineTrace {
        return try Tensorflow.Contrib.Tensorboard.LineTrace.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "filePath": return self.filePath
        case "lineNumber": return self.lineNumber
        default: return nil
        }
    }
}
extension Tensorflow.Contrib.Tensorboard.LineTrace.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "filePath": return self.filePath
            case "lineNumber": return self.lineNumber
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "filePath":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.filePath = newSubscriptValue
            case "lineNumber":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.lineNumber = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Contrib.Tensorboard.TensorInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Contrib.Tensorboard.TensorInfo> {
        var mergedArray = Array<Tensorflow.Contrib.Tensorboard.TensorInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Contrib.Tensorboard.TensorInfo? {
        return try Tensorflow.Contrib.Tensorboard.TensorInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Contrib.Tensorboard.TensorInfo {
        return try Tensorflow.Contrib.Tensorboard.TensorInfo.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.Contrib.Tensorboard.TraceInfoRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Contrib.Tensorboard.TensorInfo {
        return try Tensorflow.Contrib.Tensorboard.TensorInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Contrib.Tensorboard.TensorInfo {
        return try Tensorflow.Contrib.Tensorboard.TensorInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Contrib.Tensorboard.TensorInfo {
        return try Tensorflow.Contrib.Tensorboard.TensorInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Contrib.Tensorboard.TensorInfo {
        return try Tensorflow.Contrib.Tensorboard.TensorInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Contrib.Tensorboard.TensorInfo {
        return try Tensorflow.Contrib.Tensorboard.TensorInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "shape": return self.shape
        case "dtype": return self.dtype
        case "numBytesPerElem": return self.numBytesPerElem
        case "consumers": return self.consumers
        default: return nil
        }
    }
}
extension Tensorflow.Contrib.Tensorboard.TensorInfo.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "shape": return self.shape
            case "dtype": return self.dtype
            case "numBytesPerElem": return self.numBytesPerElem
            case "consumers": return self.consumers
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "shape":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int32> else {
                    return
                }
                self.shape = newSubscriptValue
            case "dtype":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.dtype = newSubscriptValue
            case "numBytesPerElem":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.numBytesPerElem = newSubscriptValue
            case "consumers":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.consumers = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Contrib.Tensorboard.FileInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Contrib.Tensorboard.FileInfo> {
        var mergedArray = Array<Tensorflow.Contrib.Tensorboard.FileInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Contrib.Tensorboard.FileInfo? {
        return try Tensorflow.Contrib.Tensorboard.FileInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Contrib.Tensorboard.FileInfo {
        return try Tensorflow.Contrib.Tensorboard.FileInfo.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.Contrib.Tensorboard.TraceInfoRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Contrib.Tensorboard.FileInfo {
        return try Tensorflow.Contrib.Tensorboard.FileInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Contrib.Tensorboard.FileInfo {
        return try Tensorflow.Contrib.Tensorboard.FileInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Contrib.Tensorboard.FileInfo {
        return try Tensorflow.Contrib.Tensorboard.FileInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Contrib.Tensorboard.FileInfo {
        return try Tensorflow.Contrib.Tensorboard.FileInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Contrib.Tensorboard.FileInfo {
        return try Tensorflow.Contrib.Tensorboard.FileInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "filePath": return self.filePath
        case "sourceCode": return self.sourceCode
        case "multilineStatements": return self.multilineStatements
        default: return nil
        }
    }
}
extension Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry> {
        var mergedArray = Array<Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry? {
        return try Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry {
        return try Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder().mergeFrom(data: data, extensionRegistry:Tensorflow.Contrib.Tensorboard.TraceInfoRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry {
        return try Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry {
        return try Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry {
        return try Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry {
        return try Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry {
        return try Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Tensorflow.Contrib.Tensorboard.FileInfo.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "filePath": return self.filePath
            case "sourceCode": return self.sourceCode
            case "multilineStatements": return self.multilineStatements
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "filePath":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.filePath = newSubscriptValue
            case "sourceCode":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.sourceCode = newSubscriptValue
            case "multilineStatements":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<UInt32,UInt32> else {
                    return
                }
                self.multilineStatements = newSubscriptValue
            default: return
            }
        }
    }
}
extension Tensorflow.Contrib.Tensorboard.FileInfo.MultilineStatementsEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
